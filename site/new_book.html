<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Lukasz Stafiniak" />
  <title>Curious OCaml</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Curious OCaml</h1>
<p class="author">Lukasz Stafiniak</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#curious-ocaml" id="toc-curious-ocaml">Curious OCaml</a>
<ul>
<li><a href="#chapter-1-logic" id="toc-chapter-1-logic">Chapter 1:
Logic</a>
<ul>
<li><a href="#in-the-beginning-there-was-logos"
id="toc-in-the-beginning-there-was-logos">1.1 In the Beginning there was
Logos</a></li>
<li><a href="#rules-for-logical-connectives"
id="toc-rules-for-logical-connectives">1.2 Rules for Logical
Connectives</a></li>
<li><a href="#logos-was-programmed-in-ocaml"
id="toc-logos-was-programmed-in-ocaml">1.3 Logos was Programmed in
OCaml</a></li>
<li><a href="#exercises" id="toc-exercises">1.4 Exercises</a></li>
</ul></li>
<li><a href="#chapter-2-algebra" id="toc-chapter-2-algebra">Chapter 2:
Algebra</a>
<ul>
<li><a href="#a-glimpse-at-type-inference"
id="toc-a-glimpse-at-type-inference">2.1 A Glimpse at Type
Inference</a></li>
<li><a href="#algebraic-data-types" id="toc-algebraic-data-types">2.2
Algebraic Data Types</a></li>
<li><a href="#syntactic-conventions" id="toc-syntactic-conventions">2.3
Syntactic Conventions</a></li>
<li><a href="#pattern-matching" id="toc-pattern-matching">2.4 Pattern
Matching</a></li>
<li><a href="#interpreting-algebraic-data-types-as-polynomials"
id="toc-interpreting-algebraic-data-types-as-polynomials">2.5
Interpreting Algebraic Data Types as Polynomials</a></li>
<li><a href="#differentiating-algebraic-data-types"
id="toc-differentiating-algebraic-data-types">2.6 Differentiating
Algebraic Data Types</a></li>
<li><a href="#exercises-1" id="toc-exercises-1">2.7 Exercises</a></li>
</ul></li>
<li><a href="#chapter-3-computation"
id="toc-chapter-3-computation">Chapter 3: Computation</a>
<ul>
<li><a href="#function-composition" id="toc-function-composition">3.1
Function Composition</a></li>
<li><a href="#evaluation-rules-reduction-semantics"
id="toc-evaluation-rules-reduction-semantics">3.2 Evaluation Rules
(Reduction Semantics)</a></li>
<li><a href="#symbolic-derivation-example"
id="toc-symbolic-derivation-example">3.3 Symbolic Derivation
Example</a></li>
<li><a href="#tail-calls-and-tail-recursion"
id="toc-tail-calls-and-tail-recursion">3.4 Tail Calls and Tail
Recursion</a></li>
<li><a href="#first-encounter-of-continuation-passing-style"
id="toc-first-encounter-of-continuation-passing-style">3.5 First
Encounter of Continuation Passing Style</a></li>
<li><a href="#exercises-2" id="toc-exercises-2">3.6 Exercises</a></li>
</ul></li>
<li><a href="#chapter-4-functions" id="toc-chapter-4-functions">Chapter
4: Functions</a>
<ul>
<li><a href="#review-computation-by-hand"
id="toc-review-computation-by-hand">4.1 Review: Computation by
Hand</a></li>
<li><a href="#language-and-rules-of-the-untyped-lambda-calculus"
id="toc-language-and-rules-of-the-untyped-lambda-calculus">4.2 Language
and Rules of the Untyped Lambda-Calculus</a></li>
<li><a href="#booleans" id="toc-booleans">4.3 Booleans</a></li>
<li><a href="#if-then-else-and-pairs"
id="toc-if-then-else-and-pairs">4.4 If-then-else and Pairs</a></li>
<li><a href="#pair-encoded-natural-numbers"
id="toc-pair-encoded-natural-numbers">4.5 Pair-Encoded Natural
Numbers</a></li>
<li><a href="#church-numerals" id="toc-church-numerals">4.6 Church
Numerals</a></li>
<li><a href="#recursion-fixpoint-combinators"
id="toc-recursion-fixpoint-combinators">4.7 Recursion: Fixpoint
Combinators</a></li>
<li><a href="#encoding-lists-and-trees"
id="toc-encoding-lists-and-trees">4.8 Encoding Lists and Trees</a></li>
<li><a href="#looping-recursion" id="toc-looping-recursion">4.9 Looping
Recursion</a></li>
<li><a href="#exercises-3" id="toc-exercises-3">4.10 Exercises</a></li>
</ul></li>
<li><a href="#chapter-5-polymorphism-and-abstract-data-types"
id="toc-chapter-5-polymorphism-and-abstract-data-types">Chapter 5:
Polymorphism and Abstract Data Types</a>
<ul>
<li><a href="#type-inference" id="toc-type-inference">5.1 Type
Inference</a></li>
<li><a href="#parametric-types" id="toc-parametric-types">5.2 Parametric
Types</a></li>
<li><a href="#type-inference-formally"
id="toc-type-inference-formally">5.3 Type Inference, Formally</a></li>
<li><a href="#algebraic-specification"
id="toc-algebraic-specification">5.4 Algebraic Specification</a></li>
<li><a href="#homomorphisms" id="toc-homomorphisms">5.5
Homomorphisms</a></li>
<li><a href="#example-maps" id="toc-example-maps">5.6 Example:
Maps</a></li>
<li><a href="#modules-and-interfaces-signatures-syntax"
id="toc-modules-and-interfaces-signatures-syntax">5.7 Modules and
Interfaces (Signatures): Syntax</a></li>
<li><a href="#implementing-maps-association-lists"
id="toc-implementing-maps-association-lists">5.8 Implementing Maps:
Association Lists</a></li>
<li><a href="#implementing-maps-binary-search-trees"
id="toc-implementing-maps-binary-search-trees">5.9 Implementing Maps:
Binary Search Trees</a></li>
<li><a href="#implementing-maps-red-black-trees"
id="toc-implementing-maps-red-black-trees">5.10 Implementing Maps:
Red-Black Trees</a></li>
<li><a href="#exercises-4" id="toc-exercises-4">Exercises</a></li>
</ul></li>
<li><a href="#chapter-6-folding-and-backtracking"
id="toc-chapter-6-folding-and-backtracking">Chapter 6: Folding and
Backtracking</a>
<ul>
<li><a href="#basic-generic-list-operations"
id="toc-basic-generic-list-operations">6.1 Basic Generic List
Operations</a></li>
<li><a href="#making-fold-tail-recursive"
id="toc-making-fold-tail-recursive">6.2 Making Fold
Tail-Recursive</a></li>
<li><a href="#map-and-fold-for-trees-and-other-structures"
id="toc-map-and-fold-for-trees-and-other-structures">6.3 Map and Fold
for Trees and Other Structures</a></li>
<li><a href="#point-free-programming"
id="toc-point-free-programming">6.4 Point-Free Programming</a></li>
<li><a href="#reductions-and-more-higher-order-functions"
id="toc-reductions-and-more-higher-order-functions">6.5 Reductions and
More Higher-Order Functions</a></li>
<li><a href="#grouping-and-map-reduce"
id="toc-grouping-and-map-reduce">6.6 Grouping and Map-Reduce</a></li>
<li><a href="#higher-order-functions-for-the-option-type"
id="toc-higher-order-functions-for-the-option-type">6.7 Higher-Order
Functions for the Option Type</a></li>
<li><a href="#the-countdown-problem-puzzle"
id="toc-the-countdown-problem-puzzle">6.8 The Countdown Problem
Puzzle</a></li>
<li><a href="#the-honey-islands-puzzle"
id="toc-the-honey-islands-puzzle">6.9 The Honey Islands Puzzle</a></li>
<li><a href="#constraint-based-puzzles"
id="toc-constraint-based-puzzles">6.10 Constraint-Based Puzzles</a></li>
<li><a href="#exercises-5" id="toc-exercises-5">6.11 Exercises</a></li>
</ul></li>
<li><a href="#chapter-7-laziness" id="toc-chapter-7-laziness">Chapter 7:
Laziness</a>
<ul>
<li><a href="#evaluation-strategies-and-parameter-passing"
id="toc-evaluation-strategies-and-parameter-passing">7.1 Evaluation
Strategies and Parameter Passing</a></li>
<li><a href="#call-by-name-streams" id="toc-call-by-name-streams">7.2
Call-by-name: Streams</a></li>
<li><a href="#lazy-values" id="toc-lazy-values">7.3 Lazy Values</a></li>
<li><a href="#power-series-and-differential-equations"
id="toc-power-series-and-differential-equations">7.4 Power Series and
Differential Equations</a></li>
<li><a href="#arbitrary-precision-computation"
id="toc-arbitrary-precision-computation">7.5 Arbitrary Precision
Computation</a></li>
<li><a href="#circular-data-structures-double-linked-lists"
id="toc-circular-data-structures-double-linked-lists">7.6 Circular Data
Structures: Double-Linked Lists</a></li>
<li><a href="#input-output-streams" id="toc-input-output-streams">7.7
Input-Output Streams</a></li>
<li><a href="#pipes" id="toc-pipes">7.8 Pipes</a></li>
<li><a href="#example-pretty-printing"
id="toc-example-pretty-printing">7.9 Example: Pretty-Printing</a></li>
</ul></li>
</ul></li>
<li><a href="#let-print_endline-pretty-30-test_doc"
id="toc-let-print_endline-pretty-30-test_doc">let () = print_endline
(pretty 30 test_doc);;</a></li>
<li><a href="#let-print_endline-pretty-20-test_doc"
id="toc-let-print_endline-pretty-20-test_doc">let () = print_endline
(pretty 20 test_doc);;</a></li>
<li><a href="#let-print_endline-pretty-60-test_doc"
id="toc-let-print_endline-pretty-60-test_doc">let () = print_endline
(pretty 60 test_doc);;</a>
<ul>
<li><a href="#chapter-8-monads" id="toc-chapter-8-monads">Chapter 8:
Monads</a>
<ul>
<li><a href="#list-comprehensions" id="toc-list-comprehensions">8.1 List
Comprehensions</a></li>
<li><a href="#generalized-comprehensions-binding-operators"
id="toc-generalized-comprehensions-binding-operators">8.2 Generalized
Comprehensions: Binding Operators</a></li>
<li><a href="#monads" id="toc-monads">8.3 Monads</a></li>
<li><a href="#monad-laws" id="toc-monad-laws">8.4 Monad Laws</a></li>
<li><a href="#monoid-laws-and-monad-plus"
id="toc-monoid-laws-and-monad-plus">8.5 Monoid Laws and
Monad-Plus</a></li>
<li><a href="#backtracking-computation-with-choice"
id="toc-backtracking-computation-with-choice">8.6 Backtracking:
Computation with Choice</a></li>
<li><a href="#the-two-metaphors" id="toc-the-two-metaphors">8.9 The Two
Metaphors</a></li>
<li><a href="#monad-classes-and-instances"
id="toc-monad-classes-and-instances">8.10 Monad Classes and
Instances</a></li>
<li><a href="#monad-instances" id="toc-monad-instances">8.11 Monad
Instances</a></li>
<li><a href="#exercises-6" id="toc-exercises-6">8.15 Exercises</a></li>
</ul></li>
<li><a href="#chapter-9-algebraic-effects"
id="toc-chapter-9-algebraic-effects">Chapter 9: Algebraic
Effects</a></li>
<li><a href="#chapter-10-functional-reactive-programming"
id="toc-chapter-10-functional-reactive-programming">Chapter 10:
Functional Reactive Programming</a>
<ul>
<li><a href="#zippers" id="toc-zippers">10.1 Zippers</a></li>
<li><a href="#adaptive-programming-incremental-computing"
id="toc-adaptive-programming-incremental-computing">10.3 Adaptive
Programming (Incremental Computing)</a></li>
<li><a href="#reactivity-by-incremental-computing"
id="toc-reactivity-by-incremental-computing">10.6 Reactivity by
Incremental Computing</a></li>
<li><a href="#lightweight-fp-non-solution-extensible-variant-types"
id="toc-lightweight-fp-non-solution-extensible-variant-types">11.3
Lightweight FP Non-Solution: Extensible Variant Types</a></li>
<li><a href="#polymorphic-variants" id="toc-polymorphic-variants">11.7
Polymorphic Variants</a></li>
<li><a href="#parser-combinators" id="toc-parser-combinators">11.9
Parser Combinators</a></li>
<li><a href="#parser-combinators-implementation"
id="toc-parser-combinators-implementation">11.10 Parser Combinators:
Implementation</a></li>
<li><a href="#parser-combinators-dynamic-code-loading"
id="toc-parser-combinators-dynamic-code-loading">11.12 Parser
Combinators: Dynamic Code Loading</a></li>
<li><a href="#exercises-7" id="toc-exercises-7">11.14 Exercises</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<!-- Do NOT modify this file, it is automatically generated -->
<h1 id="curious-ocaml">Curious OCaml</h1>
<h2 id="chapter-1-logic">Chapter 1: Logic</h2>
<p><em>From logic rules to programming constructs</em></p>
<h3 id="in-the-beginning-there-was-logos">1.1 In the Beginning there was
Logos</h3>
<p>What logical connectives do you know?</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th><span class="math inline">\top</span></th>
<th><span class="math inline">\bot</span></th>
<th><span class="math inline">\wedge</span></th>
<th><span class="math inline">\vee</span></th>
<th><span class="math inline">\rightarrow</span></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td><span class="math inline">a \wedge b</span></td>
<td><span class="math inline">a \vee b</span></td>
<td><span class="math inline">a \rightarrow b</span></td>
</tr>
<tr>
<td>truth</td>
<td>falsehood</td>
<td>conjunction</td>
<td>disjunction</td>
<td>implication</td>
</tr>
<tr>
<td>“trivial”</td>
<td>“impossible”</td>
<td><span class="math inline">a</span> and <span
class="math inline">b</span></td>
<td><span class="math inline">a</span> or <span
class="math inline">b</span></td>
<td><span class="math inline">a</span> gives <span
class="math inline">b</span></td>
</tr>
<tr>
<td></td>
<td>shouldn’t get</td>
<td>got both</td>
<td>got at least one</td>
<td>given <span class="math inline">a</span>, we get <span
class="math inline">b</span></td>
</tr>
</tbody>
</table>
<p>How can we define them? Think in terms of <em>derivation
trees</em>:</p>
<p><span class="math display">
\frac{
\frac{\frac{\,}{\text{a premise}} \; \frac{\,}{\text{another
premise}}}{\text{some fact}} \;
\frac{\frac{\,}{\text{this we have by default}}}{\text{another fact}}}
{\text{final conclusion}}
</span></p>
<p>We define connectives by providing rules for using them. For example,
a rule <span class="math inline">\frac{a \; b}{c}</span> matches parts
of the tree that have two premises, represented by variables <span
class="math inline">a</span> and <span class="math inline">b</span>, and
have any conclusion, represented by variable <span
class="math inline">c</span>.</p>
<p><strong>Design principle:</strong> Try to use only the connective you
define in its definition.</p>
<h3 id="rules-for-logical-connectives">1.2 Rules for Logical
Connectives</h3>
<p><strong>Introduction rules</strong> say how to <em>produce</em> a
connective.</p>
<p><strong>Elimination rules</strong> say how to <em>use</em> it.</p>
<p>Text in parentheses is comments. Letters are variables that can stand
for anything.</p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 38%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr>
<th>Connective</th>
<th>Introduction Rules</th>
<th>Elimination Rules</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\top</span></td>
<td><span class="math inline">\frac{}{\top}</span></td>
<td>doesn’t have</td>
</tr>
<tr>
<td><span class="math inline">\bot</span></td>
<td>doesn’t have</td>
<td><span class="math inline">\frac{\bot}{a}</span> (i.e.,
anything)</td>
</tr>
<tr>
<td><span class="math inline">\wedge</span></td>
<td><span class="math inline">\frac{a \quad b}{a \wedge b}</span></td>
<td><span class="math inline">\frac{a \wedge b}{a}</span> (take first)  
<span class="math inline">\frac{a \wedge b}{b}</span> (take second)</td>
</tr>
<tr>
<td><span class="math inline">\vee</span></td>
<td><span class="math inline">\frac{a}{a \vee b}</span> (put first)  
<span class="math inline">\frac{b}{a \vee b}</span> (put second)</td>
<td><span class="math inline">\frac{a \vee b \quad
\genfrac{}{}{0pt}{}{[a]^x}{\vdots \; c} \quad
\genfrac{}{}{0pt}{}{[b]^y}{\vdots \; c}}{c}</span> using <span
class="math inline">x, y</span></td>
</tr>
<tr>
<td><span class="math inline">\rightarrow</span></td>
<td><span class="math inline">\frac{\genfrac{}{}{0pt}{}{[a]^x}{\vdots \;
b}}{a \rightarrow b}</span> using <span
class="math inline">x</span></td>
<td><span class="math inline">\frac{a \rightarrow b \quad
a}{b}</span></td>
</tr>
</tbody>
</table>
<h4 id="notation-for-hypothetical-derivations">Notation for Hypothetical
Derivations</h4>
<p>The notation <span
class="math inline">\genfrac{}{}{0pt}{}{[a]^x}{\vdots \; b}</span>
(sometimes written as a tree) matches any subtree that derives <span
class="math inline">b</span> and can use <span
class="math inline">a</span> as an assumption (marked with label <span
class="math inline">x</span>), even though <span
class="math inline">a</span> might not otherwise be warranted.</p>
<p>For example, we can derive “sunny <span
class="math inline">\rightarrow</span> happy” by showing that
<em>assuming</em> it’s sunny, we can derive happiness:</p>
<p><span class="math display">
\frac{\frac{\frac{\frac{\frac{\,}{\text{sunny}}^x}{\text{go
outdoor}}}{\text{playing}}}{\text{happy}}}{\text{sunny} \rightarrow
\text{happy}} \text{ using } x
</span></p>
<p>Such assumptions can only be used in the matched subtree! But they
can be used several times. For example, if someone’s mood is more
difficult to influence:</p>
<p><span class="math display">
\frac{\frac{
  \frac{\frac{\frac{\,}{\text{sunny}}^x}{\text{go
outdoor}}}{\text{playing}} \quad
  \frac{\frac{\,}{\text{sunny}}^x \quad
\frac{\frac{\,}{\text{sunny}}^x}{\text{go outdoor}}}{\text{nice view}}
}{\text{happy}}}{\text{sunny} \rightarrow \text{happy}} \text{ using } x
</span></p>
<h4 id="reasoning-by-cases">Reasoning by Cases</h4>
<p>The elimination rule for disjunction represents <strong>reasoning by
cases</strong>.</p>
<p>How can we use the fact that it is sunny <span
class="math inline">\vee</span> cloudy (but not rainy)?</p>
<p><span class="math display">
\frac{
  \frac{\,}{\text{sunny} \vee \text{cloudy}}^{\text{forecast}} \quad
  \frac{\frac{\,}{\text{sunny}}^x}{\text{no-umbrella}} \quad
  \frac{\frac{\,}{\text{cloudy}}^y}{\text{no-umbrella}}
}{\text{no-umbrella}} \text{ using } x, y
</span></p>
<p>We know that it will be sunny or cloudy (by watching the weather
forecast). If it will be sunny, we won’t need an umbrella. If it will be
cloudy, we won’t need an umbrella. Therefore, we won’t need an
umbrella.</p>
<h4 id="reasoning-by-induction">Reasoning by Induction</h4>
<p>We need one more kind of rule to do serious math: <strong>reasoning
by induction</strong> (somewhat similar to reasoning by cases). Example
rule for induction on natural numbers:</p>
<p><span class="math display">
\frac{p(0) \quad \genfrac{}{}{0pt}{}{[p(x)]^x}{\vdots \; p(x+1)}}{p(n)}
\text{ by induction, using } x
</span></p>
<p>We get property <span class="math inline">p</span> for any natural
number <span class="math inline">n</span>, provided we can: 1. Establish
<span class="math inline">p(0)</span> (the base case) 2. Show that
assuming <span class="math inline">p(x)</span> holds, we can derive
<span class="math inline">p(x+1)</span> (the inductive step)</p>
<p>Here <span class="math inline">x</span> is a unique variable—we
cannot substitute a particular number for it because we write “using
<span class="math inline">x</span>” on the side.</p>
<h3 id="logos-was-programmed-in-ocaml">1.3 Logos was Programmed in
OCaml</h3>
<p>There is a deep correspondence between logic and programming, known
as the <strong>Curry-Howard correspondence</strong> (or “propositions as
types”). The following table shows how logical connectives correspond to
programming constructs:</p>
<table>
<thead>
<tr>
<th>Logic</th>
<th>Type</th>
<th>Expression</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\top</span></td>
<td><code>unit</code></td>
<td><code>()</code></td>
</tr>
<tr>
<td><span class="math inline">\bot</span></td>
<td><code>'a</code></td>
<td><code>raise</code></td>
</tr>
<tr>
<td><span class="math inline">\wedge</span></td>
<td><code>*</code></td>
<td><code>(,)</code></td>
</tr>
<tr>
<td><span class="math inline">\vee</span></td>
<td><code>|</code></td>
<td><code>match</code></td>
</tr>
<tr>
<td><span class="math inline">\rightarrow</span></td>
<td><code>-&gt;</code></td>
<td><code>fun</code></td>
</tr>
<tr>
<td>induction</td>
<td>—</td>
<td><code>rec</code></td>
</tr>
</tbody>
</table>
<p><strong>Typing rules for OCaml constructs:</strong></p>
<ul>
<li><p><strong>Unit (truth):</strong> <span
class="math inline">\frac{}{\texttt{()} : \texttt{unit}}</span></p></li>
<li><p><strong>Exception (falsehood):</strong> <span
class="math inline">\frac{\text{oops!}}{\texttt{raise exn} : c}</span> —
can produce any type</p></li>
<li><p><strong>Pair (conjunction):</strong></p>
<ul>
<li>Introduction: <span class="math inline">\frac{s : a \quad t : b}{(s,
t) : a * b}</span></li>
<li>Elimination: <span class="math inline">\frac{p : a *
b}{\texttt{fst}~p : a}</span> and <span class="math inline">\frac{p : a
* b}{\texttt{snd}~p : b}</span></li>
</ul></li>
<li><p><strong>Variant (disjunction):</strong></p>
<ul>
<li>Introduction: <span class="math inline">\frac{s : a}{\texttt{A}(s) :
\texttt{A of}~a~|~\texttt{B of}~b}</span></li>
<li>Elimination (match): given <span class="math inline">t</span> of
variant type and branches for each case, produce result <span
class="math inline">c</span></li>
</ul></li>
<li><p><strong>Function (implication):</strong></p>
<ul>
<li>Introduction: <span class="math inline">\frac{\genfrac{}{}{0pt}{}{[x
: a]}{e : b}}{\texttt{fun}~x \to e : a \to b}</span></li>
<li>Elimination (application): <span class="math inline">\frac{f : a \to
b \quad t : a}{f~t : b}</span></li>
</ul></li>
<li><p><strong>Recursion (induction):</strong> <span
class="math inline">\frac{\genfrac{}{}{0pt}{}{[x : a]}{e :
a}}{\texttt{rec}~x = e : a}</span></p></li>
</ul>
<h4 id="definitions">1.3.1 Definitions</h4>
<p>Writing out expressions and types repetitively is tedious: we need
definitions.</p>
<p><strong>Type definitions</strong> are written: <code>type ty =</code>
some type.</p>
<ul>
<li><p>Writing <code>A(s) : A of a | B of b</code> in the table was
cheating. Usually we have to define the type and then use it. For
example, using <code>int</code> for <span class="math inline">a</span>
and <code>string</code> for <span class="math inline">b</span>:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> int_string_choice = A <span class="kw">of</span> <span class="dt">int</span> | B <span class="kw">of</span> <span class="dt">string</span></span></code></pre></div>
<p>This allows us to write
<code>A(s) : int_string_choice</code>.</p></li>
<li><p>Without the type definition, it is difficult to know what other
variants there are when one <em>infers</em> (i.e., “guesses”, computes)
the type!</p></li>
<li><p>In OCaml we can write <code>`A(s) : [`A of a | `B of b]</code>.
With “<code>`</code>” variants (polymorphic variants), OCaml does guess
what other variants there are. These types are interesting, but we will
not focus on them in this book.</p></li>
<li><p>Tuple elements don’t need labels because we always know at which
position a tuple element stands. But having labels makes code more
clear, so we can define a <em>record type</em>:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> int_string_record = {a: <span class="dt">int</span>; b: <span class="dt">string</span>}</span></code></pre></div>
<p>and create its values: <code>{a = 7; b = "Mary"}</code>.</p></li>
<li><p>We access the <em>fields</em> of records using the dot notation:
<code>{a=7; b="Mary"}.b = "Mary"</code>.</p></li>
</ul>
<h4 id="expression-definitions">1.3.2 Expression Definitions</h4>
<p>The recursive expression <code>rec x = e</code> in the table was
cheating: <code>rec</code> (usually called <code>fix</code> in theory)
cannot appear alone in OCaml! It must be part of a definition.</p>
<p><strong>Definitions for expressions</strong> are introduced by rules
a bit more complex:</p>
<p><span class="math display">
\frac{e_1 : a \quad \frac{[x : a]}{e_2 : b}}{\texttt{let } x = e_1
\texttt{ in } e_2 : b}
</span></p>
<p>(Note that this rule is the same as introducing and eliminating <span
class="math inline">\rightarrow</span>.)</p>
<p>For recursive definitions:</p>
<p><span class="math display">
\frac{\frac{[x : a]}{e_1 : a} \quad \frac{[x : a]}{e_2 : b}}{\texttt{let
rec } x = e_1 \texttt{ in } e_2 : b}
</span></p>
<p>We will cover what is missing in the above rules when we discuss
<strong>polymorphism</strong>.</p>
<h4 id="scoping-rules">1.3.3 Scoping Rules</h4>
<ul>
<li><p><strong>Type definitions</strong> we have seen above are
<em>global</em>: they need to be at the top-level (not nested in
expressions), and they extend from the point they occur till the end of
the source file or interactive session.</p></li>
<li><p><strong><code>let</code>-<code>in</code> definitions</strong> for
expressions: <code>let x = e1 in e2</code> are <em>local</em>—<span
class="math inline">x</span> is only visible in <span
class="math inline">e_2</span>. But <strong><code>let</code>
definitions</strong> without <code>in</code> are global: placing
<code>let x = e1</code> at the top-level makes <span
class="math inline">x</span> visible from after <span
class="math inline">e_1</span> till the end of the source file or
interactive session.</p></li>
<li><p>In the interactive session (toplevel/REPL), we mark the end of a
top-level “sentence” with <code>;;</code>—this is unnecessary in source
files.</p></li>
</ul>
<h4 id="operators">1.3.4 Operators</h4>
<p>Operators like <code>+</code>, <code>*</code>, <code>&lt;</code>,
<code>=</code> are names of functions. Just like other names, you can
use operator names for your own functions:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (+:) a b = <span class="dt">String</span>.concat <span class="st">&quot;&quot;</span> [a; b]  <span class="co">(* Special way of defining *)</span></span></code></pre></div>
<div class="sourceCode" id="cb4"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;Alpha&quot;</span> +: <span class="st">&quot;Beta&quot;</span>  <span class="co">(* but normal way of using operators *)</span></span></code></pre></div>
<p>Operators in OCaml are <strong>not overloaded</strong>. This means
that every type needs its own set of operators: - <code>+</code>,
<code>*</code>, <code>/</code> work for integers - <code>+.</code>,
<code>*.</code>, <code>/.</code> work for floating point numbers</p>
<p><strong>Exception:</strong> Comparisons <code>&lt;</code>,
<code>=</code>, etc. work for all values other than functions.</p>
<h3 id="exercises">1.4 Exercises</h3>
<p>Exercises from <em>Think OCaml: How to Think Like a Computer
Scientist</em> by Nicholas Monje and Allen Downey.</p>
<ol type="1">
<li><p>Assume that we execute the following assignment statements:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> width = <span class="dv">17</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> height = <span class="fl">12.0</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> delimiter = <span class="ch">&#39;.&#39;</span></span></code></pre></div>
<p>For each of the following expressions, write the value of the
expression and the type (of the value of the expression), or the
resulting type error.</p>
<ol type="1">
<li><code>width/2</code></li>
<li><code>width/.2.0</code></li>
<li><code>height/3</code></li>
<li><code>1 + 2 * 5</code></li>
<li><code>delimiter * 5</code></li>
</ol></li>
<li><p>Practice using the OCaml interpreter as a calculator:</p>
<ol type="1">
<li>The volume of a sphere with radius <span
class="math inline">r</span> is <span class="math inline">\frac{4}{3}
\pi r^3</span>. What is the volume of a sphere with radius 5?
(<em>Hint:</em> 392.6 is wrong!)</li>
<li>Suppose the cover price of a book is $24.95, but bookstores get a
40% discount. Shipping costs $3 for the first copy and 75 cents for each
additional copy. What is the total wholesale cost for 60 copies?</li>
<li>If I leave my house at 6:52 am and run 1 mile at an easy pace (8:15
per mile), then 3 miles at tempo (7:12 per mile) and 1 mile at easy pace
again, what time do I get home for breakfast?</li>
</ol></li>
<li><p>You’ve probably heard of the Fibonacci numbers before, but in
case you haven’t, they’re defined by the following recursive
relationship: <span class="math display">
\begin{cases}
f(0) = 0 \\
f(1) = 1 \\
f(n+1) = f(n) + f(n-1) &amp; \text{for } n = 2, 3, \ldots
\end{cases}
</span> Write a recursive function to calculate these numbers.</p></li>
<li><p>A palindrome is a word that is spelled the same backward and
forward, like “noon” and “redivider”. Recursively, a word is a
palindrome if the first and last letters are the same and the middle is
a palindrome.</p>
<p>The following are functions that take a string argument and return
the first, last, and middle letters:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> first_char word = word.[<span class="dv">0</span>]</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> last_char word =</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> len = <span class="dt">String</span>.length word - <span class="dv">1</span> <span class="kw">in</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  word.[len]</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> middle word =</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> len = <span class="dt">String</span>.length word - <span class="dv">2</span> <span class="kw">in</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">String</span>.sub word <span class="dv">1</span> len</span></code></pre></div>
<ol type="1">
<li>Enter these functions into the toplevel and test them out. What
happens if you call <code>middle</code> with a string with two letters?
One letter? What about the empty string <code>""</code>?</li>
<li>Write a function called <code>is_palindrome</code> that takes a
string argument and returns <code>true</code> if it is a palindrome and
<code>false</code> otherwise.</li>
</ol></li>
<li><p>The greatest common divisor (GCD) of <span
class="math inline">a</span> and <span class="math inline">b</span> is
the largest number that divides both of them with no remainder.</p>
<p>One way to find the GCD of two numbers is Euclid’s algorithm, which
is based on the observation that if <span class="math inline">r</span>
is the remainder when <span class="math inline">a</span> is divided by
<span class="math inline">b</span>, then <span
class="math inline">\gcd(a, b) = \gcd(b, r)</span>. As a base case, we
can consider <span class="math inline">\gcd(a, 0) = a</span>.</p>
<p>Write a function called <code>gcd</code> that takes parameters
<code>a</code> and <code>b</code> and returns their greatest common
divisor.</p>
<p>If you need help, see <a
href="http://en.wikipedia.org/wiki/Euclidean_algorithm">http://en.wikipedia.org/wiki/Euclidean_algorithm</a>.</p></li>
</ol>
<h2 id="chapter-2-algebra">Chapter 2: Algebra</h2>
<p><em>Algebraic Data Types and some curious analogies</em></p>
<h3 id="a-glimpse-at-type-inference">2.1 A Glimpse at Type
Inference</h3>
<p>For a refresher, let us apply the type inference rules introduced in
Chapter 1 to some simple examples. We will start with the identity
function <code>fun x -&gt; x</code>. In the derivations below, <span
class="math inline">[?]</span> means “type unknown yet.”</p>
<p>We begin with an incomplete derivation:</p>
<p><span class="math display">
\frac{[?]}{\texttt{fun x -&gt; x} : [?]}
</span></p>
<p>Using the <span class="math inline">\rightarrow</span> introduction
rule, we need to derive the body <code>x</code> assuming <code>x</code>
has some type <span class="math inline">a</span>:</p>
<p><span class="math display">
\frac{\frac{\,}{\texttt{x} : a}^x}{\texttt{fun x -&gt; x} : [?]
\rightarrow [?]}
</span></p>
<p>The premise <span class="math inline">\frac{\,}{\texttt{x} :
a}^x</span> matches the pattern for hypothetical derivations since <span
class="math inline">e = \texttt{x}</span>. Since the body <code>x</code>
has type <span class="math inline">a</span> (from our assumption), and
the parameter <code>x</code> also has type <span
class="math inline">a</span>, we conclude:</p>
<p><span class="math display">
\frac{\frac{\,}{\texttt{x} : a}^x}{\texttt{fun x -&gt; x} : a
\rightarrow a}
</span></p>
<p>Because <span class="math inline">a</span> is arbitrary (we made no
assumptions constraining it), OCaml introduces a <em>type variable</em>
<code>'a</code> to represent it:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">fun</span> x -&gt; x;;</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>- : &#39;a -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
<h4 id="a-more-complex-example">A More Complex Example</h4>
<p>Let us try <code>fun x -&gt; x+1</code>, which is the same as
<code>fun x -&gt; ((+) x) 1</code> (try it in OCaml!). We will use the
notation <span class="math inline">[?\alpha]</span> to mean “type
unknown yet, but the same as in other places marked <span
class="math inline">[?\alpha]</span>.”</p>
<p>Starting the derivation and applying <span
class="math inline">\rightarrow</span> introduction:</p>
<p><span class="math display">
\frac{\frac{[?]}{\texttt{((+) x) 1} : [?\alpha]}}{\texttt{fun x -&gt;
((+) x) 1} : [?] \rightarrow [?\alpha]}
</span></p>
<p>Applying <span class="math inline">\rightarrow</span> elimination
(function application) to <code>((+) x) 1</code>:</p>
<p><span class="math display">
\frac{\frac{\frac{[?]}{\texttt{(+) x} : [?\beta] \rightarrow [?\alpha]}
\quad \frac{[?]}{\texttt{1} : [?\beta]}}{\texttt{((+) x) 1} :
[?\alpha]}}{\texttt{fun x -&gt; ((+) x) 1} : [?] \rightarrow [?\alpha]}
</span></p>
<p>We know that <code>1 : int</code>, so <span
class="math inline">[?\beta] = \texttt{int}</span>:</p>
<p><span class="math display">
\frac{\frac{\frac{[?]}{\texttt{(+) x} : \texttt{int} \rightarrow
[?\alpha]} \quad \frac{\,}{\texttt{1} :
\texttt{int}}^{\text{(constant)}}}{\texttt{((+) x) 1} :
[?\alpha]}}{\texttt{fun x -&gt; ((+) x) 1} : [?] \rightarrow [?\alpha]}
</span></p>
<p>Applying function application again to <code>(+) x</code>:</p>
<p><span class="math display">
\frac{\frac{\frac{\frac{[?]}{\texttt{(+)} : [?\gamma] \rightarrow
\texttt{int} \rightarrow [?\alpha]} \quad \frac{[?]}{\texttt{x} :
[?\gamma]}}{\texttt{(+) x} : \texttt{int} \rightarrow [?\alpha]} \quad
\frac{\,}{\texttt{1} : \texttt{int}}^{\text{(constant)}}}{\texttt{((+)
x) 1} : [?\alpha]}}{\texttt{fun x -&gt; ((+) x) 1} : [?\gamma]
\rightarrow [?\alpha]}
</span></p>
<p>Since <code>(+) : int -&gt; int -&gt; int</code>, we have <span
class="math inline">[?\gamma] = \texttt{int}</span> and <span
class="math inline">[?\alpha] = \texttt{int}</span>:</p>
<p><span class="math display">
\frac{\frac{\frac{\frac{\,}{\texttt{(+)} : \texttt{int} \rightarrow
\texttt{int} \rightarrow \texttt{int}}^{\text{(constant)}} \quad
\frac{\,}{\texttt{x} : \texttt{int}}^x}{\texttt{(+) x} : \texttt{int}
\rightarrow \texttt{int}} \quad \frac{\,}{\texttt{1} :
\texttt{int}}^{\text{(constant)}}}{\texttt{((+) x) 1} :
\texttt{int}}}{\texttt{fun x -&gt; ((+) x) 1} : \texttt{int} \rightarrow
\texttt{int}}
</span></p>
<h4 id="curried-form">2.1.1 Curried Form</h4>
<p>When there are several arrows “on the same depth” in a function type,
it means that the function returns a function. For example,
<code>(+) : int -&gt; int -&gt; int</code> is just a shorthand for
<code>(+) : int -&gt; (int -&gt; int)</code>. This is very different
from:</p>
<p><span class="math display">
\texttt{fun f -&gt; (f 1) + 1} : (\texttt{int} \rightarrow \texttt{int})
\rightarrow \texttt{int}
</span></p>
<p>In the first case, <code>(+)</code> is a function that takes an
integer and returns a function from integers to integers. In the second
case, we have a function that takes a function as an argument.</p>
<p>For addition, instead of <code>(fun x -&gt; x+1)</code> we can write
<code>((+) 1)</code>. What expanded form does <code>((+) 1)</code>
correspond to exactly (computationally)? It corresponds to
<code>fun y -&gt; 1 + y</code>.</p>
<p>We will become more familiar with functions returning functions when
we study the <em>lambda calculus</em> in a later chapter.</p>
<h3 id="algebraic-data-types">2.2 Algebraic Data Types</h3>
<p>In Chapter 1, we learned about the <code>unit</code> type and variant
types like:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> int_string_choice = A <span class="kw">of</span> <span class="dt">int</span> | B <span class="kw">of</span> <span class="dt">string</span></span></code></pre></div>
<p>We also covered tuple types, record types, and type definitions. Let
us now explore these concepts more deeply.</p>
<h4 id="variants-without-arguments">Variants Without Arguments</h4>
<p>Variants do not have to carry arguments. Instead of writing
<code>A of unit</code>, we can simply use <code>A</code>. This is more
convenient and idiomatic:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> color = Red | Green | Blue</span></code></pre></div>
<p><strong>A subtle point about OCaml:</strong> In OCaml, variants take
multiple arguments rather than taking tuples as arguments. This means
<code>A of int * string</code> is different from
<code>A of (int * string)</code>. The first takes two separate
arguments, while the second takes a single tuple argument. This
distinction is usually not important unless you encounter situations
where it matters.</p>
<h4 id="recursive-type-definitions">Recursive Type Definitions</h4>
<p>Type definitions can be recursive! This allows us to define data
structures of arbitrary size:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> int_list = Empty | Cons <span class="kw">of</span> <span class="dt">int</span> * int_list</span></code></pre></div>
<p>Let us see what values inhabit <code>int_list</code>: -
<code>Empty</code> represents the empty list -
<code>Cons (5, Empty)</code> is a list containing just 5 -
<code>Cons (5, Cons (7, Cons (13, Empty)))</code> is a list containing
5, 7, and 13</p>
<p>The built-in type <code>bool</code> can be viewed as if it were
defined as <code>type bool = true | false</code>. Similarly,
<code>int</code> can be thought of as a very large variant:
<code>type int = 0 | -1 | 1 | -2 | 2 | ...</code></p>
<h4 id="parametric-type-definitions">Parametric Type Definitions</h4>
<p>Type definitions can be <em>parametric</em> with respect to the types
of their components. This allows us to define generic data structures
that work with any element type. For example, a list of elements of
arbitrary type:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;elem <span class="dt">list</span> = Empty | Cons <span class="kw">of</span> &#39;elem * &#39;elem <span class="dt">list</span></span></code></pre></div>
<p>Several conventions and syntax rules apply to parametric types:</p>
<ul>
<li><p>Type variables must start with <code>'</code>, but since OCaml
will not remember the names we give, it is customary to use the names
OCaml uses: <code>'a</code>, <code>'b</code>, <code>'c</code>,
<code>'d</code>, etc.</p></li>
<li><p>The OCaml syntax places the type parameter before the type name,
mimicking English word order. A silly example:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;white_color dog = Dog <span class="kw">of</span> &#39;white_color</span></code></pre></div></li>
<li><p>With multiple parameters, OCaml uses parentheses:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (&#39;a, &#39;b) choice = Left <span class="kw">of</span> &#39;a | Right <span class="kw">of</span> &#39;b</span></code></pre></div>
<p>Compare this to F# syntax:
<code>type choice&lt;'a,'b&gt; = Left of 'a | Right of 'b</code></p>
<p>And Haskell syntax:
<code>data Choice a b = Left a | Right b</code></p></li>
</ul>
<h3 id="syntactic-conventions">2.3 Syntactic Conventions</h3>
<h4 id="constructor-naming">Constructor Naming</h4>
<p>Names of variants, called <em>constructors</em>, must start with a
capital letter. If we wanted to define our own booleans, we would
write:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> my_bool = True | False</span></code></pre></div>
<p>Only constructors and module names can start with capital letters in
OCaml. <em>Modules</em> are organizational units (like “shelves”)
containing related values. For example, the <code>List</code> module
provides operations on lists, including <code>List.map</code> and
<code>List.filter</code>.</p>
<h4 id="accessing-record-fields">Accessing Record Fields</h4>
<p>We can use dot notation to access record fields:
<code>record.field</code>. For example, if we have
<code>let person = {name="Alice"; age=30}</code>, we can write
<code>person.name</code> to get <code>"Alice"</code>.</p>
<h4 id="function-definition-shortcuts">Function Definition
Shortcuts</h4>
<p>Several syntactic shortcuts make function definitions more
concise:</p>
<ul>
<li><p><code>fun x y -&gt; e</code> stands for
<code>fun x -&gt; fun y -&gt; e</code>. Note that
<code>fun x -&gt; fun y -&gt; e</code> parses as
<code>fun x -&gt; (fun y -&gt; e)</code>.</p></li>
<li><p><code>function A x -&gt; e1 | B y -&gt; e2</code> stands for
<code>fun p -&gt; match p with A x -&gt; e1 | B y -&gt; e2</code>. The
general form is: <code>function PATTERN-MATCHING</code> stands for
<code>fun v -&gt; match v with PATTERN-MATCHING</code>.</p></li>
<li><p><code>let f ARGS = e</code> is a shorthand for
<code>let f = fun ARGS -&gt; e</code>.</p></li>
</ul>
<h3 id="pattern-matching">2.4 Pattern Matching</h3>
<p>Recall that we introduced <code>fst</code> and <code>snd</code> as
means to access elements of a pair. But what about larger tuples? The
fundamental way to access any tuple uses the <code>match</code>
construct. In fact, <code>fst</code> and <code>snd</code> can easily be
defined using pattern matching:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">fst</span> = <span class="kw">fun</span> p -&gt; <span class="kw">match</span> p <span class="kw">with</span> (a, b) -&gt; a</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">snd</span> = <span class="kw">fun</span> p -&gt; <span class="kw">match</span> p <span class="kw">with</span> (a, b) -&gt; b</span></code></pre></div>
<h4 id="matching-on-records">Matching on Records</h4>
<p>Pattern matching also works with records:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> person = {name: <span class="dt">string</span>; surname: <span class="dt">string</span>; age: <span class="dt">int</span>}</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> greet_person () =</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> {name=<span class="st">&quot;Walker&quot;</span>; surname=<span class="st">&quot;Johnnie&quot;</span>; age=<span class="dv">207</span>}</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">with</span> {name=n; surname=sn; age=a} -&gt; <span class="st">&quot;Hi &quot;</span> ^ sn ^ <span class="st">&quot;!&quot;</span></span></code></pre></div>
<h4 id="understanding-patterns">Understanding Patterns</h4>
<p>The left-hand sides of <code>-&gt;</code> in <code>match</code>
expressions are called <strong>patterns</strong>. Patterns describe the
structure of values we want to match against.</p>
<p>Patterns can be nested, allowing us to match complex structures:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> <span class="dt">Some</span> (<span class="dv">5</span>, <span class="dv">7</span>) <span class="kw">with</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>| <span class="dt">None</span> -&gt; <span class="st">&quot;sum: nothing&quot;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>| <span class="dt">Some</span> (x, y) -&gt; <span class="st">&quot;sum: &quot;</span> ^ <span class="dt">string_of_int</span> (x+y)</span></code></pre></div>
<h4 id="simple-patterns-and-wildcards">Simple Patterns and
Wildcards</h4>
<p>A pattern can simply bind the entire value without destructuring.
Writing <code>match f x with v -&gt; ...</code> is the same as
<code>let v = f x in ...</code>.</p>
<p>When we do not need a value in a pattern, it is good practice to use
the underscore <code>_</code>, which is a wildcard (not a variable):</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">fst</span> (a, _) = a</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">snd</span> (_, b) = b</span></code></pre></div>
<h4 id="pattern-linearity">Pattern Linearity</h4>
<p>A variable can only appear once in a pattern. This property is called
<em>linearity</em>. However, we can add conditions to patterns using
<code>when</code>, so linearity is not a limitation:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> describe_point p =</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> p <span class="kw">with</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  | (x, y) <span class="kw">when</span> x = y -&gt; <span class="st">&quot;diag&quot;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; <span class="st">&quot;off-diag&quot;</span></span></code></pre></div>
<p>Here is a more elaborate example:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">compare</span> a b = <span class="kw">match</span> a, b <span class="kw">with</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  | (x, y) <span class="kw">when</span> x &lt; y -&gt; <span class="dv">-1</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  | (x, y) <span class="kw">when</span> x = y -&gt; <span class="dv">0</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; <span class="dv">1</span></span></code></pre></div>
<h4 id="partial-record-patterns">Partial Record Patterns</h4>
<p>We can skip unused fields of a record in a pattern. Only the fields
we care about need to be mentioned.</p>
<h4 id="or-patterns">Or-Patterns</h4>
<p>We can compress patterns by using <code>|</code> inside a single
pattern to match multiple alternatives:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> month =</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  | Jan | Feb | Mar | Apr | May | Jun</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  | Jul | Aug | Sep | Oct | Nov | Dec</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> weekday = Mon | Tue | Wed | Thu | Fri | Sat | Sun</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date =</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>  {year: <span class="dt">int</span>; month: month; day: <span class="dt">int</span>; weekday: weekday}</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> day =</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>  {year = <span class="dv">2012</span>; month = Feb; day = <span class="dv">14</span>; weekday = Wed};;</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> day <span class="kw">with</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>  | {weekday = Sat | Sun} -&gt; <span class="st">&quot;Weekend!&quot;</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; <span class="st">&quot;Work day&quot;</span></span></code></pre></div>
<h4 id="named-patterns-with-as">Named Patterns with <code>as</code></h4>
<p>We use <code>(pattern as v)</code> to name a nested pattern, binding
the matched value to <code>v</code>:</p>
<pre><code>match day with
  | {weekday = (Mon | Tue | Wed | Thu | Fri as wday)}
      when not (day.month = Dec &amp;&amp; day.day = 24) -&gt;
    Some (work (get_plan wday))
  | _ -&gt; None</code></pre>
<p>This example shows the <code>as</code> keyword binding the matched
weekday to <code>wday</code> for use in the expression on the right side
of the arrow.</p>
<h3 id="interpreting-algebraic-data-types-as-polynomials">2.5
Interpreting Algebraic Data Types as Polynomials</h3>
<p>Let us explore a curious analogy between algebraic data types and
polynomials. We translate data types to mathematical expressions by:</p>
<ul>
<li>Replacing <code>|</code> (variant choice) with <span
class="math inline">+</span></li>
<li>Replacing <code>*</code> (tuple product) with <span
class="math inline">\times</span></li>
<li>Treating record types as tuple types (erasing field names and
translating <code>;</code> as <span
class="math inline">\times</span>)</li>
</ul>
<p>We also need translations for some special types:</p>
<ul>
<li><p>The <strong>void type</strong> (a type with no constructors,
hence no values):</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> void</span></code></pre></div>
<p>(Yes, this is its complete definition, with no
<code>= something</code> part.) Translate it as <span
class="math inline">0</span>.</p></li>
<li><p>The <strong>unit type</strong> translates as <span
class="math inline">1</span>. Since variants without arguments behave
like variants <code>of unit</code>, translate them as <span
class="math inline">1</span> as well.</p></li>
<li><p>The <strong>bool type</strong> translates as <span
class="math inline">2</span>.</p></li>
<li><p>Types like <code>int</code>, <code>string</code>,
<code>float</code>, and type parameters translate as variables.</p></li>
<li><p>Defined types translate according to their definitions
(substituting variables as necessary).</p></li>
</ul>
<p>Give a name to the type being defined (representing a function of the
introduced variables). Now interpret the result as an ordinary numeric
polynomial! (Or a “rational function” if recursively defined.)</p>
<p>Let us have some fun with this translation.</p>
<h4 id="example-date-type">Example: Date Type</h4>
<div class="sourceCode" id="cb24"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = {year: <span class="dt">int</span>; month: <span class="dt">int</span>; day: <span class="dt">int</span>}</span></code></pre></div>
<p>Translating to a polynomial (using <span class="math inline">x</span>
for <code>int</code>):</p>
<p><span class="math display">D = x \times x \times x = x^3</span></p>
<h4 id="example-option-type">Example: Option Type</h4>
<p>The built-in option type is defined as:</p>
<pre><code>type &#39;a option = None | Some of &#39;a</code></pre>
<p>Translating:</p>
<p><span class="math display">O = 1 + x</span></p>
<h4 id="example-list-type">Example: List Type</h4>
<div class="sourceCode" id="cb26"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a my_list = Empty | Cons <span class="kw">of</span> &#39;a * &#39;a my_list</span></code></pre></div>
<p>Translating (where <span class="math inline">L</span> represents the
list type):</p>
<p><span class="math display">L = 1 + x \cdot L</span></p>
<h4 id="example-binary-tree-type">Example: Binary Tree Type</h4>
<div class="sourceCode" id="cb27"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree = Tip | Node <span class="kw">of</span> <span class="dt">int</span> * btree * btree</span></code></pre></div>
<p>Translating:</p>
<p><span class="math display">T = 1 + x \cdot T \cdot T = 1 + x \cdot
T^2</span></p>
<h4 id="type-isomorphisms">Type Isomorphisms</h4>
<p>When translations of two types are equal according to the laws of
high-school algebra, the types are <em>isomorphic</em>. This means there
exist bijective (one-to-one and onto) functions between them.</p>
<p>Let us manipulate the binary tree polynomial:</p>
<p><span class="math display">
\begin{aligned}
T &amp;= 1 + x \cdot T^2 \\
  &amp;= 1 + x \cdot T + x^2 \cdot T^3 \\
  &amp;= 1 + x + x^2 \cdot T^2 + x^2 \cdot T^3 \\
  &amp;= 1 + x + x^2 \cdot T^2 \cdot (1 + T) \\
  &amp;= 1 + x \cdot (1 + x \cdot T^2 \cdot (1 + T))
\end{aligned}
</span></p>
<p>Now let us translate the resulting expression back to a type:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> repr =</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">int</span> * (<span class="dt">int</span> * btree * btree * btree <span class="dt">option</span>) <span class="dt">option</span>) <span class="dt">option</span></span></code></pre></div>
<p>The challenge is to find isomorphism functions with signatures:</p>
<pre><code>val iso1 : btree -&gt; repr
val iso2 : repr -&gt; btree</code></pre>
<p>These functions should satisfy: for all trees <code>t</code>,
<code>iso2 (iso1 t) = t</code>, and for all representations
<code>r</code>, <code>iso1 (iso2 r) = r</code>.</p>
<h4 id="a-first-attempt">A First Attempt</h4>
<p>Here is a first (failed) attempt:</p>
<pre><code># let iso1 (t : btree) : repr =
  match t with
    | Tip -&gt; None
    | Node (x, Tip, Tip) -&gt; Some (x, None)
    | Node (x, Node (y, t1, t2), Tip) -&gt;
      Some (x, Some (y, t1, t2, None))
    | Node (x, Node (y, t1, t2), t3) -&gt;
      Some (x, Some (y, t1, t2, Some t3));;

Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Node (_, Tip, Node (_, _, _))</code></pre>
<p>We forgot about one case! It seems difficult to guess the solution
directly.</p>
<h4 id="breaking-down-the-problem">Breaking Down the Problem</h4>
<p>Let us divide the task into smaller steps corresponding to
intermediate points in the polynomial transformation:</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (&#39;a, &#39;b) choice = Left <span class="kw">of</span> &#39;a | Right <span class="kw">of</span> &#39;b</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> interm1 =</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>  ((<span class="dt">int</span> * btree, <span class="dt">int</span> * <span class="dt">int</span> * btree * btree * btree) choice)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">option</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> interm2 =</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>  ((<span class="dt">int</span>, <span class="dt">int</span> * <span class="dt">int</span> * btree * btree * btree <span class="dt">option</span>) choice)</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">option</span></span></code></pre></div>
<p>Now we can define each step:</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> step1r (t : btree) : interm1 =</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> t <span class="kw">with</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    | Tip -&gt; <span class="dt">None</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    | Node (x, t1, Tip) -&gt; <span class="dt">Some</span> (Left (x, t1))</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    | Node (x, t1, Node (y, t2, t3)) -&gt;</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Some</span> (Right (x, y, t1, t2, t3))</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> step2r (r : interm1) : interm2 =</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> r <span class="kw">with</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">None</span> -&gt; <span class="dt">None</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (Left (x, Tip)) -&gt; <span class="dt">Some</span> (Left x)</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (Left (x, Node (y, t1, t2))) -&gt;</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Some</span> (Right (x, y, t1, t2, <span class="dt">None</span>))</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (Right (x, y, t1, t2, t3)) -&gt;</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Some</span> (Right (x, y, t1, t2, <span class="dt">Some</span> t3))</span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> step3r (r : interm2) : repr =</span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> r <span class="kw">with</span></span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">None</span> -&gt; <span class="dt">None</span></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (Left x) -&gt; <span class="dt">Some</span> (x, <span class="dt">None</span>)</span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (Right (x, y, t1, t2, t3opt)) -&gt;</span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Some</span> (x, <span class="dt">Some</span> (y, t1, t2, t3opt))</span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> iso1 (t : btree) : repr =</span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a>  step3r (step2r (step1r t))</span></code></pre></div>
<p>Defining <code>step1l</code>, <code>step2l</code>,
<code>step3l</code>, and <code>iso2</code> is now straightforward—each
step is the inverse of its corresponding forward step.</p>
<h4 id="take-home-lessons">Take-Home Lessons</h4>
<ol type="1">
<li><p><strong>Design for validity:</strong> Try to define data
structures so that only meaningful information can be represented—as
long as it does not overcomplicate the data structures. Avoid catch-all
clauses when defining functions. The compiler will then tell you if you
have forgotten about a case.</p></li>
<li><p><strong>Divide and conquer:</strong> Break solutions into small
steps so that each step can be easily understood and verified.</p></li>
</ol>
<h3 id="differentiating-algebraic-data-types">2.6 Differentiating
Algebraic Data Types</h3>
<p>The title might seem strange—we will differentiate the translated
polynomials, not the types themselves. But what sense does this
make?</p>
<p>It turns out that taking the partial derivative of a polynomial
(translated from a data type), when translated back, gives a type
representing how to change one occurrence of a value corresponding to
the variable with respect to which we differentiated. In other words,
the derivative represents a “context” or “hole” in the data
structure.</p>
<h4 id="example-differentiating-the-date-type">Example: Differentiating
the Date Type</h4>
<div class="sourceCode" id="cb33"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = {year: <span class="dt">int</span>; month: <span class="dt">int</span>; day: <span class="dt">int</span>}</span></code></pre></div>
<p>The translation:</p>
<p><span class="math display">
\begin{aligned}
D &amp;= x \cdot x \cdot x = x^3 \\
\frac{\partial D}{\partial x} &amp;= 3x^2 = x \cdot x + x \cdot x + x
\cdot x
\end{aligned}
</span></p>
<p>We could have left it as <span class="math inline">3 \cdot x \cdot
x</span>, but expanding shows the structure more clearly. Translating
back to a type:</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date_deriv =</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>  Year <span class="kw">of</span> <span class="dt">int</span> * <span class="dt">int</span> | Month <span class="kw">of</span> <span class="dt">int</span> * <span class="dt">int</span> | Day <span class="kw">of</span> <span class="dt">int</span> * <span class="dt">int</span></span></code></pre></div>
<p>Each variant represents a “hole” at a different position:
<code>Year</code> means the year field is missing (and we have the month
and day), and so on.</p>
<p>Now we can define functions to introduce and eliminate this
derivative type:</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> date_deriv {year=y; month=m; day=d} =</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  [Year (m, d); Month (y, d); Day (y, m)]</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> date_integr n = <span class="kw">function</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>  | Year (m, d) -&gt; {year=n; month=m; day=d}</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>  | Month (y, d) -&gt; {year=y; month=n; day=d}</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>  | Day (y, m) -&gt; {year=y; month=m; day=n}</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>;;</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.map (date_integr <span class="dv">7</span>)</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>  (date_deriv {year=<span class="dv">2012</span>; month=<span class="dv">2</span>; day=<span class="dv">14</span>})</span></code></pre></div>
<p>The <code>date_deriv</code> function produces all contexts (one for
each field), and <code>date_integr</code> fills in a hole with a new
value.</p>
<h4 id="example-differentiating-binary-trees">Example: Differentiating
Binary Trees</h4>
<p>Let us tackle the more challenging case of binary trees:</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree = Tip | Node <span class="kw">of</span> <span class="dt">int</span> * btree * btree</span></code></pre></div>
<p>The translation and differentiation:</p>
<p><span class="math display">
\begin{aligned}
T &amp;= 1 + x \cdot T^2 \\
\frac{\partial T}{\partial x} &amp;= 0 + T^2 + 2 \cdot x \cdot T \cdot
\frac{\partial T}{\partial x} = T \cdot T + 2 \cdot x \cdot T \cdot
\frac{\partial T}{\partial x}
\end{aligned}
</span></p>
<p>The derivative is recursive! This makes sense: a context in a tree is
either at the current node (<span class="math inline">T \cdot T</span>,
the two subtrees) or somewhere below (<span class="math inline">2 \cdot
x \cdot T \cdot \frac{\partial T}{\partial x}</span>, choosing left or
right, with the node value, the other subtree, and a deeper
context).</p>
<p>Instead of translating <span class="math inline">2</span> as
<code>bool</code>, we introduce a more descriptive type:</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree_dir = LeftBranch | RightBranch</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree_deriv =</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>  | Here <span class="kw">of</span> btree * btree</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>  | Below <span class="kw">of</span> btree_dir * <span class="dt">int</span> * btree * btree_deriv</span></code></pre></div>
<p>(You might someday hear about <em>zippers</em>—they are “inverted”
relative to our type, with the hole coming first.)</p>
<p>The integration function fills the hole with a value:</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> btree_integr n = <span class="kw">function</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>  | Here (ltree, rtree) -&gt; Node (n, ltree, rtree)</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>  | Below (LeftBranch, m, rtree, deriv) -&gt;</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    Node (m, btree_integr n deriv, rtree)</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>  | Below (RightBranch, m, ltree, deriv) -&gt;</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>    Node (m, ltree, btree_integr n deriv)</span></code></pre></div>
<h3 id="exercises-1">2.7 Exercises</h3>
<h4 id="exercise-1">Exercise 1</h4>
<p><em>Due to Yaron Minsky.</em></p>
<p>Consider a datatype to store internet connection information. The
time <code>when_initiated</code> marks the start of connecting and is
not needed after the connection is established (it is only used to
decide whether to give up trying to connect). The ping information is
available for established connections but not straight away.</p>
<pre><code>type connectionstate = Connecting | Connected | Disconnected

type connectioninfo = {
  state : connectionstate;
  server : Inetaddr.t;
  lastpingtime : Time.t option;
  lastpingid : int option;
  sessionid : string option;
  wheninitiated : Time.t option;
  whendisconnected : Time.t option;
}</code></pre>
<p>(The types <code>Time.t</code> and <code>Inetaddr.t</code> come from
the <em>Core</em> library. You can replace them with <code>float</code>
and <code>Unix.inet_addr</code>. Load the Unix library in the
interactive toplevel with <code>#load "unix.cma";;</code>.)</p>
<p>Rewrite the type definitions so that the datatype will contain only
reasonable combinations of information.</p>
<h4 id="exercise-2">Exercise 2</h4>
<p>In OCaml, functions can have labeled arguments and optional arguments
(parameters with default values that can be omitted). Labels can differ
from the names of argument values:</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f ~meaningfulname:n = n + <span class="dv">1</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> _ = f ~meaningfulname:<span class="dv">5</span>  <span class="co">(* We do not need the result so we ignore it. *)</span></span></code></pre></div>
<p>When the label and value names are the same, the syntax is
shorter:</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> g ~pos ~len =</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">StringLabels</span>.sub <span class="st">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span> ~pos ~len</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () =  <span class="co">(* A nicer way to mark computations that return unit. *)</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> pos = <span class="dt">Random</span>.<span class="dt">int</span> <span class="dv">26</span> <span class="kw">in</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> len = <span class="dt">Random</span>.<span class="dt">int</span> <span class="dv">10</span> <span class="kw">in</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">print_string</span> (g ~pos ~len)</span></code></pre></div>
<p>When some function arguments are optional, the function must take
non-optional arguments after the last optional argument. Optional
parameters with default values:</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> h ?(len=<span class="dv">1</span>) pos = g ~pos ~len</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () = <span class="dt">print_string</span> (h <span class="dv">10</span>)</span></code></pre></div>
<p>Optional arguments are implemented as parameters of an option type.
This allows checking whether the argument was provided:</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo ?bar n =</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> bar <span class="kw">with</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">None</span> -&gt; <span class="st">&quot;Argument = &quot;</span> ^ <span class="dt">string_of_int</span> n</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> m -&gt; <span class="st">&quot;Sum = &quot;</span> ^ <span class="dt">string_of_int</span> (m + n)</span></code></pre></div>
<p>We can use it in various ways:</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> _ = foo <span class="dv">5</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> _ = foo ~bar:<span class="dv">5</span> <span class="dv">7</span></span></code></pre></div>
<p>We can also provide the option value directly:</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> test_foo () =</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> bar = <span class="kw">if</span> <span class="dt">Random</span>.<span class="dt">int</span> <span class="dv">10</span> &lt; <span class="dv">5</span> <span class="kw">then</span> <span class="dt">None</span> <span class="kw">else</span> <span class="dt">Some</span> <span class="dv">7</span> <span class="kw">in</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>  foo ?bar <span class="dv">7</span></span></code></pre></div>
<ol type="1">
<li><p>Observe the types that functions with labeled and optional
arguments have. Come up with coding style guidelines for when to use
labeled arguments.</p></li>
<li><p>Write a rectangle-drawing procedure that takes three optional
arguments: left-upper corner, right-lower corner, and a width-height
pair. It should draw a correct rectangle whenever two arguments are
given, and raise an exception otherwise. Load the graphics library with
<code>#load "graphics.cma";;</code>. Use <code>invalid_arg</code>,
<code>Graphics.open_graph</code>, and
<code>Graphics.draw_rect</code>.</p></li>
<li><p>Write a function that takes an optional argument of arbitrary
type and a function argument, and passes the optional argument to the
function without inspecting it.</p></li>
</ol>
<h4 id="exercise-3">Exercise 3</h4>
<p><em>From a past exam.</em></p>
<ol type="1">
<li>Give the (most general) types of the following expressions, either
by guessing or by inferring by hand:
<ol type="1">
<li><code>let double f y = f (f y) in fun g x -&gt; double (g x)</code></li>
<li><code>let rec tails l = match l with [] -&gt; [] | x::xs -&gt; xs::tails xs in fun l -&gt; List.combine l (tails l)</code></li>
</ol></li>
<li>Give example expressions that have the following types (without
using type constraints):
<ol type="1">
<li><code>(int -&gt; int) -&gt; bool</code></li>
<li><code>'a option -&gt; 'a list</code></li>
</ol></li>
</ol>
<h4 id="exercise-4">Exercise 4</h4>
<p>We have seen that algebraic data types can be related to analytic
functions (the subset definable from polynomials via recursion)—by
literally interpreting sum types (variant types) as sums and product
types (tuple and record types) as products. We can extend this
interpretation to function types by interpreting <span
class="math inline">a \rightarrow b</span> as <span
class="math inline">b^a</span> (i.e., <span class="math inline">b</span>
to the power of <span class="math inline">a</span>). Note that the <span
class="math inline">b^a</span> notation is actually used to denote
functions in set theory.</p>
<ol type="1">
<li><p>Translate <span class="math inline">a^{b + cd}</span> and <span
class="math inline">a^b \cdot (a^c)^d</span> into OCaml types, using any
distinct types for <span class="math inline">a, b, c, d</span>, and
using <code>type ('a,'b) choice = Left of 'a | Right of 'b</code> for
<span class="math inline">+</span>. Write the bijection function in both
directions.</p></li>
<li><p>Come up with a type <code>'t exp</code> that shares with the
exponential function the following property: <span
class="math inline">\frac{\partial \exp(t)}{\partial t} =
\exp(t)</span>, where we translate a derivative of a type as a context
(i.e., the type with a “hole”), as in this chapter. Explain why your
answer is correct. <em>Hint:</em> in computer science, our logarithms
are mostly base 2.</p></li>
</ol>
<p><em>Further reading:</em> <a
href="http://bababadalgharaghtakamminarronnkonnbro.blogspot.com/2012/10/algebraic-type-systems-combinatorial.html">Algebraic
Type Systems - Combinatorial Species</a></p>
<h4 id="exercise-5-homework">Exercise 5 (Homework)</h4>
<p>Write a function <code>btree_deriv_at</code> that takes a predicate
over integers (i.e., a function <code>f: int -&gt; bool</code>) and a
<code>btree</code>, and builds a <code>btree_deriv</code> whose “hole”
is in the first position for which the predicate returns true. It should
return a <code>btree_deriv option</code>, with <code>None</code> if the
predicate does not hold for any node.</p>
<h2 id="chapter-3-computation">Chapter 3: Computation</h2>
<p><em>Reduction semantics and operational reasoning</em></p>
<p><strong>References:</strong></p>
<ul>
<li>“Using, Understanding and Unraveling the OCaml Language” by Didier
Remy, Chapter 1</li>
<li>“The OCaml system” manual, the tutorial part, Chapter 1</li>
</ul>
<h3 id="function-composition">3.1 Function Composition</h3>
<p>The usual way function composition is defined in mathematics is
“backward”—the notation follows the convention of mathematical function
application:</p>
<p><span class="math display">
(f \circ g)(x) = f(g(x))
</span></p>
<p>This means that when we write <span class="math inline">f \circ
g</span>, we first apply <span class="math inline">g</span> and then
apply <span class="math inline">f</span> to the result. Here is how this
is expressed in different functional programming languages:</p>
<table>
<thead>
<tr>
<th>Language</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td>Math</td>
<td><span class="math inline">(f \circ g)(x) = f(g(x))</span></td>
</tr>
<tr>
<td>OCaml</td>
<td><code>let (-|) f g x = f (g x)</code></td>
</tr>
<tr>
<td>F#</td>
<td><code>let (&lt;&lt;) f g x = f (g x)</code></td>
</tr>
<tr>
<td>Haskell</td>
<td><code>(.) f g = \x -&gt; f (g x)</code></td>
</tr>
</tbody>
</table>
<p>This backward composition looks like function application but needs
fewer parentheses. Recall the functions <code>iso1</code> and
<code>iso2</code> from the previous chapter on type isomorphisms. Using
backward composition, we could write:</p>
<pre><code>let iso2 = step1l -| step2l -| step3l</code></pre>
<p>A more natural definition of function composition is “forward”
composition, which follows the order in which computation actually
proceeds:</p>
<table>
<thead>
<tr>
<th>Language</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td>OCaml</td>
<td><code>let (\|-) f g x = g (f x)</code></td>
</tr>
<tr>
<td>F#</td>
<td><code>let (&gt;&gt;) f g x = g (f x)</code></td>
</tr>
</tbody>
</table>
<p>With forward composition, data flows from left to right, matching how
we typically read code:</p>
<pre><code>let iso1 = step1r |- step2r |- step3r</code></pre>
<h4 id="partial-application">Partial Application</h4>
<p>Both composition examples above use <strong>partial
application</strong>. Recall from the previous chapter that
<code>((+) 1)</code> is a function that adds 1 to its argument. Partial
application occurs when we do not pass all the arguments a function
needs; the result is a function that requires the remaining
arguments.</p>
<p>In the composition <code>step1r |- step2r |- step3r</code>, each
<code>stepNr</code> function is partially applied. The composition
operator <code>(|-)</code> takes two functions <code>f</code> and
<code>g</code> and returns a new function that first applies
<code>f</code>, then applies <code>g</code> to the result.</p>
<h4 id="power-function">Power Function</h4>
<p>Now we define iterated function composition:</p>
<p><span class="math display">
f^n(x) := \underbrace{(f \circ \cdots \circ f)}_{n \text{ times}}(x)
</span></p>
<p>In OCaml, we first define the backward composition operator, then use
it in <code>power</code>:</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (-|) f g x = f (g x)</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> power f n =</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> (<span class="kw">fun</span> x -&gt; x) <span class="kw">else</span> f -| power f (n<span class="dv">-1</span>)</span></code></pre></div>
<p>When <code>n &lt;= 0</code>, we return the identity function.
Otherwise, we compose <code>f</code> with <code>power f (n-1)</code>,
which gives us one more application of <code>f</code>.</p>
<h4 id="numerical-derivative">Numerical Derivative</h4>
<p>Using <code>power</code>, we can define a numerical approximation of
the derivative:</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> derivative dx f = <span class="kw">fun</span> x -&gt; (f(x +. dx) -. f(x)) /. dx</span></code></pre></div>
<p>This definition emphasizes that <code>derivative dx f</code> is
itself a function of <code>x</code>. We can write it more concisely
as:</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> derivative dx f x = (f(x +. dx) -. f(x)) /. dx</span></code></pre></div>
<p>Note that OCaml uses different operators for floating-point
arithmetic. We have <code>(+): int -&gt; int -&gt; int</code> for
integers, so we cannot use <code>+</code> with floating-point numbers.
Instead, operators followed by a dot work on <code>float</code> values:
<code>+.</code>, <code>-.</code>, <code>*.</code>, <code>/.</code>.</p>
<h4 id="computing-higher-order-derivatives">Computing Higher-Order
Derivatives</h4>
<p>With <code>power</code> and <code>derivative</code>, we can easily
compute higher-order derivatives:</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pi = <span class="fl">4.0</span> *. <span class="dt">atan</span> <span class="fl">1.0</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> sin&#39;&#39;&#39; = (power (derivative <span class="fl">1e-5</span>) <span class="dv">3</span>) <span class="dt">sin</span>;;</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>sin&#39;&#39;&#39; pi</span></code></pre></div>
<p>Here <code>sin'''</code> is the third derivative of sine. The result
should be approximately <span class="math inline">-\cos(\pi) = 1</span>
(with some numerical error due to the finite difference
approximation).</p>
<h3 id="evaluation-rules-reduction-semantics">3.2 Evaluation Rules
(Reduction Semantics)</h3>
<p>To understand how OCaml programs compute their results, we need to
formalize the evaluation process. This section presents
<strong>reduction semantics</strong>, which describes computation as a
series of rewriting steps.</p>
<h4 id="expressions">Expressions</h4>
<p>Programs consist of <strong>expressions</strong>. Here is the grammar
of expressions for a simplified version of OCaml:</p>
<p><span class="math display">
\begin{array}{lcll}
a &amp; := &amp; x &amp; \text{variables} \\
  &amp; |  &amp; \texttt{fun } x \texttt{ -&gt; } a &amp;
\text{(defined) functions} \\
  &amp; |  &amp; a \; a &amp; \text{applications} \\
  &amp; |  &amp; C^0 &amp; \text{value constructors of arity } 0 \\
  &amp; |  &amp; C^n(a, \ldots, a) &amp; \text{value constructors of
arity } n \\
  &amp; |  &amp; f^n &amp; \text{built-in values (primitives) of arity }
n \\
  &amp; |  &amp; \texttt{let } x = a \texttt{ in } a &amp; \text{name
bindings (local definitions)} \\
  &amp; |  &amp; \texttt{match } a \texttt{ with} &amp; \\
  &amp;    &amp; \quad p \texttt{ -&gt; } a \texttt{ | } \cdots \texttt{
| } p \texttt{ -&gt; } a &amp; \text{pattern matching} \\[1em]
p &amp; := &amp; x &amp; \text{pattern variables} \\
  &amp; |  &amp; (p, \ldots, p) &amp; \text{tuple patterns} \\
  &amp; |  &amp; C^0 &amp; \text{variant patterns of arity } 0 \\
  &amp; |  &amp; C^n(p, \ldots, p) &amp; \text{variant patterns of arity
} n
\end{array}
</span></p>
<p><strong>Arity</strong> means how many arguments something requires
(and for tuples, the length of the tuple).</p>
<h4 id="the-fix-primitive">The <code>fix</code> Primitive</h4>
<p>To simplify our presentation of recursion, we use a primitive
<code>fix</code> to define a limited form of <code>let rec</code>:</p>
<p><span class="math display">
\texttt{let rec } f \; x = e_1 \texttt{ in } e_2 \equiv \texttt{let } f
= \texttt{fix (fun } f \; x \texttt{ -&gt; } e_1 \texttt{) in } e_2
</span></p>
<p>The <code>fix</code> primitive captures the essence of recursion: it
takes a function that expects to receive itself as an argument and
produces a fixed point—a function that, when called, behaves as if it
had access to itself.</p>
<h4 id="values">Values</h4>
<p>Expressions evaluate (i.e., compute) to <strong>values</strong>.
Values are expressions that cannot be reduced further:</p>
<p><span class="math display">
\begin{array}{lcll}
v &amp; := &amp; \texttt{fun } x \texttt{ -&gt; } a &amp;
\text{(defined) functions} \\
  &amp; |  &amp; C^n(v_1, \ldots, v_n) &amp; \text{constructed values}
\\
  &amp; |  &amp; f^n \; v_1 \; \cdots \; v_k &amp; k &lt; n \text{
(partially applied primitives)}
\end{array}
</span></p>
<p>Note that functions are values: <code>fun x -&gt; x + 1</code> is
already fully evaluated. Partially applied primitives like
<code>(+) 3</code> are also values—they are waiting for more
arguments.</p>
<h4 id="substitution">Substitution</h4>
<p>To <strong>substitute</strong> a value <span
class="math inline">v</span> for a variable <span
class="math inline">x</span> in expression <span
class="math inline">a</span>, we write <span class="math inline">a[x :=
v]</span>. This notation means that every occurrence of <span
class="math inline">x</span> in <span class="math inline">a</span> is
replaced by <span class="math inline">v</span>.</p>
<p>In the actual implementation, the value <span
class="math inline">v</span> is not duplicated in memory. Instead, OCaml
uses references or closures to share the value efficiently.</p>
<h4 id="reduction-rules-redexes">Reduction Rules (Redexes)</h4>
<p>Reduction (i.e., computation) proceeds by finding reducible
expressions called <strong>redexes</strong> and applying reduction
rules. Here are the fundamental redexes:</p>
<p><strong>Function application (beta reduction):</strong> <span
class="math display">
(\texttt{fun } x \texttt{ -&gt; } a) \; v \rightsquigarrow a[x := v]
</span></p>
<p>When we apply a function to a value, we substitute the value for the
parameter in the function body.</p>
<p><strong>Let binding:</strong> <span class="math display">
\texttt{let } x = v \texttt{ in } a \rightsquigarrow a[x := v]
</span></p>
<p>A let binding with a value substitutes that value into the body.</p>
<p><strong>Primitive application:</strong> <span class="math display">
f^n \; v_1 \; \cdots \; v_n \rightsquigarrow f(v_1, \ldots, v_n)
</span></p>
<p>When a primitive receives all its arguments, it computes the result.
Here <span class="math inline">f(v_1, \ldots, v_n)</span> denotes the
actual result of the primitive operation.</p>
<p><strong>Pattern matching with a variable pattern:</strong> <span
class="math display">
\texttt{match } v \texttt{ with } x \texttt{ -&gt; } a \texttt{ | }
\cdots \rightsquigarrow a[x := v]
</span></p>
<p><strong>Pattern matching with a non-matching constructor:</strong>
<span class="math display">
\frac{C_1 \neq C_2}{\texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{
with } C_2^k(p_1, \ldots, p_k) \texttt{ -&gt; } a \texttt{ | } pm
\rightsquigarrow \texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{ with }
pm}
</span></p>
<p>If the constructor does not match, we try the next pattern.</p>
<p><strong>Pattern matching with a matching constructor:</strong> <span
class="math display">
\texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{ with } C_1^n(x_1,
\ldots, x_n) \texttt{ -&gt; } a \texttt{ | } \cdots \rightsquigarrow
a[x_1 := v_1; \ldots; x_n := v_n]
</span></p>
<p>If the constructor matches, we substitute all the bound values.</p>
<p>If <span class="math inline">n = 0</span>, then <span
class="math inline">C_1^n(v_1, \ldots, v_n)</span> stands for simply
<span class="math inline">C_1^0</span>, a constructor with no arguments.
We omit the more complex cases of nested pattern matching.</p>
<h4 id="rule-variables">Rule Variables</h4>
<p>In these rules, the metavariables have specific meanings: - <span
class="math inline">x</span> matches any expression or pattern variable
- <span class="math inline">a, a_1, \ldots, a_n</span> match any
expression - <span class="math inline">v, v_1, \ldots, v_n</span> match
any value</p>
<p>To apply a rule, find substitutions for these metavariables that make
the left-hand side match your expression. The right-hand side (with the
same substitutions) is the reduced expression.</p>
<h4 id="evaluation-context-rules">Evaluation Context Rules</h4>
<p>The rules above only apply when the arguments are already values. We
also need rules that allow evaluation of subexpressions. If <span
class="math inline">a_i \rightsquigarrow a_i&#39;</span>, then:</p>
<p><span class="math display">
\begin{array}{lcl}
a_1 \; a_2 &amp; \rightsquigarrow &amp; a_1&#39; \; a_2 \\
a_1 \; a_2 &amp; \rightsquigarrow &amp; a_1 \; a_2&#39; \\
C^n(a_1, \ldots, a_i, \ldots, a_n) &amp; \rightsquigarrow &amp; C^n(a_1,
\ldots, a_i&#39;, \ldots, a_n) \\
\texttt{let } x = a_1 \texttt{ in } a_2 &amp; \rightsquigarrow &amp;
\texttt{let } x = a_1&#39; \texttt{ in } a_2 \\
\texttt{match } a_1 \texttt{ with } pm &amp; \rightsquigarrow &amp;
\texttt{match } a_1&#39; \texttt{ with } pm
\end{array}
</span></p>
<p>These rules say that: - In an application, either the function or the
argument can be evaluated (in arbitrary order) - In a constructor, any
argument can be evaluated - In a let binding, the bound expression is
evaluated before the body - In a match, the scrutinee is evaluated
before matching</p>
<h4 id="the-fix-rule">The <code>fix</code> Rule</h4>
<p>Finally, the rule for the <code>fix</code> primitive, which enables
recursion:</p>
<p><span class="math display">
\texttt{fix}^2 \; v_1 \; v_2 \rightsquigarrow v_1 \; (\texttt{fix}^2 \;
v_1) \; v_2
</span></p>
<p>Because <code>fix</code> is a binary primitive (arity 2), the
expression <span class="math inline">(\texttt{fix}^2 \; v_1)</span> is
already a value (a partially applied primitive). This means it will not
be further evaluated until it is applied inside <span
class="math inline">v_1</span>. This delayed evaluation is what makes
recursion work without infinite loops.</p>
<h4 id="practice">Practice</h4>
<p><strong>Exercise:</strong> Compute some simple programs by hand using
these rules. For example, trace the evaluation of:</p>
<div class="sourceCode" id="cb52"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> double x = x + x <span class="kw">in</span> double <span class="dv">3</span></span></code></pre></div>
<h3 id="symbolic-derivation-example">3.3 Symbolic Derivation
Example</h3>
<p>Let us see the reduction rules in action with a more complex example.
Consider the symbolic expression evaluator from
<code>Lec3.ml</code>:</p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> expression =</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>  | Const <span class="kw">of</span> <span class="dt">float</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>  | Var <span class="kw">of</span> <span class="dt">string</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>  | Sum <span class="kw">of</span> expression * expression    <span class="co">(* e1 + e2 *)</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>  | Diff <span class="kw">of</span> expression * expression   <span class="co">(* e1 - e2 *)</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>  | Prod <span class="kw">of</span> expression * expression   <span class="co">(* e1 * e2 *)</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>  | Quot <span class="kw">of</span> expression * expression   <span class="co">(* e1 / e2 *)</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a><span class="kw">exception</span> Unbound_variable <span class="kw">of</span> <span class="dt">string</span></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> eval env <span class="dt">exp</span> =</span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> <span class="dt">exp</span> <span class="kw">with</span></span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>  | Const c -&gt; c</span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>  | Var v -&gt;</span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">try</span> <span class="dt">List</span>.assoc v env <span class="kw">with</span> <span class="dt">Not_found</span> -&gt; <span class="dt">raise</span> (Unbound_variable v))</span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a>  | Sum(f, g) -&gt; eval env f +. eval env g</span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a>  | Diff(f, g) -&gt; eval env f -. eval env g</span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true" tabindex="-1"></a>  | Prod(f, g) -&gt; eval env f *. eval env g</span>
<span id="cb53-19"><a href="#cb53-19" aria-hidden="true" tabindex="-1"></a>  | Quot(f, g) -&gt; eval env f /. eval env g</span></code></pre></div>
<p>We can also define symbolic differentiation:</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> deriv <span class="dt">exp</span> dv =</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> <span class="dt">exp</span> <span class="kw">with</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>  | Const c -&gt; Const <span class="fl">0.0</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>  | Var v -&gt; <span class="kw">if</span> v = dv <span class="kw">then</span> Const <span class="fl">1.0</span> <span class="kw">else</span> Const <span class="fl">0.0</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>  | Sum(f, g) -&gt; Sum(deriv f dv, deriv g dv)</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>  | Diff(f, g) -&gt; Diff(deriv f dv, deriv g dv)</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>  | Prod(f, g) -&gt; Sum(Prod(f, deriv g dv), Prod(deriv f dv, g))</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>  | Quot(f, g) -&gt; Quot(Diff(Prod(deriv f dv, g), Prod(f, deriv g dv)),</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>                       Prod(g, g))</span></code></pre></div>
<p>For convenience, let us define some operators and variables:</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = Var <span class="st">&quot;x&quot;</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> y = Var <span class="st">&quot;y&quot;</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (+:) f g = Sum (f, g)</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (-:) f g = Diff (f, g)</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ( *: ) f g = Prod (f, g)</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (/:) f g = Quot (f, g)</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (!:) i = Const i</span></code></pre></div>
<p>Now consider evaluating the expression <code>3x + 2y + x^2 y</code>
at <span class="math inline">x = 1, y = 2</span>:</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> example = !:<span class="fl">3.0</span> *: x +: !:<span class="fl">2.0</span> *: y +: x *: x *: y</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> env = [<span class="st">&quot;x&quot;</span>, <span class="fl">1.0</span>; <span class="st">&quot;y&quot;</span>, <span class="fl">2.0</span>]</span></code></pre></div>
<p>When we trace the evaluation, we can see the recursive structure of
the computation:</p>
<pre><code>eval_1_2 &lt;-- 3.00 * x + 2.00 * y + x * x * y
  eval_1_2 &lt;-- x * x * y
    eval_1_2 &lt;-- y
    eval_1_2 --&gt; 2.
    eval_1_2 &lt;-- x * x
      eval_1_2 &lt;-- x
      eval_1_2 --&gt; 1.
      eval_1_2 &lt;-- x
      eval_1_2 --&gt; 1.
    eval_1_2 --&gt; 1.
  eval_1_2 --&gt; 2.
  eval_1_2 &lt;-- 3.00 * x + 2.00 * y
    eval_1_2 &lt;-- 2.00 * y
      eval_1_2 &lt;-- y
      eval_1_2 --&gt; 2.
      eval_1_2 &lt;-- 2.00
      eval_1_2 --&gt; 2.
    eval_1_2 --&gt; 4.
    eval_1_2 &lt;-- 3.00 * x
      eval_1_2 &lt;-- x
      eval_1_2 --&gt; 1.
      eval_1_2 &lt;-- 3.00
      eval_1_2 --&gt; 3.
    eval_1_2 --&gt; 3.
  eval_1_2 --&gt; 7.
eval_1_2 --&gt; 9.
- : float = 9.</code></pre>
<p>The indentation levels in this trace correspond to <strong>stack
frames</strong>—the runtime structures that store the state of each
function call. This brings us to an important optimization
technique.</p>
<h3 id="tail-calls-and-tail-recursion">3.4 Tail Calls and Tail
Recursion</h3>
<p>Computers normally evaluate programs by creating <strong>stack
frames</strong> on the call stack for each function call. The trace
above illustrates this: each level of indentation represents a new stack
frame.</p>
<h4 id="what-is-a-tail-call">What is a Tail Call?</h4>
<p>A <strong>tail call</strong> is a function call that is performed
last when computing a function—there is nothing more to do after the
call returns. For example, in:</p>
<pre><code>let f x = g (x + 1)</code></pre>
<p>The call to <code>g</code> is a tail call because after
<code>g</code> returns, <code>f</code> immediately returns that
value.</p>
<p>In contrast, in:</p>
<pre><code>let f x = 1 + g x</code></pre>
<p>The call to <code>g</code> is <em>not</em> a tail call because after
<code>g</code> returns, we still need to add 1 to the result.</p>
<h4 id="tail-call-optimization">Tail Call Optimization</h4>
<p>Functional language compilers (including OCaml’s) recognize tail
calls and optimize them. Instead of creating a new stack frame, they
reuse the current frame by performing a “jump” to the called function.
This means tail calls use constant stack space.</p>
<h4 id="tail-recursive-functions">Tail Recursive Functions</h4>
<p>A function is <strong>tail recursive</strong> if it calls itself (and
any mutually recursive functions it depends on) only using tail
calls.</p>
<p>Tail recursive functions often use special
<strong>accumulator</strong> arguments that store intermediate
computation results. In a non-tail-recursive function, these
intermediate results would be values of subexpressions stored on the
stack.</p>
<p>The key insight is that the accumulated result is computed in
“reverse order”—while climbing up the recursion (making calls) rather
than while descending (returning from calls).</p>
<h4 id="example-counting">Example: Counting</h4>
<p>Compare these two counting functions:</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> count n =</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> <span class="dv">1</span> + (count (n<span class="dv">-1</span>))</span></code></pre></div>
<p>This is <em>not</em> tail recursive because after the recursive call
returns, we still need to add 1.</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> count_tcall acc n =</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> acc <span class="kw">else</span> count_tcall (acc+<span class="dv">1</span>) (n<span class="dv">-1</span>)</span></code></pre></div>
<p>This <em>is</em> tail recursive: the recursive call is the last thing
the function does.</p>
<h4 id="example-building-lists">Example: Building Lists</h4>
<p>Let us see a more dramatic example:</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> unfold n = <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> [] <span class="kw">else</span> n :: unfold (n<span class="dv">-1</span>)</span></code></pre></div>
<p>This function builds a list counting down from <code>n</code>. It is
not tail recursive because after the recursive call, we must cons
<code>n</code> onto the result.</p>
<pre><code># unfold 100000;;
- : int list = [100000; 99999; 99998; 99997; ...]

# unfold 1000000;;
Stack overflow during evaluation (looping recursion?).</code></pre>
<p>With a million elements, we run out of stack space! Now consider the
tail-recursive version:</p>
<div class="sourceCode" id="cb64"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> unfold_tcall acc n =</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> acc <span class="kw">else</span> unfold_tcall (n::acc) (n<span class="dv">-1</span>)</span></code></pre></div>
<p>The accumulator <code>acc</code> collects the list as we go. Note
that the list is built in reverse order:</p>
<pre><code># unfold_tcall [] 100000;;
- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; ...]

# unfold_tcall [] 1000000;;
- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; ...]</code></pre>
<p>The tail-recursive version handles a million elements with no
problem.</p>
<h4 id="a-challenge-tree-depth">A Challenge: Tree Depth</h4>
<p>Is it possible to find the depth of a tree using a tail-recursive
function?</p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree = Tip | Node <span class="kw">of</span> <span class="dt">int</span> * btree * btree</span></code></pre></div>
<p>The naive approach:</p>
<div class="sourceCode" id="cb67"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> depth tree = <span class="kw">match</span> tree <span class="kw">with</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>  | Tip -&gt; <span class="dv">0</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>  | Node(_, left, right) -&gt; <span class="dv">1</span> + <span class="dt">max</span> (depth left) (depth right)</span></code></pre></div>
<p>This is not tail recursive: after both recursive calls, we still need
to compute <code>1 + max ...</code>. The challenge is that we have
<em>two</em> recursive calls, and we cannot simply use an
accumulator.</p>
<h4 id="note-on-lazy-languages">Note on Lazy Languages</h4>
<p>The issue of tail recursion is more complex for <strong>lazy</strong>
programming languages like Haskell. In a lazy language, the cons
operation <code>(:)</code> does not immediately evaluate its arguments,
so building a list with <code>n :: unfold (n-1)</code> does not consume
stack space in the same way.</p>
<h3 id="first-encounter-of-continuation-passing-style">3.5 First
Encounter of Continuation Passing Style</h3>
<p>We can solve the tree depth problem using <strong>Continuation
Passing Style (CPS)</strong>. The key idea is to postpone doing actual
work until the very last moment by passing around a “continuation”—a
function that represents “what to do next.”</p>
<div class="sourceCode" id="cb68"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> depth_cps tree k = <span class="kw">match</span> tree <span class="kw">with</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>  | Tip -&gt; k <span class="dv">0</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>  | Node(_, left, right) -&gt;</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>    depth_cps left (<span class="kw">fun</span> dleft -&gt;</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>      depth_cps right (<span class="kw">fun</span> dright -&gt;</span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>        k (<span class="dv">1</span> + (<span class="dt">max</span> dleft dright))))</span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> depth tree = depth_cps tree (<span class="kw">fun</span> d -&gt; d)</span></code></pre></div>
<p>Let us understand how this works:</p>
<ol type="1">
<li><p>The function takes an extra parameter <code>k</code>, called the
<strong>continuation</strong>. It represents what to do with the final
result.</p></li>
<li><p>In the <code>Tip</code> case, we call the continuation with the
depth 0.</p></li>
<li><p>In the <code>Node</code> case, we recursively compute the depth
of the left subtree, passing a continuation that:</p>
<ul>
<li>Receives the left depth <code>dleft</code></li>
<li>Then recursively computes the depth of the right subtree, passing a
continuation that:
<ul>
<li>Receives the right depth <code>dright</code></li>
<li>Finally calls the original continuation with
<code>1 + max dleft dright</code></li>
</ul></li>
</ul></li>
<li><p>The wrapper function passes the identity function
<code>fun d -&gt; d</code> as the initial continuation.</p></li>
</ol>
<p>The magic is that each recursive call is now a tail call! The “work”
of computing <code>1 + max dleft dright</code> is captured in the
continuation closures, which are allocated on the heap rather than the
stack.</p>
<p>However, this does not completely solve the stack overflow problem—we
are trading stack space for heap space (storing the continuation
closures). For very deep trees, we might still run out of memory. True
solutions involve trampolining or iterative approaches with explicit
stacks.</p>
<p>CPS is a powerful technique that appears throughout functional
programming. We will encounter it again when studying monads and
advanced control flow.</p>
<h3 id="exercises-2">3.6 Exercises</h3>
<p><strong>Exercise 1:</strong> By “traverse a tree” below we mean:
write a function that takes a tree and returns a list of values in the
nodes of the tree.</p>
<ol type="1">
<li><p>Write a function (of type <code>btree -&gt; int list</code>) that
traverses a binary tree in <strong>prefix order</strong>—first the value
stored in a node, then values in all nodes to the left, then values in
all nodes to the right.</p></li>
<li><p>Write a traversal in <strong>infix order</strong>—first values in
all nodes to the left, then the value stored in the node, then values in
all nodes to the right (so it is “left-to-right” order).</p></li>
<li><p>Write a traversal in <strong>breadth-first order</strong>—first
values in shallower nodes before deeper nodes.</p></li>
</ol>
<p><strong>Exercise 2:</strong> Turn the function from Exercise 1
(prefix or infix traversal) into continuation passing style.</p>
<p><strong>Exercise 3:</strong> Do the homework from the end of Chapter
2: write <code>btree_deriv_at</code> that takes a predicate over
integers and a <code>btree</code>, and builds a <code>btree_deriv</code>
whose “hole” is in the first position for which the predicate returns
true.</p>
<p><strong>Exercise 4:</strong> Write a function
<code>simplify: expression -&gt; expression</code> that simplifies
symbolic expressions, so that for example the result of
<code>simplify (deriv exp dv)</code> looks more like what a human would
get computing the derivative of <code>exp</code> with respect to
<code>dv</code>.</p>
<ul>
<li>Write a <code>simplify_once</code> function that performs a single
step of simplification.</li>
<li>Wrap it using a general <code>fixpoint</code> function that performs
an operation until a <strong>fixed point</strong> is reached: given
<span class="math inline">f</span> and <span
class="math inline">x</span>, it computes <span
class="math inline">f^n(x)</span> such that <span
class="math inline">f^n(x) = f^{n+1}(x)</span>.</li>
</ul>
<p><strong>Exercise 5:</strong> Write two sorting algorithms working on
lists: merge sort and quicksort.</p>
<ol type="1">
<li><p><strong>Merge sort</strong> splits the list roughly in half,
sorts the parts recursively, and merges the sorted parts into the sorted
result.</p></li>
<li><p><strong>Quicksort</strong> splits the list into elements smaller
than and greater than (or equal to) the first element, sorts the parts
recursively, and concatenates them.</p></li>
</ol>
<h2 id="chapter-4-functions">Chapter 4: Functions</h2>
<p><em>Programming in untyped lambda-calculus</em></p>
<p>This chapter explores the theoretical foundations of functional
programming through the untyped lambda-calculus. We begin with a review
of computation by hand using our reduction semantics, then introduce the
lambda-calculus notation and show how to encode fundamental data
types—booleans, pairs, and natural numbers—using only functions. The
chapter concludes with an examination of recursion through fixpoint
combinators and practical considerations for avoiding infinite loops in
eager evaluation.</p>
<p><strong>References:</strong></p>
<ul>
<li>“Introduction to Lambda Calculus” by Henk Barendregt and Erik
Barendsen</li>
<li>“Lecture Notes on the Lambda Calculus” by Peter Selinger</li>
</ul>
<h3 id="review-computation-by-hand">4.1 Review: Computation by Hand</h3>
<p>Before diving into the lambda-calculus, let us work through a
complete example of evaluation using the reduction rules from Chapter 3.
This exercise reinforces our understanding of how computation proceeds
and prepares us for the more abstract setting of lambda-calculus.</p>
<p>Recall that we use <code>fix</code> instead of <code>let rec</code>
to simplify rules for recursion. Also remember our syntactic
conventions: <code>fun x y -&gt; e</code> stands for
<code>fun x -&gt; (fun y -&gt; e)</code>, and so forth.</p>
<p>Consider the following recursive <code>length</code> function applied
to a two-element list:</p>
<pre><code>let rec fix f x = f (fix f) x

type int_list = Nil | Cons of int * int_list

let length =
  fix (fun f l -&gt;
    match l with
      | Nil -&gt; 0
      | Cons (x, xs) -&gt; 1 + f xs)

length (Cons (1, (Cons (2, Nil))))</code></pre>
<p>Let us trace through this computation step by step. First, we
eliminate the <code>let</code> binding:</p>
<p><span class="math display">\texttt{let } x = v \texttt{ in } a
\Downarrow a[x := v]</span></p>
<p>This gives us:</p>
<pre><code>fix (fun f l -&gt;
    match l with
      | Nil -&gt; 0
      | Cons (x, xs) -&gt; 1 + f xs) (Cons (1, (Cons (2, Nil))))</code></pre>
<p>Next, we apply the <code>fix</code> rule:</p>
<p><span class="math display">\texttt{fix}^2 \; v_1 \; v_2 \Downarrow
v_1 \; (\texttt{fix}^2 \; v_1) \; v_2</span></p>
<p>This unfolds to:</p>
<pre><code>(fun f l -&gt;
    match l with
      | Nil -&gt; 0
      | Cons (x, xs) -&gt; 1 + f xs)
    (fix (fun f l -&gt;
      match l with
        | Nil -&gt; 0
        | Cons (x, xs) -&gt; 1 + f xs))
    (Cons (1, (Cons (2, Nil))))</code></pre>
<p>Function application reduces according to:</p>
<p><span class="math display">(\texttt{fun } x \texttt{ -&gt; } a) \; v
\rightsquigarrow a[x := v]</span></p>
<p>After substituting both <code>f</code> and <code>l</code>, we
get:</p>
<pre><code>(match Cons (1, (Cons (2, Nil))) with
    | Nil -&gt; 0
    | Cons (x, xs) -&gt; 1 + (fix (fun f l -&gt;
      match l with
        | Nil -&gt; 0
        | Cons (x, xs) -&gt; 1 + f xs)) xs)</code></pre>
<p>Pattern matching against a non-matching constructor moves to the next
branch:</p>
<p><span class="math display">
\begin{aligned}
&amp; \texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{ with} \\
&amp; C_2^n(p_1, \ldots, p_k) \texttt{ -&gt; } a \texttt{ | } pm
\Downarrow \texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{ with } pm
\end{aligned}
</span></p>
<p>Pattern matching against a matching constructor performs
substitution:</p>
<p><span class="math display">
\begin{aligned}
&amp; \texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{ with} \\
&amp; C_1^n(x_1, \ldots, x_n) \texttt{ -&gt; } a \texttt{ | } \ldots
\Downarrow a[x_1 := v_1; \ldots; x_n := v_n]
\end{aligned}
</span></p>
<p>After matching and substitution:</p>
<pre><code>1 + (fix (fun f l -&gt;
      match l with
        | Nil -&gt; 0
        | Cons (x, xs) -&gt; 1 + f xs)) (Cons (2, Nil))</code></pre>
<p>Continuing the evaluation, we apply <code>fix</code> again and work
through the pattern match for <code>Cons (2, Nil)</code>, eventually
reaching:</p>
<pre><code>1 + (1 + (fix (fun f l -&gt;
             match l with
               | Nil -&gt; 0
               | Cons (x, xs) -&gt; 1 + f xs)) Nil)</code></pre>
<p>One more unfolding and pattern match against <code>Nil</code>
gives:</p>
<pre><code>1 + (1 + 0)</code></pre>
<p>Finally, applying the built-in addition:</p>
<p><span class="math display">f^n \; v_1 \; \ldots \; v_n \Downarrow
f(v_1, \ldots, v_n)</span></p>
<p>We obtain the result: <code>2</code>.</p>
<h3 id="language-and-rules-of-the-untyped-lambda-calculus">4.2 Language
and Rules of the Untyped Lambda-Calculus</h3>
<p>The lambda-calculus, introduced by Alonzo Church in the 1930s, is a
minimal formal system for expressing computation. To work with it, we
first simplify our language:</p>
<ol type="1">
<li><p><strong>Forget about types.</strong> In pure lambda-calculus,
there is no type system constraining which terms can be
combined.</p></li>
<li><p><strong>Introduce notation.</strong> We write <span
class="math inline">\lambda x.a</span> for <code>fun x -&gt; a</code>,
and <span class="math inline">\lambda xy.a</span> for
<code>fun x y -&gt; a</code>, and so forth.</p></li>
<li><p><strong>Reduce to essentials.</strong> We keep only functions
(lambda abstractions) and variables—no constructors, no built-in
primitives.</p></li>
</ol>
<p>The core reduction rule of lambda-calculus is called <strong><span
class="math inline">\beta</span>-reduction</strong>:</p>
<p><span class="math display">(\texttt{fun } x \texttt{ -&gt; } a_1) \;
a_2 \rightsquigarrow a_1[x := a_2]</span></p>
<p>Note that this rule is more general than the one we use for OCaml
evaluation. In our OCaml semantics, we require the argument to be a
value: <span class="math inline">(\texttt{fun } x \texttt{ -&gt; } a) \;
v \rightsquigarrow a[x := v]</span>. The general <span
class="math inline">\beta</span>-reduction rule allows substituting any
expression, not just values.</p>
<p>Lambda-calculus also uses <strong><span
class="math inline">\alpha</span>-conversion</strong> (bound variable
renaming), or equivalent techniques, to avoid <strong>variable
capture</strong>—the unintended binding of free variables during
substitution. We will explore <span
class="math inline">\beta</span>-reduction further in the chapter on
laziness.</p>
<p>Why is <span class="math inline">\beta</span>-reduction more general
than our evaluation rule? Consider the expression <span
class="math inline">(\lambda x. x) \; ((\lambda y. y) \; z)</span>. With
<span class="math inline">\beta</span>-reduction, we could reduce the
outer application first, obtaining <span class="math inline">((\lambda
y. y) \; z)</span>. Our evaluation rule would require first reducing the
argument to a value.</p>
<h3 id="booleans">4.3 Booleans</h3>
<p>Alonzo Church introduced lambda-calculus to encode logic. There are
multiple ways to encode various sorts of data in lambda-calculus, though
not all of them work well in a typed setting—the straightforward
encode/decode functions may not type-check.</p>
<p>The <strong>Church encoding</strong> of booleans represents truth
values as selector functions:</p>
<ul>
<li><strong>True</strong> selects the first argument:
<code>c_true</code> <span class="math inline">= \lambda xy.x</span></li>
<li><strong>False</strong> selects the second argument:
<code>c_false</code> <span class="math inline">= \lambda
xy.y</span></li>
</ul>
<p>In OCaml syntax:</p>
<div class="sourceCode" id="cb76"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c_true = <span class="kw">fun</span> x y -&gt; x   <span class="co">(* &quot;True&quot; is projection on the first argument *)</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c_false = <span class="kw">fun</span> x y -&gt; y  <span class="co">(* And &quot;false&quot; on the second argument *)</span></span></code></pre></div>
<p>Logical conjunction can be defined as:</p>
<p><span class="math display">\texttt{c\_and} = \lambda xy. x \; y \;
\texttt{c\_false}</span></p>
<p>The logic is: if <code>x</code> is true, return <code>y</code> (so
the result is true only if both are true); if <code>x</code> is false,
return false immediately.</p>
<div class="sourceCode" id="cb77"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c_and = <span class="kw">fun</span> x y -&gt; x y c_false  <span class="co">(* If one is false, then return false *)</span></span></code></pre></div>
<p>Let us verify this works. For <code>c_and c_true c_true</code>:</p>
<p><span class="math display">(\lambda xy. x \; y \; \texttt{c\_false})
\; (\lambda xy.x) \; (\lambda xy.x)</span></p>
<p>reduces to:</p>
<p><span class="math display">(\lambda xy.x) \; (\lambda xy.x) \;
\texttt{c\_false}</span></p>
<p>which gives us <span class="math inline">\lambda xy.x</span> =
<code>c_true</code>. For any other combination involving
<code>c_false</code>, the result is <code>c_false</code>.</p>
<p>To verify our encodings in OCaml, we need encode and decode
functions:</p>
<div class="sourceCode" id="cb78"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> encode_bool b = <span class="kw">if</span> b <span class="kw">then</span> c_true <span class="kw">else</span> c_false</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> decode_bool c = c <span class="kw">true</span> <span class="kw">false</span>  <span class="co">(* Test the functions in the toplevel *)</span></span></code></pre></div>
<p><strong>Exercise:</strong> Define <code>c_or</code> and
<code>c_not</code> yourself!</p>
<h3 id="if-then-else-and-pairs">4.4 If-then-else and Pairs</h3>
<p>From now on, we will use OCaml syntax for our lambda-calculus
programs. An important observation is that our encoded booleans already
implement conditional selection:</p>
<div class="sourceCode" id="cb79"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> if_then_else = <span class="kw">fun</span> b -&gt; b  <span class="co">(* Booleans select the argument! *)</span></span></code></pre></div>
<p>Since <code>c_true</code> returns its first argument and
<code>c_false</code> returns its second,
<code>if_then_else b then_branch else_branch</code> simply applies
<code>b</code> to the two branches. Remember to play with these
functions in the toplevel to build intuition.</p>
<h4 id="pairs">Pairs</h4>
<p>Pairs (ordered tuples of two elements) can be encoded similarly:</p>
<div class="sourceCode" id="cb80"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c_pair m n = <span class="kw">fun</span> x -&gt; x m n  <span class="co">(* We couple things *)</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c_first = <span class="kw">fun</span> p -&gt; p c_true  <span class="co">(* by passing them together *)</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c_second = <span class="kw">fun</span> p -&gt; p c_false  <span class="co">(* Check that it works! *)</span></span></code></pre></div>
<p>A pair is a function that, when given a selector, applies that
selector to both components. To extract the first component, we pass
<code>c_true</code> (which selects the first argument); to extract the
second, we pass <code>c_false</code>.</p>
<p>For verification:</p>
<div class="sourceCode" id="cb81"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> encode_pair enc_fst enc_snd (a, b) =</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>  c_pair (enc_fst a) (enc_snd b)</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> decode_pair de_fst de_snd c = c (<span class="kw">fun</span> x y -&gt; de_fst x, de_snd y)</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> decode_bool_pair c = decode_pair decode_bool decode_bool c</span></code></pre></div>
<p>We can define larger tuples in the same manner:</p>
<div class="sourceCode" id="cb82"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c_triple l m n = <span class="kw">fun</span> x -&gt; x l m n</span></code></pre></div>
<h3 id="pair-encoded-natural-numbers">4.5 Pair-Encoded Natural
Numbers</h3>
<p>Our first encoding of natural numbers uses nested pairs. The
representation is based on the depth of nested pairs whose rightmost
leaf is the identity function <span class="math inline">\lambda
x.x</span> and whose left elements are <code>c_false</code>.</p>
<div class="sourceCode" id="cb83"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pn0 = <span class="kw">fun</span> x -&gt; x           <span class="co">(* Start with the identity function *)</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pn_succ n = c_pair c_false n  <span class="co">(* Stack another pair *)</span></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pn_pred = <span class="kw">fun</span> x -&gt; x c_false  <span class="co">(* Extract the nested number *)</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pn_is_zero = <span class="kw">fun</span> x -&gt; x c_true  <span class="co">(* Check if it&#39;s the base case *)</span></span></code></pre></div>
<p>The number 0 is represented as the identity function. The number 1 is
<code>c_pair c_false pn0</code>, the number 2 is
<code>c_pair c_false (c_pair c_false pn0)</code>, and so on. The
<code>pn_is_zero</code> function works because: - For <code>pn0</code>,
applying it to <code>c_true</code> gives <code>c_true</code> (since
<code>pn0</code> is the identity). - For any successor, applying
<code>c_pair c_false n</code> to <code>c_true</code> applies the pair to
<code>c_true</code>, which selects <code>c_false</code>.</p>
<p>We program in untyped lambda-calculus as an exercise, and we need
encoding/decoding to verify our exercises. Using <code>Obj.magic</code>
to bypass the type system for encoding/decoding is “fair game”:</p>
<div class="sourceCode" id="cb84"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> encode_pnat n =                <span class="co">(* We use Obj.magic to forget types *)</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> <span class="dt">Obj</span>.magic pn0</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> pn_succ (<span class="dt">Obj</span>.magic (encode_pnat (n<span class="dv">-1</span>)))  <span class="co">(* Disregarding types, *)</span></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> decode_pnat pn =               <span class="co">(* these functions are straightforward! *)</span></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> decode_bool (pn_is_zero pn) <span class="kw">then</span> <span class="dv">0</span></span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> <span class="dv">1</span> + decode_pnat (pn_pred (<span class="dt">Obj</span>.magic pn))</span></code></pre></div>
<h3 id="church-numerals">4.6 Church Numerals</h3>
<p>Do you remember our function <code>power f n</code> from Chapter 3?
We will use a similar idea for a different representation of numbers.
<strong>Church numerals</strong> represent a natural number <span
class="math inline">n</span> as a function that applies its first
argument <span class="math inline">n</span> times to its second
argument:</p>
<div class="sourceCode" id="cb85"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn0 = <span class="kw">fun</span> f x -&gt; x        <span class="co">(* The same as c_false *)</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn1 = <span class="kw">fun</span> f x -&gt; f x      <span class="co">(* Behaves like identity when f = id *)</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn2 = <span class="kw">fun</span> f x -&gt; f (f x)</span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn3 = <span class="kw">fun</span> f x -&gt; f (f (f x))</span></code></pre></div>
<p>This is the original Alonzo Church encoding. The number <span
class="math inline">n</span> is represented as <span
class="math inline">\lambda fx. f^n(x)</span>, where <span
class="math inline">f^n</span> denotes <span
class="math inline">n</span>-fold composition.</p>
<p>The successor function adds one more application of
<code>f</code>:</p>
<div class="sourceCode" id="cb86"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn_succ = <span class="kw">fun</span> n f x -&gt; f (n f x)</span></code></pre></div>
<p><strong>Exercise:</strong> Define addition, multiplication, comparing
to zero, and the predecessor function “-1” for Church numerals.</p>
<p>It turns out even Alonzo Church could not define predecessor right
away! His student Stephen Kleene eventually found it. Try to make some
progress before looking at the solution below.</p>
<div class="sourceCode" id="cb87"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (-|) f g x = f (g x)  <span class="co">(* Backward composition operator *)</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> encode_cnat n f =</span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> (<span class="kw">fun</span> x -&gt; x) <span class="kw">else</span> f -| encode_cnat (n<span class="dv">-1</span>) f</span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> decode_cnat n = n ((+) <span class="dv">1</span>) <span class="dv">0</span></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn7 f x = encode_cnat <span class="dv">7</span> f x   <span class="co">(* We need to eta-expand these definitions *)</span></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn13 f x = encode_cnat <span class="dv">13</span> f x  <span class="co">(* for type-system reasons *)</span></span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a>                                   <span class="co">(* (because OCaml allows side-effects) *)</span></span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn_add = <span class="kw">fun</span> n m f x -&gt; n f (m f x)  <span class="co">(* Put n of f in front *)</span></span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn_mult = <span class="kw">fun</span> n m f -&gt; n (m f)       <span class="co">(* Repeat n times *)</span></span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a>                                          <span class="co">(* putting m of f in front *)</span></span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn_prev n =</span>
<span id="cb87-13"><a href="#cb87-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fun</span> f x -&gt;                  <span class="co">(* This is the &quot;Church numeral signature&quot; *)</span></span>
<span id="cb87-14"><a href="#cb87-14" aria-hidden="true" tabindex="-1"></a>    n                         <span class="co">(* The only thing we have is an n-step loop *)</span></span>
<span id="cb87-15"><a href="#cb87-15" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">fun</span> g v -&gt; v (g f))    <span class="co">(* We need sth that operates on f *)</span></span>
<span id="cb87-16"><a href="#cb87-16" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">fun</span> z -&gt; x)            <span class="co">(* We need to ignore the innermost step *)</span></span>
<span id="cb87-17"><a href="#cb87-17" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">fun</span> z -&gt; z)            <span class="co">(* We&#39;ve built a &quot;machine&quot; not results -- start the machine *)</span></span></code></pre></div>
<p>The predecessor function is ingenious. It builds up a chain of
functions that, when “started” with the identity, yields <span
class="math inline">n-1</span> applications of <code>f</code>. The key
insight is to delay the actual application of <code>f</code> and skip
the first one.</p>
<p><code>cn_is_zero</code> is left as an exercise.</p>
<h4 id="tracing-cn_prev-cn3">Tracing <code>cn_prev cn3</code></h4>
<p>Let us trace through <code>decode_cnat (cn_prev cn3)</code>:</p>
<p><span class="math display">\Downarrow</span></p>
<pre><code>(cn_prev cn3) ((+) 1) 0</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>(fun f x -&gt;
    cn3
      (fun g v -&gt; v (g f))
      (fun z -&gt; x)
      (fun z -&gt; z)) ((+) 1) 0</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>((fun f x -&gt; f (f (f x)))
      (fun g v -&gt; v (g ((+) 1)))
      (fun z -&gt; 0)
      (fun z -&gt; z))</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>((fun g v -&gt; v (g ((+) 1)))
  ((fun g v -&gt; v (g ((+) 1)))
    ((fun g v -&gt; v (g ((+) 1)))
      (fun z -&gt; 0))))
  (fun z -&gt; z))</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>((fun z -&gt; z)
  (((fun g v -&gt; v (g ((+) 1)))
    ((fun g v -&gt; v (g ((+) 1)))
      (fun z -&gt; 0)))) ((+) 1)))</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>(fun g v -&gt; v (g ((+) 1)))
  ((fun g v -&gt; v (g ((+) 1)))
    (fun z -&gt; 0)) ((+) 1)</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>((+) 1) ((fun g v -&gt; v (g ((+) 1)))
          (fun z -&gt; 0) ((+) 1))</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>((+) 1) (((+) 1) ((fun z -&gt; 0) ((+) 1)))</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>((+) 1) (((+) 1) (0))</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>((+) 1) 1</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>2</code></pre>
<h3 id="recursion-fixpoint-combinators">4.7 Recursion: Fixpoint
Combinators</h3>
<p>In lambda-calculus, recursion is achieved through <strong>fixpoint
combinators</strong>—lambda terms that compute fixed points of
functions.</p>
<h4 id="turings-fixpoint-combinator">Turing’s Fixpoint Combinator</h4>
<p><span class="math display">\Theta = (\lambda xy. y \; (x \; x \; y))
\; (\lambda xy. y \; (x \; x \; y))</span></p>
<p>Let us verify it computes fixed points. Define <span
class="math inline">N = \Theta F</span>:</p>
<p><span class="math display">
\begin{aligned}
N &amp;= \Theta F \\
&amp;= (\lambda xy. y \; (x \; x \; y)) \; (\lambda xy. y \; (x \; x \;
y)) \; F \\
&amp;=_{\rightarrow\rightarrow} F \; ((\lambda xy. y \; (x \; x \; y))
\; (\lambda xy. y \; (x \; x \; y)) \; F) \\
&amp;= F \; (\Theta F) = F \; N
\end{aligned}
</span></p>
<p>So <span class="math inline">N = F \; N</span>, meaning <span
class="math inline">N</span> is a fixed point of <span
class="math inline">F</span>.</p>
<h4 id="currys-fixpoint-combinator-y-combinator">Curry’s Fixpoint
Combinator (Y Combinator)</h4>
<p><span class="math display">\mathbf{Y} = \lambda f. (\lambda x. f \;
(x \; x)) \; (\lambda x. f \; (x \; x))</span></p>
<p><span class="math display">
\begin{aligned}
N &amp;= \mathbf{Y} F \\
&amp;= (\lambda f. (\lambda x. f \; (x \; x)) \; (\lambda x. f \; (x \;
x))) \; F \\
&amp;=_{\rightarrow} (\lambda x. F \; (x \; x)) \; (\lambda x. F \; (x
\; x)) \\
&amp;=_{\rightarrow} F \; ((\lambda x. F \; (x \; x)) \; (\lambda x. F
\; (x \; x))) \\
&amp;=_{\leftarrow} F \; ((\lambda f. (\lambda x. f \; (x \; x)) \;
(\lambda x. f \; (x \; x))) \; F) \\
&amp;= F \; (\mathbf{Y} F) = F \; N
\end{aligned}
</span></p>
<h4 id="call-by-value-fixpoint-combinator">Call-by-Value Fixpoint
Combinator</h4>
<p><span class="math display">\texttt{fix} = \lambda f&#39;. (\lambda
fx. f&#39; \; (f \; f) \; x) \; (\lambda fx. f&#39; \; (f \; f) \;
x)</span></p>
<p><span class="math display">
\begin{aligned}
N &amp;= \texttt{fix} \; F \\
&amp;= (\lambda f&#39;. (\lambda fx. f&#39; \; (f \; f) \; x) \;
(\lambda fx. f&#39; \; (f \; f) \; x)) \; F \\
&amp;=_{\rightarrow} (\lambda fx. F \; (f \; f) \; x) \; (\lambda fx. F
\; (f \; f) \; x) \\
&amp;=_{\rightarrow} \lambda x. F \; ((\lambda fx. F \; (f \; f) \; x)
\; (\lambda fx. F \; (f \; f) \; x)) \; x \\
&amp;=_{\leftarrow} \lambda x. F \; ((\lambda f&#39;. (\lambda fx.
f&#39; \; (f \; f) \; x) \; (\lambda fx. f&#39; \; (f \; f) \; x)) \; F)
\; x \\
&amp;= \lambda x. F \; (\texttt{fix} \; F) \; x = \lambda x. F \; N \; x
\\
&amp;=_{\eta} F \; N
\end{aligned}
</span></p>
<h4 id="the-problem-with-the-first-two-combinators">The Problem with the
First Two Combinators</h4>
<p>What is the problem with Turing’s and Curry’s combinators? Consider
what happens when we try to evaluate <span class="math inline">\Theta
F</span>:</p>
<p><span class="math display">
\begin{aligned}
\Theta F &amp;\rightsquigarrow\rightsquigarrow F \; ((\lambda xy. y \;
(x \; x \; y)) \; (\lambda xy. y \; (x \; x \; y)) \; F) \\
&amp;\rightsquigarrow\rightsquigarrow F \; (F \; ((\lambda xy. y \; (x
\; x \; y)) \; (\lambda xy. y \; (x \; x \; y)) \; F)) \\
&amp;\rightsquigarrow\rightsquigarrow F \; (F \; (F \; ((\lambda xy. y
\; (x \; x \; y)) \; (\lambda xy. y \; (x \; x \; y)) \; F))) \\
&amp;\rightsquigarrow\rightsquigarrow \ldots
\end{aligned}
</span></p>
<p>Recall the distinction between <em>expressions</em> and
<em>values</em> from Chapter 3 on Computation. The reduction rule for
lambda-calculus is meant to determine which expressions are considered
“equal”—it is highly <em>non-deterministic</em>, while on a computer,
computation needs to go one way or another.</p>
<p>Using the general reduction rule of lambda-calculus, for a recursive
definition, it is always possible to find an infinite reduction
sequence. This means a naive lambda-calculus compiler could legitimately
generate infinite loops for all recursive definitions!</p>
<p>Therefore, we need more specific rules. Most languages use
<strong>call-by-value</strong> (also called <strong>eager</strong>
evaluation):</p>
<p><span class="math display">(\texttt{fun } x \texttt{ -&gt; } a) \; v
\rightsquigarrow a[x := v]</span></p>
<p>The program <em>eagerly</em> computes arguments before starting to
compute the function body. This is exactly the rule we introduced in the
Computation chapter.</p>
<h4 id="call-by-value-fixpoint-combinator-in-action">Call-by-Value
Fixpoint Combinator in Action</h4>
<p>What happens with the call-by-value fixpoint combinator?</p>
<p><span class="math display">
\begin{aligned}
\texttt{fix} \; F &amp;\rightsquigarrow (\lambda fx. F \; (f \; f) \; x)
\; (\lambda fx. F \; (f \; f) \; x) \\
&amp;\rightsquigarrow \lambda x. F \; ((\lambda fx. F \; (f \; f) \; x)
\; (\lambda fx. F \; (f \; f) \; x)) \; x
\end{aligned}
</span></p>
<p>The computation stops because we use the rule <span
class="math inline">(\texttt{fun } x \texttt{ -&gt; } a) \; v
\rightsquigarrow a[x := v]</span> rather than <span
class="math inline">(\texttt{fun } x \texttt{ -&gt; } a_1) \; a_2
\rightsquigarrow a_1[x := a_2]</span>. The expression inside the lambda
is not evaluated until the function is applied.</p>
<p>Let us compute the function on some input:</p>
<p><span class="math display">
\begin{aligned}
\texttt{fix} \; F \; v &amp;\rightsquigarrow (\lambda fx. F \; (f \; f)
\; x) \; (\lambda fx. F \; (f \; f) \; x) \; v \\
&amp;\rightsquigarrow (\lambda x. F \; ((\lambda fx. F \; (f \; f) \; x)
\; (\lambda fx. F \; (f \; f) \; x)) \; x) \; v \\
&amp;\rightsquigarrow F \; ((\lambda fx. F \; (f \; f) \; x) \; (\lambda
fx. F \; (f \; f) \; x)) \; v \\
&amp;\rightsquigarrow F \; (\lambda x. F \; ((\lambda fx. F \; (f \; f)
\; x) \; (\lambda fx. F \; (f \; f) \; x)) \; x) \; v \\
&amp;\rightsquigarrow \text{depends on } F
\end{aligned}
</span></p>
<h4 id="why-fixpoint">Why “Fixpoint”?</h4>
<p>If you examine our derivations, you will see they establish <span
class="math inline">x = f(x)</span>. Such values <span
class="math inline">x</span> are called <strong>fixpoints</strong> of
<span class="math inline">f</span>. An arithmetic function can have
several fixpoints—for example, <span class="math inline">f(x) =
x^2</span> has fixpoints 0 and 1—or no fixpoints, such as <span
class="math inline">f(x) = x + 1</span>.</p>
<p>When you define a function (or another object) by recursion, it has
similar meaning: the name appears on both sides of the equality. In
lambda-calculus, functions like <span class="math inline">\Theta</span>
and <span class="math inline">\mathbf{Y}</span> take <em>any</em>
function as an argument and return its fixpoint.</p>
<p>We turn a specification of a recursive object into a definition by
solving it with respect to the recurring name: deriving <span
class="math inline">x = f(x)</span> where <span
class="math inline">x</span> is the recurring name. We then have <span
class="math inline">x = \texttt{fix}(f)</span>.</p>
<h4 id="deriving-factorial">Deriving Factorial</h4>
<p>Let us walk through this for the factorial function. We omit the
prefix <code>cn_</code> (could be <code>pn_</code> if using pair-encoded
numbers) and shorten <code>if_then_else</code> to
<code>if_t_e</code>:</p>
<p><span class="math display">
\begin{aligned}
\texttt{fact} \; n &amp;= \texttt{if\_t\_e} \; (\texttt{is\_zero} \; n)
\; \texttt{cn1} \; (\texttt{mult} \; n \; (\texttt{fact} \;
(\texttt{pred} \; n))) \\
\texttt{fact} &amp;= \lambda n. \texttt{if\_t\_e} \; (\texttt{is\_zero}
\; n) \; \texttt{cn1} \; (\texttt{mult} \; n \; (\texttt{fact} \;
(\texttt{pred} \; n))) \\
\texttt{fact} &amp;= (\lambda fn. \texttt{if\_t\_e} \;
(\texttt{is\_zero} \; n) \; \texttt{cn1} \; (\texttt{mult} \; n \; (f \;
(\texttt{pred} \; n)))) \; \texttt{fact} \\
\texttt{fact} &amp;= \texttt{fix} \; (\lambda fn. \texttt{if\_t\_e} \;
(\texttt{is\_zero} \; n) \; \texttt{cn1} \; (\texttt{mult} \; n \; (f \;
(\texttt{pred} \; n))))
\end{aligned}
</span></p>
<p>The last line is a valid definition: we simply give a name to a
<em>ground</em> (also called <em>closed</em>) expression—one with no
free variables.</p>
<p><strong>Exercise:</strong> Compute <code>fact cn2</code>.</p>
<p><strong>Exercise:</strong> What does
<code>fix (fun x -&gt; cn_succ x)</code> mean?</p>
<h3 id="encoding-lists-and-trees">4.8 Encoding Lists and Trees</h3>
<p>A <strong>list</strong> is either empty (often called
<code>Empty</code> or <code>Nil</code>) or consists of an element
followed by another list (the “tail”), called <code>Cons</code>.</p>
<p>Define: - <code>nil</code> <span class="math inline">= \lambda
xy.y</span> - <code>cons</code> <span class="math inline">H \; T =
\lambda xy. x \; H \; T</span></p>
<p>To add numbers stored inside a list:</p>
<p><span class="math display">\texttt{addlist} \; l = l \; (\lambda ht.
\texttt{cn\_add} \; h \; (\texttt{addlist} \; t)) \;
\texttt{cn0}</span></p>
<p>To make a proper definition, we apply <span
class="math inline">\texttt{fix}</span> to the solution of the above
equation:</p>
<p><span class="math display">\texttt{addlist} = \texttt{fix} \;
(\lambda fl. l \; (\lambda ht. \texttt{cn\_add} \; h \; (f \; t)) \;
\texttt{cn0})</span></p>
<p>For <strong>trees</strong>, let us use a different form of binary
trees: instead of keeping elements in inner nodes, we keep elements in
leaves.</p>
<p>Define: - <code>leaf</code> <span class="math inline">n = \lambda xy.
x \; n</span> - <code>node</code> <span class="math inline">L \; R =
\lambda xy. y \; L \; R</span></p>
<p>To add numbers stored inside a tree:</p>
<p><span class="math display">\texttt{addtree} \; t = t \; (\lambda n.n)
\; (\lambda lr. \texttt{cn\_add} \; (\texttt{addtree} \; l) \;
(\texttt{addtree} \; r))</span></p>
<p>And in solved form:</p>
<p><span class="math display">\texttt{addtree} = \texttt{fix} \;
(\lambda ft. t \; (\lambda n.n) \; (\lambda lr. \texttt{cn\_add} \; (f
\; l) \; (f \; r)))</span></p>
<div class="sourceCode" id="cb99"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fix f x = f (fix f) x</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> nil = <span class="kw">fun</span> x y -&gt; y</span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cons h t = <span class="kw">fun</span> x y -&gt; x h t</span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> addlist l =</span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a>  fix (<span class="kw">fun</span> f l -&gt; l (<span class="kw">fun</span> h t -&gt; cn_add h (f t)) cn0) l</span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a>;;</span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a>decode_cnat</span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a>  (addlist (cons cn1 (cons cn2 (cons cn7 nil))));;</span>
<span id="cb99-9"><a href="#cb99-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> leaf n = <span class="kw">fun</span> x y -&gt; x n</span>
<span id="cb99-10"><a href="#cb99-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> node l r = <span class="kw">fun</span> x y -&gt; y l r</span>
<span id="cb99-11"><a href="#cb99-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> addtree t =</span>
<span id="cb99-12"><a href="#cb99-12" aria-hidden="true" tabindex="-1"></a>  fix (<span class="kw">fun</span> f t -&gt;</span>
<span id="cb99-13"><a href="#cb99-13" aria-hidden="true" tabindex="-1"></a>    t (<span class="kw">fun</span> n -&gt; n) (<span class="kw">fun</span> l r -&gt; cn_add (f l) (f r))</span>
<span id="cb99-14"><a href="#cb99-14" aria-hidden="true" tabindex="-1"></a>  ) t</span>
<span id="cb99-15"><a href="#cb99-15" aria-hidden="true" tabindex="-1"></a>;;</span>
<span id="cb99-16"><a href="#cb99-16" aria-hidden="true" tabindex="-1"></a>decode_cnat</span>
<span id="cb99-17"><a href="#cb99-17" aria-hidden="true" tabindex="-1"></a>  (addtree (node (node (leaf cn3) (leaf cn7))</span>
<span id="cb99-18"><a href="#cb99-18" aria-hidden="true" tabindex="-1"></a>              (leaf cn1)));;</span></code></pre></div>
<h4 id="the-general-pattern">The General Pattern</h4>
<p>Observe a regularity: when we encode a variant type with <span
class="math inline">n</span> variants, for each variant we define a
function that takes <span class="math inline">n</span> arguments.</p>
<p>If the <span class="math inline">k</span>th variant <span
class="math inline">C_k</span> has <span class="math inline">m_k</span>
parameters, then the function <span class="math inline">c_k</span> that
encodes it has the form:</p>
<p><span class="math display">C_k(v_1, \ldots, v_{m_k}) \sim c_k \; v_1
\; \ldots \; v_{m_k} = \lambda x_1 \ldots x_n. x_k \; v_1 \; \ldots \;
v_{m_k}</span></p>
<p>The encoded variants serve as shallow pattern matching with
guaranteed exhaustiveness: the <span class="math inline">k</span>th
argument corresponds to the <span class="math inline">k</span>th branch
of pattern matching.</p>
<h3 id="looping-recursion">4.9 Looping Recursion</h3>
<p>Let us return to pair-encoded numbers and define addition:</p>
<pre><code>let pn_add m n =
  fix (fun f m n -&gt;
    if_then_else (pn_is_zero m)
      n (pn_succ (f (pn_pred m) n))
  ) m n;;
decode_pnat (pn_add pn3 pn3);;</code></pre>
<p>Oops… OCaml says:
<code>Stack overflow during evaluation (looping recursion?).</code></p>
<p>What went wrong? Nothing as far as lambda-calculus is concerned. But
OCaml (and F#) always compute arguments before calling a function. By
definition of <code>fix</code>, <code>f</code> corresponds to
recursively calling <code>pn_add</code>. Therefore,
<code>(pn_succ (f (pn_pred m) n))</code> will be evaluated regardless of
what <code>(pn_is_zero m)</code> returns!</p>
<p>Why do <code>addlist</code> and <code>addtree</code> work? Because
their recursive calls are “guarded” by corresponding <code>fun</code>.
What is inside of <code>fun</code> is not computed immediately—only when
the function is applied to argument(s).</p>
<p>To avoid looping recursion, you need to guard all recursive calls.
Besides putting them inside <code>fun</code>, in OCaml or F# you can
also put them in branches of a <code>match</code> clause, as long as one
of the branches does not have unguarded recursive calls.</p>
<p>The trick for functions like <code>if_then_else</code> is to guard
their arguments with <code>fun x -&gt;</code>, where <code>x</code> is
not used, and apply the <em>result</em> of <code>if_then_else</code> to
some dummy value:</p>
<pre><code>let id x = x
let rec fix f x = f (fix f) x
let pn1 x = pn_succ pn0 x
let pn2 x = pn_succ pn1 x
let pn3 x = pn_succ pn2 x
let pn7 x = encode_pnat 7 x
let pn_add m n =
  fix (fun f m n -&gt;
    (if_then_else (pn_is_zero m)
       (fun x -&gt; n) (fun x -&gt; pn_succ (f (pn_pred m) n)))
      id
  ) m n;;
decode_pnat (pn_add pn3 pn3);;
decode_pnat (pn_add pn3 pn7);;</code></pre>
<p>In OCaml or F# we would typically guard by <code>fun () -&gt;</code>
and then apply to <code>()</code>, but we do not have datatypes like
<code>unit</code> in pure lambda-calculus.</p>
<h3 id="exercises-3">4.10 Exercises</h3>
<p><strong>Exercise 1:</strong> Define (implement) and test on a couple
of examples functions corresponding to or computing:</p>
<ol type="1">
<li><code>c_or</code> and <code>c_not</code>;</li>
<li>exponentiation for Church numerals;</li>
<li>is-zero predicate for Church numerals;</li>
<li>even-number predicate for Church numerals;</li>
<li>multiplication for pair-encoded natural numbers;</li>
<li>factorial <span class="math inline">n!</span> for pair-encoded
natural numbers;</li>
<li>the length of a list (in Church numerals);</li>
<li><code>cn_max</code> – maximum of two Church numerals;</li>
<li>the depth of a tree (in Church numerals).</li>
</ol>
<p><strong>Exercise 2:</strong> Construct lambda-terms <span
class="math inline">m_0, m_1, \ldots</span> such that for all <span
class="math inline">n</span> one has:</p>
<p><span class="math display">
\begin{aligned}
m_0 &amp;= x \\
m_{n+1} &amp;= m_{n+2} \; m_n
\end{aligned}
</span></p>
<p>(where equality is after performing <span
class="math inline">\beta</span>-reductions).</p>
<p><strong>Exercise 3:</strong> Representing side-effects as an
explicitly “passed around” state value, write (higher-order) functions
that represent the imperative constructs:</p>
<ol type="1">
<li><code>for</code>…<code>to</code>…</li>
<li><code>for</code>…<code>downto</code>…</li>
<li><code>while</code>…<code>do</code>…</li>
<li><code>do</code>…<code>while</code>…</li>
<li><code>repeat</code>…<code>until</code>…</li>
</ol>
<p>Rather than writing a lambda-term using the encodings that we have
learnt, just implement the functions in OCaml / F#, using built-in
<code>int</code> and <code>bool</code> types. You can use
<code>let rec</code> instead of <code>fix</code>.</p>
<ul>
<li>For example, in exercise (a), write a function
<code>let rec for_to f beg_i end_i s = ...</code> where <code>f</code>
takes arguments <code>i</code> ranging from <code>beg_i</code> to
<code>end_i</code>, state <code>s</code> at given step, and returns
state <code>s</code> at next step; the <code>for_to</code> function
returns the state after the last step.</li>
<li>And in exercise (c), write a function
<code>let rec while_do p f s = ...</code> where both <code>p</code> and
<code>f</code> take state <code>s</code> at given step, and if
<code>p s</code> returns true, then <code>f s</code> is computed to
obtain state at next step; the <code>while_do</code> function returns
the state after the last step.</li>
</ul>
<p>Do not use the imperative features of OCaml and F#!</p>
<p>Although we will not cover imperative features in this course, it is
instructive to see the implementation using them, to better understand
what is actually required of a solution to Exercise 3:</p>
<div class="sourceCode" id="cb102"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* (a) *)</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> for_to f beg_i end_i s =</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s = <span class="dt">ref</span> s <span class="kw">in</span></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">for</span> i = beg_i <span class="kw">to</span> end_i <span class="kw">do</span></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a>    s := f i !s</span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span>;</span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true" tabindex="-1"></a>  !s</span>
<span id="cb102-8"><a href="#cb102-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-9"><a href="#cb102-9" aria-hidden="true" tabindex="-1"></a><span class="co">(* (b) *)</span></span>
<span id="cb102-10"><a href="#cb102-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> for_downto f beg_i end_i s =</span>
<span id="cb102-11"><a href="#cb102-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s = <span class="dt">ref</span> s <span class="kw">in</span></span>
<span id="cb102-12"><a href="#cb102-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">for</span> i = beg_i <span class="kw">downto</span> end_i <span class="kw">do</span></span>
<span id="cb102-13"><a href="#cb102-13" aria-hidden="true" tabindex="-1"></a>    s := f i !s</span>
<span id="cb102-14"><a href="#cb102-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span>;</span>
<span id="cb102-15"><a href="#cb102-15" aria-hidden="true" tabindex="-1"></a>  !s</span>
<span id="cb102-16"><a href="#cb102-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-17"><a href="#cb102-17" aria-hidden="true" tabindex="-1"></a><span class="co">(* (c) *)</span></span>
<span id="cb102-18"><a href="#cb102-18" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> while_do p f s =</span>
<span id="cb102-19"><a href="#cb102-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s = <span class="dt">ref</span> s <span class="kw">in</span></span>
<span id="cb102-20"><a href="#cb102-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">while</span> p !s <span class="kw">do</span></span>
<span id="cb102-21"><a href="#cb102-21" aria-hidden="true" tabindex="-1"></a>    s := f !s</span>
<span id="cb102-22"><a href="#cb102-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span>;</span>
<span id="cb102-23"><a href="#cb102-23" aria-hidden="true" tabindex="-1"></a>  !s</span>
<span id="cb102-24"><a href="#cb102-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-25"><a href="#cb102-25" aria-hidden="true" tabindex="-1"></a><span class="co">(* (d) *)</span></span>
<span id="cb102-26"><a href="#cb102-26" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> do_while p f s =</span>
<span id="cb102-27"><a href="#cb102-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s = <span class="dt">ref</span> (f s) <span class="kw">in</span></span>
<span id="cb102-28"><a href="#cb102-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">while</span> p !s <span class="kw">do</span></span>
<span id="cb102-29"><a href="#cb102-29" aria-hidden="true" tabindex="-1"></a>    s := f !s</span>
<span id="cb102-30"><a href="#cb102-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span>;</span>
<span id="cb102-31"><a href="#cb102-31" aria-hidden="true" tabindex="-1"></a>  !s</span>
<span id="cb102-32"><a href="#cb102-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-33"><a href="#cb102-33" aria-hidden="true" tabindex="-1"></a><span class="co">(* (e) *)</span></span>
<span id="cb102-34"><a href="#cb102-34" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> repeat_until p f s =</span>
<span id="cb102-35"><a href="#cb102-35" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s = <span class="dt">ref</span> (f s) <span class="kw">in</span></span>
<span id="cb102-36"><a href="#cb102-36" aria-hidden="true" tabindex="-1"></a>  <span class="kw">while</span> <span class="dt">not</span> (p !s) <span class="kw">do</span></span>
<span id="cb102-37"><a href="#cb102-37" aria-hidden="true" tabindex="-1"></a>    s := f !s</span>
<span id="cb102-38"><a href="#cb102-38" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span>;</span>
<span id="cb102-39"><a href="#cb102-39" aria-hidden="true" tabindex="-1"></a>  !s</span></code></pre></div>
<h2 id="chapter-5-polymorphism-and-abstract-data-types">Chapter 5:
Polymorphism and Abstract Data Types</h2>
<p>This chapter explores how OCaml’s type system supports generic
programming through parametric polymorphism, and how abstract data types
provide clean interfaces for data structures. We examine the formal
mechanics of type inference and then apply these concepts to build
progressively more sophisticated implementations of the map (dictionary)
data structure, culminating in red-black trees.</p>
<h3 id="type-inference">5.1 Type Inference</h3>
<p>We have seen the rules that govern the assignment of types to
expressions, but how does OCaml guess what types to use, and when no
correct types exist? The answer is that it solves equations.</p>
<h4 id="variables-unknowns-and-parameters">5.1.1 Variables: Unknowns and
Parameters</h4>
<p>Variables in type inference play two distinct roles: they can be
<em>unknowns</em> (standing for a specific but not-yet-determined type)
or <em>parameters</em> (standing for any type whatsoever).</p>
<p>Consider the following example:</p>
<div class="sourceCode" id="cb103"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> f = <span class="dt">List</span>.hd;;</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : &#39;a <span class="dt">list</span> -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
<p>Here <code>'a</code> is a parameter: it can become any type.
Mathematically we write: <span class="math inline">f : \forall \alpha .
\alpha \ \text{list} \rightarrow \alpha</span> – the quantified type is
called a <em>type scheme</em>.</p>
<p>In contrast:</p>
<div class="sourceCode" id="cb104"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> x = <span class="dt">ref</span> [];;</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> x : &#39;_weak1 <span class="dt">list</span> <span class="dt">ref</span> = {contents = []}</span></code></pre></div>
<p>Here <code>'_a</code> is an unknown. It stands for a particular type
like <code>float</code> or <code>int -&gt; int</code>, but OCaml just
does not yet know which type. OCaml only reports unknowns like
<code>'_a</code> in inferred types for reasons related to mutable state
(the “value restriction”), which are not central to functional
programming.</p>
<p>When unknowns appear in inferred types against our expectations,
<em><span class="math inline">\eta</span>-expansion</em> may help:
writing <code>let f x = expr x</code> instead of
<code>let f = expr</code>. For example:</p>
<div class="sourceCode" id="cb105"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> f = <span class="dt">List</span>.append [];;</span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : &#39;_weak2 <span class="dt">list</span> -&gt; &#39;_weak2 <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> f l = <span class="dt">List</span>.append [] l;;</span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
<p>In the second definition, the eta-expanded form allows full
generalization.</p>
<h4 id="type-environments">5.1.2 Type Environments</h4>
<p>A <em>type environment</em> specifies what names (corresponding to
parameters and definitions) are available for an expression because they
were introduced above it, and it specifies their types.</p>
<h4 id="solving-type-equations">5.1.3 Solving Type Equations</h4>
<p>Type inference solves equations over unknowns. The central question
is: “What has to hold so that <span class="math inline">e : \tau</span>
in type environment <span class="math inline">\Gamma</span>?”</p>
<p>The process works as follows:</p>
<ul>
<li><p>If, for example, <span class="math inline">f : \forall \alpha .
\alpha \ \text{list} \rightarrow \alpha \in \Gamma</span>, then for
<span class="math inline">f : \tau</span> we introduce <span
class="math inline">\gamma \ \text{list} \rightarrow \gamma =
\tau</span> for some fresh unknown <span
class="math inline">\gamma</span>.</p></li>
<li><p>For function application <span class="math inline">e_1 \ e_2 :
\tau</span>, we introduce <span class="math inline">\beta = \tau</span>
and ask for <span class="math inline">e_1 : \gamma \rightarrow
\beta</span> and <span class="math inline">e_2 : \gamma</span>, for some
fresh unknowns <span class="math inline">\beta, \gamma</span>.</p></li>
<li><p>For a function <span class="math inline">\text{fun} \ x
\rightarrow e : \tau</span>, we introduce <span
class="math inline">\beta \rightarrow \gamma = \tau</span> and ask for
<span class="math inline">e : \gamma</span> in environment <span
class="math inline">\{x : \beta\} \cup \Gamma</span>, for some fresh
unknowns <span class="math inline">\beta, \gamma</span>.</p></li>
<li><p>The case <span class="math inline">\text{let} \ x = e_1 \
\text{in} \ e_2 : \tau</span> is different. One approach is to
<em>first</em> solve the equations that we get by asking for <span
class="math inline">e_1 : \beta</span>, for some fresh unknown <span
class="math inline">\beta</span>. Let us say a solution <span
class="math inline">\beta = \tau_\beta</span> has been found, <span
class="math inline">\alpha_1 \ldots \alpha_n \beta_1 \ldots
\beta_m</span> are the remaining unknowns in <span
class="math inline">\tau_\beta</span>, and <span
class="math inline">\alpha_1 \ldots \alpha_n</span> are all that do not
appear in <span class="math inline">\Gamma</span>. Then we ask for <span
class="math inline">e_2 : \tau</span> in environment <span
class="math inline">\{x : \forall \alpha_1 \ldots \alpha_n .
\tau_\beta\} \cup \Gamma</span>.</p></li>
<li><p>Remember that whenever we establish a solution <span
class="math inline">\beta = \tau_\beta</span> to an unknown <span
class="math inline">\beta</span>, it takes effect everywhere!</p></li>
<li><p>To find a type for <span class="math inline">e</span> (in
environment <span class="math inline">\Gamma</span>), we pick a fresh
unknown <span class="math inline">\beta</span> and ask for <span
class="math inline">e : \beta</span> (in <span
class="math inline">\Gamma</span>).</p></li>
</ul>
<h4 id="polymorphism">5.1.4 Polymorphism</h4>
<p>The “top-level” definitions for which the system infers types with
variables are called <em>polymorphic</em>, which informally means
“working with different shapes of data”. This kind of polymorphism is
called <em>parametric polymorphism</em>, since the types have
parameters. A different kind of polymorphism is provided by
object-oriented programming languages (sometimes called <em>subtype
polymorphism</em> or <em>ad-hoc polymorphism</em>).</p>
<h3 id="parametric-types">5.2 Parametric Types</h3>
<p>Polymorphic functions shine when used with polymorphic data types.
Consider:</p>
<div class="sourceCode" id="cb106"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a my_list = Empty | Cons <span class="kw">of</span> &#39;a * &#39;a my_list</span></code></pre></div>
<p>We define lists that can store elements of any type <code>'a</code>.
Now:</p>
<div class="sourceCode" id="cb107"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> tail l =</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="dt">invalid_arg</span> <span class="st">&quot;tail&quot;</span></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a>    | Cons (_, tl) -&gt; tl;;</span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> tail : &#39;a my_list -&gt; &#39;a my_list = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
<p>This is a polymorphic function: it works for lists with elements of
any type.</p>
<p>A <em>parametric type</em> like <code>'a my_list</code> <em>is
not</em> itself a data type but a family of data types:
<code>bool my_list</code>, <code>int my_list</code>, etc. <em>are</em>
different types. We say that the type <code>int my_list</code>
<em>instantiates</em> the parametric type <code>'a my_list</code>.</p>
<h4 id="multiple-type-parameters">5.2.1 Multiple Type Parameters</h4>
<p>In OCaml, the syntax is a bit confusing: type parameters precede the
type name. For example:</p>
<div class="sourceCode" id="cb108"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (&#39;a, &#39;b) choice = Left <span class="kw">of</span> &#39;a | Right <span class="kw">of</span> &#39;b</span></code></pre></div>
<p>This type has two parameters. Mathematically we would write <span
class="math inline">\text{choice}(\alpha, \beta)</span>.</p>
<p>Functions do not have to be polymorphic:</p>
<div class="sourceCode" id="cb109"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> get_int c =</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> c <span class="kw">with</span></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a>    | Left i -&gt; i</span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a>    | Right b -&gt; <span class="kw">if</span> b <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>;;</span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> get_int : (<span class="dt">int</span>, <span class="dt">bool</span>) choice -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
<h4 id="syntax-in-other-languages">5.2.2 Syntax in Other Languages</h4>
<p>In F#, we provide parameters (when more than one) after the type
name:</p>
<div class="sourceCode" id="cb110"><pre
class="sourceCode fsharp"><code class="sourceCode fsharp"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> choice&lt;&#39;a,&#39;b&gt; = Left <span class="kw">of</span> &#39;a | Right <span class="kw">of</span> &#39;b</span></code></pre></div>
<p>In Haskell, we provide type parameters similarly to function
arguments:</p>
<div class="sourceCode" id="cb111"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Choice</span> a b <span class="ot">=</span> <span class="dt">Left</span> a <span class="op">|</span> <span class="dt">Right</span> b</span></code></pre></div>
<h3 id="type-inference-formally">5.3 Type Inference, Formally</h3>
<p>A statement that an expression has a type in an environment is called
a <em>type judgement</em>. For environment <span
class="math inline">\Gamma = \{x : \forall \alpha_1 \ldots \alpha_n .
\tau_x ; \ldots\}</span>, expression <span class="math inline">e</span>
and type <span class="math inline">\tau</span> we write:</p>
<p><span class="math display">\Gamma \vdash e : \tau</span></p>
<p>We will derive the equations in one go using <span
class="math inline">[\![ \cdot ]\!]</span>, to be solved later. Besides
equations we will need to manage introduced variables, using existential
quantification.</p>
<p>For local definitions we require remembering what constraints should
hold when the definition is used. Therefore we extend <em>type
schemes</em> in the environment to: <span class="math inline">\Gamma =
\{x : \forall \beta_1 \ldots \beta_m [\exists \alpha_1 \ldots \alpha_n .
D] . \tau_x ; \ldots\}</span> where <span class="math inline">D</span>
are equations – keeping the variables <span class="math inline">\alpha_1
\ldots \alpha_n</span> introduced while deriving <span
class="math inline">D</span> in front. A simpler form would be enough:
<span class="math inline">\Gamma = \{x : \forall \beta [\exists \alpha_1
\ldots \alpha_n . D] . \beta ; \ldots\}</span></p>
<p>The formal constraint generation rules are:</p>
<p><span class="math display">[\![ \Gamma \vdash x : \tau ]\!] = \exists
\overline{\beta&#39;} \overline{\alpha&#39;} . (D[\overline{\beta}
\overline{\alpha} := \overline{\beta&#39;} \overline{\alpha&#39;}]
\wedge \tau_x[\overline{\beta} \overline{\alpha} :=
\overline{\beta&#39;} \overline{\alpha&#39;}] \doteq \tau)</span></p>
<p>where <span class="math inline">\Gamma(x) = \forall \overline{\beta}
[\exists \overline{\alpha} . D] . \tau_x</span>, <span
class="math inline">\overline{\beta&#39;} \overline{\alpha&#39;} \#
\text{FV}(\Gamma, \tau)</span></p>
<p><span class="math display">[\![ \Gamma \vdash \mathbf{fun} \ x
\texttt{-&gt;} e : \tau ]\!] = \exists \alpha_1 \alpha_2 . ([\![ \Gamma
\{x : \alpha_1\} \vdash e : \alpha_2 ]\!] \wedge \alpha_1 \rightarrow
\alpha_2 \doteq \tau)</span></p>
<p>where <span class="math inline">\alpha_1 \alpha_2 \#
\text{FV}(\Gamma, \tau)</span></p>
<p><span class="math display">[\![ \Gamma \vdash e_1 \ e_2 : \tau ]\!] =
\exists \alpha . ([\![ \Gamma \vdash e_1 : \alpha \rightarrow \tau ]\!]
\wedge [\![ \Gamma \vdash e_2 : \alpha ]\!]), \alpha \#
\text{FV}(\Gamma, \tau)</span></p>
<p><span class="math display">[\![ \Gamma \vdash K \ e_1 \ldots e_n :
\tau ]\!] = \exists \overline{\alpha&#39;} . (\bigwedge_i [\![ \Gamma
\vdash e_i : \tau_i[\overline{\alpha} := \overline{\alpha&#39;}] ]\!]
\wedge \varepsilon(\overline{\alpha&#39;}) \doteq \tau)</span></p>
<p>where <span class="math inline">K : \forall \overline{\alpha} .
\tau_1 \times \ldots \times \tau_n \rightarrow
\varepsilon(\overline{\alpha})</span>, <span
class="math inline">\overline{\alpha&#39;} \# \text{FV}(\Gamma,
\tau)</span></p>
<p>For let-expressions:</p>
<p><span class="math display">[\![ \Gamma \vdash \mathbf{let} \ x = e_1
\ \mathbf{in} \ e_2 : \tau ]\!] = (\exists \beta . C) \wedge [\![ \Gamma
\{x : \forall \beta [C] . \beta\} \vdash e_2 : \tau ]\!]</span></p>
<p>where <span class="math inline">C = [\![ \Gamma \vdash e_1 : \beta
]\!]</span></p>
<p>For recursive let-expressions:</p>
<p><span class="math display">[\![ \Gamma \vdash \mathbf{letrec} \ x =
e_1 \ \mathbf{in} \ e_2 : \tau ]\!] = (\exists \beta . C) \wedge [\![
\Gamma \{x : \forall \beta [C] . \beta\} \vdash e_2 : \tau
]\!]</span></p>
<p>where <span class="math inline">C = [\![ \Gamma \{x : \beta\} \vdash
e_1 : \beta ]\!]</span></p>
<p>For match expressions:</p>
<p><span class="math display">[\![ \Gamma \vdash \mathbf{match} \ e_v \
\mathbf{with} \ \overline{c} : \tau ]\!] = \exists \alpha_v . [\![
\Gamma \vdash e_v : \alpha_v ]\!] \bigwedge_i [\![ \Gamma \vdash p_i .
e_i : \alpha_v \rightarrow \tau ]\!]</span></p>
<p>where <span class="math inline">\overline{c} = p_1 . e_1 | \ldots |
p_n . e_n</span>, <span class="math inline">\alpha_v \#
\text{FV}(\Gamma, \tau)</span></p>
<p>For pattern clauses:</p>
<p><span class="math display">[\![ \Gamma, \Sigma \vdash p.e : \tau_1
\rightarrow \tau_2 ]\!] = [\![ \Sigma \vdash p \downarrow \tau_1 ]\!]
\wedge \exists \overline{\beta} . [\![ \Gamma \Gamma&#39; \vdash e :
\tau_2 ]\!]</span></p>
<p>where <span class="math inline">\exists \overline{\beta}
\Gamma&#39;</span> is <span class="math inline">[\![ \Sigma \vdash p
\uparrow \tau_1 ]\!]</span>, <span class="math inline">\overline{\beta}
\# \text{FV}(\Gamma, \tau_2)</span></p>
<p>The notation <span class="math inline">[\![ \Sigma \vdash p
\downarrow \tau_1 ]\!]</span> derives constraints on the type of the
matched value, while <span class="math inline">[\![ \Sigma \vdash p
\uparrow \tau_1 ]\!]</span> derives the environment for pattern
variables.</p>
<p>By <span class="math inline">\overline{\alpha}</span> or <span
class="math inline">\overline{\alpha_i}</span> we denote a sequence of
some length: <span class="math inline">\alpha_1 \ldots \alpha_n</span>.
By <span class="math inline">\bigwedge_i \varphi_i</span> we denote a
conjunction of <span class="math inline">\overline{\varphi_i}</span>:
<span class="math inline">\varphi_1 \wedge \ldots \wedge
\varphi_n</span>.</p>
<h4 id="polymorphic-recursion">5.3.1 Polymorphic Recursion</h4>
<p>Note the limited polymorphism of <code>let rec f = ...</code> – we
cannot use <code>f</code> polymorphically in its definition. In modern
OCaml we can bypass the problem if we provide the type of <code>f</code>
upfront:</p>
<pre><code>let rec f : &#39;a. &#39;a -&gt; &#39;a list = ...</code></pre>
<p>where <code>'a. 'a -&gt; 'a list</code> stands for <span
class="math inline">\forall \alpha . \alpha \rightarrow \alpha \
\text{list}</span>.</p>
<p>Using the recursively defined function with different types in its
definition is called <em>polymorphic recursion</em>. It is most useful
together with <em>irregular recursive datatypes</em> where the recursive
use has different type arguments than the actual parameters.</p>
<h5
id="example-a-list-alternating-between-two-types-of-elements">Example: A
List Alternating Between Two Types of Elements</h5>
<div class="sourceCode" id="cb113"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (&#39;x, &#39;o) alterning =</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>  | Stop</span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>  | One <span class="kw">of</span> &#39;x * (&#39;o, &#39;x) alterning</span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> to_list :</span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a>    &#39;x &#39;o &#39;a. (&#39;x -&gt; &#39;a) -&gt; (&#39;o -&gt; &#39;a) -&gt;</span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a>              (&#39;x, &#39;o) alterning -&gt; &#39;a <span class="dt">list</span> =</span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fun</span> x2a o2a -&gt;</span>
<span id="cb113-9"><a href="#cb113-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">function</span></span>
<span id="cb113-10"><a href="#cb113-10" aria-hidden="true" tabindex="-1"></a>    | Stop -&gt; []</span>
<span id="cb113-11"><a href="#cb113-11" aria-hidden="true" tabindex="-1"></a>    | One (x, rest) -&gt; x2a x :: to_list o2a x2a rest</span>
<span id="cb113-12"><a href="#cb113-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-13"><a href="#cb113-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> to_choice_list alt =</span>
<span id="cb113-14"><a href="#cb113-14" aria-hidden="true" tabindex="-1"></a>  to_list (<span class="kw">fun</span> x -&gt; Left x) (<span class="kw">fun</span> o -&gt; Right o) alt</span>
<span id="cb113-15"><a href="#cb113-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-16"><a href="#cb113-16" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> it = to_choice_list</span>
<span id="cb113-17"><a href="#cb113-17" aria-hidden="true" tabindex="-1"></a>  (One (<span class="dv">1</span>, One (<span class="st">&quot;o&quot;</span>, One (<span class="dv">2</span>, One (<span class="st">&quot;oo&quot;</span>, Stop)))))</span></code></pre></div>
<p>Notice how the recursive call to <code>to_list</code> swaps
<code>o2a</code> and <code>x2a</code> – this is necessary because the
alternating structure swaps the type parameters at each level.</p>
<h5 id="example-data-structural-bootstrapping">Example: Data-Structural
Bootstrapping</h5>
<div class="sourceCode" id="cb114"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a seq =</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>  | Nil</span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>  | Zero <span class="kw">of</span> (&#39;a * &#39;a) seq</span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>  | One <span class="kw">of</span> &#39;a * (&#39;a * &#39;a) seq</span></code></pre></div>
<p>We store a list of elements in exponentially increasing chunks:</p>
<div class="sourceCode" id="cb115"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> example =</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>  One (<span class="dv">0</span>, One ((<span class="dv">1</span>,<span class="dv">2</span>), Zero (One ((((<span class="dv">3</span>,<span class="dv">4</span>),(<span class="dv">5</span>,<span class="dv">6</span>)), ((<span class="dv">7</span>,<span class="dv">8</span>),(<span class="dv">9</span>,<span class="dv">10</span>))), Nil))))</span></code></pre></div>
<div class="sourceCode" id="cb116"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> cons : &#39;a. &#39;a -&gt; &#39;a seq -&gt; &#39;a seq =  <span class="co">(* Appending an element to the *)</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fun</span> x -&gt; <span class="kw">function</span>                           <span class="co">(* datastructure is like *)</span></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>  | Nil -&gt; One (x, Nil)                       <span class="co">(* adding one to a binary number: 1+0=1 *)</span></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a>  | Zero ps -&gt; One (x, ps)                    <span class="co">(* 1+...0=...1 *)</span></span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a>  | One (y, ps) -&gt; Zero (cons (x,y) ps)       <span class="co">(* 1+...1=[...+1]0 *)</span></span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> lookup : &#39;a. <span class="dt">int</span> -&gt; &#39;a seq -&gt; &#39;a =</span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fun</span> i s -&gt; <span class="kw">match</span> i, s <span class="kw">with</span></span>
<span id="cb116-9"><a href="#cb116-9" aria-hidden="true" tabindex="-1"></a>  | _, Nil -&gt; <span class="dt">raise</span> <span class="dt">Not_found</span>                 <span class="co">(* Rather than returning None : &#39;a option *)</span></span>
<span id="cb116-10"><a href="#cb116-10" aria-hidden="true" tabindex="-1"></a>  | <span class="dv">0</span>, One (x, _) -&gt; x                        <span class="co">(* we raise exception, for convenience. *)</span></span>
<span id="cb116-11"><a href="#cb116-11" aria-hidden="true" tabindex="-1"></a>  | i, One (_, ps) -&gt; lookup (i<span class="dv">-1</span>) (Zero ps)</span>
<span id="cb116-12"><a href="#cb116-12" aria-hidden="true" tabindex="-1"></a>  | i, Zero ps -&gt;                             <span class="co">(* Random-Access lookup works *)</span></span>
<span id="cb116-13"><a href="#cb116-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> x, y = lookup (i / <span class="dv">2</span>) ps <span class="kw">in</span>         <span class="co">(* in logarithmic time -- much faster than *)</span></span>
<span id="cb116-14"><a href="#cb116-14" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> i <span class="kw">mod</span> <span class="dv">2</span> = <span class="dv">0</span> <span class="kw">then</span> x <span class="kw">else</span> y            <span class="co">(* in standard lists. *)</span></span></code></pre></div>
<h3 id="algebraic-specification">5.4 Algebraic Specification</h3>
<p>The way we introduce a data structure, like complex numbers or
strings, in mathematics is by specifying an <em>algebraic
structure</em>.</p>
<p>Algebraic structures consist of a set (or several sets, for so-called
<em>multisorted</em> algebras) and a bunch of functions (also known as
operations) over this set (or sets).</p>
<p>A <em>signature</em> is a rough description of an algebraic
structure: it provides <em>sorts</em> – names for the sets (in the
multisorted case) – and names of the functions-operations together with
their arity (and what sorts of arguments they take).</p>
<p>We select a class of algebraic structures by providing axioms that
have to hold. We will call such classes <em>algebraic
specifications</em>. In mathematics, a rusty name for some algebraic
specifications is a <em>variety</em>; a more modern name is
<em>algebraic category</em>.</p>
<p>Algebraic structures correspond to “implementations” and signatures
to “interfaces” in programming languages. We will say that an algebraic
structure <em>implements</em> an algebraic specification when all axioms
of the specification hold in the structure. All algebraic specifications
are implemented by multiple structures!</p>
<p>We say that an algebraic structure does not have <em>junk</em> when
all its elements (i.e., elements in the sets corresponding to sorts) can
be built using operations in its signature.</p>
<p>We allow parametric types as sorts. In that case, strictly speaking,
we define a family of algebraic specifications (a different
specification for each instantiation of the parametric type).</p>
<h4 id="algebraic-specifications-examples">5.4.1 Algebraic
Specifications: Examples</h4>
<p>An algebraic specification can also use an earlier specification. In
“impure” languages like OCaml and F# we allow that the result of any
operation be an <span class="math inline">\text{error}</span>. In
Haskell we could use <code>Maybe</code>.</p>
<p><strong>Specification <span class="math inline">\text{nat}_p</span>
(bounded natural numbers):</strong></p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr>
<th><span class="math inline">\text{nat}_p</span></th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">0 : \text{nat}_p</span></td>
</tr>
<tr>
<td><span class="math inline">\text{succ} : \text{nat}_p \rightarrow
\text{nat}_p</span></td>
</tr>
<tr>
<td><span class="math inline">+ : \text{nat}_p \rightarrow \text{nat}_p
\rightarrow \text{nat}_p</span></td>
</tr>
<tr>
<td><span class="math inline">* : \text{nat}_p \rightarrow \text{nat}_p
\rightarrow \text{nat}_p</span></td>
</tr>
<tr>
<td>Variables: <span class="math inline">n, m : \text{nat}_p</span></td>
</tr>
<tr>
<td>Axioms:</td>
</tr>
<tr>
<td><span class="math inline">0 + n = n</span>, <span
class="math inline">n + 0 = n</span></td>
</tr>
<tr>
<td><span class="math inline">m + \text{succ}(n) = \text{succ}(m +
n)</span></td>
</tr>
<tr>
<td><span class="math inline">0 * n = 0</span>, <span
class="math inline">n * 0 = 0</span></td>
</tr>
<tr>
<td><span class="math inline">m * \text{succ}(n) = m + (m *
n)</span></td>
</tr>
<tr>
<td><span
class="math inline">\underbrace{\text{succ}(\ldots\text{succ}(0))}_{\text{less
than } p \text{ times}} \neq 0</span></td>
</tr>
<tr>
<td><span
class="math inline">\underbrace{\text{succ}(\ldots\text{succ}(0))}_{p
\text{ times}} = 0</span></td>
</tr>
</tbody>
</table>
<p><strong>Specification <span
class="math inline">\text{string}_p</span> (bounded
strings):</strong></p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr>
<th><span class="math inline">\text{string}_p</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>uses <span class="math inline">\text{char}</span>, <span
class="math inline">\text{nat}_p</span></td>
</tr>
<tr>
<td><code>""</code> <span class="math inline">:
\text{string}_p</span></td>
</tr>
<tr>
<td><code>"c"</code> <span class="math inline">: \text{char} \rightarrow
\text{string}_p</span></td>
</tr>
<tr>
<td><span class="math inline">\hat{\ } : \text{string}_p \rightarrow
\text{string}_p \rightarrow \text{string}_p</span></td>
</tr>
<tr>
<td><span class="math inline">\cdot[\cdot] : \text{string}_p \rightarrow
\text{nat}_p \rightarrow \text{char}</span></td>
</tr>
<tr>
<td>Variables: <span class="math inline">s : \text{string}_p</span>,
<span class="math inline">c, c_1, \ldots, c_p : \text{char}</span>,
<span class="math inline">n : \text{nat}_p</span></td>
</tr>
<tr>
<td>Axioms:</td>
</tr>
<tr>
<td><code>""</code> <span class="math inline">\hat{\ } s = s</span>,
<span class="math inline">s \hat{\ }</span> <code>""</code> <span
class="math inline">= s</span></td>
</tr>
<tr>
<td><span class="math inline">\underbrace{\text{``}c_1\text{&#39;&#39;}
\hat{\ } (\ldots \hat{\ } \text{``}c_p\text{&#39;&#39;})}_{p \text{
times}} = \text{error}</span></td>
</tr>
<tr>
<td><span class="math inline">r \hat{\ } (s \hat{\ } t) = (r \hat{\ } s)
\hat{\ } t</span></td>
</tr>
<tr>
<td><span class="math inline">(\text{``}c\text{&#39;&#39;} \hat{\ }
s)[0] = c</span></td>
</tr>
<tr>
<td><span class="math inline">(\text{``}c\text{&#39;&#39;} \hat{\ }
s)[\text{succ}(n)] = s[n]</span></td>
</tr>
<tr>
<td><code>""</code><span class="math inline">[n] =
\text{error}</span></td>
</tr>
</tbody>
</table>
<h3 id="homomorphisms">5.5 Homomorphisms</h3>
<p>Homomorphisms are mappings between algebraic structures with the same
signature that preserve operations.</p>
<p>A <em>homomorphism</em> from algebraic structure <span
class="math inline">(A, \{f^A, g^A, \ldots\})</span> to <span
class="math inline">(B, \{f^B, g^B, \ldots\})</span> is a function <span
class="math inline">h : A \rightarrow B</span> such that: - <span
class="math inline">h(f^A(a_1, \ldots, a_{n_f})) = f^B(h(a_1), \ldots,
h(a_{n_f}))</span> for all <span class="math inline">(a_1, \ldots,
a_{n_f})</span> - <span class="math inline">h(g^A(a_1, \ldots, a_{n_g}))
= g^B(h(a_1), \ldots, h(a_{n_g}))</span> for all <span
class="math inline">(a_1, \ldots, a_{n_g})</span> - and so on for all
operations.</p>
<p>Two algebraic structures are <em>isomorphic</em> if there are
homomorphisms <span class="math inline">h_1 : A \rightarrow B</span>,
<span class="math inline">h_2 : B \rightarrow A</span> from one to the
other and back, that when composed in any order form identity: <span
class="math inline">\forall (b \in B) \ h_1(h_2(b)) = b</span> and <span
class="math inline">\forall (a \in A) \ h_2(h_1(a)) = a</span>.</p>
<p>An algebraic specification whose all implementations without junk are
isomorphic is called “<em>monomorphic</em>”. We usually only add axioms
that really matter to us to the specification, so that the
implementations have room for optimization. For this reason, the
resulting specifications will often not be monomorphic in the above
sense.</p>
<h3 id="example-maps">5.6 Example: Maps</h3>
<p>A <em>map</em> (also called dictionary or associative array)
associates keys with values. Here is an algebraic specification:</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr>
<th><span class="math inline">(\alpha, \beta) \ \text{map}</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>uses <span class="math inline">\text{bool}</span>, type parameters
<span class="math inline">\alpha, \beta</span></td>
</tr>
<tr>
<td><span class="math inline">\text{empty} : (\alpha, \beta) \
\text{map}</span></td>
</tr>
<tr>
<td><span class="math inline">\text{member} : \alpha \rightarrow
(\alpha, \beta) \ \text{map} \rightarrow \text{bool}</span></td>
</tr>
<tr>
<td><span class="math inline">\text{add} : \alpha \rightarrow \beta
\rightarrow (\alpha, \beta) \ \text{map} \rightarrow (\alpha, \beta) \
\text{map}</span></td>
</tr>
<tr>
<td><span class="math inline">\text{remove} : \alpha \rightarrow
(\alpha, \beta) \ \text{map} \rightarrow (\alpha, \beta) \
\text{map}</span></td>
</tr>
<tr>
<td><span class="math inline">\text{find} : \alpha \rightarrow (\alpha,
\beta) \ \text{map} \rightarrow \beta</span></td>
</tr>
<tr>
<td>Variables: <span class="math inline">k, k_2 : \alpha</span>, <span
class="math inline">v, v_2 : \beta</span>, <span class="math inline">m :
(\alpha, \beta) \ \text{map}</span></td>
</tr>
<tr>
<td>Axioms:</td>
</tr>
<tr>
<td><span class="math inline">\text{member}(k, \text{add}(k, v, m)) =
\text{true}</span></td>
</tr>
<tr>
<td><span class="math inline">\text{member}(k, \text{remove}(k, m)) =
\text{false}</span></td>
</tr>
<tr>
<td><span class="math inline">\text{member}(k, \text{add}(k_2, v, m)) =
\text{true} \wedge k \neq k_2 \Leftrightarrow \text{member}(k, m) =
\text{true} \wedge k \neq k_2</span></td>
</tr>
<tr>
<td><span class="math inline">\text{member}(k, \text{remove}(k_2, m)) =
\text{true} \wedge k \neq k_2 \Leftrightarrow \text{member}(k, m) =
\text{true} \wedge k \neq k_2</span></td>
</tr>
<tr>
<td><span class="math inline">\text{find}(k, \text{add}(k, v, m)) =
v</span></td>
</tr>
<tr>
<td><span class="math inline">\text{find}(k, \text{remove}(k, m)) =
\text{error}</span>, <span class="math inline">\text{find}(k,
\text{empty}) = \text{error}</span></td>
</tr>
<tr>
<td><span class="math inline">\text{find}(k, \text{add}(k_2, v_2, m)) =
v \wedge k \neq k_2 \Leftrightarrow \text{find}(k, m) = v \wedge k \neq
k_2</span></td>
</tr>
<tr>
<td><span class="math inline">\text{find}(k, \text{remove}(k_2, m)) = v
\wedge k \neq k_2 \Leftrightarrow \text{find}(k, m) = v \wedge k \neq
k_2</span></td>
</tr>
<tr>
<td><span class="math inline">\text{remove}(k, \text{empty}) =
\text{empty}</span></td>
</tr>
</tbody>
</table>
<h3 id="modules-and-interfaces-signatures-syntax">5.7 Modules and
Interfaces (Signatures): Syntax</h3>
<p>In the ML family of languages, structures are given names by
<strong>module</strong> bindings, and signatures are types of modules.
From outside of a structure or signature, we refer to the values or
types it provides with a dot notation: <code>Module.value</code>.</p>
<p>Module (and module type) names have to start with a capital letter
(in ML languages). Since modules and module types have names, there is a
tradition to name the central type of a signature (the one that is
“specified” by the signature), for brevity, <code>t</code>. Module types
are often named with “all-caps” (all letters upper case).</p>
<div class="sourceCode" id="cb117"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">type</span> MAP = <span class="kw">sig</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> (&#39;a, &#39;b) t</span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> empty : (&#39;a, &#39;b) t</span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> member : &#39;a -&gt; (&#39;a, &#39;b) t -&gt; <span class="dt">bool</span></span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> add : &#39;a -&gt; &#39;b -&gt; (&#39;a, &#39;b) t -&gt; (&#39;a, &#39;b) t</span>
<span id="cb117-6"><a href="#cb117-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> remove : &#39;a -&gt; (&#39;a, &#39;b) t -&gt; (&#39;a, &#39;b) t</span>
<span id="cb117-7"><a href="#cb117-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> find : &#39;a -&gt; (&#39;a, &#39;b) t -&gt; &#39;b</span>
<span id="cb117-8"><a href="#cb117-8" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb117-9"><a href="#cb117-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-10"><a href="#cb117-10" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> ListMap : MAP = <span class="kw">struct</span></span>
<span id="cb117-11"><a href="#cb117-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> (&#39;a, &#39;b) t = (&#39;a * &#39;b) <span class="dt">list</span></span>
<span id="cb117-12"><a href="#cb117-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> empty = []</span>
<span id="cb117-13"><a href="#cb117-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> member = <span class="dt">List</span>.mem_assoc</span>
<span id="cb117-14"><a href="#cb117-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> add k v m = (k, v)::m</span>
<span id="cb117-15"><a href="#cb117-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> remove = <span class="dt">List</span>.remove_assoc</span>
<span id="cb117-16"><a href="#cb117-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> find = <span class="dt">List</span>.assoc</span>
<span id="cb117-17"><a href="#cb117-17" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<h3 id="implementing-maps-association-lists">5.8 Implementing Maps:
Association Lists</h3>
<p>Let us now build an implementation of maps from the ground up. The
most straightforward implementation… might not be what you expected:</p>
<div class="sourceCode" id="cb118"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> TrivialMap : MAP = <span class="kw">struct</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> (&#39;a, &#39;b) t =</span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>    | Empty</span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a>    | Add <span class="kw">of</span> &#39;a * &#39;b * (&#39;a, &#39;b) t</span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a>    | Remove <span class="kw">of</span> &#39;a * (&#39;a, &#39;b) t</span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> empty = Empty</span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-9"><a href="#cb118-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> member k m =</span>
<span id="cb118-10"><a href="#cb118-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb118-11"><a href="#cb118-11" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="kw">false</span></span>
<span id="cb118-12"><a href="#cb118-12" aria-hidden="true" tabindex="-1"></a>    | Add (k2, _, _) <span class="kw">when</span> k = k2 -&gt; <span class="kw">true</span></span>
<span id="cb118-13"><a href="#cb118-13" aria-hidden="true" tabindex="-1"></a>    | Remove (k2, _) <span class="kw">when</span> k = k2 -&gt; <span class="kw">false</span></span>
<span id="cb118-14"><a href="#cb118-14" aria-hidden="true" tabindex="-1"></a>    | Add (_, _, m2) -&gt; member k m2</span>
<span id="cb118-15"><a href="#cb118-15" aria-hidden="true" tabindex="-1"></a>    | Remove (_, m2) -&gt; member k m2</span>
<span id="cb118-16"><a href="#cb118-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-17"><a href="#cb118-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> add k v m = Add (k, v, m)</span>
<span id="cb118-18"><a href="#cb118-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> remove k m = Remove (k, m)</span>
<span id="cb118-19"><a href="#cb118-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-20"><a href="#cb118-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> find k m =</span>
<span id="cb118-21"><a href="#cb118-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb118-22"><a href="#cb118-22" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="dt">raise</span> <span class="dt">Not_found</span></span>
<span id="cb118-23"><a href="#cb118-23" aria-hidden="true" tabindex="-1"></a>    | Add (k2, v, _) <span class="kw">when</span> k = k2 -&gt; v</span>
<span id="cb118-24"><a href="#cb118-24" aria-hidden="true" tabindex="-1"></a>    | Remove (k2, _) <span class="kw">when</span> k = k2 -&gt; <span class="dt">raise</span> <span class="dt">Not_found</span></span>
<span id="cb118-25"><a href="#cb118-25" aria-hidden="true" tabindex="-1"></a>    | Add (_, _, m2) -&gt; find k m2</span>
<span id="cb118-26"><a href="#cb118-26" aria-hidden="true" tabindex="-1"></a>    | Remove (_, m2) -&gt; find k m2</span>
<span id="cb118-27"><a href="#cb118-27" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>This “trivial” implementation simply records all operations as a log.
The <code>add</code> and <code>remove</code> operations are <span
class="math inline">O(1)</span>, but <code>member</code> and
<code>find</code> must traverse the entire history.</p>
<p>Here is an implementation based on association lists, i.e., on lists
of key-value pairs:</p>
<div class="sourceCode" id="cb119"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> MyListMap : MAP = <span class="kw">struct</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> (&#39;a, &#39;b) t = Empty | Add <span class="kw">of</span> &#39;a * &#39;b * (&#39;a, &#39;b) t</span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> empty = Empty</span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> member k m =</span>
<span id="cb119-7"><a href="#cb119-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb119-8"><a href="#cb119-8" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="kw">false</span></span>
<span id="cb119-9"><a href="#cb119-9" aria-hidden="true" tabindex="-1"></a>    | Add (k2, _, _) <span class="kw">when</span> k = k2 -&gt; <span class="kw">true</span></span>
<span id="cb119-10"><a href="#cb119-10" aria-hidden="true" tabindex="-1"></a>    | Add (_, _, m2) -&gt; member k m2</span>
<span id="cb119-11"><a href="#cb119-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-12"><a href="#cb119-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> add k v m =</span>
<span id="cb119-13"><a href="#cb119-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb119-14"><a href="#cb119-14" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; Add (k, v, Empty)</span>
<span id="cb119-15"><a href="#cb119-15" aria-hidden="true" tabindex="-1"></a>    | Add (k2, _, m) <span class="kw">when</span> k = k2 -&gt; Add (k, v, m)</span>
<span id="cb119-16"><a href="#cb119-16" aria-hidden="true" tabindex="-1"></a>    | Add (k2, v2, m) -&gt; Add (k2, v2, add k v m)</span>
<span id="cb119-17"><a href="#cb119-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-18"><a href="#cb119-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> remove k m =</span>
<span id="cb119-19"><a href="#cb119-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb119-20"><a href="#cb119-20" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; Empty</span>
<span id="cb119-21"><a href="#cb119-21" aria-hidden="true" tabindex="-1"></a>    | Add (k2, _, m) <span class="kw">when</span> k = k2 -&gt; m</span>
<span id="cb119-22"><a href="#cb119-22" aria-hidden="true" tabindex="-1"></a>    | Add (k2, v, m) -&gt; Add (k2, v, remove k m)</span>
<span id="cb119-23"><a href="#cb119-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-24"><a href="#cb119-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> find k m =</span>
<span id="cb119-25"><a href="#cb119-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb119-26"><a href="#cb119-26" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="dt">raise</span> <span class="dt">Not_found</span></span>
<span id="cb119-27"><a href="#cb119-27" aria-hidden="true" tabindex="-1"></a>    | Add (k2, v, _) <span class="kw">when</span> k = k2 -&gt; v</span>
<span id="cb119-28"><a href="#cb119-28" aria-hidden="true" tabindex="-1"></a>    | Add (_, _, m2) -&gt; find k m2</span>
<span id="cb119-29"><a href="#cb119-29" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<h3 id="implementing-maps-binary-search-trees">5.9 Implementing Maps:
Binary Search Trees</h3>
<p>Binary search trees are binary trees with elements stored at the
interior nodes, such that elements to the left of a node are smaller
than, and elements to the right bigger than, elements within a node.</p>
<p>For maps, we store key-value pairs as elements in binary search
trees, and compare the elements by keys alone.</p>
<p>On average, binary search trees are fast because they use
“divide-and-conquer” to search for the value associated with a key
(<span class="math inline">O(\log n)</span> complexity). In the worst
case, however, they reduce to association lists.</p>
<p>The simple polymorphic signature for maps is only possible with
implementations based on some total order of keys because OCaml has
polymorphic comparison (and equality) operators. These operators work on
elements of most types, but not on functions. They may not work in a way
you would want though! Our signature for polymorphic maps is not the
standard approach because of the problem of needing the order of keys;
it is just to keep things simple.</p>
<div class="sourceCode" id="cb120"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> BTreeMap : MAP = <span class="kw">struct</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> (&#39;a, &#39;b) t = Empty | T <span class="kw">of</span> (&#39;a, &#39;b) t * &#39;a * &#39;b * (&#39;a, &#39;b) t</span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> empty = Empty</span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> member k m =                    <span class="co">(* &quot;Divide and conquer&quot; search through the tree. *)</span></span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="kw">false</span></span>
<span id="cb120-9"><a href="#cb120-9" aria-hidden="true" tabindex="-1"></a>    | T (_, k2, _, _) <span class="kw">when</span> k = k2 -&gt; <span class="kw">true</span></span>
<span id="cb120-10"><a href="#cb120-10" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, _, _) <span class="kw">when</span> k &lt; k2 -&gt; member k m1</span>
<span id="cb120-11"><a href="#cb120-11" aria-hidden="true" tabindex="-1"></a>    | T (_, _, _, m2) -&gt; member k m2</span>
<span id="cb120-12"><a href="#cb120-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-13"><a href="#cb120-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> add k v m =                     <span class="co">(* Searches the tree in the same way as member *)</span></span>
<span id="cb120-14"><a href="#cb120-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span>                          <span class="co">(* but copies every node along the way. *)</span></span>
<span id="cb120-15"><a href="#cb120-15" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; T (Empty, k, v, Empty)</span>
<span id="cb120-16"><a href="#cb120-16" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, _, m2) <span class="kw">when</span> k = k2 -&gt; T (m1, k, v, m2)</span>
<span id="cb120-17"><a href="#cb120-17" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, v2, m2) <span class="kw">when</span> k &lt; k2 -&gt; T (add k v m1, k2, v2, m2)</span>
<span id="cb120-18"><a href="#cb120-18" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, v2, m2) -&gt; T (m1, k2, v2, add k v m2)</span>
<span id="cb120-19"><a href="#cb120-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-20"><a href="#cb120-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> split_rightmost m =             <span class="co">(* A helper function, it does not belong *)</span></span>
<span id="cb120-21"><a href="#cb120-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span>                          <span class="co">(* to the &quot;exported&quot; signature. *)</span></span>
<span id="cb120-22"><a href="#cb120-22" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="dt">raise</span> <span class="dt">Not_found</span></span>
<span id="cb120-23"><a href="#cb120-23" aria-hidden="true" tabindex="-1"></a>    | T (Empty, k, v, Empty) -&gt; k, v, Empty   <span class="co">(* We remove one element, *)</span></span>
<span id="cb120-24"><a href="#cb120-24" aria-hidden="true" tabindex="-1"></a>    | T (m1, k, v, m2) -&gt;                 <span class="co">(* the one that is on the bottom right. *)</span></span>
<span id="cb120-25"><a href="#cb120-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> rk, rv, rm = split_rightmost m2 <span class="kw">in</span></span>
<span id="cb120-26"><a href="#cb120-26" aria-hidden="true" tabindex="-1"></a>        rk, rv, T (m1, k, v, rm)</span>
<span id="cb120-27"><a href="#cb120-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-28"><a href="#cb120-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> remove k m =</span>
<span id="cb120-29"><a href="#cb120-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb120-30"><a href="#cb120-30" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; Empty</span>
<span id="cb120-31"><a href="#cb120-31" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, _, Empty) <span class="kw">when</span> k = k2 -&gt; m1</span>
<span id="cb120-32"><a href="#cb120-32" aria-hidden="true" tabindex="-1"></a>    | T (Empty, k2, _, m2) <span class="kw">when</span> k = k2 -&gt; m2</span>
<span id="cb120-33"><a href="#cb120-33" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, _, m2) <span class="kw">when</span> k = k2 -&gt;</span>
<span id="cb120-34"><a href="#cb120-34" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> rk, rv, rm = split_rightmost m1 <span class="kw">in</span></span>
<span id="cb120-35"><a href="#cb120-35" aria-hidden="true" tabindex="-1"></a>        T (rm, rk, rv, m2)</span>
<span id="cb120-36"><a href="#cb120-36" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, v, m2) <span class="kw">when</span> k &lt; k2 -&gt; T (remove k m1, k2, v, m2)</span>
<span id="cb120-37"><a href="#cb120-37" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, v, m2) -&gt; T (m1, k2, v, remove k m2)</span>
<span id="cb120-38"><a href="#cb120-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-39"><a href="#cb120-39" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> find k m =</span>
<span id="cb120-40"><a href="#cb120-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb120-41"><a href="#cb120-41" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="dt">raise</span> <span class="dt">Not_found</span></span>
<span id="cb120-42"><a href="#cb120-42" aria-hidden="true" tabindex="-1"></a>    | T (_, k2, v, _) <span class="kw">when</span> k = k2 -&gt; v</span>
<span id="cb120-43"><a href="#cb120-43" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, _, _) <span class="kw">when</span> k &lt; k2 -&gt; find k m1</span>
<span id="cb120-44"><a href="#cb120-44" aria-hidden="true" tabindex="-1"></a>    | T (_, _, _, m2) -&gt; find k m2</span>
<span id="cb120-45"><a href="#cb120-45" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<h3 id="implementing-maps-red-black-trees">5.10 Implementing Maps:
Red-Black Trees</h3>
<p>This section is based on Wikipedia’s <a
href="http://en.wikipedia.org/wiki/Red-black_tree">Red-black tree
article</a>, Chris Okasaki’s “Purely Functional Data Structures” and
Matt Might’s excellent blog post on <a
href="http://matt.might.net/articles/red-black-delete/">red-black tree
deletion</a>.</p>
<p>Binary search trees are good when we encounter keys in random order,
because the cost of operations is limited by the depth of the tree which
is small relative to the number of nodes… unless the tree grows
unbalanced achieving large depth (which means there are sibling subtrees
of vastly different sizes on some path).</p>
<p>To remedy this, we <em>rebalance</em> the tree while building it –
i.e., while adding elements.</p>
<p>In <em>red-black trees</em> we achieve balance by: 1. Remembering one
of two colors with each node 2. Keeping the same length of each
root-to-leaf path if only black nodes are counted 3. Not allowing a red
node to have a red child</p>
<p>This way the depth is at most twice the depth of a perfectly balanced
tree with the same number of nodes.</p>
<h4 id="b-trees-of-order-4-2-3-4-trees">5.10.1 B-trees of Order 4 (2-3-4
Trees)</h4>
<p>How can we have perfectly balanced trees without worrying about
having <span class="math inline">2^k - 1</span> elements? <strong>2-3-4
trees</strong> can store from 1 to 3 elements in each node and have 2 to
4 subtrees correspondingly. Lots of freedom!</p>
<p>A 2-node contains one element and has two children. A 3-node contains
two elements and has three children. A 4-node contains three elements
and has four children.</p>
<p>To insert “25” into a 2-3-4 tree, we descend right, but if we
encounter a full node (4-node), we move the middle element up and split
the remaining elements. This maintains balance at all times.</p>
<p>To represent a 2-3-4 tree as a binary tree with one element per node,
we color the middle element of a 4-node, or the first element of a
2-/3-node, black and make it the parent of its neighbor elements, and
make them parents of the original subtrees. This correspondence provides
the intuition behind red-black trees.</p>
<h4 id="red-black-trees-without-deletion">5.10.2 Red-Black Trees,
Without Deletion</h4>
<p>Red-black trees maintain two invariants:</p>
<p><strong>Invariant 1.</strong> No red node has a red child.</p>
<p><strong>Invariant 2.</strong> Every path from the root to an empty
node contains the same number of black nodes.</p>
<p>First we implement red-black tree based sets without deletion. The
implementation proceeds almost exactly like for unbalanced binary search
trees; we only need to restore invariants.</p>
<p>By keeping balance at each step of constructing a node, it is enough
to check locally (around the root of the subtree). For an understandable
implementation of deletion, we need to introduce more colors – see Matt
Might’s post.</p>
<div class="sourceCode" id="cb121"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> color = R | B</span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a t = E | T <span class="kw">of</span> color * &#39;a t * &#39;a * &#39;a t</span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> empty = E</span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> member x m =                     <span class="co">(* Like in unbalanced binary search tree. *)</span></span>
<span id="cb121-7"><a href="#cb121-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb121-8"><a href="#cb121-8" aria-hidden="true" tabindex="-1"></a>  | E -&gt; <span class="kw">false</span></span>
<span id="cb121-9"><a href="#cb121-9" aria-hidden="true" tabindex="-1"></a>  | T (_, _, y, _) <span class="kw">when</span> x = y -&gt; <span class="kw">true</span></span>
<span id="cb121-10"><a href="#cb121-10" aria-hidden="true" tabindex="-1"></a>  | T (_, a, y, _) <span class="kw">when</span> x &lt; y -&gt; member x a</span>
<span id="cb121-11"><a href="#cb121-11" aria-hidden="true" tabindex="-1"></a>  | T (_, _, _, b) -&gt; member x b</span>
<span id="cb121-12"><a href="#cb121-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-13"><a href="#cb121-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> balance = <span class="kw">function</span>                   <span class="co">(* Restoring the invariants. *)</span></span>
<span id="cb121-14"><a href="#cb121-14" aria-hidden="true" tabindex="-1"></a>  | B, T (R, T (R,a,x,b), y, c), z, d    <span class="co">(* On next figure: left, *)</span></span>
<span id="cb121-15"><a href="#cb121-15" aria-hidden="true" tabindex="-1"></a>  | B, T (R, a, x, T (R,b,y,c)), z, d    <span class="co">(* top, *)</span></span>
<span id="cb121-16"><a href="#cb121-16" aria-hidden="true" tabindex="-1"></a>  | B, a, x, T (R, T (R,b,y,c), z, d)    <span class="co">(* bottom, *)</span></span>
<span id="cb121-17"><a href="#cb121-17" aria-hidden="true" tabindex="-1"></a>  | B, a, x, T (R, b, y, T (R,c,z,d))    <span class="co">(* right, *)</span></span>
<span id="cb121-18"><a href="#cb121-18" aria-hidden="true" tabindex="-1"></a>      -&gt; T (R, T (B,a,x,b), y, T (B,c,z,d))    <span class="co">(* center tree. *)</span></span>
<span id="cb121-19"><a href="#cb121-19" aria-hidden="true" tabindex="-1"></a>  | color, a, x, b -&gt; T (color, a, x, b)       <span class="co">(* We allow red-red violation for now. *)</span></span>
<span id="cb121-20"><a href="#cb121-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-21"><a href="#cb121-21" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> insert x s =</span>
<span id="cb121-22"><a href="#cb121-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> ins = <span class="kw">function</span>                 <span class="co">(* Like in unbalanced binary search tree, *)</span></span>
<span id="cb121-23"><a href="#cb121-23" aria-hidden="true" tabindex="-1"></a>    | E -&gt; T (R, E, x, E)                <span class="co">(* but fix violation above created node. *)</span></span>
<span id="cb121-24"><a href="#cb121-24" aria-hidden="true" tabindex="-1"></a>    | T (color, a, y, b) <span class="kw">as</span> s -&gt;</span>
<span id="cb121-25"><a href="#cb121-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> x &lt; y <span class="kw">then</span> balance (color, ins a, y, b)</span>
<span id="cb121-26"><a href="#cb121-26" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="kw">if</span> x &gt; y <span class="kw">then</span> balance (color, a, y, ins b)</span>
<span id="cb121-27"><a href="#cb121-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> s</span>
<span id="cb121-28"><a href="#cb121-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb121-29"><a href="#cb121-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> ins s <span class="kw">with</span>                       <span class="co">(* We could still have red-red violation at root, *)</span></span>
<span id="cb121-30"><a href="#cb121-30" aria-hidden="true" tabindex="-1"></a>  | T (_, a, y, b) -&gt; T (B, a, y, b)     <span class="co">(* fixed by coloring it black. *)</span></span>
<span id="cb121-31"><a href="#cb121-31" aria-hidden="true" tabindex="-1"></a>  | E -&gt; <span class="dt">failwith</span> <span class="st">&quot;insert: impossible&quot;</span></span></code></pre></div>
<p>The <code>balance</code> function handles four cases where a red-red
violation occurs (a red node with a red child). In each case, we
restructure the tree to eliminate the violation while maintaining the
binary search tree property. All four cases produce the same balanced
result: a red root with two black children.</p>
<h3 id="exercises-4">Exercises</h3>
<p><strong>Exercise 1.</strong> Derive the equations and solve them to
find the type for:</p>
<div class="sourceCode" id="cb122"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cadr l = <span class="dt">List</span>.hd (<span class="dt">List</span>.tl l) <span class="kw">in</span> cadr (<span class="dv">1</span>::<span class="dv">2</span>::[]), cadr (<span class="kw">true</span>::<span class="kw">false</span>::[])</span></code></pre></div>
<p>in environment <span class="math inline">\Gamma = \{ \text{List.hd} :
\forall \alpha . \alpha \ \text{list} \rightarrow \alpha ;
\text{List.tl} : \forall \alpha . \alpha \ \text{list} \rightarrow
\alpha \ \text{list} \}</span>. You can take “shortcuts” if it is too
many equations to write down.</p>
<p><strong>Exercise 2.</strong> <em>Terms</em> <span
class="math inline">t_1, t_2, \ldots \in T(\Sigma, X)</span> are built
out of variables <span class="math inline">x, y, \ldots \in X</span> and
function symbols <span class="math inline">f, g, \ldots \in
\Sigma</span> the way you build values out of functions:</p>
<ul>
<li><span class="math inline">X \subset T(\Sigma, X)</span> – variables
are terms; usually an infinite set,</li>
<li>for terms <span class="math inline">t_1, \ldots, t_n \in T(\Sigma,
X)</span> and a function symbol <span class="math inline">f \in
\Sigma_n</span> of arity <span class="math inline">n</span>, <span
class="math inline">f(t_1, \ldots, t_n) \in T(\Sigma, X)</span> – bigger
terms arise from applying function symbols to smaller terms; <span
class="math inline">\Sigma = \dot{\cup}_n \Sigma_n</span> is called a
signature.</li>
</ul>
<p>In OCaml, we can define terms as:
<code>type term = V of string | T of string * term list</code>, where
for example <code>V("x")</code> is a variable <span
class="math inline">x</span> and <code>T("f", [V("x"); V("y")])</code>
is the term <span class="math inline">f(x, y)</span>.</p>
<p>By <em>substitutions</em> <span class="math inline">\sigma, \rho,
\ldots</span> we mean finite sets of variable-term pairs which we can
write as <span class="math inline">\{x_1 \mapsto t_1, \ldots, x_k
\mapsto t_k\}</span> or <span class="math inline">[x_1 := t_1; \ldots;
x_k := t_k]</span>, but also functions from terms to terms <span
class="math inline">\sigma : T(\Sigma, X) \rightarrow T(\Sigma,
X)</span> related to the pairs as follows: if <span
class="math inline">\sigma = \{x_1 \mapsto t_1, \ldots, x_k \mapsto
t_k\}</span>, then</p>
<ul>
<li><span class="math inline">\sigma(x_i) = t_i</span> for <span
class="math inline">x_i \in \{x_1, \ldots, x_k\}</span>,</li>
<li><span class="math inline">\sigma(x) = x</span> for <span
class="math inline">x \in X \setminus \{x_1, \ldots, x_k\}</span>,</li>
<li><span class="math inline">\sigma(f(t_1, \ldots, t_n)) =
f(\sigma(t_1), \ldots, \sigma(t_n))</span>.</li>
</ul>
<p>In OCaml, we can define substitutions <span
class="math inline">\sigma</span> as:
<code>type subst = (string * term) list</code>, together with a function
<code>apply : subst -&gt; term -&gt; term</code> which computes <span
class="math inline">\sigma(\cdot)</span>.</p>
<p>We say that a substitution <span class="math inline">\sigma</span> is
<em>more general</em> than all substitutions <span
class="math inline">\rho \circ \sigma</span>, where <span
class="math inline">(\rho \circ \sigma)(x) = \rho(\sigma(x))</span>. In
type inference, we are interested in most general solutions.</p>
<p>A <em>unification problem</em> is a finite set of equations <span
class="math inline">S = \{s_1 =^? t_1, \ldots, s_n =^? t_n\}</span>. A
solution, or <em>unifier</em> of <span class="math inline">S</span>, is
a substitution <span class="math inline">\sigma</span> such that <span
class="math inline">\sigma(s_i) = \sigma(t_i)</span> for <span
class="math inline">i = 1, \ldots, n</span>. A <em>most general
unifier</em>, or <em>MGU</em>, is a most general such substitution.</p>
<ol type="1">
<li><p>Implement an algorithm that, given a set of equations represented
as a list of pairs of terms, computes an idempotent most general unifier
of the equations.</p></li>
<li><p>(Ex. 4.22 in Franz Baader and Tobias Nipkow “Term Rewriting and
All That”, p. 82.) Modify the implementation of unification to achieve
linear space complexity by working with what could be called iterated
substitutions.</p></li>
</ol>
<p><strong>Exercise 3.</strong></p>
<ol type="1">
<li>What does it mean that an implementation has junk (as an algebraic
structure for a given signature)? Is it bad?</li>
<li>Define a monomorphic algebraic specification (other than, but
similar to, <span class="math inline">\text{nat}_p</span> or <span
class="math inline">\text{string}_p</span>, some useful data type).</li>
<li>Discuss an example of a (monomorphic) algebraic specification where
it would be useful to drop some axioms (giving up monomorphicity) to
allow more efficient implementations.</li>
</ol>
<p><strong>Exercise 4.</strong></p>
<ol type="1">
<li><p>Does the example <code>ListMap</code> meet the requirements of
the algebraic specification for maps? Hint: here is the definition of
<code>List.remove_assoc</code>; <code>compare a x</code> equals
<code>0</code> if and only if <code>a = x</code>.</p>
<div class="sourceCode" id="cb123"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> remove_assoc x = <span class="kw">function</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; []</span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>  | (a, b <span class="kw">as</span> pair) :: l -&gt;</span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> <span class="dt">compare</span> a x = <span class="dv">0</span> <span class="kw">then</span> l <span class="kw">else</span> pair :: remove_assoc x l</span></code></pre></div></li>
<li><p>Trick question: what is the computational complexity of
<code>ListMap</code> or <code>TrivialMap</code>?</p></li>
<li><p>(*) The implementation <code>MyListMap</code> is inefficient: it
performs a lot of copying and is not tail-recursive. Optimize it
(without changing the type definition).</p></li>
<li><p>Add (and specify) <span class="math inline">\text{isEmpty} :
(\alpha, \beta) \ \text{map} \rightarrow \text{bool}</span> to the
example algebraic specification of maps without increasing the burden on
its implementations. Hint: equational reasoning might be not enough;
consider an equivalence relation <span
class="math inline">\approx</span> meaning “have the same
keys”.</p></li>
</ol>
<p><strong>Exercise 5.</strong> Design an algebraic specification and
write a signature for first-in-first-out queues. Provide two
implementations: one straightforward using a list, and another one using
two lists: one for freshly added elements providing efficient queueing
of new elements, and “reversed” one for efficient popping of old
elements.</p>
<p><strong>Exercise 6.</strong> Design an algebraic specification and
write a signature for sets. Provide two implementations: one
straightforward using a list, and another one using a map into the unit
type.</p>
<p><strong>Exercise 7.</strong></p>
<ol type="1">
<li><p>(Ex. 2.2 in Chris Okasaki “Purely Functional Data Structures”) In
the worst case, <code>member</code> performs approximately <span
class="math inline">2d</span> comparisons, where <span
class="math inline">d</span> is the depth of the tree. Rewrite
<code>member</code> to take no more than <span class="math inline">d +
1</span> comparisons by keeping track of a candidate element that
<em>might</em> be equal to the query element (say, the last element for
which <span class="math inline">&lt;</span> returned false) and checking
for equality only when you hit the bottom of the tree.</p></li>
<li><p>(Ex. 3.10 in Chris Okasaki “Purely Functional Data Structures”)
The <code>balance</code> function currently performs several unnecessary
tests: when e.g. <code>ins</code> recurses on the left child, there are
no violations on the right child.</p>
<ul>
<li>Split <code>balance</code> into <code>lbalance</code> and
<code>rbalance</code> that test for violations of left resp. right child
only. Replace calls to <code>balance</code> appropriately.</li>
<li>One of the remaining tests on grandchildren is also unnecessary.
Rewrite <code>ins</code> so that it never tests the color of nodes not
on the search path.</li>
</ul></li>
</ol>
<p><strong>Exercise 8.</strong> (*) Implement maps (i.e. write a module
for the map signature) based on AVL trees. See
<code>http://en.wikipedia.org/wiki/AVL_tree</code>.</p>
<h2 id="chapter-6-folding-and-backtracking">Chapter 6: Folding and
Backtracking</h2>
<p>This chapter explores two fundamental programming paradigms in
functional programming: <strong>folding</strong> (also known as
reduction) and <strong>backtracking</strong>. We begin with the classic
<code>map</code> and <code>fold</code> higher-order functions, examine
how they generalize to trees and other data structures, then move on to
solving puzzles using backtracking with lists.</p>
<h3 id="basic-generic-list-operations">6.1 Basic Generic List
Operations</h3>
<p>Functional programming emphasizes identifying common patterns and
abstracting them into reusable higher-order functions. Let us see how
this works in practice.</p>
<h4 id="the-map-function">The <code>map</code> Function</h4>
<p>Consider the problem of printing a comma-separated list of integers.
The <code>String</code> module provides:</p>
<pre><code>val concat : string -&gt; string list -&gt; string</code></pre>
<p>First, we need to convert numbers into strings:</p>
<p>```ocaml env=ch6 let rec strings_of_ints = function | [] -&gt; [] |
hd::tl -&gt; string_of_int hd :: strings_of_ints tl</p>
<p>let comma_sep_ints = String.concat “,” -| strings_of_ints</p>
<pre><code>
Similarly, to sort strings from shortest to longest, we first compute lengths:

```ocaml env=ch6
let rec strings_lengths = function
  | [] -&gt; []
  | hd::tl -&gt; (String.length hd, hd) :: strings_lengths tl

let by_size = List.sort compare -| strings_lengths</code></pre>
<p>Notice the common structure in <code>strings_of_ints</code> and
<code>strings_lengths</code>: both transform each element of a list
independently. We can extract this pattern into a generic function
called <code>map</code>:</p>
<p><code>ocaml env=ch6 let rec list_map f = function   | [] -&gt; []   | hd::tl -&gt; f hd :: list_map f tl</code></p>
<p>Now we can rewrite our functions more concisely:</p>
<p>```ocaml env=ch6 let comma_sep_ints = String.concat “,” -| list_map
string_of_int</p>
<p>let by_size = List.sort compare -| list_map (fun s -&gt;
String.length s, s)</p>
<pre><code>
#### The `fold` Function

Consider summing elements of a list:

```ocaml env=ch6
let rec balance = function
  | [] -&gt; 0
  | hd::tl -&gt; hd + balance tl</code></pre>
<p>Or multiplying elements:</p>
<p><code>ocaml env=ch6 let rec total_ratio = function   | [] -&gt; 1.   | hd::tl -&gt; hd *. total_ratio tl</code></p>
<p>The pattern is the same: we combine each element with the result of
processing the rest of the list. This is the <strong>fold</strong>
operation:</p>
<p><code>ocaml env=ch6 let rec list_fold f base = function   | [] -&gt; base   | hd::tl -&gt; f hd (list_fold f base tl)</code></p>
<p><strong>Important:</strong> Note that <code>list_fold f base l</code>
equals <code>List.fold_right f l base</code>. The OCaml standard library
uses a different argument order.</p>
<p>The key insight is that <code>map</code> alters the <em>contents</em>
of data without changing its structure, while <code>fold</code> computes
a value using the structure as scaffolding. Visually:</p>
<ul>
<li><code>map</code> transforms: <code>[a; b; c; d]</code> becomes
<code>[f a; f b; f c; f d]</code></li>
<li><code>fold</code> collapses: <code>[a; b; c; d]</code> becomes
<code>f a (f b (f c (f d accu)))</code></li>
</ul>
<h3 id="making-fold-tail-recursive">6.2 Making Fold Tail-Recursive</h3>
<p>Let us investigate tail-recursive functions. Consider reversing a
list:</p>
<p><code>ocaml env=ch6 let rec list_rev acc = function   | [] -&gt; acc   | hd::tl -&gt; list_rev (hd::acc) tl</code></p>
<p>Or computing an average:</p>
<p><code>ocaml env=ch6 let rec average (sum, tot) = function   | [] when tot = 0. -&gt; 0.   | [] -&gt; sum /. tot   | hd::tl -&gt; average (hd +. sum, 1. +. tot) tl</code></p>
<p>The pattern here is different from <code>fold_right</code>. We
process elements from left to right, accumulating a result:</p>
<p><code>ocaml env=ch6 let rec fold_left f accu = function   | [] -&gt; accu   | a::l -&gt; fold_left f (f accu a) l</code></p>
<p>With <code>fold_left</code>, hiding the accumulator is
straightforward:</p>
<p>```ocaml env=ch6 let list_rev l = fold_left (fun t h -&gt; h::t) []
l</p>
<p>let average = fold_left (fun (sum, tot) e -&gt; sum +. e, 1. +. tot)
(0., 0.)</p>
<pre><code>
The naming convention for `fold_right` and `fold_left` reflects associativity:

- `fold_right f` makes `f` **right associative**, like the list constructor `::`:
  `List.fold_right f [a1; ...; an] b` is `f a1 (f a2 (... (f an b) ...))`

- `fold_left f` makes `f` **left associative**, like function application:
  `List.fold_left f a [b1; ...; bn]` is `f (... (f (f a b1) b2) ...) bn`

The &quot;backward&quot; structure of `fold_left` — the input list has a right-leaning spine,
while the computation tree has a left-leaning spine:
</code></pre>
<pre><code>Input list              Result computation

    ::                         f
   /  \                       / \
  a    ::                    f   d
      /  \                  / \
     b    ::               f   c
         /  \             / \
        c    ::          f   b
            /  \        / \
           d    []  accu   a</code></pre>
<pre><code>
#### Useful Derived Functions

List filtering is naturally expressed using `fold_right`:

```ocaml env=ch6
let list_filter p l =
  List.fold_right (fun h t -&gt; if p h then h::t else t) l []</code></pre>
<p>A tail-recursive map that returns elements in reverse order:</p>
<p><code>ocaml env=ch6 let list_rev_map f l =   List.fold_left (fun t h -&gt; f h :: t) [] l</code></p>
<h3 id="map-and-fold-for-trees-and-other-structures">6.3 Map and Fold
for Trees and Other Structures</h3>
<h4 id="binary-trees">Binary Trees</h4>
<p>Mapping binary trees is straightforward:</p>
<p>```ocaml env=ch6 type ’a btree = Empty | Node of ’a * ’a btree * ’a
btree</p>
<p>let rec bt_map f = function | Empty -&gt; Empty | Node (e, l, r)
-&gt; Node (f e, bt_map f l, bt_map f r)</p>
<p>let test = Node (3, Node (5, Empty, Empty), Node (7, Empty, Empty))
let _ = bt_map ((+) 1) test</p>
<pre><code>
The `map` and `fold` functions we consider here preserve/respect the structure of data. They do **not** correspond to `map` and `fold` of abstract data type containers (which are like `List.rev_map` and `List.fold_left` over container elements in arbitrary order). Here we generalize `List.map` and `List.fold_right` to other structures.

The most general form of `fold` for binary trees processes each element together with partial results from subtrees:

```ocaml env=ch6
let rec bt_fold f base = function
  | Empty -&gt; base
  | Node (e, l, r) -&gt;
    f e (bt_fold f base l) (bt_fold f base r)</code></pre>
<p>Examples:</p>
<p><code>ocaml env=ch6 let sum_els = bt_fold (fun i l r -&gt; i + l + r) 0 let depth t = bt_fold (fun _ l r -&gt; 1 + max l r) 1 t</code></p>
<h4 id="more-complex-structures-expressions">More Complex Structures:
Expressions</h4>
<p>To demonstrate map and fold for more complex structures, we recall
the expression type from Chapter 3:</p>
<p><code>ocaml env=ch6 type expression =     Const of float   | Var of string   | Sum of expression * expression    (* e1 + e2 *)   | Diff of expression * expression   (* e1 - e2 *)   | Prod of expression * expression   (* e1 * e2 *)   | Quot of expression * expression   (* e1 / e2 *)</code></p>
<p>The multitude of cases makes the datatype harder to work with.
Fortunately, <em>or-patterns</em> help:</p>
<p><code>ocaml env=ch6 let rec vars = function   | Const _ -&gt; []   | Var x -&gt; [x]   | Sum (a,b) | Diff (a,b) | Prod (a,b) | Quot (a,b) -&gt;     vars a @ vars b</code></p>
<p>Mapping and folding must be specialized for each case. We pack
behaviors into records:</p>
<p>```ocaml env=ch6 type expression_map = { map_const : float -&gt;
expression; map_var : string -&gt; expression; map_sum : expression
-&gt; expression -&gt; expression; map_diff : expression -&gt;
expression -&gt; expression; map_prod : expression -&gt; expression
-&gt; expression; map_quot : expression -&gt; expression -&gt;
expression; }</p>
<p>(* Note: ’a replaces expression because fold produces values of
arbitrary type *) type ’a expression_fold = { fold_const : float -&gt;
’a; fold_var : string -&gt; ’a; fold_sum : ’a -&gt; ’a -&gt; ’a;
fold_diff : ’a -&gt; ’a -&gt; ’a; fold_prod : ’a -&gt; ’a -&gt; ’a;
fold_quot : ’a -&gt; ’a -&gt; ’a; }</p>
<pre><code>
We define standard behaviors that can be tailored for specific uses:

```ocaml env=ch6
let identity_map = {
  map_const = (fun c -&gt; Const c);
  map_var = (fun x -&gt; Var x);
  map_sum = (fun a b -&gt; Sum (a, b));
  map_diff = (fun a b -&gt; Diff (a, b));
  map_prod = (fun a b -&gt; Prod (a, b));
  map_quot = (fun a b -&gt; Quot (a, b));
}

let make_fold op base = {
  fold_const = (fun _ -&gt; base);
  fold_var = (fun _ -&gt; base);
  fold_sum = op; fold_diff = op;
  fold_prod = op; fold_quot = op;
}</code></pre>
<p>The actual <code>map</code> and <code>fold</code> functions:</p>
<p>```ocaml env=ch6 let rec expr_map emap = function | Const c -&gt;
emap.map_const c | Var x -&gt; emap.map_var x | Sum (a,b) -&gt;
emap.map_sum (expr_map emap a) (expr_map emap b) | Diff (a,b) -&gt;
emap.map_diff (expr_map emap a) (expr_map emap b) | Prod (a,b) -&gt;
emap.map_prod (expr_map emap a) (expr_map emap b) | Quot (a,b) -&gt;
emap.map_quot (expr_map emap a) (expr_map emap b)</p>
<p>let rec expr_fold efold = function | Const c -&gt; efold.fold_const c
| Var x -&gt; efold.fold_var x | Sum (a,b) -&gt; efold.fold_sum
(expr_fold efold a) (expr_fold efold b) | Diff (a,b) -&gt;
efold.fold_diff (expr_fold efold a) (expr_fold efold b) | Prod (a,b)
-&gt; efold.fold_prod (expr_fold efold a) (expr_fold efold b) | Quot
(a,b) -&gt; efold.fold_quot (expr_fold efold a) (expr_fold efold b)</p>
<pre><code>
Using the `{record with field = value}` syntax to customize behaviors:

```ocaml env=ch6
let prime_vars = expr_map
  {identity_map with map_var = fun x -&gt; Var (x ^ &quot;&#39;&quot;)}

let subst s =
  let apply x = try List.assoc x s with Not_found -&gt; Var x in
  expr_map {identity_map with map_var = apply}

let vars =
  expr_fold {(make_fold (@) []) with fold_var = fun x -&gt; [x]}

let size = expr_fold (make_fold (fun a b -&gt; 1 + a + b) 1)

let eval env = expr_fold {
  fold_const = id;
  fold_var = (fun x -&gt; List.assoc x env);
  fold_sum = (+.); fold_diff = (-.);
  fold_prod = ( *.); fold_quot = (/.);
}</code></pre>
<h3 id="point-free-programming">6.4 Point-Free Programming</h3>
<p>In 1977/78, John Backus designed <strong>FP</strong>, the first
<em>function-level programming</em> language. Over the next decade it
evolved into the <strong>FL</strong> language.</p>
<blockquote>
<p>“Clarity is achieved when programs are written at the function
level–that is, by putting together existing programs to form new ones,
rather than by manipulating objects and then abstracting from those
objects to produce programs.” – <em>The FL Project: The Design of a
Functional Language</em></p>
</blockquote>
<p>For function-level programming, we need combinators like these from
<em>OCaml Batteries</em>:</p>
<p><code>ocaml env=ch6 let const x _ = x let ( |- ) f g x = g (f x)          (* forward composition *) let ( -| ) f g x = f (g x)          (* backward composition *) let flip f x y = f y x let ( *** ) f g = fun (x,y) -&gt; (f x, g y) let ( &amp;&amp;&amp; ) f g = fun x -&gt; (f x, g x) let first f x = fst (f x) let second f x = snd (f x) let curry f x y = f (x,y) let uncurry f (x,y) = f x y</code></p>
<p>The flow of computation can be viewed as a circuit where results of
nodes (functions) connect to further nodes as inputs. We represent
cross-sections of the circuit as tuples of intermediate values.</p>
<p><code>ocaml env=ch6 let print2 c i =   let a = Char.escaped c in   let b = string_of_int i in   a ^ b</code></p>
<p>In point-free style:</p>
<p><code>ocaml env=ch6 let print2 = curry   ((Char.escaped *** string_of_int) |- uncurry (^))</code></p>
<p>Since we usually pass arguments one at a time rather than in tuples,
we need <code>uncurry</code> to access multi-argument functions.
Converting a C/Pascal-like function to one that takes arguments one at a
time is called <em>currying</em>, after logician Haskell Brooks
Curry.</p>
<p>Another approach uses function composition, <code>flip</code>, and
the <strong>S</strong> combinator:</p>
<p><code>ocaml env=ch6 let s x y z = x z (y z)</code></p>
<p>Example: transforming a filter-map function step by step:</p>
<p><code>ocaml env=ch6 let func2 f g l = List.filter f (List.map g l) (* Using composition: *) let func2 f g = (-|) (List.filter f) (List.map g) let func2 f = (-|) (List.filter f) -| List.map (* Eliminating f: *) let func2 f = (-|) ((-|) (List.filter f)) List.map let func2 f = flip (-|) List.map ((-|) (List.filter f)) let func2 f = (((|-) List.map) -| ((-|) -| List.filter)) f let func2 = (|-) List.map -| ((-|) -| List.filter)</code></p>
<h3 id="reductions-and-more-higher-order-functions">6.5 Reductions and
More Higher-Order Functions</h3>
<p>Mathematics has notation for sums over intervals: <span
class="math inline">\sum_{n=a}^{b} f(n)</span>.</p>
<p>In OCaml, we do not have a universal addition operator:</p>
<p>```ocaml env=ch6 let rec i_sum_fromto f a b = if a &gt; b then 0 else
f a + i_sum_fromto f (a+1) b</p>
<p>let rec f_sum_fromto f a b = if a &gt; b then 0. else f a +.
f_sum_fromto f (a+1) b</p>
<p>let pi2_over6 = f_sum_fromto (fun i -&gt; 1. /. float_of_int (i*i)) 1
5000</p>
<pre><code>
The natural generalization:

```ocaml env=ch6
let rec op_fromto op base f a b =
  if a &gt; b then base
  else op (f a) (op_fromto op base f (a+1) b)</code></pre>
<h4 id="collecting-results-concat_map">Collecting Results:
concat_map</h4>
<p>Let us collect results of a multifunction (set-valued function) for a
set of arguments. In mathematical notation:</p>
<p><span class="math display">f(A) = \bigcup_{p \in A} f(p)</span></p>
<p>This translates to a useful list operation with union as append:</p>
<p><code>ocaml env=ch6 let rec concat_map f = function   | [] -&gt; []   | a::l -&gt; f a @ concat_map f l</code></p>
<p>More efficiently (tail-recursive):</p>
<p><code>ocaml env=ch6 let concat_map f l =   let rec cmap_f accu = function     | [] -&gt; accu     | a::l -&gt; cmap_f (List.rev_append (f a) accu) l in   List.rev (cmap_f [] l)</code></p>
<h4 id="all-subsequences-of-a-list">All Subsequences of a List</h4>
<p><code>ocaml env=ch6 let rec subseqs l =   match l with     | [] -&gt; [[]]     | x::xs -&gt;       let pxs = subseqs xs in       List.map (fun px -&gt; x::px) pxs @ pxs</code></p>
<p>Tail-recursively:</p>
<p>```ocaml env=ch6 let rec rmap_append f accu = function | [] -&gt;
accu | a::l -&gt; rmap_append f (f a :: accu) l</p>
<p>let rec subseqs l = match l with | [] -&gt; [[]] | x::xs -&gt; let
pxs = subseqs xs in rmap_append (fun px -&gt; x::px) pxs pxs</p>
<pre><code>
#### Permutations and Choices

To generate all permutations, we interleave each element into all positions:

```ocaml env=ch6
let rec interleave x = function
  | [] -&gt; [[x]]
  | y::ys -&gt; (x::y::ys) :: List.map (fun zs -&gt; y::zs) (interleave x ys)

let rec perms = function
  | [] -&gt; [[]]
  | x::xs -&gt; concat_map (interleave x) (perms xs)</code></pre>
<p>For the Countdown problem, we need all non-empty subsequences with
all their permutations:</p>
<p><code>ocaml env=ch6 let choices l = concat_map perms (List.filter ((&lt;&gt;) []) (subseqs l))</code></p>
<h3 id="grouping-and-map-reduce">6.6 Grouping and Map-Reduce</h3>
<p>It is often useful to organize values by some property.</p>
<h4 id="collecting-by-key">Collecting by Key</h4>
<p>First, we collect elements from an association list by key:</p>
<p><code>ocaml env=ch6 let collect l =   match List.sort (fun x y -&gt; compare (fst x) (fst y)) l with   | [] -&gt; []                                (* Start with associations sorted by key *)   | (k0, v0)::tl -&gt;     let k0, vs, l = List.fold_left       (fun (k0, vs, l) (kn, vn) -&gt;           (* Collect values for current key *)         if k0 = kn then k0, vn::vs, l        (* and when the key changes, *)         else kn, [vn], (k0, List.rev vs)::l) (* stack the collected values *)       (k0, [v0], []) tl in                   (* Why reverse? To preserve order *)     List.rev ((k0, List.rev vs)::l)</code></p>
<p>Now we can group by an arbitrary property:</p>
<p><code>ocaml env=ch6 let group_by p l = collect (List.map (fun e -&gt; p e, e) l)</code></p>
<h4 id="reduction-aggregation">Reduction (Aggregation)</h4>
<p>To process results like SQL aggregate operations, we add
<strong>reduction</strong>:</p>
<p><code>ocaml env=ch6 let aggregate_by p red base l =   let ags = group_by p l in   List.map (fun (k, vs) -&gt; k, List.fold_right red vs base) ags</code></p>
<p>Using the <strong>feed-forward</strong> (pipe) operator
<code>let ( |&gt; ) x f = f x</code>:</p>
<p><code>ocaml env=ch6 let aggregate_by p redf base l =   group_by p l   |&gt; List.map (fun (k, vs) -&gt; k, List.fold_right redf vs base)</code></p>
<p>Often it is easier to extract the property upfront. Since we first
map elements into key-value pairs, we call this
<code>map_reduce</code>:</p>
<p><code>ocaml env=ch6 let map_reduce mapf redf base l =   List.map mapf l   |&gt; collect   |&gt; List.map (fun (k, vs) -&gt; k, List.fold_right redf vs base)</code></p>
<h4 id="map-reduce-examples">Map-Reduce Examples</h4>
<p>Sometimes we have multiple sources of information:</p>
<p><code>ocaml env=ch6 let concat_reduce mapf redf base l =   concat_map mapf l   |&gt; collect   |&gt; List.map (fun (k, vs) -&gt; k, List.fold_right redf vs base)</code></p>
<p>Computing a merged histogram of documents:</p>
<p><code>ocaml env=ch6 let histogram documents =   let mapf doc =     Str.split (Str.regexp "[ \t.,;]+") doc     |&gt; List.map (fun word -&gt; word, 1) in   concat_reduce mapf (+) 0 documents</code></p>
<p>Computing an inverted index:</p>
<p>```ocaml env=ch6 let cons hd tl = hd::tl</p>
<p>let inverted_index documents = let mapf (addr, doc) = Str.split
(Str.regexp “[ ,;]+”) doc |&gt; List.map (fun word -&gt; word, addr) in
concat_reduce mapf cons [] documents</p>
<pre><code>
Set intersection is computed using `intersect` for sets represented as sorted lists:

```ocaml env=ch6
let intersect xs ys =                       (* Sets as sorted lists *)
  let rec aux acc = function
    | [], _ | _, [] -&gt; acc
    | (x::xs&#39; as xs), (y::ys&#39; as ys) -&gt;
      let c = compare x y in
      if c = 0 then aux (x::acc) (xs&#39;, ys&#39;)
      else if c &lt; 0 then aux acc (xs&#39;, ys)
      else aux acc (xs, ys&#39;) in
  List.rev (aux [] (xs, ys))</code></pre>
<p>A simple “search engine”:</p>
<p><code>ocaml env=ch6 let search index words =   match List.map (flip List.assoc index) words with   | [] -&gt; []   | idx::idcs -&gt; List.fold_left intersect idx idcs</code></p>
<h3 id="higher-order-functions-for-the-option-type">6.7 Higher-Order
Functions for the Option Type</h3>
<p>Operating on optional values:</p>
<p><code>ocaml env=ch6 let map_option f = function   | None -&gt; None   | Some e -&gt; f e</code></p>
<p>Mapping over a list and filtering out failures:</p>
<p><code>ocaml env=ch6 let rec map_some f = function   | [] -&gt; []   | e::l -&gt; match f e with     | None -&gt; map_some f l     | Some r -&gt; r :: map_some f l</code></p>
<p>Tail-recursively:</p>
<p><code>ocaml env=ch6 let map_some f l =   let rec maps_f accu = function     | [] -&gt; accu     | a::l -&gt; maps_f (match f a with None -&gt; accu       | Some r -&gt; r::accu) l in   List.rev (maps_f [] l)</code></p>
<h3 id="the-countdown-problem-puzzle">6.8 The Countdown Problem
Puzzle</h3>
<p>The Countdown Problem is a classic puzzle:</p>
<ul>
<li>Using a given set of numbers and arithmetic operators +, -, *, /,
construct an expression with a given value.</li>
<li>All numbers, including intermediate results, must be positive
integers.</li>
<li>Each source number can be used at most once.</li>
</ul>
<p><strong>Example:</strong> - Numbers: 1, 3, 7, 10, 25, 50 - Target:
765 - Possible solution: (25-10) * (50+1)</p>
<p>There are 780 solutions for this example. Changing the target to 831
gives an example with no solutions.</p>
<h4 id="data-types">Data Types</h4>
<p>```ocaml env=ch6 type op = Add | Sub | Mul | Div</p>
<p>let apply op x y = match op with | Add -&gt; x + y | Sub -&gt; x - y
| Mul -&gt; x * y | Div -&gt; x / y</p>
<p>let valid op x y = match op with | Add -&gt; true | Sub -&gt; x &gt;
y | Mul -&gt; true | Div -&gt; x mod y = 0</p>
<p>type expr = Val of int | App of op * expr * expr</p>
<p>let rec eval = function | Val n -&gt; if n &gt; 0 then Some n else
None | App (o, l, r) -&gt; eval l |&gt; map_option (fun x -&gt; eval r
|&gt; map_option (fun y -&gt; if valid o x y then Some (apply o x y)
else None))</p>
<p>let rec values = function | Val n -&gt; [n] | App (_, l, r) -&gt;
values l @ values r</p>
<p>let solution e ns n = list_diff (values e) ns = [] &amp;&amp;
is_unique (values e) &amp;&amp; eval e = Some n</p>
<pre><code>
#### Brute Force Solution

Splitting a list into two non-empty parts:

```ocaml env=ch6
let split l =
  let rec aux lhs acc = function
    | [] | [_] -&gt; []
    | [y; z] -&gt; (List.rev (y::lhs), [z])::acc
    | hd::rhs -&gt;
      let lhs = hd::lhs in
      aux lhs ((List.rev lhs, rhs)::acc) rhs in
  aux [] [] l</code></pre>
<p>We introduce an operator for working with multiple data sources:</p>
<p><code>ocaml env=ch6 let ( |-&gt; ) x f = concat_map f x</code></p>
<p>Generating all expressions from a list of numbers:</p>
<p>```ocaml env=ch6 let combine l r = (* Combine two expressions using
each operator *) List.map (fun o -&gt; App (o, l, r)) [Add; Sub; Mul;
Div]</p>
<p>let rec exprs = function | [] -&gt; [] | [n] -&gt; [Val n] | ns -&gt;
split ns |-&gt; (fun (ls, rs) -&gt; (* For each split ls,rs of numbers
<em>) exprs ls |-&gt; (fun l -&gt; (</em> for each expression l over ls
<em>) exprs rs |-&gt; (fun r -&gt; (</em> and expression r over rs <em>)
combine l r))) (</em> produce all l ? r expressions *)</p>
<pre><code>
Finding solutions:

```ocaml env=ch6
let guard n =
  List.filter (fun e -&gt; eval e = Some n)

let solutions ns n =
  choices ns |-&gt; (fun ns&#39; -&gt;
    exprs ns&#39; |&gt; guard n)</code></pre>
<h4 id="optimization-fuse-generation-with-testing">Optimization: Fuse
Generation with Testing</h4>
<p>We memorize values with expressions as pairs
<code>(e, eval e)</code>, so only valid subexpressions are
generated:</p>
<p>```ocaml env=ch6 let combine’ (l, x) (r, y) = [Add; Sub; Mul; Div]
|&gt; List.filter (fun o -&gt; valid o x y) |&gt; List.map (fun o -&gt;
App (o, l, r), apply o x y)</p>
<p>let rec results = function | [] -&gt; [] | [n] -&gt; if n &gt; 0 then
[Val n, n] else [] | ns -&gt; split ns |-&gt; (fun (ls, rs) -&gt;
results ls |-&gt; (fun lx -&gt; results rs |-&gt; (fun ry -&gt; combine’
lx ry)))</p>
<p>let solutions’ ns n = choices ns |-&gt; (fun ns’ -&gt; results ns’
|&gt; List.filter (fun (e, m) -&gt; m = n) |&gt; List.map fst) (*
Discard memorized values *)</p>
<pre><code>
#### Eliminating Symmetric Cases

Strengthening the validity predicate to account for commutativity and identity:

```ocaml env=ch6
let valid op x y =
  match op with
  | Add -&gt; x &lt;= y
  | Sub -&gt; x &gt; y
  | Mul -&gt; x &lt;= y &amp;&amp; x &lt;&gt; 1 &amp;&amp; y &lt;&gt; 1
  | Div -&gt; x mod y = 0 &amp;&amp; y &lt;&gt; 1</code></pre>
<p>This eliminates repeating symmetrical solutions on the semantic level
(values) rather than syntactic level (expressions)–both easier and more
effective.</p>
<h3 id="the-honey-islands-puzzle">6.9 The Honey Islands Puzzle</h3>
<p>The Honey Islands puzzle: Find cells to eat honey from so that the
least amount of honey becomes sour (assuming sourness spreads through
contact).</p>
<p>Given a honeycomb with some cells initially marked black, mark
additional cells so that unmarked cells form <code>num_islands</code>
disconnected components, each with <code>island_size</code> cells.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Task: 3 islands × 3 cells</th>
<th style="text-align: center;">Solution</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><img src="honey0.png" alt="Task" /></td>
<td style="text-align: center;"><img src="honey1.png"
alt="Solution" /></td>
</tr>
</tbody>
</table>
<p>In the solution, yellow cells contain honey, black cells were
initially empty, and purple cells are the newly “eaten” cells that
separate the honey into 3 islands of 3 cells each.</p>
<h4 id="representing-the-honeycomb">Representing the Honeycomb</h4>
<p>```ocaml env=ch6 type cell = int * int (* Cartesian coordinates
*)</p>
<p>module CellSet = (* Store cells in sets *) Set.Make (struct type t =
cell let compare = compare end)</p>
<p>type task = { (* For board size N, coordinates <em>) board_size :
int; (</em> range from (-2N, -N) to (2N, N) <em>) num_islands : int;
(</em> Required number of islands <em>) island_size : int; (</em>
Required cells per island <em>) empty_cells : CellSet.t; (</em>
Initially empty cells *) }</p>
<p>let cellset_of_list l = (* List to set, inverse of CellSet.elements
*) List.fold_right CellSet.add l CellSet.empty</p>
<pre><code>
**Neighborhood:** Each cell (x, y) has up to 6 neighbors:

```ocaml env=ch6
let even x = x mod 2 = 0

let inside_board n eaten (x, y) =
  even x = even y &amp;&amp; abs y &lt;= n &amp;&amp;
  abs x + abs y &lt;= 2*n &amp;&amp;
  not (CellSet.mem (x, y) eaten)

let neighbors n eaten (x, y) =
  List.filter
    (inside_board n eaten)
    [x-1,y-1; x+1,y-1; x+2,y;
     x+1,y+1; x-1,y+1; x-2,y]</code></pre>
<p><strong>Building the honeycomb:</strong></p>
<p><code>ocaml env=ch6 let honey_cells n eaten =   fromto (-2*n) (2*n) |-&gt; (fun x -&gt;     fromto (-n) n |-&gt; (fun y -&gt;      pred_guard (inside_board n eaten)         (x, y)))</code></p>
<h4 id="drawing-honeycombs">Drawing Honeycombs</h4>
<p>To visualize the honeycomb, we generate colored polygons. Each cell
is drawn as a hexagon by placing 6 points evenly spaced on a
circumcircle:</p>
<p><code>ocaml skip let draw_honeycomb ~w ~h task eaten =   let i2f = float_of_int in   let nx = i2f (4 * task.board_size + 2) in   let ny = i2f (2 * task.board_size + 2) in   let radius = min (i2f w /. nx) (i2f h /. ny) in   let x0 = w / 2 in   let y0 = h / 2 in   let dx = (sqrt 3. /. 2.) *. radius +. 1. in  (* Distance between *)   let dy = (3. /. 2.) *. radius +. 2. in       (* (x,y) and (x+1,y+1) *)   let draw_cell (x, y) =     Array.init 7                               (* Draw a closed polygon *)       (fun i -&gt;                                (* with 6 points evenly *)         let phi = float_of_int i *. pi /. 3. in   (* spaced on circumcircle *)         x0 + int_of_float (radius *. sin phi +. float_of_int x *. dx),         y0 + int_of_float (radius *. cos phi +. float_of_int y *. dy)) in   let honey =     honey_cells task.board_size (CellSet.union task.empty_cells                                    (cellset_of_list eaten))     |&gt; List.map (fun p -&gt; draw_cell p, (255, 255, 0)) in   (* Yellow cells *)   let eaten = List.map     (fun p -&gt; draw_cell p, (50, 0, 50)) eaten in           (* Purple: eaten *)   let old_empty = List.map     (fun p -&gt; draw_cell p, (0, 0, 0))                      (* Black: empty *)     (CellSet.elements task.empty_cells) in   honey @ eaten @ old_empty</code></p>
<p><strong>Drawing to SVG:</strong> We can render the polygons to an SVG
image file:</p>
<p><code>ocaml skip let draw_to_svg file ~w ~h ?title ?desc curves =   let f = open_out file in   Printf.fprintf f "&lt;?xml version=\"1.0\" standalone=\"no\"?&gt; &lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"   \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt; &lt;svg width=\"%d\" height=\"%d\" viewBox=\"0 0 %d %d\"     xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; " w h w h;   (match title with None -&gt; ()   | Some title -&gt; Printf.fprintf f "  &lt;title&gt;%s&lt;/title&gt;\n" title);   (match desc with None -&gt; ()   | Some desc -&gt; Printf.fprintf f "  &lt;desc&gt;%s&lt;/desc&gt;\n" desc);   let draw_shape (points, (r, g, b)) =     uncurry (Printf.fprintf f "  &lt;path d=\"M %d %d") points.(0);     Array.iteri (fun i (x, y) -&gt;       if i &gt; 0 then Printf.fprintf f " L %d %d" x y) points;     Printf.fprintf f "\"\n       fill=\"rgb(%d, %d, %d)\" stroke-width=\"3\" /&gt;\n"       r g b in   List.iter draw_shape curves;   Printf.fprintf f "&lt;/svg&gt;%!"</code></p>
<p><strong>Drawing to screen:</strong> We can also draw interactively
using the <code>Graphics</code> library. In the toplevel, load it with
<code>#load "graphics.cma";;</code>. When compiling, provide
<code>graphics.cma</code> to the command.</p>
<p><code>ocaml skip let draw_to_screen ~w ~h curves =   Graphics.open_graph (" " ^ string_of_int w ^ "x" ^ string_of_int h);   Graphics.set_color (Graphics.rgb 50 50 0);   (* Brown background *)   Graphics.fill_rect 0 0 (Graphics.size_x ()) (Graphics.size_y ());   List.iter (fun (points, (r, g, b)) -&gt;     Graphics.set_color (Graphics.rgb r g b);     Graphics.fill_poly points) curves;   if Graphics.read_key () = 'q'                (* Wait so solutions can be seen *)   then failwith "User interrupted finding solutions.";   Graphics.close_graph ()</code></p>
<h4 id="testing-correctness">Testing Correctness</h4>
<p>We walk through each island counting cells depth-first:</p>
<p>```ocaml skip let check_correct n island_size num_islands empty_cells
= let honey = honey_cells n empty_cells in</p>
<p>let rec check_board been_islands unvisited visited = match unvisited
with | [] -&gt; been_islands = num_islands | cell::remaining when
CellSet.mem cell visited -&gt; check_board been_islands remaining
visited (* Keep looking <em>) | cell::remaining (</em> when not visited
<em>) -&gt; let (been_size, unvisited, visited) = check_island cell
(</em> Visit another island *) (1, remaining, CellSet.add cell visited)
in been_size = island_size &amp;&amp; check_board (been_islands+1)
unvisited visited</p>
<p>and check_island current state = neighbors n empty_cells current
|&gt; List.fold_left (* Walk into each direction <em>) (fun (been_size,
unvisited, visited as state) neighbor -&gt; if CellSet.mem neighbor
visited then state else let unvisited = remove neighbor unvisited in let
visited = CellSet.add neighbor visited in let been_size = been_size + 1
in check_island neighbor (been_size, unvisited, visited)) state in
(</em> Initial been_size is 1 *)</p>
<p>check_board 0 honey empty_cells</p>
<pre><code>
#### Multiple Results per Step: concat_fold

When processing lists with potentially multiple results per step, we need `concat_fold`:

```ocaml env=ch6
let rec concat_fold f a = function
  | [] -&gt; [a]
  | x::xs -&gt;
    f x a |-&gt; (fun a&#39; -&gt; concat_fold f a&#39; xs)</code></pre>
<h4 id="generating-solutions">Generating Solutions</h4>
<p>We transform the testing code into generation code by:</p>
<ul>
<li>Passing around the current solution <code>eaten</code></li>
<li>Returning results in a list (empty list = no solutions)</li>
<li>At each neighbor, trying both eating and keeping</li>
</ul>
<p>```ocaml skip let find_to_eat n island_size num_islands empty_cells =
let honey = honey_cells n empty_cells in</p>
<p>let rec find_board been_islands unvisited visited eaten = match
unvisited with | [] -&gt; if been_islands = num_islands then [eaten]
else [] | cell::remaining when CellSet.mem cell visited -&gt; find_board
been_islands remaining visited eaten | cell::remaining (* when not
visited <em>) -&gt; find_island cell (1, remaining, CellSet.add cell
visited, eaten) |-&gt; (</em> Concatenate solutions *) (fun (been_size,
unvisited, visited, eaten) -&gt; if been_size = island_size then
find_board (been_islands+1) unvisited visited eaten else [])</p>
<p>and find_island current state = neighbors n empty_cells current |&gt;
concat_fold (* Multiple results <em>) (fun neighbor (been_size,
unvisited, visited, eaten as state) -&gt; if CellSet.mem neighbor
visited then [state] else let unvisited = remove neighbor unvisited in
let visited = CellSet.add neighbor visited in (been_size, unvisited,
visited, neighbor::eaten):: (</em> solutions where neighbor is honey *)
find_island neighbor (been_size+1, unvisited, visited, eaten)) state
in</p>
<p>find_board 0 honey empty_cells []</p>
<pre><code>
#### Optimizations

The main rule: **fail (drop solution candidates) as early as possible**.

We guard both choices (eating and keeping) and track how much honey needs to be eaten:

```ocaml env=ch6
type state = {
  been_size: int;                           (* Honey cells in current island *)
  been_islands: int;                        (* Islands visited so far *)
  unvisited: cell list;                     (* Cells to visit *)
  visited: CellSet.t;                       (* Already visited *)
  eaten: cell list;                         (* Current solution candidate *)
  more_to_eat: int;                         (* Remaining cells to eat *)
}

let rec visit_cell s =
  match s.unvisited with
  | [] -&gt; None
  | c::remaining when CellSet.mem c s.visited -&gt;
    visit_cell {s with unvisited=remaining}
  | c::remaining (* when c not visited *) -&gt;
    Some (c, {s with
      unvisited=remaining;
      visited = CellSet.add c s.visited})

let eat_cell c s =
  {s with eaten = c::s.eaten;
    visited = CellSet.add c s.visited;
    more_to_eat = s.more_to_eat - 1}

let keep_cell c s =                         (* c is actually unused *)
  {s with been_size = s.been_size + 1;
    visited = CellSet.add c s.visited}

let fresh_island s =                        (* Increment been_size at start of find_island *)
  {s with been_size = 0;
    been_islands = s.been_islands + 1}

let init_state unvisited more_to_eat = {
  been_size = 0; been_islands = 0;
  unvisited; visited = CellSet.empty;
  eaten = []; more_to_eat;
}</code></pre>
<p>The optimized island loop only tries actions that make sense:</p>
<pre><code>  and find_island current s =
    let s = keep_cell current s in
    neighbors n empty_cells current
    |&gt; concat_fold
        (fun neighbor s -&gt;
          if CellSet.mem neighbor s.visited then [s]
          else
            let choose_eat =                (* Guard against failed actions *)
              if s.more_to_eat = 0 then []
              else [eat_cell neighbor s]
            and choose_keep =
              if s.been_size &gt;= island_size then []
              else find_island neighbor s in
            choose_eat @ choose_keep)
        s in
  (* Finally, compute the required eaten cells and start searching *)
  let cells_to_eat =
    List.length honey - island_size * num_islands in
  find_board (init_state honey cells_to_eat)</code></pre>
<h3 id="constraint-based-puzzles">6.10 Constraint-Based Puzzles</h3>
<p>Puzzles can be presented by providing:</p>
<ol type="1">
<li>The general form of solutions</li>
<li>Additional requirements (constraints) that solutions must meet</li>
</ol>
<p>For many puzzles, solutions decompose into a fixed number of
<strong>variables</strong>:</p>
<ul>
<li>A <strong>domain</strong> is the set of possible values a variable
can have</li>
<li>In Honey Islands, variables are cells with domain {Honey,
Empty}</li>
<li><strong>Constraints</strong> specify relationships: cells that must
be empty, number and size of connected components, neighborhood
graph</li>
</ul>
<h4 id="finite-domain-constraint-programming">Finite Domain Constraint
Programming</h4>
<p>A general and often efficient scheme:</p>
<ol type="1">
<li><p>With each variable, associate a set of values (initially the full
domain). The singleton containing this association is the initial set of
partial solutions.</p></li>
<li><p>While there is a solution with more than one value for some
variable:</p>
<ul>
<li><ol type="a">
<li>If some value for a variable fails for all possible assignments to
other variables, remove it</li>
</ol></li>
<li><ol start="2" type="a">
<li>If a variable has an empty set of possible values, remove that
solution</li>
</ol></li>
<li><ol start="3" type="a">
<li>Select the variable with the smallest non-singleton set. Split into
similarly-sized parts. Replace the solution with two solutions for each
part.</li>
</ol></li>
</ul></li>
<li><p>Build final solutions by assigning each variable its single
remaining value.</p></li>
</ol>
<p>Simplifications: In step (2c), instead of equal-sized splits, we can
partition into singleton and remainder, or partition completely into
singletons.</p>
<h3 id="exercises-5">6.11 Exercises</h3>
<ol type="1">
<li><p>Recall how we generated all subsequences of a list. Find
(generate) all:</p>
<ul>
<li>permutations of a list</li>
<li>ways of choosing without repetition from a list</li>
<li>combinations of K distinct objects chosen from N elements of a
list</li>
</ul></li>
<li><p>Using folding for the <code>expression</code> data type, compute
the degree of the corresponding polynomial.</p></li>
<li><p>Implement simplification of expressions using mapping for the
<code>expression</code> data type.</p></li>
<li><p>Express in terms of <code>fold_left</code> or
<code>fold_right</code>:</p>
<ul>
<li><code>indexed : 'a list -&gt; (int * 'a) list</code>, which pairs
elements with their indices</li>
<li><code>concat_fold</code> as used in Honey Islands</li>
<li>Run-length encoding of a list:
<code>encode ['a;'a;'a;'a;'b;'c;'c;'a;'a;'d] = [4,'a; 1,'b; 2,'c; 2,'a; 1,'d]</code></li>
</ul></li>
<li><p>Write more efficient variants:</p>
<ul>
<li><code>list_diff</code> computing difference of sets represented as
sorted lists</li>
<li><code>is_unique</code> in constant stack space</li>
</ul></li>
<li><p>Write functions <code>compose</code> and <code>perform</code>
that take a list of functions and return their composition:</p>
<ul>
<li><code>compose [f1; ...; fn] = x -&gt; f1 (... (fn x)...)</code></li>
<li><code>perform [f1; ...; fn] = x -&gt; fn (... (f1 x)...)</code></li>
</ul></li>
<li><p>Write a solver for the <em>Tents Puzzle</em>.</p></li>
<li><p><strong>Robot Squad</strong> (harder): Given a map with walls and
lidar readings (8 directions: E, NE, N, NW, W, SW, S, SE) for multiple
robots, determine possible robot positions.</p></li>
<li><p>Write a solver for the <em>Plinx Puzzle</em> (does not need to
solve all levels, but should handle initial ones).</p></li>
</ol>
<h2 id="chapter-7-laziness">Chapter 7: Laziness</h2>
<p>This chapter explores lazy evaluation and stream processing in OCaml.
We examine different evaluation strategies, implement streams and lazy
lists, apply them to power series computation and differential
equations, build circular data structures, and develop a sophisticated
pipe-based pretty-printer.</p>
<h3 id="evaluation-strategies-and-parameter-passing">7.1 Evaluation
Strategies and Parameter Passing</h3>
<p><strong>Evaluation strategy</strong> is the order in which
expressions are computed – primarily, when arguments are computed.
Recall our problems with using <em>flow control</em> expressions like
<code>if_then_else</code> in examples from the lambda-calculus lecture.
There are many technical terms describing various evaluation
strategies:</p>
<p><strong>Strict evaluation</strong>: Arguments are always evaluated
completely before the function is applied.</p>
<p><strong>Non-strict evaluation</strong>: Arguments are not evaluated
unless they are actually used in the evaluation of the function
body.</p>
<p><strong>Eager evaluation</strong>: An expression is evaluated as soon
as it gets bound to a variable.</p>
<p><strong>Lazy evaluation</strong>: Non-strict evaluation which avoids
repeating computation.</p>
<p><strong>Call-by-value</strong>: The argument expression is evaluated,
and the resulting value is bound to the corresponding variable in the
function (frequently by copying the value into a new memory region).</p>
<p><strong>Call-by-reference</strong>: A function receives an implicit
reference to a variable used as argument, rather than a copy of its
value. In purely functional languages there is no difference between the
two strategies, so they are typically described as call-by-value even
though implementations use call-by-reference internally for efficiency.
Call-by-value languages like C and OCaml support explicit references
(objects that refer to other objects), and these can be used to simulate
call-by-reference.</p>
<p><strong>Normal order</strong>: Start computing function bodies before
evaluating their arguments. Do not even wait for arguments if they are
not needed.</p>
<p><strong>Call-by-name</strong>: Arguments are substituted directly
into the function body and then left to be evaluated whenever they
appear in the function.</p>
<p><strong>Call-by-need</strong>: If the function argument is evaluated,
that value is stored for subsequent uses.</p>
<p>Almost all languages do not compute inside the body of an un-applied
function, but with curried functions you can pre-compute data before all
arguments are provided (recall the <code>search_bible</code> example
from earlier lectures).</p>
<p>In eager / call-by-value languages we can simulate call-by-name by
taking a function to compute the value as an argument instead of the
value directly. “Our” languages have a <code>unit</code> type with a
single value <code>()</code> specifically for use as throw-away
arguments. Scala has built-in support for call-by-name (i.e. direct,
without the need to build argument functions).</p>
<p>ML languages have built-in support for lazy evaluation, while Haskell
has built-in support for eager evaluation (to override the default
laziness).</p>
<h3 id="call-by-name-streams">7.2 Call-by-name: Streams</h3>
<p>Call-by-name is useful not only for implementing flow control:</p>
<p><code>ocaml env=ch7 let if_then_else cond e1 e2 =   match cond with   | true -&gt; e1 ()   | false -&gt; e2 ()</code></p>
<p>but also for arguments of value constructors, i.e. for data
structures.</p>
<p><strong>Streams</strong> are lists with call-by-name tails:</p>
<p><code>ocaml env=ch7 type 'a stream = SNil | SCons of 'a * (unit -&gt; 'a stream)</code></p>
<p>Reading from a stream into a list:</p>
<p><code>ocaml env=ch7 let rec stake n = function   | SCons (a, s) when n &gt; 0 -&gt; a :: (stake (n-1) (s ()))   | _ -&gt; []</code></p>
<p>Streams can easily be infinite:</p>
<p>```ocaml env=ch7 let rec s_ones = SCons (1, fun () -&gt; s_ones)</p>
<p>let rec s_from n = SCons (n, fun () -&gt; s_from (n+1))</p>
<pre><code>
#### 7.2.1 Stream Operations

Streams admit list-like operations:

```ocaml env=ch7
let rec smap f = function
  | SNil -&gt; SNil
  | SCons (a, s) -&gt; SCons (f a, fun () -&gt; smap f (s ()))

let rec szip = function
  | SNil, SNil -&gt; SNil
  | SCons (a1, s1), SCons (a2, s2) -&gt;
      SCons ((a1, a2), fun () -&gt; szip (s1 (), s2 ()))
  | _ -&gt; raise (Invalid_argument &quot;szip&quot;)</code></pre>
<p>Streams can provide scaffolding for recursive algorithms. Consider
the Fibonacci sequence:</p>
<p><code>ocaml env=ch7 let rec sfib =   SCons (1, fun () -&gt; smap (fun (a,b) -&gt; a+b)     (szip (sfib, SCons (1, fun () -&gt; sfib))))</code></p>
<p>This definition creates a stream where each element is computed by
adding pairs from the current stream and itself shifted by one
position:</p>
<table>
<thead>
<tr>
<th>sfib</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>5</th>
<th>8</th>
<th>13</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr>
<td>sfib</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>8</td>
<td>13</td>
<td>…</td>
</tr>
<tr>
<td>shifted</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>8</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>The <code>+</code> operation between corresponding elements produces
the next values.</p>
<h4 id="streams-and-input-output">7.2.2 Streams and Input-Output</h4>
<p>Streams are less functional than could be expected in the context of
input-output effects:</p>
<p><code>ocaml env=ch7 let file_stream name =   let ch = open_in name in   let rec ch_read_line () =     try SCons (input_line ch, ch_read_line)     with End_of_file -&gt; SNil in   ch_read_line ()</code></p>
<p><em>OCaml Batteries</em> uses a stream type <code>enum</code> for
interfacing between various sequence-like data types. The safest way to
use streams is in a <em>linear</em> / <em>ephemeral</em> manner: every
value used only once. Streams minimize space consumption at the expense
of time for recomputation.</p>
<h3 id="lazy-values">7.3 Lazy Values</h3>
<p>Lazy evaluation is more general than call-by-need as any value can be
lazy, not only a function parameter.</p>
<p>A <em>lazy value</em> is a value that “holds” an expression until its
result is needed, and from then on it “holds” the result. It is also
called a <em>suspension</em>. If it holds the expression (not yet
evaluated), it is called a <em>thunk</em>.</p>
<p>In OCaml, we build lazy values explicitly. In Haskell, all values are
lazy but functions can have call-by-value parameters which “need” the
argument.</p>
<p>To create a lazy value: <code>lazy expr</code> – where
<code>expr</code> is the suspended computation.</p>
<p>Two ways to use a lazy value (be careful when the result is
computed!): - In expressions: <code>Lazy.force l_expr</code> - In
patterns: <code>match l_expr with lazy v -&gt; ...</code> -
Syntactically <code>lazy</code> behaves like a data constructor.</p>
<h4 id="lazy-lists">7.3.1 Lazy Lists</h4>
<p>Lazy lists are defined as:</p>
<p><code>ocaml env=ch7 type 'a llist = LNil | LCons of 'a * 'a llist Lazy.t</code></p>
<p>Reading from a lazy list into a list:</p>
<p><code>ocaml env=ch7 let rec ltake n = function   | LCons (a, lazy l) when n &gt; 0 -&gt; a :: (ltake (n-1) l)   | _ -&gt; []</code></p>
<p>Lazy lists can easily be infinite:</p>
<p>```ocaml env=ch7 let rec l_ones = LCons (1, lazy l_ones)</p>
<p>let rec l_from n = LCons (n, lazy (l_from (n+1)))</p>
<pre><code>
Read once, access multiple times (unlike streams):

```ocaml env=ch7
let file_llist name =
  let ch = open_in name in
  let rec ch_read_line () =
    try LCons (input_line ch, lazy (ch_read_line ()))
    with End_of_file -&gt; LNil in
  ch_read_line ()</code></pre>
<h4 id="lazy-list-operations">7.3.2 Lazy List Operations</h4>
<p>```ocaml env=ch7 let rec lzip = function | LNil, LNil -&gt; LNil |
LCons (a1, ll1), LCons (a2, ll2) -&gt; LCons ((a1, a2), lazy ( lzip
(Lazy.force ll1, Lazy.force ll2))) | _ -&gt; raise (Invalid_argument
“lzip”)</p>
<p>let rec lmap f = function | LNil -&gt; LNil | LCons (a, ll) -&gt;
LCons (f a, lazy (lmap f (Lazy.force ll)))</p>
<pre><code>
Using these operations, we can define the factorial sequence elegantly:

```ocaml env=ch7
let posnums = l_from 1

let rec lfact =
  LCons (1, lazy (lmap (fun (a,b) -&gt; a*b)
                    (lzip (lfact, posnums))))</code></pre>
<p>This produces: 1, 1, 2, 6, 24, 120, … where each element is the
product of the previous factorial and the corresponding positive
integer:</p>
<table>
<thead>
<tr>
<th>lfact</th>
<th>1</th>
<th>1</th>
<th>2</th>
<th>6</th>
<th>24</th>
<th>120</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr>
<td>lfact</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>6</td>
<td>24</td>
<td>120</td>
<td>…</td>
</tr>
<tr>
<td>posnums</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>The <code>*</code> operation between corresponding elements produces
the next values.</p>
<h3 id="power-series-and-differential-equations">7.4 Power Series and
Differential Equations</h3>
<p>This section presents an application of lazy lists to power series
computation and solving differential equations through power series. The
differential equations idea is due to Henning Thielemann.</p>
<p>The expression <span class="math inline">P(x) = \sum_{i=0}^{n} a_i
x^i</span> defines a polynomial for <span class="math inline">n &lt;
\infty</span> and a power series for <span class="math inline">n =
\infty</span>.</p>
<p>If we define:</p>
<p><code>ocaml env=ch7 let rec lfold_right f l base =   match l with     | LNil -&gt; base     | LCons (a, lazy l) -&gt; f a (lfold_right f l base)</code></p>
<p>then we can compute polynomials using Horner’s method:</p>
<p><code>ocaml env=ch7 let horner x l =   lfold_right (fun c sum -&gt; c +. x *. sum) l 0.</code></p>
<p>But this will not work for infinite power series! Does it make sense
to compute the value at <span class="math inline">x</span> of a power
series? Does it make sense to fold an infinite list?</p>
<p>If the power series converges for <span class="math inline">x &gt;
1</span>, then when the elements <span class="math inline">a_n</span>
get small, the remaining sum <span
class="math inline">\sum_{i=n}^{\infty} a_i x^i</span> is also
small.</p>
<p><code>lfold_right</code> falls into an infinite loop on infinite
lists. We need call-by-name / call-by-need semantics for the argument
function <code>f</code>:</p>
<p><code>ocaml env=ch7 let rec lazy_foldr f l base =   match l with     | LNil -&gt; base     | LCons (a, ll) -&gt;       f a (lazy (lazy_foldr f (Lazy.force ll) base))</code></p>
<p>We need a stopping condition in the Horner algorithm step:</p>
<p>```ocaml env=ch7 let lhorner x l = (* This is a bit of a hack, <em>)
let upd c sum = (</em> we hope to “hit” the interval (0, epsilon]. <em>)
if c = 0. || abs_float c &gt; epsilon_float then c +. x </em>.
Lazy.force sum else 0. in lazy_foldr upd l 0.</p>
<p>let inv_fact = lmap (fun n -&gt; 1. /. float_of_int n) lfact let e =
lhorner 1. inv_fact</p>
<pre><code>
#### 7.4.1 Power Series / Polynomial Operations

For power series operations with floating-point coefficients, we need a float-based version of positive numbers:

```ocaml env=ch7
let rec l_from_f n = LCons (n, lazy (l_from_f (n +. 1.)))
let posnums_f = l_from_f 1.

(* Unary negation for series *)
let (~-:) = lmap (fun x -&gt; -.x)</code></pre>
<p>```ocaml env=ch7 let rec add xs ys = match xs, ys with | LNil, _
-&gt; ys | _, LNil -&gt; xs | LCons (x,xs), LCons (y,ys) -&gt; LCons (x
+. y, lazy (add (Lazy.force xs) (Lazy.force ys)))</p>
<p>let rec sub xs ys = match xs, ys with | LNil, _ -&gt; lmap (fun x
-&gt; -.x) ys | _, LNil -&gt; xs | LCons (x,xs), LCons (y,ys) -&gt;
LCons (x -. y, lazy (add (Lazy.force xs) (Lazy.force ys)))</p>
<p>let scale s = lmap (fun x -&gt; s *. x)</p>
<p>let rec shift n xs = if n = 0 then xs else if n &gt; 0 then LCons
(0., lazy (shift (n-1) xs)) else match xs with | LNil -&gt; LNil | LCons
(0., lazy xs) -&gt; shift (n+1) xs | _ -&gt; failwith “shift: fractional
division”</p>
<p>let rec mul xs = function | LNil -&gt; LNil | LCons (y, ys) -&gt; add
(scale y xs) (LCons (0., lazy (mul xs (Lazy.force ys))))</p>
<p>let rec div xs ys = match xs, ys with | LNil, _ -&gt; LNil | LCons
(0., xs’), LCons (0., ys’) -&gt; div (Lazy.force xs’) (Lazy.force ys’) |
LCons (x, xs’), LCons (y, ys’) -&gt; let q = x /. y in LCons (q, lazy
(div (sub (Lazy.force xs’) (scale q (Lazy.force ys’))) ys)) | LCons _,
LNil -&gt; failwith “div: division by zero”</p>
<p>let integrate c xs = LCons (c, lazy (lmap (uncurry (/.)) (lzip (xs,
posnums_f))))</p>
<p>let ltail = function | LNil -&gt; invalid_arg “ltail” | LCons (_,
lazy tl) -&gt; tl</p>
<p>let differentiate xs = lmap (uncurry ( *.)) (lzip (ltail xs,
posnums_f))</p>
<pre><code>
#### 7.4.2 Differential Equations

Consider the differential equations for sine and cosine:

$$\frac{d \sin x}{dx} = \cos x, \quad \frac{d \cos x}{dx} = -\sin x, \quad \sin 0 = 0, \quad \cos 0 = 1$$

We will solve the corresponding integral equations. We cannot define the integral by direct recursion like this:
</code></pre>
<p>let (~-:) = lmap (fun x -&gt; -.x) (* Unary negation for series
*)</p>
<p>let rec sin = integrate (of_int 0) cos and cos = integrate (of_int 1)
(~-:sin)</p>
<pre><code>
Unfortunately this fails with: `Error: This kind of expression is not allowed as right-hand side of &#39;let rec&#39;`

Even changing the second argument of `integrate` to call-by-need does not help, because OCaml cannot represent the values that `sin` and `cos` refer to at the point of their definition.

We need to inline a bit of `integrate` so that OCaml knows how to start building the recursive structure:

```ocaml env=ch7
let integ xs = lmap (uncurry (/.)) (lzip (xs, posnums_f))

let rec sin = LCons (of_int 0, lazy (integ cos))
and cos = LCons (of_int 1, lazy (integ (~-:sin)))</code></pre>
<p>The complete example would look much more elegant in Haskell, where
all values are lazy by default.</p>
<p>Although this approach is not limited to linear equations, equations
like Lotka-Volterra or Lorentz are not “solvable” this way – computed
coefficients quickly grow instead of quickly falling.</p>
<p>Drawing functions work like in the previous lecture, but with open
curves:</p>
<p><code>ocaml env=ch7 let plot_1D f ~w ~scale ~t_beg ~t_end =   let dt = (t_end -. t_beg) /. of_int w in   Array.init w (fun i -&gt;     let y = lhorner (dt *. of_int i) f in     i, to_int (scale *. y))</code></p>
<h3 id="arbitrary-precision-computation">7.5 Arbitrary Precision
Computation</h3>
<p>Putting together the power series computation with floating-point
numbers reveals drastic numerical errors for large <span
class="math inline">x</span>. Floating-point numbers have limited
precision, and we break out of Horner method computations too
quickly.</p>
<p>For infinite precision on rational numbers we use the
<code>nums</code> library – but it does not help by itself.</p>
<p>We need to generate a sequence of approximations to the power series
limit at <span class="math inline">x</span>:</p>
<p><code>ocaml env=ch7 let infhorner x l =   let upd c sum =     LCons (c, lazy (lmap (fun apx -&gt; c +. x *. apx)                       (Lazy.force sum))) in   lazy_foldr upd l (LCons (of_int 0, lazy LNil))</code></p>
<p>Find where the series converges – as far as a given test is
concerned:</p>
<p><code>ocaml env=ch7 let rec exact f = function           (* We arbitrarily decide that convergence is *)   | LNil -&gt; assert false             (* when three consecutive results are the same. *)   | LCons (x0, lazy (LCons (x1, lazy (LCons (x2, _)))))       when f x0 = f x1 &amp;&amp; f x0 = f x2 -&gt; f x0   | LCons (_, lazy tl) -&gt; exact f tl</code></p>
<p>Draw the pixels of the graph at exact coordinates:</p>
<p><code>ocaml env=ch7 let plot_1D f ~w ~h0 ~scale ~t_beg ~t_end =   let dt = (t_end -. t_beg) /. of_int w in   let eval = exact (fun y -&gt; to_int (scale *. y)) in   Array.init w (fun i -&gt;     let y = infhorner (t_beg +. dt *. of_int i) f in     i, h0 + eval y)</code></p>
<p>If a power series had every third term contributing we would have to
check three terms in the function <code>exact</code>. We could also test
for <code>f x0 = f x1 &amp;&amp; not (x0 =. x1)</code> like in
<code>lhorner</code>.</p>
<h4 id="example-nuclear-chain-reaction">7.5.1 Example: Nuclear Chain
Reaction</h4>
<p>Consider a nuclear chain reaction where substance A decays into B,
which decays into C. The differential equations are:</p>
<p><span class="math display">\frac{dN_A}{dt} = -\lambda_A N_A, \quad
\frac{dN_B}{dt} = \lambda_A N_A - \lambda_B N_B</span></p>
<pre><code>let n_chain ~nA0 ~nB0 ~lA ~lB =
  let rec nA =
    LCons (nA0, lazy (integ (~-.lA *:. nA)))
  and nB =
    LCons (nB0, lazy (integ (~-.lB *:. nB +: lA *:. nA))) in
  nA, nB</code></pre>
<p>(See <a
href="http://en.wikipedia.org/wiki/Radioactive_decay#Chain-decay_processes">Radioactive
decay chain processes</a> for more information.)</p>
<h3 id="circular-data-structures-double-linked-lists">7.6 Circular Data
Structures: Double-Linked Lists</h3>
<p>Without delayed computation, the ability to define data structures
with referential cycles is very limited.</p>
<p>Double-linked lists contain such cycles between any two nodes even if
they are not cyclic when following only <em>forward</em> or
<em>backward</em> links:</p>
<pre><code>+--------+     +--------+     +--------+     +--------+     +--------+
| DLNil  | &lt;-&gt; |   a1   | &lt;-&gt; |   a2   | &lt;-&gt; |   a3   | &lt;-&gt; | DLNil  |
+--------+     +--------+     +--------+     +--------+     +--------+</code></pre>
<p>We need to “break” the cycles by making some links lazy:</p>
<p><code>ocaml env=ch7 type 'a dllist =   DLNil | DLCons of 'a dllist Lazy.t * 'a * 'a dllist</code></p>
<p><code>ocaml env=ch7 let rec dldrop n l =   match l with     | DLCons (_, x, xs) when n &gt; 0 -&gt;        dldrop (n-1) xs     | _ -&gt; l</code></p>
<p>Creating a double-linked list from a regular list:</p>
<p><code>ocaml env=ch7 let dllist_of_list l =   let rec dllist prev l =     match l with       | [] -&gt; DLNil       | x::xs -&gt;         let rec cell =           lazy (DLCons (prev, x, dllist cell xs)) in         Lazy.force cell in   dllist (lazy DLNil) l</code></p>
<p>Taking elements going forward:</p>
<p><code>ocaml env=ch7 let rec dltake n l =   match l with     | DLCons (_, x, xs) when n &gt; 0 -&gt;        x :: dltake (n-1) xs     | _ -&gt; []</code></p>
<p>Taking elements going backward:</p>
<p><code>ocaml env=ch7 let rec dlbackwards n l =   match l with     | DLCons (lazy xs, x, _) when n &gt; 0 -&gt;       x :: dlbackwards (n-1) xs     | _ -&gt; []</code></p>
<h3 id="input-output-streams">7.7 Input-Output Streams</h3>
<p>The stream type used a throwaway argument to make a suspension:</p>
<p><code>ocaml env=ch7 type 'a stream = SNil | SCons of 'a * (unit -&gt; 'a stream)</code></p>
<p>What if we take a real argument?</p>
<p><code>ocaml env=ch7 type ('a, 'b) iostream =   EOS | More of 'b * ('a -&gt; ('a, 'b) iostream)</code></p>
<p>This is a stream that for a single input value produces an output
value.</p>
<p><code>ocaml env=ch7 type 'a istream = (unit, 'a) iostream  (* Input stream produces output when "asked". *) type 'a ostream = ('a, unit) iostream  (* Output stream consumes provided input. *)</code></p>
<p>(The confusion arises from adapting the <em>input file / output
file</em> terminology, also used for streams.)</p>
<p>We can compose streams: directing output of one to input of
another.</p>
<p><code>ocaml env=ch7 let rec compose sf sg =   match sg with   | EOS -&gt; EOS                              (* No more output. *)   | More (z, g) -&gt;     match sf with     | EOS -&gt; More (z, fun _ -&gt; EOS)         (* No more input "processing power". *)     | More (y, f) -&gt;       let update x = compose (f x) (g y) in       More (z, update)</code></p>
<p>Every box has one incoming and one outgoing wire. Notice how the
output stream is ahead of the input stream.</p>
<h3 id="pipes">7.8 Pipes</h3>
<p>We need a more flexible input-output stream definition: - Consume
several inputs to produce a single output. - Produce several outputs
after a single input (or even without input). - No need for a dummy when
producing output requires input.</p>
<p>After Haskell, we call the data structure <code>pipe</code>:</p>
<p><code>ocaml env=ch7 type ('a, 'b) pipe =   EOP                                       (* End of pipe *) | Yield of 'b * ('a, 'b) pipe               (* For incremental streams change to lazy. *) | Await of ('a -&gt; ('a, 'b) pipe)</code></p>
<p>Again, we can have producing output only <em>input pipes</em> and
consuming input only <em>output pipes</em>:</p>
<p><code>ocaml env=ch7 type 'a ipipe = (unit, 'a) pipe type void type 'a opipe = ('a, void) pipe</code></p>
<p>Why <code>void</code> rather than <code>unit</code>, and why only for
<code>opipe</code>? Because an output pipe never yields values – if it
used <code>unit</code> as the output type, it could still yield
<code>()</code> values, but with the abstract <code>void</code> type, it
cannot yield anything.</p>
<h4 id="pipe-composition">7.8.1 Pipe Composition</h4>
<p>Composition of pipes is like “concatenating them in space” or
connecting boxes:</p>
<p>```ocaml env=ch7 let rec compose pf pg = match pg with | EOP -&gt;
EOP (* Done producing results. <em>) | Yield (z, pg’) -&gt; Yield (z,
compose pf pg’) (</em> Ready result. <em>) | Await g -&gt; match pf with
| EOP -&gt; EOP (</em> End of input. <em>) | Yield (y, pf’) -&gt;
compose pf’ (g y) (</em> Compute next result. <em>) | Await f -&gt; let
update x = compose (f x) pg in Await update (</em> Wait for more input.
*)</p>
<p>let (&gt;-&gt;) pf pg = compose pf pg</p>
<pre><code>
Appending pipes means &quot;concatenating them in time&quot; or adding more fuel to a box:

```ocaml env=ch7
let rec append pf pg =
  match pf with
  | EOP -&gt; pg                               (* When pf runs out, use pg. *)
  | Yield (z, pf&#39;) -&gt; Yield (z, append pf&#39; pg)
  | Await f -&gt;                              (* If pf awaits input, continue when it comes. *)
    let update x = append (f x) pg in
    Await update</code></pre>
<p>Append a list of ready results in front of a pipe:</p>
<p><code>ocaml env=ch7 let rec yield_all l tail =   match l with   | [] -&gt; tail   | x::xs -&gt; Yield (x, yield_all xs tail)</code></p>
<p>Iterate a pipe (<strong>not functional</strong> – performs side
effects):</p>
<p><code>ocaml env=ch7 let rec iterate f : 'a opipe =   Await (fun x -&gt; let () = f x in iterate f)</code></p>
<h3 id="example-pretty-printing">7.9 Example: Pretty-Printing</h3>
<p>Print a hierarchically organized document with a limited line
width.</p>
<p><code>ocaml env=ch7 type doc =   Text of string | Line | Cat of doc * doc | Group of doc</code></p>
<p>```ocaml env=ch7 let (++) d1 d2 = Cat (d1, Cat (Line, d2)) let (!) s
= Text s</p>
<p>let test_doc = Group (!“Document” ++ Group (!“First part” ++ !“Second
part”))</p>
<pre><code>
Example output with different widths:
</code></pre>
<h1 id="let-print_endline-pretty-30-test_doc">let () = print_endline
(pretty 30 test_doc);;</h1>
<p>Document First part Second part</p>
<h1 id="let-print_endline-pretty-20-test_doc">let () = print_endline
(pretty 20 test_doc);;</h1>
<p>Document First part Second part</p>
<h1 id="let-print_endline-pretty-60-test_doc">let () = print_endline
(pretty 60 test_doc);;</h1>
<p>Document First part Second part</p>
<pre><code>
#### 7.9.1 Straightforward Solution

```ocaml env=ch7
let pretty w d =                     (* Allowed width of line w. *)
  let rec width = function           (* Total length of subdocument. *)
    | Text z -&gt; String.length z
    | Line -&gt; 1
    | Cat (d1, d2) -&gt; width d1 + width d2
    | Group d -&gt; width d in
  let rec format f r = function      (* Remaining space r. *)
    | Text z -&gt; z, r - String.length z
    | Line when f -&gt; &quot; &quot;, r-1        (* If not f then line breaks. *)
    | Line -&gt; &quot;\n&quot;, w
    | Cat (d1, d2) -&gt;
      let s1, r = format f r d1 in
      let s2, r = format f r d2 in
      s1 ^ s2, r                     (* If following group fits, then without line breaks. *)
    | Group d -&gt; format (f || width d &lt;= r) r d in
  fst (format false w d)</code></pre>
<h4 id="stream-based-solution">7.9.2 Stream-Based Solution</h4>
<p>Working with a stream of nodes:</p>
<p><code>ocaml env=ch7 type ('a, 'b) doc_e =                (* Annotated nodes, special for group beginning. *)   TE of 'a * string | LE of 'a | GBeg of 'b | GEnd of 'a</code></p>
<p>Normalize a subdocument – remove empty groups:</p>
<p><code>ocaml env=ch7 let rec norm = function   | Group d -&gt; norm d   | Text "" -&gt; None   | Cat (Text "", d) -&gt; norm d   | d -&gt; Some d</code></p>
<p>Generate the stream by infix traversal:</p>
<p><code>ocaml env=ch7 let rec gen = function   | Text z -&gt; Yield (TE ((),z), EOP)   | Line -&gt; Yield (LE (), EOP)   | Cat (d1, d2) -&gt; append (gen d1) (gen d2)   | Group d -&gt;     match norm d with     | None -&gt; EOP     | Some d -&gt;       Yield (GBeg (),              append (gen d) (Yield (GEnd (), EOP)))</code></p>
<p>Compute lengths of document prefixes, i.e. the position of each node
counting by characters from the beginning of document:</p>
<p>```ocaml env=ch7 let rec docpos curpos = Await (function (* We input
from a doc_e pipe *) | TE (_, z) -&gt; Yield (TE (curpos, z), (* and
output doc_e annotated with position. <em>) docpos (curpos +
String.length z)) | LE _ -&gt; (</em> Space and line breaks increase
position by 1. <em>) Yield (LE curpos, docpos (curpos + 1)) | GBeg _
-&gt; (</em> Groups do not increase position. *) Yield (GBeg curpos,
docpos curpos) | GEnd _ -&gt; Yield (GEnd curpos, docpos curpos))</p>
<p>let docpos = docpos 0 (* The whole document starts at 0. *)</p>
<pre><code>
Put the end position of the group into the group beginning marker, so that we can know whether to break it into multiple lines:

```ocaml env=ch7
let rec grends grstack =
  Await (function
  | TE _ | LE _ as e -&gt;
    (match grstack with
    | [] -&gt; Yield (e, grends [])          (* We can yield only when *)
    | gr::grs -&gt; grends ((e::gr)::grs))   (* no group is waiting. *)
  | GBeg _ -&gt; grends ([]::grstack)        (* Wait for end of group. *)
  | GEnd endp -&gt;
    match grstack with                    (* End the group on top of stack. *)
    | [] -&gt; failwith &quot;grends: unmatched group end marker&quot;
    | [gr] -&gt;                             (* Top group -- we can yield now. *)
      yield_all
        (GBeg endp::List.rev (GEnd endp::gr))
        (grends [])
    | gr::par::grs -&gt;                     (* Remember in parent group instead. *)
      let par = GEnd endp::gr @ [GBeg endp] @ par in
      grends (par::grs))                  (* Could use catenable lists above. *)</code></pre>
<p>That’s waiting too long! We can stop waiting when the width of a
group exceeds the line limit. <code>GBeg</code> will not store end of
group when it is irrelevant:</p>
<p>```ocaml skip type grp_pos = Pos of int | Too_far</p>
<p>let rec grends w grstack = let flush tail = (* When the stack exceeds
width w, <em>) yield_all (</em> flush it – yield everything in it. *)
(rev_concat_map ~prep:(GBeg Too_far) snd grstack) tail in Await
(function | TE (curp, _) | LE curp as e -&gt; (match grstack with (*
Remember beginning of groups in the stack. <em>) | [] -&gt; Yield (e,
grends w []) | (begp, <em>)::</em> when curp-begp &gt; w -&gt; flush
(Yield (e, grends w [])) | (begp, gr)::grs -&gt; grends w ((begp,
e::gr)::grs)) | GBeg begp -&gt; grends w ((begp, [])::grstack) | GEnd
endp as e -&gt; match grstack with (</em> No longer fail when the stack
is empty – <em>) | [] -&gt; Yield (e, grends w []) (</em> could have
been flushed. <em>) | (begp, <em>)::</em> when endp-begp &gt; w -&gt;
flush (Yield (e, grends w [])) | [_, gr] -&gt; (</em> If width not
exceeded, <em>) yield_all (</em> work as before optimization. *) (GBeg
(Pos endp)::List.rev (GEnd endp::gr)) (grends w []) | (_,
gr)::(par_begp, par)::grs -&gt; let par = GEnd endp::gr @ [GBeg (Pos
endp)] @ par in grends w ((par_begp, par)::grs))</p>
<p>let grends w = grends w [] (* Initial stack is empty. *)</p>
<pre><code>
Finally we produce the resulting stream of strings:

```ocaml skip
let rec format w (inline, endlpos as st) =  (* State: the stack of *)
  Await (function                           (* &quot;group fits in line&quot;; position where *)
  | TE (_, z) -&gt; Yield (z, format w st)     (* end of line would be. *)
  | LE p when List.hd inline -&gt;
    Yield (&quot; &quot;, format w st)                (* After return, line has w free space. *)
  | LE p -&gt; Yield (&quot;\n&quot;, format w (inline, p+w))
  | GBeg Too_far -&gt;                         (* Group with end too far is not inline. *)
    format w (false::inline, endlpos)
  | GBeg (Pos p) -&gt;                         (* Group is inline if it ends soon enough. *)
    format w ((p&lt;=endlpos)::inline, endlpos)
  | GEnd _ -&gt; format w (List.tl inline, endlpos))

let format w = format w ([false], w)        (* Break lines outside of groups. *)</code></pre>
<p>Put the pipes together:</p>
<pre><code>+--------+     +-------+     +---------+     +--------+     +----------------+
| gen doc| --&gt; |docpos | --&gt; |grends w | --&gt; |format w| --&gt; |iterate print_s |
+--------+     +-------+     +---------+     +--------+     +----------------+</code></pre>
<h4 id="factored-solution">7.9.3 Factored Solution</h4>
<p>Factorize <code>format</code> so that various line breaking styles
can be plugged in:</p>
<p>```ocaml skip let rec breaks w (inline, endlpos as st) = Await
(function | TE _ as e -&gt; Yield (e, breaks w st) | LE p when List.hd
inline -&gt; Yield (TE (p, ” “), breaks w st) | LE p as e -&gt; Yield
(e, breaks w (inline, p+w)) | GBeg Too_far as e -&gt; Yield (e, breaks w
(false::inline, endlpos)) | GBeg (Pos p) as e -&gt; Yield (e, breaks w
((p&lt;=endlpos)::inline, endlpos)) | GEnd _ as e -&gt; Yield (e, breaks
w (List.tl inline, endlpos)))</p>
<p>let breaks w = breaks w ([false], w)</p>
<p>let rec emit = Await (function | TE (<em>, z) -&gt; Yield (z, emit) |
LE </em> -&gt; Yield (“”, emit) | GBeg _ | GEnd _ -&gt; emit)</p>
<p>let pretty_print w doc = gen doc &gt;-&gt; docpos &gt;-&gt; grends w
&gt;-&gt; breaks w &gt;-&gt; emit &gt;-&gt; iterate print_string</p>
<pre><code>
### 7.10 Exercises

**Exercise 1:** My first impulse was to define lazy list functions as follows:

```ocaml env=ch7
let rec wrong_lzip = function
  | LNil, LNil -&gt; LNil
  | LCons (a1, lazy l1), LCons (a2, lazy l2) -&gt;
      LCons ((a1, a2), lazy (wrong_lzip (l1, l2)))
  | _ -&gt; raise (Invalid_argument &quot;lzip&quot;)

let rec wrong_lmap f = function
  | LNil -&gt; LNil
  | LCons (a, lazy l) -&gt; LCons (f a, lazy (wrong_lmap f l))</code></pre>
<p>What is wrong with these definitions – for which edge cases do they
not work as intended?</p>
<p><strong>Exercise 2:</strong> Cyclic lazy lists.</p>
<ol type="1">
<li><p>Implement a function <code>cycle : 'a list -&gt; 'a llist</code>
that creates a lazy list with elements from a standard list, and the
whole list as the tail after the last element from the input list:
<code>[a1; a2; ...; aN]</code> maps to a cyclic structure where
<code>aN</code> points back to <code>a1</code>. Your function
<code>cycle</code> can either return <code>LNil</code> or fail for an
empty list as argument.</p></li>
<li><p>Note that <code>inv_fact</code> from the lecture defines the
power series for the <span class="math inline">\exp(\cdot)</span>
function (<span class="math inline">\exp(x) = e^x</span>). Using
<code>cycle</code> and <code>inv_fact</code>, define the power series
for <span class="math inline">\sin(\cdot)</span> and <span
class="math inline">\cos(\cdot)</span>, and draw their graphs using
helper functions from the lecture script <code>Lec7.ml</code>.</p></li>
</ol>
<p><strong>Exercise 3:</strong> Modify one of the puzzle solving
programs (either from the previous lecture or from your previous
homework) to work with lazy lists. Implement the necessary higher-order
lazy list functions. Check that indeed displaying only the first
solution when there are multiple solutions in the result takes shorter
than computing solutions by the original program.</p>
<p><strong>Exercise 4:</strong> <em>Hamming’s problem</em>. Generate in
increasing order the numbers of the form <span
class="math inline">2^{a_1} 3^{a_2} 5^{a_3} \ldots p_k^{a_k}</span>,
that is numbers not divisible by prime numbers greater than the <span
class="math inline">k</span>th prime number.</p>
<p>In the original Hamming’s problem posed by Dijkstra, <span
class="math inline">k = 3</span>, which is related to <a
href="http://en.wikipedia.org/wiki/Regular_number">regular
numbers</a>.</p>
<p>Starter code is available in the lecture script
<code>Lec7.ml</code>:</p>
<p>```ocaml env=ch7 let rec lfilter f = function | LNil -&gt; LNil |
LCons (n, ll) -&gt; if f n then LCons (n, lazy (lfilter f (Lazy.force
ll))) else lfilter f (Lazy.force ll)</p>
<p>let primes = let rec sieve = function | LCons(p, nf) -&gt; LCons(p,
lazy (sieve (sift p (Lazy.force nf)))) | LNil -&gt; failwith
“Impossible! Internal error.” and sift p = lfilter (fun n -&gt; n mod p
&lt;&gt; 0) in sieve (l_from 2)</p>
<p>let times ll n = lmap (fun i -&gt; i * n) ll</p>
<p>let rec merge xs ys = match xs, ys with | LCons (x, lazy xr), LCons
(y, lazy yr) -&gt; if x &lt; y then LCons (x, lazy (merge xr ys)) else
if x &gt; y then LCons (y, lazy (merge xs yr)) else LCons (x, lazy
(merge xr yr)) | r, LNil | LNil, r -&gt; r</p>
<p>let hamming k = let _pr = ltake k primes in (* TODO: use primes to
generate smooth numbers <em>) let rec h = LCons (1, lazy ( (</em> TODO
*)h )) in h</p>
<pre><code>
**Exercise 5:** Modify `format` and/or `breaks` to use just a single number instead of a stack of booleans to keep track of what groups should be inlined.

**Exercise 6:** Add **indentation** to the pretty-printer for groups: if a group does not fit in a single line, its consecutive lines are indented by a given amount `tab` of spaces deeper than its parent group lines would be. For comparison, let&#39;s do several implementations.

1. Modify the straightforward implementation of `pretty`.
2. Modify the first pipe-based implementation of `pretty` by modifying the `format` function.
3. Modify the second pipe-based implementation of `pretty` by modifying the `breaks` function. Recover the positions of elements -- the number of characters from the beginning of the document -- by keeping track of the growing offset.
4. (Harder) Modify a pipe-based implementation to provide a different style of indentation: indent the first line of a group, when the group starts on a new line, at the same level as the consecutive lines (rather than at the parent level of indentation).

**Exercise 7:** Write a pipe that takes document elements annotated with linear position, and produces document elements annotated with (line, column) coordinates.

Write another pipe that takes so annotated elements and adds a line number indicator in front of each line. Do not update the column coordinate. Test the pipes by plugging them before the `emit` pipe.
</code></pre>
<p>1: first line 2: second line, etc.</p>
<pre><code>
**Exercise 8:** Write a pipe that consumes document elements `doc_e` and yields the toplevel subdocuments `doc` which would generate the corresponding elements.

You can modify the definition of documents to allow annotations, so that the element annotations are preserved (`gen` should ignore annotations to keep things simple):

```ocaml skip
type &#39;a doc =
  Text of &#39;a * string | Line of &#39;a | Cat of &#39;a doc * &#39;a doc | Group of &#39;a * &#39;a doc</code></pre>
<p><strong>Exercise 9:</strong> (Harder) Design and implement a way to
duplicate arrows outgoing from a pipe-box, that would memoize the
stream, i.e. not recompute everything “upstream” for the composition of
pipes. Such duplicated arrows would behave nicely with pipes reading
from files.</p>
<h2 id="chapter-8-monads">Chapter 8: Monads</h2>
<p>This chapter explores one of functional programming’s most powerful
abstractions: monads. We begin with list comprehensions, introduce
monadic concepts, examine monad laws and the monad-plus extension, then
work through various monad instances including state, exception, and
probability monads. We conclude with monad transformers and cooperative
lightweight threads.</p>
<h3 id="list-comprehensions">8.1 List Comprehensions</h3>
<p>Recall the somewhat awkward syntax we used in the Countdown Problem
example from earlier chapters. The brute-force generation of expressions
looked like this:</p>
<p>```ocaml env=ch8 let combine l r = List.map (fun o -&gt; App (o, l,
r)) [Add; Sub; Mul; Div]</p>
<p>let rec exprs = function | [] -&gt; [] | [n] -&gt; [Val n] | ns -&gt;
split ns |-&gt; (fun (ls, rs) -&gt; exprs ls |-&gt; (fun l -&gt; exprs
rs |-&gt; (fun r -&gt; combine l r)))</p>
<pre><code>
And the generate-and-test scheme used:

```ocaml env=ch8
let guard p e = if p e then [e] else []

let solutions ns n =
  choices ns |-&gt; (fun ns&#39; -&gt;
  exprs ns&#39; |-&gt;
    guard (fun e -&gt; eval e = Some n))</code></pre>
<p>We introduced the operator <code>|-&gt;</code> defined as:</p>
<p><code>ocaml env=ch8 let ( |-&gt; ) x f = concat_map f x</code></p>
<p>We can do much better with list comprehensions syntax extension. In
older versions of OCaml with Camlp4, this was loaded via:</p>
<pre><code>#load &quot;dynlink.cma&quot;;;
#load &quot;camlp4o.cma&quot;;;
#load &quot;Camlp4Parsers/Camlp4ListComprehension.cmo&quot;;;</code></pre>
<p>With list comprehensions, we can write:</p>
<pre><code>let test = [i * 2 | i &lt;- from_to 2 22; i mod 3 = 0]</code></pre>
<p>The translation rules for list comprehensions are:</p>
<ul>
<li><code>[expr | ]</code> translates to <code>[expr]</code></li>
<li><code>[expr | v &lt;- generator; more]</code> translates to
<code>generator |-&gt; (fun v -&gt; [expr | more])</code></li>
<li><code>[expr | condition; more]</code> translates to
<code>if condition then [expr | more] else []</code></li>
</ul>
<h4 id="revisiting-countdown-with-list-comprehensions">Revisiting
Countdown with List Comprehensions</h4>
<p>The brute-force generation becomes cleaner:</p>
<pre><code>let rec exprs = function
  | [] -&gt; []
  | [n] -&gt; [Val n]
  | ns -&gt;
      [App (o, l, r) | (ls, rs) &lt;- split ns;
       l &lt;- exprs ls; r &lt;- exprs rs;
       o &lt;- [Add; Sub; Mul; Div]]</code></pre>
<p>And the generate-and-test scheme simplifies to:</p>
<pre><code>let solutions ns n =
  [e | ns&#39; &lt;- choices ns;
   e &lt;- exprs ns&#39;; eval e = Some n]</code></pre>
<h4 id="more-list-comprehension-examples">More List Comprehension
Examples</h4>
<p>Computing subsequences using list comprehensions (with some garbage
generation):</p>
<pre><code>let rec subseqs l =
  match l with
  | [] -&gt; [[]]
  | x::xs -&gt; [ys | px &lt;- subseqs xs; ys &lt;- [px; x::px]]</code></pre>
<p>Computing permutations via insertion:</p>
<pre><code>let rec insert x = function
  | [] -&gt; [[x]]
  | y::ys&#39; as ys -&gt;
      (x::ys) :: [y::zs | zs &lt;- insert x ys&#39;]

let rec ins_perms = function
  | [] -&gt; [[]]
  | x::xs -&gt; [zs | ys &lt;- ins_perms xs; zs &lt;- insert x ys]</code></pre>
<p>And via selection:</p>
<pre><code>let rec select = function
  | [x] -&gt; [x, []]
  | x::xs -&gt; (x, xs) :: [y, x::ys | y, ys &lt;- select xs]

let rec sel_perms = function
  | [] -&gt; [[]]
  | xs -&gt; [x::ys | x, xs&#39; &lt;- select xs; ys &lt;- sel_perms xs&#39;]</code></pre>
<h3 id="generalized-comprehensions-binding-operators">8.2 Generalized
Comprehensions: Binding Operators</h3>
<p>OCaml 5 introduced <strong>binding operators</strong> that provide a
clean, native syntax for monadic computations. Instead of external
syntax extensions like the old <code>pa_monad</code>, we can define
custom <code>let*</code> and <code>let+</code> operators that integrate
naturally with the language.</p>
<p>For the list monad, we define these binding operators:</p>
<p><code>ocaml env=ch8 let ( let* ) x f = concat_map f x      (* bind *) let ( let+ ) x f = List.map f x        (* map/fmap *) let ( and* ) x y = concat_map (fun a -&gt; List.map (fun b -&gt; (a, b)) y) x let ( and+ ) = ( and* ) let return x = [x] let fail = []</code></p>
<p>With these operators, the expression generation code becomes:</p>
<pre><code>let rec exprs = function
  | [] -&gt; []
  | [n] -&gt; [Val n]
  | ns -&gt;
      let* (ls, rs) = split ns in
      let* l = exprs ls in
      let* r = exprs rs in
      let* o = [Add; Sub; Mul; Div] in
      [App (o, l, r)]</code></pre>
<p>Note that unlike the old <code>perform</code> syntax where we used
<code>&lt;--</code> for binding, we now use <code>let*</code> followed
by <code>=</code> and must explicitly write <code>in</code> before the
continuation.</p>
<p>The <code>let*</code> syntax does not directly support guards. If we
try to write:</p>
<pre><code>let solutions ns n =
  let* ns&#39; = choices ns in
  let* e = exprs ns&#39; in
  eval e = Some n;  (* Error! *)
  e</code></pre>
<p>We get an error because it expects a list, not a boolean. We can work
around this by deciding whether to return anything:</p>
<pre><code>let solutions ns n =
  let* ns&#39; = choices ns in
  let* e = exprs ns&#39; in
  if eval e = Some n then [e] else []</code></pre>
<p>For a general guard check function, we define:</p>
<p><code>ocaml env=ch8 let guard p = if p then [()] else []</code></p>
<p>And then:</p>
<pre><code>let solutions ns n =
  let* ns&#39; = choices ns in
  let* e = exprs ns&#39; in
  let* () = guard (eval e = Some n) in
  [e]</code></pre>
<h3 id="monads">8.3 Monads</h3>
<p>A monad is a polymorphic type <code>'a monad</code> (or
<code>'a Monad.t</code>) that supports at least two operations:</p>
<ul>
<li><code>bind : 'a monad -&gt; ('a -&gt; 'b monad) -&gt; 'b monad</code></li>
<li><code>return : 'a -&gt; 'a monad</code></li>
<li>The infix <code>&gt;&gt;=</code> is commonly used for
<code>bind</code>: <code>let (&gt;&gt;=) a b = bind a b</code></li>
</ul>
<p>With OCaml 5’s binding operators, we define <code>let*</code> as an
alias for <code>bind</code>:</p>
<p>```ocaml env=ch8 let bind a b = concat_map b a let return x = [x] let
( let* ) = bind</p>
<p>let solutions ns n = let* ns’ = choices ns in let* e = exprs ns’ in
let* () = guard (eval e = Some n) in return e</p>
<pre><code>
Why does `guard` look this way? Let us examine:

```ocaml env=ch8
let fail = []
let guard p = if p then return () else fail</code></pre>
<p>Steps in monadic computation are composed with <code>let*</code> (or
<code>&gt;&gt;=</code>, like <code>|-&gt;</code> for lists). The key
insight is:</p>
<ul>
<li><code>let* _ = [] in ...</code> does not produce anything – as
needed by guarding</li>
<li><code>let* _ = [()] in ...</code> becomes
<code>(fun _ -&gt; ...) ()</code> which simply continues the computation
unchanged</li>
</ul>
<p>Throwing away the binding argument is common. With binding operators,
we can use <code>let* () = ...</code> or <code>let* _ = ...</code>:</p>
<p><code>ocaml env=ch8 let (&gt;&gt;=) a b = bind a b let (&gt;&gt;) m f = m &gt;&gt;= (fun _ -&gt; f)</code></p>
<h4 id="the-binding-operator-syntax">The Binding Operator Syntax</h4>
<p>OCaml 5’s binding operators translate as follows:</p>
<table>
<colgroup>
<col style="width: 38%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr>
<th>Source</th>
<th>Translation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>let* x = exp in body</code></td>
<td><code>bind exp (fun x -&gt; body)</code></td>
</tr>
<tr>
<td><code>let+ x = exp in body</code></td>
<td><code>map (fun x -&gt; body) exp</code></td>
</tr>
<tr>
<td><code>let* () = exp in body</code></td>
<td><code>bind exp (fun () -&gt; body)</code></td>
</tr>
<tr>
<td><code>let* x = e1 and* y = e2 in body</code></td>
<td><code>bind (and* e1 e2) (fun (x, y) -&gt; body)</code></td>
</tr>
</tbody>
</table>
<p>The binding operators <code>let*</code>, <code>let+</code>,
<code>and*</code>, and <code>and+</code> must be defined in scope. These
are regular OCaml operators and require no syntax extensions.</p>
<p>For pattern matching in bindings, if the pattern is refutable (can
fail to match), the monadic operation should handle the failure
appropriately.</p>
<h3 id="monad-laws">8.4 Monad Laws</h3>
<p>A parametric data type is a monad only if its <code>bind</code> and
<code>return</code> operations meet these axioms:</p>
<p><span class="math display">
\begin{aligned}
\text{bind}\ (\text{return}\ a)\ f &amp;\approx f\ a &amp; \text{(left
identity)} \\
\text{bind}\ a\ (\lambda x.\text{return}\ x) &amp;\approx a &amp;
\text{(right identity)} \\
\text{bind}\ (\text{bind}\ a\ (\lambda x.b))\ (\lambda y.c) &amp;\approx
\text{bind}\ a\ (\lambda x.\text{bind}\ b\ (\lambda y.c)) &amp;
\text{(associativity)}
\end{aligned}
</span></p>
<p>You should verify that these laws hold for our list monad:</p>
<p><code>ocaml env=ch8 let bind a b = concat_map b a let return x = [x]</code></p>
<h3 id="monoid-laws-and-monad-plus">8.5 Monoid Laws and Monad-Plus</h3>
<p>A monoid is a type with at least two operations:</p>
<ul>
<li><code>mzero : 'a monoid</code></li>
<li><code>mplus : 'a monoid -&gt; 'a monoid -&gt; 'a monoid</code></li>
</ul>
<p>that meet these laws:</p>
<p><span class="math display">
\begin{aligned}
\text{mplus}\ \text{mzero}\ a &amp;\approx a &amp; \text{(left
identity)} \\
\text{mplus}\ a\ \text{mzero} &amp;\approx a &amp; \text{(right
identity)} \\
\text{mplus}\ a\ (\text{mplus}\ b\ c) &amp;\approx \text{mplus}\
(\text{mplus}\ a\ b)\ c &amp; \text{(associativity)}
\end{aligned}
</span></p>
<p>We define <code>fail</code> as a synonym for <code>mzero</code> and
infix <code>++</code> for <code>mplus</code>.</p>
<p>Fusing monads and monoids gives the most popular general flavor of
monads, which we call <strong>monad-plus</strong> after Haskell.
Monad-plus requires additional axioms relating its “addition” and
“multiplication”:</p>
<p><span class="math display">
\begin{aligned}
\text{bind}\ \text{mzero}\ f &amp;\approx \text{mzero} \\
\text{bind}\ m\ (\lambda x.\text{mzero}) &amp;\approx \text{mzero}
\end{aligned}
</span></p>
<p>Using infix notation with <span class="math inline">\oplus</span> for
<code>mplus</code>, <span class="math inline">\mathbf{0}</span> for
<code>mzero</code>, <span class="math inline">\triangleright</span> for
<code>bind</code>, and <span class="math inline">\mathbf{1}</span> for
<code>return</code>, the complete monad-plus axioms are:</p>
<p><span class="math display">
\begin{aligned}
\mathbf{0} \oplus a &amp;\approx a \\
a \oplus \mathbf{0} &amp;\approx a \\
a \oplus (b \oplus c) &amp;\approx (a \oplus b) \oplus c \\
\mathbf{1}\ x \triangleright f &amp;\approx f\ x \\
a \triangleright \lambda x.\mathbf{1}\ x &amp;\approx a \\
(a \triangleright \lambda x.b) \triangleright \lambda y.c &amp;\approx a
\triangleright (\lambda x.b \triangleright \lambda y.c) \\
\mathbf{0} \triangleright f &amp;\approx \mathbf{0} \\
a \triangleright (\lambda x.\mathbf{0}) &amp;\approx \mathbf{0}
\end{aligned}
</span></p>
<p>The list type has a natural monad and monoid structure:</p>
<p><code>ocaml env=ch8 let mzero = [] let mplus = (@) let bind a b = concat_map b a let return a = [a]</code></p>
<p>We can define in any monad-plus:</p>
<p><code>ocaml env=ch8 let fail = mzero let failwith _ = fail let (++) = mplus let (&gt;&gt;=) a b = bind a b let guard p = if p then return () else fail</code></p>
<h3 id="backtracking-computation-with-choice">8.6 Backtracking:
Computation with Choice</h3>
<p>We have seen <code>mzero</code> (i.e., <code>fail</code>) in the
countdown problem. What about <code>mplus</code>? Here is an example
from a puzzle solver:</p>
<p>```ocaml skip let find_to_eat n island_size num_islands empty_cells =
let honey = honey_cells n empty_cells in</p>
<p>let rec find_board s = match visit_cell s with | None -&gt; let* () =
guard (s.been_islands = num_islands) in return s.eaten | Some (cell, s)
-&gt; let* s = find_island cell (fresh_island s) in let* () = guard
(s.been_size = island_size) in find_board s</p>
<p>and find_island current s = let s = keep_cell current s in neighbors
n empty_cells current |&gt; foldM (fun neighbor s -&gt; if CellSet.mem
neighbor s.visited then return s else let choose_eat = if s.more_to_eat
&lt;= 0 then fail else return (eat_cell neighbor s) and choose_keep = if
s.been_size &gt;= island_size then fail else find_island neighbor s in
mplus choose_eat choose_keep) (* Choice point! *) s in</p>
<p>let cells_to_eat = List.length honey - island_size * num_islands in
find_board (init_state honey cells_to_eat)</p>
<pre><code>
The `mplus choose_eat choose_keep` creates a choice point: either eat the cell or keep it as part of the island. The monad-plus structure handles backtracking automatically.

### 8.7 Monad Flavors

Monads &quot;wrap around&quot; a type, but some monads need an additional type parameter. Usually the additional type does not change while within a monad, so we stick to `&#39;a monad` rather than `(&#39;s, &#39;a) monad`.

As monad-plus shows, things get interesting when we add more operations to a basic monad. Here are some common monad flavors:

**Monads with access:**
</code></pre>
<p>access : ’a monad -&gt; ’a</p>
<pre><code>
Example: the lazy monad.

**Monad-plus (non-deterministic computation):**
</code></pre>
<p>mzero : ’a monad mplus : ’a monad -&gt; ’a monad -&gt; ’a monad</p>
<pre><code>
**Monads with state (parameterized by type `store`):**
</code></pre>
<p>get : store monad put : store -&gt; unit monad</p>
<pre><code>
There is a &quot;canonical&quot; state monad. Similar monads include the writer monad (with `get` called `listen` and `put` called `tell`) and the reader monad, without `put`, but with `get` (called `ask`) and:
</code></pre>
<p>local : (store -&gt; store) -&gt; ’a monad -&gt; ’a monad</p>
<pre><code>
**Exception/error monads (parameterized by type `excn`):**
</code></pre>
<p>throw : excn -&gt; ’a monad catch : ’a monad -&gt; (excn -&gt; ’a
monad) -&gt; ’a monad</p>
<pre><code>
**Continuation monad:**
</code></pre>
<p>callCC : ((’a -&gt; ’b monad) -&gt; ’a monad) -&gt; ’a monad</p>
<pre><code>
We will not cover continuations in detail here.

**Probabilistic computation:**
</code></pre>
<p>choose : float -&gt; ’a monad -&gt; ’a monad -&gt; ’a monad</p>
<pre><code>
satisfying the laws with $a \oplus_p b$ for `choose p a b` and $p \cdot q$ for `p *. q`, where $0 \leq p, q \leq 1$:

$$
\begin{aligned}
a \oplus_0 b &amp;\approx b \\
a \oplus_p b &amp;\approx b \oplus_{1-p} a \\
a \oplus_p (b \oplus_q c) &amp;\approx (a \oplus_{\frac{p}{p+q-pq}} b) \oplus_{p+q-pq} c \\
a \oplus_p a &amp;\approx a
\end{aligned}
$$

**Parallel computation (monad with access and parallel bind):**
</code></pre>
<p>parallel : ’a monad -&gt; ’b monad -&gt; (’a -&gt; ’b -&gt; ’c monad)
-&gt; ’c monad</p>
<pre><code>
Example: lightweight threads.

### 8.8 Interlude: The Module System

OCaml&#39;s module system provides the infrastructure for defining monads in a reusable way. Here is a brief overview of the key concepts.

Modules collect related type definitions and operations together. Module values are introduced with `struct ... end` (structures), and module types with `sig ... end` (signatures). A structure is a package of definitions; a signature is an interface for packages.

A source file `source.ml` defines a module `Source`. A file `source.mli` defines its type.

In the module level, modules are defined with `module ModuleName = ...` or `module ModuleName : MODULE_TYPE = ...`, and module types with `module type MODULE_TYPE = ...`.

Locally in expressions, modules are defined with `let module M = ... in ...`.

The content of a module is made visible with `open Module`. Module `Pervasives` (now `Stdlib`) is initially visible.

Content of a module is included into another module with `include Module`.

**Functors** are module functions -- functions from modules to modules:
</code></pre>
<p>module Funct = functor (Arg : sig … end) -&gt; struct … end (* Or
equivalently: *) module Funct (Arg : sig … end) = struct … end</p>
<pre><code>
Functors can return functors, and modules can be parameterized by multiple modules. Functor application always uses parentheses: `Funct (struct ... end)`.

A signature `MODULE_TYPE with type t_name = ...` is like `MODULE_TYPE` but with `t_name` made more specific. We can also include signatures with `include MODULE_TYPE`.

Finally, we can pass around modules in normal functions using first-class modules:

```ocaml env=ch8
module type T = sig val g : int -&gt; int end

let f mod_v x =
  let module M = (val mod_v : T) in
  M.g x
(* val f : (module T) -&gt; int -&gt; int = &lt;fun&gt; *)

let test = f (module struct let g i = i*i end : T)
(* val test : int -&gt; int = &lt;fun&gt; *)</code></pre>
<h3 id="the-two-metaphors">8.9 The Two Metaphors</h3>
<p>Monads can be understood through two complementary metaphors.</p>
<h4 id="monads-as-containers">Monads as Containers</h4>
<p>A monad is a <strong>quarantine container</strong>:</p>
<ul>
<li>We can put something into the container with
<code>return</code></li>
<li>We can operate on it, but the result needs to stay in the
container</li>
</ul>
<p><code>ocaml env=ch8 let lift f m =   let* x = m in   return (f x) (* val lift : ('a -&gt; 'b) -&gt; 'a monad -&gt; 'b monad *)</code></p>
<ul>
<li>We can deactivate-unwrap the quarantine container but only when it
is in another container so the quarantine is not broken</li>
</ul>
<p><code>ocaml env=ch8 let join m =   let* x = m in   x (* val join : ('a monad) monad -&gt; 'a monad *)</code></p>
<p>The quarantine container for a <strong>monad-plus</strong> is more
like other containers: it can be empty, or contain multiple
elements.</p>
<p>Monads with access allow us to extract the resulting element from the
container; other monads provide a <code>run</code> operation that
exposes “what really happened behind the quarantine.”</p>
<h4 id="monads-as-computation">Monads as Computation</h4>
<p>To compute the result, use <code>let*</code> bindings to sequence
instructions, naming partial results. The physical metaphor is an
<strong>assembly line</strong>:</p>
<pre><code>let assemblyLine w =
  let* c = makeChopsticks w in    (* Worker makes chopsticks *)
  let* c&#39; = polishChopsticks c in (* Worker polishes them *)
  let* c&#39;&#39; = wrapChopsticks c&#39; in (* Worker wraps them *)
  return c&#39;&#39;                       (* Loader returns the result *)</code></pre>
<p>Any expression can be spread over a monad. For lambda-terms:</p>
<p><span class="math display">
\begin{aligned}
[\![ N ]\!] &amp;= \text{return}\ N &amp; \text{(constant)} \\
[\![ x ]\!] &amp;= \text{return}\ x &amp; \text{(variable)} \\
[\![ \lambda x.a ]\!] &amp;= \text{return}\ (\lambda x.[\![ a ]\!])
&amp; \text{(function)} \\
[\![ \text{let}\ x = a\ \text{in}\ b ]\!] &amp;= \text{bind}\ [\![ a
]\!]\ (\lambda x.[\![ b ]\!]) &amp; \text{(local definition)} \\
[\![ a\ b ]\!] &amp;= \text{bind}\ [\![ a ]\!]\ (\lambda
v_a.\text{bind}\ [\![ b ]\!]\ (\lambda v_b.v_a\ v_b)) &amp;
\text{(application)}
\end{aligned}
</span></p>
<p>When an expression is spread over a monad, its computation can be
monitored or affected without modifying the expression.</p>
<h3 id="monad-classes-and-instances">8.10 Monad Classes and
Instances</h3>
<p>To implement a monad, we need to provide the implementation type,
<code>return</code>, and <code>bind</code> operations.</p>
<p><code>ocaml env=ch8 module type MONAD = sig   type 'a t   val return : 'a -&gt; 'a t   val bind : 'a t -&gt; ('a -&gt; 'b t) -&gt; 'b t end</code></p>
<p>Alternatively, we could start from <code>return</code>,
<code>lift</code>, and <code>join</code> operations.</p>
<p>Based on just these two operations, we can define a suite of
general-purpose functions:</p>
<p>```ocaml env=ch8 module type MONAD_OPS = sig type ’a monad include
MONAD with type ’a t := ’a monad val ( let* ) : ’a monad -&gt; (’a -&gt;
’b monad) -&gt; ’b monad val ( let+ ) : ’a monad -&gt; (’a -&gt; ’b)
-&gt; ’b monad val ( &gt;&gt;= ) : ’a monad -&gt; (’a -&gt; ’b monad)
-&gt; ’b monad val foldM : (’a -&gt; ’b -&gt; ’a monad) -&gt; ’a -&gt;
’b list -&gt; ’a monad val whenM : bool -&gt; unit monad -&gt; unit
monad val lift : (’a -&gt; ’b) -&gt; ’a monad -&gt; ’b monad val
(&gt;&gt;|) : ’a monad -&gt; (’a -&gt; ’b) -&gt; ’b monad val join : ’a
monad monad -&gt; ’a monad val ( &gt;=&gt;) : (’a -&gt; ’b monad) -&gt;
(’b -&gt; ’c monad) -&gt; ’a -&gt; ’c monad end</p>
<p>module MonadOps (M : MONAD) = struct open M type ‘a monad = ’a t let
run x = x let ( let* ) a b = bind a b let ( let+ ) a f = bind a (fun x
-&gt; return (f x)) let (&gt;&gt;=) a b = bind a b let rec foldM f a =
function | [] -&gt; return a | x::xs -&gt; let* a’ = f a x in foldM f a’
xs let whenM p s = if p then s else return () let lift f m = let* x = m
in return (f x) let (&gt;&gt;|) a b = lift b a let join m = let* x = m
in x let (&gt;=&gt;) f g = fun x -&gt; let* y = f x in g y end</p>
<pre><code>
We make the monad &quot;safe&quot; by keeping its type abstract, but `run` exposes &quot;what really happened&quot;:

```ocaml env=ch8
module Monad (M : MONAD) : sig
  include MONAD_OPS
  val run : &#39;a monad -&gt; &#39;a M.t
end = struct
  include M
  include MonadOps(M)
end</code></pre>
<h4 id="monad-plus-classes">Monad-Plus Classes</h4>
<p>The monad-plus class has many implementations. They need to provide
<code>mzero</code> and <code>mplus</code>:</p>
<p>```ocaml env=ch8 module type MONAD_PLUS = sig include MONAD val mzero
: ’a t val mplus : ’a t -&gt; ’a t -&gt; ’a t end</p>
<p>module type MONAD_PLUS_OPS = sig include MONAD_OPS val mzero : ’a
monad val mplus : ’a monad -&gt; ’a monad -&gt; ’a monad val fail : ’a
monad val (++) : ’a monad -&gt; ’a monad -&gt; ’a monad val guard : bool
-&gt; unit monad val msum_map : (’a -&gt; ’b monad) -&gt; ’a list -&gt;
’b monad end</p>
<p>module MonadPlusOps (M : MONAD_PLUS) = struct open M include
MonadOps(M) let fail = mzero let (++) a b = mplus a b let guard p = if p
then return () else fail let msum_map f l = List.fold_right (fun a acc
-&gt; mplus (f a) acc) l mzero end</p>
<p>module MonadPlus (M : MONAD_PLUS) : sig include MONAD_PLUS_OPS val
run : ’a monad -&gt; ’a M.t end = struct include M include
MonadPlusOps(M) end</p>
<pre><code>
We also need a class for computations with state:

```ocaml env=ch8
module type STATE = sig
  type store
  type &#39;a t
  val get : store t
  val put : store -&gt; unit t
end</code></pre>
<h3 id="monad-instances">8.11 Monad Instances</h3>
<h4 id="the-lazy-monad">The Lazy Monad</h4>
<p>Heavy laziness notation? Try a monad (with access):</p>
<p>```ocaml env=ch8 module LazyM = Monad (struct type ’a t = ’a Lazy.t
let bind a b = lazy (Lazy.force (b (Lazy.force a))) let return a = lazy
a end)</p>
<p>let laccess m = Lazy.force (LazyM.run m)</p>
<pre><code>
#### The List Monad

Our resident list monad (monad-plus):

```ocaml env=ch8
module ListM = MonadPlus (struct
  type &#39;a t = &#39;a list
  let bind a b = concat_map b a
  let return a = [a]
  let mzero = []
  let mplus = List.append
end)</code></pre>
<h4 id="backtracking-parameterized-by-monad-plus">Backtracking
Parameterized by Monad-Plus</h4>
<p>The Countdown module can be parameterized by any monad-plus:</p>
<p>```ocaml env=ch8 module Countdown (M : MONAD_PLUS_OPS) = struct open
M (* Open the module to make monad operations visible *)</p>
<p>let rec insert x = function (* All choice-introducing operations
<em>) | [] -&gt; return [x] (</em> need to happen in the monad <em>) |
y::ys as xs -&gt; let</em> xys = insert x ys in return (x::xs) ++ return
(y::xys)</p>
<p>let rec choices = function | [] -&gt; return [] | x::xs -&gt; let*
cxs = choices xs in (* Choosing which numbers in what order <em>) return
cxs ++ insert x cxs (</em> and now whether with or without x *)</p>
<p>type op = Add | Sub | Mul | Div</p>
<p>let apply op x y = match op with | Add -&gt; x + y | Sub -&gt; x - y
| Mul -&gt; x * y | Div -&gt; x / y</p>
<p>let valid op x y = match op with | Add -&gt; x &lt;= y | Sub -&gt; x
&gt; y | Mul -&gt; x &lt;= y &amp;&amp; x &lt;&gt; 1 &amp;&amp; y
&lt;&gt; 1 | Div -&gt; x mod y = 0 &amp;&amp; y &lt;&gt; 1</p>
<p>type expr = Val of int | App of op * expr * expr</p>
<p>let op2str = function | Add -&gt; “+” | Sub -&gt; “-” | Mul -&gt; “*”
| Div -&gt; “/”</p>
<p>let rec expr2str = function (* We will provide solutions as strings
*) | Val n -&gt; string_of_int n | App (op, l, r) -&gt; “(” ^ expr2str l
^ op2str op ^ expr2str r ^ “)”</p>
<p>let combine (l, x) (r, y) o = (* Try out an operator <em>) let</em>
() = guard (valid o x y) in return (App (o, l, r), apply o x y)</p>
<p>let split l = (* Another choice: which numbers go into which argument
<em>) let rec aux lhs = function | [] | [_] -&gt; fail (</em> Both
arguments need numbers *) | [y; z] -&gt; return (List.rev (y::lhs), [z])
| hd::rhs -&gt; let lhs = hd::lhs in return (List.rev lhs, rhs) ++ aux
lhs rhs in aux [] l</p>
<p>let rec results = function (* Build possible expressions once numbers
<em>) | [] -&gt; fail (</em> have been picked <em>) | [n] -&gt; let</em>
() = guard (n &gt; 0) in return (Val n, n) | ns -&gt; let* (ls, rs) =
split ns in let* lx = results ls in let* ly = results rs in (* Collect
solutions using each operator *) msum_map (combine lx ly) [Add; Sub;
Mul; Div]</p>
<p>let solutions ns n = (* Solve the problem: <em>) let</em> ns’ =
choices ns in (* pick numbers and their order, <em>) let</em> (e, m) =
results ns’ in (* build possible expressions, <em>) let</em> () = guard
(m = n) in (* check if the expression gives target value, <em>) return
(expr2str e) (</em> “print” the solution *) end</p>
<pre><code>
#### Understanding Laziness

Let us measure execution times:

```ocaml env=ch8
let time f =
  let tbeg = Unix.gettimeofday () in
  let res = f () in
  let tend = Unix.gettimeofday () in
  tend -. tbeg, res</code></pre>
<p>With the list monad:</p>
<p><code>ocaml env=ch8 module ListCountdown = Countdown (ListM) let test1 () = ListM.run (ListCountdown.solutions [1;3;7;10;25;50] 765) let t1, sol1 = time test1 (* val t1 : float = 2.28... *) (* val sol1 : string list = ["((25-(3+7))*(1+50))"; "(((25-3)-7)*(1+50))"; ...] *)</code></p>
<p>What if we want only one solution? Laziness to the rescue! We define
an “odd lazy list”:</p>
<p>```ocaml env=ch8 type ’a llist = LNil | LCons of ’a * ’a llist
Lazy.t</p>
<p>let rec ltake n = function | LCons (a, lazy l) when n &gt; 0 -&gt;
a::(ltake (n-1) l) | _ -&gt; []</p>
<p>let rec lappend l1 l2 = match l1 with | LNil -&gt; l2 | LCons (hd,
tl) -&gt; LCons (hd, lazy (lappend (Lazy.force tl) l2))</p>
<p>let rec lconcat_map f = function | LNil -&gt; LNil | LCons (a, lazy
l) -&gt; lappend (f a) (lconcat_map f l)</p>
<p>module LListM = MonadPlus (struct type ’a t = ’a llist let bind a b =
lconcat_map b a let return a = LCons (a, lazy LNil) let mzero = LNil let
mplus = lappend end)</p>
<pre><code>
Testing shows that the odd lazy list still takes about the same time to even get the lazy list started! The elements are almost already computed once the first one is.

The **option monad** does not help either:

```ocaml env=ch8
module OptionM = MonadPlus (struct
  type &#39;a t = &#39;a option
  let bind a b =
    match a with None -&gt; None | Some x -&gt; b x
  let return a = Some a
  let mzero = None
  let mplus a b = match a with None -&gt; b | Some _ -&gt; a
end)</code></pre>
<p>This very quickly computes… nothing. The <code>OptionM</code> monad
(Haskell’s <code>Maybe</code> monad) is good for computations that might
fail, but not for search with multiple solutions.</p>
<p>Our lazy list type is not lazy enough. Whenever we “make” a choice
with <code>a ++ b</code> or <code>msum_map</code>, it computes the first
candidate for each choice path immediately.</p>
<p>We need <strong>even lazy lists</strong> (our <code>llist</code>
above are called “odd lazy lists”):</p>
<p>```ocaml env=ch8 type ’a lazy_list = ’a lazy_list_ Lazy.t and ’a
lazy_list_ = LazNil | LazCons of ’a * ’a lazy_list</p>
<p>let rec laztake n = function | lazy (LazCons (a, l)) when n &gt; 0
-&gt; a::(laztake (n-1) l) | _ -&gt; []</p>
<p>let rec append_aux l1 l2 = match l1 with | lazy LazNil -&gt;
Lazy.force l2 | lazy (LazCons (hd, tl)) -&gt; LazCons (hd, lazy
(append_aux tl l2))</p>
<p>let lazappend l1 l2 = lazy (append_aux l1 l2)</p>
<p>let rec concat_map_aux f = function | lazy LazNil -&gt; LazNil | lazy
(LazCons (a, l)) -&gt; append_aux (f a) (lazy (concat_map_aux f l))</p>
<p>let lazconcat_map f l = lazy (concat_map_aux f l)</p>
<p>module LazyListM = MonadPlus (struct type ’a t = ’a lazy_list let
bind a b = lazconcat_map b a let return a = lazy (LazCons (a, lazy
LazNil)) let mzero = lazy LazNil let mplus = lazappend end)</p>
<pre><code>
Now the first solution takes considerably less time than all solutions. The next 9 solutions are almost computed once the first one is. But computing all solutions takes nearly twice as long as without the overhead of lazy computation -- the price of laziness.

#### The Exception Monad

Built-in non-functional exceptions in OCaml are more efficient and more flexible. However, monadic exceptions are safer than standard exceptions in situations like multi-threading. The monadic lightweight-thread library Lwt has `throw` (called `fail` there) and `catch` operations in its monad.

```ocaml env=ch8
module ExceptionM (Excn : sig type t end) : sig
  type excn = Excn.t
  type &#39;a t = OK of &#39;a | Bad of excn
  include MONAD_OPS
  val run : &#39;a monad -&gt; &#39;a t
  val throw : excn -&gt; &#39;a monad
  val catch : &#39;a monad -&gt; (excn -&gt; &#39;a monad) -&gt; &#39;a monad
end = struct
  type excn = Excn.t
  module M = struct
    type &#39;a t = OK of &#39;a | Bad of excn
    let return a = OK a
    let bind m b = match m with
      | OK a -&gt; b a
      | Bad e -&gt; Bad e
  end
  include M
  include MonadOps(M)
  let throw e = Bad e
  let catch m handler = match m with
    | OK _ -&gt; m
    | Bad e -&gt; handler e
end</code></pre>
<h4 id="the-state-monad">The State Monad</h4>
<p><code>ocaml env=ch8 module StateM (Store : sig type t end) : sig   type store = Store.t   type 'a t = store -&gt; 'a * store  (* Pass the current store value to get the next value *)   include MONAD_OPS   include STATE with type 'a t := 'a monad                  and type store := store   val run : 'a monad -&gt; 'a t end = struct   type store = Store.t   module M = struct     type 'a t = store -&gt; 'a * store     let return a = fun s -&gt; a, s     (* Keep the current value unchanged *)     let bind m b = fun s -&gt; let a, s' = m s in b a s'   end                          (* To bind two steps, pass the value after first step *)   include M                          (* to the second step *)   include MonadOps(M)   let get = fun s -&gt; s, s            (* Keep the value unchanged but put it in monad *)   let put s' = fun _ -&gt; (), s'       (* Change the value; a throwaway in monad *) end</code></p>
<p>The state monad is useful to hide passing-around of a “current”
value. Here is an example that renames variables in lambda-terms to
eliminate potential name clashes:</p>
<p>```ocaml skip type term = | Var of string | Lam of string * term |
App of term * term</p>
<p>let (!) x = Var x let (|-&gt;) x t = Lam (x, t) let (@) t1 t2 = App
(t1, t2) let test = “x” |-&gt; (“x” |-&gt; !“y” @ !“x”) @ !“x”</p>
<p>module S = StateM (struct type t = int * (string * string) list end)
open S</p>
<p>let rec alpha_conv = function | Var x as v -&gt; (* Function from
terms to StateM monad <em>) let</em> (<em>, env) = get in (* Seeing a
variable does not change state <em>) let v = try Var (List.assoc x env)
(</em> but we need its new name <em>) with Not_found -&gt; v in (</em>
Free variables don’t change name <em>) return v | Lam (x, t) -&gt;
(</em> We rename each bound variable <em>) let</em> (fresh, env) = get
in (* We need a fresh number <em>) let x’ = x ^ string_of_int fresh in
let</em> () = put (fresh+1, (x, x’)::env) in (* Remember new name,
update number <em>) let</em> t’ = alpha_conv t in let* (fresh’, </em>) =
get in (* We need to restore names, <em>) let</em> () = put (fresh’,
env) in (* but keep the number fresh <em>) return (Lam (x’, t’)) | App
(t1, t2) -&gt; let</em> t1 = alpha_conv t1 in (* Passing around of names
<em>) let</em> t2 = alpha_conv t2 in (* and the currently fresh number
<em>) return (App (t1, t2)) (</em> is done by the monad *)</p>
<p>(* val test : term = Lam (“x”, App (Lam (“x”, App (Var “y”, Var
“x”)), Var “x”)) <em>) (</em> # StateM.run (alpha_conv test) (5, []);; -
: term * (int * (string * string) list) = (Lam (“x5”, App (Lam (“x6”,
App (Var “y”, Var “x6”)), Var “x5”)), (7, [])) *)</p>
<pre><code>
Note: This does not make a lambda-term safe for multiple steps of beta-reduction. Can you find a counter-example?

### 8.12 Monad Transformers

Sometimes we need merits of multiple monads at the same time, e.g., monads `AM` and `BM`. The straightforward idea is to nest one monad within another: either `&#39;a AM.monad BM.monad` or `&#39;a BM.monad AM.monad`. But we want a monad that has operations of both `AM` and `BM`.

It turns out that the straightforward approach does not lead to operations with the meaning we want. A **monad transformer** `AT` takes a monad `BM` and turns it into a monad `AT(BM)` which actually wraps around `BM` on both sides. `AT(BM)` has operations of both monads.

We will develop a monad transformer `StateT` which adds state to a monad-plus. The resulting monad has all: `return`, `bind`, `mzero`, `mplus`, `put`, `get`, and their supporting general-purpose functions.

We need monad transformers in OCaml because &quot;monads are contagious&quot;: although we have built-in state and exceptions, we need to use monadic state and exceptions when we are inside a monad. This is the reason Lwt is both a concurrency and an exception monad.

The state monad uses `let x = a in ...` for binding. The transformed monad uses `M.bind` (or `M.let*`) instead:
</code></pre>
<p>type ’a state = store -&gt; (’a * store)</p>
<p>let return (a : ’a) : ’a state = fun s -&gt; (a, s)</p>
<p>let bind (u : ‘a state) (f : ’a -&gt; ’b state) : ’b state = fun s
-&gt; (fun (a, s’) -&gt; f a s’) (u s)</p>
<p>(* Monad M transformed to add state, in pseudo-code: <em>) type ’a
stateT(M) = store -&gt; (’a </em> store) M (* notice this is not an (’a
M) state *)</p>
<p>let return (a : ’a) : ’a stateT(M) = fun s -&gt; M.return (a, s) (*
Rather than returning, M.return *)</p>
<p>let bind (u : ‘a stateT(M)) (f : ’a -&gt; ’b stateT(M)) : ’b
stateT(M) = fun s -&gt; M.bind (u s) (fun (a, s’) -&gt; f a s’) (*
Rather than let-binding, M.bind *)</p>
<pre><code>
#### State Transformer Implementation

```ocaml env=ch8
module StateT (MP : MONAD_PLUS_OPS) (Store : sig type t end) : sig
  type store = Store.t
  type &#39;a t = store -&gt; (&#39;a * store) MP.monad
  include MONAD_PLUS_OPS         (* Exporting all monad-plus operations *)
  include STATE with type &#39;a t := &#39;a monad
                 and type store := store  (* and state operations *)
  val run : &#39;a monad -&gt; &#39;a t     (* Expose &quot;what happened&quot; -- resulting states *)
  val runT : &#39;a monad -&gt; store -&gt; &#39;a MP.monad
end = struct                     (* Run the state transformer -- get resulting values *)
  type store = Store.t
  module M = struct
    type &#39;a t = store -&gt; (&#39;a * store) MP.monad
    let return a = fun s -&gt; MP.return (a, s)
    let bind m b = fun s -&gt;
      MP.bind (m s) (fun (a, s&#39;) -&gt; b a s&#39;)
    let mzero = fun _ -&gt; MP.mzero            (* Lift the monad-plus operations *)
    let mplus ma mb = fun s -&gt; MP.mplus (ma s) (mb s)
  end
  include M
  include MonadPlusOps(M)
  let get = fun s -&gt; MP.return (s, s)        (* Instead of just returning, *)
  let put s&#39; = fun _ -&gt; MP.return ((), s&#39;)   (* MP.return *)
  let runT m s = MP.lift fst (m s)
end</code></pre>
<h4 id="backtracking-with-state">Backtracking with State</h4>
<p>Using the state transformer with our puzzle solver:</p>
<p>```ocaml skip module HoneyIslands (M : MONAD_PLUS_OPS) = struct type
state = { been_size : int; been_islands : int; unvisited : cell list;
visited : CellSet.t; eaten : cell list; more_to_eat : int; }</p>
<p>let init_state unvisited more_to_eat = { been_size = 0; been_islands
= 0; unvisited; visited = CellSet.empty; eaten = []; more_to_eat; }</p>
<p>module BacktrackingM = StateT (M) (struct type t = state end) open
BacktrackingM</p>
<p>let rec visit_cell () = (* State update actions <em>) let</em> s =
get in match s.unvisited with | [] -&gt; return None | c::remaining when
CellSet.mem c s.visited -&gt; let* () = put {s with unvisited=remaining}
in visit_cell () (* Throwaway argument because of recursion <em>) |
c::remaining -&gt; let</em> () = put {s with unvisited=remaining;
visited = CellSet.add c s.visited} in return (Some c) (* This action
returns a value *)</p>
<p>let eat_cell c = let* s = get in let* () = put {s with eaten =
c::s.eaten; visited = CellSet.add c s.visited; more_to_eat =
s.more_to_eat - 1} in return () (* Remaining state update actions just
affect the state *)</p>
<p>let keep_cell c = let* s = get in let* () = put {s with visited =
CellSet.add c s.visited; been_size = s.been_size + 1} in return ()</p>
<p>let fresh_island = let* s = get in let* () = put {s with been_size =
0; been_islands = s.been_islands + 1} in return ()</p>
<p>let find_to_eat n island_size num_islands empty_cells = let honey =
honey_cells n empty_cells in let rec find_board () = let* cell =
visit_cell () in match cell with | None -&gt; let* s = get in let* () =
guard (s.been_islands = num_islands) in return s.eaten | Some cell -&gt;
let* () = fresh_island in let* () = find_island cell in let* s = get in
let* () = guard (s.been_size = island_size) in find_board ()</p>
<pre><code>and find_island current =
  let* () = keep_cell current in
  neighbors n empty_cells current
  |&gt; foldM
       (fun () neighbor -&gt;
          let* s = get in
          whenM (not (CellSet.mem neighbor s.visited))
            (let choose_eat =
               let* () = guard (s.more_to_eat &gt; 0) in
               eat_cell neighbor
             and choose_keep =
               let* () = guard (s.been_size &lt; island_size) in
               find_island neighbor in
             choose_eat ++ choose_keep)) () in

let cells_to_eat =
  List.length honey - island_size * num_islands in
init_state honey cells_to_eat
|&gt; runT (find_board ())</code></pre>
<p>end</p>
<p>module HoneyL = HoneyIslands (ListM) let find_to_eat a b c d =
ListM.run (HoneyL.find_to_eat a b c d)</p>
<pre><code>
### 8.13 Probabilistic Programming

Using a random number generator, we can define procedures that produce various output. This is **not functional** -- mathematical functions have a deterministic result for fixed arguments.

Similarly to how we can &quot;simulate&quot; (mutable) variables with state monad and non-determinism with list monad, we can &quot;simulate&quot; random computation with a probability monad.

The probability monad class means much more than having randomized computation. We can ask questions about probabilities of results. Monad instances can make tradeoffs of efficiency vs. accuracy (exact vs. approximate probabilities).

#### The Probability Monad

The essential functions for the probability monad class are `choose` and `distrib`. Remaining functions could be defined in terms of these but are provided by each instance for efficiency.

Inside-monad operations:

- `choose : float -&gt; &#39;a monad -&gt; &#39;a monad -&gt; &#39;a monad`: `choose p a b` represents an event or distribution which is `a` with probability $p$ and is `b` with probability $1-p$.
- `pick : (&#39;a * float) list -&gt; &#39;a monad`: A result from the provided distribution over values. The argument must be a probability distribution: positive values summing to 1.
- `uniform : &#39;a list -&gt; &#39;a monad`: Uniform distribution over given values.
- `flip : float -&gt; bool monad`: Equal to `choose p (return true) (return false)`.
- `coin : bool monad`: Equal to `flip 0.5`.

Outside-monad operations:

- `prob : (&#39;a -&gt; bool) -&gt; &#39;a monad -&gt; float`: Returns the probability that the predicate holds.
- `distrib : &#39;a monad -&gt; (&#39;a * float) list`: Returns the distribution of probabilities over the resulting values.
- `access : &#39;a monad -&gt; &#39;a`: Samples a random result from the distribution -- **non-functional** behavior.

```ocaml env=ch8
module type PROBABILITY = sig
  include MONAD_OPS
  val choose : float -&gt; &#39;a monad -&gt; &#39;a monad -&gt; &#39;a monad
  val pick : (&#39;a * float) list -&gt; &#39;a monad
  val uniform : &#39;a list -&gt; &#39;a monad
  val coin : bool monad
  val flip : float -&gt; bool monad
  val prob : (&#39;a -&gt; bool) -&gt; &#39;a monad -&gt; float
  val distrib : &#39;a monad -&gt; (&#39;a * float) list
  val access : &#39;a monad -&gt; &#39;a
end</code></pre>
<p>Helper functions:</p>
<p>```ocaml skip let total dist = List.fold_left (fun a (_,b) -&gt; a +.
b) 0. dist</p>
<p>let merge dist = map_reduce (fun x -&gt; x) (+.) 0. dist (* Merge
repeating elements *)</p>
<p>let normalize dist = (* Normalize a measure into a distribution *)
let tot = total dist in if tot = 0. then dist else List.map (fun (e,w)
-&gt; e, w /. tot) dist</p>
<p>let roulette dist = (* Roulette wheel from a distribution/measure *)
let tot = total dist in let rec aux r = function | [] -&gt; assert false
| (e, w)::_ when w &lt;= r -&gt; e | (_, w)::tl -&gt; aux (r -. w) tl in
aux (Random.float tot) dist</p>
<pre><code>
#### Exact Distribution Monad

```ocaml skip
module DistribM : PROBABILITY = struct
  module M = struct           (* Exact probability distribution -- naive implementation *)
    type &#39;a t = (&#39;a * float) list
    let bind a b = merge             (* x w.p. p and then y w.p. q happens = *)
      (List.concat_map (fun (x, p) -&gt;
        List.map (fun (y, q) -&gt; (y, q *. p)) (b x)) a)  (* y results w.p. p*q *)
    let return a = [a, 1.]           (* Certainly a *)
  end
  include M
  include MonadOps (M)
  let choose p a b =
    List.map (fun (e,w) -&gt; e, p *. w) a @
      List.map (fun (e,w) -&gt; e, (1. -. p) *. w) b
  let pick dist = dist
  let uniform elems = normalize
    (List.map (fun e -&gt; e, 1.) elems)
  let coin = [true, 0.5; false, 0.5]
  let flip p = [true, p; false, 1. -. p]
  let prob p m = m
    |&gt; List.filter (fun (e,_) -&gt; p e)    (* All cases where p holds, *)
    |&gt; List.map snd |&gt; List.fold_left (+.) 0.  (* add up *)
  let distrib m = m
  let access m = roulette m
end</code></pre>
<h4 id="sampling-monad">Sampling Monad</h4>
<p><code>ocaml skip module SamplingM (S : sig val samples : int end) : PROBABILITY = struct   module M = struct                      (* Parameterized by how many samples *)     type 'a t = unit -&gt; 'a               (* used to approximate prob or distrib *)     let bind a b () = b (a ()) ()        (* Randomized computation -- each call a() *)     let return a = fun () -&gt; a           (* is an independent sample. Always a. *)   end   include M   include MonadOps (M)   let choose p a b () =     if Random.float 1. &lt;= p then a () else b ()   let pick dist = fun () -&gt; roulette dist   let uniform elems =     let n = List.length elems in     fun () -&gt; List.nth elems (Random.int n)   let coin = Random.bool   let flip p = choose p (return true) (return false)   let prob p m =     let count = ref 0 in     for i = 1 to S.samples do       if p (m ()) then incr count     done;     float_of_int !count /. float_of_int S.samples   let distrib m =     let dist = ref [] in     for i = 1 to S.samples do       dist := (m (), 1.) :: !dist done;     normalize (merge !dist)   let access m = m () end</code></p>
<h4 id="example-the-monty-hall-problem">Example: The Monty Hall
Problem</h4>
<p>In search of a new car, the player picks a door, say 1. The game host
then opens one of the other doors, say 3, to reveal a goat and offers to
let the player pick door 2 instead of door 1.</p>
<p>```ocaml skip module MontyHall (P : PROBABILITY) = struct open P type
door = A | B | C let doors = [A; B; C]</p>
<p>let monty_win switch = let* prize = uniform doors in let* chosen =
uniform doors in let* opened = uniform (list_diff doors [prize; chosen])
in let final = if switch then List.hd (list_diff doors [opened; chosen])
else chosen in return (final = prize) end</p>
<p>module MontyExact = MontyHall (DistribM) module Sampling1000 =
SamplingM (struct let samples = 1000 end) module MontySimul = MontyHall
(Sampling1000)</p>
<p>(* DistribM.distrib (MontyExact.monty_win false);; - : (bool * float)
list = [(true, 0.333…); (false, 0.666…)]</p>
<p>DistribM.distrib (MontyExact.monty_win true);; - : (bool * float)
list = [(true, 0.666…); (false, 0.333…)] *)</p>
<pre><code>
The famous result: switching doubles your chances of winning!

#### Conditional Probabilities

Wouldn&#39;t it be nice to have a monad-plus rather than just a monad? We could use `guard` for conditional probabilities!

To compute $P(A|B)$:
1. Compute what is needed for both $A$ and $B$
2. Guard $B$
3. Return $A$

For the exact distribution monad, we just need to allow intermediate distributions to be unnormalized (sum to less than 1). For the sampling monad, we use rejection sampling (though `mplus` has no straightforward correct implementation).

```ocaml skip
module type COND_PROBAB = sig
  include PROBABILITY
  include MONAD_PLUS_OPS with type &#39;a monad := &#39;a monad
end

module DistribMP : COND_PROBAB = struct
  module MP = struct
    type &#39;a t = (&#39;a * float) list      (* Measures no longer restricted to *)
    let bind a b = merge               (* probability distributions *)
      (List.concat_map (fun (x, p) -&gt;
        List.map (fun (y, q) -&gt; (y, q *. p)) (b x)) a)
    let return a = [a, 1.]
    let mzero = []                     (* Measure equal 0 everywhere is OK *)
    let mplus = List.append
  end
  include MP
  include MonadPlusOps (MP)
  let choose p a b =                   (* It isn&#39;t a w.p. p &amp; b w.p. (1-p) since a and b *)
    List.map (fun (e,w) -&gt; e, p *. w) a @  (* are not normalized! *)
      List.map (fun (e,w) -&gt; e, (1. -. p) *. w) b
  let pick dist = dist
  let uniform elems = normalize
    (List.map (fun e -&gt; e, 1.) elems)
  let coin = [true, 0.5; false, 0.5]
  let flip p = [true, p; false, 1. -. p]
  let prob p m = normalize m           (* Final normalization step *)
    |&gt; List.filter (fun (e,_) -&gt; p e)
    |&gt; List.map snd |&gt; List.fold_left (+.) 0.
  let distrib m = normalize m
  let access m = roulette m
end

module SamplingMP (S : sig val samples : int end) : COND_PROBAB = struct
  exception Rejected                   (* For rejecting current sample *)
  module MP = struct                   (* Monad operations are exactly as for SamplingM *)
    type &#39;a t = unit -&gt; &#39;a
    let bind a b () = b (a ()) ()
    let return a = fun () -&gt; a
    let mzero = fun () -&gt; raise Rejected  (* but now we can fail *)
    let mplus a b = fun () -&gt;
      failwith &quot;SamplingMP.mplus not implemented&quot;
  end
  include MP
  include MonadPlusOps (MP)
  let choose p a b () =                (* Inside-monad operations don&#39;t change *)
    if Random.float 1. &lt;= p then a () else b ()
  let pick dist = fun () -&gt; roulette dist
  let uniform elems =
    let n = List.length elems in
    fun () -&gt; List.nth elems (Random.int n)
  let coin = Random.bool
  let flip p = choose p (return true) (return false)
  let prob p m =                       (* Getting out of monad: handle rejected samples *)
    let count = ref 0 and tot = ref 0 in
    while !tot &lt; S.samples do          (* Count up to the required *)
      try                              (* number of samples *)
        if p (m ()) then incr count;   (* m() can fail *)
        incr tot                       (* But if we got here it hasn&#39;t *)
      with Rejected -&gt; ()              (* Rejected, keep sampling *)
    done;
    float_of_int !count /. float_of_int S.samples
  let distrib m =
    let dist = ref [] and tot = ref 0 in
    while !tot &lt; S.samples do
      try
        dist := (m (), 1.) :: !dist;
        incr tot
      with Rejected -&gt; ()
    done;
    normalize (merge !dist)
  let rec access m =
    try m () with Rejected -&gt; access m
end</code></pre>
<h4 id="burglary-example-encoding-a-bayes-net">Burglary Example:
Encoding a Bayes Net</h4>
<p>Consider a problem with this dependency structure:</p>
<ul>
<li>An alarm can be due to either a burglary or an earthquake</li>
<li>You are on vacation and have asked neighbors John and Mary to call
if the alarm rings</li>
<li>Mary only calls when she is really sure about the alarm, but John
has better hearing</li>
<li>Earthquakes are twice as probable as burglaries</li>
<li>The alarm has about 30% chance of going off during an
earthquake</li>
<li>You can check on the radio if there was an earthquake, but you might
miss the news</li>
</ul>
<p>Probability tables:</p>
<ul>
<li><span class="math inline">P(\text{Burglary}) = 0.001</span></li>
<li><span class="math inline">P(\text{Earthquake}) = 0.002</span></li>
<li><span class="math inline">P(\text{Alarm}|\text{B}, \text{E})</span>
varies (0.001 for FF, 0.29 for FT, 0.94 for TF, 0.95 for TT)</li>
<li><span class="math inline">P(\text{John calls}|\text{Alarm})</span>
is 0.9 if alarm, 0.05 otherwise</li>
<li><span class="math inline">P(\text{Mary calls}|\text{Alarm})</span>
is 0.7 if alarm, 0.01 otherwise</li>
</ul>
<p>```ocaml skip module Burglary (P : COND_PROBAB) = struct open P type
what_happened = | Safe | Burgl | Earthq | Burgl_n_earthq</p>
<p>let check ~john_called ~mary_called ~radio = let* earthquake = flip
0.002 in let* () = guard (radio = None || radio = Some earthquake) in
let* burglary = flip 0.001 in let alarm_p = match burglary, earthquake
with | false, false -&gt; 0.001 | false, true -&gt; 0.29 | true, false
-&gt; 0.94 | true, true -&gt; 0.95 in let* alarm = flip alarm_p in let
john_p = if alarm then 0.9 else 0.05 in let* john_calls = flip john_p in
let* () = guard (john_calls = john_called) in let mary_p = if alarm then
0.7 else 0.01 in let* mary_calls = flip mary_p in let* () = guard
(mary_calls = mary_called) in match burglary, earthquake with | false,
false -&gt; return Safe | true, false -&gt; return Burgl | false, true
-&gt; return Earthq | true, true -&gt; return Burgl_n_earthq end</p>
<p>module BurglaryExact = Burglary (DistribMP) module Sampling2000 =
SamplingMP (struct let samples = 2000 end) module BurglarySimul =
Burglary (Sampling2000)</p>
<p>(* DistribMP.distrib (BurglaryExact.check ~john_called:true
~mary_called:true ~radio:None);; - : (BurglaryExact.what_happened *
float) list = [(Burgl_n_earthq, 0.000574…); (Earthq, 0.175…); (Burgl,
0.283…); (Safe, 0.540…)] *)</p>
<pre><code>
### 8.14 Lightweight Cooperative Threads

The `bind` operation is inherently sequential: `bind a (fun x -&gt; b)` computes `a`, and resumes computing `b` only once the result `x` is known.

For concurrency, we need to &quot;suppress&quot; this sequentiality. We introduce:
</code></pre>
<p>parallel : ’a monad -&gt; ’b monad -&gt; (’a -&gt; ’b -&gt; ’c monad)
-&gt; ’c monad</p>
<pre><code>
where `parallel a b (fun x y -&gt; c)` does not wait for `a` to be computed before it can start computing `b`.

If the monad starts computing right away (as in the Lwt library), `parallel ea eb c` is equivalent to:
</code></pre>
<p>let a = ea in let b = eb in let* x = a in let* y = b in c x y</p>
<pre><code>
#### Fine-Grained vs. Coarse-Grained Concurrency

Under **fine-grained** concurrency, every `bind` is suspended and computation moves to other threads. It comes back to complete the `bind` before running threads created since the `bind` was suspended.

Under **coarse-grained** concurrency, computation is only suspended when requested via a `suspend` (often called `yield`) operation. Library operations that need to wait for an event or completion of I/O should call `suspend` internally.

#### Thread Monad Signatures

```ocaml env=ch8
module type THREADS = sig
  include MONAD
  val parallel :
    &#39;a t -&gt; &#39;b t -&gt; (&#39;a -&gt; &#39;b -&gt; &#39;c t) -&gt; &#39;c t
end

module type THREAD_OPS = sig
  include MONAD_OPS
  include THREADS with type &#39;a t := &#39;a monad
  val parallel_map :
    &#39;a list -&gt; (&#39;a -&gt; &#39;b monad) -&gt; &#39;b list monad
  val (&gt;||=) :
    &#39;a monad -&gt; &#39;b monad -&gt; (&#39;a -&gt; &#39;b -&gt; &#39;c monad) -&gt; &#39;c monad
  val (&gt;||) :
    &#39;a monad -&gt; &#39;b monad -&gt; (unit -&gt; &#39;c monad) -&gt; &#39;c monad
end

module type THREADSYS = sig
  include THREADS
  val access : &#39;a t -&gt; &#39;a
  val kill_threads : unit -&gt; unit
end

module ThreadOps (M : THREADS) = struct
  open M
  include MonadOps (M)
  let parallel_map l f =
    List.fold_right (fun a bs -&gt;
      parallel (f a) bs
        (fun a bs -&gt; return (a::bs))) l (return [])
  let (&gt;||=) = parallel
  let (&gt;||) a b c = parallel a b (fun _ _ -&gt; c ())
end

module Threads (M : THREADSYS) : sig
  include THREAD_OPS
  val access : &#39;a monad -&gt; &#39;a
  val kill_threads : unit -&gt; unit
end = struct
  include M
  include ThreadOps(M)
end</code></pre>
<h4 id="cooperative-thread-implementation">Cooperative Thread
Implementation</h4>
<p>```ocaml skip module Cooperative = Threads(struct type ’a state = |
Return of ’a (* The thread has returned <em>) | Sleep of (’a -&gt; unit)
list (</em> When thread returns, wake up waiters <em>) | Link of ’a t
(</em> A link to the actual thread <em>) and ’a t = {mutable state : ’a
state} (</em> State of the thread can change <em>) (</em> – it can
return, or more waiters can be added <em>) let rec find t = (</em>
Union-find style link chasing *) match t.state with | Link t -&gt; find
t | _ -&gt; t</p>
<p>let jobs = Queue.create () (* Work queue – will store unit -&gt; unit
procedures *)</p>
<p>let wakeup m a = (* Thread m has actually finished – <em>) let m =
find m in (</em> updating its state <em>) match m.state with | Return _
-&gt; assert false | Sleep waiters -&gt; m.state &lt;- Return a; (</em>
Set the state, and only then <em>) List.iter ((|&gt;) a) waiters (</em>
wake up the waiters *) | Link _ -&gt; assert false</p>
<p>let return a = {state = Return a}</p>
<p>let connect t t’ = (* t was a placeholder for t’ <em>) let t’ = find
t’ in match t’.state with | Sleep waiters’ -&gt; let t = find t in
(match t.state with | Sleep waiters -&gt; (</em> If both sleep, collect
their waiters <em>) t.state &lt;- Sleep (waiters’ @ waiters); t’.state
&lt;- Link t (</em> and link one to the other <em>) | _ -&gt; assert
false) | Return x -&gt; wakeup t x (</em> If t’ returned, wake up the
placeholder *) | Link _ -&gt; assert false</p>
<p>let rec bind a b = let a = find a in let m = {state = Sleep []} in (*
The resulting monad <em>) (match a.state with | Return x -&gt; (</em> If
a returned, we suspend further work <em>) let job () = connect m (b x)
in (</em> (In exercise 11, this should <em>) Queue.push job jobs (</em>
only happen after suspend) <em>) | Sleep waiters -&gt; (</em> If a
sleeps, we wait for it to return *) let job x = connect m (b x) in
a.state &lt;- Sleep (job::waiters) | Link _ -&gt; assert false); m</p>
<p>let parallel a b c = (* Since in our implementation <em>) bind a (fun
x -&gt; (</em> the threads run as soon as they are created, <em>) bind b
(fun y -&gt; (</em> parallel is redundant *) c x y))</p>
<p>let rec access m = (* Accessing not only gets the result of m, <em>)
let m = find m in (</em> but spins the thread loop till m terminates
<em>) match m.state with | Return x -&gt; x (</em> No further work <em>)
| Sleep _ -&gt; (try Queue.pop jobs () (</em> Perform suspended work *)
with Queue.Empty -&gt; failwith “access: result not available”); access
m | Link _ -&gt; assert false</p>
<p>let kill_threads () = Queue.clear jobs (* Remove pending work *)
end)</p>
<pre><code>
#### Testing the Thread Implementation

```ocaml skip
module TTest (T : THREAD_OPS) = struct
  open T
  let rec loop s n =
    let* () = return (Printf.printf &quot;-- %s(%d)\n%!&quot; s n) in
    if n &gt; 0 then loop s (n-1)         (* We cannot use whenM because the thread *)
    else return ()                     (* would be created regardless of condition *)
end

module TT = TTest (Cooperative)

let test =
  Cooperative.kill_threads ();         (* Clean-up after previous tests *)
  let thread1 = TT.loop &quot;A&quot; 5 in
  let thread2 = TT.loop &quot;B&quot; 4 in
  Cooperative.access thread1;          (* We ensure threads finish computing *)
  Cooperative.access thread2           (* before we proceed *)

(* Output:
   -- A(5)
   -- B(4)
   -- A(4)
   -- B(3)
   -- A(3)
   -- B(2)
   -- A(2)
   -- B(1)
   -- A(1)
   -- B(0)
   -- A(0)
   val test : unit = () *)</code></pre>
<p>The output shows that the threads interleave their execution, with
each <code>bind</code> causing a context switch.</p>
<h3 id="exercises-6">8.15 Exercises</h3>
<p><strong>Exercise 1.</strong> (Puzzle via Oleg Kiselyov)</p>
<p>“U2” has a concert that starts in 17 minutes and they must all cross
a bridge to get there. All four men begin on the same side of the
bridge. It is night. There is one flashlight. A maximum of two people
can cross at one time. Any party who crosses, either 1 or 2 people, must
have the flashlight with them. The flashlight must be walked back and
forth, it cannot be thrown, etc. Each band member walks at a different
speed. A pair must walk together at the rate of the slower man’s
pace:</p>
<ul>
<li>Bono: 1 minute to cross</li>
<li>Edge: 2 minutes to cross</li>
<li>Adam: 5 minutes to cross</li>
<li>Larry: 10 minutes to cross</li>
</ul>
<p>For example: if Bono and Larry walk across first, 10 minutes have
elapsed when they get to the other side of the bridge. If Larry then
returns with the flashlight, a total of 20 minutes have passed and you
have failed the mission.</p>
<p>Find all answers to the puzzle using a list comprehension. The
comprehension will be a bit long but recursion is not needed.</p>
<p><strong>Exercise 2.</strong> Assume <code>concat_map</code> as
defined in lecture 6 and the binding operators defined above. What will
the following expressions return? Why?</p>
<ol type="1">
<li><code>let* _ = return 5 in return 7</code></li>
<li><code>let guard p = if p then [()] else [] in let* () = guard false in return 7</code></li>
<li><code>let* _ = return 5 in let* () = guard false in return 7</code></li>
</ol>
<p><strong>Exercise 3.</strong> Define <code>bind</code> in terms of
<code>lift</code> and <code>join</code>.</p>
<p><strong>Exercise 4.</strong> Define a monad-plus implementation based
on binary trees, with constant-time <code>mzero</code> and
<code>mplus</code>. Starter code:</p>
<p>```ocaml skip type ’a tree = Empty | Leaf of ’a | T of ’a tree * ’a
tree</p>
<p>module TreeM = MonadPlus (struct type ’a t = ’a tree let bind a b =
(* TODO <em>) let return a = (</em> TODO <em>) let mzero = (</em> TODO
<em>) let mplus a b = (</em> TODO *) end)</p>
<pre><code>
**Exercise 5.** Show the monad-plus laws for one of:
1. `TreeM` from your solution of exercise 4
2. `ListM` from lecture

**Exercise 6.** Why is the following monad-plus not lazy enough?

```ocaml skip
let rec badappend l1 l2 =
  match l1 with lazy LazNil -&gt; l2
  | lazy (LazCons (hd, tl)) -&gt;
      lazy (LazCons (hd, badappend tl l2))

let rec badconcatmap f = function
  | lazy LazNil -&gt; lazy LazNil
  | lazy (LazCons (a, l)) -&gt;
      badappend (f a) (badconcatmap f l)

module BadyListM = MonadPlus (struct
  type &#39;a t = &#39;a lazylist
  let bind a b = badconcatmap b a
  let return a = lazy (LazCons (a, lazy LazNil))
  let mzero = lazy LazNil
  let mplus = badappend
end)</code></pre>
<p><strong>Exercise 7.</strong> Convert a “rectangular” list of lists of
strings, representing a matrix with inner lists being rows, into a
string, where elements are column-aligned. (Exercise not related to
monads.)</p>
<p><strong>Exercise 8.</strong> Recall the enriched monad signature with
<code>('s, 'a) t</code> type. Design the signatures for the exception
monad operations to provide more flexibility than our exception monad.
Does the implementation need to change?</p>
<p><strong>Exercise 9.</strong> Implement the following constructs for
<em>all</em> monads:</p>
<ol type="1">
<li><code>for...to...</code></li>
<li><code>for...downto...</code></li>
<li><code>while...do...</code></li>
<li><code>do...while...</code></li>
<li><code>repeat...until...</code></li>
</ol>
<p>Explain how, when your implementation is instantiated with the StateM
monad, we get the solution to exercise 2 from lecture 4.</p>
<p><strong>Exercise 10.</strong> A canonical example of a probabilistic
model is that of a lawn whose grass may be wet because it rained,
because the sprinkler was on, or for some other reason. The probability
tables are:</p>
<p><span class="math display">
\begin{aligned}
P(\text{cloudy}) &amp;= 0.5 \\
P(\text{rain}|\text{cloudy}) &amp;= 0.8 \\
P(\text{rain}|\neg\text{cloudy}) &amp;= 0.2 \\
P(\text{sprinkler}|\text{cloudy}) &amp;= 0.1 \\
P(\text{sprinkler}|\neg\text{cloudy}) &amp;= 0.5 \\
P(\text{wet\_roof}|\neg\text{rain}) &amp;= 0 \\
P(\text{wet\_roof}|\text{rain}) &amp;= 0.7 \\
P(\text{wet\_grass}|\text{rain} \land \neg\text{sprinkler}) &amp;= 0.9
\\
P(\text{wet\_grass}|\text{sprinkler} \land \neg\text{rain}) &amp;= 0.9
\end{aligned}
</span></p>
<p>We observe whether the grass is wet and whether the roof is wet. What
is the probability that it rained?</p>
<p><strong>Exercise 11.</strong> Implement the coarse-grained
concurrency model:</p>
<ul>
<li>Modify <code>bind</code> to compute the resulting monad straight
away if the input monad has returned.</li>
<li>Introduce <code>suspend</code> to do what in the fine-grained model
was the effect of <code>bind (return a) b</code>, i.e., suspend the work
although it could already be started.</li>
<li>One possibility is to introduce <code>suspend</code> of type
<code>unit monad</code>, introduce a “dummy” monadic value
<code>Suspend</code> (besides <code>Return</code> and
<code>Sleep</code>), and define <code>bind suspend b</code> to do what
<code>bind (return ()) b</code> would formerly do.</li>
</ul>
<h2 id="chapter-9-algebraic-effects">Chapter 9: Algebraic Effects</h2>
<p>This chapter replaces the chapter <em>Compilation, Runtime,
Optimization, and Parsing</em> from the old lectures.</p>
<p>TODO</p>
<h2 id="chapter-10-functional-reactive-programming">Chapter 10:
Functional Reactive Programming</h2>
<p>This chapter explores techniques for dealing with change and
interaction in functional programming. We begin with zippers, a data
structure for navigating and modifying positions within larger
structures, then progress to adaptive (incremental) programming and
Functional Reactive Programming (FRP). We conclude with practical
examples including graphical user interfaces.</p>
<p><strong>Recommended Reading:</strong></p>
<ul>
<li><em>“Zipper”</em> in Haskell Wikibook and <em>“The Zipper”</em> by
Gerard Huet</li>
<li><em>“How <code>froc</code> works”</em> by Jacob Donham</li>
<li><em>“The Haskell School of Expression”</em> by Paul Hudak</li>
<li><em>“Deprecating the Observer Pattern with
<code>Scala.React</code>”</em> by Ingo Maier, Martin Odersky</li>
</ul>
<h3 id="zippers">10.1 Zippers</h3>
<p>Often we need to keep track of a position within a data structure:
easily access and modify it at that location, and easily move the
location around. Recall from earlier chapters how we defined <em>context
types</em> for datatypes – types that represent a data structure with
one of its elements missing.</p>
<p>Consider binary trees:</p>
<p><code>ocaml skip type btree = Tip | Node of int * btree * btree</code></p>
<p>Using our algebraic datatype calculus, where <span
class="math inline">T</span> represents the tree type:</p>
<p><span class="math display">
\begin{matrix}
T &amp; = &amp; 1 + xT^2 \\
\frac{\partial T}{\partial x} &amp; = &amp; 0 + T^2 + 2xT\frac{\partial
T}{\partial x} = TT + 2xT\frac{\partial T}{\partial x}
\end{matrix}
</span></p>
<p>This derivative gives us the context type:</p>
<p><code>ocaml skip type btree_dir = LeftBranch | RightBranch type btree_deriv =   | Here of btree * btree   | Below of btree_dir * int * btree * btree_deriv</code></p>
<p>The key insight is that <strong>Location = context +
subtree</strong>! However, there is a problem with the representation
above: we cannot easily move the location if <code>Here</code> is at the
bottom. The part closest to the location should be on top.</p>
<h4 id="revisiting-the-equations">Revisiting the Equations</h4>
<p>Let us revisit the equations for trees and lists:</p>
<p><span class="math display">
\begin{matrix}
T &amp; = &amp; 1 + xT^2 \\
\frac{\partial T}{\partial x} &amp; = &amp; 0 + T^2 + 2xT\frac{\partial
T}{\partial x} \\
\frac{\partial T}{\partial x} &amp; = &amp; \frac{T^2}{1 - 2xT} \\
L(y) &amp; = &amp; 1 + yL(y) \\
L(y) &amp; = &amp; \frac{1}{1 - y} \\
\frac{\partial T}{\partial x} &amp; = &amp; T^2 L(2xT)
\end{matrix}
</span></p>
<p>This tells us that the context can be stored as a list with the root
as the last node. It does not matter whether we use built-in lists or a
type with <code>Above</code> and <code>Root</code> variants.</p>
<p>Contexts of subtrees are more useful than contexts of single
elements:</p>
<p>```ocaml skip type ’a tree = Tip | Node of ’a tree * ’a * ’a tree
type tree_dir = Left_br | Right_br type ’a context = (tree_dir * ’a * ’a
tree) list type ’a location = {sub: ’a tree; ctx: ’a context}</p>
<p>let access {sub} = sub let change {ctx} sub = {sub; ctx} let modify f
{sub; ctx} = {sub = f sub; ctx}</p>
<pre><code>
We can imagine a location as a rooted tree which is hanging pinned at one of its nodes. For visualizations, see http://en.wikibooks.org/wiki/Haskell/Zippers.

#### Moving Around

Navigation functions allow us to traverse the structure:

```ocaml skip
let ascend loc =
  match loc.ctx with
  | [] -&gt; loc  (* Or raise exception *)
  | (Left_br, n, l) :: up_ctx -&gt;
    {sub = Node (l, n, loc.sub); ctx = up_ctx}
  | (Right_br, n, r) :: up_ctx -&gt;
    {sub = Node (loc.sub, n, r); ctx = up_ctx}

let desc_left loc =
  match loc.sub with
  | Tip -&gt; loc  (* Or raise exception *)
  | Node (l, n, r) -&gt;
    {sub = l; ctx = (Right_br, n, r) :: loc.ctx}

let desc_right loc =
  match loc.sub with
  | Tip -&gt; loc  (* Or raise exception *)
  | Node (l, n, r) -&gt;
    {sub = r; ctx = (Left_br, n, l) :: loc.ctx}</code></pre>
<h4 id="trees-with-arbitrary-branching">Trees with Arbitrary
Branching</h4>
<p>Following <em>The Zipper</em> by Gerard Huet, let us look at a tree
with an arbitrary number of branches, representing a document
structure:</p>
<p><code>ocaml skip type doc = Text of string | Line | Group of doc list type context = (doc list * doc list) list type location = {sub: doc; ctx: context}</code></p>
<p>The navigation functions for this more complex structure:</p>
<p>```ocaml skip let go_up loc = match loc.ctx with | [] -&gt;
invalid_arg “go_up: at top” | (left, right) :: up_ctx -&gt; (* Previous
subdocument and its siblings *) {sub = Group (List.rev left @ loc.sub ::
right); ctx = up_ctx}</p>
<p>let go_left loc = match loc.ctx with | [] -&gt; invalid_arg “go_left:
at top” | (l :: left, right) :: up_ctx -&gt; (* Left sibling of previous
subdocument *) {sub = l; ctx = (left, loc.sub :: right) :: up_ctx} |
([], <em>) :: </em> -&gt; invalid_arg “go_left: at first”</p>
<p>let go_right loc = match loc.ctx with | [] -&gt; invalid_arg
“go_right: at top” | (left, r :: right) :: up_ctx -&gt; {sub = r; ctx =
(loc.sub :: left, right) :: up_ctx} | (<em>, []) :: </em> -&gt;
invalid_arg “go_right: at last”</p>
<p>let go_down loc = (* Go to the first (i.e. leftmost) subdocument *)
match loc.sub with | Text _ -&gt; invalid_arg “go_down: at text” | Line
-&gt; invalid_arg “go_down: at line” | Group [] -&gt; invalid_arg
“go_down: at empty” | Group (doc :: docs) -&gt; {sub = doc; ctx = ([],
docs) :: loc.ctx}</p>
<pre><code>
### 10.2 Example: Context Rewriting

Imagine a friend working on string theory asks us for help simplifying equations. The task is to pull out particular subexpressions as far to the left as possible, while changing the whole expression as little as possible.

We can illustrate our algorithm using mathematical notation. Let:
- $x$ be the thing we pull out
- $C[e]$ and $D[e]$ be big expressions with subexpression $e$
- operator $\circ$ stand for one of: $*, +$

The rewriting rules are:

$$
\begin{matrix}
D[(C[x] \circ e_1) \circ e_2] &amp; \Rightarrow &amp; D[C[x] \circ (e_1 \circ e_2)] \\
D[e_2 \circ (C[x] \circ e_1)] &amp; \Rightarrow &amp; D[C[x] \circ (e_1 \circ e_2)] \\
D[(C[x] + e_1) e_2] &amp; \Rightarrow &amp; D[C[x] e_2 + e_1 e_2] \\
D[e_2 (C[x] + e_1)] &amp; \Rightarrow &amp; D[C[x] e_2 + e_1 e_2] \\
D[e \circ C[x]] &amp; \Rightarrow &amp; D[C[x] \circ e]
\end{matrix}
$$

First, the groundwork:

```ocaml skip
type op = Add | Mul
type expr = Val of int | Var of string | App of expr * op * expr
type expr_dir = Left_arg | Right_arg
type context = (expr_dir * op * expr) list
type location = {sub: expr; ctx: context}</code></pre>
<p>To locate the subexpression described by predicate
<code>p</code>:</p>
<p>```ocaml skip let rec find_aux p e = if p e then Some (e, []) else
match e with | Val _ | Var _ -&gt; None | App (l, op, r) -&gt; match
find_aux p l with | Some (sub, up_ctx) -&gt; Some (sub, (Right_arg, op,
r) :: up_ctx) | None -&gt; match find_aux p r with | Some (sub, up_ctx)
-&gt; Some (sub, (Left_arg, op, l) :: up_ctx) | None -&gt; None</p>
<p>let find p e = match find_aux p e with | None -&gt; None | Some (sub,
ctx) -&gt; Some {sub; ctx = List.rev ctx}</p>
<pre><code>
Now we can implement the pull-out transformation:

```ocaml skip
let rec pull_out loc =
  match loc.ctx with
  | [] -&gt; loc  (* Done *)
  | (Left_arg, op, l) :: up_ctx -&gt;
    (* D[e . C[x]] =&gt; D[C[x] . e] *)
    pull_out {loc with ctx = (Right_arg, op, l) :: up_ctx}
  | (Right_arg, op1, e1) :: (_, op2, e2) :: up_ctx
      when op1 = op2 -&gt;
    (* D[(C[x] . e1) . e2] / D[e2 . (C[x] . e1)] =&gt; D[C[x] . (e1 . e2)] *)
    pull_out {loc with ctx = (Right_arg, op1, App(e1, op1, e2)) :: up_ctx}
  | (Right_arg, Add, e1) :: (_, Mul, e2) :: up_ctx -&gt;
    (* D[(C[x] + e1) * e2] / D[e2 * (C[x] + e1)] =&gt; D[C[x] * e2 + e1 * e2] *)
    pull_out {loc with ctx =
        (Right_arg, Mul, e2) ::
          (Right_arg, Add, App(e1, Mul, e2)) :: up_ctx}
  | (Right_arg, op, r) :: up_ctx -&gt;  (* Move up the context *)
    pull_out {sub = App(loc.sub, op, r); ctx = up_ctx}</code></pre>
<p>Since operators are commutative, we ignore the direction for the
second piece of context above.</p>
<p>Testing the implementation:</p>
<p><code>ocaml skip let (+) a b = App (a, Add, b) let ( * ) a b = App (a, Mul, b) let (!) a = Val a let x = Var "x" let y = Var "y" let ex = !5 + y * (!7 + x) * (!3 + y) let loc = find (fun e -&gt; e = x) ex let sol =   match loc with   | None -&gt; raise Not_found   | Some loc -&gt; pull_out loc (* Result: "(((x*y)*(3+y))+(((7*y)*(3+y))+5))" *)</code></p>
<p>For best results, we can iterate the <code>pull_out</code> function
until a fixpoint is reached.</p>
<h3 id="adaptive-programming-incremental-computing">10.3 Adaptive
Programming (Incremental Computing)</h3>
<p>While zippers are useful, they are somewhat unnatural for
general-purpose programming. Once we change the data structure, it is
difficult to propagate the changes – we would need to rewrite all
algorithms to work on context changes.</p>
<p>In <em>Adaptive Programming</em>, also known as <em>incremental
computation</em> or <em>self-adjusting computation</em>, we write
programs in a straightforward functional manner, but can later modify
any data causing only the minimal amount of work required to update
results.</p>
<p>The functional description of computation is within a monad. We can
change monadic values – for example, parts of input – from outside and
propagate the changes. In the <em>Froc</em> library, the monadic
<em>changeables</em> are <code>'a Froc_sa.t</code>, and the ability to
modify them is exposed by type <code>'a Froc_sa.u</code> – the
<em>writeables</em>.</p>
<h4 id="dependency-graphs">Dependency Graphs</h4>
<p>The monadic value <code>'a changeable</code> will be the
<em>dependency graph</em> of the computation of the represented value
<code>'a</code>. Consider the computation:</p>
<pre><code>let u = v / w + x * y + z</code></pre>
<p>The dependency graph shows how the result depends on the inputs. When
we modify inputs <code>v</code> and <code>z</code> simultaneously, we
need to update intermediate nodes in the correct order. For example, we
need to update <code>n2</code> before <code>u</code>.</p>
<p>We use the order of computation (represented as gray numbers in the
dependency visualization) for the order of updates. Similarly to
<code>parallel</code> in the concurrency monad, we provide
<code>bind2</code>, <code>bind3</code>, etc., and corresponding
<code>lift2</code>, <code>lift3</code>, etc., to introduce nodes with
several children:</p>
<pre><code>let n0 = bind2 v w (fun v w -&gt; return (v / w))
let n1 = bind2 x y (fun x y -&gt; return (x * y))
let n2 = bind2 n0 n1 (fun n0 n1 -&gt; return (n0 + n1))
let u = bind2 n2 z (fun n2 z -&gt; return (n2 + z))</code></pre>
<p>Do-notation is not necessary to have readable expressions:</p>
<pre><code>let (/) = lift2 (/)
let ( * ) = lift2 ( * )
let (+) = lift2 (+)
let u = v / w + x * y + z</code></pre>
<p>As in other monads, we can decrease overhead by using bigger
chunks:</p>
<pre><code>let n0 = blift2 v w (fun v w -&gt; v / w)
let n2 = blift3 n0 x y (fun n0 x y -&gt; n0 + x * y)
let u = blift2 n2 z (fun n2 z -&gt; n2 + z)</code></pre>
<h4 id="handling-conditional-dependencies">Handling Conditional
Dependencies</h4>
<p>We have a problem if we recompute all nodes simply by order of
computation:</p>
<pre><code>let b = x &gt;&gt;= fun x -&gt; return (x = 0)
let n0 = x &gt;&gt;= fun x -&gt; return (100 / x)
let y = bind2 b n0 (fun b n0 -&gt; if b then return 0 else n0)</code></pre>
<p>Rather than a single “time” stamp, we store intervals: begin and end
of computation. When updating the <code>y</code> node, we first detach
nodes in the range 4-9 from the graph. Computing the expression will
re-attach the nodes as needed.</p>
<p>When the value of <code>b</code> does not change, we skip updating
<code>y</code> and proceed with updating <code>n0</code>. The value of
<code>y</code> is a link to the value of <code>n0</code> so it will
change anyway.</p>
<p>We need memoization to re-attach the same nodes in case they do not
need updating. Are they up-to-date? Run updating past the node’s
timestamp range.</p>
<h4 id="example-using-froc">Example Using Froc</h4>
<p>The <code>Froc_sa</code> (for <em>self-adjusting</em>) module exports
the monadic type <code>t</code> for changeable computation, and a handle
type <code>u</code> for updating the computation:</p>
<p>```ocaml skip open Froc_sa</p>
<p>type tree = (* Binary tree with nodes storing their screen location
<em>) | Leaf of int </em> int (* We will grow the tree <em>) | Node of
int </em> int * tree t * tree t (* by modifying subtrees *)</p>
<pre><code>
Displaying the tree is a changeable effect. Whenever the tree changes, displaying will be updated. Only new nodes will be drawn after an update:

```ocaml skip
let rec display px py t =
  match t with
  | Leaf (x, y) -&gt;
    return
      (Graphics.draw_poly_line [|px, py; x, y|];  (* We return *)
       Graphics.draw_circle x y 3)  (* a throwaway value *)
  | Node (x, y, l, r) -&gt;
    return (Graphics.draw_poly_line [|px, py; x, y|])
    &gt;&gt;= fun _ -&gt; l &gt;&gt;= display x y
    &gt;&gt;= fun _ -&gt; r &gt;&gt;= display x y</code></pre>
<p>Growing the tree:</p>
<p><code>ocaml skip let grow_at (x, depth, upd) =   let x_l = x - f2i (width *. (2.0 ** (~-. (i2f (depth + 1))))) in   let l, upd_l = changeable (Leaf (x_l, (depth + 1) * 20)) in   let x_r = x + f2i (width *. (2.0 ** (~-. (i2f (depth + 1))))) in   let r, upd_r = changeable (Leaf (x_r, (depth + 1) * 20)) in   write upd (Node (x, depth * 20, l, r));  (* Update the old leaf *)   propagate ();  (* and keep handles to make future updates *)   [x_l, depth + 1, upd_l; x_r, depth + 1, upd_r]</code></p>
<p>The main loop:</p>
<p>```ocaml skip let rec loop t subts steps = if steps &lt;= 0 then ()
else loop t (concat_map grow_at subts) (steps - 1)</p>
<p>let incremental steps () = Graphics.open_graph ” 1024x600”; let t, u
= changeable (Leaf (512, 20)) in let d = t &gt;&gt;= display (f2i (width
/. 2.)) 0 in (* Display once <em>) loop t [512, 1, u] steps; (</em> new
nodes will be drawn automatically *) Graphics.close_graph ()</p>
<pre><code>
Unfortunately, the overhead of incremental computation is quite large. Comparing byte code execution times:

| depth | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 |
|-------|-----|-----|-----|-----|-----|-----|-----|------|------|
| incremental | 0.66s | 1s | 2.2s | 4.4s | 9.3s | 21s | 50s | 140s | 255s |
| rebuilding | 0.5s | 0.63s | 1.3s | 3s | 5.3s | 13s | 39s | 190s | -- |

### 10.4 Functional Reactive Programming

FRP is an attempt to declaratively deal with time. *Behaviors* are functions of time -- a behavior has a specific value in each instant. *Events* are sets of (time, value) pairs, organized into streams of actions.

Two problems arise in FRP:

1. Behaviors and events are well-defined when they do not depend on future
2. Efficiency: minimize overhead

FRP is *synchronous*: it is possible to set up for events to happen at the same time. It is also *continuous*: behaviors can have details at arbitrary time resolution. Although the results are *sampled*, there is no fixed (minimal) time step for specifying behavior. (Note: &quot;Asynchrony&quot; refers to various ideas, so always ask what people mean when they use the term.)

#### Idealized Definitions

Ideally we would define:

```ocaml skip
type time = float
type &#39;a behavior = time -&gt; &#39;a  (* Arbitrary function *)
type &#39;a event = (&#39;a, time) stream  (* Increasing time instants *)</code></pre>
<p>Forcing a lazy list (stream) of events would wait until an event
arrives. But behaviors need to react to external events:</p>
<p>```ocaml skip type user_action = | Key of char * bool | Button of int
* int * bool * bool | MouseMove of int * int | Resize of int * int</p>
<p>type ’a behavior = user_action event -&gt; time -&gt; ’a</p>
<pre><code>
Scanning through an event list since the beginning of time until current time, each time we evaluate a behavior, is very wasteful with respect to time and space. Producing a stream of behaviors for the stream of time allows us to forget about events already in the past:

```ocaml skip
type &#39;a behavior =
  user_action event -&gt; time stream -&gt; &#39;a stream</code></pre>
<p>The next optimization is to pair user actions with sampling
times:</p>
<p><code>ocaml skip type 'a behavior =   (user_action option * time) stream -&gt; 'a stream</code></p>
<p>The <code>None</code> action corresponds to sampling time when
nothing happens.</p>
<p>Turning behaviors and events from functions of time into input-output
streams is similar to optimizing intersection of ordered lists from
<span class="math inline">O(mn)</span> to <span class="math inline">O(m
+ n)</span> time.</p>
<p>Now we can in turn define events in terms of behaviors:</p>
<p><code>ocaml skip type 'a event = 'a option behavior</code></p>
<p>although it betrays the discrete character of events (happening at
points in time rather than varying over intervals of time).</p>
<p>We have gotten very close to <em>stream processing</em> as discussed
in Chapter 7. Recall the incremental pretty-printing example that can
“react” to more input. Stream combinators, <em>fork</em> from the
exercises for Chapter 7, and a corresponding <em>merge</em>, turn stream
processing into <em>synchronous discrete reactive programming</em>.</p>
<h4 id="behaviors-as-monads">Behaviors as Monads</h4>
<p>Behaviors are monadic (but see the next point) – in the original
specification:</p>
<p>```ocaml skip type ’a behavior = time -&gt; ’a</p>
<p>val return : ’a -&gt; ’a behavior let return a = fun _ -&gt; a</p>
<p>val bind : ’a behavior -&gt; (’a -&gt; ’b behavior) -&gt; ’b behavior
let bind a f = fun t -&gt; f (a t) t</p>
<pre><code>
As we have seen with changeables, we mostly use lifting. In the Haskell world we would call behaviors *applicative*. To build our own lifters in any monad:
</code></pre>
<p>val ap : (’a -&gt; ’b) monad -&gt; ’a monad -&gt; ’b monad let ap fm
am = let* f = fm in let* a = am in return (f a)</p>
<pre><code>
Note that for changeables, the naive implementation above will introduce unnecessary dependencies. Monadic libraries for *incremental computing* or FRP should provide optimized variants if needed. Compare with `parallel` for concurrent computing.

#### Converting Between Events and Behaviors

Going from events to behaviors, `until` and `switch` have type:
</code></pre>
<p>’a behavior -&gt; ’a behavior event -&gt; ’a behavior</p>
<pre><code>
while `step` has type:
</code></pre>
<p>’a -&gt; ’a event -&gt; ’a behavior</p>
<pre><code>
- `until b es` behaves as `b` until the first event in `es`, then behaves as the behavior in that event
- `switch b es` behaves as the behavior from the last event in `es` prior to current time, if any, otherwise as `b`
- `step a b` starts with behavior returning `a` and then switches to returning the value of the last event in `b` (prior to current time) -- a *step function*

We will use &quot;*signal*&quot; to refer to a behavior or an event. Note that often &quot;signal&quot; is used to mean what we call behavior (check terminology when looking at a new FRP library).

### 10.5 Reactivity by Stream Processing

The stream processing infrastructure should be familiar from earlier chapters:

```ocaml skip
type &#39;a stream = &#39;a stream_ Lazy.t
and &#39;a stream_ = Cons of &#39;a * &#39;a stream

let rec lmap f l = lazy (
  let Cons (x, xs) = Lazy.force l in
  Cons (f x, lmap f xs))

let rec liter (f : &#39;a -&gt; unit) (l : &#39;a stream) : unit =
  let Cons (x, xs) = Lazy.force l in
  f x; liter f xs

let rec lmap2 f xs ys = lazy (
  let Cons (x, xs) = Lazy.force xs in
  let Cons (y, ys) = Lazy.force ys in
  Cons (f x y, lmap2 f xs ys))

let rec lmap3 f xs ys zs = lazy (
  let Cons (x, xs) = Lazy.force xs in
  let Cons (y, ys) = Lazy.force ys in
  let Cons (z, zs) = Lazy.force zs in
  Cons (f x y z, lmap3 f xs ys zs))

let rec lfold acc f (l : &#39;a stream) = lazy (
  let Cons (x, xs) = Lazy.force l in  (* Fold a function over the stream *)
  let acc = f acc x in  (* producing a stream of partial results *)
  Cons (acc, lfold acc f xs))</code></pre>
<p>Since a behavior is a function of user actions and sample times, we
need to ensure that only one stream is created for the actual input
stream:</p>
<p>```ocaml skip type (’a, ’b) memo1 = {memo_f : ’a -&gt; ’b; mutable
memo_r : (’a * ’b) option}</p>
<p>let memo1 f = {memo_f = f; memo_r = None}</p>
<p>let memo1_app f x = match f.memo_r with | Some (y, res) when x == y
-&gt; res (* Physical equality is OK – <em>) | _ -&gt; (</em> external
input is “physically” unique <em>) let res = f.memo_f x in (</em> While
debugging, we can monitor <em>) f.memo_r &lt;- Some (x, res); (</em>
whether f.memo_r = None before *) res</p>
<p>let ($) = memo1_app</p>
<p>type ’a behavior = ((user_action option * time) stream, ’a stream)
memo1</p>
<pre><code>
#### Building Complex Behaviors

The monadic/applicative functions to build complex behaviors. If you do not provide type annotations in `.ml` files, work together with an `.mli` file to catch problems early. You can later add more type annotations as needed to find out what is wrong.

```ocaml skip
let returnB x : &#39;a behavior =
  let rec xs = lazy (Cons (x, xs)) in
  memo1 (fun _ -&gt; xs)

let ( !* ) = returnB

let liftB f fb = memo1 (fun uts -&gt; lmap f (fb $ uts))

let liftB2 f fb1 fb2 = memo1
  (fun uts -&gt; lmap2 f (fb1 $ uts) (fb2 $ uts))

let liftB3 f fb1 fb2 fb3 = memo1
  (fun uts -&gt; lmap3 f (fb1 $ uts) (fb2 $ uts) (fb3 $ uts))

let liftE f (fe : &#39;a event) : &#39;b event = memo1
  (fun uts -&gt; lmap
    (function Some e -&gt; Some (f e) | None -&gt; None)
    (fe $ uts))

let (=&gt;&gt;) fe f = liftE f fe
let (-&gt;&gt;) e v = e =&gt;&gt; fun _ -&gt; v</code></pre>
<p>Creating events out of behaviors:</p>
<p>```ocaml skip let whileB (fb : bool behavior) : unit event = memo1
(fun uts -&gt; lmap (function true -&gt; Some () | false -&gt; None) (fb
$ uts))</p>
<p>let unique fe : ’a event = memo1 (fun uts -&gt; let xs = fe $ uts in
lmap2 (fun x y -&gt; if x = y then None else y) (lazy (Cons (None, xs)))
xs)</p>
<p>let whenB fb = memo1 (fun uts -&gt; unique (whileB fb) $ uts)</p>
<p>let snapshot fe fb : (’a * ’b) event = memo1 (fun uts -&gt; lmap2
(fun x -&gt; function Some y -&gt; Some (y, x) | None -&gt; None) (fb $
uts) (fe $ uts))</p>
<pre><code>
Creating behaviors out of events:

```ocaml skip
let step acc fe =  (* The step function: value of last event *)
  memo1 (fun uts -&gt; lfold acc
    (fun acc -&gt; function None -&gt; acc | Some v -&gt; v)
    (fe $ uts))

let step_accum acc ff =  (* Transform a value by a series of functions *)
  memo1 (fun uts -&gt;
    lfold acc (fun acc -&gt; function
      | None -&gt; acc | Some f -&gt; f acc)
      (ff $ uts))</code></pre>
<p>To numerically integrate a behavior, we need to access the sampling
times:</p>
<p><code>ocaml skip let integral fb =   let rec loop t0 acc uts bs =     let Cons ((_, t1), uts) = Lazy.force uts in     let Cons (b, bs) = Lazy.force bs in     let acc = acc +. (t1 -. t0) *. b in  (* b = fb(t1), acc approx integral up to t0 *)     Cons (acc, lazy (loop t1 acc uts bs)) in   memo1 (fun uts -&gt; lazy (     let Cons ((_, t), uts') = Lazy.force uts in     Cons (0., lazy (loop t 0. uts' (fb $ uts)))))</code></p>
<p>In our <em>paddle game</em> example, we paradoxically express
position and velocity in mutually recursive manner. The trick is the
same as in Chapter 7 – integration introduces one step of delay.</p>
<p>User actions:</p>
<p>```ocaml skip let lbp : unit event = memo1 (fun uts -&gt; lmap
(function Some(Button(<em>,</em>)), _ -&gt; Some() | _ -&gt; None)
uts)</p>
<p>let mm : (int * int) event = memo1 (fun uts -&gt; lmap (function
Some(MouseMove(x, y)), _ -&gt; Some(x, y) | _ -&gt; None) uts)</p>
<p>let screen : (int * int) event = memo1 (fun uts -&gt; lmap (function
Some(Resize(x, y)), _ -&gt; Some(x, y) | _ -&gt; None) uts)</p>
<p>let mouse_x : int behavior = step 0 (liftE fst mm) let mouse_y : int
behavior = step 0 (liftE snd mm) let width : int behavior = step 640
(liftE fst screen) let height : int behavior = step 512 (liftE snd
screen)</p>
<pre><code>
#### The Paddle Game Example

A *scene graph* is a data structure that represents a &quot;world&quot; which can be drawn on screen:

```ocaml skip
type scene =
  | Rect of int * int * int * int  (* position, width, height *)
  | Circle of int * int * int  (* position, radius *)
  | Group of scene list
  | Color of Graphics.color * scene  (* color of subscene objects *)
  | Translate of float * float * scene  (* additional offset of origin *)</code></pre>
<p>Drawing a scene explains what we mean above:</p>
<p><code>ocaml skip let draw sc =   let f2i = int_of_float in   let open Graphics in   let rec aux t_x t_y = function  (* Accumulate translations *)     | Rect (x, y, w, h) -&gt;       fill_rect (f2i t_x + x) (f2i t_y + y) w h     | Circle (x, y, r) -&gt;       fill_circle (f2i t_x + x) (f2i t_y + y) r     | Group scs -&gt;       List.iter (aux t_x t_y) scs     | Color (c, sc) -&gt; set_color c; aux t_x t_y sc  (* Set color for sc objects *)     | Translate (x, y, sc) -&gt; aux (t_x +. x) (t_y +. y) sc in   clear_graph ();  (* "Fast and clean" removing of previous picture *)   aux 0. 0. sc;   synchronize ()  (* Synchronize the double buffer -- avoiding flickering *)</code></p>
<p>An animation is a scene behavior. To animate it we need to create the
input stream: the user actions and sampling times stream. We could
abstract away drawing from time sampling in <code>reactimate</code>,
asking for (i.e. passing as argument) a producer of user actions and a
consumer of scene graphs (like <code>draw</code>).</p>
<p>General-purpose behavior operators:</p>
<p><code>ocaml skip let (+*) = liftB2 (+) let (-*) = liftB2 (-) let ( *** ) = liftB2 ( * ) let (/*) = liftB2 (/) let (&amp;&amp;*) = liftB2 (&amp;&amp;) let (||*) = liftB2 (||) let (&lt;*) = liftB2 (&lt;) let (&gt;*) = liftB2 (&gt;)</code></p>
<p>The walls are drawn on left, top and right borders of the window:</p>
<p><code>ocaml skip let walls =   liftB2 (fun w h -&gt; Color (Graphics.blue, Group     [Rect (0, 0, 20, h-1); Rect (0, h-21, w-1, 20);      Rect (w-21, 0, 20, h-1)]))     width height</code></p>
<p>The paddle is tied to the mouse at the bottom border of the
window:</p>
<p><code>ocaml skip let paddle = liftB (fun mx -&gt;   Color (Graphics.black, Rect (mx, 0, 50, 10))) mouse_x</code></p>
<p>The ball has a velocity in pixels per second. It bounces from the
walls, which is hard-coded in terms of distance from window borders.
Unfortunately OCaml, being an eager language, does not let us encode
recursive behaviors in an elegant way. We need to unpack behaviors and
events as functions of the input stream:</p>
<ul>
<li><code>xbounce -&gt;&gt; (~-.)</code> event is just the negation
function happening at each horizontal bounce</li>
<li><code>step_accum vel (xbounce -&gt;&gt; (~-.))</code> behavior is
<code>vel</code> value changing sign at each horizontal bounce</li>
<li><code>liftB int_of_float (integral xvel) +* width /* !*2</code> –
first integrate velocity, then truncate it to integers and offset to the
middle of the window</li>
<li><code>whenB ((xpos &gt;* width -* !*27) ||* (xpos &lt;* !*27))</code>
– issue an event the first time the position exceeds the bounds. This
ensures there are no further bouncings until the ball moves out of the
walls</li>
</ul>
<h3 id="reactivity-by-incremental-computing">10.6 Reactivity by
Incremental Computing</h3>
<p>In <em>Froc</em>, behaviors and events are both implemented as
changeables but only behaviors persist; events are “instantaneous.”
Behaviors are composed out of constants and prior events, capturing the
“changeable” aspect. Events capture the “writeable” aspect – after their
values are propagated, the values are removed. Events and behaviors are
collectively called <em>signals</em>.</p>
<p><em>Froc</em> does not represent time, and provides the function
<code>changes : 'a behavior -&gt; 'a event</code>, which violates the
continuous semantics we introduced before. It breaks the illusion that
behaviors vary continuously rather than at discrete points in time. But
it avoids the need to synchronize global time samples with events in the
system. It is “less continuous but more dense.”</p>
<p>Sending an event – <code>send</code> – starts an <em>update
cycle</em>. Signals cannot call <code>send</code>, but can
<code>send_deferred</code> which will send an event in the next cycle.
Things that happen in the same update cycle are <em>simultaneous</em>.
Events are removed (detached from dependency graph) after an update
cycle.</p>
<p><em>Froc</em> provides the <code>fix_b</code>, <code>fix_e</code>
functions to define signals recursively. Current value refers to value
from previous update cycle, and defers next recursive step to next
cycle, until convergence.</p>
<p>Update cycles can happen “back-to-back” via
<code>send_deferred</code> and <code>fix_b</code>, <code>fix_e</code>,
or can be invoked from outside <em>Froc</em> by sending events at
arbitrary times. With a <code>time</code> behavior that holds a
<code>clock</code> event value, events from “back-to-back” update cycles
can be at the same clock time although not simultaneous in this sense.
Update cycles prevent <em>glitches</em>, where outdated signal is used
e.g. to issue an event.</p>
<h4 id="pure-vs.-impure-style">Pure vs. Impure Style</h4>
<p>A behavior is written in <em>pure style</em> when its definition does
not use <code>send</code>, <code>send_deferred</code>,
<code>notify_e</code>, <code>notify_b</code> and
<code>sample</code>:</p>
<ul>
<li><code>sample</code>, <code>notify_e</code>, <code>notify_b</code>
are used from outside the behavior (from its “environment”) analogously
to observing the result of a function</li>
<li><code>send</code>, <code>send_deferred</code> are used from outside
analogously to providing input to a function</li>
</ul>
<p>When writing in impure style we need to remember to refer from
somewhere to all the pieces of our behavior, otherwise the unreferred
parts will be <strong>garbage collected</strong> breaking the behavior.
A value is referred to when it has a name in the global environment or
is part of a bigger value that is referred to (for example it is stored
somewhere). Signals can be referred to by being part of the dependency
graph, but also by any of the more general ways.</p>
<h4 id="reimplementing-the-paddle-game-example">Reimplementing the
Paddle Game Example</h4>
<p>Rather than following our incremental computing example (a scene with
changeable parts), we follow our FRP example: a scene behavior.</p>
<p>First we introduce time:</p>
<p><code>ocaml skip open Froc let clock, tick = make_event () let time = hold (Unix.gettimeofday ()) clock</code></p>
<p>Next we define integration:</p>
<p><code>ocaml skip let integral fb =   let aux (sum, t0) t1 =     sum +. (t1 -. t0) *. sample fb, t1 in   collect_b aux (0., sample time) clock</code></p>
<p>For convenience, the integral remembers the current upper limit of
integration. It will be useful to get the integer part:</p>
<p><code>ocaml skip let integ_res fb =   lift (fun (v, _) -&gt; int_of_float v) (integral fb)</code></p>
<p>We can also define integration in pure style:</p>
<p>```ocaml skip let pair fa fb = lift2 (fun x y -&gt; x, y) fa fb</p>
<p>let integral_nice fb = let samples = changes (pair fb time) in let
aux (sum, t0) (fv, t1) = sum +. (t1 -. t0) *. fv, t1 in collect_b aux
(0., sample time) samples</p>
<pre><code>
The initial value `(0., sample time)` is not &quot;inside&quot; the behavior so `sample` here does not spoil the pure style.

### 10.7 Direct Control

Real-world behaviors often are *state machines*, going through several stages. We do not have declarative means for it yet. For example, consider baking recipes: *1. Preheat the oven. 2. Put flour, sugar, eggs into a bowl. 3. Spoon the mixture.* etc.

We want a *flow* to be able to proceed through events: when the first event arrives we remember its result and wait for the next event, disregarding any further arrivals of the first event! Therefore *Froc* constructs like mapping an event (`map`) or attaching a notification to a behavior change (`bind b1 (fun v1 -&gt; notify_b ~now:false b2 (fun v2 -&gt; ...))`) will not work.

We also want to be able to repeat or loop a flow, but starting from the notification of the first event that happens after the notification of the last event.

`next e` is an event propagating only the first occurrence of `e`. This will be the basis of our `await` function.

The whole flow should be cancellable from outside at any time.

A flow is a kind of a *lightweight thread* as in the end of Chapter 8; we will make it a monad. It only &quot;stores&quot; a non-unit value when it `await`s an event. But it has a primitive to `emit` values. We actually implement *coarse-grained* threads (Chapter 8 exercise 11), with `await` in the role of `suspend`.

We build a module `Flow` with monadic type `(&#39;a, &#39;b) flow` &quot;storing&quot; `&#39;b` and emitting `&#39;a`:

```ocaml skip
type (&#39;a, &#39;b) flow
type cancellable  (* A handle to cancel a flow (stop further computation) *)
val noop_flow : (&#39;a, unit) flow  (* Same as return () *)
val return : &#39;b -&gt; (&#39;a, &#39;b) flow  (* Completed flow *)
val await : &#39;b Froc.event -&gt; (&#39;a, &#39;b) flow  (* Wait and store event: *)
val bind :  (* the principled way to input *)
  (&#39;a, &#39;b) flow -&gt; (&#39;b -&gt; (&#39;a, &#39;c) flow) -&gt; (&#39;a, &#39;c) flow
val emit : &#39;a -&gt; (&#39;a, unit) flow  (* The principled way to output *)
val cancel : cancellable -&gt; unit
val repeat :  (* Loop the given flow and store the stop event *)
  ?until:&#39;a Froc.event -&gt; (&#39;b, unit) flow -&gt; (&#39;b, &#39;a) flow
val event_flow :
  (&#39;a, unit) flow -&gt; &#39;a Froc.event * cancellable
val behavior_flow :  (* The initial value of a behavior and a flow to update it *)
  &#39;a -&gt; (&#39;a, unit) flow -&gt; &#39;a Froc.behavior * cancellable
val is_cancelled : cancellable -&gt; bool</code></pre>
<h4 id="implementation-details">Implementation Details</h4>
<p>We follow our (or <em>Lwt</em>) implementation of lightweight
threads, adapting it to the need of cancelling flows:</p>
<p><code>ocaml skip module F = Froc type 'a result =   | Return of 'a  (* Notifications to cancel when cancelled *)   | Sleep of ('a -&gt; unit) list * F.cancel ref list   | Cancelled   | Link of 'a state and 'a state = {mutable state : 'a result} type cancellable = unit state</code></p>
<p>Functions <code>find</code>, <code>wakeup</code>,
<code>connect</code> are as in Chapter 8 (but connecting to cancelled
thread cancels the other thread).</p>
<p>Our monad is actually a reader monad over the result state. The
reader supplies the <code>emit</code> function:</p>
<p><code>ocaml skip type ('a, 'b) flow = ('a -&gt; unit) -&gt; 'b state</code></p>
<p>The <code>return</code> and <code>bind</code> functions are as in our
lightweight threads, but we need to handle cancelled flows: for
<code>m = bind a b</code>, if <code>a</code> is cancelled then
<code>m</code> is cancelled, and if <code>m</code> is cancelled then we
do not wake up <code>b</code>:</p>
<p><code>ocaml skip let waiter x =   if not (is_cancelled m)   then connect m (b x emit) in   ...</code></p>
<p><code>await</code> is implemented like <code>next</code>, but it
wakes up a flow:</p>
<p><code>ocaml skip let await t = fun emit -&gt;   let c = ref F.no_cancel in   let m = {state = Sleep ([], [c])} in   c :=     F.notify_e_cancel t begin fun r -&gt;       F.cancel !c;       c := F.no_cancel;       wakeup m r     end;   m</code></p>
<p><code>repeat</code> attaches the whole loop as a waiter for the loop
body.</p>
<h4 id="example-drawing-shapes">Example: Drawing Shapes</h4>
<p>The scene is a list of shapes, the first shape is open:</p>
<p>```ocaml skip type scene = (int * int) list list</p>
<p>let draw sc = let open Graphics in clear_graph (); (match sc with |
[] -&gt; () | opn :: cld -&gt; draw_poly_line (Array.of_list opn);
List.iter (fill_poly -| Array.of_list) cld); synchronize ()</p>
<pre><code>
We build a flow and turn it into a behavior to animate:

```ocaml skip
let painter =
  let cld = ref [] in  (* Global state of painter *)
  repeat (perform
      await mbutton_pressed;  (* Start when button down *)
      let opn = ref [] in
      repeat (perform
          mpos &lt;-- await mouse_move;  (* Add next position to line *)
          emit (opn := mpos :: !opn; !opn :: !cld))
        ~until:mbutton_released;  (* Start new shape *)
      emit (cld := !opn :: !cld; opn := []; [] :: !cld))

let painter, cancel_painter = behavior_flow [] painter
let () = reactimate painter</code></pre>
<h4 id="flows-and-state">Flows and State</h4>
<p>Global state and thread-local state can be used with lightweight
threads, but pay attention to semantics – which computations are inside
the monad and which while building the initial monadic value.</p>
<p>Side effects hidden in <code>return</code> and <code>emit</code>
arguments are not inside the monad. For example, if in the “first line”
of a loop effects are executed only at the start of the loop – but if
after bind (“below first line” of a loop), at each step of the loop:</p>
<p>```ocaml skip let f = repeat ( let* () = emit (Printf.printf “[0]%!”;
‘0’) in let* () = await aas in let* () = emit (Printf.printf “[1]%!”;
‘1’) in let* () = () &lt;– await bs in let* () = emit (Printf.printf
“[2]%!”; ‘2’) in let* () = () &lt;– await cs in let* () = emit
(Printf.printf “[3]%!”; ‘3’) in let* () = await ds in emit
(Printf.printf “[4]%!”; ‘4’))</p>
<p>let e, cancel_e = event_flow f let () = F.notify_e e (fun c -&gt;
Printf.printf “flow: %c%!” c) in Printf.printf “notification
installed%!”</p>
<p>let () = F.send a (); F.send b (); F.send c (); F.send d (); F.send a
(); F.send b (); F.send c (); F.send d ()</p>
<pre><code>
The output demonstrates the execution order:
- `[0]` -- Only printed once, when building the loop
- `notification installed` -- Only installed after the first flow event sent
- `event: a` -- Event notification
- `[1]` -- Second emit computed after first await returns
- `flow: 1` -- Emitted signal
- ... and so on through the loop iterations

### 10.8 Graphical User Interfaces

In-depth discussion of GUIs is beyond the scope of this course. We only cover what is needed for an example reactive program with direct control.

We demonstrate two libraries: *LablTk* based on optional labelled arguments (discussed in Chapter 2 exercise 2) and polymorphic variants, and *LablGTk* additionally based on objects. We will learn more about objects and polymorphic variants in the next chapter.

#### Calculator Flow

We represent the mechanics of the calculator directly as a flow:

```ocaml skip
let digits, digit = F.make_event ()
let ops, op = F.make_event ()
let dots, dot = F.make_event ()

let calc =
  (* We need two state variables for two arguments of calculation *)
  let f = ref (fun x -&gt; x) and now = ref 0.0 in  (* but we *)
  repeat (         (* remember the older argument in partial application *)
      let* op = repeat (    (* Enter the digits of a number (on later turns *)
            let* d = await digits in  (* starting from the second digit) *)
            emit (now := 10. *. !now +. d; !now))
        ~until:ops in                 (* until operator button is pressed *)
      let* () = emit (now := !f !now; f := op !now; !now) in
      (* Compute the result and &quot;store away&quot; the operator *)
      let* d = repeat
        (let* op = await ops in return (f := op !now))
        ~until:digits in  (* The user can pick a different operator *)
      emit (now := d; !now))  (* Reset the state to a new number *)

let calc_e, cancel_calc = event_flow calc  (* Notifies display update *)</code></pre>
<h4 id="tk-labltk">Tk: LablTk</h4>
<p>Widget toolkit <em>Tk</em> is known from the <em>Tcl</em>
language.</p>
<p>Layout of the calculator – common across GUIs:</p>
<p><code>ocaml skip let layout = [|   [|"7", `Di 7.; "8", `Di 8.; "9", `Di 9.; "+", `O (+.)|];   [|"4", `Di 4.; "5", `Di 5.; "6", `Di 6.; "-", `O (-.)|];   [|"1", `Di 1.; "2", `Di 2.; "3", `Di 3.; "*", `O ( *.)|];   [|"0", `Di 0.; ".", `Dot;   "=",  `O sk; "/", `O (/.)|] |]</code></p>
<p>Key concepts:</p>
<ul>
<li>Every <em>widget</em> (window gadget) has a parent in which it is
located</li>
<li><em>Buttons</em> have action associated with pressing them,
<em>labels</em> just provide information, <em>entries</em> (aka.
<em>edit</em> fields) are for entering info from keyboard</li>
<li>Actions are <em>callback</em> functions passed as the
<code>~command</code> argument</li>
<li><em>Frames</em> in <em>Tk</em> group widgets</li>
<li>The parent is sent as last argument, after optional labelled
arguments</li>
</ul>
<p>```ocaml skip let top = Tk.openTk ()</p>
<p>let btn_frame = Frame.create ~relief:`Groove ~borderwidth:2 top</p>
<p>let buttons = Array.map (Array.map (function | text,
<code>Dot -&gt;       Button.create ~text         ~command:(fun () -&gt; F.send dot ()) btn_frame     | text,</code>Di
d -&gt; Button.create ~text ~command:(fun () -&gt; F.send digit d)
btn_frame | text, `O f -&gt; Button.create ~text ~command:(fun () -&gt;
F.send op f) btn_frame)) layout</p>
<p>let result = Label.create ~text:“0” ~relief:`Sunken top</p>
<pre><code>
GUI toolkits have layout algorithms, so we only need to tell which widgets hang together and whether they should fill all available space etc. -- via `pack`, or `grid` for &quot;rectangular&quot; organization:

- `~fill:` the allocated space in `` `X``, `` `Y``, `` `Both`` or `` `None`` axes
- `~expand:` maximally how much space is allocated or only as needed
- `~anchor:` allows to glue a widget in particular direction (`` `Center``, `` `E``, `` `Ne`` etc.)
- The `grid` packing flexibility: `~columnspan` and `~rowspan`
- `configure` functions accept the same arguments as `create` but change existing widgets

```ocaml skip
let () =
  Wm.title_set top &quot;Calculator&quot;;
  Tk.pack [result] ~side:`Top ~fill:`X;
  Tk.pack [btn_frame] ~side:`Bottom ~expand:true;
  Array.iteri (fun column -&gt; Array.iteri (fun row button -&gt;
    Tk.grid ~column ~row [button])) buttons;
  Wm.geometry_set top &quot;200x200&quot;;
  F.notify_e calc_e
    (fun now -&gt;
      Label.configure ~text:(string_of_float now) result);
  Tk.mainLoop ()</code></pre>
<h4 id="gtk-lablgtk">GTk+: LablGTk</h4>
<p><em>LablGTk</em> is built as an object-oriented layer over a
low-level layer of functions interfacing with the <em>GTk+</em> library,
which is written in <em>C</em>.</p>
<p>In OCaml, object fields are only visible to object methods, and
methods are called with <code>#</code> syntax,
e.g. <code>window#show ()</code>.</p>
<p>The interaction with the application is reactive:</p>
<ul>
<li>Our events are called signals in <em>GTk+</em></li>
<li>Registering a notification is called connecting a signal handler,
e.g. <code>button#connect#clicked ~callback:hello</code> which takes
<code>~callback:(unit -&gt; unit)</code> and returns
<code>GtkSignal.id</code></li>
<li>As with <em>Froc</em> notifications, multiple handlers can be
attached</li>
<li><em>GTk+</em> events are a subclass of signals related to more
specific window events,
e.g. <code>window#event#connect#delete ~callback:delete_event</code></li>
<li><em>GTk+</em> event callbacks take more info:
<code>~callback:(event -&gt; unit)</code> for some type
<code>event</code></li>
</ul>
<p>Automatic layout (aka. packing) seems less sophisticated than in
<em>Tk</em>:</p>
<ul>
<li>only horizontal and vertical boxes</li>
<li>therefore <code>~fill</code> is binary and <code>~anchor</code> is
replaced by <code>~from</code> <code>`START</code> or
<code>`END</code></li>
</ul>
<p>Automatic grid layout is called <code>table</code>:</p>
<ul>
<li><code>~fill</code> and <code>~expand</code> take <code>`X</code>,
<code>`Y</code>, <code>`BOTH</code>, <code>`NONE</code></li>
</ul>
<p>The <code>coerce</code> method casts the type of the object (in
<em>Tk</em> there is <code>coe</code> function). Labels do not have a
dedicated module. Widgets have setter methods <code>widget#set_X</code>
(instead of a single <code>configure</code> function in
<em>Tk</em>).</p>
<p>Setup:</p>
<p><code>ocaml skip let _ = GtkMain.Main.init () let window =   GWindow.window ~width:200 ~height:200 ~title:"Calculator" () let top = GPack.vbox ~packing:window#add () let result = GMisc.label ~text:"0" ~packing:top#add () let btn_frame =   GPack.table ~rows:(Array.length layout)    ~columns:(Array.length layout.(0)) ~packing:top#add ()</code></p>
<p>Button actions:</p>
<p><code>ocaml skip let buttons =   Array.map (Array.map (function     | label, `Dot -&gt;       let b = GButton.button ~label () in       let _ = b#connect#clicked         ~callback:(fun () -&gt; F.send dot ()) in b     | label, `Di d -&gt;       let b = GButton.button ~label () in       let _ = b#connect#clicked         ~callback:(fun () -&gt; F.send digit d) in b     | label, `O f -&gt;       let b = GButton.button ~label () in       let _ = b#connect#clicked         ~callback:(fun () -&gt; F.send op f) in b)) layout</code></p>
<p>Button layout, result notification, start application:</p>
<p>```ocaml skip let delete_event _ = GMain.Main.quit (); false</p>
<p>let () = let _ = window#event#connect#delete ~callback:delete_event
in Array.iteri (fun column -&gt; Array.iteri (fun row button -&gt;
btn_frame#attach ~left:column ~top:row
~fill:<code>BOTH ~expand:</code>BOTH (button#coerce)) ) buttons;
F.notify_e calc_e (fun now -&gt; result#set_label (string_of_float
now)); window#show (); GMain.Main.main ()</p>
<pre><code>
### 10.9 Exercises

**Exercise 1:** Introduce operators $-, /$ into the context rewriting &quot;pull out subexpression&quot; example. Remember that they are not commutative.

**Exercise 2:** Add to the *paddle game* example:
1. game restart,
2. score keeping,
3. game quitting (in more-or-less elegant way).

**Exercise 3:** Our numerical integration function roughly corresponds to the rectangle rule. Modify the rule and write a test for the accuracy of:
1. the trapezoidal rule;
2. the Simpson&#39;s rule. See http://en.wikipedia.org/wiki/Simpson%27s_rule

**Exercise 4:** Explain the recursive behavior of integration:
1. In *paddle game* implemented by stream processing (`Lec10b.ml`), do we look at past velocity to determine current position, at past position to determine current velocity, both, or neither?
2. What is the difference between `integral` and `integral_nice` in `Lec10c.ml`, what happens when we replace the former with the latter in the `pbal` function? How about after rewriting `pbal` into pure style as in the following exercise?

**Exercise 5:** Reimplement the *Froc* based paddle ball example in a pure style: rewrite the `pbal` function to not use `notify_e`.

**Exercise 6:** Our implementation of flows is a bit heavy. One alternative approach is to use continuations, as in `Scala.React`. OCaml has a continuations library *Delimcc*; for how it can cooperate with *Froc*, see http://ambassadortothecomputers.blogspot.com/2010/08/mixing-monadic-and-direct-style-code.html

**Exercise 7:** Implement `parallel` for flows, retaining coarse-grained implementation and using the event queue from *Froc* somehow (instead of introducing a new job queue).

**Exercise 8:** Add quitting, e.g. via a `&#39;q&#39;` key press, to the *painter* example. Use the `is_cancelled` function.

**Exercise 9:** Our calculator example is not finished. Implement entering decimal fractions: add handling of the `dots` event.

**Exercise 10:** The Flow module has reader monad functions that have not been discussed in this chapter:
</code></pre>
<p>let local f m = fun emit -&gt; m (fun x -&gt; emit (f x)) let
local_opt f m = fun emit -&gt; m (fun x -&gt; match f x with None -&gt;
() | Some y -&gt; emit y)</p>
<p>val local : (’a -&gt; ’b) -&gt; (’a, ’c) flow -&gt; (’b, ’c) flow val
local_opt : (’a -&gt; ’b option) -&gt; (’a, ’c) flow -&gt; (’b, ’c)
flow</p>
<pre><code>
Implement an example that uses this compositionality-increasing capability.


## Chapter 11: The Expression Problem

This chapter explores **the expression problem**, a classic challenge in software engineering that addresses how to design systems that can be extended with both new data variants and new operations without modifying existing code, while maintaining static type safety. We examine multiple approaches in OCaml, ranging from algebraic data types through object-oriented programming to polymorphic variants with recursive modules. The chapter concludes with an application to parser combinators and dynamic code loading.

### 11.1 The Expression Problem: Definition

The **Expression Problem** concerns the design of an implementation for expressions where:

- **Datatype extensibility**: New variants of expressions can be added
- **Functional extensibility**: New operations on expressions can be added

By *extensibility* we mean three conditions:

1. **Code-level modularization**: The new datatype variants and new operations are in separate files
2. **Separate compilation**: The files can be compiled and distributed separately
3. **Static type safety**: We do not lose type checking help and guarantees

The name comes from a classic example: extending a language of expressions with new constructs. Consider two sub-languages:

- **Lambda calculus**: variables `Var`, $\lambda$-abstractions `Abs`, function applications `App`
- **Arithmetic**: variables `Var`, constants `Num`, addition `Add`, multiplication `Mult`

And operations we want to support:

- Evaluation `eval`
- Pretty-printing to strings `string_of`
- Free variables computation `free_vars`

The challenge is to combine these sub-languages and add new operations without breaking existing code or sacrificing type safety.

#### References

- Ralf Lammel lectures on MSDN&#39;s Channel 9: [The Expression Problem](http://channel9.msdn.com/Shows/Going+Deep/C9-Lectures-Dr-Ralf-Laemmel-Advanced-Functional-Programming-The-Expression-Problem), [Haskell&#39;s Type Classes](http://channel9.msdn.com/Shows/Going+Deep/C9-Lectures-Dr-Ralf-Lmmel-Advanced-Functional-Programming-Type-Classes)
- The book *Developing Applications with Objective Caml*: [Comparison of Modules and Objects](http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora153.html), [Extending Components](http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora154.html)
- *Real World OCaml*: [Chapter 11: Objects](https://realworldocaml.org/v1/en/html/objects.html), [Chapter 12: Classes](https://realworldocaml.org/v1/en/html/classes.html)
- Jacques Garrigue&#39;s [Code reuse through polymorphic variants](http://www.math.nagoya-u.ac.jp/~garrigue/papers/variant-reuse.ps.gz), and [Recursive Modules for Programming](http://www.math.nagoya-u.ac.jp/~garrigue/papers/nakata-icfp2006.pdf) with Keiko Nakata
- [Extensible variant types](http://caml.inria.fr/pub/docs/manual-ocaml/extn.html#sec246)
- Graham Hutton&#39;s and Erik Meijer&#39;s [Monadic Parser Combinators](https://www.cs.nott.ac.uk/~gmh/monparsing.pdf)

### 11.2 Functional Programming Non-Solution: Ordinary Algebraic Datatypes

Pattern matching makes **functional extensibility** easy in functional programming. However, ensuring **datatype extensibility** is complicated when using standard variant types.

For brevity, we place examples in a single file, but the component type and function definitions are not mutually recursive, so they can be put in separate modules.

**Non-solution penalty points:**

- Functions implemented for a broader language (e.g., `lexpr_t`) cannot be used with a value from a narrower language (e.g., `expr_t`)
- Significant memory (and some time) overhead due to *tagging*: the work of `wrap` and `unwrap` functions, adding tags such as `Lambda` and `Expr`
- Some code bloat due to tagging. For example, deep pattern matching needs to be manually unrolled and interspersed with calls to `unwrap`

**Verdict:** Non-solution, but better than extensible variant types-based approach and direct OOP approach.

Here is the implementation:

```ocaml env=sol1
type var = string  (* Variables constitute a sub-language of its own *)
                   (* We treat this sub-language slightly differently --
                      no need for a dedicated variant *)

let eval_var wrap sub (s : var) =
  try List.assoc s sub with Not_found -&gt; wrap s

type &#39;a lambda =  (* Here we define the sub-language of lambda-expressions *)
  VarL of var | Abs of string * &#39;a | App of &#39;a * &#39;a

(* During evaluation, we need to freshen variables to avoid capture *)
(* (mistaking distinct variables with the same name) *)
let gensym = let n = ref 0 in fun () -&gt; incr n; &quot;_&quot; ^ string_of_int !n

let eval_lambda eval_rec wrap unwrap subst e =
  match unwrap e with  (* Alternatively, unwrapping could use an exception *)
  | Some (VarL v) -&gt; eval_var (fun v -&gt; wrap (VarL v)) subst v
  | Some (App (l1, l2)) -&gt;  (* but we use the option type as it is safer *)
    let l1&#39; = eval_rec subst l1  (* and more flexible in this context *)
    and l2&#39; = eval_rec subst l2 in  (* Recursive processing function returns expression *)
    (match unwrap l1&#39; with  (* of the completed language, we need *)
    | Some (Abs (s, body)) -&gt;  (* to unwrap it into the current sub-language *)
      eval_rec [s, l2&#39;] body  (* The recursive call is already wrapped *)
    | _ -&gt; wrap (App (l1&#39;, l2&#39;)))  (* Wrap into the completed language *)
  | Some (Abs (s, l1)) -&gt;
    let s&#39; = gensym () in  (* Rename variable to avoid capture (alpha-equivalence) *)
    wrap (Abs (s&#39;, eval_rec ((s, wrap (VarL s&#39;))::subst) l1))
  | None -&gt; e  (* Falling-through when not in the current sub-language *)

type lambda_t = Lambda_t of lambda_t lambda  (* Defining lambdas as the completed language *)

let rec eval1 subst =  (* and the corresponding eval function *)
  eval_lambda eval1
    (fun e -&gt; Lambda_t e) (fun (Lambda_t e) -&gt; Some e) subst</code></pre>
<p>Now we define the arithmetic sub-language:</p>
<p>```ocaml env=sol1 type ’a expr = (* The sub-language of arithmetic
expressions <em>) VarE of var | Num of int | Add of ’a </em> ’a | Mult
of ’a * ’a</p>
<p>let eval_expr eval_rec wrap unwrap subst e = match unwrap e with |
Some (Num <em>) -&gt; e | Some (VarE v) -&gt; eval_var (fun x -&gt; wrap
(VarE x)) subst v | Some (Add (m, n)) -&gt; let m’ = eval_rec subst m
and n’ = eval_rec subst n in (match unwrap m’, unwrap n’ with (*
Unwrapping to check if the subexpressions <em>) | Some (Num m’), Some
(Num n’) -&gt; (</em> got computed to values <em>) wrap (Num (m’ + n’))
| _ -&gt; wrap (Add (m’, n’))) (</em> Here m’ and n’ are wrapped <em>) |
Some (Mult (m, n)) -&gt; let m’ = eval_rec subst m and n’ = eval_rec
subst n in (match unwrap m’, unwrap n’ with | Some (Num m’), Some (Num
n’) -&gt; wrap (Num (m’ </em> n’)) | </em> -&gt; wrap (Mult (m’, n’))) |
None -&gt; e</p>
<p>type expr_t = Expr_t of expr_t expr (* Defining arithmetic as the
completed language *)</p>
<p>let rec eval2 subst = (* aka “tying the recursive knot” *) eval_expr
eval2 (fun e -&gt; Expr_t e) (fun (Expr_t e) -&gt; Some e) subst</p>
<pre><code>
Finally, we merge the two sub-languages:

```ocaml env=sol1
type &#39;a lexpr =  (* The language merging lambda-expressions and arithmetic expressions *)
  Lambda of &#39;a lambda | Expr of &#39;a expr  (* can also be used in further extensions *)

let eval_lexpr eval_rec wrap unwrap subst e =
  eval_lambda eval_rec
    (fun e -&gt; wrap (Lambda e))
    (fun e -&gt;
      match unwrap e with
      | Some (Lambda e) -&gt; Some e
      | _ -&gt; None)
    subst
    (eval_expr eval_rec  (* We use the &quot;fall-through&quot; property of eval_expr *)
       (fun e -&gt; wrap (Expr e))  (* to combine the evaluators *)
       (fun e -&gt;
         match unwrap e with
         | Some (Expr e) -&gt; Some e
         | _ -&gt; None)
       subst e)

type lexpr_t = LExpr_t of lexpr_t lexpr  (* Tying the recursive knot one last time *)

let rec eval3 subst =
  eval_lexpr eval3
    (fun e -&gt; LExpr_t e)
    (fun (LExpr_t e) -&gt; Some e) subst</code></pre>
<h3 id="lightweight-fp-non-solution-extensible-variant-types">11.3
Lightweight FP Non-Solution: Extensible Variant Types</h3>
<p>Exceptions have always formed an extensible variant type in OCaml,
whose pattern matching is done using the <code>try...with</code> syntax.
Since recently, new extensible variant types can be defined. This
augments the normal function extensibility of FP with straightforward
data extensibility.</p>
<p><strong>Non-solution penalty points:</strong></p>
<ul>
<li>Giving up exhaustivity checking, which is an important aspect of
static type safety</li>
<li>More natural with “single inheritance” extension chains, although
merging is possible and demonstrated in our example</li>
<li>Requires “tying the recursive knot” for functions</li>
</ul>
<p><strong>Verdict:</strong> Pleasant-looking, but the worst approach
because of possible bugginess. Unless bug-proneness is not a concern,
then the best approach.</p>
<p>```ocaml env=sol2 type expr = .. (* This is how extensible variant
types are defined *)</p>
<p>type var_name = string type expr += Var of string (* We add a variant
case *)</p>
<p>let eval_var sub = function | Var s as v -&gt; (try List.assoc s sub
with Not_found -&gt; v) | e -&gt; e</p>
<p>let gensym = let n = ref 0 in fun () -&gt; incr n; “_” ^
string_of_int !n</p>
<p>type expr += Abs of string * expr | App of expr * expr (* The
sub-languages are not differentiated by types, a shortcoming of this
non-solution *)</p>
<p>let eval_lambda eval_rec subst = function | Var _ as v -&gt; eval_var
subst v | App (l1, l2) -&gt; let l2’ = eval_rec subst l2 in (match
eval_rec subst l1 with | Abs (s, body) -&gt; eval_rec [s, l2’] body |
l1’ -&gt; App (l1’, l2’)) | Abs (s, l1) -&gt; let s’ = gensym () in Abs
(s’, eval_rec ((s, Var s’)::subst) l1) | e -&gt; e</p>
<p>let freevars_lambda freevars_rec = function | Var v -&gt; [v] | App
(l1, l2) -&gt; freevars_rec l1 @ freevars_rec l2 | Abs (s, l1) -&gt;
List.filter (fun v -&gt; v &lt;&gt; s) (freevars_rec l1) | _ -&gt;
[]</p>
<p>let rec eval1 subst e = eval_lambda eval1 subst e let rec freevars1 e
= freevars_lambda freevars1 e</p>
<p>let test1 = App (Abs (“x”, Var “x”), Var “y”) let e_test = eval1 []
test1 let fv_test = freevars1 test1</p>
<pre><code>
Now we extend with arithmetic:

```ocaml env=sol2
type expr += Num of int | Add of expr * expr | Mult of expr * expr

let map_expr f = function
  | Add (e1, e2) -&gt; Add (f e1, f e2)
  | Mult (e1, e2) -&gt; Mult (f e1, f e2)
  | e -&gt; e

let eval_expr eval_rec subst e =
  match map_expr (eval_rec subst) e with
  | Add (Num m, Num n) -&gt; Num (m + n)
  | Mult (Num m, Num n) -&gt; Num (m * n)
  | (Num _ | Add _ | Mult _) as e -&gt; e
  | e -&gt; e

let freevars_expr freevars_rec = function
  | Num _ -&gt; []
  | Add (e1, e2) | Mult (e1, e2) -&gt; freevars_rec e1 @ freevars_rec e2
  | _ -&gt; []

let rec eval2 subst e = eval_expr eval2 subst e
let rec freevars2 e = freevars_expr freevars2 e

let test2 = Add (Mult (Num 3, Var &quot;x&quot;), Num 1)
let e_test2 = eval2 [] test2
let fv_test2 = freevars2 test2</code></pre>
<p>Merging the sub-languages:</p>
<p>```ocaml env=sol2 let eval_lexpr eval_rec subst e = eval_expr
eval_rec subst (eval_lambda eval_rec subst e)</p>
<p>let freevars_lexpr freevars_rec e = freevars_lambda freevars_rec e @
freevars_expr freevars_rec e</p>
<p>let rec eval3 subst e = eval_lexpr eval3 subst e let rec freevars3 e
= freevars_lexpr freevars3 e</p>
<p>let test3 = App (Abs (“x”, Add (Mult (Num 3, Var “x”), Num 1)), Num
2) let e_test3 = eval3 [] test3 let fv_test3 = freevars3 test3</p>
<pre><code>
### 11.4 Object-Oriented Programming: Subtyping

OCaml&#39;s **objects** are values, somewhat similar to records. Viewed from the outside, an OCaml object has only **methods**, identifying the code with which to respond to messages (method invocations). All methods are **late-bound**; the object determines what code is run (i.e., *virtual* in C++ parlance).

**Subtyping** determines if an object can be used in some context. OCaml has **structural subtyping**: the content of the types concerned decides if an object can be used. Parametric polymorphism can be used to infer if an object has the required methods.

```ocaml env=oop_intro
let f x = x#m  (* Method invocation: object#method *)
(* val f : &lt; m : &#39;a; .. &gt; -&gt; &#39;a *)
(* Type polymorphic in two ways: &#39;a is the method type, *)
(* .. means that objects with more methods will be accepted *)</code></pre>
<p>Methods are computed when they are invoked, even if they do not take
arguments. We define objects inside <code>object...end</code> (compare:
records <code>{...}</code>) using keywords:</p>
<ul>
<li><code>method</code> for methods</li>
<li><code>val</code> for constant fields</li>
<li><code>val mutable</code> for mutable fields</li>
</ul>
<p>Constructor arguments can often be used instead of constant
fields:</p>
<p><code>ocaml env=oop_intro let square w = object   method area = float_of_int (w * w)   method width = w end</code></p>
<p>Subtyping often needs to be explicit: we write
<code>(object :&gt; supertype)</code> or in more complex cases
<code>(object : type :&gt; supertype)</code>.</p>
<p>Technically speaking, subtyping in OCaml always is explicit, and
<em>open types</em>, containing <code>..</code>, use <strong>row
polymorphism</strong> rather than subtyping.</p>
<p>```ocaml env=oop_intro let a = object method m = 7 method x = “a” end
(* Toy example: object types <em>) let b = object method m = 42 method y
= “b” end (</em> share some but not all methods *)</p>
<p>(* let l = [a; b] – Error: the exact types of the objects do not
agree <em>) (</em> Error: This expression has type &lt; m : int; y :
string &gt; but an expression was expected of type &lt; m : int; x :
string &gt; The second object type has no method y *)</p>
<p>let l = [(a :&gt; &lt;m : ’a&gt;); (b :&gt; &lt;m : ’a&gt;)] (* But
the types share a supertype <em>) (</em> val l : &lt; m : int &gt; list
*)</p>
<pre><code>
### 11.5 Direct Object-Oriented Non-Solution

We can try to solve the expression problem using objects directly. However, adding new functionality still requires modifying old code, so this approach does not fully solve the expression problem.

**Non-solution penalty points:**

- No way to add functionality without modifying old code (in particular, the abstract class and all concrete classes)
- No deep pattern matching

**Verdict:** Non-solution, and probably the worst approach.

Here is an implementation using objects:

```ocaml env=sol3
type var_name = string

let gensym = let n = ref 0 in fun () -&gt; incr n; &quot;_&quot; ^ string_of_int !n

class virtual [&#39;lang] evaluable =
object
  method virtual eval : (var_name * &#39;lang) list -&gt; &#39;lang
  method virtual rename : var_name -&gt; var_name -&gt; &#39;lang
  method apply (_arg : &#39;lang)
    (fallback : unit -&gt; &#39;lang) (_subst : (var_name * &#39;lang) list) =
    fallback ()
end

class [&#39;lang] var (v : var_name) =
object (self)
  inherit [&#39;lang] evaluable
  val v = v
  method eval subst =
    try List.assoc v subst with Not_found -&gt; self
  method rename v1 v2 =
    if v = v1 then {&lt; v = v2 &gt;} else self
end

class [&#39;lang] abs (v : var_name) (body : &#39;lang) =
object (self)
  inherit [&#39;lang] evaluable
  val v = v
  val body = body
  method eval subst =
    let v&#39; = gensym () in
    {&lt; v = v&#39;; body = (body#rename v v&#39;)#eval subst &gt;}
  method rename v1 v2 =
    if v = v1 then self
    else {&lt; body = body#rename v1 v2 &gt;}
  method apply arg _ subst =
    body#eval ((v, arg)::subst)
end

class [&#39;lang] app (f : &#39;lang) (arg : &#39;lang) =
object (self)
  inherit [&#39;lang] evaluable
  val f = f
  val arg = arg
  method eval subst =
    let arg&#39; = arg#eval subst in
    f#apply arg&#39; (fun () -&gt; {&lt; f = f#eval subst; arg = arg&#39; &gt;}) subst
  method rename v1 v2 =
    {&lt; f = f#rename v1 v2; arg = arg#rename v1 v2 &gt;}
end

type evaluable_t = evaluable_t evaluable
let new_var1 v : evaluable_t = new var v
let new_abs1 v (body : evaluable_t) : evaluable_t = new abs v body
let new_app1 (arg1 : evaluable_t) (arg2 : evaluable_t) : evaluable_t =
  new app arg1 arg2

let test1 = new_app1 (new_abs1 &quot;x&quot; (new_var1 &quot;x&quot;)) (new_var1 &quot;y&quot;)
let e_test1 = test1#eval []</code></pre>
<p>Extending with arithmetic requires additional mixins:</p>
<p>```ocaml env=sol3 class virtual compute_mixin = object method compute
: int option = None end</p>
<p>class [’lang] var_c v = object inherit [’lang] var v inherit
compute_mixin end</p>
<p>class [’lang] abs_c v body = object inherit [’lang] abs v body
inherit compute_mixin end</p>
<p>class [’lang] app_c f arg = object inherit [’lang] app f arg inherit
compute_mixin end</p>
<p>class [’lang] num (i : int) = object (self) inherit [’lang] evaluable
val i = i method eval <em>subst = self method rename </em> _ = self
method compute = Some i end</p>
<p>class virtual [’lang] operation (num_inst : int -&gt; ‘lang) (n1 :
’lang) (n2 : ’lang) = object (self) inherit [’lang] evaluable val n1 =
n1 val n2 = n2 method eval subst = let self’ = {&lt; n1 = n1#eval subst;
n2 = n2#eval subst &gt;} in match self’#compute with | Some i -&gt;
num_inst i | _ -&gt; self’ method rename v1 v2 = {&lt; n1 = n1#rename v1
v2; n2 = n2#rename v1 v2 &gt;} end</p>
<p>class [’lang] add num_inst n1 n2 = object (self) inherit [’lang]
operation num_inst n1 n2 method compute = match n1#compute, n2#compute
with | Some i1, Some i2 -&gt; Some (i1 + i2) | _ -&gt; None end</p>
<p>class [’lang] mult num_inst n1 n2 = object (self) inherit [’lang]
operation num_inst n1 n2 method compute = match n1#compute, n2#compute
with | Some i1, Some i2 -&gt; Some (i1 * i2) | _ -&gt; None end</p>
<p>class virtual [’lang] computable = object inherit [’lang] evaluable
inherit compute_mixin end</p>
<p>type computable_t = computable_t computable let new_var2 v :
computable_t = new var_c v let new_abs2 v (body : computable_t) :
computable_t = new abs_c v body let new_app2 v (body : computable_t) :
computable_t = new app_c v body let new_num2 i : computable_t = new num
i let new_add2 (n1 : computable_t) (n2 : computable_t) : computable_t =
new add new_num2 n1 n2 let new_mult2 (n1 : computable_t) (n2 :
computable_t) : computable_t = new mult new_num2 n1 n2</p>
<p>let test2 = new_app2 (new_abs2 “x” (new_add2 (new_mult2 (new_num2 3)
(new_var2 “x”)) (new_num2 1))) (new_num2 2) let e_test2 = test2#eval
[]</p>
<pre><code>
### 11.6 OOP Non-Solution: The Visitor Pattern

The **visitor pattern** is a design pattern that separates an algorithm from the object structure on which it operates. This allows adding new operations to existing object structures without modifying those structures.

**Non-solution penalty points:**

- Adding new functionality requires modifying old code (the abstract visitor class)
- No deep pattern matching
- Uses mutable state for returning results

**Verdict:** Poor solution, better than approaches we considered so far, and worse than approaches we consider next.

```ocaml env=sol4
type &#39;visitor visitable = &lt; accept : &#39;visitor -&gt; unit &gt;
(* The variants need be visitable *)
(* We store the computation as side effect because of the difficulty *)
(* to keep the visitor polymorphic but have the result type depend on the visitor *)

type var_name = string

class [&#39;visitor] var (v : var_name) =
object (self)  (* The &#39;visitor will determine the (sub)language *)
               (* to which a given var variant belongs *)
  method v = v
  method accept : &#39;visitor -&gt; unit =  (* The visitor pattern inverts the way *)
    fun visitor -&gt; visitor#visitVar self  (* pattern matching proceeds: the variant *)
end  (* selects the computation *)
let new_var v = (new var v :&gt; &#39;a visitable)

class [&#39;visitor] abs (v : var_name) (body : &#39;visitor visitable) =
object (self)
  method v = v
  method body = body
  method accept : &#39;visitor -&gt; unit =
    fun visitor -&gt; visitor#visitAbs self
end
let new_abs v body = (new abs v body :&gt; &#39;a visitable)

class [&#39;visitor] app (f : &#39;visitor visitable) (arg : &#39;visitor visitable) =
object (self)
  method f = f
  method arg = arg
  method accept : &#39;visitor -&gt; unit =
    fun visitor -&gt; visitor#visitApp self
end
let new_app f arg = (new app f arg :&gt; &#39;a visitable)

class virtual [&#39;visitor] lambda_visit =
object
  method virtual visitVar : &#39;visitor var -&gt; unit
  method virtual visitAbs : &#39;visitor abs -&gt; unit
  method virtual visitApp : &#39;visitor app -&gt; unit
end

let gensym = let n = ref 0 in fun () -&gt; incr n; &quot;_&quot; ^ string_of_int !n

class [&#39;visitor] eval_lambda
  (subst : (var_name * &#39;visitor visitable) list)
  (result : &#39;visitor visitable ref) =
object (self)
  inherit [&#39;visitor] lambda_visit
  val mutable subst = subst
  val mutable beta_redex : (var_name * &#39;visitor visitable) option = None
  method visitVar var =
    beta_redex &lt;- None;
    try result := List.assoc var#v subst
    with Not_found -&gt; result := (var :&gt; &#39;visitor visitable)
  method visitAbs abs =
    let v&#39; = gensym () in
    let orig_subst = subst in
    subst &lt;- (abs#v, new_var v&#39;)::subst;
    (abs#body)#accept self;
    let body&#39; = !result in
    subst &lt;- orig_subst;
    beta_redex &lt;- Some (v&#39;, body&#39;);
    result := new_abs v&#39; body&#39;
  method visitApp app =
    app#arg#accept self;
    let arg&#39; = !result in
    app#f#accept self;
    let f&#39; = !result in
    match beta_redex with
    | Some (v&#39;, body&#39;) -&gt;
      beta_redex &lt;- None;
      let orig_subst = subst in
      subst &lt;- (v&#39;, arg&#39;)::subst;
      body&#39;#accept self;
      subst &lt;- orig_subst
    | None -&gt; result := new_app f&#39; arg&#39;
end

class [&#39;visitor] freevars_lambda (result : var_name list ref) =
object (self)
  inherit [&#39;visitor] lambda_visit
  method visitVar var =
    result := var#v :: !result
  method visitAbs abs =
    (abs#body)#accept self;
    result := List.filter (fun v&#39; -&gt; v&#39; &lt;&gt; abs#v) !result
  method visitApp app =
    app#arg#accept self; app#f#accept self
end

type lambda_visit_t = lambda_visit_t lambda_visit
type lambda_t = lambda_visit_t visitable

let eval1 (e : lambda_t) subst : lambda_t =
  let result = ref (new_var &quot;&quot;) in
  e#accept (new eval_lambda subst result :&gt; lambda_visit_t);
  !result

let freevars1 (e : lambda_t) =
  let result = ref [] in
  e#accept (new freevars_lambda result);
  !result

let test1 =
  (new_app (new_abs &quot;x&quot; (new_var &quot;x&quot;)) (new_var &quot;y&quot;) :&gt; lambda_t)
let e_test = eval1 test1 []
let fv_test = freevars1 test1</code></pre>
<p>Extending with arithmetic expressions follows a similar pattern, and
the merged language visitor inherits from both <code>lambda_visit</code>
and <code>expr_visit</code>.</p>
<h3 id="polymorphic-variants">11.7 Polymorphic Variants</h3>
<p><strong>Polymorphic variants</strong> provide a flexible alternative
to standard variants. They allow combining types from different sources
without explicitly defining a common parent type.</p>
<p><strong>Penalty points:</strong></p>
<ul>
<li>Requires explicit type annotations more often</li>
<li>Requires “tying the recursive knots” for types, e.g.,
<code>type lambda_t = lambda_t lambda</code></li>
<li>Some loss of type-level distinction between sub-languages</li>
</ul>
<p><strong>Verdict:</strong> A flexible solution, better than the
previous approaches but still not perfect.</p>
<p>``<code>ocaml env=sol5 type var = [</code>Var of string]</p>
<p>let eval_var sub (`Var s as v : var) = try List.assoc s sub with
Not_found -&gt; v</p>
<p>type ’a lambda = [<code>Var of string |</code>Abs of string * ’a |
`App of ’a * ’a]</p>
<p>let gensym = let n = ref 0 in fun () -&gt; incr n; “_” ^
string_of_int !n</p>
<p>let eval_lambda eval_rec subst : ‘a lambda -&gt; ’a = function | #var
as v -&gt; eval_var subst v |
<code>App (l1, l2) -&gt;     let l2' = eval_rec subst l2 in     (match eval_rec subst l1 with     |</code>Abs
(s, body) -&gt; eval_rec [s, l2’] body | l1’ -&gt;
<code>App (l1', l2'))   |</code>Abs (s, l1) -&gt; let s’ = gensym () in
<code>Abs (s', eval_rec ((s,</code>Var s’)::subst) l1)</p>
<p>let freevars_lambda freevars_rec : ’a lambda -&gt; ’b = function |
<code>Var v -&gt; [v]   |</code>App (l1, l2) -&gt; freevars_rec l1 @
freevars_rec l2 | `Abs (s, l1) -&gt; List.filter (fun v -&gt; v &lt;&gt;
s) (freevars_rec l1)</p>
<p>type lambda_t = lambda_t lambda</p>
<p>let rec eval1 subst e : lambda_t = eval_lambda eval1 subst e let rec
freevars1 (e : lambda_t) = freevars_lambda freevars1 e</p>
<p>let test1 = (<code>App (</code>Abs (“x”, <code>Var "x"),</code>Var
“y”) :&gt; lambda_t) let e_test = eval1 [] test1 let fv_test = freevars1
test1</p>
<pre><code>
The arithmetic expression sub-language:

```ocaml env=sol5
type &#39;a expr =
  [`Var of string | `Num of int | `Add of &#39;a * &#39;a | `Mult of &#39;a * &#39;a]

let map_expr (f : _ -&gt; &#39;a) : &#39;a expr -&gt; &#39;a = function
  | #var as v -&gt; v
  | `Num _ as n -&gt; n
  | `Add (e1, e2) -&gt; `Add (f e1, f e2)
  | `Mult (e1, e2) -&gt; `Mult (f e1, f e2)

let eval_expr eval_rec subst (e : &#39;a expr) : &#39;a =
  match map_expr (eval_rec subst) e with
  | #var as v -&gt; eval_var subst v
  | `Add (`Num m, `Num n) -&gt; `Num (m + n)
  | `Mult (`Num m, `Num n) -&gt; `Num (m * n)
  | e -&gt; e

let freevars_expr freevars_rec : &#39;a expr -&gt; &#39;b = function
  | `Var v -&gt; [v]
  | `Num _ -&gt; []
  | `Add (e1, e2) | `Mult (e1, e2) -&gt; freevars_rec e1 @ freevars_rec e2

type expr_t = expr_t expr

let rec eval2 subst e : expr_t = eval_expr eval2 subst e
let rec freevars2 (e : expr_t) = freevars_expr freevars2 e

let test2 = (`Add (`Mult (`Num 3, `Var &quot;x&quot;), `Num 1) : expr_t)
let e_test2 = eval2 [&quot;x&quot;, `Num 2] test2
let fv_test2 = freevars2 test2</code></pre>
<p>Merging the sub-languages:</p>
<p>```ocaml env=sol5 type ’a lexpr = [’a lambda | ’a expr]</p>
<p>let eval_lexpr eval_rec subst : ’a lexpr -&gt; ’a = function |
#lambda as x -&gt; eval_lambda eval_rec subst x | #expr as x -&gt;
eval_expr eval_rec subst x</p>
<p>let freevars_lexpr freevars_rec : ’a lexpr -&gt; ’b = function |
#lambda as x -&gt; freevars_lambda freevars_rec x | #expr as x -&gt;
freevars_expr freevars_rec x</p>
<p>type lexpr_t = lexpr_t lexpr</p>
<p>let rec eval3 subst e : lexpr_t = eval_lexpr eval3 subst e let rec
freevars3 (e : lexpr_t) = freevars_lexpr freevars3 e</p>
<p>let test3 = (<code>App (</code>Abs (“x”, <code>Add (</code>Mult
(<code>Num 3,</code>Var “x”), <code>Num 1)),</code>Num 2) : lexpr_t) let
e_test3 = eval3 [] test3 let fv_test3 = freevars3 test3 let e_old_test =
eval3 [] (test2 :&gt; lexpr_t) let fv_old_test = freevars3 (test2 :&gt;
lexpr_t)</p>
<pre><code>
### 11.8 Polymorphic Variants with Recursive Modules

Using recursive modules, we can clean up the confusing or cluttering aspects of tying the recursive knots: type variables and recursive call arguments.

We need **private types**, which for objects and polymorphic variants means *private rows*. We can conceive of open row types, e.g., `[&gt; \`Int of int | \`String of string]` as using a *row variable*, e.g., `&#39;a`:
</code></pre>
<p>[<code>Int of int |</code>String of string | ’a]</p>
<pre><code>
and then of private row types as abstracting the row variable:
</code></pre>
<p>type ’row t = [<code>Int of int |</code>String of string | ’row]</p>
<pre><code>
But the actual formalization of private row types is more complex.

**Penalty points:**

- We still need to tie the recursive knots for types, for example `private [&gt; &#39;a lambda] as &#39;a`
- There can be slight time costs due to the use of functors and dispatch on merging of sub-languages

**Verdict:** A clean solution, best place.

```ocaml env=sol6
type var = [`Var of string]

let eval_var subst (`Var s as v : var) =
  try List.assoc s subst with Not_found -&gt; v

type &#39;a lambda =
  [`Var of string | `Abs of string * &#39;a | `App of &#39;a * &#39;a]

module type Eval =
sig type exp val eval : (string * exp) list -&gt; exp -&gt; exp end

module LF(X : Eval with type exp = private [&gt; &#39;a lambda] as &#39;a) =
struct
  type exp = X.exp lambda

  let gensym = let n = ref 0 in fun () -&gt; incr n; &quot;_&quot; ^ string_of_int !n

  let eval subst : exp -&gt; X.exp = function
    | #var as v -&gt; eval_var subst v
    | `App (l1, l2) -&gt;
      let l2&#39; = X.eval subst l2 in
      (match X.eval subst l1 with
      | `Abs (s, body) -&gt;
        X.eval [s, l2&#39;] body
      | l1&#39; -&gt; `App (l1&#39;, l2&#39;))
    | `Abs (s, l1) -&gt;
      let s&#39; = gensym () in
      `Abs (s&#39;, X.eval ((s, `Var s&#39;)::subst) l1)
end
module rec Lambda : (Eval with type exp = Lambda.exp lambda) =
  LF(Lambda)

module type FreeVars =
sig type exp val freevars : exp -&gt; string list end

module LFVF(X : FreeVars with type exp = private [&gt; &#39;a lambda] as &#39;a) =
struct
  type exp = X.exp lambda

  let freevars : exp -&gt; &#39;b = function
    | `Var v -&gt; [v]
    | `App (l1, l2) -&gt; X.freevars l1 @ X.freevars l2
    | `Abs (s, l1) -&gt;
      List.filter (fun v -&gt; v &lt;&gt; s) (X.freevars l1)
end
module rec LambdaFV : (FreeVars with type exp = LambdaFV.exp lambda) =
  LFVF(LambdaFV)

let test1 = (`App (`Abs (&quot;x&quot;, `Var &quot;x&quot;), `Var &quot;y&quot;) : Lambda.exp)
let e_test = Lambda.eval [] test1
let fv_test = LambdaFV.freevars test1</code></pre>
<p>The arithmetic expression sub-language:</p>
<p>``<code>ocaml env=sol6 type 'a expr =   [</code>Var of string |
<code>Num of int |</code>Add of ’a * ’a | `Mult of ’a * ’a]</p>
<p>module type Operations = sig include Eval include FreeVars with type
exp := exp end</p>
<p>module EF(X : Operations with type exp = private [&gt; ’a expr] as
’a) = struct type exp = X.exp expr</p>
<p>let map_expr f = function | #var as v -&gt; v |
<code>Num _ as n -&gt; n     |</code>Add (e1, e2) -&gt;
<code>Add (f e1, f e2)     |</code>Mult (e1, e2) -&gt; `Mult (f e1, f
e2)</p>
<p>let eval subst (e : exp) : X.exp = match map_expr (X.eval subst) e
with | #var as v -&gt; eval_var subst v | <code>Add (</code>Num m,
<code>Num n) -&gt;</code>Num (m + n) | <code>Mult (</code>Num m,
<code>Num n) -&gt;</code>Num (m * n) | e -&gt; e</p>
<p>let freevars : exp -&gt; ’b = function |
<code>Var v -&gt; [v]     |</code>Num _ -&gt; [] |
<code>Add (e1, e2) |</code>Mult (e1, e2) -&gt; X.freevars e1 @
X.freevars e2 end module rec Expr : (Operations with type exp = Expr.exp
expr) = EF(Expr)</p>
<p>let test2 = (<code>Add (</code>Mult (<code>Num 3,</code>Var “x”),
<code>Num 1) : Expr.exp) let e_test2 = Expr.eval ["x",</code>Num 2]
test2 let fvs_test2 = Expr.freevars test2</p>
<pre><code>
Merging the sub-languages:

```ocaml env=sol6
type &#39;a lexpr = [&#39;a lambda | &#39;a expr]

module LEF(X : Operations with type exp = private [&gt; &#39;a lexpr] as &#39;a) =
struct
  type exp = X.exp lexpr
  module LambdaX = LF(X)
  module LambdaFVX = LFVF(X)
  module ExprX = EF(X)

  let eval subst : exp -&gt; X.exp = function
    | #LambdaX.exp as x -&gt; LambdaX.eval subst x
    | #ExprX.exp as x -&gt; ExprX.eval subst x

  let freevars : exp -&gt; &#39;b = function
    | #lambda as x -&gt; LambdaFVX.freevars x  (* Either of #lambda or #LambdaX.exp is fine *)
    | #expr as x -&gt; ExprX.freevars x  (* Either of #expr or #ExprX.exp is fine *)
end
module rec LExpr : (Operations with type exp = LExpr.exp lexpr) =
  LEF(LExpr)

let test3 =
  (`App (`Abs (&quot;x&quot;, `Add (`Mult (`Num 3, `Var &quot;x&quot;), `Num 1)),
         `Num 2) : LExpr.exp)
let e_test3 = LExpr.eval [] test3
let fv_test3 = LExpr.freevars test3
let e_old_test = LExpr.eval [] (test2 :&gt; LExpr.exp)
let fv_old_test = LExpr.freevars (test2 :&gt; LExpr.exp)</code></pre>
<h3 id="parser-combinators">11.9 Parser Combinators</h3>
<p>Large-scale parsing in OCaml is typically done using external
languages OCamlLex and Menhir. But it is convenient to have parsers
written directly in OCaml.</p>
<p>Language <strong>combinators</strong> are ways of defining languages
by composing definitions of smaller languages. For example, the
combinators of the <strong>Extended Backus-Naur Form</strong> notation
are:</p>
<ul>
<li><strong>Concatenation</strong>: <span class="math inline">S = A,
B</span> stands for <span class="math inline">S = \{ ab \mid a \in A, b
\in B \}</span></li>
<li><strong>Alternation</strong>: <span class="math inline">S = A \mid
B</span> stands for <span class="math inline">S = \{ a \mid a \in A \vee
a \in B \}</span></li>
<li><strong>Option</strong>: <span class="math inline">S = [A]</span>
stands for <span class="math inline">S = \{ \epsilon \} \cup A</span>,
where <span class="math inline">\epsilon</span> is an empty string</li>
<li><strong>Repetition</strong>: <span class="math inline">S = \{ A
\}</span> stands for <span class="math inline">S = \{ \epsilon \} \cup
\{ as \mid a \in A, s \in S \}</span></li>
<li><strong>Terminal string</strong>: <span class="math inline">S =
``a&quot;</span> stands for <span class="math inline">S = \{ a
\}</span></li>
</ul>
<p>Parsers implemented directly in a functional programming paradigm are
functions from character streams to the parsed values. Algorithmically
they are <strong>recursive descent parsers</strong>.</p>
<p><strong>Parser combinators</strong> approach builds parsers as
<strong>monad plus</strong> values:</p>
<ul>
<li><strong>Bind</strong>:
<code>val (&gt;&gt;=) : 'a parser -&gt; ('a -&gt; 'b parser) -&gt; 'b parser</code>
<ul>
<li><code>p &gt;&gt;= f</code> is a parser that first parses
<code>p</code>, and makes the result available for parsing
<code>f</code></li>
</ul></li>
<li><strong>Return</strong>:
<code>val return : 'a -&gt; 'a parser</code>
<ul>
<li><code>return x</code> parses an empty string, symbolically <span
class="math inline">S = \{ \epsilon \}</span>, and returns
<code>x</code></li>
</ul></li>
<li><strong>MZero</strong>: <code>val fail : 'a parser</code>
<ul>
<li><code>fail</code> fails to parse anything, symbolically <span
class="math inline">S = \varnothing = \{ \}</span></li>
</ul></li>
<li><strong>MPlus</strong>:
<code>val (&lt;|&gt;) : 'a parser -&gt; 'a parser -&gt; 'a parser</code>
<ul>
<li><code>p &lt;|&gt; q</code> tries <code>p</code>, and if
<code>p</code> succeeds, its result is returned, otherwise the parser
<code>q</code> is used</li>
</ul></li>
</ul>
<p>The only non-monad-plus operation that has to be built into the monad
is some way to consume a single character from the input stream, for
example:</p>
<ul>
<li><code>val satisfy : (char -&gt; bool) -&gt; char parser</code>
<ul>
<li><code>satisfy (fun c -&gt; c = 'a')</code> consumes the character
“a” from the input stream and returns it; if the input stream starts
with a different character, this parser fails</li>
</ul></li>
</ul>
<p>Ordinary monadic recursive descent parsers <strong>do not
allow</strong> <em>left-recursion</em>: if a cycle of calls not
consuming any character can be entered when a parse failure should
occur, the cycle will keep repeating.</p>
<p>For example, if we define numbers <span class="math inline">N := D
\mid N D</span>, where <span class="math inline">D</span> stands for
digits, then a stack of uses of the rule <span class="math inline">N
\rightarrow N D</span> will build up when the next character is not a
digit.</p>
<p>On the other hand, rules can share common prefixes.</p>
<h3 id="parser-combinators-implementation">11.10 Parser Combinators:
Implementation</h3>
<p>The parser monad is actually a composition of two monads:</p>
<ul>
<li>The <strong>state monad</strong> for storing the stream of
characters that remain to be parsed</li>
<li>The <strong>backtracking monad</strong> for handling parse failures
and ambiguities</li>
</ul>
<p>Alternatively, one can split the state monad into a reader monad with
the parsed string, and a state monad with the parsing position.</p>
<p>We experiment with a different approach to monad-plus:
<strong>lazy-monad-plus</strong>:</p>
<pre><code>val mplus : &#39;a monad -&gt; &#39;a monad Lazy.t -&gt; &#39;a monad</code></pre>
<h4 id="implementation-of-lazy-monad-plus">Implementation of
lazy-monad-plus</h4>
<p>First a brief reminder about monads with backtracking. Starting with
an operation from <code>MonadPlusOps</code>:</p>
<p><code>ocaml skip let msum_map f l =   List.fold_left  (* Folding left reverses the apparent order of composition *)     (fun acc a -&gt; mplus acc (lazy (f a))) mzero l  (* order from l is preserved *)</code></p>
<p>The implementation of the lazy-monad-plus using lazy lists:</p>
<p>```ocaml env=parsec type ’a llist = LNil | LCons of ’a * ’a llist
Lazy.t</p>
<p>let rec ltake n = function | LCons (a, l) when n &gt; 1 -&gt;
a::(ltake (n-1) (Lazy.force l)) | LCons (a, l) when n = 1 -&gt; [a] (*
Avoid forcing the tail if not needed *) | _ -&gt; []</p>
<p>let rec lappend l1 l2 = match l1 with LNil -&gt; Lazy.force l2 |
LCons (hd, tl) -&gt; LCons (hd, lazy (lappend (Lazy.force tl) l2))</p>
<p>let rec lconcat_map f = function | LNil -&gt; LNil | LCons (a, l)
-&gt; lappend (f a) (lazy (lconcat_map f (Lazy.force l)))</p>
<p>module LListM = MonadPlus (struct type ’a t = ’a llist let bind a b =
lconcat_map b a let return a = LCons (a, lazy LNil) let mzero = LNil let
mplus = lappend end)</p>
<pre><code>
#### The Parsec Monad

File `Parsec.ml`:

```ocaml env=parsec
module type PARSE = sig
  type &#39;a backtracking_monad  (* Name for the underlying monad-plus *)
  type &#39;a parsing_state = int -&gt; (&#39;a * int) backtracking_monad  (* State: position *)
  type &#39;a t = string -&gt; &#39;a parsing_state  (* Reader for the parsed text *)
  include MONAD_PLUS_OPS
  val (&lt;|&gt;) : &#39;a monad -&gt; &#39;a monad Lazy.t -&gt; &#39;a monad  (* A synonym for mplus *)
  val run : &#39;a monad -&gt; &#39;a t
  val runT : &#39;a monad -&gt; string -&gt; int -&gt; &#39;a backtracking_monad
  val satisfy : (char -&gt; bool) -&gt; char monad  (* Consume a character of the class *)
  val end_of_text : unit monad  (* Check for end of the processed text *)
end

module ParseT (MP : MONAD_PLUS_OPS) :
  PARSE with type &#39;a backtracking_monad := &#39;a MP.monad =
struct
  type &#39;a backtracking_monad = &#39;a MP.monad
  type &#39;a parsing_state = int -&gt; (&#39;a * int) MP.monad
  module M = struct
    type &#39;a t = string -&gt; &#39;a parsing_state
    let return a = fun s p -&gt; MP.return (a, p)
    let bind m b = fun s p -&gt;
      MP.bind (m s p) (fun (a, p&#39;) -&gt; b a s p&#39;)
    let mzero = fun _ p -&gt; MP.mzero
    let mplus ma mb = fun s p -&gt;
      MP.mplus (ma s p) (lazy (Lazy.force mb s p))
  end
  include M
  include MonadPlusOps(M)
  let (&lt;|&gt;) ma mb = mplus ma mb
  let runT m s p = MP.lift fst (m s p)
  let satisfy f s p =
    if p &lt; String.length s &amp;&amp; f s.[p]  (* Consuming a character means accessing it *)
    then MP.return (s.[p], p + 1) else MP.mzero  (* and advancing the parsing position *)
  let end_of_text s p =
    if p &gt;= String.length s then MP.return ((), p) else MP.mzero
end</code></pre>
<h4 id="additional-parser-operations">Additional Parser Operations</h4>
<p>```ocaml env=parsec module type PARSE_OPS = sig include PARSE val
many : ’a monad -&gt; ’a list monad val opt : ’a monad -&gt; ’a option
monad val (?|) : ’a monad -&gt; ’a option monad val seq : ’a monad -&gt;
’b monad Lazy.t -&gt; (’a * ’b) monad (* Exercise: why lazy here? <em>)
val (&lt;</em>&gt;) : ’a monad -&gt; ’b monad Lazy.t -&gt; (’a * ’b)
monad (* Synonym for seq <em>) val lowercase : char monad val uppercase
: char monad val digit : char monad val alpha : char monad val alphanum
: char monad val literal : string -&gt; unit monad (</em> Consume
characters of the given string <em>) val (&lt;&lt;&gt;) : string -&gt;
’a monad -&gt; ’a monad (</em> Prefix and postfix keywords *) val
(&lt;&gt;&gt;) : ’a monad -&gt; string -&gt; ’a monad end</p>
<p>module ParseOps (R : MONAD_PLUS_OPS) (P : PARSE with type ’a
backtracking_monad := ’a R.monad) : PARSE_OPS with type ’a
backtracking_monad := ’a R.monad = struct include P let rec many p =
(let* r = p in let* rs = many p in return (r::rs)) ++ lazy (return [])
let opt p = (let* x = p in return (Some x)) ++ lazy (return None) let
(?|) p = opt p let seq p q = let* x = p in let* y = Lazy.force q in
return (x, y) let (&lt;<em>&gt;) p q = seq p q let lowercase = satisfy
(fun c -&gt; c &gt;= ‘a’ &amp;&amp; c &lt;= ‘z’) let uppercase = satisfy
(fun c -&gt; c &gt;= ‘A’ &amp;&amp; c &lt;= ‘Z’) let digit = satisfy
(fun c -&gt; c &gt;= ‘0’ &amp;&amp; c &lt;= ‘9’) let alpha = lowercase
++ lazy uppercase let alphanum = alpha ++ lazy digit let literal l = let
rec loop pos = if pos = String.length l then return () else satisfy (fun
c -&gt; c = l.[pos]) &gt;&gt;- loop (pos + 1) in loop 0 let
(&lt;&lt;&gt;) bra p = literal bra &gt;&gt;- p let (&lt;&gt;&gt;) p ket
= let</em> x = p in literal ket &gt;&gt;- return x end</p>
<pre><code>
### 11.11 Parser Combinators: Tying the Recursive Knot

File `PluginBase.ml`:

```ocaml env=parsec
module ParseM = ParseOps (LListM) (ParseT (LListM))
open ParseM

let grammar_rules : (int monad -&gt; int monad) list ref = ref []

let get_language () : int monad =
  let rec result =
    lazy
      (List.fold_left
         (fun acc lang -&gt; acc &lt;|&gt; lazy (lang (Lazy.force result)))
          mzero !grammar_rules) in
  let* r = Lazy.force result in
  let* () = end_of_text in return r  (* Ensure we parse the whole text *)</code></pre>
<h3 id="parser-combinators-dynamic-code-loading">11.12 Parser
Combinators: Dynamic Code Loading</h3>
<p>File <code>PluginRun.ml</code>:</p>
<p>```ocaml skip let load_plug fname : unit = let fname =
Dynlink.adapt_filename fname in if Sys.file_exists fname then try
Dynlink.loadfile fname with | (Dynlink.Error err) as e -&gt;
Printf.printf “loading plugin: %s%!” (Dynlink.error_message err); raise
e | e -&gt; Printf.printf “error while loading plugin%!” else (
Printf.printf “file %s does not exist%!” fname; exit (-1))</p>
<p>let () = for i = 2 to Array.length Sys.argv - 1 do load_plug
Sys.argv.(i) done; let lang = PluginBase.get_language () in let result =
Monad.LListM.run (PluginBase.ParseM.runT lang Sys.argv.(1) 0) in match
Monad.ltake 1 result with | [] -&gt; Printf.printf “error%!” | r::_
-&gt; Printf.printf “: %d%!” r</p>
<pre><code>
### 11.13 Parser Combinators: Toy Example

File `Plugin1.ml`:

```ocaml env=parsec
open ParseM
let digit_of_char d = int_of_char d - int_of_char &#39;0&#39;

let number _ =  (* Numbers: N := D N | D where D is digits *)
  let rec num =
    lazy ((let* d = digit in
           let* (n, b) = Lazy.force num in
           return (digit_of_char d * b + n, b * 10))
      &lt;|&gt; lazy (let* d = digit in return (digit_of_char d, 10))) in
  Lazy.force num &gt;&gt;| fst

let addition lang =  (* Addition rule: S -&gt; (S + S) *)
  (* Requiring a parenthesis ( turns the rule into non-left-recursive *)
  let* () = literal &quot;(&quot; in
  let* n1 = lang in
  let* () = literal &quot;+&quot; in
  let* n2 = lang in
  let* () = literal &quot;)&quot; in
  return (n1 + n2)

let () = grammar_rules := number :: addition :: !grammar_rules</code></pre>
<p>File <code>Plugin2.ml</code>:</p>
<p>```ocaml env=parsec open ParseM</p>
<p>let multiplication lang = (* Multiplication rule: S -&gt; (S * S)
<em>) let</em> () = literal “(” in let* n1 = lang in let* () = literal
“<em>” in let</em> n2 = lang in let* () = literal”)” in return (n1 *
n2)</p>
<p>let () = grammar_rules := multiplication :: !grammar_rules ```</p>
<h3 id="exercises-7">11.14 Exercises</h3>
<p><strong>Exercise 1:</strong> Implement the <code>string_of_</code>
functions or methods, covering all data cases, corresponding to the
<code>eval_</code> functions in at least two examples from the lecture,
including both an object-based example and a variant-based example
(either standard, or polymorphic, or extensible variants).</p>
<p><strong>Exercise 2:</strong> Split at least one of the examples from
the previous exercise into multiple files and demonstrate separate
compilation.</p>
<p><strong>Exercise 3:</strong> Can we drop the tags
<code>Lambda_t</code>, <code>Expr_t</code> and <code>LExpr_t</code> used
in the examples based on standard variants (file
<code>FP_ADT.ml</code>)? When using polymorphic variants, such tags are
not needed.</p>
<p><strong>Exercise 4:</strong> Factor-out the sub-language consisting
only of variables, thus eliminating the duplication of tags
<code>VarL</code>, <code>VarE</code> in the examples based on standard
variants (file <code>FP_ADT.ml</code>).</p>
<p><strong>Exercise 5:</strong> Come up with a scenario where the
extensible variant types-based solution leads to a non-obvious or hard
to locate bug.</p>
<p><strong>Exercise 6:</strong> Re-implement the direct object-based
solution to the expression problem (file <code>Objects.ml</code>) to
make it more satisfying. For example, eliminate the need for some of the
<code>rename</code>, <code>apply</code>, <code>compute</code>
methods.</p>
<p><strong>Exercise 7:</strong> Re-implement the visitor pattern-based
solution to the expression problem (file <code>Visitor.ml</code>) in a
functional way, i.e., replace the mutable fields <code>subst</code> and
<code>beta_redex</code> in the <code>eval_lambda</code> class with a
different solution to the problem of treating <code>abs</code> and
non-<code>abs</code> expressions differently.</p>
<p><strong>Exercise 8:</strong> Extend the sub-language
<code>expr_visit</code> with variables, and add to arguments of the
evaluation constructor <code>eval_expr</code> the substitution. Handle
the problem of potentially duplicate fields <code>subst</code>. (One
approach might be to use ideas from exercise 6.)</p>
<p><strong>Exercise 9:</strong> Implement the following modifications to
the example from the file <code>PolyV.ml</code>:</p>
<ol type="1">
<li>Factor-out the sub-language of variables, around the already present
<code>var</code> type.</li>
<li>Open the types of functions <code>eval3</code>,
<code>freevars3</code> and other functions as required, so that explicit
subtyping, e.g., in <code>eval3 [] (test2 :&gt; lexpr_t)</code>, is not
necessary.</li>
<li>Remove the double-dispatch currently in <code>eval_lexpr</code> and
<code>freevars_lexpr</code>, by implementing a cascading design rather
than a “divide-and-conquer” design.</li>
</ol>
<p><strong>Exercise 10:</strong> Streamline the solution
<code>PolyRecM.ml</code> by extending the language of <span
class="math inline">\lambda</span>-expressions with arithmetic
expressions, rather than defining the sub-languages separately and then
merging them. See slide on page 15 of Jacques Garrigue <em>Structural
Types, Recursive Modules, and the Expression Problem</em>.</p>
<p><strong>Exercise 11:</strong> Transform a parser monad, or rewrite
the parser monad transformer, by adding state for the line and column
numbers.</p>
<p><strong>Exercise 12:</strong> Implement <code>_of_string</code>
functions as parser combinators on top of the example
<code>PolyRecM.ml</code>. Sections 4.3 and 6.2 of <em>Monadic Parser
Combinators</em> by Graham Hutton and Erik Meijer might be helpful.
Split the result into multiple files as in Exercise 2 and demonstrate
dynamic loading of code.</p>
<p><strong>Exercise 13:</strong> What are the benefits and drawbacks of
our lazy-monad-plus (built on top of <em>odd lazy lists</em>) approach,
as compared to regular monad-plus built on top of <em>even lazy
lists</em>? To additionally illustrate your answer:</p>
<ol type="1">
<li>Rewrite the parser combinators example to use regular monad-plus and
even lazy lists.</li>
<li>Select one example from Lecture 8 and rewrite it using
lazy-monad-plus and odd lazy lists.</li>
</ol>
</body>
</html>
