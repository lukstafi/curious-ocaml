\documentclass{article}
\usepackage[english]{babel}
\usepackage{geometry,amsmath,theorem}
\geometry{letterpaper}

%%%%%%%%%% Start TeXmacs macros
\catcode`\>=\active \def>{
\fontencoding{T1}\selectfont\symbol{62}\fontencoding{\encodingdefault}}
\newcommand{\tmem}[1]{{\em #1\/}}
\newcommand{\tmname}[1]{\textsc{#1}}
\newcommand{\tmverbatim}[1]{\text{{\ttfamily{#1}}}}
{\theorembodyfont{\rmfamily\small}\newtheorem{exercise}{Exercise}}
%%%%%%%%%% End TeXmacs macros

\begin{document}

{\class{Functional Programming}}{\tmname{{\L}ukasz Stafiniak}}

{\title{The Expression Problem}}

\begin{exercise}
  \label{ExStringOf}Implement the \tmverbatim{string\_of\_} functions or
  methods, covering all data cases, corresponding to the \tmverbatim{eval\_}
  functions in at least two examples from the lecture, including both an
  object-based example and a variant-based example (either standard, or
  polymorphic, or extensible variants).
\end{exercise}

\begin{exercise}
  \label{ExSplitFiles}Split at least one of the examples from the previous
  exercise into multiple files and demonstrate separate compilation.
\end{exercise}

\begin{exercise}
  Can we drop the tags \tmverbatim{Lambda\_t}, \tmverbatim{Expr\_t} and
  \tmverbatim{LExpr\_t} used in the examples based on standard variants (file
  \tmverbatim{FP\_ADT.ml})? When using polymorphic variants, such tags are not
  needed.
\end{exercise}

\begin{exercise}
  Factor-out the sub-language consisting only of variables, thus eliminating
  the duplication of tags \tmverbatim{VarL}, \tmverbatim{VarE} in the examples
  based on standard variants (file \tmverbatim{FP\_ADT.ml}).
\end{exercise}

\begin{exercise}
  Come up with a scenario where the extensible variant types-based solution
  leads to a non-obvious or hard to locate bug.
\end{exercise}

\begin{exercise}
  * Re-implement the direct object-based solution to the expression problem
  (file \tmverbatim{Objects.ml}) to make it more satisfying. For example,
  eliminate the need for some of the \tmverbatim{rename}, \tmverbatim{apply},
  \tmverbatim{compute} methods.
\end{exercise}

\begin{exercise}
  Re-implement the visitor pattern-based solution to the expression problem
  (file \tmverbatim{Visitor.ml}) in a functional way, i.e. replace the mutable
  fields \tmverbatim{subst} and \tmverbatim{beta\_redex} in the
  \tmverbatim{eval\_lambda} class with a different solution to the problem of
  treating \tmverbatim{abs} and non-\tmverbatim{abs} expressions differently.
  
  * See if you can replace the reference cells \tmverbatim{result} in
  \tmverbatim{eval$N$} and \tmverbatim{freevars$N$} functions (for
  \tmverbatim{$N =$1,2,3}) with a different solution to the problem of
  polymorphism wrt. the type of the computed values. 
\end{exercise}

\begin{exercise}
  Extend the sub-language \tmverbatim{expr\_visit} with variables, and add to
  arguments of the evaluation constructor \tmverbatim{eval\_expr} the
  substitution. Handle the problem of potentially duplicate fields
  \tmverbatim{subst}. (One approach might be to use ideas from exercise 6.)
\end{exercise}

\begin{exercise}
  Impement the following modifications to the example from the file
  \tmverbatim{PolyV.ml}:
  \begin{enumerate}
    \item Factor-out the sub-language of variables, around the already present
    \tmverbatim{var} type.
    
    \item Open the types of functions \tmverbatim{eval3},
    \tmverbatim{freevars3} and other functions as required, so that explicit
    subtyping, e.g. in {\hlstd{eval3\enspace}}{\hlopt{[]\enspace
    (}}{\hlstd{test2\enspace}}{\hlopt{:>\enspace}}{\hlstd{lexpr{\textunderscore}t}}{\hlopt{)}},
    is not necessary.
    
    \item Remove the double-dispatch currently in \tmverbatim{eval\_lexpr} and
    \tmverbatim{freevars\_lexpr}, by implementing a cascading design rather
    than a ``divide-and-conquer'' design.
  \end{enumerate}
\end{exercise}

\begin{exercise}
  Streamline the solution \tmverbatim{PolyRecM.ml} by extending the language
  of $\lambda$-expressions with arithmetic expressions, rather than defining
  the sub-languages separately and then merging them. See slide on page 15 of
  Jacques Garrigue {\tmem{Structural Types, Recursive Modules, and the
  Expression Problem}}.
\end{exercise}

\begin{exercise}
  Transform a parser monad, or rewrite the parser monad transformer, by adding
  state for the line and column numbers.
  
  * How to implement a monad transformer transformer in OCaml?
\end{exercise}

\begin{exercise}
  Implement \tmverbatim{\_of\_string} functions as parser combinators on top
  of the example \tmverbatim{PolyRecM.ml}. Sections 4.3 and 6.2 of
  {\tmem{Monadic Parser Combinators}} by Graham Hutton and Erik Meijer might
  be helpful. Split the result into multiple files as in Exercise
  \ref{ExSplitFiles} and demonstrate dynamic loading of code.
\end{exercise}

\begin{exercise}
  What are the benefits and drawbacks of our lazy-monad-plus (built on top of
  {\tmem{odd lazy lists}}) approach, as compared to regular monad-plus built
  on top of {\tmem{even lazy lists}}? To additionally illustrate your answer:
  \begin{enumerate}
    \item Rewrite the parser combinators example to use regular monad-plus and
    even lazy lists.
    
    \item Select one example from Lecture 8 and rewrite it using
    lazy-monad-plus and odd lazy lists.
  \end{enumerate}
\end{exercise}

\

\end{document}
