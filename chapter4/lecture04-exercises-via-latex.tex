\documentclass{article}
\usepackage[english]{babel}
\usepackage{geometry,amsmath,enumerate,theorem}
\geometry{letterpaper}

%%%%%%%%%% Start TeXmacs macros
\newcommand{\tmverbatim}[1]{\text{{\ttfamily{#1}}}}
\newenvironment{enumeratealpha}{\begin{enumerate}[a{\textup{)}}] }{\end{enumerate}}
{\theorembodyfont{\rmfamily\small}\newtheorem{exercise}{Exercise}}
%%%%%%%%%% End TeXmacs macros

\begin{document}

{\class{Functional Programming}}

{\title{Functions}}

\begin{exercise}
  Define (implement) and test on a couple of examples functions corresponding
  to / computing:
  \begin{enumerate}
    \item \tmverbatim{c\_or} and \tmverbatim{c\_not};
    
    \item exponentiation for Church numerals;
    
    \item is-zero predicate for Church numerals;
    
    \item even-number predicate for Church numerals;
    
    \item multiplication for pair-encoded natural numbers;
    
    \item factorial $n!$ for pair-encoded natural numbers.
    
    \item the length of a list (in Church numerals);
    
    \item \tmverbatim{cn\_max} -- maximum of two Church numerals;
    
    \item the depth of a tree (in Church numerals).
  \end{enumerate}
\end{exercise}

\begin{exercise}
  Representing side-effects as an explicitly ``passed around'' state value,
  write (higher-order) functions that represent the imperative constructs:
  \begin{enumerate}
    \item {\hlkwa{for}}...{\hlkwa{to}}...
    
    \item {\hlkwa{for}}...{\hlkwa{downto}}...
    
    \item {\hlkwa{while}}...{\hlkwa{do}}...
    
    \item {\hlkwa{do}}...{\hlkwa{while}}...
    
    \item {\hlkwa{repeat}}...{\hlkwa{until}}...
  \end{enumerate}
  Rather than writing a $\lambda$-term using the encodings that we've learnt,
  just implement the functions in OCaml / F\#, using built-in {\hlkwb{int}}
  and {\hlkwb{bool}} types. You can use {\hlkwa{let rec}} instead of
  {\hlkwa{fix}}.
  \begin{itemize}
    \item For example, in exercise (a), write a function {\hlkwa{let rec
    }}\tmverbatim{for\_to f beg\_i end\_i s }{\hlopt{=}}... where
    \tmverbatim{f} takes arguments \tmverbatim{i} ranging from
    \tmverbatim{beg\_i} to \tmverbatim{end\_i}, state \tmverbatim{s} at given
    step, and returns state \tmverbatim{s} at next step; the
    \tmverbatim{for\_to} function returns the state after the last step.
    
    \item And in exercise (c), write a function {\hlkwa{let rec
    }}\tmverbatim{while\_do p f s }{\hlopt{=}}... where both \tmverbatim{p}
    and \tmverbatim{f} take state \tmverbatim{s} at given step, and if
    \tmverbatim{p s} returns true, then \tmverbatim{f s} is computed to obtain
    state at next step; the \tmverbatim{while\_do} function returns the state
    after the last step.
  \end{itemize}
  Do not use the imperative features of OCaml and F\#, we will not even cover
  them in this course!
\end{exercise}

Despite we will not cover them, it is instructive to see the implementation
using the imperative features, to better understand what is actually required
of a solution to this exercise.
\begin{enumeratealpha}
  \item {\hlkwa{let }}{\hlstd{for{\textunderscore}to f beg{\textunderscore}i
  end{\textunderscore}i s }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{s }}{\hlopt{= }}{\hlkwb{ref }}{\hlstd{s
  }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{for }}{\hlstd{i }}{\hlopt{=
  }}{\hlstd{beg{\textunderscore}i }}{\hlkwa{to }}{\hlstd{end{\textunderscore}i
  }}{\hlkwa{do}}{\hlendline{}}\\
  {\hlstd{ \ \ \ s }}{\hlopt{:= }}{\hlstd{f i
  }}{\hlopt{!}}{\hlstd{s{\hlendline{}}\\
  \ }}{\hlkwa{done}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlopt{!}}{\hlstd{s}}
  
  \item {\hlkwa{let }}{\hlstd{for{\textunderscore}downto f
  beg{\textunderscore}i end{\textunderscore}i s }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{s }}{\hlopt{= }}{\hlkwb{ref }}{\hlstd{s
  }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{for }}{\hlstd{i }}{\hlopt{=
  }}{\hlstd{beg{\textunderscore}i }}{\hlkwa{downto
  }}{\hlstd{end{\textunderscore}i }}{\hlkwa{do}}{\hlendline{}}\\
  {\hlstd{ \ \ \ s }}{\hlopt{:= }}{\hlstd{f i
  }}{\hlopt{!}}{\hlstd{s{\hlendline{}}\\
  \ }}{\hlkwa{done}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlopt{!}}{\hlstd{s}}
  
  \item {\hlkwa{let }}{\hlstd{while{\textunderscore}do p f s
  }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{s }}{\hlopt{= }}{\hlkwb{ref }}{\hlstd{s
  }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{while }}{\hlstd{p }}{\hlopt{!}}{\hlstd{s
  }}{\hlkwa{do}}{\hlendline{}}\\
  {\hlstd{ \ \ \ s }}{\hlopt{:= }}{\hlstd{f
  }}{\hlopt{!}}{\hlstd{s{\hlendline{}}\\
  \ }}{\hlkwa{done}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlopt{!}}{\hlstd{s}}
  
  \item {\hlkwa{let }}{\hlstd{do{\textunderscore}while p f s
  }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{s }}{\hlopt{= }}{\hlkwb{ref
  }}{\hlopt{(}}{\hlstd{f s}}{\hlopt{) }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{while }}{\hlstd{p }}{\hlopt{!}}{\hlstd{s
  }}{\hlkwa{do}}{\hlendline{}}\\
  {\hlstd{ \ \ \ s }}{\hlopt{:= }}{\hlstd{f
  }}{\hlopt{!}}{\hlstd{s{\hlendline{}}\\
  \ }}{\hlkwa{done}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlopt{!}}{\hlstd{s}}
  
  \item {\hlkwa{let }}{\hlstd{repeat{\textunderscore}until p f s
  }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{s }}{\hlopt{= }}{\hlkwb{ref
  }}{\hlopt{(}}{\hlstd{f s}}{\hlopt{) }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{while }}{\hlstd{not }}{\hlopt{(}}{\hlstd{p
  }}{\hlopt{!}}{\hlstd{s}}{\hlopt{) }}{\hlkwa{do}}{\hlendline{}}\\
  {\hlstd{ \ \ \ s }}{\hlopt{:= }}{\hlstd{f
  }}{\hlopt{!}}{\hlstd{s{\hlendline{}}\\
  \ }}{\hlkwa{done}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlopt{!}}{\hlstd{s}}
\end{enumeratealpha}

\end{document}
