\documentclass{beamer}
\usepackage[english]{babel}
\usepackage{geometry,amsmath,amssymb,graphicx,enumerate}
\geometry{landscape, letterpaper}

%%%%%%%%%% Start TeXmacs macros
\catcode`\>=\active \def>{
\fontencoding{T1}\selectfont\symbol{62}\fontencoding{\encodingdefault}}
\newcommand{\assign}{:=}
\newcommand{\downsquigarrow}{{\mbox{\rotatebox[origin=c]{-90}{$\rightsquigarrow$}}}}
\newcommand{\tmem}[1]{{\em #1\/}}
\newcommand{\tmfnhomepage}[1]{\thanks{\textit{Web:} \texttt{#1}}}
\newcommand{\tmmathbf}[1]{\ensuremath{\boldsymbol{#1}}}
\newcommand{\tmop}[1]{\ensuremath{\operatorname{#1}}}
\newcommand{\tmstrong}[1]{\textbf{#1}}
\newcommand{\tmverbatim}[1]{\text{{\ttfamily{#1}}}}
\newenvironment{enumeratealpha}{\begin{enumerate}[a{\textup{)}}] }{\end{enumerate}}
%%%%%%%%%% End TeXmacs macros

\begin{document}

\title{Functional Programming}

\author{
  {\L}ukasz Stafiniak
  \tmfnhomepage{www.ii.uni.wroc.pl/\~{}lukstafi}
}

\institute{{\L}ukasz Stafiniak}

\maketitle

\title{Lecture 4: Functions.}

\subtitle{Programming in untyped $\lambda$-calculus.\\
{\small{{\tmem{Introduction to Lambda Calculus}} Henk Barendregt, Erik
Barendsen\\
{\tmem{Lecture Notes on the Lambda Calculus}} Peter Selinger}}}

\maketitle

{\newpage}

\section{Review: a ``computation by hand'' example}

Let's compute some larger, recursive program.\\
Recall that we use {\hlkwa{fix}} instead of {\hlkwa{let rec}} to simplify
rules for recursion. Also remember our syntactic conventions:\\
\tmverbatim{fun x y -> e} stands for \tmverbatim{fun x -> (fun y -> e)}, etc.

{\hlkwa{let rec fix }}{\hlstd{f x }}{\hlopt{= }}{\hlstd{f
}}{\hlopt{(}}{\hlkwa{fix }}{\hlstd{f}}{\hlopt{)
}}{\hlstd{x}}{\hlendline{Preparations.}}\\
{\hlkwa{type }}{\hlstd{int{\textunderscore}list }}{\hlopt{= }}{\hlkwd{Nil
}}{\hlopt{\textbar }}{\hlkwd{Cons }}{\hlkwa{of }}{\hlkwb{int }}{\hlopt{*
}}{\hlstd{int{\textunderscore}list}}{\hlendline{}}\\
{\hlendline{We will evaluate (reduce) the following expression.}}\\
{\hlkwa{let }}{\hlstd{length }}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlkwa{fix }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{f l
}}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwa{match }}{\hlstd{l }}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Nil }}{\hlopt{->
}}{\hlnum{0}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlstd{x}}{\hlopt{, }}{\hlstd{xs}}{\hlopt{) -> }}{\hlnum{1
}}{\hlopt{+ }}{\hlstd{f xs}}{\hlopt{) }}{\hlkwa{in}}{\hlendline{}}\\
{\hlstd{length }}{\hlopt{(}}{\hlkwd{Cons }}{\hlopt{(}}{\hlnum{1}}{\hlopt{,
(}}{\hlkwd{Cons }}{\hlopt{(}}{\hlnum{2}}{\hlopt{,
}}{\hlkwd{Nil}}{\hlopt{))))}}{\hlendline{}}{\newpage}

{\hlkwa{let }}{\hlstd{length }}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlkwa{fix }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{f l
}}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwa{match }}{\hlstd{l }}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Nil }}{\hlopt{->
}}{\hlnum{0}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlstd{x}}{\hlopt{, }}{\hlstd{xs}}{\hlopt{) -> }}{\hlnum{1
}}{\hlopt{+ }}{\hlstd{f xs}}{\hlopt{) }}{\hlkwa{in}}{\hlendline{}}\\
{\hlstd{length }}{\hlopt{(}}{\hlkwd{Cons }}{\hlopt{(}}{\hlnum{1}}{\hlopt{,
(}}{\hlkwd{Cons }}{\hlopt{(}}{\hlnum{2}}{\hlopt{,
}}{\hlkwd{Nil}}{\hlopt{))))}}{\hlendline{}}
\begin{eqnarray*}
  \text{\tmverbatim{let }} x = v \text{\tmverbatim{ in }} a & \downsquigarrow
  & a [x \assign v]
\end{eqnarray*}
{\hlstd{ \ }}{\hlkwa{fix }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{f l
}}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwa{match }}{\hlstd{l }}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Nil }}{\hlopt{->
}}{\hlnum{0}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlstd{x}}{\hlopt{, }}{\hlstd{xs}}{\hlopt{) -> }}{\hlnum{1
}}{\hlopt{+ }}{\hlstd{f xs}}{\hlopt{) }}{\hlopt{(}}{\hlkwd{Cons
}}{\hlopt{(}}{\hlnum{1}}{\hlopt{, (}}{\hlkwd{Cons
}}{\hlopt{(}}{\hlnum{2}}{\hlopt{, }}{\hlkwd{Nil}}{\hlopt{))))}}
\begin{eqnarray*}
  \text{\tmverbatim{fix}}^2 v_1 v_2 & \downsquigarrow & v_1  \left(
  \text{\tmverbatim{fix}}^2 v_1 \right) v_2
\end{eqnarray*}
{\newpage}
\begin{eqnarray*}
  \text{\tmverbatim{fix}}^2 v_1 v_2 & \downsquigarrow & v_1  \left(
  \text{\tmverbatim{fix}}^2 v_1 \right) v_2
\end{eqnarray*}
{\hlstd{ \ }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{f l
}}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwa{match }}{\hlstd{l }}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Nil }}{\hlopt{->
}}{\hlnum{0}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlstd{x}}{\hlopt{, }}{\hlstd{xs}}{\hlopt{) -> }}{\hlnum{1
}}{\hlopt{+ }}{\hlstd{f xs}}{\hlopt{) }}\\
{\hlopt{ \ \ \ (}}{\hlkwa{fix }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{f l
}}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlkwa{match }}{\hlstd{l
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Nil }}{\hlopt{->
}}{\hlnum{0}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlopt{ \ \textbar }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlstd{x}}{\hlopt{, }}{\hlstd{xs}}{\hlopt{) -> }}{\hlnum{1
}}{\hlopt{+ }}{\hlstd{f xs}}{\hlopt{))}}\\
{\hlopt{ \ \ \ (}}{\hlkwd{Cons }}{\hlopt{(}}{\hlnum{1}}{\hlopt{,
(}}{\hlkwd{Cons }}{\hlopt{(}}{\hlnum{2}}{\hlopt{,
}}{\hlkwd{Nil}}{\hlopt{))))}}
\begin{eqnarray*}
  \left( \text{\tmverbatim{fun }} x \text{\tmverbatim{->}} a \right) v &
  \rightsquigarrow & a [x \assign v]\\
  a_1 a_2 & \downsquigarrow & a_1' a_2
\end{eqnarray*}
{\newpage}
\begin{eqnarray*}
  \left( \text{\tmverbatim{fun }} x \text{\tmverbatim{->}} a \right) v &
  \rightsquigarrow & a [x \assign v]\\
  a_1 a_2 & \downsquigarrow & a_1' a_2
\end{eqnarray*}
{\hlstd{ \ }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{l }}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwa{match }}{\hlstd{l }}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{ \ \textbar }}{\hlkwd{Nil }}{\hlopt{->
}}{\hlnum{0}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{ \ \textbar }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlstd{x}}{\hlopt{, }}{\hlstd{xs}}{\hlopt{) -> }}{\hlnum{1
}}{\hlopt{+ }}{\hlopt{(}}{\hlkwa{fix }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{f l
}}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ }}{\hlkwa{match }}{\hlstd{l
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Nil }}{\hlopt{->
}}{\hlnum{0}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlopt{ \ \ \ \textbar }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlstd{x}}{\hlopt{, }}{\hlstd{xs}}{\hlopt{) -> }}{\hlnum{1
}}{\hlopt{+ }}{\hlstd{f xs}}{\hlopt{))}}{\hlstd{ xs}}{\hlopt{) }}\\
{\hlopt{ \ \ \ (}}{\hlkwd{Cons }}{\hlopt{(}}{\hlnum{1}}{\hlopt{,
(}}{\hlkwd{Cons }}{\hlopt{(}}{\hlnum{2}}{\hlopt{,
}}{\hlkwd{Nil}}{\hlopt{))))}}
\begin{eqnarray*}
  \left( \text{\tmverbatim{fun }} x \text{\tmverbatim{->}} a \right) v &
  \downsquigarrow & a [x \assign v]
\end{eqnarray*}
{\newpage}
\begin{eqnarray*}
  \left( \text{\tmverbatim{fun }} x \text{\tmverbatim{->}} a \right) v &
  \downsquigarrow & a [x \assign v]
\end{eqnarray*}
{\hlstd{ \ }}{\hlopt{(}}{\hlkwa{match }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlnum{1}}{\hlopt{, (}}{\hlkwd{Cons
}}{\hlopt{(}}{\hlnum{2}}{\hlopt{, }}{\hlkwd{Nil}}{\hlopt{)))
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlopt{ \ \textbar }}{\hlkwd{Nil }}{\hlopt{->
}}{\hlnum{0}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlopt{ \ \textbar }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlstd{x}}{\hlopt{, }}{\hlstd{xs}}{\hlopt{) -> }}{\hlnum{1
}}{\hlopt{+ }}{\hlopt{(}}{\hlkwa{fix }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{f l
}}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlkwa{match }}{\hlstd{l
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Nil }}{\hlopt{->
}}{\hlnum{0}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{ \ \ \ \textbar }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlstd{x}}{\hlopt{, }}{\hlstd{xs}}{\hlopt{) -> }}{\hlnum{1
}}{\hlopt{+ }}{\hlstd{f xs}}{\hlopt{))}}{\hlstd{ xs}}{\hlopt{) }}
\begin{eqnarray*}
  \text{\tmverbatim{match }} C_1^n (v_1, \ldots, v_n) \text{\tmverbatim{
  with}} &  & \\
  C_2^n (p_1, \ldots, p_k) \text{\tmverbatim{->}} a \text{\tmverbatim{
  \textbar }} \tmop{pm} & \downsquigarrow & \text{\tmverbatim{match }} C_1^n
  (v_1, \ldots, v_n)\\
  &  & \text{\tmverbatim{with} } \tmop{pm}
\end{eqnarray*}
{\newpage}
\begin{eqnarray*}
  \text{\tmverbatim{match }} C_1^n (v_1, \ldots, v_n) \text{\tmverbatim{
  with}} &  & \\
  C_2^n (p_1, \ldots, p_k) \text{\tmverbatim{->}} a \text{\tmverbatim{
  \textbar }} \tmop{pm} & \downsquigarrow & \text{\tmverbatim{match }} C_1^n
  (v_1, \ldots, v_n)\\
  &  & \text{\tmverbatim{with} } \tmop{pm}
\end{eqnarray*}
{\hlstd{ \ }}{\hlopt{(}}{\hlkwa{match }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlnum{1}}{\hlopt{, (}}{\hlkwd{Cons
}}{\hlopt{(}}{\hlnum{2}}{\hlopt{, }}{\hlkwd{Nil}}{\hlopt{)))
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlopt{ \ \textbar }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlstd{x}}{\hlopt{, }}{\hlstd{xs}}{\hlopt{) -> }}{\hlnum{1
}}{\hlopt{+ }}{\hlopt{(}}{\hlkwa{fix }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{f l
}}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlkwa{match }}{\hlstd{l
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Nil }}{\hlopt{->
}}{\hlnum{0}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{ \ \ \ \textbar }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlstd{x}}{\hlopt{, }}{\hlstd{xs}}{\hlopt{) -> }}{\hlnum{1
}}{\hlopt{+ }}{\hlstd{f xs}}{\hlopt{))}}{\hlstd{ xs}}{\hlopt{) }}
\begin{eqnarray*}
  \text{\tmverbatim{match }} C_1^n (v_1, \ldots, v_n) \text{\tmverbatim{
  with}} &  & \\
  C_1^n (x_1, \ldots, x_n) \text{\tmverbatim{->}} a \text{\tmverbatim{
  \textbar }} \ldots & \downsquigarrow & a [x_1 \assign v_1 ; \ldots ; x_n
  \assign v_n]
\end{eqnarray*}
{\newpage}
\begin{eqnarray*}
  \text{\tmverbatim{match }} C_1^n (v_1, \ldots, v_n) \text{\tmverbatim{
  with}} &  & \\
  C_1^n (x_1, \ldots, x_n) \text{\tmverbatim{->}} a \text{\tmverbatim{
  \textbar }} \ldots & \downsquigarrow & a [x_1 \assign v_1 ; \ldots ; x_n
  \assign v_n]
\end{eqnarray*}
{\hlstd{ \ }}{\hlnum{1 }}{\hlopt{+ }}{\hlopt{(}}{\hlkwa{fix
}}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{f l }}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlkwa{match }}{\hlstd{l
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Nil }}{\hlopt{->
}}{\hlnum{0}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{ \ \ \ \textbar }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlstd{x}}{\hlopt{, }}{\hlstd{xs}}{\hlopt{) -> }}{\hlnum{1
}}{\hlopt{+ }}{\hlstd{f xs}}{\hlopt{))}}{\hlopt{ (}}{\hlkwd{Cons
}}{\hlopt{(}}{\hlnum{2}}{\hlopt{, }}{\hlkwd{Nil}}{\hlopt{))}}
\begin{eqnarray*}
  \text{\tmverbatim{fix}}^2 v_1 v_2 & \rightsquigarrow & v_1  \left(
  \text{\tmverbatim{fix}}^2 v_1 \right) v_2\\
  a_1 a_2 & \downsquigarrow & a_1 a_2'
\end{eqnarray*}
{\newpage}
\begin{eqnarray*}
  \text{\tmverbatim{fix}}^2 v_1 v_2 & \rightsquigarrow & v_1  \left(
  \text{\tmverbatim{fix}}^2 v_1 \right) v_2\\
  a_1 a_2 & \downsquigarrow & a_1 a_2'
\end{eqnarray*}
{\hlstd{ \ }}{\hlnum{1 }}{\hlopt{+ }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{f l
}}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }} \ \ {\hlkwa{match }}{\hlstd{l
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Nil }}{\hlopt{->
}}{\hlnum{0}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{ \ \ \ \ \ \textbar }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlstd{x}}{\hlopt{, }}{\hlstd{xs}}{\hlopt{) -> }}{\hlnum{1
}}{\hlopt{+ }}{\hlstd{f xs}}{\hlopt{))}}\\
{\hlopt{ \ \ \ \ \ \ \ (}}{\hlkwa{fix }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{f l
}}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlkwa{ \ \ \ \ match }}{\hlstd{l
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ }}{\hlopt{ \ \ \ \ \textbar }}{\hlkwd{Nil }}{\hlopt{->
}}{\hlnum{0}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{ \ \ \ \ \ \ \ \ \textbar }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlstd{x}}{\hlopt{, }}{\hlstd{xs}}{\hlopt{) -> }}{\hlnum{1
}}{\hlopt{+ }}{\hlstd{f xs}}{\hlopt{))}}{\hlopt{ (}}{\hlkwd{Cons
}}{\hlopt{(}}{\hlnum{2}}{\hlopt{, }}{\hlkwd{Nil}}{\hlopt{))}}
\begin{eqnarray*}
  \left( \text{\tmverbatim{fun }} x \text{\tmverbatim{->}} a \right) v &
  \rightsquigarrow & a [x \assign v]\\
  a_1 a_2 & \downsquigarrow & a_1 a_2'
\end{eqnarray*}
{\newpage}
\begin{eqnarray*}
  \left( \text{\tmverbatim{fun }} x \text{\tmverbatim{->}} a \right) v &
  \rightsquigarrow & a [x \assign v]\\
  a_1 a_2 & \downsquigarrow & a_1 a_2'
\end{eqnarray*}
{\hlstd{ \ }}{\hlnum{1 }}{\hlopt{+ }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{l
}}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }} \ \ {\hlkwa{match }}{\hlstd{l
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Nil }}{\hlopt{->
}}{\hlnum{0}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{ \ \ \ \ \ \textbar }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlstd{x}}{\hlopt{, }}{\hlstd{xs}}{\hlopt{) -> }}{\hlnum{1
}}{\hlopt{+ }}{\hlopt{(}}{\hlkwa{fix }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{f l
}}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlkwa{ \ \ \ \ \ match }}{\hlstd{l
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ }}{\hlopt{ \ \ \ \ \ \textbar }}{\hlkwd{Nil
}}{\hlopt{-> }}{\hlnum{0}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{ \ \ \ \ \ \ \ \ \ \textbar }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlstd{x}}{\hlopt{, }}{\hlstd{xs}}{\hlopt{) -> }}{\hlnum{1
}}{\hlopt{+ }}{\hlstd{f xs}}{\hlopt{))}}{\hlstd{ xs}}{\hlopt{))}}\\
{\hlopt{ \ \ \ \ \ \ \ (}}{\hlkwd{Cons }}{\hlopt{(}}{\hlnum{2}}{\hlopt{,
}}{\hlkwd{Nil}}{\hlopt{))}}
\begin{eqnarray*}
  \left( \text{\tmverbatim{fun }} x \text{\tmverbatim{->}} a \right) v &
  \rightsquigarrow & a [x \assign v]\\
  a_1 a_2 & \downsquigarrow & a_1 a_2'
\end{eqnarray*}
{\newpage}
\begin{eqnarray*}
  \left( \text{\tmverbatim{fun }} x \text{\tmverbatim{->}} a \right) v &
  \rightsquigarrow & a [x \assign v]\\
  a_1 a_2 & \downsquigarrow & a_1 a_2'
\end{eqnarray*}
{\hlstd{ \ }}{\hlnum{1 }}{\hlopt{+ }}{\hlopt{(}}{\hlkwa{match }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlnum{2}}{\hlopt{, }}{\hlkwd{Nil}}{\hlopt{)
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Nil }}{\hlopt{->
}}{\hlnum{0}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{ \ \ \ \ \textbar }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlstd{x}}{\hlopt{, }}{\hlstd{xs}}{\hlopt{) -> }}{\hlnum{1
}}{\hlopt{+ }}{\hlopt{(}}{\hlkwa{fix }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{f l
}}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlkwa{ \ \ \ \ match }}{\hlstd{l
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ }}{\hlopt{ \ \ \ \ \textbar }}{\hlkwd{Nil }}{\hlopt{->
}}{\hlnum{0}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{ \ \ \ \ \ \ \ \ \textbar }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlstd{x}}{\hlopt{, }}{\hlstd{xs}}{\hlopt{) -> }}{\hlnum{1
}}{\hlopt{+ }}{\hlstd{f xs}}{\hlopt{))}}{\hlstd{ xs}}{\hlopt{))}}
\begin{eqnarray*}
  \text{\tmverbatim{match }} C_1^n (v_1, \ldots, v_n) \text{\tmverbatim{
  with}} &  & \\
  C_2^n (p_1, \ldots, p_k) \text{\tmverbatim{->}} a \text{\tmverbatim{
  \textbar }} \tmop{pm} & \rightsquigarrow & \text{\tmverbatim{match }} C_1^n
  (v_1, \ldots, v_n)\\
  &  & \text{\tmverbatim{with} } \tmop{pm}\\
  a_1 a_2 & \downsquigarrow & a_1 a_2'
\end{eqnarray*}
{\newpage}
\begin{eqnarray*}
  \text{\tmverbatim{match }} C_1^n (v_1, \ldots, v_n) \text{\tmverbatim{
  with}} &  & \\
  C_2^n (p_1, \ldots, p_k) \text{\tmverbatim{->}} a \text{\tmverbatim{
  \textbar }} \tmop{pm} & \rightsquigarrow & \text{\tmverbatim{match }} C_1^n
  (v_1, \ldots, v_n)\\
  &  & \text{\tmverbatim{with} } \tmop{pm}\\
  a_1 a_2 & \downsquigarrow & a_1 a_2'
\end{eqnarray*}
{\hlstd{ \ }}{\hlnum{1 }}{\hlopt{+ }}{\hlopt{(}}{\hlkwa{match }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlnum{2}}{\hlopt{, }}{\hlkwd{Nil}}{\hlopt{)
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlopt{ \ \ \ \ \ \ \textbar }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlstd{x}}{\hlopt{, }}{\hlstd{xs}}{\hlopt{) -> }}{\hlnum{1
}}{\hlopt{+ }}{\hlopt{(}}{\hlkwa{fix }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{f l
}}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ }}{\hlkwa{match }}{\hlstd{l
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Nil }}{\hlopt{->
}}{\hlnum{0}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{ \ \ \ \ \ \ \ \ \textbar }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlstd{x}}{\hlopt{, }}{\hlstd{xs}}{\hlopt{) -> }}{\hlnum{1
}}{\hlopt{+ }}{\hlstd{f xs}}{\hlopt{))}}{\hlstd{ xs}}{\hlopt{) }}
\begin{eqnarray*}
  \text{\tmverbatim{match }} C_1^n (v_1, \ldots, v_n) \text{\tmverbatim{
  with}} &  & \\
  C_1^n (x_1, \ldots, x_n) \text{\tmverbatim{->}} a \text{\tmverbatim{
  \textbar }} \ldots & \downsquigarrow & a [x_1 \assign v_1 ; \ldots ; x_n
  \assign v_n]\\
  &  & 
\end{eqnarray*}
{\newpage}
\begin{eqnarray*}
  \text{\tmverbatim{match }} C_1^n (v_1, \ldots, v_n) \text{\tmverbatim{
  with}} &  & \\
  C_1^n (x_1, \ldots, x_n) \text{\tmverbatim{->}} a \text{\tmverbatim{
  \textbar }} \ldots & \rightsquigarrow & a [x_1 \assign v_1 ; \ldots ; x_n
  \assign v_n]\\
  a_1 a_2 & \downsquigarrow & a_1 a_2'
\end{eqnarray*}
{\hlstd{ \ }}{\hlnum{1 }}{\hlopt{+ }}{\hlopt{(}}{\hlnum{1 }}{\hlopt{+
}}{\hlopt{(}}{\hlkwa{fix }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{f l
}}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ \ }}{\hlkwa{match }}{\hlstd{l
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Nil
}}{\hlopt{-> }}{\hlnum{0}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{ \ \ \ \ \ \ \ \ \ \ \textbar }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlstd{x}}{\hlopt{, }}{\hlstd{xs}}{\hlopt{) -> }}{\hlnum{1
}}{\hlopt{+ }}{\hlstd{f xs}}{\hlopt{))}}{\hlstd{ Nil}}{\hlopt{)}}
\begin{eqnarray*}
  \text{\tmverbatim{fix}}^2 v_1 v_2 & \rightsquigarrow & v_1  \left(
  \text{\tmverbatim{fix}}^2 v_1 \right) v_2\\
  a_1 a_2 & \downsquigarrow & a_1 a_2'\\
  a_1 a_2 & \downsquigarrow & a_1 a_2'
\end{eqnarray*}
{\newpage}
\begin{eqnarray*}
  \text{\tmverbatim{fix}}^2 v_1 v_2 & \rightsquigarrow & v_1  \left(
  \text{\tmverbatim{fix}}^2 v_1 \right) v_2\\
  a_1 a_2 & \downsquigarrow & a_1 a_2'\\
  a_1 a_2 & \downsquigarrow & a_1 a_2'
\end{eqnarray*}
{\hlstd{ \ }}{\hlnum{1 }}{\hlopt{+ }}{\hlopt{(}}{\hlnum{1 }}{\hlopt{+
}}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{f l }}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ \ }}{\hlkwa{match }}{\hlstd{l
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Nil
}}{\hlopt{-> }}{\hlnum{0}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{ \ \ \ \ \ \ \ \ \ \ \textbar }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlstd{x}}{\hlopt{, }}{\hlstd{xs}}{\hlopt{) -> }}{\hlnum{1
}}{\hlopt{+ }}{\hlstd{f xs}}{\hlopt{)}}{\hlopt{ }}{\hlopt{(}}{\hlkwa{fix
}}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{f l }}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }}{\hlkwa{match }}{\hlstd{l
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }}{\hlopt{ \ \ \ \textbar }}{\hlkwd{Nil
}}{\hlopt{-> }}{\hlnum{0}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textbar }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlstd{x}}{\hlopt{, }}{\hlstd{xs}}{\hlopt{) -> }}{\hlnum{1
}}{\hlopt{+ }}{\hlstd{f xs}}{\hlopt{))}}{\hlstd{ Nil}}{\hlopt{)}}
\begin{eqnarray*}
  \left( \text{\tmverbatim{fun }} x \text{\tmverbatim{->}} a \right) v &
  \rightsquigarrow & a [x \assign v]\\
  a_1 a_2 & \downsquigarrow & a_1 a_2'\\
  a_1 a_2 & \downsquigarrow & a_1 a_2'
\end{eqnarray*}
{\newpage}
\begin{eqnarray*}
  \left( \text{\tmverbatim{fun }} x \text{\tmverbatim{->}} a \right) v &
  \rightsquigarrow & a [x \assign v]\\
  a_1 a_2 & \downsquigarrow & a_1 a_2'\\
  a_1 a_2 & \downsquigarrow & a_1 a_2'
\end{eqnarray*}
{\hlstd{ \ }}{\hlnum{1 }}{\hlopt{+ }}{\hlopt{(}}{\hlnum{1 }}{\hlopt{+
}}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{l }}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ \ }}{\hlkwa{match }}{\hlstd{l
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Nil
}}{\hlopt{-> }}{\hlnum{0}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{ \ \ \ \ \ \ \ \ \ \ \textbar }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlstd{x}}{\hlopt{, }}{\hlstd{xs}}{\hlopt{) -> }}{\hlnum{1
}}{\hlopt{+ }}{\hlopt{(}}{\hlkwa{fix }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{f l
}}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }}{\hlkwa{match }}{\hlstd{l
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }}{\hlopt{ \ \ \ \textbar }}{\hlkwd{Nil
}}{\hlopt{-> }}{\hlnum{0}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textbar }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlstd{x}}{\hlopt{, }}{\hlstd{xs}}{\hlopt{) -> }}{\hlnum{1
}}{\hlopt{+ }}{\hlstd{f xs}}{\hlopt{))}}{\hlstd{ xs}}{\hlopt{)}}{\hlstd{
Nil}}{\hlopt{)}}
\begin{eqnarray*}
  \left( \text{\tmverbatim{fun }} x \text{\tmverbatim{->}} a \right) v &
  \rightsquigarrow & a [x \assign v]\\
  a_1 a_2 & \downsquigarrow & a_1 a_2'\\
  a_1 a_2 & \downsquigarrow & a_1 a_2'
\end{eqnarray*}
{\newpage}
\begin{eqnarray*}
  \left( \text{\tmverbatim{fun }} x \text{\tmverbatim{->}} a \right) v &
  \rightsquigarrow & a [x \assign v]\\
  a_1 a_2 & \downsquigarrow & a_1 a_2'\\
  a_1 a_2 & \downsquigarrow & a_1 a_2'
\end{eqnarray*}
{\hlstd{ \ }}{\hlnum{1 }}{\hlopt{+ }}{\hlopt{(}}{\hlnum{1 }}{\hlopt{+
}}{\hlopt{(}}{\hlkwa{match }}{\hlstd{Nil }}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Nil
}}{\hlopt{-> }}{\hlnum{0}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{ \ \ \ \ \ \ \ \ \ \ \textbar }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlstd{x}}{\hlopt{, }}{\hlstd{xs}}{\hlopt{) -> }}{\hlnum{1
}}{\hlopt{+ }}{\hlopt{(}}{\hlkwa{fix }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{f l
}}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }}{\hlkwa{match }}{\hlstd{l
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }}{\hlopt{ \ \ \ \textbar }}{\hlkwd{Nil
}}{\hlopt{-> }}{\hlnum{0}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textbar }}{\hlkwd{Cons
}}{\hlopt{(}}{\hlstd{x}}{\hlopt{, }}{\hlstd{xs}}{\hlopt{) -> }}{\hlnum{1
}}{\hlopt{+ }}{\hlstd{f xs}}{\hlopt{))}}{\hlstd{ xs}}{\hlopt{)}}{\hlopt{)}}
\begin{eqnarray*}
  \text{\tmverbatim{match }} C_1^n (v_1, \ldots, v_n) \text{\tmverbatim{
  with}} &  & \\
  C_1^n (x_1, \ldots, x_n) \text{\tmverbatim{->}} a \text{\tmverbatim{
  \textbar }} \ldots & \rightsquigarrow & a [x_1 \assign v_1 ; \ldots ; x_n
  \assign v_n]\\
  a_1 a_2 & \downsquigarrow & a_1 a_2'\\
  a_1 a_2 & \downsquigarrow & a_1 a_2'
\end{eqnarray*}
{\newpage}
\begin{eqnarray*}
  \text{\tmverbatim{match }} C_1^n (v_1, \ldots, v_n) \text{\tmverbatim{
  with}} &  & \\
  C_1^n (x_1, \ldots, x_n) \text{\tmverbatim{->}} a \text{\tmverbatim{
  \textbar }} \ldots & \rightsquigarrow & a [x_1 \assign v_1 ; \ldots ; x_n
  \assign v_n]\\
  a_1 a_2 & \downsquigarrow & a_1 a_2'\\
  a_1 a_2 & \downsquigarrow & a_1 a_2'
\end{eqnarray*}
{\hlstd{ \ }}{\hlnum{1 }}{\hlopt{+ }}{\hlopt{(}}{\hlnum{1 }}{\hlopt{+
}}{\hlnum{0}}{\hlopt{)}}
\begin{eqnarray*}
  f^n v_1 \ldots v_n & \rightsquigarrow & f (v_1, \ldots, v_n)\\
  a_1 a_2 & \downsquigarrow & a_1 a_2'
\end{eqnarray*}
{\hlstd{ \ }}{\hlnum{1 }}{\hlopt{+ }}{\hlnum{1}}
\begin{eqnarray*}
  f^n v_1 \ldots v_n & \downsquigarrow & f (v_1, \ldots, v_n)
\end{eqnarray*}
{\hlstd{ \ }}{\hlnum{2}}{\newpage}

\section{Language and rules of the untyped $\lambda$-calculus}

\begin{itemize}
  \item First, let's forget about types.
  
  \item Next, let's introduce a shortcut:
  \begin{itemize}
    \item We write $\lambda x.a$ for \tmverbatim{fun $x$->$a$}, $\lambda x
    y.a$ for \tmverbatim{fun $x$ $y$->$a$}, etc.
  \end{itemize}
  \item Let's forget about all other constructions, only {\hlkwa{fun}} and
  variables.
  
  \item The real $\lambda$-calculus has a more general reduction:
  \begin{eqnarray*}
    \left( \text{\tmverbatim{fun }} x \text{\tmverbatim{->}} a_1 \right) a_2 &
    \rightsquigarrow & a_1 [x \assign a_2]
  \end{eqnarray*}
  (called {\tmem{$\beta$-reduction}}) and uses {\tmem{bound variable
  renaming}} (called {\tmem{$\alpha$-conversion}}), or some other trick, to
  avoid {\tmem{variable capture}}. But let's not over-complicate things.
  \begin{itemize}
    \item We will look into the $\beta$-reduction rule in the
    {\tmstrong{laziness}} lecture.
    
    \item Why is $\beta$-reduction more general than the rule we use?
  \end{itemize}
\end{itemize}


\section{Booleans}

\begin{itemize}
  \item Alonzo Church introduced $\lambda$-calculus to encode logic.
  
  \item There are multiple ways to encode various sorts of data in
  $\lambda$-calculus. Not all of them make sense in a typed setting, i.e. the
  straightforward encode/decode functions do not type-check for them.
  
  \item Define \tmverbatim{c\_true}=$\lambda x y.x$ and
  \tmverbatim{c\_false}=$\lambda x y.y$.
  
  \item Define \tmverbatim{c\_and}=$\lambda x y.x y
  \text{\tmverbatim{c\_false}}$. Check that it works!
  \begin{itemize}
    \item I.e. that \tmverbatim{c\_and c\_true c\_true} =
    \tmverbatim{c\_true},\\
    otherwise \tmverbatim{c\_and a b} = \tmverbatim{c\_false}.
  \end{itemize}
\end{itemize}
{\hlkwa{let }}{\hlstd{c{\textunderscore}true }}{\hlopt{= }}{\hlkwa{fun
}}{\hlstd{x y }}{\hlopt{-> }}{\hlstd{x}}{\hlendline{``True'' is projection on
the first argument.}}\\
{\hlkwa{let }}{\hlstd{c{\textunderscore}false }}{\hlopt{= }}{\hlkwa{fun
}}{\hlstd{x y }}{\hlopt{-> }}{\hlstd{y}}{\hlendline{And ``false'' on the
second argument.}}\\
{\hlkwa{let }}{\hlstd{c{\textunderscore}and }}{\hlopt{= }}{\hlkwa{fun
}}{\hlstd{x y }}{\hlopt{-> }}{\hlstd{x y
c{\textunderscore}false}}{\hlendline{If one is false, then return false.}}\\
{\hlkwa{let }}{\hlstd{encode{\textunderscore}bool b }}{\hlopt{= }}{\hlkwa{if
}}{\hlstd{b }}{\hlkwa{then }}{\hlstd{c{\textunderscore}true }}{\hlkwa{else
}}{\hlstd{c{\textunderscore}false}}{\hlendline{}}\\
{\hlkwa{let }}{\hlstd{decode{\textunderscore}bool c }}{\hlopt{= }}{\hlstd{c
}}{\hlkwa{true false}}{\hlendline{Test the functions in the toplevel.}}
\begin{itemize}
  \item Define \tmverbatim{c\_or} and \tmverbatim{c\_not} yourself!
\end{itemize}

\section{If-then-else and pairs}

\begin{itemize}
  \item We will just use the OCaml syntax from now.
\end{itemize}
{\hlkwa{let }}{\hlstd{if{\textunderscore}then{\textunderscore}else }}{\hlopt{=
}}{\hlkwa{fun }}{\hlstd{b }}{\hlopt{-> }}{\hlstd{b}}{\hlendline{Booleans
select the argument!}}{\small{}}

Remember to play with the functions in the toplevel.

{\hlkwa{let }}{\hlstd{c{\textunderscore}pair m n }}{\hlopt{= }}{\hlkwa{fun
}}{\hlstd{x }}{\hlopt{-> }}{\hlstd{x m n}}{\hlendline{We couple things}}\\
{\hlkwa{let }}{\hlstd{c{\textunderscore}first }}{\hlopt{= }}{\hlkwa{fun
}}{\hlstd{p }}{\hlopt{-> }}{\hlstd{p c{\textunderscore}true}}{\hlendline{by
passing them together.}}\\
{\hlkwa{let }}{\hlstd{c{\textunderscore}second }}{\hlopt{= }}{\hlkwa{fun
}}{\hlstd{p }}{\hlopt{-> }}{\hlstd{p
c{\textunderscore}false}}{\hlendline{Check that it works!}}

{\small{{\hlkwa{let }}{\hlstd{encode{\textunderscore}pair
enc{\textunderscore}fst enc{\textunderscore}snd
}}{\hlopt{(}}{\hlstd{a}}{\hlopt{, }}{\hlstd{b}}{\hlopt{) =}}{\hlendline{}}\\
{\hlstd{ \ c{\textunderscore}pair }}{\hlopt{(}}{\hlstd{enc{\textunderscore}fst
a}}{\hlopt{) (}}{\hlstd{enc{\textunderscore}snd b}}{\hlopt{)}}{\hlendline{}}\\
{\hlkwa{let }}{\hlstd{decode{\textunderscore}pair de{\textunderscore}fst
de{\textunderscore}snd c }}{\hlopt{= }}{\hlstd{c }}{\hlopt{(}}{\hlkwa{fun
}}{\hlstd{x y }}{\hlopt{-> }}{\hlstd{de{\textunderscore}fst x}}{\hlopt{,
}}{\hlstd{de{\textunderscore}snd y}}{\hlopt{)}}{\hlendline{}}\\
{\hlkwa{let }}{\hlstd{decode{\textunderscore}bool{\textunderscore}pair c
}}{\hlopt{= }}{\hlstd{decode{\textunderscore}pair decode{\textunderscore}bool
decode{\textunderscore}bool c}}{\hlendline{}}}}
\begin{itemize}
  \item We can define larger tuples in the same manner:
  
  {\hlkwa{let }}{\hlstd{c{\textunderscore}triple l m n }}{\hlopt{=
  }}{\hlkwa{fun }}{\hlstd{x }}{\hlopt{-> }}{\hlstd{x l m n}}{\hlendline{}}
\end{itemize}


\section{Pair-encoded natural numbers}

\begin{itemize}
  \item Our first encoding of natural numbers is as the depth of nested pairs
  whose rightmost leaf is $\lambda x.x$ and whose left elements are
  \tmverbatim{c\_false}.
\end{itemize}
{\hlkwa{let }}{\hlstd{pn0 }}{\hlopt{= }}{\hlkwa{fun }}{\hlstd{x }}{\hlopt{->
}}{\hlstd{x}}{\hlendline{Start with the identity function.}}\\
{\hlkwa{let }}{\hlstd{pn{\textunderscore}succ n }}{\hlopt{=
}}{\hlstd{c{\textunderscore}pair c{\textunderscore}false n}}{\hlendline{Stack
another pair.}}\\
{\hlendline{}}\\
{\hlkwa{let }}{\hlstd{pn{\textunderscore}pred }}{\hlopt{= }}{\hlkwa{fun
}}{\hlstd{x }}{\hlopt{-> }}{\hlstd{x
c{\textunderscore}false}}{\hlendline{[Explain these functions.]}}\\
{\hlkwa{let }}{\hlstd{pn{\textunderscore}is{\textunderscore}zero }}{\hlopt{=
}}{\hlkwa{fun }}{\hlstd{x }}{\hlopt{-> }}{\hlstd{x
c{\textunderscore}true}}{\hlendline{}}

We program in untyped lambda calculus as an exercise, and we need encoding /
decoding to verify our exercises, so using ``magic'' for encoding / decoding
is ``fair game''.

{\hlkwa{let rec }}{\hlstd{encode{\textunderscore}pnat n
}}{\hlopt{=}}{\hlendline{We use {\hlkwc{Obj}}{\hlopt{.}}\tmverbatim{magic} to
forget types.}}\\
{\hlstd{ \ }}{\hlkwa{if }}{\hlstd{n }}{\hlopt{$<$= }}{\hlnum{0 }}{\hlkwa{then
}}{\hlkwc{Obj}}{\hlopt{.}}{\hlstd{magic pn0{\hlendline{}}\\
\ }}{\hlkwa{else }}{\hlstd{pn{\textunderscore}succ
}}{\hlopt{(}}{\hlkwc{Obj}}{\hlopt{.}}{\hlstd{magic
}}{\hlopt{(}}{\hlstd{encode{\textunderscore}pnat
}}{\hlopt{(}}{\hlstd{n}}{\hlopt{-}}{\hlnum{1}}{\hlopt{)))}}{\hlendline{Disregarding
types,}}\\
{\hlkwa{let rec }}{\hlstd{decode{\textunderscore}pnat pn
}}{\hlopt{=}}{\hlendline{these functions are straightforward!}}\\
{\hlstd{ \ }}{\hlkwa{if }}{\hlstd{decode{\textunderscore}bool
}}{\hlopt{(}}{\hlstd{pn{\textunderscore}is{\textunderscore}zero pn}}{\hlopt{)
}}{\hlkwa{then }}{\hlnum{0}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlkwa{else }}{\hlnum{1 }}{\hlopt{+
}}{\hlstd{decode{\textunderscore}pnat
}}{\hlopt{(}}{\hlstd{pn{\textunderscore}pred
}}{\hlopt{(}}{\hlkwc{Obj}}{\hlopt{.}}{\hlstd{magic
pn}}{\hlopt{))}}{\hlendline{}}

\section{Church numerals (natural numbers in Ch. enc.)}

\begin{itemize}
  \item Do you remember our function \tmverbatim{power f n}? We will use its
  variant for a different representation of numbers:
\end{itemize}
{\hlkwa{let }}{\hlstd{cn0 }}{\hlopt{= }}{\hlkwa{fun }}{\hlstd{f x }}{\hlopt{->
}}{\hlstd{x}}{\hlendline{The same as \tmverbatim{c\_false}.}}\\
{\hlkwa{let }}{\hlstd{cn1 }}{\hlopt{= }}{\hlkwa{fun }}{\hlstd{f x }}{\hlopt{->
}}{\hlstd{f x}}{\hlendline{Behaves like identity.}}\\
{\hlkwa{let }}{\hlstd{cn2 }}{\hlopt{= }}{\hlkwa{fun }}{\hlstd{f x }}{\hlopt{->
}}{\hlstd{f }}{\hlopt{(}}{\hlstd{f x}}{\hlopt{)}}{\hlendline{}}\\
{\hlkwa{let }}{\hlstd{cn3 }}{\hlopt{= }}{\hlkwa{fun }}{\hlstd{f x }}{\hlopt{->
}}{\hlstd{f }}{\hlopt{(}}{\hlstd{f }}{\hlopt{(}}{\hlstd{f
x}}{\hlopt{))}}{\hlendline{}}
\begin{itemize}
  \item This is the original Alonzo Church encoding.
\end{itemize}
{\hlkwa{let }}{\hlstd{cn{\textunderscore}succ }}{\hlopt{= }}{\hlkwa{fun
}}{\hlstd{n f x }}{\hlopt{-> }}{\hlstd{f }}{\hlopt{(}}{\hlstd{n f
x}}{\hlopt{)}}{\hlendline{}}
\begin{itemize}
  \item Define addition, multiplication, comparing to zero, and the predecesor
  function ``-1'' for Church numerals.
  
  \item Turns out even Alozno Church couldn't define predecesor right away!
  But try to make some progress before you turn to the next slide.
  \begin{itemize}
    \item His student Stephen Kleene found it.
  \end{itemize}
\end{itemize}
{\newpage}

{\hlkwa{let rec }}{\hlstd{encode{\textunderscore}cnat n f
}}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlkwa{if }}{\hlstd{n }}{\hlopt{$<$= }}{\hlnum{0 }}{\hlkwa{then
}}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{x }}{\hlopt{-> }}{\hlstd{x}}{\hlopt{)
}}{\hlkwa{else }}{\hlstd{f }}{\hlopt{-}}{\hlstd{{\hlopt{\textbar}}
encode{\textunderscore}cnat
}}{\hlopt{(}}{\hlstd{n}}{\hlopt{-}}{\hlnum{1}}{\hlopt{)
}}{\hlstd{f}}{\hlendline{}}\\
{\hlkwa{let }}{\hlstd{decode{\textunderscore}cnat n }}{\hlopt{= }}{\hlstd{n
}}{\hlopt{((+) }}{\hlnum{1}}{\hlopt{) }}{\hlnum{0}}{\hlendline{}}\\
{\hlkwa{let }}{\hlstd{cn7 f x }}{\hlopt{=
}}{\hlstd{encode{\textunderscore}cnat }}{\hlnum{7 }}{\hlstd{f
x}}{\hlendline{We need to {\tmem{$\eta$-expand}} these definitions}}\\
{\hlkwa{let }}{\hlstd{cn13 f x }}{\hlopt{=
}}{\hlstd{encode{\textunderscore}cnat }}{\hlnum{13 }}{\hlstd{f
x}}{\hlendline{for type-system reasons.}}\\
{\hlendline{(Because OCaml allows {\tmem{side-effects}}.)}}\\
{\hlkwa{let }}{\hlstd{cn{\textunderscore}add }}{\hlopt{= }}{\hlkwa{fun
}}{\hlstd{n m f x }}{\hlopt{-> }}{\hlstd{n f }}{\hlopt{(}}{\hlstd{m f
x}}{\hlopt{)}}{\hlendline{Put \tmverbatim{n} of \tmverbatim{f} in front.}}\\
{\hlkwa{let }}{\hlstd{cn{\textunderscore}mult }}{\hlopt{= }}{\hlkwa{fun
}}{\hlstd{n m f }}{\hlopt{-> }}{\hlstd{n }}{\hlopt{(}}{\hlstd{m
f}}{\hlopt{)}}{\hlendline{Repeat \tmverbatim{n} times}}\\
{\hlendline{putting \tmverbatim{m} of \tmverbatim{f} in front.}}\\
{\hlkwa{let }}{\hlstd{cn{\textunderscore}prev n }}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlkwa{fun }}{\hlstd{f x }}{\hlopt{->}}{\hlendline{This is the
``Church numeral signature''.}}\\
{\hlstd{ \ \ \ n}}{\hlendline{The only thing we have is an \tmverbatim{n}-step
loop.}}\\
{\hlstd{ \ \ \ \ \ }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{g v }}{\hlopt{->
}}{\hlstd{v }}{\hlopt{(}}{\hlstd{g f}}{\hlopt{))}}{\hlendline{We need sth that
operates on \tmverbatim{f}.}}\\
{\hlstd{ \ \ \ \ \ }}{\hlopt{(}}{\hlkwa{fun
}}{\hlstd{z}}{\hlopt{->}}{\hlstd{x}}{\hlopt{)}}{\hlendline{We need to ignore
the innermost step.}}\\
{\hlstd{ \ \ \ \ \ }}{\hlopt{(}}{\hlkwa{fun
}}{\hlstd{z}}{\hlopt{->}}{\hlstd{z}}{\hlopt{)}}{\hlendline{We've build a
``machine'' not results -- start the machine.}}

\tmverbatim{cn\_is\_zero} left as an exercise.

{\newpage}

{\hlstd{decode{\textunderscore}cnat }}{\hlopt{(}}{\hlstd{cn\_prev
cn3}}{\hlopt{)}}
\[ \downsquigarrow \]
{\hlopt{(}}{\hlstd{cn\_prev cn3}}{\hlopt{)}}{\hlstd{ }}{\hlopt{((+)
}}{\hlnum{1}}{\hlopt{) }}{\hlnum{0}}
\[ \downsquigarrow \]
{\hlopt{(}}{\hlkwa{fun }}{\hlstd{f x }}{\hlopt{->}}\\
{\hlstd{ \ \ \ }}{\hlstd{cn3}}\\
{\hlstd{ \ \ \ \ \ }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{g v }}{\hlopt{->
}}{\hlstd{v }}{\hlopt{(}}{\hlstd{g f}}{\hlopt{))}}\\
{\hlstd{ \ \ \ \ \ }}{\hlopt{(}}{\hlkwa{fun
}}{\hlstd{z}}{\hlopt{->}}{\hlstd{x}}{\hlopt{)}}\\
{\hlstd{ \ \ \ \ \ }}{\hlopt{(}}{\hlkwa{fun
}}{\hlstd{z}}{\hlopt{->}}{\hlstd{z}}{\hlopt{)}}{\hlopt{)}}{\hlstd{
}}{\hlopt{((+) }}{\hlnum{1}}{\hlopt{) }}{\hlnum{0}}
\[ \downsquigarrow \]
{\hlopt{((}}{\hlkwa{fun }}{\hlstd{f x }}{\hlopt{-> }}{\hlstd{f
}}{\hlopt{(}}{\hlstd{f }}{\hlopt{(}}{\hlstd{f x}}{\hlopt{)))}}\\
{\hlstd{ \ \ \ \ \ }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{g v }}{\hlopt{->
}}{\hlstd{v }}{\hlopt{(}}{\hlstd{g }}{\hlopt{((+)
}}{\hlnum{1}}{\hlopt{)}}{\hlopt{))}}\\
{\hlstd{ \ \ \ \ \ }}{\hlopt{(}}{\hlkwa{fun
}}{\hlstd{z}}{\hlopt{->}}{\hlnum{0}}{\hlopt{)}}\\
{\hlstd{ \ \ \ \ \ }}{\hlopt{(}}{\hlkwa{fun
}}{\hlstd{z}}{\hlopt{->}}{\hlstd{z}}{\hlopt{)}}{\hlopt{)}}
\[ \downsquigarrow \]
{\hlopt{(}}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{g v }}{\hlopt{-> }}{\hlstd{v
}}{\hlopt{(}}{\hlstd{g }}{\hlopt{((+) }}{\hlnum{1}}{\hlopt{)}}{\hlopt{))}}\\
{\hlstd{ \ }}{\hlopt{(}}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{g v }}{\hlopt{->
}}{\hlstd{v }}{\hlopt{(}}{\hlstd{g }}{\hlopt{((+)
}}{\hlnum{1}}{\hlopt{)}}{\hlopt{))}}\\
{\hlstd{ \ \ \ }}{\hlopt{(}}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{g v }}{\hlopt{->
}}{\hlstd{v }}{\hlopt{(}}{\hlstd{g }}{\hlopt{((+)
}}{\hlnum{1}}{\hlopt{)}}{\hlopt{))}}\\
{\hlstd{ \ \ \ \ \ }}{\hlopt{(}}{\hlkwa{fun
}}{\hlstd{z}}{\hlopt{->}}{\hlnum{0}}{\hlopt{)}}{\hlopt{)))}}\\
{\hlstd{ \ }}{\hlopt{(}}{\hlkwa{fun
}}{\hlstd{z}}{\hlopt{->}}{\hlstd{z}}{\hlopt{)}}{\hlopt{)}}
\[ \downsquigarrow \]
{\hlopt{(}}{\hlopt{(}}{\hlkwa{fun
}}{\hlstd{z}}{\hlopt{->}}{\hlstd{z}}{\hlopt{)}}\\
{\hlstd{ \ }}{\hlopt{(}}{\hlopt{(}}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{g v
}}{\hlopt{-> }}{\hlstd{v }}{\hlopt{(}}{\hlstd{g }}{\hlopt{((+)
}}{\hlnum{1}}{\hlopt{)}}{\hlopt{))}}\\
{\hlstd{ \ \ \ }}{\hlopt{(}}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{g v }}{\hlopt{->
}}{\hlstd{v }}{\hlopt{(}}{\hlstd{g }}{\hlopt{((+)
}}{\hlnum{1}}{\hlopt{)}}{\hlopt{))}}\\
{\hlstd{ \ \ \ \ \ }}{\hlopt{(}}{\hlkwa{fun
}}{\hlstd{z}}{\hlopt{->}}{\hlnum{0}}{\hlopt{)}}{\hlopt{)))}}{\hlstd{
}}{\hlopt{((+) }}{\hlnum{1}}{\hlopt{)}}{\hlopt{))}}
\[ \downsquigarrow \]
{\hlopt{}}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{g v }}{\hlopt{-> }}{\hlstd{v
}}{\hlopt{(}}{\hlstd{g }}{\hlopt{((+) }}{\hlnum{1}}{\hlopt{)}}{\hlopt{))}}\\
{\hlstd{ \ }}{\hlopt{(}}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{g v }}{\hlopt{->
}}{\hlstd{v }}{\hlopt{(}}{\hlstd{g }}{\hlopt{((+)
}}{\hlnum{1}}{\hlopt{)}}{\hlopt{))}}\\
{\hlstd{ \ \ \ }}{\hlopt{(}}{\hlkwa{fun
}}{\hlstd{z}}{\hlopt{->}}{\hlnum{0}}{\hlopt{)}}{\hlopt{)}}{\hlstd{
}}{\hlopt{((+) }}{\hlnum{1}}{\hlopt{)}}
\[ \downsquigarrow \]
{\hlopt{}}{\hlopt{((+) }}{\hlnum{1}}{\hlopt{)}}{\hlstd{
}}{\hlopt{(}}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{g v }}{\hlopt{-> }}{\hlstd{v
}}{\hlopt{(}}{\hlstd{g }}{\hlopt{((+) }}{\hlnum{1}}{\hlopt{)}}{\hlopt{))}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ }}{\hlopt{(}}{\hlkwa{fun
}}{\hlstd{z}}{\hlopt{->}}{\hlnum{0}}{\hlopt{)}}{\hlstd{ }}{\hlopt{((+)
}}{\hlnum{1}}{\hlopt{)}}{\hlopt{)}}
\[ \downsquigarrow \]
{\hlopt{}}{\hlopt{((+) }}{\hlnum{1}}{\hlopt{)}}{\hlstd{
}}{\hlopt{(}}{\hlopt{((+) }}{\hlnum{1}}{\hlopt{)}}{\hlstd{
}}{\hlopt{(}}{\hlopt{(}}{\hlkwa{fun
}}{\hlstd{z}}{\hlopt{->}}{\hlnum{0}}{\hlopt{)}}{\hlstd{ }}{\hlopt{((+)
}}{\hlnum{1}}{\hlopt{)}}{\hlopt{))}}
\[ \downsquigarrow \]
{\hlopt{}}{\hlopt{((+) }}{\hlnum{1}}{\hlopt{)}}{\hlstd{
}}{\hlopt{(}}{\hlopt{((+) }}{\hlnum{1}}{\hlopt{)}}{\hlstd{
}}{\hlopt{(}}{\hlnum{0}}{\hlopt{))}}
\[ \downsquigarrow \]
{\hlopt{}}{\hlopt{((+) }}{\hlnum{1}}{\hlopt{)}}{\hlstd{ }}{\hlnum{1}}
\[ \downsquigarrow \]
{\hlopt{}}{\hlnum{2}}

\section{Recursion: Fixpoint Combinator}

\begin{itemize}
  \item Turing's fixpoint combinator: $\Theta = (\lambda x y.y (x x y)) 
  (\lambda x y.y (x x y))$
  \begin{eqnarray*}
    N & = & \Theta F\\
    & = & (\lambda x y.y (x x y))  (\lambda x y.y (x x y)) F\\
    & =_{\rightarrow \rightarrow} & F ((\lambda x y.y (x x y))  (\lambda x
    y.y (x x y)) F)\\
    & = & F (\Theta F) = F N
  \end{eqnarray*}
  \item Curry's fixpoint combinator: $\tmmathbf{Y}= \lambda f. (\lambda x.f (x
  x))  (\lambda x.f (x x))$
  \begin{eqnarray*}
    N & = & \tmmathbf{Y}F\\
    & = & (\lambda f. (\lambda x.f (x x))  (\lambda x.f (x x))) F\\
    & =_{\rightarrow} & (\lambda x.F (x x))  (\lambda x.F (x x))\\
    & =_{\rightarrow} & F ((\lambda x.F (x x))  (\lambda x.F (x x)))\\
    & =_{\leftarrow} & F ((\lambda f. (\lambda x.f (x x))  (\lambda x.f (x
    x))) F)\\
    & = & F (\tmmathbf{Y}F) = F N
  \end{eqnarray*}
  \item Call-by-value {\tmem{fix}}point combinator: $\lambda f' . (\lambda f
  x.f'  (f f) x)  (\lambda f x.f'  (f f) x)$
  \begin{eqnarray*}
    N & = & \tmop{fix} F\\
    & = & (\lambda f' . (\lambda f x.f'  (f f) x)  (\lambda f x.f'  (f f) x))
    F\\
    & =_{\rightarrow} & (\lambda f x.F (f f) x)  (\lambda f x.F (f f) x)\\
    & =_{\rightarrow} & \lambda x.F ((\lambda f x.F (f f) x)  (\lambda f x.F
    (f f) x)) x\\
    & =_{\leftarrow} & \lambda x.F ((\lambda f' . (\lambda f x.f'  (f f) x) 
    (\lambda f x.f'  (f f) x)) F) x\\
    & = & \lambda x.F (\tmop{fix} F) x = \lambda x.F N x\\
    & =_{\eta} & F N
  \end{eqnarray*}
  \item The $\lambda$-terms we have seen above are {\tmstrong{fixpoint
  combinators}} -- means inside $\lambda$-calculus to perform recursion.
  
  \item What is the problem with the first two combinators?
  \begin{eqnarray*}
    \Theta F & \rightsquigarrow \rightsquigarrow & F ((\lambda x y.y (x x y)) 
    (\lambda x y.y (x x y)) F)\\
    & \rightsquigarrow \rightsquigarrow & F (F ((\lambda x y.y (x x y)) 
    (\lambda x y.y (x x y)) F))\\
    & \rightsquigarrow \rightsquigarrow & F (F (F ((\lambda x y.y (x x y)) 
    (\lambda x y.y (x x y)) F)))\\
    & \rightsquigarrow \rightsquigarrow & \ldots
  \end{eqnarray*}
  \item Recall the distinction between {\tmem{expressions}} and
  {\tmem{values}} from the previous lecture {\tmem{Computation}}.
  
  \item The reduction rule for $\lambda$-calculus is just meant to determine
  which expressions are considered ``equal'' -- it is highly
  {\tmem{non-deterministic}}, while on a computer, computation needs to go one
  way or another.
  
  \item Using the general reduction rule of $\lambda$-calculus, for a
  recursive definition, it is always possible to find an infinite reduction
  sequence {\small{(which means that you couldn't complain when a nasty
  $\lambda$-calculus compiler generates infinite loops for all recursive
  definitions)}}.
  \begin{itemize}
    \item Why?
  \end{itemize}
  \item Therefore, we need more specific rules. For example, most languages
  use $\left( \text{\tmverbatim{fun }} x \text{\tmverbatim{->}} a \right) v
  \rightsquigarrow a [x \assign v]$, which is called {\tmem{call-by-value}},
  or {\tmstrong{eager}} computation (because the program {\tmem{eagerly}}
  computes the arguments before starting to compute the function). (It's
  exactly the rule we introduced in {\tmem{Computation}} lecture.)
  
  \item What happens with call-by-value fixpoint combinator?
  \begin{eqnarray*}
    \tmop{fix} F & \rightsquigarrow & (\lambda f x.F (f f) x)  (\lambda f x.F
    (f f) x)\\
    & \rightsquigarrow & \lambda x.F ((\lambda f x.F (f f) x)  (\lambda f x.F
    (f f) x)) x
  \end{eqnarray*}
  Voila -- if we use $\left( \text{\tmverbatim{fun }} x \text{\tmverbatim{->}}
  a \right) v \rightsquigarrow a [x \assign v]$ as the rule\\
  rather than $\left( \text{\tmverbatim{fun }} x \text{\tmverbatim{->}} a_1
  \right) a_2 \rightsquigarrow a_1 [x \assign a_2]$, the computation stops.
  Let's compute the function on some input:
  \begin{eqnarray*}
    \tmop{fix} F v & \rightsquigarrow & (\lambda f x.F (f f) x)  (\lambda f
    x.F (f f) x) v\\
    & \rightsquigarrow & (\lambda x.F ((\lambda f x.F (f f) x)  (\lambda f
    x.F (f f) x)) x) v\\
    & \rightsquigarrow & F ((\lambda f x.F (f f) x)  (\lambda f x.F (f f) x))
    v\\
    & \rightsquigarrow & F (\lambda x.F ((\lambda f x.F (f f) x)  (\lambda f
    x.F (f f) x)) x) v\\
    & \rightsquigarrow & \text{depends on } F
  \end{eqnarray*}
  \item Why the name {\tmem{fixpoint}}? If you look at our derivations, you'll
  see that they show what in math can be written as $x = f (x)$. Such values
  $x$ are called fixpoints of $f$. An arithmetic function can have several
  fixpoints, for example $f (x) = x^2$ (which $x$es are fixpoints?) or no
  fixpoints, for example $f (x) = x + 1$.
  
  \item When you define a function (or another object) by recursion, it has
  very similar meaning: there is a name that is on both sides of $=$.
  
  \item In $\lambda$-calculus, there are functions like $\Theta$ and
  $\tmmathbf{Y}$, that take {\tmem{any}} function as an argument, and return
  its fixpoint.
  
  \item We turn a specification of a recursive object into a definition, by
  solving it with respect to the recurring name: deriving $x = f (x)$ where
  $x$ is the recurring name. We then have $x = \tmop{fix} (f)$.
  
  \item Let's walk through it for the factorial function (we omit the prefix
  \tmverbatim{cn\_} -- could be \tmverbatim{pn\_} if \tmverbatim{pn1} was used
  instead of \tmverbatim{cn1} -- for numeric functions, and we shorten
  \text{\tmverbatim{if\_then\_else}} into \tmverbatim{if\_t\_e}):
  \begin{eqnarray*}
    \text{\tmverbatim{fact}} n & = & \text{\tmverbatim{if\_t\_e}}  \left(
    \text{\tmverbatim{is\_zero}} n \right)  \text{\tmverbatim{cn1}}  \left(
    \text{\tmverbatim{mult}} n \left( \text{\tmverbatim{fact}}  \left(
    \text{\tmverbatim{pred}} n \right) \right) \right)\\
    \text{\tmverbatim{fact}} & = & \lambda n. \text{\tmverbatim{if\_t\_e}} 
    \left( \text{\tmverbatim{is\_zero}} n \right)  \text{\tmverbatim{cn1}} 
    \left( \text{\tmverbatim{mult}} n \left( \text{\tmverbatim{fact}}  \left(
    \text{\tmverbatim{pred}} n \right) \right) \right)\\
    \text{\tmverbatim{fact}} & = & \left( \lambda f n.
    \text{\tmverbatim{if\_t\_e}}  \left( \text{\tmverbatim{is\_zero}} n
    \right)  \text{\tmverbatim{cn1}}  \left( \text{\tmverbatim{mult}} n \left(
    f \left( \text{\tmverbatim{pred}} n \right) \right) \right) \right) 
    \text{\tmverbatim{fact}}\\
    \text{\tmverbatim{fact}} & = & \tmop{fix} \left( \lambda f n.
    \text{\tmverbatim{if\_t\_e}}  \left( \text{\tmverbatim{is\_zero}} n
    \right)  \text{\tmverbatim{cn1}}  \left( \text{\tmverbatim{mult}} n \left(
    f \left( \text{\tmverbatim{pred}} n \right) \right) \right) \right)
  \end{eqnarray*}
  The last specification is a valid definition: we just give a name to a
  {\small{({\tmem{ground}}, a.k.a. {\tmem{closed}})}} expression.
  
  \item We have seen how {\hlkwa{fix}} works already!
  \begin{itemize}
    \item Compute \tmverbatim{fact cn2}.
  \end{itemize}
  \item What does \tmverbatim{fix ({\hlkwa{fun}} x {\hlopt{->}} cn\_succ x)}
  mean?
\end{itemize}

\section{Encoding of Lists and Trees}

\begin{itemize}
  \item A list is either empty, which we often call \tmverbatim{Empty} or
  \tmverbatim{Nil}, or it consists of an element followed by another list
  (called ``tail''), the other case often called \tmverbatim{Cons}.
  
  \item Define \tmverbatim{nil}$= \lambda x y.y$ and \tmverbatim{cons}$H T =
  \lambda x y.x H T$.
  
  \item Add numbers stored inside a list:
  \begin{eqnarray*}
    \text{\tmverbatim{addlist}} l & = & l \left( \lambda h t.
    \text{\tmverbatim{cn\_add}} h \left( \text{\tmverbatim{addlist}} t \right)
    \right)  \text{\tmverbatim{cn0}}
  \end{eqnarray*}
  To make a proper definition, we need to apply $\tmop{fix}$ to the solution
  of above equation.
  \begin{eqnarray*}
    \text{\tmverbatim{addlist}} & = & \tmop{fix} \left( \lambda f l.l \left(
    \lambda h t. \text{\tmverbatim{cn\_add}} h (f t) \right) 
    \text{\tmverbatim{cn0}} \right)
  \end{eqnarray*}
  \item For trees, let's use a different form of binary trees than so far:
  instead of keeping elements in inner nodes, we will keep elements in leaves.
  
  \item Define \tmverbatim{leaf}$n = \lambda x y.x n$ and \tmverbatim{node}$L
  R = \lambda x y.y L R$.
  
  \item Add numbers stored inside a tree:
  \begin{eqnarray*}
    \text{\tmverbatim{addtree}} t & = & t (\lambda n.n)  \left( \lambda l r.
    \text{\tmverbatim{cn\_add}}  \left( \text{\tmverbatim{addtree}} l \right) 
    \left( \text{\tmverbatim{addtree}} r \right) \right)
  \end{eqnarray*}
  and, in solved form:
  \begin{eqnarray*}
    \text{\tmverbatim{addtree}} & = & \tmop{fix} \left( \lambda f t.t (\lambda
    n.n)  \left( \lambda l r. \text{\tmverbatim{cn\_add}}  (f l)  (f r)
    \right) \right)
  \end{eqnarray*}
\end{itemize}
{\newpage}

{\hlkwa{let }}{\hlstd{nil }}{\hlopt{= }}{\hlkwa{fun }}{\hlstd{x y }}{\hlopt{->
}}{\hlstd{y}}{\hlendline{}}\\
{\hlkwa{let }}{\hlstd{cons h t }}{\hlopt{= }}{\hlkwa{fun }}{\hlstd{x y
}}{\hlopt{-> }}{\hlstd{x h t}}{\hlendline{}}\\
{\hlkwa{let }}{\hlstd{addlist l }}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlkwa{fix }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{f l }}{\hlopt{->
}}{\hlstd{l }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{h t }}{\hlopt{->
}}{\hlstd{cn{\textunderscore}add h }}{\hlopt{(}}{\hlstd{f t}}{\hlopt{))
}}{\hlstd{cn0}}{\hlopt{) }}{\hlstd{l}}{\hlendline{}}\\
{\hlopt{;;}}{\hlendline{}}\\
{\hlstd{decode{\textunderscore}cnat{\hlendline{}}\\
\ }}{\hlopt{(}}{\hlstd{addlist }}{\hlopt{(}}{\hlstd{cons cn1
}}{\hlopt{(}}{\hlstd{cons cn2 }}{\hlopt{(}}{\hlstd{cons cn7
nil}}{\hlopt{))));;}}{\hlendline{}}\\
{\hlkwa{let }}{\hlstd{leaf n }}{\hlopt{= }}{\hlkwa{fun }}{\hlstd{x y
}}{\hlopt{-> }}{\hlstd{x n}}{\hlendline{}}\\
{\hlkwa{let }}{\hlstd{node l r }}{\hlopt{= }}{\hlkwa{fun }}{\hlstd{x y
}}{\hlopt{-> }}{\hlstd{y l r}}{\hlendline{}}\\
{\hlkwa{let }}{\hlstd{addtree t }}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlkwa{fix }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{f t
}}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ t }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{n }}{\hlopt{->
}}{\hlstd{n}}{\hlopt{) (}}{\hlkwa{fun }}{\hlstd{l r }}{\hlopt{->
}}{\hlstd{cn{\textunderscore}add }}{\hlopt{(}}{\hlstd{f l}}{\hlopt{)
(}}{\hlstd{f r}}{\hlopt{))}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlopt{) }}{\hlstd{t}}{\hlendline{}}\\
{\hlopt{;;}}{\hlendline{}}\\
{\hlstd{decode{\textunderscore}cnat{\hlendline{}}\\
\ }}{\hlopt{(}}{\hlstd{addtree }}{\hlopt{(}}{\hlstd{node
}}{\hlopt{(}}{\hlstd{node }}{\hlopt{(}}{\hlstd{leaf cn3}}{\hlopt{)
(}}{\hlstd{leaf cn7}}{\hlopt{))}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ \ \ }}{\hlopt{(}}{\hlstd{leaf
cn1}}{\hlopt{)));;}}{\hlendline{}}{\newpage}
\begin{itemize}
  \item Observe a regularity: when we encode a variant type with $n$ variants,
  for each variant we define a function that takes $n$ arguments.
  
  \item If the $k$th variant $C_k$ has $m_k$ parameters, then the function
  $c_k$ that encodes it will have the form:
  \[ C_k (v_1, \ldots, v_{m_k}) \sim c_k v_1 \ldots v_{m_k} = \lambda x_1
     \ldots x_n .x_k v_1 \ldots v_{m_k} \]
  \item The encoded variants serve as a shallow pattern matching with
  guaranteed exhaustiveness: $k$th argument corresponds to $k$th branch of
  pattern matching.
\end{itemize}

\section{Looping Recursion}

\begin{itemize}
  \item Let's come back to numbers defined as lengths lists and define
  addition:
\end{itemize}
{\hlkwa{let }}{\hlstd{pn{\textunderscore}add m n }}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlkwa{fix }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{f m n
}}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ if{\textunderscore}then{\textunderscore}else
}}{\hlopt{(}}{\hlstd{pn{\textunderscore}is{\textunderscore}zero
m}}{\hlopt{)}}\\
{\hlstd{ \ \ \ \ \ n }}{\hlopt{(}}{\hlstd{pn{\textunderscore}succ
}}{\hlopt{(}}{\hlstd{f }}{\hlopt{(}}{\hlstd{pn{\textunderscore}pred
m}}{\hlopt{) }}{\hlstd{n}}{\hlopt{))}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlopt{) }}{\hlstd{m n}}{\hlopt{;;}}{\hlendline{}}\\
{\hlstd{decode{\textunderscore}pnat
}}{\hlopt{(}}{\hlstd{pn{\textunderscore}add pn3 pn3}}{\hlopt{);;}}
\begin{itemize}
  \item Oops... OCaml says:\\
  \tmverbatim{Stack overflow during evaluation (looping recursion?).}
  
  \item What is wrong? Nothing as far as $\lambda$-calculus is concerned. But
  OCaml and F\# always compute arguments before calling a function. By
  definition of {\hlkwa{fix}}, \tmverbatim{f} corresponds to recursively
  calling \tmverbatim{pn\_add}. Therefore,\\
  {\hlopt{(}}{\hlstd{pn{\textunderscore}succ }}{\hlopt{(}}{\hlstd{f
  }}{\hlopt{(}}{\hlstd{pn{\textunderscore}pred m}}{\hlopt{)
  }}{\hlstd{n}}{\hlopt{))}} will be called regardless of what\\
  {\hlopt{(}}{\hlstd{pn{\textunderscore}is{\textunderscore}zero m}}{\hlopt{)}}
  returns!
  
  \item Why \tmverbatim{addlist} and \tmverbatim{addtree} work?
  
  \item \tmverbatim{addlist} and \tmverbatim{addtree} work because their
  recursive calls are ``guarded'' by corresponding {\hlkwa{fun}}. What is
  inside of {\hlkwa{fun}} is not computed immediately, only when the function
  is applied to argument(s).
  
  \item To avoid looping recursion, you need to guard all recursive calls.
  Besides putting them inside {\hlkwa{fun}}, in OCaml or F\# you can also put
  them in branches of a {\hlkwa{match}} clause, as long as one of the branches
  does not have unguarded recursive calls!
  
  \item The trick to use with functions like \tmverbatim{if\_then\_else}, is
  to guard their arguments with {\hlkwa{fun}}\tmverbatim{ x}{\hlopt{ ->}},
  where \tmverbatim{x} is not used, and apply the {\tmem{result}} of
  \tmverbatim{if\_then\_else} to some dummy value.
  \begin{itemize}
    \item In OCaml or F\# we would guard by {\hlkwa{fun }}{\hlopt{() ->}}, and
    then apply to {\hlopt{()}}, but we do not have datatypes like
    \tmverbatim{unit} in $\lambda$-calculus.
  \end{itemize}
\end{itemize}
{\hlkwa{let }}{\hlstd{pn{\textunderscore}add m n }}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlkwa{fix }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{f m n
}}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \
}}{\hlopt{(}}{\hlstd{if{\textunderscore}then{\textunderscore}else
}}{\hlopt{(}}{\hlstd{pn{\textunderscore}is{\textunderscore}zero
m}}{\hlopt{)}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{x }}{\hlopt{->
}}{\hlstd{n}}{\hlopt{) (}}{\hlkwa{fun }}{\hlstd{x }}{\hlopt{->
}}{\hlstd{pn{\textunderscore}succ }}{\hlopt{(}}{\hlstd{f
}}{\hlopt{(}}{\hlstd{pn{\textunderscore}pred m}}{\hlopt{)
}}{\hlstd{n}}{\hlopt{)))}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ id{\hlendline{}}\\
\ }}{\hlopt{) }}{\hlstd{m n}}{\hlopt{;;}}{\hlendline{}}\\
{\hlstd{decode{\textunderscore}pnat
}}{\hlopt{(}}{\hlstd{pn{\textunderscore}add pn3
pn3}}{\hlopt{);;}}{\hlendline{}}\\
{\hlstd{decode{\textunderscore}pnat
}}{\hlopt{(}}{\hlstd{pn{\textunderscore}add pn3
pn7}}{\hlopt{);;}}{\hlendline{}}\\


\section{In-class Work and Homework}

\begin{enumerate}
  Define (implement) and verify:
  
  \item \tmverbatim{c\_or} and \tmverbatim{c\_not};
  
  \item exponentiation for Church numerals;
  
  \item is-zero predicate for Church numerals;
  
  \item even-number predicate for Church numerals;
  
  \item multiplication for pair-encoded natural numbers;
  
  \item factorial $n!$ for pair-encoded natural numbers.
  
  \item Construct $\lambda$-terms $m_0, m_1, \ldots$ such that for all $n$ one
  has:
  \begin{eqnarray*}
    m_0 & = & x\\
    m_{n + 1} & = & m_{n + 2} m_n
  \end{eqnarray*}
  (where equality is after performing $\beta$-reductions).
  
  \item Define (implement) and verify a function computing: the length of a
  list (in Church numerals);
  
  \item \tmverbatim{cn\_max} -- maximum of two Church numerals;
  
  \item the depth of a tree (in Church numerals).
  
  \item Representing side-effects as an explicitly ``passed around'' state
  value, write combinators that represent the imperative constructs:
  \begin{enumerate}
    \item {\hlkwa{for}}...{\hlkwa{to}}...
    
    \item {\hlkwa{for}}...{\hlkwa{downto}}...
    
    \item {\hlkwa{while}}...{\hlkwa{do}}...
    
    \item {\hlkwa{do}}...{\hlkwa{while}}...
    
    \item {\hlkwa{repeat}}...{\hlkwa{until}}...
  \end{enumerate}
  Rather than writing a $\lambda$-term using the encodings that we've learnt,
  just implement the functions in OCaml / F\#, using built-in {\hlkwb{int}}
  and {\hlkwb{bool}} types. You can use {\hlkwa{let rec}} instead of
  {\hlkwa{fix}}.
  \begin{itemize}
    \item For example, in exercise (a), write a function {\hlkwa{let rec
    }}\tmverbatim{for\_to f beg\_i end\_i s }{\hlopt{=}}... where
    \tmverbatim{f} takes arguments \tmverbatim{i} ranging from
    \tmverbatim{beg\_i} to \tmverbatim{end\_i}, state \tmverbatim{s} at given
    step, and returns state \tmverbatim{s} at next step; the
    \tmverbatim{for\_to} function returns the state after the last step.
    
    \item And in exercise (c), write a function {\hlkwa{let rec
    }}\tmverbatim{while\_do p f s }{\hlopt{=}}... where both \tmverbatim{p}
    and \tmverbatim{f} take state \tmverbatim{s} at given step, and if
    \tmverbatim{p s} returns true, then \tmverbatim{f s} is computed to obtain
    state at next step; the \tmverbatim{while\_do} function returns the state
    after the last step.
  \end{itemize}
  Do not use the imperative features of OCaml and F\#, we will not even cover
  them in this course!
\end{enumerate}
Despite we will not cover them, it is instructive to see the implementation
using the imperative features, to better understand what is actually required
of a solution to the last exercise.
\begin{enumeratealpha}
  \item {\hlkwa{let }}{\hlstd{for{\textunderscore}to f beg{\textunderscore}i
  end{\textunderscore}i s }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{s }}{\hlopt{= }}{\hlkwb{ref }}{\hlstd{s
  }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{for }}{\hlstd{i }}{\hlopt{=
  }}{\hlstd{beg{\textunderscore}i }}{\hlkwa{to }}{\hlstd{end{\textunderscore}i
  }}{\hlkwa{do}}{\hlendline{}}\\
  {\hlstd{ \ \ \ s }}{\hlopt{:= }}{\hlstd{f i
  }}{\hlopt{!}}{\hlstd{s{\hlendline{}}\\
  \ }}{\hlkwa{done}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlopt{!}}{\hlstd{s}}
  
  \item {\hlkwa{let }}{\hlstd{for{\textunderscore}downto f
  beg{\textunderscore}i end{\textunderscore}i s }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{s }}{\hlopt{= }}{\hlkwb{ref }}{\hlstd{s
  }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{for }}{\hlstd{i }}{\hlopt{=
  }}{\hlstd{beg{\textunderscore}i }}{\hlkwa{downto
  }}{\hlstd{end{\textunderscore}i }}{\hlkwa{do}}{\hlendline{}}\\
  {\hlstd{ \ \ \ s }}{\hlopt{:= }}{\hlstd{f i
  }}{\hlopt{!}}{\hlstd{s{\hlendline{}}\\
  \ }}{\hlkwa{done}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlopt{!}}{\hlstd{s}}
  
  \item {\hlkwa{let }}{\hlstd{while{\textunderscore}do p f s
  }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{s }}{\hlopt{= }}{\hlkwb{ref }}{\hlstd{s
  }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{while }}{\hlstd{p }}{\hlopt{!}}{\hlstd{s
  }}{\hlkwa{do}}{\hlendline{}}\\
  {\hlstd{ \ \ \ s }}{\hlopt{:= }}{\hlstd{f
  }}{\hlopt{!}}{\hlstd{s{\hlendline{}}\\
  \ }}{\hlkwa{done}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlopt{!}}{\hlstd{s}}
  
  \item {\hlkwa{let }}{\hlstd{do{\textunderscore}while p f s
  }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{s }}{\hlopt{= }}{\hlkwb{ref
  }}{\hlopt{(}}{\hlstd{f s}}{\hlopt{) }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{while }}{\hlstd{p }}{\hlopt{!}}{\hlstd{s
  }}{\hlkwa{do}}{\hlendline{}}\\
  {\hlstd{ \ \ \ s }}{\hlopt{:= }}{\hlstd{f
  }}{\hlopt{!}}{\hlstd{s{\hlendline{}}\\
  \ }}{\hlkwa{done}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlopt{!}}{\hlstd{s}}
  
  \item {\hlkwa{let }}{\hlstd{repeat{\textunderscore}until p f s
  }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{s }}{\hlopt{= }}{\hlkwb{ref
  }}{\hlopt{(}}{\hlstd{f s}}{\hlopt{) }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{while }}{\hlstd{not }}{\hlopt{(}}{\hlstd{p
  }}{\hlopt{!}}{\hlstd{s}}{\hlopt{) }}{\hlkwa{do}}{\hlendline{}}\\
  {\hlstd{ \ \ \ s }}{\hlopt{:= }}{\hlstd{f
  }}{\hlopt{!}}{\hlstd{s{\hlendline{}}\\
  \ }}{\hlkwa{done}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlopt{!}}{\hlstd{s}}
\end{enumeratealpha}

\end{document}
