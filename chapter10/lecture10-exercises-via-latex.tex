\documentclass{article}
\usepackage[english]{babel}
\usepackage{geometry,amsmath,hyperref,theorem}
\geometry{letterpaper}

%%%%%%%%%% Start TeXmacs macros
\catcode`\>=\active \def>{
\fontencoding{T1}\selectfont\symbol{62}\fontencoding{\encodingdefault}}
\newcommand{\tmem}[1]{{\em #1\/}}
\newcommand{\tmverbatim}[1]{\text{{\ttfamily{#1}}}}
{\theorembodyfont{\rmfamily\small}\newtheorem{exercise}{Exercise}}
%%%%%%%%%% End TeXmacs macros

\begin{document}

{\class{Functional Programming}}

{\title{Zippers, Reactivity, GUIs}}

\begin{exercise}
  Introduce operators $-, /$ into the context rewriting ``pull out
  subexpression'' example. Remember that they are not commutative.
\end{exercise}

\begin{exercise}
  Add to the {\tmem{paddle game}} example:
  \begin{enumerate}
    \item game restart,
    
    \item score keeping,
    
    \item game quitting (in more-or-less elegant way).
  \end{enumerate}
\end{exercise}

\begin{exercise}
  Our numerical integration function roughly corresponds to the rectangle
  rule. Modify the rule and write a test for the accuracy of:
  \begin{enumerate}
    \item the trapezoidal rule;
    
    \item the Simpson's rule.
    \href{http://en.wikipedia.org/wiki/Simpson%27s_rule}{http://en.wikipedia.org/wiki/Simpson\%27s\_rule}
  \end{enumerate}
\end{exercise}

\begin{exercise}
  Explain the recursive behavior of integration:
  \begin{enumerate}
    \item In {\tmem{paddle game}} implemented by stream processing --
    \tmverbatim{Lec10b.ml}, do we look at past velocity to determine current
    position, at past position to determine current velocity, both, or
    neither?
    
    \item What is the difference between \tmverbatim{integral} and
    \tmverbatim{integral\_nice} in \tmverbatim{Lec10c.ml}, what happens when
    we replace the former with the latter in the \tmverbatim{pbal} function?
    How about after rewriting \tmverbatim{pbal} into pure style as in the
    following exercise?
  \end{enumerate}
\end{exercise}

\begin{exercise}
  Reimplement the {\tmem{Froc}} based paddle ball example in a pure style:
  rewrite the \tmverbatim{pbal} function to not use \tmverbatim{notify\_e}.
\end{exercise}

\begin{exercise}
  * Our implementation of flows is a bit heavy. One alternative approach is to
  use continuations, as in \tmverbatim{Scala.React}. OCaml has a continuations
  library {\tmem{Delimcc}}; for how it can cooperate with {\tmem{Froc}}, see\\
  \href{http://ambassadortothecomputers.blogspot.com/2010/08/mixing-monadic-and-direct-style-code.html}{http://ambassadortothecomputers.blogspot.com/2010/08/mixing-monadic-and-direct-style-code.html}
\end{exercise}

\begin{exercise}
  Implement \tmverbatim{parallel} for flows, retaining coarse-grained
  implementation and using the event queue from {\tmem{Froc}} somehow (instead
  of introducing a new job queue).
\end{exercise}

\begin{exercise}
  Add quitting, e.g. via a \tmverbatim{'q'} key press, to the {\tmem{painter}}
  example. Use the \tmverbatim{is\_cancelled} function.
\end{exercise}

\begin{exercise}
  Our calculator example is not finished. Implement entering decimal
  fractions: add handling of the \tmverbatim{dots} event.
\end{exercise}

\begin{exercise}
  The {\hlkwc{Flow}} module has reader monad functions that have not been
  discussed on slides:\\
  {\hlkwa{let }}{\hlstd{local f m }}{\hlopt{= }}{\hlkwa{fun }}{\hlstd{emit
  }}{\hlopt{-> }}{\hlstd{m }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{x }}{\hlopt{->
  }}{\hlstd{emit }}{\hlopt{(}}{\hlstd{f x}}{\hlopt{))}}{\hlendline{}}\\
  {\hlkwa{let }}{\hlstd{local{\textunderscore}opt f m }}{\hlopt{=
  }}{\hlkwa{fun }}{\hlstd{emit }}{\hlopt{->}}{\hlendline{}}\\
  {\hlstd{ \ m }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{x }}{\hlopt{->
  }}{\hlkwa{match }}{\hlstd{f x }}{\hlkwa{with }}{\hlkwd{None }}{\hlopt{-> ()
  \textbar }}{\hlkwd{Some }}{\hlstd{y }}{\hlopt{-> }}{\hlstd{emit
  y}}{\hlopt{)}}{\hlendline{}}\\
  {\hlkwa{val }}{\hlstd{local }}{\hlopt{: (}}{\hlstd{'a }}{\hlopt{->
  }}{\hlstd{'b}}{\hlopt{) -> (}}{\hlstd{'a}}{\hlopt{, }}{\hlstd{'c}}{\hlopt{)
  }}{\hlstd{flow }}{\hlopt{-> (}}{\hlstd{'b}}{\hlopt{, }}{\hlstd{'c}}{\hlopt{)
  }}{\hlstd{flow}}{\hlendline{}}\\
  {\hlkwa{val }}{\hlstd{local{\textunderscore}opt }}{\hlopt{: (}}{\hlstd{'a
  }}{\hlopt{-> }}{\hlstd{'b }}{\hlkwb{option}}{\hlopt{) ->
  (}}{\hlstd{'a}}{\hlopt{, }}{\hlstd{'c}}{\hlopt{) }}{\hlstd{flow }}{\hlopt{->
  (}}{\hlstd{'b}}{\hlopt{, }}{\hlstd{'c}}{\hlopt{)
  }}{\hlstd{flow}}{\hlendline{}}
  
  Implement an example that uses this compositionality-increasing capability.
\end{exercise}

\

\end{document}
