<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Lukasz Stafiniak" />
  <title>Curious OCaml</title>
  <style>
    html {
      font-size: 11pt;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Curious OCaml</h1>
<p class="author">Lukasz Stafiniak</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#curious-ocaml" id="toc-curious-ocaml">Curious OCaml</a>
<ul>
<li><a href="#chapter-1-logic" id="toc-chapter-1-logic">Chapter 1:
Logic</a>
<ul>
<li><a href="#in-the-beginning-there-was-logos"
id="toc-in-the-beginning-there-was-logos">1.1 In the Beginning there was
Logos</a></li>
<li><a href="#rules-for-logical-connectives"
id="toc-rules-for-logical-connectives">1.2 Rules for Logical
Connectives</a></li>
<li><a href="#logos-was-programmed-in-ocaml"
id="toc-logos-was-programmed-in-ocaml">1.3 Logos was Programmed in
OCaml</a></li>
<li><a href="#exercises" id="toc-exercises">1.4 Exercises</a></li>
</ul></li>
<li><a href="#chapter-2-algebra" id="toc-chapter-2-algebra">Chapter 2:
Algebra</a>
<ul>
<li><a href="#a-glimpse-at-type-inference"
id="toc-a-glimpse-at-type-inference">2.1 A Glimpse at Type
Inference</a></li>
<li><a href="#algebraic-data-types" id="toc-algebraic-data-types">2.2
Algebraic Data Types</a></li>
<li><a href="#syntactic-bread-and-sugar"
id="toc-syntactic-bread-and-sugar">2.3 Syntactic Bread and
Sugar</a></li>
<li><a href="#pattern-matching" id="toc-pattern-matching">2.4 Pattern
Matching</a></li>
<li><a href="#differentiating-algebraic-data-types"
id="toc-differentiating-algebraic-data-types">2.6 Differentiating
Algebraic Data Types</a></li>
<li><a href="#exercises-1" id="toc-exercises-1">2.7 Exercises</a></li>
</ul></li>
<li><a href="#chapter-3-computation"
id="toc-chapter-3-computation">Chapter 3: Computation</a>
<ul>
<li><a href="#function-composition" id="toc-function-composition">3.1
Function Composition</a></li>
<li><a href="#evaluation-rules-reduction-semantics"
id="toc-evaluation-rules-reduction-semantics">3.2 Evaluation Rules
(Reduction Semantics)</a></li>
<li><a href="#symbolic-derivation-example"
id="toc-symbolic-derivation-example">3.3 Symbolic Derivation
Example</a></li>
<li><a href="#tail-calls-and-tail-recursion"
id="toc-tail-calls-and-tail-recursion">3.4 Tail Calls and Tail
Recursion</a></li>
</ul></li>
</ul></li>
<li><a href="#unfold-1000000" id="toc-unfold-1000000">unfold
1000000;;</a></li>
<li><a href="#unfold_tcall-1000000"
id="toc-unfold_tcall-1000000">unfold_tcall [] 1000000;;</a>
<ul>
<li><a href="#first-encounter-of-continuation-passing-style"
id="toc-first-encounter-of-continuation-passing-style">3.5 First
Encounter of Continuation Passing Style</a></li>
<li><a href="#language-and-rules-of-the-untyped-lambda-calculus"
id="toc-language-and-rules-of-the-untyped-lambda-calculus">4.2 Language
and Rules of the Untyped Lambda-Calculus</a></li>
<li><a href="#booleans" id="toc-booleans">4.3 Booleans</a></li>
<li><a href="#if-then-else-and-pairs"
id="toc-if-then-else-and-pairs">4.4 If-then-else and Pairs</a></li>
<li><a href="#pair-encoded-natural-numbers"
id="toc-pair-encoded-natural-numbers">4.5 Pair-Encoded Natural
Numbers</a></li>
<li><a href="#church-numerals" id="toc-church-numerals">4.6 Church
Numerals</a></li>
<li><a href="#looping-recursion" id="toc-looping-recursion">4.9 Looping
Recursion</a></li>
<li><a href="#exercises-2" id="toc-exercises-2">4.10 Exercises</a></li>
<li><a href="#parametric-types" id="toc-parametric-types">5.2 Parametric
Types</a></li>
<li><a href="#type-inference-formally"
id="toc-type-inference-formally">5.3 Type Inference, Formally</a></li>
<li><a href="#implementing-maps-association-lists"
id="toc-implementing-maps-association-lists">5.8 Implementing Maps:
Association Lists</a></li>
<li><a href="#implementing-maps-binary-search-trees"
id="toc-implementing-maps-binary-search-trees">5.9 Implementing Maps:
Binary Search Trees</a></li>
<li><a href="#exercises-3" id="toc-exercises-3">Exercises</a></li>
<li><a href="#chapter-6-folding-and-backtracking"
id="toc-chapter-6-folding-and-backtracking">Chapter 6: Folding and
Backtracking</a>
<ul>
<li><a href="#basic-generic-list-operations"
id="toc-basic-generic-list-operations">6.1 Basic Generic List
Operations</a></li>
<li><a href="#making-fold-tail-recursive"
id="toc-making-fold-tail-recursive">6.2 Making Fold
Tail-Recursive</a></li>
<li><a href="#map-and-fold-for-trees-and-other-structures"
id="toc-map-and-fold-for-trees-and-other-structures">6.3 Map and Fold
for Trees and Other Structures</a></li>
<li><a href="#point-free-programming"
id="toc-point-free-programming">6.4 Point-Free Programming</a></li>
<li><a href="#reductions-and-more-higher-order-functions"
id="toc-reductions-and-more-higher-order-functions">6.5 Reductions and
More Higher-Order Functions</a></li>
<li><a href="#grouping-and-map-reduce"
id="toc-grouping-and-map-reduce">6.6 Grouping and Map-Reduce</a></li>
<li><a href="#higher-order-functions-for-the-option-type"
id="toc-higher-order-functions-for-the-option-type">6.7 Higher-Order
Functions for the Option Type</a></li>
<li><a href="#the-countdown-problem-puzzle"
id="toc-the-countdown-problem-puzzle">6.8 The Countdown Problem
Puzzle</a></li>
<li><a href="#the-honey-islands-puzzle"
id="toc-the-honey-islands-puzzle">6.9 The Honey Islands Puzzle</a></li>
<li><a href="#constraint-based-puzzles"
id="toc-constraint-based-puzzles">6.10 Constraint-Based Puzzles</a></li>
<li><a href="#exercises-4" id="toc-exercises-4">6.11 Exercises</a></li>
</ul></li>
<li><a href="#chapter-7-laziness" id="toc-chapter-7-laziness">Chapter 7:
Laziness</a>
<ul>
<li><a href="#evaluation-strategies-and-parameter-passing"
id="toc-evaluation-strategies-and-parameter-passing">7.1 Evaluation
Strategies and Parameter Passing</a></li>
<li><a href="#call-by-name-streams" id="toc-call-by-name-streams">7.2
Call-by-name: Streams</a></li>
<li><a href="#lazy-values" id="toc-lazy-values">7.3 Lazy Values</a></li>
<li><a href="#power-series-and-differential-equations"
id="toc-power-series-and-differential-equations">7.4 Power Series and
Differential Equations</a></li>
<li><a href="#arbitrary-precision-computation"
id="toc-arbitrary-precision-computation">7.5 Arbitrary Precision
Computation</a></li>
<li><a href="#circular-data-structures-double-linked-lists"
id="toc-circular-data-structures-double-linked-lists">7.6 Circular Data
Structures: Double-Linked Lists</a></li>
<li><a href="#input-output-streams" id="toc-input-output-streams">7.7
Input-Output Streams</a></li>
<li><a href="#pipes" id="toc-pipes">7.8 Pipes</a></li>
<li><a href="#example-pretty-printing"
id="toc-example-pretty-printing">7.9 Example: Pretty-Printing</a></li>
</ul></li>
</ul></li>
<li><a href="#let-print_endline-pretty-30-test_doc"
id="toc-let-print_endline-pretty-30-test_doc">let () = print_endline
(pretty 30 test_doc);;</a></li>
<li><a href="#let-print_endline-pretty-20-test_doc"
id="toc-let-print_endline-pretty-20-test_doc">let () = print_endline
(pretty 20 test_doc);;</a></li>
<li><a href="#let-print_endline-pretty-60-test_doc"
id="toc-let-print_endline-pretty-60-test_doc">let () = print_endline
(pretty 60 test_doc);;</a>
<ul>
<li><a href="#chapter-8-monads" id="toc-chapter-8-monads">Chapter 8:
Monads</a>
<ul>
<li><a href="#list-comprehensions" id="toc-list-comprehensions">8.1 List
Comprehensions</a></li>
<li><a href="#generalized-comprehensions-binding-operators"
id="toc-generalized-comprehensions-binding-operators">8.2 Generalized
Comprehensions: Binding Operators</a></li>
<li><a href="#monads" id="toc-monads">8.3 Monads</a></li>
<li><a href="#monad-laws" id="toc-monad-laws">8.4 Monad Laws</a></li>
<li><a href="#monoid-laws-and-monad-plus"
id="toc-monoid-laws-and-monad-plus">8.5 Monoid Laws and
Monad-Plus</a></li>
<li><a href="#backtracking-computation-with-choice"
id="toc-backtracking-computation-with-choice">8.6 Backtracking:
Computation with Choice</a></li>
<li><a href="#the-two-metaphors" id="toc-the-two-metaphors">8.9 The Two
Metaphors</a></li>
<li><a href="#monad-classes-and-instances"
id="toc-monad-classes-and-instances">8.10 Monad Classes and
Instances</a></li>
<li><a href="#monad-instances" id="toc-monad-instances">8.11 Monad
Instances</a></li>
<li><a href="#exercises-5" id="toc-exercises-5">8.15 Exercises</a></li>
</ul></li>
<li><a href="#chapter-9-algebraic-effects"
id="toc-chapter-9-algebraic-effects">Chapter 9: Algebraic Effects</a>
<ul>
<li><a href="#from-monads-to-effects"
id="toc-from-monads-to-effects">9.1 From Monads to Effects</a></li>
<li><a href="#lightweight-threads-with-effects"
id="toc-lightweight-threads-with-effects">9.2 Lightweight Threads with
Effects</a></li>
<li><a href="#importance-sampling" id="toc-importance-sampling">9.6
Importance Sampling</a></li>
<li><a href="#particle-filter-with-replay"
id="toc-particle-filter-with-replay">9.8 Particle Filter with
Replay</a></li>
<li><a href="#comparing-inference-methods"
id="toc-comparing-inference-methods">9.9 Comparing Inference
Methods</a></li>
<li><a href="#summary" id="toc-summary">9.10 Summary</a></li>
<li><a href="#exercises-6" id="toc-exercises-6">9.11 Exercises</a></li>
</ul></li>
<li><a href="#chapter-10-functional-reactive-programming"
id="toc-chapter-10-functional-reactive-programming">Chapter 10:
Functional Reactive Programming</a>
<ul>
<li><a href="#zippers" id="toc-zippers">10.1 Zippers</a></li>
<li><a href="#reactivity-by-stream-processing"
id="toc-reactivity-by-stream-processing">10.5 Reactivity by Stream
Processing</a></li>
<li><a href="#frp-by-incremental-computing-lwd"
id="toc-frp-by-incremental-computing-lwd">10.6 FRP by Incremental
Computing (Lwd)</a></li>
<li><a href="#summary-1" id="toc-summary-1">10.8 Summary</a></li>
<li><a href="#exercises-7" id="toc-exercises-7">10.9 Exercises</a></li>
</ul></li>
<li><a href="#chapter-11-the-expression-problem"
id="toc-chapter-11-the-expression-problem">Chapter 11: The Expression
Problem</a>
<ul>
<li><a href="#the-expression-problem-definition"
id="toc-the-expression-problem-definition">11.1 The Expression Problem:
Definition</a></li>
<li><a
href="#functional-programming-non-solution-ordinary-algebraic-datatypes"
id="toc-functional-programming-non-solution-ordinary-algebraic-datatypes">11.2
Functional Programming Non-Solution: Ordinary Algebraic
Datatypes</a></li>
<li><a href="#object-oriented-programming-subtyping"
id="toc-object-oriented-programming-subtyping">11.4 Object-Oriented
Programming: Subtyping</a></li>
<li><a href="#polymorphic-variants" id="toc-polymorphic-variants">11.7
Polymorphic Variants</a></li>
<li><a href="#parser-combinators" id="toc-parser-combinators">11.9
Parser Combinators</a></li>
<li><a href="#parser-combinators-implementation"
id="toc-parser-combinators-implementation">11.10 Parser Combinators:
Implementation</a></li>
<li><a href="#parser-combinators-dynamic-code-loading"
id="toc-parser-combinators-dynamic-code-loading">11.12 Parser
Combinators: Dynamic Code Loading</a></li>
<li><a href="#exercises-8" id="toc-exercises-8">11.14 Exercises</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<!-- Do NOT modify this file, it is automatically generated -->
<h1 id="curious-ocaml">Curious OCaml</h1>
<p><em>Curious OCaml</em> invites you to explore programming through the
lens of types, logic, and algebra. OCaml is a language that rewards
curiosity—its type system catches errors before your code runs, its
functional style encourages clear thinking about data transformations,
and its mathematical foundations reveal deep connections between
programming and logic. Whether you’re new to programming, experienced
with OCaml, or a seasoned developer discovering functional programming
for the first time, this book aims to spark that “aha!” moment when
abstract concepts click into place.</p>
<p>This book is intended for three audiences:</p>
<ul>
<li>New to programming: ambitious students in areas with formal rigor –
math, computer science, philosophy, linguistics, etc.</li>
<li>Intermediate: OCaml programmers.</li>
<li>Advanced: programmers who are new to functional programming.</li>
</ul>
<h2 id="chapter-1-logic">Chapter 1: Logic</h2>
<p><em>From logic rules to programming constructs</em></p>
<p><strong>In this chapter, you will:</strong></p>
<ul>
<li>Learn natural-deduction rules for the core connectives (<span
class="math inline">\top, \bot, \wedge, \vee, \rightarrow</span>)</li>
<li>Practice reading and building derivation trees (including
hypothetical derivations)</li>
<li>See the Curry–Howard correspondence emerge in OCaml typing
rules</li>
<li>Connect logical reasoning patterns (cases, induction) to programming
patterns (pattern matching, recursion)</li>
</ul>
<p><strong>Conventions.</strong> OCaml code blocks are intended to be
runnable unless marked with <code>ocaml skip</code> (used for
illustrative or partial snippets).</p>
<p>Throughout this chapter we use <em>natural deduction</em> in the
style of intuitionistic (constructive) logic. This choice is not
accidental: it is exactly the fragment of logic that lines up with the
“pure” core of functional programming via the Curry–Howard
correspondence.</p>
<h3 id="in-the-beginning-there-was-logos">1.1 In the Beginning there was
Logos</h3>
<p>What logical connectives do you know? Before we write any code, let
us take a step back and think about logic itself. The connectives listed
below form the foundation of reasoning, and as we will discover, they
also form the foundation of programming.</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th><span class="math inline">\top</span></th>
<th><span class="math inline">\bot</span></th>
<th><span class="math inline">\wedge</span></th>
<th><span class="math inline">\vee</span></th>
<th><span class="math inline">\rightarrow</span></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td><span class="math inline">a \wedge b</span></td>
<td><span class="math inline">a \vee b</span></td>
<td><span class="math inline">a \rightarrow b</span></td>
</tr>
<tr>
<td>truth</td>
<td>falsehood</td>
<td>conjunction</td>
<td>disjunction</td>
<td>implication</td>
</tr>
<tr>
<td>“trivial”</td>
<td>“impossible”</td>
<td><span class="math inline">a</span> and <span
class="math inline">b</span></td>
<td><span class="math inline">a</span> or <span
class="math inline">b</span></td>
<td><span class="math inline">a</span> gives <span
class="math inline">b</span></td>
</tr>
<tr>
<td></td>
<td>shouldn’t get</td>
<td>got both</td>
<td>got at least one</td>
<td>given <span class="math inline">a</span>, we get <span
class="math inline">b</span></td>
</tr>
</tbody>
</table>
<p>How can we define these connectives precisely? The key insight is to
think in terms of <em>derivation trees</em>. A derivation tree shows how
we arrive at conclusions from premises, building up knowledge step by
step:</p>
<p><span class="math display">
\frac{
\frac{\frac{\,}{\text{a premise}} \; \frac{\,}{\text{another
premise}}}{\text{some fact}} \;
\frac{\frac{\,}{\text{this we have by default}}}{\text{another fact}}}
{\text{final conclusion}}
</span></p>
<p>We define connectives by providing rules for using them. For example,
a rule <span class="math inline">\frac{a \; b}{c}</span> matches parts
of the tree that have two premises, represented by variables <span
class="math inline">a</span> and <span class="math inline">b</span>, and
have any conclusion, represented by variable <span
class="math inline">c</span>. These variables act as placeholders that
can match any proposition.</p>
<p><strong>Design principle:</strong> When defining a connective, we try
to use only that connective in its definition. This keeps definitions
self-contained and avoids circular dependencies between connectives.</p>
<h3 id="rules-for-logical-connectives">1.2 Rules for Logical
Connectives</h3>
<p>Each logical connective comes with two kinds of rules:</p>
<p><strong>Introduction rules</strong> tell us how to <em>produce</em>
or <em>construct</em> a connective. If you want to prove “A and B”, the
introduction rule tells you what you need: proofs of both A and B.</p>
<p><strong>Elimination rules</strong> tell us how to <em>use</em> or
<em>consume</em> a connective. If you already have “A and B”, the
elimination rules tell you what you can get from it: either A or B (your
choice).</p>
<p>In the table below, text in parentheses provides informal commentary.
Letters like <span class="math inline">a</span>, <span
class="math inline">b</span>, and <span class="math inline">c</span> are
variables that can stand for any proposition.</p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 38%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr>
<th>Connective</th>
<th>Introduction Rules</th>
<th>Elimination Rules</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\top</span></td>
<td><span class="math inline">\frac{}{\top}</span></td>
<td>doesn’t have</td>
</tr>
<tr>
<td><span class="math inline">\bot</span></td>
<td>doesn’t have</td>
<td><span class="math inline">\frac{\bot}{a}</span> (i.e.,
anything)</td>
</tr>
<tr>
<td><span class="math inline">\wedge</span></td>
<td><span class="math inline">\frac{a \quad b}{a \wedge b}</span></td>
<td><span class="math inline">\frac{a \wedge b}{a}</span> (take first)  
<span class="math inline">\frac{a \wedge b}{b}</span> (take second)</td>
</tr>
<tr>
<td><span class="math inline">\vee</span></td>
<td><span class="math inline">\frac{a}{a \vee b}</span> (put first)  
<span class="math inline">\frac{b}{a \vee b}</span> (put second)</td>
<td><span class="math inline">\frac{a \vee b \quad
\genfrac{}{}{0pt}{}{[a]^x}{\vdots \; c} \quad
\genfrac{}{}{0pt}{}{[b]^y}{\vdots \; c}}{c}</span> using <span
class="math inline">x, y</span></td>
</tr>
<tr>
<td><span class="math inline">\rightarrow</span></td>
<td><span class="math inline">\frac{\genfrac{}{}{0pt}{}{[a]^x}{\vdots \;
b}}{a \rightarrow b}</span> using <span
class="math inline">x</span></td>
<td><span class="math inline">\frac{a \rightarrow b \quad
a}{b}</span></td>
</tr>
</tbody>
</table>
<h4 id="notation-for-hypothetical-derivations">Notation for Hypothetical
Derivations</h4>
<p>The notation <span
class="math inline">\genfrac{}{}{0pt}{}{[a]^x}{\vdots \; b}</span>
(sometimes written as a tree) matches any subtree that derives <span
class="math inline">b</span> and can use <span
class="math inline">a</span> as an assumption (marked with label <span
class="math inline">x</span>), even though <span
class="math inline">a</span> might not otherwise be warranted. The
square brackets around <span class="math inline">a</span> indicate that
this is a <em>hypothetical</em> assumption, not something we have
actually established. The superscript <span class="math inline">x</span>
is a label that helps us track which assumption gets “discharged” when
we complete the derivation.</p>
<p>This is the key to proving implications: to prove “if A then B”, we
temporarily assume A and show we can derive B. For example, we can
derive “sunny <span class="math inline">\rightarrow</span> happy” by
showing that <em>assuming</em> it is sunny, we can derive happiness:</p>
<p><span class="math display">
\frac{\frac{\frac{\frac{\frac{\,}{\text{sunny}}^x}{\text{go
outdoor}}}{\text{playing}}}{\text{happy}}}{\text{sunny} \rightarrow
\text{happy}} \text{ using } x
</span></p>
<p>Notice how the assumption “sunny” (marked with <span
class="math inline">x</span>) appears at the top of the derivation tree.
We use this assumption to derive “go outdoor”, then “playing”, and
finally “happy”. Once we complete the derivation, the assumption is
<em>discharged</em>: we no longer need to assume it is sunny because we
have established the conditional “sunny <span
class="math inline">\rightarrow</span> happy”.</p>
<p>A crucial point: such assumptions can only be used within the matched
subtree! However, they can be used <em>multiple times</em> within that
subtree. For example, if someone’s mood is more difficult to influence
and requires multiple sunny conditions:</p>
<p><span class="math display">
\frac{\frac{
  \frac{\frac{\frac{\,}{\text{sunny}}^x}{\text{go
outdoor}}}{\text{playing}} \quad
  \frac{\frac{\,}{\text{sunny}}^x \quad
\frac{\frac{\,}{\text{sunny}}^x}{\text{go outdoor}}}{\text{nice view}}
}{\text{happy}}}{\text{sunny} \rightarrow \text{happy}} \text{ using } x
</span></p>
<p>In this more complex derivation, the assumption “sunny” (labeled
<span class="math inline">x</span>) is used three times: once to derive
“go outdoor”, and twice more in deriving “nice view”. All three uses are
valid because they occur within the same hypothetical subtree.</p>
<h4 id="reasoning-by-cases">Reasoning by Cases</h4>
<p>The elimination rule for disjunction deserves special attention
because it represents <strong>reasoning by cases</strong>, one of the
most fundamental proof techniques.</p>
<p>Suppose we know “A or B” is true, but we do not know which one. How
can we still derive a conclusion C? We must show that C follows
<em>regardless</em> of which alternative holds. In other words, we need
to prove: (1) assuming A, we can derive C, and (2) assuming B, we can
derive C. Since one of A or B must be true, and both lead to C, we can
conclude C.</p>
<p>Here is a concrete example: How can we use the fact that it is sunny
<span class="math inline">\vee</span> cloudy (but not rainy)?</p>
<p><span class="math display">
\frac{
  \frac{\,}{\text{sunny} \vee \text{cloudy}}^{\text{forecast}} \quad
  \frac{\frac{\,}{\text{sunny}}^x}{\text{no-umbrella}} \quad
  \frac{\frac{\,}{\text{cloudy}}^y}{\text{no-umbrella}}
}{\text{no-umbrella}} \text{ using } x, y
</span></p>
<p>We know that it will be sunny or cloudy (by watching the weather
forecast). Now we reason by cases: <em>If</em> it will be sunny, we will
not need an umbrella. <em>If</em> it will be cloudy, we will not need an
umbrella. Since one of these must be the case, and both lead to the same
conclusion, we can confidently say: we will not need an umbrella.</p>
<h4 id="reasoning-by-induction">Reasoning by Induction</h4>
<p>We need one more kind of rule to do serious math: <strong>reasoning
by induction</strong>. This rule is somewhat similar to reasoning by
cases, but instead of considering a finite number of alternatives, it
allows us to prove properties that hold for infinitely many cases, such
as all natural numbers.</p>
<p>Here is the example rule for induction on natural numbers:</p>
<p><span class="math display">
\frac{p(0) \quad \genfrac{}{}{0pt}{}{[p(x)]^x}{\vdots \; p(x+1)}}{p(n)}
\text{ by induction, using } x
</span></p>
<p>This rule says: we get property <span class="math inline">p</span>
for <em>any</em> natural number <span class="math inline">n</span>,
provided we can do two things:</p>
<ol type="1">
<li><strong>Base case:</strong> Establish <span
class="math inline">p(0)</span>, that is, prove the property holds for
zero.</li>
<li><strong>Inductive step:</strong> Show that <em>assuming</em> <span
class="math inline">p(x)</span> holds for some arbitrary <span
class="math inline">x</span>, we can derive <span
class="math inline">p(x+1)</span>. This assumption <span
class="math inline">p(x)</span> is called the <em>induction
hypothesis</em>.</li>
</ol>
<p>Here <span class="math inline">x</span> is a unique variable
representing an arbitrary natural number. We cannot substitute a
particular number for it because we write “using <span
class="math inline">x</span>” on the side, indicating that the
derivation works for any choice of <span
class="math inline">x</span>.</p>
<p>The power of induction lies in this: once we have the base case and
the inductive step, we have implicitly covered <em>all</em> natural
numbers. Starting from <span class="math inline">p(0)</span>, we can
derive <span class="math inline">p(1)</span>, then <span
class="math inline">p(2)</span>, then <span
class="math inline">p(3)</span>, and so on, reaching any natural number
<span class="math inline">n</span> we wish.</p>
<h3 id="logos-was-programmed-in-ocaml">1.3 Logos was Programmed in
OCaml</h3>
<p>We now arrive at one of the most remarkable discoveries in the
foundations of computer science: the <strong>Curry–Howard
correspondence</strong>, also known as “propositions as types” or the
“proofs-as-programs” interpretation. In a pure, intuitionistic setting,
this correspondence is not just a metaphor: proof rules and typing rules
are the same kind of object.</p>
<p>Under this correspondence:</p>
<ul>
<li><strong>Propositions</strong> (logical statements) correspond to
<strong>types</strong></li>
<li><strong>Proofs</strong> (derivations showing a proposition is true)
correspond to <strong>programs</strong> (expressions of a given
type)</li>
<li><strong>Introduction rules</strong> correspond to
<strong>constructors</strong> (ways to build values)</li>
<li><strong>Elimination rules</strong> correspond to
<strong>destructors</strong> (ways to use values)</li>
</ul>
<p>When you write a well-typed program, you are (implicitly)
constructing a derivation tree that proves a typing judgement.</p>
<p>The following table shows how each logical connective corresponds to
a programming construct in OCaml:</p>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 16%" />
<col style="width: 33%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr>
<th>Logic</th>
<th>OCaml type (example)</th>
<th>Example program</th>
<th>Intuition</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\top</span></td>
<td><code>unit</code></td>
<td><code>()</code></td>
<td>The trivially true proposition; the type with exactly one value</td>
</tr>
<tr>
<td><span class="math inline">\bot</span></td>
<td><code>void</code> (an empty type)</td>
<td><code>match v with _ -&gt; .</code></td>
<td>Falsehood; a type with no values</td>
</tr>
<tr>
<td><span class="math inline">\wedge</span></td>
<td><code>*</code></td>
<td><code>(,)</code></td>
<td>Conjunction corresponds to pairs: having both A and B</td>
</tr>
<tr>
<td><span class="math inline">\vee</span></td>
<td>a variant type</td>
<td><code>Left x</code> / <code>Right y</code></td>
<td>Disjunction corresponds to sums: having either A or B</td>
</tr>
<tr>
<td><span class="math inline">\rightarrow</span></td>
<td><code>-&gt;</code></td>
<td><code>fun</code></td>
<td>Implication corresponds to functions: given A, produce B</td>
</tr>
<tr>
<td>induction</td>
<td>-</td>
<td><code>let rec</code></td>
<td>Inductive proofs correspond to recursive definitions</td>
</tr>
</tbody>
</table>
<p>For example, the identity function corresponds to the tautology <span
class="math inline">a \rightarrow a</span>:</p>
<p><code>ocaml env=ch1 # fun x -&gt; x;; - : 'a -&gt; 'a = &lt;fun&gt;</code></p>
<p>Let us now see the precise typing rules for each OCaml construct,
presented in the same style as our logical rules:</p>
<p><strong>Typing rules for OCaml constructs:</strong></p>
<ul>
<li><p><strong>Unit (truth):</strong> <span
class="math inline">\frac{}{\texttt{()} : \texttt{unit}}</span></p>
<p>The unit value <code>()</code> always has type <code>unit</code>.
This is like <span class="math inline">\top</span> in logic: we can
always produce it without any premises.</p></li>
<li><p><strong>Empty type (falsehood):</strong> in OCaml we can
<em>define</em> an empty type (a type with no constructors):</p>
<p><code>ocaml env=ch1 type void = |</code></p>
<p>There is no way to construct a value of type <code>void</code> using
ordinary, terminating code. But if we somehow have a
<code>v : void</code>, then we can derive anything from it (falsity
elimination):</p>
<p><code>ocaml env=ch1 let absurd (v : void) : 'a =   match v with _ -&gt; .</code></p>
<p>This corresponds closely to the logical rule <span
class="math inline">\frac{\bot}{a}</span>.</p>
<p>OCaml also has <em>effects</em> (notably exceptions). Because
<code>raise e</code> never returns normally, the type checker allows it
to have any result type: <span class="math display">
\frac{e : \texttt{exn}}{\texttt{raise } e : a}
</span> This is useful in practice, but it is also a good reminder that
effects complicate the neat “proofs-as-programs” story.</p></li>
<li><p><strong>Pair (conjunction):</strong></p>
<ul>
<li>Introduction: <span class="math inline">\frac{s : a \quad t : b}{(s,
t) : a * b}</span></li>
<li>Elimination: from <code>p : a * b</code> we can extract either
component (e.g. by pattern matching, or via
<code>fst</code>/<code>snd</code>)</li>
</ul>
<p>To construct a pair, you need both components. To use a pair, you can
extract either component. This mirrors conjunction perfectly: to prove
“A and B”, you need proofs of both; given “A and B”, you can conclude
either A or B.</p></li>
<li><p><strong>Variant (disjunction):</strong> first, we define a sum
type (a two-way choice):</p>
<p><code>ocaml env=ch1 type ('a, 'b) either = Left of 'a | Right of 'b</code></p>
<ul>
<li>Introduction: from <code>x : a</code> we get
<code>Left x : (a, b) either</code>, and from <code>y : b</code> we get
<code>Right y : (a, b) either</code></li>
<li>Elimination: given <code>t : (a, b) either</code> and a branch for
each case, produce a result <code>c</code> (pattern matching)</li>
</ul>
<p>The shape of the elimination rule is exactly “reasoning by cases”: to
use an <code>either</code>, you must handle both <code>Left</code> and
<code>Right</code>.</p>
<p><code>ocaml env=ch1 let either f g = function   | Left x -&gt; f x   | Right y -&gt; g y</code></p>
<p>A built-in example is <code>bool</code>, which you can think of as a
two-constructor variant; the <code>if ... then ... else ...</code>
expression is just a specialized form of case analysis on a boolean.</p>
<p>```ocaml env=ch1 let choose b x y = if b then x else y</p>
<p>let choose’ b x y = match b with | true -&gt; x | false -&gt; y
```</p>
<p>To construct a variant, you only need one of the alternatives. To use
a variant, you must handle <em>all</em> possible cases (pattern
matching). This mirrors disjunction: to prove “A or B”, you only need
one; to use “A or B”, you must consider both possibilities.</p></li>
<li><p><strong>Function (implication):</strong></p>
<ul>
<li>Introduction: <span class="math inline">\frac{\genfrac{}{}{0pt}{}{[x
: a]}{\vdots \; e : b}}{\texttt{fun}~x \to e : a \to b}</span></li>
<li>Elimination (application): <span class="math inline">\frac{f : a \to
b \quad t : a}{f~t : b}</span></li>
</ul>
<p>To construct a function, you assume you have an input of type <span
class="math inline">a</span> (the parameter <span
class="math inline">x</span>) and show how to produce a result of type
<span class="math inline">b</span>. To use a function, you apply it to
an argument. This mirrors implication: to prove “A implies B”, assume A
and derive B; given “A implies B” and A, conclude B.</p></li>
<li><p><strong>Recursion (induction):</strong> recursion is not a
connective, but it matches the <em>shape</em> of induction: in a
recursive definition you are allowed to assume the function being
defined (the “induction hypothesis”) when defining its body.</p>
<p>In OCaml, recursion is introduced with <code>let rec</code> (there is
no standalone <code>rec</code> expression).</p></li>
</ul>
<h4 id="definitions">Definitions</h4>
<p>Writing out expressions and types repetitively quickly becomes
tedious. More importantly, without definitions we cannot give names to
our concepts, making code harder to understand and maintain. This is why
we need definitions.</p>
<p><strong>Type definitions</strong> are written: <code>type ty =</code>
some type.</p>
<ul>
<li><p>In OCaml, disjunction-like types are not written as something
like <code>a | b</code> directly; instead, you define a <em>variant
type</em> and then use its constructors. For example:
<code>ocaml env=ch1 type int_string_choice = A of int | B of string</code>
This allows us to write <code>A x : int_string_choice</code> for any
<code>x : int</code>, and <code>B y : int_string_choice</code> for any
<code>y : string</code>.</p></li>
<li><p>Why do we need to define variant types? The reasons are:
exhaustiveness checks, performance of generated code, and ease of type
inference. When OCaml sees <code>A 5</code>, it needs to figure out (or
“infer”) the type. Without a type definition, how would OCaml know
whether this is <code>A of int | B of string</code> or
<code>A of int | B of float | C of bool</code>? The definition tells
OCaml exactly what variants exist. When you match
<code>| A i -&gt; ...</code>, the compiler will warn you if you forgot
to also cover <code>C b</code> in your match patterns.</p></li>
<li><p>OCaml does provide an alternative: <em>polymorphic variants</em>,
written with a backtick. We can write
<code>`A x : [ `A of a | `B of b ]</code>. With <code>`</code> variants,
OCaml does infer what other variants might exist based on usage. These
types are powerful and flexible; we will discuss them in chapter
11.</p></li>
<li><p>Tuple elements do not need labels because we always know at which
position a tuple element stands: the first element is first, the second
is second, and so on. However, having labels makes code much clearer,
especially when tuples have many components or components of the same
type. For this reason, we can define a <em>record type</em>:</p>
<p><code>ocaml env=ch1 type int_string_record = { a : int; b : string }</code></p>
<p>and create its values: <code>{a = 7; b = "Mary"}</code>. OCaml 5.4
and newer also support labeled tuples, we will not discuss
these.</p></li>
<li><p>We access the <em>fields</em> of records using the dot notation:
<code>{a = 7; b = "Mary"}.b = "Mary"</code>. Unlike tuples where you
must remember “the second element is the name”, with records you can
write <code>.b</code> to get the field named <code>b</code>.</p></li>
</ul>
<h4 id="expression-definitions">Expression Definitions</h4>
<p>In many presentations of the Curry–Howard correspondence (and in
programming language theory), recursion is introduced via a standalone
operator often called <code>fix</code>. OCaml does not have a standalone
<code>fix</code> expression: recursion is introduced only as part of a
<code>let rec</code> definition.</p>
<p>This brings us to <strong>expression definitions</strong>, which let
us give names to values. The typing rules for definitions are a bit more
complex than what we have seen so far:</p>
<p><span class="math display">
\frac{e_1 : a \quad \genfrac{}{}{0pt}{}{[x : a]}{\vdots \; e_2 :
b}}{\texttt{let } x = e_1 \texttt{ in } e_2 : b}
</span></p>
<p>This rule says: if <span class="math inline">e_1</span> has type
<span class="math inline">a</span>, and assuming <span
class="math inline">x</span> has type <span class="math inline">a</span>
we can show that <span class="math inline">e_2</span> has type <span
class="math inline">b</span>, then the whole <code>let</code> expression
has type <span class="math inline">b</span>. Interestingly, this rule is
equivalent to introducing a function and immediately applying it:
<code>let x = e1 in e2</code> behaves the same as
<code>(fun x -&gt; e2) e1</code>. This equivalence reflects a deep
connection in the Curry–Howard correspondence.</p>
<p>For recursive definitions, we need an additional rule:</p>
<p><span class="math display">
\frac{\genfrac{}{}{0pt}{}{[x : a]}{\vdots \; e_1 : a} \quad
\genfrac{}{}{0pt}{}{[x : a]}{\vdots \; e_2 : b}}{\texttt{let rec } x =
e_1 \texttt{ in } e_2 : b}
</span></p>
<p>Notice the crucial difference: in the recursive case, <span
class="math inline">x</span> can appear in <span
class="math inline">e_1</span> itself! This is what allows functions to
call themselves. The name <span class="math inline">x</span> is visible
both in its own definition (<span class="math inline">e_1</span>) and in
the body that uses the definition (<span
class="math inline">e_2</span>).</p>
<p>These rules are slightly simplified. The full rules involve a concept
called <strong>polymorphism</strong>, which we will cover in a later
chapter. Polymorphism explains how the same function can work with
different types.</p>
<h4 id="scoping-rules">Scoping Rules</h4>
<p>Understanding <em>scope</em>—where names are visible—is essential for
reading and writing OCaml programs.</p>
<ul>
<li><p><strong>Type definitions</strong> we have seen above are
<em>global</em>: they need to be at the top-level (not nested in
expressions), and they extend from the point they occur till the end of
the source file or interactive session. You cannot define a type inside
a function.</p></li>
<li><p><strong><code>let</code>-<code>in</code> definitions</strong> for
expressions: <code>let x = e1 in e2</code> are <em>local</em>—the name
<span class="math inline">x</span> is only visible within <span
class="math inline">e_2</span>. Once you exit the <code>in</code> part,
<span class="math inline">x</span> no longer exists. This is useful for
temporary values that should not pollute the global namespace.</p></li>
<li><p><strong><code>let</code> definitions</strong> without
<code>in</code> are global: placing <code>let x = e1</code> at the
top-level makes <span class="math inline">x</span> visible from after
<span class="math inline">e_1</span> till the end of the source file or
interactive session. This is how you define functions and values that
the rest of your program can use.</p></li>
<li><p>In the interactive session (toplevel/REPL), we mark the end of a
top-level “sentence” with <code>;;</code>. This tells OCaml “I am done
typing, please evaluate this.” In source files compiled by the build
system, <code>;;</code> is unnecessary because the end of each
definition is clear from context.</p></li>
</ul>
<h4 id="operators">Operators</h4>
<p>Operators like <code>+</code>, <code>*</code>, <code>&lt;</code>,
<code>=</code> are simply names of functions. In OCaml, there is nothing
magical about operators; they are ordinary functions that happen to have
special characters in their names and can be used in infix position
(between their arguments).</p>
<p>Just like other names, you can define your own operators:</p>
<p><code>ocaml env=ch1 # let (+:) a b = String.concat "" [a; b];; val ( +: ) : string -&gt; string -&gt; string = &lt;fun&gt; # "Alpha" +: "Beta";; - : string = "AlphaBeta"</code></p>
<p>Notice the asymmetry here: when <em>defining</em> an operator, we
wrap it in parentheses to tell OCaml “this is the name I am defining”.
When <em>using</em> the operator, we write it in the normal infix
position between its arguments. This asymmetry exists because the
definition syntax needs to distinguish between “the name
<code>+:</code>” and “the expression <code>a +: b</code>”.</p>
<p>An important feature of OCaml is that operators are <strong>not
overloaded</strong>. This means that a single operator cannot work for
multiple types. Each type needs its own set of operators: -
<code>+</code>, <code>*</code>, <code>/</code> work for integers -
<code>+.</code>, <code>*.</code>, <code>/.</code> work for floating
point numbers</p>
<p>This design choice makes type inference simpler and more predictable.
When you see <code>x + y</code>, OCaml knows immediately that
<code>x</code> and <code>y</code> must be integers.</p>
<p><strong>Exception:</strong> The comparison operators
<code>&lt;</code>, <code>=</code>, <code>&lt;=</code>,
<code>&gt;=</code>, <code>&lt;&gt;</code> do work for all values other
than functions. These are called <em>polymorphic comparisons</em>.</p>
<h3 id="exercises">1.4 Exercises</h3>
<p>The following exercises are adapted from <em>Think OCaml: How to
Think Like a Computer Scientist</em> by Nicholas Monje and Allen Downey.
They will help you get comfortable with OCaml’s syntax and type
system.</p>
<ol type="1">
<li><p>Assume that we execute the following assignment statements:
<code>ocaml env=ch1 let width = 17 let height = 12.0 let delimiter = '.'</code>
For each of the following expressions, write the value of the expression
and the type (of the value of the expression), or the resulting type
error.</p>
<ol type="1">
<li><code>width/2</code></li>
<li><code>width/.2.0</code></li>
<li><code>height/3</code></li>
<li><code>1 + 2 * 5</code></li>
<li><code>delimiter * 5</code></li>
</ol></li>
<li><p>Practice using the OCaml interpreter as a calculator:</p>
<ol type="1">
<li>The volume of a sphere with radius <span
class="math inline">r</span> is <span class="math inline">\frac{4}{3}
\pi r^3</span>. What is the volume of a sphere with radius 5?
(<em>Hint:</em> 392.6 is wrong!)</li>
<li>Suppose the cover price of a book is $24.95, but bookstores get a
40% discount. Shipping costs $3 for the first copy and 75 cents for each
additional copy. What is the total wholesale cost for 60 copies?</li>
<li>If I leave my house at 6:52 am and run 1 mile at an easy pace (8:15
per mile), then 3 miles at tempo (7:12 per mile) and 1 mile at easy pace
again, what time do I get home for breakfast?</li>
</ol></li>
<li><p>You’ve probably heard of the Fibonacci numbers before, but in
case you haven’t, they’re defined by the following recursive
relationship: <span class="math display">
\begin{cases}
f(0) = 0 \\
f(1) = 1 \\
f(n+1) = f(n) + f(n-1) &amp; \text{for } n = 2, 3, \ldots
\end{cases}
</span> Write a recursive function to calculate these numbers.</p></li>
<li><p>A palindrome is a word that is spelled the same backward and
forward, like “noon” and “redivider”. Recursively, a word is a
palindrome if the first and last letters are the same and the middle is
a palindrome.</p>
<p>The following are functions that take a string argument and return
the first, last, and middle letters:
<code>ocaml env=ch1 let first_char word = word.[0] let last_char word =   let len = String.length word - 1 in   word.[len] let middle word =   let len = String.length word - 2 in   String.sub word 1 len</code></p>
<ol type="1">
<li>Enter these functions into the toplevel and test them out. What
happens if you call <code>middle</code> with a string with two letters?
One letter? What about the empty string <code>""</code>?</li>
<li>Write a function called <code>is_palindrome</code> that takes a
string argument and returns <code>true</code> if it is a palindrome and
<code>false</code> otherwise.</li>
</ol></li>
<li><p>The greatest common divisor (GCD) of <span
class="math inline">a</span> and <span class="math inline">b</span> is
the largest number that divides both of them with no remainder.</p>
<p>One way to find the GCD of two numbers is Euclid’s algorithm, which
is based on the observation that if <span class="math inline">r</span>
is the remainder when <span class="math inline">a</span> is divided by
<span class="math inline">b</span>, then <span
class="math inline">\gcd(a, b) = \gcd(b, r)</span>. As a base case, we
can consider <span class="math inline">\gcd(a, 0) = a</span>.</p>
<p>Write a function called <code>gcd</code> that takes parameters
<code>a</code> and <code>b</code> and returns their greatest common
divisor.</p>
<p>If you need help, see <a
href="http://en.wikipedia.org/wiki/Euclidean_algorithm">http://en.wikipedia.org/wiki/Euclidean_algorithm</a>.</p></li>
</ol>
<h2 id="chapter-2-algebra">Chapter 2: Algebra</h2>
<p><em>Algebraic data types and some curious analogies</em></p>
<p>In this chapter, we will deepen our understanding of OCaml’s type
system by working through type inference examples by hand. Then we will
explore algebraic data types—a cornerstone of functional programming
that allows us to define rich, structured data. Along the way, we will
discover a surprising and beautiful connection between these types and
ordinary polynomials from high-school algebra.</p>
<p><strong>In this chapter, you will:</strong></p>
<ul>
<li>Practice type inference by hand (constraints, unification
intuition)</li>
<li>Define and manipulate algebraic data types (variants, records,
recursion, parameters)</li>
<li>Interpret types as polynomials (and learn what this analogy buys
you)</li>
<li>Differentiate types to compute “one-hole contexts” (derivatives of
data structures)</li>
</ul>
<h3 id="a-glimpse-at-type-inference">2.1 A Glimpse at Type
Inference</h3>
<p>For a refresher, let us apply the type inference rules introduced in
Chapter 1 to some simple examples. We will start with the identity
function <code>fun x -&gt; x</code>—perhaps the simplest possible
function, yet one that reveals important aspects of polymorphism. In the
derivations below, <span class="math inline">[?]</span> means “unknown
(to be inferred)”.</p>
<p>We begin with an incomplete derivation:</p>
<p><span class="math display">
\frac{[?]}{\texttt{fun x -&gt; x} : [?]}
</span></p>
<p>Using the <span class="math inline">\rightarrow</span> introduction
rule, we need to derive the body <code>x</code> assuming <code>x</code>
has some type <span class="math inline">a</span>:</p>
<p><span class="math display">
\frac{\genfrac{}{}{0pt}{}{[x : a]^x}{\vdots \; \texttt{x} :
a}}{\texttt{fun x -&gt; x} : [?] \rightarrow [?]}
</span></p>
<p>The premise is a hypothetical derivation: inside the body we are
allowed to use the assumption <code>x : a</code>. Since the body is just
<code>x</code>, the result type is also <span
class="math inline">a</span>, and we conclude:</p>
<p><span class="math display">
\frac{\genfrac{}{}{0pt}{}{[x : a]^x}{\vdots \; \texttt{x} :
a}}{\texttt{fun x -&gt; x} : a \rightarrow a}
</span></p>
<p>Because <span class="math inline">a</span> is arbitrary (we made no
assumptions constraining it), OCaml introduces a <em>type variable</em>
<code>'a</code> to represent it. This is how polymorphism emerges
naturally from the inference process—the identity function can work with
values of any type:</p>
<p><code>ocaml env=ch2 # fun x -&gt; x;; - : 'a -&gt; 'a = &lt;fun&gt;</code></p>
<h4 id="a-more-complex-example">A More Complex Example</h4>
<p>Now let us try something that will constrain the types more:
<code>fun x -&gt; x+1</code>. This is the same as
<code>fun x -&gt; ((+) x) 1</code> (try it in OCaml to verify!). The
addition operator forces specific types upon us.</p>
<p>We will use the notation <span class="math inline">[?\alpha]</span>
to mean “type unknown yet, but the same as in other places marked <span
class="math inline">[?\alpha]</span>.” This notation helps us track how
constraints propagate through the derivation.</p>
<p>Starting the derivation and applying <span
class="math inline">\rightarrow</span> introduction:</p>
<p><span class="math display">
\frac{\frac{[?]}{\texttt{((+) x) 1} : [?\alpha]}}{\texttt{fun x -&gt;
((+) x) 1} : [?] \rightarrow [?\alpha]}
</span></p>
<p>Applying <span class="math inline">\rightarrow</span> elimination
(function application) to <code>((+) x) 1</code>:</p>
<p><span class="math display">
\frac{\frac{\frac{[?]}{\texttt{(+) x} : [?\beta] \rightarrow [?\alpha]}
\quad \frac{[?]}{\texttt{1} : [?\beta]}}{\texttt{((+) x) 1} :
[?\alpha]}}{\texttt{fun x -&gt; ((+) x) 1} : [?] \rightarrow [?\alpha]}
</span></p>
<p>We know that <code>1 : int</code>, so <span
class="math inline">[?\beta] = \texttt{int}</span>:</p>
<p><span class="math display">
\frac{\frac{\frac{[?]}{\texttt{(+) x} : \texttt{int} \rightarrow
[?\alpha]} \quad \frac{\,}{\texttt{1} :
\texttt{int}}^{\text{(constant)}}}{\texttt{((+) x) 1} :
[?\alpha]}}{\texttt{fun x -&gt; ((+) x) 1} : [?] \rightarrow [?\alpha]}
</span></p>
<p>Applying function application again to <code>(+) x</code>:</p>
<p><span class="math display">
\frac{\frac{\frac{\frac{[?]}{\texttt{(+)} : [?\gamma] \rightarrow
\texttt{int} \rightarrow [?\alpha]} \quad \frac{[?]}{\texttt{x} :
[?\gamma]}}{\texttt{(+) x} : \texttt{int} \rightarrow [?\alpha]} \quad
\frac{\,}{\texttt{1} : \texttt{int}}^{\text{(constant)}}}{\texttt{((+)
x) 1} : [?\alpha]}}{\texttt{fun x -&gt; ((+) x) 1} : [?\gamma]
\rightarrow [?\alpha]}
</span></p>
<p>Since <code>(+) : int -&gt; int -&gt; int</code>, we have <span
class="math inline">[?\gamma] = \texttt{int}</span> and <span
class="math inline">[?\alpha] = \texttt{int}</span>:</p>
<p><span class="math display">
\frac{\frac{\frac{\frac{\,}{\texttt{(+)} : \texttt{int} \rightarrow
\texttt{int} \rightarrow \texttt{int}}^{\text{(constant)}} \quad
\frac{\,}{\texttt{x} : \texttt{int}}^x}{\texttt{(+) x} : \texttt{int}
\rightarrow \texttt{int}} \quad \frac{\,}{\texttt{1} :
\texttt{int}}^{\text{(constant)}}}{\texttt{((+) x) 1} :
\texttt{int}}}{\texttt{fun x -&gt; ((+) x) 1} : \texttt{int} \rightarrow
\texttt{int}}
</span></p>
<h4 id="curried-form">Curried Form</h4>
<p>When there are several arrows “on the same depth” in a function type,
it means that the function returns a function. For example,
<code>(+) : int -&gt; int -&gt; int</code> is just a shorthand for
<code>(+) : int -&gt; (int -&gt; int)</code>. The arrow associates to
the right, so we can omit the parentheses.</p>
<p>This is very different from:</p>
<p><span class="math display">
\texttt{fun f -&gt; (f 1) + 1} : (\texttt{int} \rightarrow \texttt{int})
\rightarrow \texttt{int}
</span></p>
<p>In the first case, <code>(+)</code> is a function that takes an
integer and returns a function from integers to integers. In the second
case, we have a function that takes a function as an argument—a
<em>higher-order function</em>. The parentheses around
<code>int -&gt; int</code> are essential here; without them, the meaning
would be completely different.</p>
<p>This style of defining multi-argument functions, where each function
takes one argument and returns another function expecting the remaining
arguments, is called <em>curried form</em> (named after logician Haskell
Curry). It enables a powerful technique called <em>partial
application</em>.</p>
<p>For example, instead of writing <code>(fun x -&gt; x+1)</code>, we
can simply write <code>((+) 1)</code>. Here we apply <code>(+)</code> to
just one argument, getting back a function that adds 1 to its input.
What expanded form does <code>((+) 1)</code> correspond to exactly
(computationally)?</p>
<p><em>Think about it before reading on…</em></p>
<p>It corresponds to <code>fun y -&gt; 1 + y</code>. We have “baked in”
the first argument, and the resulting function waits for the second.</p>
<p>We will become more familiar with functions returning functions when
we study the <em>lambda calculus</em> in a later chapter.</p>
<h3 id="algebraic-data-types">2.2 Algebraic Data Types</h3>
<p>In Chapter 1, we learned about the <code>unit</code> type and variant
types like:</p>
<p><code>ocaml env=ch2 type int_string_choice = A of int | B of string</code></p>
<p>We also covered tuple types, record types, and type definitions. Now
let us explore these concepts more deeply, building up to the powerful
notion of <em>algebraic data types</em>.</p>
<h4 id="variants-without-arguments">Variants Without Arguments</h4>
<p>Variants do not have to carry arguments. Instead of writing
<code>A of unit</code>, we can simply use <code>A</code>. This is more
convenient and idiomatic:</p>
<p><code>ocaml env=ch2 type color = Red | Green | Blue</code></p>
<p>This defines a type with exactly three possible values—no more, no
less. The compiler knows this, which enables exhaustive pattern matching
checks.</p>
<p><strong>A subtle point about OCaml:</strong> In OCaml, variants take
multiple arguments rather than taking tuples as arguments. This means
<code>A of int * string</code> is different from
<code>A of (int * string)</code>. The first takes two separate
arguments, while the second takes a single tuple argument. This
distinction is usually not important—until you get bitten by it in some
corner case! For most purposes, you can ignore it.</p>
<h4 id="recursive-type-definitions">Recursive Type Definitions</h4>
<p>Here is where things get really interesting: type definitions can be
recursive! This allows us to define data structures of arbitrary size
using a finite definition:</p>
<p><code>ocaml env=ch2 type int_list = Empty | Cons of int * int_list</code></p>
<p>Let us see what values inhabit <code>int_list</code>. The definition
tells us there are two ways to build an <code>int_list</code>: -
<code>Empty</code> represents the empty list—a list with no elements -
<code>Cons (5, Empty)</code> is a list containing just 5 -
<code>Cons (5, Cons (7, Cons (13, Empty)))</code> is a list containing
5, 7, and 13</p>
<p>Notice how <code>Cons</code> takes an integer and another
<code>int_list</code>, allowing us to chain together as many elements as
we like. This recursive structure is the essence of how functional
languages represent unbounded data.</p>
<p>The built-in type <code>bool</code> really does behave like a
two-constructor variant with values <code>true</code> and
<code>false</code>—but note a small OCaml wrinkle: user-defined
constructors must start with a capital letter, while a few built-in
constructors like <code>true</code>, <code>false</code>,
<code>[]</code>, and <code>(::)</code> are special-cased.</p>
<p>Similarly, <code>int</code> can be <em>thought of</em> as a very
large finite variant (“one constructor per integer”), even though the
compiler implements it as an efficient machine integer rather than as a
gigantic sum type.</p>
<h4 id="parametric-type-definitions">Parametric Type Definitions</h4>
<p>Our <code>int_list</code> type only works with integers. But what if
we want a list of strings? Or a list of booleans? We would have to
define separate types for each, duplicating the same structure.</p>
<p>Type definitions can be <em>parametric</em> with respect to the types
of their components. This allows us to define generic data structures
that work with any element type. OCaml already has a built-in parametric
list type, so to avoid shadowing it we will define our own simplified
list type:</p>
<p><code>ocaml env=ch2 type 'a my_list = Empty | Cons of 'a * 'a my_list</code></p>
<p>The <code>'a</code> is a <em>type parameter</em>—a placeholder that
gets filled in when we use the type. We can have a
<code>string my_list</code>, an <code>int my_list</code>, or even an
<code>(int my_list) my_list</code> (a list of lists of integers).</p>
<p>Several conventions and syntax rules apply to parametric types:</p>
<ul>
<li><p>Type variables must start with <code>'</code>. When printing
inferred types, OCaml may rename these variables, so it is customary to
stick to the standard names <code>'a</code>, <code>'b</code>,
<code>'c</code>, <code>'d</code>, etc.</p></li>
<li><p>The OCaml syntax places the type parameter before the type name,
mimicking English word order. A silly example that reads almost like
English:
<code>ocaml env=ch2 type 'white_color dog = Dog of 'white_color</code></p>
<p>This defines a “white-color dog” type—the syntax reads
naturally!</p></li>
<li><p>With multiple parameters, OCaml uses parentheses:
<code>ocaml env=ch2 type ('a, 'b) choice = Left of 'a | Right of 'b</code></p>
<p>Compare this to F# syntax:
<code>type choice&lt;'a,'b&gt; = Left of 'a | Right of 'b</code></p>
<p>And Haskell syntax:
<code>data Choice a b = Left a | Right b</code></p>
<p>Different languages have different conventions, but the underlying
concept is the same.</p></li>
</ul>
<h3 id="syntactic-bread-and-sugar">2.3 Syntactic Bread and Sugar</h3>
<p>OCaml provides various syntactic conveniences—sometimes called
<em>syntactic sugar</em>—that make code more pleasant to write and read.
Let us survey the most important ones.</p>
<h4 id="constructor-naming">Constructor Naming</h4>
<p>Names of variants, called <em>constructors</em>, must start with a
capital letter. If we wanted to define our own booleans, we would
write:</p>
<p><code>ocaml env=ch2 type my_bool = True | False</code></p>
<p>Only constructors and module names can start with capital letters in
OCaml. Everything else (values, functions, type names) must start with a
lowercase letter. This convention makes it easy to distinguish
constructors at a glance.</p>
<p>(As noted above, a few built-in constructors like <code>true</code>,
<code>false</code>, <code>[]</code>, and <code>(::)</code> are special
exceptions to the capitalization rule.)</p>
<p><em>Modules</em> are organizational units (like “shelves”) containing
related values. For example, the <code>List</code> module provides
operations on lists, including <code>List.map</code> and
<code>List.filter</code>. We will learn more about modules in later
chapters.</p>
<h4 id="accessing-record-fields">Accessing Record Fields</h4>
<p>Did we mention that we can use dot notation to access record fields?
The syntax <code>record.field</code> extracts a field value. For
example, if we have <code>let person = {name="Alice"; age=30}</code>, we
can write <code>person.name</code> to get <code>"Alice"</code>.</p>
<h4 id="function-definition-shortcuts">Function Definition
Shortcuts</h4>
<p>Several syntactic shortcuts make function definitions more concise.
These are worth memorizing, as you will see them constantly in OCaml
code:</p>
<ul>
<li><p><code>fun x y -&gt; e</code> stands for
<code>fun x -&gt; fun y -&gt; e</code>. Note that
<code>fun x -&gt; fun y -&gt; e</code> parses as
<code>fun x -&gt; (fun y -&gt; e)</code>. This shorthand aligns with
curried form—we can write multi-argument functions without nesting
<code>fun</code> expressions.</p></li>
<li><p><code>function A x -&gt; e1 | B y -&gt; e2</code> stands for
<code>fun p -&gt; match p with A x -&gt; e1 | B y -&gt; e2</code>. The
general form is: <code>function PATTERN-MATCHING</code> stands for
<code>fun v -&gt; match v with PATTERN-MATCHING</code>. This is handy
when you want to immediately pattern-match on a function’s
argument.</p></li>
<li><p><code>let f ARGS = e</code> is a shorthand for
<code>let f = fun ARGS -&gt; e</code>. This is probably the most common
way to define functions in practice.</p></li>
</ul>
<h3 id="pattern-matching">2.4 Pattern Matching</h3>
<p>Pattern matching is one of the most powerful features of OCaml and
similar languages. It lets us examine the structure of data and extract
components in a single, elegant construct.</p>
<p>Recall that we introduced <code>fst</code> and <code>snd</code> as
means to access elements of a pair. But what about larger tuples? There
is no built-in <code>thd</code> for the third element. The fundamental
way to access any tuple—or any algebraic data type—uses the
<code>match</code> construct. In fact, <code>fst</code> and
<code>snd</code> can easily be defined using pattern matching:</p>
<p><code>ocaml env=ch2 let fst p = match p with (a, b) -&gt; a let snd p = match p with (a, b) -&gt; b</code></p>
<p>The pattern <code>(a, b)</code> <em>destructures</em> the pair,
binding its first component to <code>a</code> and its second to
<code>b</code>. We then return whichever component we want.</p>
<h4 id="matching-on-records">Matching on Records</h4>
<p>Pattern matching also works with records, letting us extract multiple
fields at once:</p>
<p>```ocaml env=ch2 type person = { name : string; surname : string; age
: int }</p>
<p>let greet_person () = match { name = “Walker”; surname = “Johnnie”;
age = 207 } with | { name = <em>; surname = sn; age = </em> } -&gt; “Hi”
^ sn ^ “!”</p>
<pre><code>
Here we match against a record pattern, binding each field to a variable. Note that we bind `name` to `n`, `surname` to `sn`, and `age` to `a`---then use `sn` in the greeting.

#### Understanding Patterns

The left-hand sides of `-&gt;` in `match` expressions are called **patterns**. Patterns describe the structure of values we want to match against. They can include:
- Constants (like `1`, `&quot;hello&quot;`, or `true`)
- Variables (which bind to the matched value)
- Constructors (like `None`, `Some x`, or `Cons (h, t)`)
- Tuples and records
- Nested combinations of all the above

Patterns can be nested to arbitrary depth, allowing us to match complex structures in one go:

```ocaml env=ch2
match Some (5, 7) with
| None -&gt; &quot;sum: nothing&quot;
| Some (x, y) -&gt; &quot;sum: &quot; ^ string_of_int (x + y)</code></pre>
<p>Here <code>Some (x, y)</code> is a nested pattern: we match
<code>Some</code> of <em>something</em>, and that something must be a
pair, whose components we bind to <code>x</code> and <code>y</code>.</p>
<h4 id="simple-patterns-and-wildcards">Simple Patterns and
Wildcards</h4>
<p>A pattern can simply bind the entire value without destructuring.
Writing <code>match f x with v -&gt; ...</code> is the same as
<code>let v = f x in ...</code>. This is occasionally useful when you
want the syntax of <code>match</code> but do not need to take the value
apart.</p>
<p>When we do not need a value in a pattern, it is good practice to use
the underscore <code>_</code>, which is a <em>wildcard</em>. The
wildcard matches anything but does not bind it to a name. This signals
to the reader (and the compiler) that we are intentionally ignoring that
part:</p>
<p><code>ocaml env=ch2 let fst (a, _) = a let snd (_, b) = b</code></p>
<p>Using <code>_</code> instead of an unused variable name avoids
compiler warnings about unused bindings.</p>
<h4 id="pattern-linearity">Pattern Linearity</h4>
<p>A variable can only appear once in a pattern. This property is called
<em>linearity</em>. You might think this is a limitation—what if we want
to check that two parts of a structure are equal? We cannot write
<code>(x, x)</code> to match pairs with equal components.</p>
<p>However, we can add conditions to patterns using <code>when</code>,
so linearity is not really a limitation in practice:</p>
<p><code>ocaml env=ch2 let describe_point p =   match p with   | (x, y) when x = y -&gt; "diag"   | _ -&gt; "off-diag"</code></p>
<p>The <code>when</code> clause acts as a guard: the pattern matches
only if both the structure matches <em>and</em> the condition is
true.</p>
<p>Here is a more elaborate example showing how to implement a
comparison function (without shadowing the standard
<code>compare</code>):</p>
<p><code>ocaml env=ch2 let compare_int a b =   match a, b with   | (x, y) when x &lt; y -&gt; -1   | (x, y) when x = y -&gt; 0   | _ -&gt; 1</code></p>
<p>Notice how we match against the tuple <code>(a, b)</code> in
different ways, using guards to distinguish the cases.</p>
<h4 id="partial-record-patterns">Partial Record Patterns</h4>
<p>We can skip unused fields of a record in a pattern. Only the fields
we care about need to be mentioned. This keeps patterns concise and
means we do not have to update every pattern when we add a new field to
a record type.</p>
<h4 id="or-patterns">Or-Patterns</h4>
<p>We can compress patterns by using <code>|</code> inside a single
pattern to match multiple alternatives. This is different from having
multiple pattern clauses—it lets us share a single right-hand side for
several patterns:</p>
<p>```ocaml env=ch2 type month = | Jan | Feb | Mar | Apr | May | Jun |
Jul | Aug | Sep | Oct | Nov | Dec</p>
<p>type weekday = Mon | Tue | Wed | Thu | Fri | Sat | Sun</p>
<p>type calendar_date = { year : int; month : month; day : int; weekday
: weekday }</p>
<p>let day = { year = 2012; month = Feb; day = 14; weekday = Wed }</p>
<p>let day_kind = match day with | { weekday = Sat | Sun; _ } -&gt;
“Weekend!” | _ -&gt; “Work day”</p>
<pre><code>
The pattern `Sat | Sun` matches either `Sat` or `Sun`. This is much cleaner than writing two separate clauses with the same right-hand side.

#### Named Patterns with `as`

Sometimes we want to both destructure a value *and* keep a reference to the whole thing (or some intermediate part). We use `(pattern as v)` to name a nested pattern, binding the matched value to `v`:
</code></pre>
<p>match day with | {weekday = (Mon | Tue | Wed | Thu | Fri as wday);
<em>} when not (day.month = Dec &amp;&amp; day.day = 24) -&gt; Some
(work (get_plan wday)) | </em> -&gt; None</p>
<pre><code>
This example demonstrates several features working together:

- An or-pattern matches any weekday from Monday to Friday
- The `as wday` clause binds the matched weekday to the variable `wday`
- A `when` guard checks that it is not Christmas Eve
- The bound variable `wday` is then used in the expression `get_plan wday`

This combination of features makes OCaml&#39;s pattern matching remarkably expressive.

### 2.5 Interpreting Algebraic Data Types as Polynomials

Now we come to one of the most delightful aspects of algebraic data types: they really are *algebraic* in a precise mathematical sense. Let us explore a curious analogy between types and polynomials that turns out to be surprisingly deep.

The translation from types to mathematical expressions works as follows:

- Replace `|` (variant choice) with $+$ (addition)
- Replace `*` (tuple product) with $\times$ (multiplication)
- Treat record types as tuple types (erasing field names and translating `;` as $\times$)

We also need translations for some special types:

- The **void type** (a type with no constructors, hence no values):
  ```ocaml env=ch2
  type void = |</code></pre>
<p>Since no values can be constructed, it represents emptiness—translate
it as <span class="math inline">0</span>.</p>
<ul>
<li><p>The <strong>unit type</strong> has exactly one value, so
translate it as <span class="math inline">1</span>. Since variants
without arguments behave like variants <code>of unit</code>, translate
them as <span class="math inline">1</span> as well.</p></li>
<li><p>The <strong>bool type</strong> has exactly two values
(<code>true</code> and <code>false</code>), so translate it as <span
class="math inline">2</span>.</p></li>
<li><p>Types like <code>int</code>, <code>string</code>,
<code>float</code>, and type parameters are treated as variables. We do
not care about their exact number of values; we just give them symbolic
names like <span class="math inline">x</span>, <span
class="math inline">y</span>, etc.</p></li>
<li><p>Defined types translate according to their definitions
(substituting variables as necessary).</p></li>
</ul>
<p>Give a name to the type being defined (representing a function of the
introduced variables). Now interpret the result as an ordinary numeric
polynomial! (Or a “rational function” if recursively defined.)</p>
<p>This might seem like a mere curiosity, but it leads to real insights.
Let us have some fun with it!</p>
<h4 id="example-date-type">Example: Date Type</h4>
<p><code>ocaml env=ch2 type ymd = { year : int; month : int; day : int }</code></p>
<p>A simple “year-month-day” record is a product of three
<code>int</code> fields. Translating to a polynomial (using <span
class="math inline">x</span> for <code>int</code>):</p>
<p><span class="math display">D = x \times x \times x = x^3</span></p>
<p>The cube makes sense: this record is essentially a triple of
integers.</p>
<h4 id="example-option-type">Example: Option Type</h4>
<p>The built-in option type is defined as:</p>
<pre><code>type &#39;a option = None | Some of &#39;a</code></pre>
<p>Translating (using <span class="math inline">x</span> for the type
parameter <code>'a</code>):</p>
<p><span class="math display">O = 1 + x</span></p>
<p>This reads as: an option is either nothing (1) or something of type
<span class="math inline">x</span>. The polynomial <span
class="math inline">1 + x</span> is beautifully simple!</p>
<h4 id="example-list-type">Example: List Type</h4>
<p><code>ocaml skip type 'a my_list = Empty | Cons of 'a * 'a my_list</code></p>
<p>Translating (where <span class="math inline">L</span> represents the
list type itself, and <span class="math inline">x</span> represents the
element type):</p>
<p><span class="math display">L = 1 + x \cdot L</span></p>
<p>This is a recursive equation! A list is either empty (<span
class="math inline">1</span>) or an element times another list (<span
class="math inline">x \cdot L</span>). If you solve this equation
algebraically, you get <span class="math inline">L = \frac{1}{1-x} = 1 +
x + x^2 + x^3 + \ldots</span>, which corresponds to: a list is either
empty, or has one element, or has two elements, etc.</p>
<h4 id="example-binary-tree-type">Example: Binary Tree Type</h4>
<p><code>ocaml env=ch2 type btree = Tip | Node of int * btree * btree</code></p>
<p>Translating:</p>
<p><span class="math display">T = 1 + x \cdot T \cdot T = 1 + x \cdot
T^2</span></p>
<p>A binary tree is either a tip (<span class="math inline">1</span>) or
a node containing a value and two subtrees (<span class="math inline">x
\cdot T^2</span>).</p>
<h4 id="type-isomorphisms">Type Isomorphisms</h4>
<p>Here is the remarkable payoff: when translations of two types are
equal according to the laws of high-school algebra, the types are
<em>isomorphic</em>. This means there exist bijective (one-to-one and
onto) functions between them—you can convert from one type to the other
and back without losing any information.</p>
<p>Let us play with the binary tree polynomial and see where algebra
takes us:</p>
<p><span class="math display">
\begin{aligned}
T &amp;= 1 + x \cdot T^2 \\
  &amp;= 1 + x \cdot T + x^2 \cdot T^3 \\
  &amp;= 1 + x + x^2 \cdot T^2 + x^2 \cdot T^3 \\
  &amp;= 1 + x + x^2 \cdot T^2 \cdot (1 + T) \\
  &amp;= 1 + x \cdot (1 + x \cdot T^2 \cdot (1 + T))
\end{aligned}
</span></p>
<p>Each step uses standard algebraic manipulations: substituting <span
class="math inline">T = 1 + xT^2</span>, expanding, factoring, and
rearranging. The result is a different but algebraically equivalent
expression.</p>
<p>Now let us translate this resulting expression back to a type:</p>
<p><code>ocaml env=ch2 type repr =   (int * (int * btree * btree * btree option) option) option</code></p>
<p>Reading the polynomial <span class="math inline">1 + x \cdot (1 + x
\cdot T^2 \cdot (1 + T))</span> from outside in: we have an option (the
outermost <span class="math inline">1 + \ldots</span>), whose
<code>Some</code> case contains an <code>int</code> times another
option, and so on.</p>
<p>The challenge is to find isomorphism functions with signatures:</p>
<pre><code>val iso1 : btree -&gt; repr
val iso2 : repr -&gt; btree</code></pre>
<p>These functions should satisfy: for all trees <code>t</code>,
<code>iso2 (iso1 t) = t</code>, and for all representations
<code>r</code>, <code>iso1 (iso2 r) = r</code>. Can you write them?</p>
<h4 id="my-first-failed-attempt">My First (Failed) Attempt</h4>
<p>Here is my first attempt, trying to guess the pattern directly:</p>
<pre><code># let iso1 (t : btree) : repr =
  match t with
    | Tip -&gt; None
    | Node (x, Tip, Tip) -&gt; Some (x, None)
    | Node (x, Node (y, t1, t2), Tip) -&gt;
      Some (x, Some (y, t1, t2, None))
    | Node (x, Node (y, t1, t2), t3) -&gt;
      Some (x, Some (y, t1, t2, Some t3));;

Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Node (_, Tip, Node (_, _, _))</code></pre>
<p>I forgot about one case! The case
<code>Node (_, Tip, Node (_, _, _))</code>—a node with an empty left
subtree and non-empty right subtree—was not covered. It seems difficult
to guess the solution directly when trying to map the complex final form
all at once.</p>
<p>Have you found it on your first try? If so, congratulations! Most
people do not. This illustrates an important principle: complex
transformations are easier to get right when broken into smaller
steps.</p>
<h4 id="breaking-down-the-problem">Breaking Down the Problem</h4>
<p>Let us divide the task into smaller steps corresponding to
intermediate points in the polynomial transformation. Instead of jumping
from <span class="math inline">T = 1 + xT^2</span> directly to the final
form, we will introduce intermediate types for each algebraic step:</p>
<p>```ocaml env=ch2 type (’a, ’b) choice = Left of ’a | Right of ’b</p>
<p>type interm1 = ((int * btree, int * int * btree * btree * btree)
choice) option</p>
<p>type interm2 = ((int, int * int * btree * btree * btree option)
choice) option</p>
<pre><code>
Now we can define each step:

```ocaml env=ch2
let step1r (t : btree) : interm1 =
  match t with
    | Tip -&gt; None
    | Node (x, t1, Tip) -&gt; Some (Left (x, t1))
    | Node (x, t1, Node (y, t2, t3)) -&gt;
      Some (Right (x, y, t1, t2, t3))

let step2r (r : interm1) : interm2 =
  match r with
    | None -&gt; None
    | Some (Left (x, Tip)) -&gt; Some (Left x)
    | Some (Left (x, Node (y, t1, t2))) -&gt;
      Some (Right (x, y, t1, t2, None))
    | Some (Right (x, y, t1, t2, t3)) -&gt;
      Some (Right (x, y, t1, t2, Some t3))

let step3r (r : interm2) : repr =
  match r with
    | None -&gt; None
    | Some (Left x) -&gt; Some (x, None)
    | Some (Right (x, y, t1, t2, t3opt)) -&gt;
      Some (x, Some (y, t1, t2, t3opt))

let iso1 (t : btree) : repr =
  step3r (step2r (step1r t))</code></pre>
<p>Each step function handles one small transformation, and the compiler
verifies that our pattern matching is exhaustive. No more missed
cases!</p>
<p><strong>Exercise:</strong> Define <code>step1l</code>,
<code>step2l</code>, <code>step3l</code>, and <code>iso2</code>.</p>
<p><em>Hint:</em> Now it is straightforward—each step is simply the
inverse of its corresponding forward step. The left-going functions undo
what the right-going functions do.</p>
<h4 id="take-home-lessons">Take-Home Lessons</h4>
<p>This exploration of type isomorphisms teaches us two valuable
principles:</p>
<ol type="1">
<li><p><strong>Design for validity:</strong> Try to define data
structures so that only meaningful information can be represented—as
long as it does not overcomplicate the data structures. Avoid catch-all
clauses when defining functions. The compiler will then tell you if you
have forgotten about a case. The exhaustiveness checker is your
friend.</p></li>
<li><p><strong>Divide and conquer:</strong> Break solutions into small
steps so that each step can be easily understood and verified. When I
tried to write <code>iso1</code> directly, I made a mistake. When I
broke it into three simple steps, each step was obviously correct, and
composing them gave the right answer.</p></li>
</ol>
<h3 id="differentiating-algebraic-data-types">2.6 Differentiating
Algebraic Data Types</h3>
<p>Of course, you might object that the pompous title is wrong—we will
differentiate the translated polynomials, not the types themselves. Fair
enough! But what sense does differentiating a type’s polynomial
make?</p>
<p>It turns out that taking the partial derivative of a polynomial
(translated from a data type), when translated back, gives a type
representing a “one-hole context”—a data structure with one piece
missing. This missing piece corresponds to the variable with respect to
which we differentiated. The derivative tells us: “Here are all the ways
to point at one element of this type.”</p>
<h4 id="example-differentiating-a-simple-record">Example:
Differentiating a Simple Record</h4>
<p>Let us start with a simple record type:</p>
<p><code>ocaml env=ch2 type ymd = { year : int; month : int; day : int }</code></p>
<p>The translation and its derivative:</p>
<p><span class="math display">
\begin{aligned}
D &amp;= x \cdot x \cdot x = x^3 \\
\frac{\partial D}{\partial x} &amp;= 3x^2 = x \cdot x + x \cdot x + x
\cdot x
\end{aligned}
</span></p>
<p>We could have left it as <span class="math inline">3 \cdot x \cdot
x</span>, but expanding it as a sum shows the structure more clearly.
The derivative <span class="math inline">3x^2</span> says: there are
three ways to “point at” an <code>int</code> in a <code>ymd</code>, and
each way leaves two other <code>int</code>s behind.</p>
<p>Translating the expanded form back to a type:</p>
<p><code>ocaml env=ch2 type ymd_ctx =   Year of int * int | Month of int * int | Day of int * int</code></p>
<p>Each variant represents a “hole” at a different position: -
<code>Year (m, d)</code> means the year field is the hole (and we have
the month <code>m</code> and day <code>d</code>) -
<code>Month (y, d)</code> means the month field is the hole (and we have
year <code>y</code> and day <code>d</code>) - <code>Day (y, m)</code>
means the day field is the hole</p>
<p>Now we can define functions to introduce and eliminate this
derivative type:</p>
<p>```ocaml env=ch2 let ymd_deriv ({ year = y; month = m; day = d } :
ymd) = [ Year (m, d); Month (y, d); Day (y, m) ]</p>
<p>let ymd_integr n = function | Year (m, d) -&gt; { year = n; month =
m; day = d } | Month (y, d) -&gt; { year = y; month = n; day = d } | Day
(y, m) -&gt; { year = y; month = m; day = n }</p>
<p>let example = List.map (ymd_integr 7) (ymd_deriv { year = 2012; month
= 2; day = 14 })</p>
<pre><code>
The `ymd_deriv` function produces all contexts (one for each field)---it &quot;differentiates&quot; a record into a list of one-hole contexts. The `ymd_integr` function fills in a hole with a new value---it &quot;integrates&quot; by putting a value back into the context. Notice how the naming follows the calculus analogy!

The example above takes the date February 14, 2012, produces three contexts (one for each field), and then fills each hole with the number 7, producing three modified dates.

#### Example: Differentiating Binary Trees

Now let us tackle the more challenging case of binary trees (using the same `btree` type as above):
</code></pre>
<p>type btree = Tip | Node of int * btree * btree</p>
<pre><code>
The translation and differentiation:

$$
\begin{aligned}
T &amp;= 1 + x \cdot T^2 \\
\frac{\partial T}{\partial x} &amp;= 0 + T^2 + 2 \cdot x \cdot T \cdot \frac{\partial T}{\partial x} = T \cdot T + 2 \cdot x \cdot T \cdot \frac{\partial T}{\partial x}
\end{aligned}
$$

Something interesting happened: the derivative is recursive! It refers to itself via $\frac{\partial T}{\partial x}$. This makes perfect sense when you think about it:

- $T \cdot T$ represents pointing at the root: the hole is at the current node, and we have the two subtrees.
- $2 \cdot x \cdot T \cdot \frac{\partial T}{\partial x}$ represents pointing deeper in the tree: we choose left or right (the factor of 2), remember the current node&#39;s value ($x$), keep the other subtree ($T$), and then have a context in the chosen subtree ($\frac{\partial T}{\partial x}$).

Instead of translating $2$ as `bool`, we introduce a more descriptive type to make the code clearer:

```ocaml env=ch2
type btree_dir = LeftBranch | RightBranch

type btree_deriv =
  | Here of btree * btree
  | Below of btree_dir * int * btree * btree_deriv</code></pre>
<p>The <code>Here</code> constructor means the hole is at the current
position, and we have the left and right subtrees. The
<code>Below</code> constructor means we go down one level, remembering
which direction we went, the value at the node we passed, and the
subtree we did not enter.</p>
<p>(You might someday hear about <em>zippers</em>—they are “inverted”
relative to our type. In a zipper, the hole comes first, and the context
trails behind. Both representations are useful in different
situations.)</p>
<p><strong>Exercise:</strong> Write a function that takes a number and a
<code>btree_deriv</code>, and builds a <code>btree</code> by putting the
number into the “hole” in <code>btree_deriv</code>.</p>
<details>
<summary>
Solution
</summary>
<p>The integration function fills the hole with a value. It must be
recursive because the derivative type is recursive—we may need to
descend through multiple <code>Below</code> constructors before reaching
the <code>Here</code> where the hole actually is:</p>
<p><code>ocaml env=ch2 let rec btree_integr n = function   | Here (ltree, rtree) -&gt; Node (n, ltree, rtree)   | Below (LeftBranch, m, rtree, deriv) -&gt;     Node (m, btree_integr n deriv, rtree)   | Below (RightBranch, m, ltree, deriv) -&gt;     Node (m, ltree, btree_integr n deriv)</code></p>
<p>When we reach <code>Here</code>, we create a node with the new value
<code>n</code> and the two subtrees. When we see <code>Below</code>, we
reconstruct the node we passed through and recursively integrate into
the appropriate subtree.</p>
</details>
<h3 id="exercises-1">2.7 Exercises</h3>
<h4 id="exercise-1-designing-valid-data-structures">Exercise 1:
Designing Valid Data Structures</h4>
<p><em>Due to Yaron Minsky.</em></p>
<p>This exercise practices the principle of “making invalid states
unrepresentable.” Consider a datatype to store internet connection
information. The time <code>when_initiated</code> marks the start of
connecting and is not needed after the connection is established (it is
only used to decide whether to give up trying to connect). The ping
information is available for established connections but not straight
away.</p>
<pre><code>type connectionstate = Connecting | Connected | Disconnected

type connectioninfo = {
  state : connectionstate;
  server : Inetaddr.t;
  lastpingtime : Time.t option;
  lastpingid : int option;
  sessionid : string option;
  wheninitiated : Time.t option;
  whendisconnected : Time.t option;
}</code></pre>
<p>(The types <code>Time.t</code> and <code>Inetaddr.t</code> come from
the <em>Core</em> library. You can replace them with <code>float</code>
and <code>Unix.inet_addr</code>. Load the Unix library in the
interactive toplevel with <code>#load "unix.cma";;</code>.)</p>
<p>The problem with this design is that it allows many nonsensical
combinations: a <code>Connecting</code> state with ping information, a
<code>Disconnected</code> state with a session ID, etc. The optional
fields (all those <code>option</code> types) make it unclear which
fields are valid in which states.</p>
<p>Rewrite the type definitions so that the datatype will contain only
reasonable combinations of information. Use separate record types for
each connection state, with only the fields that make sense for that
state.</p>
<h4 id="exercise-2-labeled-and-optional-arguments">Exercise 2: Labeled
and Optional Arguments</h4>
<p>In OCaml, functions can have labeled arguments and optional arguments
(parameters with default values that can be omitted). This exercise
explores these features.</p>
<p>Labels can differ from the names of argument values:</p>
<p><code>ocaml env=ch2 let f ~meaningfulname:n = n + 1 let _ = f ~meaningfulname:5  (* We do not need the result so we ignore it. *)</code></p>
<p>When the label and value names are the same, the syntax is
shorter:</p>
<p>```ocaml env=ch2 let g ~pos ~len = StringLabels.sub
“0123456789abcdefghijklmnopqrstuvwxyz” ~pos ~len</p>
<p>let () = (* A nicer way to mark computations that return unit. *) let
pos = Random.int 26 in let len = Random.int 10 in print_string (g ~pos
~len)</p>
<pre><code>
When some function arguments are optional, the function must take non-optional arguments after the last optional argument. Optional parameters with default values:

```ocaml env=ch2
let h ?(len=1) pos = g ~pos ~len
let () = print_string (h 10)</code></pre>
<p>Optional arguments are implemented as parameters of an option type.
This allows checking whether the argument was provided:</p>
<p><code>ocaml env=ch2 let foo ?bar n =   match bar with     | None -&gt; "Argument = " ^ string_of_int n     | Some m -&gt; "Sum = " ^ string_of_int (m + n)</code></p>
<p>We can use it in various ways:</p>
<p><code>ocaml env=ch2 let _ = foo 5 let _ = foo ~bar:5 7</code></p>
<p>We can also provide the option value directly:</p>
<p><code>ocaml env=ch2 let test_foo () =   let bar = if Random.int 10 &lt; 5 then None else Some 7 in   foo ?bar 7</code></p>
<ol type="1">
<li><p>Observe the types that functions with labeled and optional
arguments have. Come up with coding style guidelines for when to use
labeled arguments. When might they improve readability? When might they
be overkill?</p></li>
<li><p>Write a rectangle-drawing procedure that takes three optional
arguments: left-upper corner, right-lower corner, and a width-height
pair. It should draw a correct rectangle whenever two of the three
arguments are given (since any two determine the third), and raise an
exception otherwise. Use the <em>Bogue</em> library.</p></li>
<li><p>Write a function that takes an optional argument of arbitrary
type and a function argument, and passes the optional argument to the
function without inspecting it. This tests your understanding of how
optional arguments work at the type level.</p></li>
</ol>
<h4 id="exercise-3-type-inference-practice">Exercise 3: Type Inference
Practice</h4>
<p><em>From a past exam.</em></p>
<p>These exercises help you internalize how type inference works. Try to
work them out by hand before checking with the OCaml toplevel.</p>
<ol type="1">
<li>Give the (most general) types of the following expressions, either
by guessing or by inferring by hand:
<ol type="1">
<li><code>let double f y = f (f y) in fun g x -&gt; double (g x)</code></li>
<li><code>let rec tails l = match l with [] -&gt; [] | x::xs -&gt; xs::tails xs in fun l -&gt; List.combine l (tails l)</code></li>
</ol></li>
<li>Give example expressions that have the following types (without
using type constraints). There are many possible answers for each:
<ol type="1">
<li><code>(int -&gt; int) -&gt; bool</code></li>
<li><code>'a option -&gt; 'a list</code></li>
</ol></li>
</ol>
<h4 id="exercise-4-types-as-exponents">Exercise 4: Types as
Exponents</h4>
<p>We have seen that algebraic data types can be related to analytic
functions (the subset definable from polynomials via recursion)—by
literally interpreting sum types (variant types) as sums and product
types (tuple and record types) as products. We can extend this
interpretation to function types by interpreting <span
class="math inline">a \rightarrow b</span> as <span
class="math inline">b^a</span> (i.e., <span class="math inline">b</span>
to the power of <span class="math inline">a</span>). Note that the <span
class="math inline">b^a</span> notation is actually used to denote
functions in set theory.</p>
<p>This interpretation makes sense: a function from a set with <span
class="math inline">a</span> elements to a set with <span
class="math inline">b</span> elements is choosing, for each of the <span
class="math inline">a</span> inputs, one of <span
class="math inline">b</span> outputs—giving <span
class="math inline">b^a</span> possible functions.</p>
<ol type="1">
<li><p>Translate <span class="math inline">a^{b + cd}</span> and <span
class="math inline">a^b \cdot (a^c)^d</span> into OCaml types, using any
distinct types for <span class="math inline">a, b, c, d</span>, and
using <code>type ('a,'b) choice = Left of 'a | Right of 'b</code> for
<span class="math inline">+</span>. Write the bijection functions in
both directions. Verify algebraically that <span
class="math inline">a^{b + cd} = a^b \cdot (a^c)^d</span> using the laws
of exponents.</p></li>
<li><p>Come up with a type <code>'t exp</code> that shares with the
exponential function the following property: <span
class="math inline">\frac{\partial \exp(t)}{\partial t} =
\exp(t)</span>, where we translate a derivative of a type as a context
(i.e., the type with a “hole”), as in this chapter. In other words, the
derivative of the type should be isomorphic to the type itself! Explain
why your answer is correct. <em>Hint:</em> in computer science, our
logarithms are mostly base 2.</p></li>
</ol>
<p><em>Further reading:</em> <a
href="http://bababadalgharaghtakamminarronnkonnbro.blogspot.com/2012/10/algebraic-type-systems-combinatorial.html">Algebraic
Type Systems - Combinatorial Species</a></p>
<h4 id="exercise-5-homework-finding-contexts">Exercise 5 (Homework):
Finding Contexts</h4>
<p>Write a function <code>btree_deriv_at</code> that takes a predicate
over integers (i.e., a function <code>f: int -&gt; bool</code>) and a
<code>btree</code>, and builds a <code>btree_deriv</code> whose “hole”
is in the first position for which the predicate returns true. It should
return a <code>btree_deriv option</code>, with <code>None</code> if the
predicate does not hold for any node.</p>
<p>This function lets you “search” a tree and get back a context
pointing to the found element. Think about what order you want to search
in (pre-order, in-order, or post-order) and what “first” means in that
context.</p>
<h2 id="chapter-3-computation">Chapter 3: Computation</h2>
<p><em>Reduction semantics and operational reasoning</em></p>
<p><strong>In this chapter, you will:</strong></p>
<ul>
<li>Use function composition to build reusable “pipelines”</li>
<li>Learn reduction semantics to reason about evaluation step by
step</li>
<li>Recognize and write tail-recursive programs (and understand what TCO
buys you)</li>
<li>Get a first working intuition for continuation-passing style
(CPS)</li>
</ul>
<p><strong>References:</strong></p>
<ul>
<li>“Using, Understanding and Unraveling the OCaml Language” by Didier
Remy, Chapter 1</li>
<li>“The OCaml system” manual, the tutorial part, Chapter 1</li>
</ul>
<p>In this chapter, we explore how functional programs actually execute.
We will learn how to reason about computation step by step using
<em>reduction semantics</em>, and discover important optimization
techniques like <em>tail call optimization</em> that make functional
programming practical. Along the way, we will encounter our first taste
of <em>continuation passing style</em>, a powerful programming technique
that will reappear throughout this book.</p>
<h3 id="function-composition">3.1 Function Composition</h3>
<p>Function composition is one of the most fundamental operations in
functional programming. It allows us to build complex transformations by
combining simpler functions. The usual way function composition is
defined in mathematics is “backward”—the notation follows the convention
of mathematical function application:</p>
<p><span class="math display">
(f \circ g)(x) = f(g(x))
</span></p>
<p>This means that when we write <span class="math inline">f \circ
g</span>, we first apply <span class="math inline">g</span> and then
apply <span class="math inline">f</span> to the result. The function
written on the left is applied last—hence the term “backward”
composition. Here is how this is expressed in different functional
programming languages:</p>
<table>
<thead>
<tr>
<th>Language</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td>Math</td>
<td><span class="math inline">(f \circ g)(x) = f(g(x))</span></td>
</tr>
<tr>
<td>OCaml</td>
<td><code>let (-|) f g x = f (g x)</code></td>
</tr>
<tr>
<td>F#</td>
<td><code>let (&lt;&lt;) f g x = f (g x)</code></td>
</tr>
<tr>
<td>Haskell</td>
<td><code>(.) f g = \x -&gt; f (g x)</code></td>
</tr>
</tbody>
</table>
<p>This backward composition looks like function application but needs
fewer parentheses. Do you recall the functions <code>iso1</code> and
<code>iso2</code> from the previous chapter on type isomorphisms? Using
backward composition, we could write:</p>
<p><code>ocaml skip let iso2 = step1l -| step2l -| step3l</code></p>
<p>While backward composition matches traditional mathematical notation,
many programmers find a “forward” composition more intuitive. Forward
composition follows the order in which computation actually
proceeds—data flows from left to right, matching how we typically read
code in most programming languages:</p>
<table>
<thead>
<tr>
<th>Language</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td>OCaml</td>
<td><code>let (\|-) f g x = g (f x)</code></td>
</tr>
<tr>
<td>F#</td>
<td><code>let (&gt;&gt;) f g x = g (f x)</code></td>
</tr>
</tbody>
</table>
<p>With forward composition, you can read a pipeline of transformations
in the natural order:</p>
<p><code>ocaml skip let iso1 = step1r |- step2r |- step3r</code></p>
<p>Here, the data first passes through <code>step1r</code>, then the
result goes to <code>step2r</code>, and finally to <code>step3r</code>.
This “pipeline” style of programming is particularly popular in
languages like F# and has influenced the design of many modern
programming languages.</p>
<p>In the table above, the operator is written as <code>\|-</code>
because Markdown tables use <code>|</code> to separate columns. In
actual OCaml code, the operator name is <code>(|-)</code>.</p>
<p><code>ocaml env=ch3 let (|-) f g x = g (f x)</code></p>
<p>Two related (but distinct) tools are also worth knowing:</p>
<ul>
<li>The standard library provides backward composition as
<code>Fun.compose</code>, where
<code>Fun.compose f g x = f (g x)</code>.</li>
<li>OCaml also provides the forward <em>application</em> operator
<code>(|&gt;)</code> (a pipeline): <code>x |&gt; f |&gt; g</code> means
<code>g (f x)</code>. Unlike <code>(|-)</code>, this is not composition
of functions but immediate application to a value.</li>
</ul>
<h4 id="partial-application">Partial Application</h4>
<p>Both composition examples above rely on <strong>partial
application</strong>, a technique we introduced in the previous chapter.
Recall that <code>((+) 1)</code> is a function that adds 1 to its
argument—we have provided only one of the two arguments that
<code>(+)</code> requires. Partial application occurs whenever we supply
fewer arguments than a function expects; the result is a new function
that waits for the remaining arguments.</p>
<p>Consider the composition <code>step1r |- step2r |- step3r</code>. How
exactly does partial application come into play here? The composition
operator <code>(|-)</code> is defined as
<code>let (|-) f g x = g (f x)</code>, which means it takes
<em>three</em> arguments: two functions <code>f</code> and
<code>g</code>, and a value <code>x</code>. When we write
<code>step1r |- step2r</code>, we are partially applying
<code>(|-)</code> with just two arguments. The result is a function that
still needs the final argument <code>x</code>.</p>
<p><em>Exercise:</em> Think about the types involved. If
<code>step1r</code> has type <code>'a -&gt; 'b</code> and
<code>step2r</code> has type <code>'b -&gt; 'c</code>, what is the type
of <code>step1r |- step2r</code>?</p>
<p><em>Check:</em> <code>step1r |- step2r</code> has type
<code>'a -&gt; 'c</code>. (Composition “cancels” the middle type
<code>'b</code>.)</p>
<h4 id="power-function">Power Function</h4>
<p>Now we define iterated function composition—applying a function to
itself repeatedly. This is written mathematically as:</p>
<p><span class="math display">
f^n(x) := \underbrace{(f \circ \cdots \circ f)}_{n \text{ times}}(x)
</span></p>
<p>In other words, <span class="math inline">f^0</span> is the identity
function, <span class="math inline">f^1 = f</span>, <span
class="math inline">f^2 = f \circ f</span>, and so on. In OCaml, we
first define the backward composition operator, then use it to implement
<code>power</code>:</p>
<p>```ocaml env=ch3 let (-|) f g x = f (g x)</p>
<p>let rec power f n = if n &lt;= 0 then (fun x -&gt; x) else f -| power
f (n-1)</p>
<pre><code>
When `n &lt;= 0`, we return the identity function `fun x -&gt; x`. Otherwise, we compose `f` with `power f (n-1)`, which gives us one more application of `f`. Notice how elegantly this definition expresses the mathematical concept---we are literally composing `f` with itself `n` times.

This `power` function is surprisingly versatile. For example, we can use it to define addition in terms of the successor function:

```ocaml env=ch3
let add n = power ((+) 1) n</code></pre>
<p>Here <code>add 5 7</code> would compute <span class="math inline">7 +
1 + 1 + 1 + 1 + 1 = 12</span>. We could even define multiplication:</p>
<p><code>ocaml env=ch3 let mult k n = power ((+) k) n 0</code></p>
<p>This computes <span class="math inline">0 + k + k + \ldots + k</span>
(adding <span class="math inline">k</span> a total of <span
class="math inline">n</span> times), giving us <span
class="math inline">k \times n</span>. While not the most efficient
implementation, these examples show how higher-order functions like
<code>power</code> can express fundamental mathematical operations.</p>
<h4 id="numerical-derivative">Numerical Derivative</h4>
<p>A beautiful application of <code>power</code> is computing
higher-order derivatives. First, let us define a numerical approximation
of the derivative using the standard finite difference formula:</p>
<p><code>ocaml env=ch3 let derivative dx f = fun x -&gt; (f (x +. dx) -. f x) /. dx</code></p>
<p>This definition computes <span class="math inline">\frac{f(x + dx) -
f(x)}{dx}</span>, which approximates <span
class="math inline">f&#39;(x)</span> when <code>dx</code> is small.
Notice the explicit <code>fun x -&gt; ...</code> syntax, which
emphasizes that <code>derivative dx f</code> is itself a function—we are
transforming a function <code>f</code> into its derivative function.</p>
<p>We can write the same definition more concisely using OCaml’s curried
function syntax:</p>
<p><code>ocaml env=ch3 let derivative dx f x = (f (x +. dx) -. f x) /. dx</code></p>
<p>Both definitions are equivalent, but the first makes the “function
returning a function” structure more explicit, while the second is more
compact.</p>
<p><strong>A note on OCaml’s numeric operators:</strong> OCaml uses
different operators for floating-point arithmetic than for integers. The
type of <code>(+)</code> is <code>int -&gt; int -&gt; int</code>, so we
cannot use <code>+</code> with <code>float</code> values. Instead,
operators followed by a dot work on <code>float</code> numbers:
<code>+.</code>, <code>-.</code>, <code>*.</code>, and <code>/.</code>.
This might seem inconvenient at first, but it catches type errors at
compile time and avoids the implicit conversions that cause subtle bugs
in other languages.</p>
<h4 id="computing-higher-order-derivatives">Computing Higher-Order
Derivatives</h4>
<p>Now comes the payoff. With <code>power</code> and
<code>derivative</code>, we can elegantly compute higher-order
derivatives:</p>
<p><code>ocaml env=ch3 let pi = 4.0 *. atan 1.0 let sin''' = (power (derivative 1e-5) 3) sin let _approx = sin''' pi</code></p>
<p>Here <code>sin'''</code> is the third derivative of sine. The
expression <code>(power (derivative 1e-5) 3)</code> creates a function
that applies the derivative operation three times—exactly what we need
for the third derivative.</p>
<p>Mathematically, the third derivative of <span
class="math inline">\sin(x)</span> is <span
class="math inline">-\cos(x)</span>, so <code>sin''' pi</code> should
give us <span class="math inline">-\cos(\pi) = 1</span>. The actual
result will be close to 1, with some numerical error due to the finite
difference approximation (the error compounds with each derivative we
take).</p>
<p>This example demonstrates the power of treating functions as
first-class values. We have built a general-purpose derivative operator
and combined it with our <code>power</code> function to create an <span
class="math inline">n</span>th-derivative calculator—all in just a few
lines of code.</p>
<h3 id="evaluation-rules-reduction-semantics">3.2 Evaluation Rules
(Reduction Semantics)</h3>
<p>So far, we have written OCaml programs and observed their results,
but we have not precisely described <em>how</em> those results are
computed. To understand how OCaml programs execute, we need to formalize
the evaluation process. This section presents <strong>reduction
semantics</strong> (also called <em>operational semantics</em>), which
describes computation as a series of rewriting steps that transform
expressions until we reach a final value.</p>
<p>Understanding reduction semantics is valuable for several reasons. It
helps us predict what our programs will do, reason about their
efficiency, and understand subtle behaviors like infinite loops and
non-termination. The ideas here also form the foundation for
understanding more advanced topics like type systems and program
verification.</p>
<h4 id="expressions">Expressions</h4>
<p>Programs consist of <strong>expressions</strong>. Here is the grammar
of expressions for a simplified version of OCaml (we omit some features
for clarity):</p>
<p><span class="math display">
\begin{array}{lcll}
a &amp; := &amp; x &amp; \text{variables} \\
  &amp; |  &amp; \texttt{fun } x \texttt{ -&gt; } a &amp;
\text{(defined) functions} \\
  &amp; |  &amp; a \; a &amp; \text{applications} \\
  &amp; |  &amp; C^0 &amp; \text{value constructors of arity } 0 \\
  &amp; |  &amp; C^n(a, \ldots, a) &amp; \text{value constructors of
arity } n \\
  &amp; |  &amp; f^n &amp; \text{built-in values (primitives) of arity }
n \\
  &amp; |  &amp; \texttt{let } x = a \texttt{ in } a &amp; \text{name
bindings (local definitions)} \\
  &amp; |  &amp; \texttt{match } a \texttt{ with} &amp; \\
  &amp;    &amp; \quad p \texttt{ -&gt; } a \texttt{ | } \cdots \texttt{
| } p \texttt{ -&gt; } a &amp; \text{pattern matching} \\[1em]
p &amp; := &amp; x &amp; \text{pattern variables} \\
  &amp; |  &amp; (p, \ldots, p) &amp; \text{tuple patterns} \\
  &amp; |  &amp; C^0 &amp; \text{variant patterns of arity } 0 \\
  &amp; |  &amp; C^n(p, \ldots, p) &amp; \text{variant patterns of arity
} n
\end{array}
</span></p>
<p><strong>Arity</strong> means how many arguments something requires.
For constructors, arity tells us how many components the constructor
holds; for functions (primitives), it tells us how many arguments they
need before they can compute a result. For tuple patterns, arity is
simply the length of the tuple.</p>
<p><strong>Meta-syntax note.</strong> In the grammar and rules below, we
write constructors as if they were truly <span
class="math inline">n</span>-ary, e.g. <span
class="math inline">C^3(a_1,a_2,a_3)</span>. In actual OCaml syntax,
constructors take exactly one argument; “multiple arguments” are
represented by a tuple, e.g. <code>Node (v1, v2, v3)</code>. The <span
class="math inline">n</span>-ary presentation is a convenient
mathematical shorthand.</p>
<p><strong>Evaluation-order note.</strong> The small-step rules below
are intentionally simplified. In particular, the “context” rules allow
reducing subexpressions in more than one place. Real OCaml is
<em>strict</em> (call-by-value) and evaluates subexpressions in a
deterministic order (in current OCaml implementations this is often
right-to-left); the details matter when you have effects (exceptions,
printing, mutation), but are usually irrelevant for purely functional
code.</p>
<h4 id="the-fix-primitive">The <code>fix</code> Primitive</h4>
<p>Our grammar above includes functions defined with <code>fun</code>,
but what about recursive functions defined with <code>let rec</code>? To
keep our semantics simple, we introduce a primitive <code>fix</code>
that captures the essence of recursion:</p>
<p><span class="math display">
\texttt{let rec } f \; x = e_1 \texttt{ in } e_2 \equiv \texttt{let } f
= \texttt{fix (fun } f \; x \texttt{ -&gt; } e_1 \texttt{) in } e_2
</span></p>
<p>The <code>fix</code> primitive is a <em>fixpoint combinator</em>. It
takes a function that expects to receive “itself” as its first argument
and produces a function that, when called, behaves as if it has access
to itself for recursive calls. This might seem mysterious now, but we
will see exactly how it works when we examine its reduction rule
below.</p>
<h4 id="values">Values</h4>
<p>Expressions evaluate (i.e., compute) to <strong>values</strong>.
Values are expressions that cannot be reduced further—they are the
“final answers” of computation:</p>
<p><span class="math display">
\begin{array}{lcll}
v &amp; := &amp; \texttt{fun } x \texttt{ -&gt; } a &amp;
\text{(defined) functions} \\
  &amp; |  &amp; C^n(v_1, \ldots, v_n) &amp; \text{constructed values}
\\
  &amp; |  &amp; f^n \; v_1 \; \cdots \; v_k &amp; k &lt; n \text{
(partially applied primitives)}
\end{array}
</span></p>
<p>Note that functions are values: <code>fun x -&gt; x + 1</code> is
already fully evaluated—there is nothing more to compute until the
function is applied to an argument. Similarly, constructed values like
<code>Some 42</code> or <code>(1, 2, 3)</code> are values when all their
components are values.</p>
<p>Partially applied primitives like <code>(+) 3</code> are also values.
The expression <code>(+) 3</code> has received one argument but needs
another before it can compute a sum. Until that second argument arrives,
there is nothing more to do, so <code>(+) 3</code> is a value.</p>
<h4 id="substitution">Substitution</h4>
<p>The heart of evaluation is <strong>substitution</strong>. To
substitute a value <span class="math inline">v</span> for a variable
<span class="math inline">x</span> in expression <span
class="math inline">a</span>, we write <span class="math inline">a[x :=
v]</span>. This notation means that every occurrence of <span
class="math inline">x</span> in <span class="math inline">a</span> is
replaced by <span class="math inline">v</span>.</p>
<p>For example, if <span class="math inline">a</span> is the expression
<code>x + x * y</code> and we substitute 3 for <code>x</code>, we get
<code>3 + 3 * y</code>. In our notation:
<code>(x + x * y)[x := 3] = 3 + 3 * y</code>.</p>
<p>In the presence of binders like <code>fun x -&gt; ...</code> (and
pattern-bound variables), substitution must be
<strong>capture-avoiding</strong>: we are allowed to rename bound
variables so we do not accidentally change which occurrence refers to
which binder.</p>
<p><strong>Implementation note:</strong> Although we describe
substitution as “replacing” variables with values, the actual
implementation in OCaml does not duplicate the value <span
class="math inline">v</span> in memory each time it appears. Instead,
OCaml uses closures and sharing to ensure that values are stored once
and referenced wherever needed. This is both more efficient and
essential for handling recursive data structures.</p>
<h4 id="reduction-rules-redexes">Reduction Rules (Redexes)</h4>
<p>Now we can describe how computation actually proceeds. Reduction
works by finding reducible expressions called <strong>redexes</strong>
(short for “reducible expressions”) and applying reduction rules that
rewrite them into simpler forms. We write <span class="math inline">e_1
\rightsquigarrow e_2</span> to mean “expression <span
class="math inline">e_1</span> reduces to expression <span
class="math inline">e_2</span> in one step.”</p>
<p>Here are the fundamental reduction rules:</p>
<p><strong>Function application (beta reduction):</strong> <span
class="math display">
(\texttt{fun } x \texttt{ -&gt; } a) \; v \rightsquigarrow a[x := v]
</span></p>
<p>This is the most important rule. When we apply a function
<code>fun x -&gt; a</code> to a value <span
class="math inline">v</span>, we substitute <span
class="math inline">v</span> for the parameter <span
class="math inline">x</span> throughout the function body <span
class="math inline">a</span>. This rule is traditionally called “beta
reduction” in the lambda calculus literature.</p>
<p>For example: <code>(fun x -&gt; x + 1) 5</code> <span
class="math inline">\rightsquigarrow</span> <code>5 + 1</code> <span
class="math inline">\rightsquigarrow</span> <code>6</code>.</p>
<p><strong>Let binding:</strong> <span class="math display">
\texttt{let } x = v \texttt{ in } a \rightsquigarrow a[x := v]
</span></p>
<p>A let binding works similarly: once the bound expression has been
evaluated to a value <span class="math inline">v</span>, we substitute
it into the body. Notice that <code>let x = e in a</code> is essentially
equivalent to <code>(fun x -&gt; a) e</code>—both bind <span
class="math inline">x</span> to the result of evaluating <span
class="math inline">e</span> within the expression <span
class="math inline">a</span>.</p>
<p><strong>Primitive application:</strong> <span class="math display">
f^n \; v_1 \; \cdots \; v_n \rightsquigarrow f(v_1, \ldots, v_n)
</span></p>
<p>When a primitive (like <code>+</code> or <code>*</code>) receives all
the arguments it needs (determined by its arity <span
class="math inline">n</span>), it computes the result. Here <span
class="math inline">f(v_1, \ldots, v_n)</span> denotes the actual result
of the primitive operation—for example, <code>(+) 2 3</code> <span
class="math inline">\rightsquigarrow</span> <code>5</code>.</p>
<p><strong>Pattern matching with a variable pattern:</strong> <span
class="math display">
\texttt{match } v \texttt{ with } x \texttt{ -&gt; } a \texttt{ | }
\cdots \rightsquigarrow a[x := v]
</span></p>
<p>A variable pattern always matches, binding the entire value to the
variable.</p>
<p><strong>Pattern matching with a non-matching constructor:</strong>
<span class="math display">
\frac{C_1 \neq C_2}{\texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{
with } C_2^k(p_1, \ldots, p_k) \texttt{ -&gt; } a \texttt{ | } pm
\rightsquigarrow \texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{ with }
pm}
</span></p>
<p>If the constructor in the value (<span
class="math inline">C_1</span>) does not match the constructor in the
pattern (<span class="math inline">C_2</span>), we skip this branch and
try the remaining patterns (<span class="math inline">pm</span>). This
is how OCaml searches through pattern match cases from top to
bottom.</p>
<p><strong>Pattern matching with a matching constructor:</strong> <span
class="math display">
\texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{ with } C_1^n(x_1,
\ldots, x_n) \texttt{ -&gt; } a \texttt{ | } \cdots \rightsquigarrow
a[x_1 := v_1; \ldots; x_n := v_n]
</span></p>
<p>If the constructor matches, we substitute all the values from inside
the constructor for the corresponding pattern variables. For example,
<code>match Some 42 with Some x -&gt; x + 1 | None -&gt; 0</code>
reduces to <code>42 + 1</code> because <code>Some</code> matches
<code>Some</code> and we substitute 42 for <code>x</code>.</p>
<p>If <span class="math inline">n = 0</span>, then <span
class="math inline">C_1^n(v_1, \ldots, v_n)</span> stands for simply
<span class="math inline">C_1^0</span>, a constructor with no arguments
(like <code>None</code> or <code>[]</code>). We omit the more complex
cases of nested pattern matching for brevity.</p>
<h4 id="rule-variables">Rule Variables</h4>
<p>In these rules, we use <em>metavariables</em>—placeholders that can
be replaced with actual expressions. Understanding them is key to
applying the rules:</p>
<ul>
<li><span class="math inline">x</span> matches any variable name (like
<code>foo</code>, <code>n</code>, or <code>result</code>)</li>
<li><span class="math inline">a, a_1, \ldots, a_n</span> match any
expression (not necessarily a value)</li>
<li><span class="math inline">v, v_1, \ldots, v_n</span> match any
<em>value</em> (expressions that are fully evaluated)</li>
</ul>
<p>To apply a rule, find substitutions for these metavariables that make
the left-hand side of the rule match your expression. Then the
right-hand side (with the same substitutions applied) gives you the
reduced expression.</p>
<p>For example, to apply the beta reduction rule to
<code>(fun n -&gt; n * 2) 5</code>: 1. Match <code>fun x -&gt; a</code>
with <code>fun n -&gt; n * 2</code>, giving us <span
class="math inline">x = \texttt{n}</span> and <span
class="math inline">a = \texttt{n * 2}</span> 2. Match <span
class="math inline">v</span> with <code>5</code> 3. The right-hand side
<span class="math inline">a[x := v]</span> becomes
<code>(n * 2)[n := 5]</code> which equals <code>5 * 2</code></p>
<h4 id="evaluation-context-rules">Evaluation Context Rules</h4>
<p>The reduction rules above only apply when the arguments are already
values. But what if we have <code>(fun x -&gt; x + 1) (2 + 3)</code>?
The argument <code>2 + 3</code> is not a value, so we cannot directly
apply beta reduction. We need rules that tell us evaluation can proceed
inside subexpressions.</p>
<p>If <span class="math inline">a_i \rightsquigarrow a_i&#39;</span>
(meaning <span class="math inline">a_i</span> can take a reduction
step), then:</p>
<p><span class="math display">
\begin{array}{lcl}
a_1 \; a_2 &amp; \rightsquigarrow &amp; a_1&#39; \; a_2 \\
a_1 \; a_2 &amp; \rightsquigarrow &amp; a_1 \; a_2&#39; \\
C^n(a_1, \ldots, a_i, \ldots, a_n) &amp; \rightsquigarrow &amp; C^n(a_1,
\ldots, a_i&#39;, \ldots, a_n) \\
\texttt{let } x = a_1 \texttt{ in } a_2 &amp; \rightsquigarrow &amp;
\texttt{let } x = a_1&#39; \texttt{ in } a_2 \\
\texttt{match } a_1 \texttt{ with } pm &amp; \rightsquigarrow &amp;
\texttt{match } a_1&#39; \texttt{ with } pm
\end{array}
</span></p>
<p>These rules describe <em>where</em> reduction can happen: - In a
function application <span class="math inline">a_1 \; a_2</span>, the
rules allow reducing either the function (<span
class="math inline">a_1</span>) or the argument (<span
class="math inline">a_2</span>). This is a common simplification in
textbook semantics; OCaml itself uses a fixed evaluation order. - In a
constructor application, any argument can be evaluated. - In a let
binding <code>let x = a1 in a2</code>, the bound expression <span
class="math inline">a_1</span> must be evaluated to a value before we
can proceed. Notice there is no rule for evaluating <span
class="math inline">a_2</span> directly—the body is only evaluated after
the substitution happens. - In a match expression, the scrutinee (the
expression being matched) must be evaluated before pattern matching can
proceed.</p>
<h4 id="the-fix-rule">The <code>fix</code> Rule</h4>
<p>Finally, the rule for the <code>fix</code> primitive, which enables
recursion:</p>
<p><span class="math display">
\texttt{fix}^2 \; v_1 \; v_2 \rightsquigarrow v_1 \; (\texttt{fix}^2 \;
v_1) \; v_2
</span></p>
<p>This rule is subtle but powerful. Let us unpack it:</p>
<ol type="1">
<li><code>fix</code> is a binary primitive (arity 2), meaning it needs
two arguments before it computes.</li>
<li>When we apply <code>fix</code> to two values <span
class="math inline">v_1</span> and <span class="math inline">v_2</span>,
it “unrolls” one level of recursion by calling <span
class="math inline">v_1</span> with two arguments: <code>(fix v1)</code>
(which represents “the recursive function itself”) and <span
class="math inline">v_2</span> (the actual argument to the recursive
call).</li>
<li>Because <code>fix</code> has arity 2, the expression
<code>(fix v1)</code> is a <em>partially applied primitive</em>—and
partially applied primitives are values! This is crucial: it means
<code>(fix v1)</code> will not be evaluated further until it is applied
to another argument inside <span class="math inline">v_1</span>.</li>
</ol>
<p>This delayed evaluation is what prevents infinite loops. If
<code>(fix v1)</code> were evaluated immediately, we would get an
infinite chain of expansions. Instead, evaluation only continues when
the recursive function actually makes a recursive call.</p>
<p><code>fix</code> is not an OCaml primitive; it is a pedagogical
device. If you <em>did</em> want to define it directly in OCaml, you
could (ironically) do so using <code>let rec</code>:</p>
<p><code>ocaml env=ch3 let fix f =   let rec self x = f self x in   self</code></p>
<h4 id="practice">Practice</h4>
<p>The best way to understand reduction semantics is to work through
examples by hand. Trace the evaluation of these expressions step by
step:</p>
<p><strong>Exercise 1:</strong> Evaluate
<code>let double x = x + x in double 3</code></p>
<p><strong>Exercise 2:</strong> Evaluate
<code>(fun f -&gt; fun x -&gt; f (f x)) (fun y -&gt; y + 1) 0</code></p>
<p><strong>Exercise 3:</strong> Define the factorial function using
<code>fix</code> and trace the evaluation of
<code>factorial 3</code></p>
<h3 id="symbolic-derivation-example">3.3 Symbolic Derivation
Example</h3>
<p>Let us see the reduction rules in action with a more substantial
example. We will build a small computer algebra system that can
represent mathematical expressions symbolically, evaluate them, and even
compute their derivatives symbolically.</p>
<p>Consider the symbolic expression type from <code>Lec3.ml</code>:</p>
<p>```ocaml env=ch3 type expression = | Const of float | Var of string |
Sum of expression * expression (* e1 + e2 <em>) | Diff of expression
</em> expression (* e1 - e2 <em>) | Prod of expression </em> expression
(* e1 * e2 <em>) | Quot of expression </em> expression (* e1 / e2 *)</p>
<p>exception Unbound_variable of string</p>
<p>let rec eval env exp = match exp with | Const c -&gt; c | Var v -&gt;
(try List.assoc v env with Not_found -&gt; raise (Unbound_variable v)) |
Sum(f, g) -&gt; eval env f +. eval env g | Diff(f, g) -&gt; eval env f
-. eval env g | Prod(f, g) -&gt; eval env f *. eval env g | Quot(f, g)
-&gt; eval env f /. eval env g</p>
<pre><code>
The `expression` type represents mathematical expressions as a tree structure. Each constructor corresponds to a different kind of expression: constants, variables, and the four basic arithmetic operations. The `eval` function takes an environment `env` (a list of variable-value pairs) and recursively evaluates an expression to a floating-point number.

We can also define *symbolic differentiation*---computing the derivative of an expression without evaluating it numerically:

```ocaml env=ch3
let rec deriv exp dv =
  match exp with
  | Const _ -&gt; Const 0.0
  | Var v -&gt; if v = dv then Const 1.0 else Const 0.0
  | Sum(f, g) -&gt; Sum(deriv f dv, deriv g dv)
  | Diff(f, g) -&gt; Diff(deriv f dv, deriv g dv)
  | Prod(f, g) -&gt; Sum(Prod(f, deriv g dv), Prod(deriv f dv, g))
  | Quot(f, g) -&gt; Quot(Diff(Prod(deriv f dv, g), Prod(f, deriv g dv)),
                       Prod(g, g))</code></pre>
<p>The <code>deriv</code> function implements the standard rules of
calculus: - The derivative of a constant is 0. - The derivative of the
variable we are differentiating with respect to is 1; any other variable
is treated as a constant (derivative 0). - The sum and difference rules:
<span class="math inline">(f + g)&#39; = f&#39; + g&#39;</span> and
<span class="math inline">(f - g)&#39; = f&#39; - g&#39;</span>. - The
product rule: <span class="math inline">(f \cdot g)&#39; = f \cdot
g&#39; + f&#39; \cdot g</span>. - The quotient rule: <span
class="math inline">(f / g)&#39; = (f&#39; \cdot g - f \cdot g&#39;) /
g^2</span>.</p>
<p>For convenience, let us define some operators and variables so we can
write expressions more naturally:</p>
<p><code>ocaml env=ch3 let x = Var "x" let y = Var "y" let z = Var "z" let (+:) f g = Sum (f, g) let (-:) f g = Diff (f, g) let ( *: ) f g = Prod (f, g) let (/:) f g = Quot (f, g) let (!:) i = Const i</code></p>
<p>These custom operators (ending in <code>:</code>) let us write
symbolic expressions that look almost like regular mathematical
notation.</p>
<p>Now let us evaluate the expression <span class="math inline">3x + 2y
+ x^2 y</span> at <span class="math inline">x = 1, y = 2</span>:</p>
<p><code>ocaml env=ch3 let example = !:3.0 *: x +: !:2.0 *: y +: x *: x *: y let env = ["x", 1.0; "y", 2.0]</code></p>
<p>For nicer output, it is helpful to define a pretty-printer that
displays expressions in infix notation (this is adapted from
<code>Lec3.ml</code>):</p>
<p><code>ocaml env=ch3 let print_expr ppf exp =   let open_paren prec op_prec =     if prec &gt; op_prec then Format.fprintf ppf "(@["     else Format.fprintf ppf "@[" in   let close_paren prec op_prec =     if prec &gt; op_prec then Format.fprintf ppf "@])"     else Format.fprintf ppf "@]" in   let rec print prec exp =     match exp with     | Const c -&gt; Format.fprintf ppf "%.2f" c     | Var v -&gt; Format.fprintf ppf "%s" v     | Sum(f, g) -&gt;       open_paren prec 0;       print 0 f; Format.fprintf ppf "@ +@ "; print 0 g;       close_paren prec 0     | Diff(f, g) -&gt;       open_paren prec 0;       print 0 f; Format.fprintf ppf "@ -@ "; print 1 g;       close_paren prec 0     | Prod(f, g) -&gt;       open_paren prec 2;       print 2 f; Format.fprintf ppf "@ *@ "; print 2 g;       close_paren prec 2     | Quot(f, g) -&gt;       open_paren prec 2;       print 2 f; Format.fprintf ppf "@ /@ "; print 3 g;       close_paren prec 2   in   print 0 exp</code></p>
<p>And for tracing, we define a specialized evaluator
<code>eval_1_2</code> with the environment baked in (so the trace
focuses on the expression structure):</p>
<p><code>ocaml env=ch3 let rec eval_1_2 exp =   match exp with   | Const c -&gt; c   | Var v -&gt;     (try List.assoc v env with Not_found -&gt; raise (Unbound_variable v))   | Sum(f, g) -&gt; eval_1_2 f +. eval_1_2 g   | Diff(f, g) -&gt; eval_1_2 f -. eval_1_2 g   | Prod(f, g) -&gt; eval_1_2 f *. eval_1_2 g   | Quot(f, g) -&gt; eval_1_2 f /. eval_1_2 g</code></p>
<p>In the toplevel, you can now install the printer and trace the
evaluation:</p>
<p><code>ocaml skip # #install_printer print_expr;; # #trace eval_1_2;; # eval_1_2 example;;</code></p>
<p>The trace output makes the recursive structure of the computation
very concrete:</p>
<pre><code>eval_1_2 &lt;-- 3.00 * x + 2.00 * y + x * x * y
  eval_1_2 &lt;-- x * x * y
    eval_1_2 &lt;-- y
    eval_1_2 --&gt; 2.
    eval_1_2 &lt;-- x * x
      eval_1_2 &lt;-- x
      eval_1_2 --&gt; 1.
      eval_1_2 &lt;-- x
      eval_1_2 --&gt; 1.
    eval_1_2 --&gt; 1.
  eval_1_2 --&gt; 2.
  eval_1_2 &lt;-- 3.00 * x + 2.00 * y
    eval_1_2 &lt;-- 2.00 * y
      eval_1_2 &lt;-- y
      eval_1_2 --&gt; 2.
      eval_1_2 &lt;-- 2.00
      eval_1_2 --&gt; 2.
    eval_1_2 --&gt; 4.
    eval_1_2 &lt;-- 3.00 * x
      eval_1_2 &lt;-- x
      eval_1_2 --&gt; 1.
      eval_1_2 &lt;-- 3.00
      eval_1_2 --&gt; 3.
    eval_1_2 --&gt; 3.
  eval_1_2 --&gt; 7.
eval_1_2 --&gt; 9.
- : float = 9.</code></pre>
<p>The arrows <code>&lt;--</code> and <code>--&gt;</code> show function
calls and returns, respectively. Each level of indentation represents a
nested function call. These indentation levels correspond to
<strong>stack frames</strong>—the runtime structures that store the
state of each function call. Each time <code>eval_1_2</code> is called
recursively, a new stack frame is created to remember where to return
and what computation remains.</p>
<p>The final result is <span class="math inline">3 \cdot 1 + 2 \cdot 2 +
1 \cdot 1 \cdot 2 = 3 + 4 + 2 = 9</span>, as expected.</p>
<p>This trace visualization brings us to an important question: what
happens when we have very deep recursion? This leads us to our next
topic.</p>
<h3 id="tail-calls-and-tail-recursion">3.4 Tail Calls and Tail
Recursion</h3>
<p>The call stack is finite, and each recursive call typically adds a
new frame to it. This means that deeply recursive functions can exhaust
the stack and crash—a notorious problem known as “stack overflow.”
Fortunately, functional language implementations have a trick to avoid
this problem in many cases.</p>
<p>Excuse me for not formally defining what a <em>function call</em> is…
Computers normally evaluate programs by creating <strong>stack
frames</strong> on the call stack for each function call. A stack frame
stores the local variables, the return address (where to continue after
the function returns), and other bookkeeping information. The trace in
the previous section illustrates this: each level of indentation
represents a new stack frame.</p>
<h4 id="what-is-a-tail-call">What is a Tail Call?</h4>
<p>The key insight is that not all function calls require a new stack
frame. A <strong>tail call</strong> is a function call that is performed
as the very last action when computing a function—there is nothing more
to do after the call returns except to return that value. For
example:</p>
<p><code>ocaml skip let f x = g (x + 1)</code></p>
<p>The call to <code>g</code> is a tail call. Once <code>g</code>
returns some value, <code>f</code> simply returns that same value—no
further computation is needed.</p>
<p>In contrast:</p>
<p><code>ocaml skip let f x = 1 + g x</code></p>
<p>The call to <code>g</code> is <em>not</em> a tail call. After
<code>g</code> returns, we still need to add 1 to the result before
<code>f</code> can return. This means we need to remember to do the
addition, which requires keeping the stack frame around.</p>
<h4 id="tail-call-optimization">Tail Call Optimization</h4>
<p>Functional language compilers (including OCaml’s) recognize tail
calls and optimize them by performing <strong>tail call
optimization</strong> (TCO). Instead of creating a new stack frame, the
compiler generates code that reuses the current frame by performing a
“jump” to the called function. This means tail calls use constant stack
space, no matter how deep the call chain goes.</p>
<p>This optimization is not just a nice-to-have; it is
<em>essential</em> for functional programming. Without TCO, many natural
recursive algorithms would be impractical because they would overflow
the stack on moderately large inputs.</p>
<h4 id="tail-recursive-functions">Tail Recursive Functions</h4>
<p>A function is <strong>tail recursive</strong> if all of its recursive
calls (including calls to mutually recursive functions it depends on)
are tail calls.</p>
<p>Writing tail recursive functions requires a shift in thinking.
Instead of building up the result as recursive calls return, we build it
up as we <em>make</em> the calls. This typically requires an extra
<strong>accumulator</strong> argument that carries the partial result
through the recursion.</p>
<p>The key insight is that with an accumulator, results are computed in
“reverse order”—we do the work while climbing <em>into</em> the
recursion (making calls) rather than while climbing <em>out</em>
(returning from calls).</p>
<h4 id="example-counting">Example: Counting</h4>
<p>Let us see this in action with a simple counting function. Compare
these two versions:</p>
<p><code>ocaml env=ch3 let rec count n =   if n &lt;= 0 then 0 else 1 + (count (n-1))</code></p>
<p>This version is <em>not</em> tail recursive. Look at the recursive
case: after <code>count (n-1)</code> returns, we still need to add 1 to
the result. Each recursive call must remember to do this addition,
consuming a stack frame.</p>
<p>Now compare with the tail recursive version:</p>
<p><code>ocaml env=ch3 let rec count_tcall acc n =   if n &lt;= 0 then acc else count_tcall (acc+1) (n-1)</code></p>
<p>Here, the recursive call <code>count_tcall (acc+1) (n-1)</code> is
the very last thing the function does—its result becomes our result
directly. The accumulator <code>acc</code> carries the running count: we
add 1 to it <em>before</em> the recursive call rather than
<em>after</em> it returns. To count to 1000000, we call
<code>count_tcall 0 1000000</code>.</p>
<h4 id="example-building-lists">Example: Building Lists</h4>
<p>The counting example does not really show the practical impact
because the numbers are so small. Let us see a more dramatic example
with lists:</p>
<p><code>ocaml env=ch3 let rec unfold n = if n &lt;= 0 then [] else n :: unfold (n-1)</code></p>
<p>This function builds a list counting down from <code>n</code> to 1.
It is not tail recursive because after the recursive call
<code>unfold (n-1)</code> returns, we must cons <code>n</code> onto the
front of the result.</p>
<p>```ocaml skip # unfold 100000;; - : int list = [100000; 99999; 99998;
99997; …]</p>
<h1 id="unfold-1000000">unfold 1000000;;</h1>
<p>Stack overflow during evaluation (looping recursion?).</p>
<pre><code>
With 100,000 elements, it works. But with a million elements, we run out of stack space and the program crashes! This is a serious problem for practical programming.

Now consider the tail-recursive version:

```ocaml env=ch3
let rec unfold_tcall acc n =
  if n &lt;= 0 then acc else unfold_tcall (n::acc) (n-1)</code></pre>
<p>The accumulator <code>acc</code> collects the list as we go. We cons
each element onto the accumulator <em>before</em> the recursive call.
However, there is a catch: because we are building the list as we
descend into the recursion (rather than as we return), the list comes
out in reverse order:</p>
<p>```ocaml skip # unfold_tcall [] 100000;; - : int list = [1; 2; 3; 4;
5; 6; 7; 8; 9; 10; 11; 12; …]</p>
<h1 id="unfold_tcall-1000000">unfold_tcall [] 1000000;;</h1>
<ul>
<li>: int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; …]</li>
</ul>
<pre><code>
The tail-recursive version handles a million elements effortlessly. The trade-off is that we get `[1; 2; 3; ...]` instead of `[1000000; 999999; ...]`. If we need the original order, we could reverse the result at the end (which is an O(n) operation but uses only constant stack space).

#### A Challenge: Tree Depth

Not all recursive functions can be easily converted to tail recursive form. Consider this problem: can we find the depth of a binary tree using a tail-recursive function?

```ocaml env=ch3
type btree = Tip | Node of int * btree * btree</code></pre>
<p>Here is the natural recursive approach:</p>
<p><code>ocaml env=ch3 let rec depth tree = match tree with   | Tip -&gt; 0   | Node(_, left, right) -&gt; 1 + max (depth left) (depth right)</code></p>
<p>This is not tail recursive: after both recursive calls return, we
still need to compute <code>1 + max ...</code>. The fundamental
challenge is that we have <em>two</em> recursive calls that we need to
make. A simple accumulator will not work—we cannot proceed with one
subtree until we know the result of the other.</p>
<p>This seems like an impossible situation. How can we make a function
tail recursive when it inherently needs to explore two branches? The
answer involves a technique called <em>continuation passing style</em>,
which we explore in the next section.</p>
<h4 id="note-on-lazy-languages">Note on Lazy Languages</h4>
<p>The issue of tail recursion is more nuanced for <strong>lazy</strong>
programming languages like Haskell. In a lazy language, expressions are
only evaluated when their values are actually needed. The cons operation
<code>(:)</code> does not immediately evaluate its arguments—it just
builds a “promise” to compute them later.</p>
<p>This means that building a list with <code>n : unfold (n-1)</code>
does not consume stack space in the same way as in OCaml. The
<code>unfold (n-1)</code> is not evaluated immediately; it is just
stored as an unevaluated expression (called a “thunk”). Stack space is
only consumed later, when you actually traverse the list. This gives
lazy languages different performance characteristics and trade-offs.</p>
<h3 id="first-encounter-of-continuation-passing-style">3.5 First
Encounter of Continuation Passing Style</h3>
<p>We can solve the tree depth problem using <strong>Continuation
Passing Style (CPS)</strong>. This is a powerful technique that
transforms programs in a surprising way: instead of returning values,
functions receive an extra argument—a <em>continuation</em>—that tells
them what to do with their result.</p>
<p>The key idea is to postpone doing actual work until the very last
moment by passing around a continuation—a function that represents “what
to do next with this result.”</p>
<p>```ocaml env=ch3 let rec depth_cps tree k = match tree with | Tip
-&gt; k 0 | Node(_, left, right) -&gt; depth_cps left (fun dleft -&gt;
depth_cps right (fun dright -&gt; k (1 + (max dleft dright))))</p>
<p>let depth tree = depth_cps tree (fun d -&gt; d)</p>
<pre><code>
Let us understand how this works step by step:

1. **The continuation parameter:** The function takes an extra parameter `k`, called the **continuation**. Instead of returning a value directly, `depth_cps` will call `k` with its result. You can think of `k` as meaning &quot;and then do this with the answer.&quot;

2. **The base case (`Tip`):** When we reach a leaf, the depth is 0. Instead of returning 0, we call `k 0`---&quot;give 0 to whoever is waiting for our answer.&quot;

3. **The recursive case (`Node`):** This is where CPS shines. We need to compute depths of both subtrees and combine them. Here is how we do it:
   - First, recursively compute the depth of the left subtree. But instead of waiting for the result, we pass a continuation: `fun dleft -&gt; ...`
   - This continuation says &quot;when you have the left depth (call it `dleft`), then...&quot;
   - ...compute the depth of the right subtree, passing another continuation: `fun dright -&gt; ...`
   - This inner continuation says &quot;when you have the right depth (call it `dright`), then...&quot;
   - ...finally call the original continuation `k` with the combined result `1 + max dleft dright`

4. **The wrapper function:** To use `depth_cps`, we need to provide an initial continuation. We pass the identity function `fun d -&gt; d`, which just returns whatever it receives. This is the &quot;final consumer&quot; of the result.

The magic is that *every recursive call is now a tail call*! Look carefully: `depth_cps left (...)` is the last thing the function does in that branch---everything else is inside the continuation, which will be called later.

Where does the &quot;pending work&quot; go? Instead of being stored on the call stack, it is captured in the continuation closures. These closures are allocated on the heap. We have traded stack space for heap space.

**Important caveat:** This does not completely solve the stack overflow problem---we are just moving the problem from the stack to the heap. For very deep trees, the continuation closures can grow very large, potentially exhausting memory. True solutions for extreme cases involve techniques like *trampolining* (returning control to a loop) or using explicit data structures to represent the pending work. Nevertheless, CPS is often more space-efficient than direct recursion, and it is a fundamental technique that appears throughout functional programming.

We will encounter CPS again when studying monads and advanced control flow, where it provides the foundation for powerful abstractions.

### 3.6 Exercises

These exercises will help you practice the concepts from this chapter: function composition, reduction semantics, tail recursion, and continuation passing style.

**Exercise 1: Tree Traversals**

By &quot;traverse a tree&quot; below we mean: write a function that takes a tree and returns a list of values in the nodes of the tree. Use the `btree` type defined earlier.

1. Write a function (of type `btree -&gt; int list`) that traverses a binary tree in **prefix order** (also called *preorder*)---first the value stored in a node, then values in all nodes to the left, then values in all nodes to the right.

2. Write a traversal in **infix order** (also called *inorder*)---first values in all nodes to the left, then the value stored in the node, then values in all nodes to the right. For a binary search tree, this would give you the elements in sorted order.

3. Write a traversal in **breadth-first order** (also called *level order*)---visit all nodes at depth 0, then all nodes at depth 1, and so on. Hint: you will need an auxiliary data structure (a queue) to keep track of nodes to visit.

**Exercise 2: CPS Transformation**

Turn the function from Exercise 1 (prefix or infix traversal) into continuation passing style. Compare the structure of your CPS version to the original. What are the trade-offs?

**Exercise 3: Tree Derivatives Revisited**

Do the homework from the end of Chapter 2: write `btree_deriv_at` that takes a predicate over integers and a `btree`, and builds a `btree_deriv` whose &quot;hole&quot; is in the first position (using your chosen traversal order) for which the predicate returns true.

**Exercise 4: Expression Simplification**

Write a function `simplify: expression -&gt; expression` that simplifies symbolic expressions, so that for example the result of `simplify (deriv exp dv)` looks more like what a human would get computing the derivative of `exp` with respect to `dv`.

Some simplifications to consider:
- $0 + x = x$ and $x + 0 = x$
- $0 \cdot x = 0$ and $x \cdot 0 = 0$
- $1 \cdot x = x$ and $x \cdot 1 = x$
- $x - 0 = x$
- $x / 1 = x$

Approach this in two steps:
1. Write a `simplify_once` function that performs a single &quot;pass&quot; of simplification over the expression tree.
2. Wrap it using a general `fixpoint` function that performs an operation until a **fixed point** is reached: given $f$ and $x$, it computes $f^n(x)$ such that $f^n(x) = f^{n+1}(x)$ (i.e., applying $f$ one more time does not change the result).

Why do we need iteration to a fixed point rather than a single pass?

**Exercise 5: Sorting Algorithms**

Write two sorting algorithms working on lists: merge sort and quicksort.

1. **Merge sort** splits the list roughly in half, sorts the parts recursively, and merges the sorted parts into the sorted result. You will need a helper function to merge two sorted lists.

2. **Quicksort** splits the list into elements smaller than and greater-than-or-equal-to the first element (the &quot;pivot&quot;), sorts the parts recursively, and concatenates them.

Which of these algorithms can be implemented in a tail-recursive manner? What about the helper functions (merge, partition)?


## Chapter 4: Functions

*Programming in untyped lambda-calculus*

**In this chapter, you will:**

- Rehearse reduction-by-hand on a non-trivial recursive program
- Learn the syntax and $\beta$-reduction rules of the untyped lambda-calculus
- Encode booleans, pairs, naturals, lists, and trees using functions alone
- Understand recursion via fixpoint combinators (and how evaluation order matters)

This chapter explores the theoretical foundations of functional programming through the untyped lambda-calculus. We embark on a fascinating journey that reveals a surprising truth: every computation can be expressed using nothing but functions. No numbers, no booleans, no data structures---just functions all the way down.

We begin with a review of computation by hand using our reduction semantics, then introduce the lambda-calculus notation and show how to encode fundamental data types---booleans, pairs, and natural numbers---using only functions. The chapter concludes with an examination of recursion through fixpoint combinators and practical considerations for avoiding infinite loops in eager evaluation.

**References:**

- &quot;Introduction to Lambda Calculus&quot; by Henk Barendregt and Erik Barendsen
- &quot;Lecture Notes on the Lambda Calculus&quot; by Peter Selinger

### 4.1 Review: Computation by Hand

Before diving into the lambda-calculus, let us work through a complete example of evaluation using the reduction rules from Chapter 3. Computing a larger, recursive program by hand will solidify our understanding of how computation proceeds step by step and prepare us for the more abstract setting of lambda-calculus.

Recall that we use `fix` instead of `let rec` to simplify our rules for recursion. Also remember our syntactic conventions: `fun x y -&gt; e` stands for `fun x -&gt; (fun y -&gt; e)`, and so forth.

Consider the following recursive `length` function applied to a two-element list:

```ocaml skip
let rec fix f x = f (fix f) x

type int_list = Nil | Cons of int * int_list

let length =
  fix (fun f l -&gt;
    match l with
    | Nil -&gt; 0
    | Cons (_x, xs) -&gt; 1 + f xs)
in
length (Cons (1, (Cons (2, Nil))))</code></pre>
<p>Let us trace through this computation step by step. First, we
eliminate the <code>let ... in ...</code> binding for
<code>length</code>:</p>
<p><span class="math display">\texttt{let } x = v \texttt{ in } a
\rightsquigarrow a[x := v]</span></p>
<p>This gives us:</p>
<pre><code>fix (fun f l -&gt;
    match l with
      | Nil -&gt; 0
      | Cons (x, xs) -&gt; 1 + f xs) (Cons (1, (Cons (2, Nil))))</code></pre>
<p>Next, we apply the <code>fix</code> rule:</p>
<p><span class="math display">\texttt{fix}^2 \; v_1 \; v_2
\rightsquigarrow v_1 \; (\texttt{fix}^2 \; v_1) \; v_2</span></p>
<p>This unfolds to:</p>
<pre><code>(fun f l -&gt;
    match l with
      | Nil -&gt; 0
      | Cons (x, xs) -&gt; 1 + f xs)
    (fix (fun f l -&gt;
      match l with
        | Nil -&gt; 0
        | Cons (x, xs) -&gt; 1 + f xs))
    (Cons (1, (Cons (2, Nil))))</code></pre>
<p>Function application reduces according to:</p>
<p><span class="math display">(\texttt{fun } x \texttt{ -&gt; } a) \; v
\rightsquigarrow a[x := v]</span></p>
<p>After substituting both <code>f</code> and <code>l</code>, we
get:</p>
<pre><code>(match Cons (1, (Cons (2, Nil))) with
    | Nil -&gt; 0
    | Cons (x, xs) -&gt; 1 + (fix (fun f l -&gt;
      match l with
        | Nil -&gt; 0
        | Cons (x, xs) -&gt; 1 + f xs)) xs)</code></pre>
<p>Pattern matching against a non-matching constructor moves to the next
branch:</p>
<p><span class="math display">
\begin{aligned}
&amp; \texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{ with} \\
&amp; C_2^n(p_1, \ldots, p_k) \texttt{ -&gt; } a \texttt{ | } pm
\rightsquigarrow \texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{ with }
pm
\end{aligned}
</span></p>
<p>Pattern matching against a matching constructor performs
substitution:</p>
<p><span class="math display">
\begin{aligned}
&amp; \texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{ with} \\
&amp; C_1^n(x_1, \ldots, x_n) \texttt{ -&gt; } a \texttt{ | } \ldots
\rightsquigarrow a[x_1 := v_1; \ldots; x_n := v_n]
\end{aligned}
</span></p>
<p>After matching and substitution:</p>
<pre><code>1 + (fix (fun f l -&gt;
      match l with
        | Nil -&gt; 0
        | Cons (x, xs) -&gt; 1 + f xs)) (Cons (2, Nil))</code></pre>
<p>Continuing the evaluation, we apply <code>fix</code> again and work
through the pattern match for <code>Cons (2, Nil)</code>, eventually
reaching:</p>
<pre><code>1 + (1 + (fix (fun f l -&gt;
             match l with
               | Nil -&gt; 0
               | Cons (x, xs) -&gt; 1 + f xs)) Nil)</code></pre>
<p>One more unfolding and pattern match against <code>Nil</code>
gives:</p>
<pre><code>1 + (1 + 0)</code></pre>
<p>Finally, applying the built-in addition:</p>
<p><span class="math display">f^n \; v_1 \; \ldots \; v_n
\rightsquigarrow f(v_1, \ldots, v_n)</span></p>
<p>We obtain the result: <code>2</code>.</p>
<h3 id="language-and-rules-of-the-untyped-lambda-calculus">4.2 Language
and Rules of the Untyped Lambda-Calculus</h3>
<p>The lambda-calculus, introduced by Alonzo Church in the 1930s, is a
minimal formal system for expressing computation. It may seem surprising
that such a stripped-down language can be computationally complete, but
that is precisely what we will demonstrate in this chapter. To work with
lambda-calculus, we first simplify our language in several ways:</p>
<ol type="1">
<li><p><strong>Forget about types.</strong> In pure lambda-calculus,
there is no type system constraining which terms can be combined. Any
function can be applied to any argument—including itself!</p></li>
<li><p><strong>Introduce notation.</strong> We write <span
class="math inline">\lambda x.a</span> for <code>fun x -&gt; a</code>,
and <span class="math inline">\lambda xy.a</span> for
<code>fun x y -&gt; a</code>, and so forth. This notation is more
compact and traditional in the literature.</p></li>
<li><p><strong>Reduce to essentials.</strong> We keep only functions
(lambda abstractions) and variables—no constructors, no built-in
primitives. Everything else will be <em>encoded</em> using
functions.</p></li>
</ol>
<p>The core reduction rule of lambda-calculus is called <strong><span
class="math inline">\beta</span>-reduction</strong>:</p>
<p><span class="math display">(\texttt{fun } x \texttt{ -&gt; } a_1) \;
a_2 \rightsquigarrow a_1[x := a_2]</span></p>
<p>Note that this rule is more general than the one we use for OCaml
evaluation. In our OCaml semantics, we require the argument to be a
value: <span class="math inline">(\texttt{fun } x \texttt{ -&gt; } a) \;
v \rightsquigarrow a[x := v]</span>. The general <span
class="math inline">\beta</span>-reduction rule allows substituting any
expression, not just values.</p>
<p>Lambda-calculus also uses <strong><span
class="math inline">\alpha</span>-conversion</strong> (bound variable
renaming), or equivalent techniques, to avoid <strong>variable
capture</strong>—the unintended binding of free variables during
substitution. We will explore the implications of <span
class="math inline">\beta</span>-reduction more deeply in the chapter on
laziness.</p>
<p>Why is <span class="math inline">\beta</span>-reduction more general
than our evaluation rule? Consider the expression <span
class="math inline">(\lambda x. x) \; ((\lambda y. y) \; z)</span>. With
<span class="math inline">\beta</span>-reduction, we could reduce the
outer application first, obtaining <span class="math inline">((\lambda
y. y) \; z)</span>. Our evaluation rule would require first reducing the
argument to a value—but here <code>z</code> is a free variable, not a
value, so we would be stuck!</p>
<p>This example is intentionally an <em>open term</em> (it has a free
variable <code>z</code>): in lambda-calculus we often reason about open
terms up to <span class="math inline">\beta</span>-equivalence, while
programming-language evaluation is usually defined for <em>closed</em>
programs.</p>
<h3 id="booleans">4.3 Booleans</h3>
<p>Alonzo Church originally introduced lambda-calculus as a foundation
for logic, seeking to encode logical reasoning in a purely computational
form. There are multiple ways to encode various sorts of data in
lambda-calculus, though not all of them work well in a typed setting—the
straightforward encode/decode functions may not type-check for some
encodings.</p>
<p>The key insight behind the <strong>Church encoding</strong> of
booleans is to represent truth values as <em>selector functions</em>.
Think about what a boolean fundamentally does: it chooses between two
alternatives. So we define:</p>
<ul>
<li><strong>True</strong> selects the first argument:
<code>c_true</code> <span class="math inline">= \lambda xy.x</span></li>
<li><strong>False</strong> selects the second argument:
<code>c_false</code> <span class="math inline">= \lambda
xy.y</span></li>
</ul>
<p>In OCaml syntax:</p>
<p><code>ocaml env=ch4 let c_true = fun x y -&gt; x   (* "True" is projection on the first argument *) let c_false = fun x y -&gt; y  (* And "false" on the second argument *)</code></p>
<p>Once we have booleans as selectors, logical operations become
elegant. Logical conjunction can be defined as:</p>
<p><span class="math display">\texttt{c\_and} = \lambda xy. x \; y \;
\texttt{c\_false}</span></p>
<p>The logic behind this definition is beautifully simple: we apply
<code>x</code> (which is a selector) to two arguments. If <code>x</code>
is true, it selects its first argument, which is <code>y</code>—so the
result is true only if both <code>x</code> and <code>y</code> are true.
If <code>x</code> is false, it selects its second argument,
<code>c_false</code>, and returns false immediately without even looking
at <code>y</code>.</p>
<p><code>ocaml env=ch4 let c_and = fun x y -&gt; x y c_false  (* If one is false, then return false *)</code></p>
<p>Let us verify this works. For <code>c_and c_true c_true</code>:</p>
<p><span class="math display">(\lambda xy. x \; y \; \texttt{c\_false})
\; (\lambda xy.x) \; (\lambda xy.x)</span></p>
<p>reduces to:</p>
<p><span class="math display">(\lambda xy.x) \; (\lambda xy.x) \;
\texttt{c\_false}</span></p>
<p>which gives us <span class="math inline">\lambda xy.x</span> =
<code>c_true</code>. You can verify that for any other combination
involving <code>c_false</code>, the result is <code>c_false</code>.</p>
<p>To verify our encodings in OCaml, we need encode and decode
functions. The decoder works by applying our Church boolean to the
actual OCaml values <code>true</code> and <code>false</code>:</p>
<p><code>ocaml env=ch4 let encode_bool b = if b then c_true else c_false let decode_bool c = (Obj.magic c) true false  (* Don't enforce type on c *)</code></p>
<p><strong>Exercise:</strong> Define <code>c_or</code> and
<code>c_not</code> yourself! Hint: think about what <code>c_or</code>
should return when the first argument is true, and when it is false. For
<code>c_not</code>, consider that a boolean is a function that selects
between two arguments.</p>
<h3 id="if-then-else-and-pairs">4.4 If-then-else and Pairs</h3>
<p>From now on, we will use OCaml syntax for our lambda-calculus
programs. This makes it easier to experiment with our encodings in the
toplevel.</p>
<p>An important observation is that our encoded booleans already
implement conditional selection:</p>
<p><code>ocaml env=ch4 let if_then_else b t e = b t e  (* Booleans select the branch! *)</code></p>
<p>Wait—is <code>if_then_else</code> “just” the identity function? Up to
<span class="math inline">\eta</span>-equivalence, yes:
<code>fun b -&gt; b</code> and <code>fun b t e -&gt; b t e</code> are
the same function. Since <code>c_true</code> returns its first argument
and <code>c_false</code> returns its second,
<code>if_then_else b t e</code> simply applies <code>b</code> to the two
branches. The boolean <em>is</em> the conditional.</p>
<p>Remember to play with these functions in the toplevel to build
intuition. Try expressions like
<code>if_then_else c_true "yes" "no"</code> and see what happens.</p>
<h4 id="pairs">Pairs</h4>
<p>Pairs (ordered tuples of two elements) can be encoded using a similar
idea. The key insight is that a pair needs to “remember” two values and
provide them when asked. We can achieve this by creating a function that
holds onto both values and waits for a selector to choose between
them:</p>
<p><code>ocaml env=ch4 let c_pair m n = fun x -&gt; x m n  (* We couple things *) let c_first = fun p -&gt; p c_true  (* by passing them together *) let c_second = fun p -&gt; p c_false  (* Check that it works! *)</code></p>
<p>A pair is a function that, when given a selector, applies that
selector to both components. To extract the first component, we pass
<code>c_true</code> (which selects the first argument); to extract the
second, we pass <code>c_false</code>. Verify for yourself that
<code>c_first (c_pair a b)</code> reduces to <code>a</code>!</p>
<p>For verification:</p>
<p><code>ocaml env=ch4 let encode_pair enc_fst enc_snd (a, b) =   c_pair (enc_fst a) (enc_snd b) let decode_pair de_fst de_snd c = c (fun x y -&gt; de_fst x, de_snd y) let decode_bool_pair c = decode_pair decode_bool decode_bool c</code></p>
<p>We can define larger tuples in the same manner:
<code>let c_triple l m n = fun x -&gt; x l m n</code></p>
<h3 id="pair-encoded-natural-numbers">4.5 Pair-Encoded Natural
Numbers</h3>
<p>Now we come to encoding numbers—a crucial test of whether functions
alone can represent all data. Our first encoding of natural numbers uses
nested pairs. The representation is based on the depth of nested pairs
whose rightmost leaf is the identity function <span
class="math inline">\lambda x.x</span> and whose left elements are
<code>c_false</code>.</p>
<p>```ocaml env=ch4 let pn0 = fun x -&gt; x (* Start with the identity
function <em>) let pn_succ n = c_pair c_false n (</em> Stack another
pair *)</p>
<p>let pn_pred = fun x -&gt; x c_false (* Extract the nested number
<em>) let pn_is_zero = fun x -&gt; x c_true (</em> Check if it’s the
base case *)</p>
<pre><code>
The number 0 is represented as the identity function. The number 1 is `c_pair c_false pn0`, the number 2 is `c_pair c_false (c_pair c_false pn0)`, and so on. Think of it as a stack of pairs, where the height of the stack represents the number.

How do `pn_pred` and `pn_is_zero` work? Let us think through this carefully:
- The identity function `pn0`, when applied to any argument, returns that argument.
- A successor `c_pair c_false n` is a function waiting for a selector; applying it to `c_false` selects the second component (the predecessor), while applying it to `c_true` selects the first component (`c_false`).

So `pn_is_zero` applies the number to `c_true`:
- For `pn0`, we get `c_true` back (since `pn0` is the identity)---the number is zero!
- For any successor, we get `c_false` back (the first component of the pair)---the number is not zero!

We program in untyped lambda-calculus as an exercise, and we need encoding/decoding to verify our work. Since these encodings do not type-check cleanly in OCaml, using `Obj.magic` to bypass the type system for encoding/decoding is &quot;fair game&quot;:

```ocaml env=ch4
let rec encode_pnat n =                (* We use Obj.magic to forget types *)
  if n &lt;= 0 then Obj.magic pn0
  else pn_succ (Obj.magic (encode_pnat (n-1)))  (* Disregarding types, *)
let rec decode_pnat pn =               (* these functions are straightforward! *)
  if decode_bool (pn_is_zero pn) then 0
  else 1 + decode_pnat (pn_pred (Obj.magic pn))</code></pre>
<p>Needless to say, <code>Obj.magic</code> is unsafe and should not be
used in real code; here it is only a convenient bridge from untyped
lambda-terms to OCaml so we can test our encodings.</p>
<h3 id="church-numerals">4.6 Church Numerals</h3>
<p>Do you remember our function <code>power f n</code> from Chapter 3
that composed a function with itself <code>n</code> times? We will use a
similar idea for a different, and historically important, representation
of numbers.</p>
<p><strong>Church numerals</strong> represent a natural number <span
class="math inline">n</span> as a function that applies its first
argument <span class="math inline">n</span> times to its second
argument:</p>
<p><code>ocaml env=ch4 let cn0 = fun f x -&gt; x        (* The same as c_false *) let cn1 = fun f x -&gt; f x      (* Behaves like identity when f = id *) let cn2 = fun f x -&gt; f (f x) let cn3 = fun f x -&gt; f (f (f x))</code></p>
<p>This is the original Alonzo Church encoding, and it is remarkably
elegant. The number <span class="math inline">n</span> is represented as
<span class="math inline">\lambda fx. f^n(x)</span>, where <span
class="math inline">f^n</span> denotes <span
class="math inline">n</span>-fold composition. A number literally
<em>is</em> the act of doing something <span
class="math inline">n</span> times!</p>
<p>Notice that <code>cn0</code> is the same as <code>c_false</code>—zero
applications of <code>f</code> just returns <code>x</code>.</p>
<p>The successor function adds one more application of
<code>f</code>:</p>
<p><code>ocaml env=ch4 let cn_succ = fun n f x -&gt; f (n f x)</code></p>
<p><strong>Exercise:</strong> Define addition, multiplication, and
comparing to zero for Church numerals. Also try to define the
predecessor function “-1”.</p>
<p>It turns out even Alonzo Church could not define predecessor right
away! The story goes that his student Stephen Kleene figured it out
while at the dentist. Try to make some progress on addition and
multiplication first (they are not too hard), and then attempt
predecessor before looking at the solution below.</p>
<p>```ocaml env=ch4 let (-|) f g x = f (g x) (* Backward composition
operator *)</p>
<p>let rec encode_cnat n f = if n &lt;= 0 then (fun x -&gt; x) else f -|
encode_cnat (n-1) f let decode_cnat n = n ((+) 1) 0 let cn7 f x =
encode_cnat 7 f x (* We need to eta-expand these definitions <em>) let
cn13 f x = encode_cnat 13 f x (</em> for type-system reasons <em>)
(</em> (because OCaml allows side-effects) <em>) let cn_add = fun n m f
x -&gt; n f (m f x) (</em> Put n of f in front <em>) let cn_mult = fun n
m f -&gt; n (m f) (</em> Repeat n times <em>) (</em> putting m of f in
front <em>) let cn_prev n = fun f x -&gt; (</em> A Church numeral is an
n-step iterator. Predecessor is tricky because we cannot “subtract an
iteration”; instead we build a small state transformer that delays the
use of [f] and then skips the first step. *) n (fun g h -&gt; h (g f))
(fun _z -&gt; x) (fun z -&gt; z)</p>
<pre><code>
Addition is intuitive: to add $n$ and $m$, we first apply `f` $m$ times (giving us `m f x`), then apply `f` $n$ more times. Multiplication is even more clever: we apply the operation &quot;apply `f` $m$ times&quot; $n$ times, which computes $m \times n$ applications of `f`.

The predecessor function is ingenious and worth studying carefully. The challenge is that Church numerals only know how to apply `f` more times, not fewer. Kleene&#39;s insight was to build up a chain of functions that, when &quot;started&quot; with the identity, yields $n-1$ applications of `f`. The key is to delay the actual application of `f` and skip the first one.

`cn_is_zero` is left as an exercise. Hint: what happens when you apply zero to a function that always returns `c_false` and start with `c_true`?

#### Tracing `cn_prev cn3`

The predecessor function is tricky enough that it is worth tracing through a complete example. Let us trace through `decode_cnat (cn_prev cn3)` to see how it computes 2 from 3:

$$\rightsquigarrow^*$$
</code></pre>
<p>(cn_prev cn3) ((+) 1) 0</p>
<pre><code>
$$\rightsquigarrow^*$$
</code></pre>
<p>(fun f x -&gt; cn3 (fun g h -&gt; h (g f)) (fun _z -&gt; x) (fun z
-&gt; z)) ((+) 1) 0</p>
<pre><code>
$$\rightsquigarrow^*$$
</code></pre>
<p>((fun f x -&gt; f (f (f x))) (fun g h -&gt; h (g ((+) 1))) (fun z
-&gt; 0) (fun z -&gt; z))</p>
<pre><code>
$$\rightsquigarrow^*$$
</code></pre>
<p>((fun g h -&gt; h (g ((+) 1))) ((fun g h -&gt; h (g ((+) 1))) ((fun g
h -&gt; h (g ((+) 1))) (fun z -&gt; 0)))) (fun z -&gt; z))</p>
<pre><code>
$$\rightsquigarrow^*$$
</code></pre>
<p>((fun z -&gt; z) (((fun g h -&gt; h (g ((+) 1))) ((fun g h -&gt; h (g
((+) 1))) (fun z -&gt; 0)))) ((+) 1)))</p>
<pre><code>
$$\rightsquigarrow^*$$
</code></pre>
<p>(fun g h -&gt; h (g ((+) 1))) ((fun g h -&gt; h (g ((+) 1))) (fun z
-&gt; 0)) ((+) 1)</p>
<pre><code>
$$\rightsquigarrow^*$$
</code></pre>
<p>((+) 1) ((fun g h -&gt; h (g ((+) 1))) (fun z -&gt; 0) ((+) 1))</p>
<pre><code>
$$\rightsquigarrow^*$$
</code></pre>
<p>((+) 1) (((+) 1) ((fun z -&gt; 0) ((+) 1)))</p>
<pre><code>
$$\rightsquigarrow^*$$
</code></pre>
<p>((+) 1) (((+) 1) (0))</p>
<pre><code>
$$\rightsquigarrow^*$$
</code></pre>
<p>((+) 1) 1</p>
<pre><code>
$\rightsquigarrow^*$ `2`

### 4.7 Recursion: Fixpoint Combinators

We have seen how to encode data in lambda-calculus, but how do we encode *computation*, especially recursive computation? In lambda-calculus, there is no `let rec` or any built-in notion of a function referring to itself. Instead, recursion is achieved through **fixpoint combinators**---remarkable lambda terms that compute fixed points of functions.

#### Turing&#39;s Fixpoint Combinator

$$\Theta = (\lambda xy. y \; (x \; x \; y)) \; (\lambda xy. y \; (x \; x \; y))$$

Let us verify it computes fixed points. Define $N = \Theta F$:

$$
\begin{aligned}
N &amp;= \Theta F \\
&amp;= (\lambda xy. y \; (x \; x \; y)) \; (\lambda xy. y \; (x \; x \; y)) \; F \\
&amp;=_{\rightarrow\rightarrow} F \; ((\lambda xy. y \; (x \; x \; y)) \; (\lambda xy. y \; (x \; x \; y)) \; F) \\
&amp;= F \; (\Theta F) = F \; N
\end{aligned}
$$

So $N = F \; N$, meaning $N$ is a fixed point of $F$.

#### Curry&#39;s Fixpoint Combinator (Y Combinator)

$$\mathbf{Y} = \lambda f. (\lambda x. f \; (x \; x)) \; (\lambda x. f \; (x \; x))$$

$$
\begin{aligned}
N &amp;= \mathbf{Y} F \\
&amp;= (\lambda f. (\lambda x. f \; (x \; x)) \; (\lambda x. f \; (x \; x))) \; F \\
&amp;=_{\rightarrow} (\lambda x. F \; (x \; x)) \; (\lambda x. F \; (x \; x)) \\
&amp;=_{\rightarrow} F \; ((\lambda x. F \; (x \; x)) \; (\lambda x. F \; (x \; x))) \\
&amp;=_{\leftarrow} F \; ((\lambda f. (\lambda x. f \; (x \; x)) \; (\lambda x. f \; (x \; x))) \; F) \\
&amp;= F \; (\mathbf{Y} F) = F \; N
\end{aligned}
$$

#### Call-by-Value Fixpoint Combinator

$$\texttt{fix} = \lambda f&#39;. (\lambda fx. f&#39; \; (f \; f) \; x) \; (\lambda fx. f&#39; \; (f \; f) \; x)$$

$$
\begin{aligned}
N &amp;= \texttt{fix} \; F \\
&amp;= (\lambda f&#39;. (\lambda fx. f&#39; \; (f \; f) \; x) \; (\lambda fx. f&#39; \; (f \; f) \; x)) \; F \\
&amp;=_{\rightarrow} (\lambda fx. F \; (f \; f) \; x) \; (\lambda fx. F \; (f \; f) \; x) \\
&amp;=_{\rightarrow} \lambda x. F \; ((\lambda fx. F \; (f \; f) \; x) \; (\lambda fx. F \; (f \; f) \; x)) \; x \\
&amp;=_{\leftarrow} \lambda x. F \; ((\lambda f&#39;. (\lambda fx. f&#39; \; (f \; f) \; x) \; (\lambda fx. f&#39; \; (f \; f) \; x)) \; F) \; x \\
&amp;= \lambda x. F \; (\texttt{fix} \; F) \; x = \lambda x. F \; N \; x \\
&amp;=_{\eta} F \; N
\end{aligned}
$$

The lambda-terms we have seen above are **fixpoint combinators**---the means within lambda-calculus to perform recursion without any special recursive binding constructs.

#### The Problem with the First Two Combinators

What is the problem with Turing&#39;s and Curry&#39;s combinators in a practical programming language? Consider what happens when we try to evaluate $\Theta F$:

$$
\begin{aligned}
\Theta F &amp;\rightsquigarrow\rightsquigarrow F \; ((\lambda xy. y \; (x \; x \; y)) \; (\lambda xy. y \; (x \; x \; y)) \; F) \\
&amp;\rightsquigarrow\rightsquigarrow F \; (F \; ((\lambda xy. y \; (x \; x \; y)) \; (\lambda xy. y \; (x \; x \; y)) \; F)) \\
&amp;\rightsquigarrow\rightsquigarrow F \; (F \; (F \; ((\lambda xy. y \; (x \; x \; y)) \; (\lambda xy. y \; (x \; x \; y)) \; F))) \\
&amp;\rightsquigarrow\rightsquigarrow \ldots
\end{aligned}
$$

Recall the distinction between *expressions* and *values* from Chapter 3 on Computation. The reduction rule for lambda-calculus is meant to determine which expressions are considered &quot;equal&quot;---it is highly *non-deterministic*, while on a computer, computation needs to go one way or another.

Using the general reduction rule of lambda-calculus, for a recursive definition, it is always possible to find an infinite reduction sequence. Why? Because we can always choose to reduce the recursive call first, which generates another recursive call, and so on forever. This means a naive lambda-calculus compiler could legitimately generate infinite loops for all recursive definitions---which would not be very useful!

Therefore, we need more specific rules. Most languages use **call-by-value** (also called **eager** evaluation):

$$(\texttt{fun } x \texttt{ -&gt; } a) \; v \rightsquigarrow a[x := v]$$

The program *eagerly* computes arguments before starting to compute the function body. This is exactly the rule we introduced in the Computation chapter.

#### Call-by-Value Fixpoint Combinator in Action

What happens with the call-by-value fixpoint combinator?

$$
\begin{aligned}
\texttt{fix} \; F &amp;\rightsquigarrow (\lambda fx. F \; (f \; f) \; x) \; (\lambda fx. F \; (f \; f) \; x) \\
&amp;\rightsquigarrow \lambda x. F \; ((\lambda fx. F \; (f \; f) \; x) \; (\lambda fx. F \; (f \; f) \; x)) \; x
\end{aligned}
$$

The computation stops because we use the rule $(\texttt{fun } x \texttt{ -&gt; } a) \; v \rightsquigarrow a[x := v]$ rather than $(\texttt{fun } x \texttt{ -&gt; } a_1) \; a_2 \rightsquigarrow a_1[x := a_2]$. The expression inside the lambda is not evaluated until the function is applied.

Let us compute the function on some input:

$$
\begin{aligned}
\texttt{fix} \; F \; v &amp;\rightsquigarrow (\lambda fx. F \; (f \; f) \; x) \; (\lambda fx. F \; (f \; f) \; x) \; v \\
&amp;\rightsquigarrow (\lambda x. F \; ((\lambda fx. F \; (f \; f) \; x) \; (\lambda fx. F \; (f \; f) \; x)) \; x) \; v \\
&amp;\rightsquigarrow F \; ((\lambda fx. F \; (f \; f) \; x) \; (\lambda fx. F \; (f \; f) \; x)) \; v \\
&amp;\rightsquigarrow F \; (\lambda x. F \; ((\lambda fx. F \; (f \; f) \; x) \; (\lambda fx. F \; (f \; f) \; x)) \; x) \; v \\
&amp;\rightsquigarrow \text{depends on } F
\end{aligned}
$$

#### Why &quot;Fixpoint&quot;?

If you examine our derivations, you will see they establish $x = f(x)$. Such values $x$ are called **fixpoints** of $f$. An arithmetic function can have several fixpoints---for example, $f(x) = x^2$ has fixpoints 0 and 1 (since $0^2 = 0$ and $1^2 = 1$)---or no fixpoints, such as $f(x) = x + 1$ (since $x + 1 \neq x$ for all $x$).

When you define a function (or another object) by recursion, it has a similar meaning: the name appears on both sides of the equality. For example, `fact n = if n = 0 then 1 else n * fact (n-1)` has `fact` on both sides. In lambda-calculus, functions like $\Theta$ and $\mathbf{Y}$ take *any* function as an argument and return its fixpoint.

We turn a specification of a recursive object into a definition by solving it with respect to the recurring name: deriving $x = f(x)$ where $x$ is the recurring name. We then have $x = \texttt{fix}(f)$.

#### Deriving Factorial

Let us walk through this process step by step for the factorial function. This will show how to transform a recursive specification into a proper definition using `fix`. We omit the prefix `cn_` (could be `pn_` if using pair-encoded numbers) and shorten `if_then_else` to `if_t_e`:

$$
\begin{aligned}
\texttt{fact} \; n &amp;= \texttt{if\_t\_e} \; (\texttt{is\_zero} \; n) \; \texttt{cn1} \; (\texttt{mult} \; n \; (\texttt{fact} \; (\texttt{pred} \; n))) \\
\texttt{fact} &amp;= \lambda n. \texttt{if\_t\_e} \; (\texttt{is\_zero} \; n) \; \texttt{cn1} \; (\texttt{mult} \; n \; (\texttt{fact} \; (\texttt{pred} \; n))) \\
\texttt{fact} &amp;= (\lambda fn. \texttt{if\_t\_e} \; (\texttt{is\_zero} \; n) \; \texttt{cn1} \; (\texttt{mult} \; n \; (f \; (\texttt{pred} \; n)))) \; \texttt{fact} \\
\texttt{fact} &amp;= \texttt{fix} \; (\lambda fn. \texttt{if\_t\_e} \; (\texttt{is\_zero} \; n) \; \texttt{cn1} \; (\texttt{mult} \; n \; (f \; (\texttt{pred} \; n))))
\end{aligned}
$$

The last line is a valid definition: we simply give a name to a *ground* (also called *closed*) expression---one with no free variables. We have already seen how `fix` works in the reduction semantics.

**Exercise:** Compute `fact cn2` by hand, tracing through the reduction steps.

**Exercise:** What does `fix (fun x -&gt; cn_succ x)` mean? What happens if you try to evaluate it? Think about whether there is any value `x` such that `x = cn_succ x`.

### 4.8 Encoding Lists and Trees

Now that we have numbers and recursion, we can encode more complex data structures. The pattern we have seen with booleans and pairs extends naturally to algebraic data types like lists and trees.

A **list** is either empty (often called `Empty` or `Nil`) or consists of an element followed by another list (the &quot;tail&quot;), called `Cons`. Since lists have two variants, we encode them with two-argument selector functions:

- `nil` $= \lambda xy.y$ (select the second argument, like `c_false`)
- `cons` $H \; T = \lambda xy. x \; H \; T$ (apply the first argument to head and tail)

With these definitions, we can write a function to add all numbers stored inside a list:

$$\texttt{addlist} \; l = l \; (\lambda h t. \texttt{cn\_add} \; h \; (\texttt{addlist} \; t)) \; \texttt{cn0}$$

To make a proper definition, we apply $\texttt{fix}$ to the solution of the above equation:

$$\texttt{addlist} = \texttt{fix} \; (\lambda f l. l \; (\lambda h t. \texttt{cn\_add} \; h \; (f \; t)) \; \texttt{cn0})$$

For **trees**, let us use a different form of binary trees than we have seen before: instead of keeping elements in inner nodes, we will keep elements in leaves. This is sometimes called an &quot;external&quot; tree structure.

Again, we have two variants, so we use two-argument selector functions:

- `leaf` $n = \lambda xy. x \; n$ (apply first argument to the element)
- `node` $L \; R = \lambda xy. y \; L \; R$ (apply second argument to left and right subtrees)

To add numbers stored inside a tree:

$$\texttt{addtree} \; t = t \; (\lambda n.n) \; (\lambda l r. \texttt{cn\_add} \; (\texttt{addtree} \; l) \; (\texttt{addtree} \; r))$$

And in solved form:

$$\texttt{addtree} = \texttt{fix} \; (\lambda f t. t \; (\lambda n.n) \; (\lambda l r. \texttt{cn\_add} \; (f \; l) \; (f \; r)))$$

```ocaml env=ch4
let rec fix f x = f (fix f) x
let nil = fun x y -&gt; y
let cons h t = fun x y -&gt; x h t
let addlist l =
  fix (fun f l -&gt; l (fun h t -&gt; cn_add h (f t)) cn0) l
;;
decode_cnat
  (addlist (cons cn1 (cons cn2 (cons cn7 nil))));;
let leaf n = fun x y -&gt; x n
let node l r = fun x y -&gt; y l r
let addtree t =
  fix (fun f t -&gt;
    t (fun n -&gt; n) (fun l r -&gt; cn_add (f l) (f r))
  ) t
;;
decode_cnat
  (addtree (node (node (leaf cn3) (leaf cn7))
              (leaf cn1)));;</code></pre>
<h4 id="the-general-pattern">The General Pattern</h4>
<p>If you look back at our encodings, you will observe a consistent
pattern: when we encode a variant type with <span
class="math inline">n</span> variants, for each variant we define a
function that takes <span class="math inline">n</span> arguments.</p>
<p>If the <span class="math inline">k</span>th variant <span
class="math inline">C_k</span> has <span class="math inline">m_k</span>
parameters, then the function <span class="math inline">c_k</span> that
encodes it has the form:</p>
<p><span class="math display">C_k(v_1, \ldots, v_{m_k}) \sim c_k \; v_1
\; \ldots \; v_{m_k} = \lambda x_1 \ldots x_n. x_k \; v_1 \; \ldots \;
v_{m_k}</span></p>
<p>The encoded variants serve as shallow pattern matching with
guaranteed exhaustiveness: the <span class="math inline">k</span>th
argument corresponds to the <span class="math inline">k</span>th branch
of pattern matching. This is exactly how <code>match</code> works in
OCaml, but encoded purely with functions!</p>
<h3 id="looping-recursion">4.9 Looping Recursion</h3>
<p>We have been coding in untyped lambda-calculus and verifying our code
works in OCaml. But there is a subtle trap we must be aware of when
combining lambda-calculus encodings with OCaml’s eager evaluation.</p>
<p>Let us return to pair-encoded numbers and define addition:</p>
<p><code>ocaml skip let pn_add m n =   fix (fun f m n -&gt;     if_then_else (pn_is_zero m)       n (pn_succ (f (pn_pred m) n))   ) m n;; decode_pnat (pn_add pn3 pn3);;</code></p>
<p>Oops… OCaml says:
<code>Stack overflow during evaluation (looping recursion?).</code></p>
<p>What went wrong? Nothing as far as lambda-calculus is concerned—the
definition is mathematically correct. But OCaml (and F#) always compute
arguments before calling a function. This is the <em>eager</em>
evaluation strategy we discussed earlier. By definition of
<code>fix</code>, <code>f</code> corresponds to recursively calling
<code>pn_add</code>. Therefore, <code>(pn_succ (f (pn_pred m) n))</code>
will be evaluated regardless of what <code>(pn_is_zero m)</code>
returns!</p>
<p>In other words, even when <code>m</code> is zero and we should return
<code>n</code>, OCaml first tries to compute the “else” branch, which
makes a recursive call, which computes its “else” branch, and so on
forever.</p>
<p>Why do <code>addlist</code> and <code>addtree</code> work? Look at
them carefully: their recursive calls are “guarded” by corresponding
<code>fun</code>. The expression
<code>(fun h t -&gt; cn_add h (f t))</code> does not immediately call
<code>f</code>—it creates a function that will call <code>f</code> only
when that function is applied to arguments. What is inside of
<code>fun</code> is not computed immediately—only when the function is
applied to argument(s).</p>
<p>To avoid looping recursion, you need to guard all recursive calls.
Besides putting them inside <code>fun</code>, in OCaml or F# you can
also put them in branches of a <code>match</code> clause, as long as one
of the branches does not have unguarded recursive calls.</p>
<p>The trick for functions like <code>if_then_else</code> is to guard
their arguments with <code>fun x -&gt;</code>, where <code>x</code> is
not used, and apply the <em>result</em> of <code>if_then_else</code> to
some dummy value. This delays the evaluation of both branches until the
boolean has selected one of them:</p>
<p><code>ocaml env=ch4 let id x = x let rec fix f x = f (fix f) x let pn1 x = pn_succ pn0 x let pn2 x = pn_succ pn1 x let pn3 x = pn_succ pn2 x let pn7 x = encode_pnat 7 x let pn_add m n =   fix (fun f m n -&gt;     (if_then_else (pn_is_zero m)        (fun x -&gt; n) (fun x -&gt; pn_succ (f (pn_pred m) n)))       id   ) m n;; decode_pnat (pn_add pn3 pn3);; decode_pnat (pn_add pn3 pn7);;</code></p>
<p>Now the recursive call is wrapped in <code>fun x -&gt;</code>, so it
is not evaluated until <code>if_then_else</code> selects the second
branch and applies it to <code>id</code>. When <code>m</code> is zero,
the first branch <code>(fun x -&gt; n)</code> is selected and applied to
<code>id</code>, giving us <code>n</code> without ever touching the
recursive call.</p>
<p>In OCaml or F# we would typically guard by <code>fun () -&gt;</code>
and then apply to <code>()</code>, but we do not have datatypes like
<code>unit</code> in pure lambda-calculus, so we use <code>id</code> as
our dummy value.</p>
<h3 id="exercises-2">4.10 Exercises</h3>
<p>The following exercises will help solidify your understanding of
lambda-calculus encodings. For each exercise involving lambda-calculus,
test your implementation by encoding some inputs, applying your
function, and decoding the result.</p>
<p><strong>Exercise 1:</strong> Define (implement) and test on a couple
of examples functions corresponding to or computing:</p>
<ol type="1">
<li><code>c_or</code> and <code>c_not</code>;</li>
<li>exponentiation for Church numerals;</li>
<li>is-zero predicate for Church numerals;</li>
<li>even-number predicate for Church numerals;</li>
<li>multiplication for pair-encoded natural numbers;</li>
<li>factorial <span class="math inline">n!</span> for pair-encoded
natural numbers;</li>
<li>the length of a list (in Church numerals);</li>
<li><code>cn_max</code> – maximum of two Church numerals;</li>
<li>the depth of a tree (in Church numerals).</li>
</ol>
<p><strong>Exercise 2:</strong> Construct lambda-terms <span
class="math inline">m_0, m_1, \ldots</span> such that for all <span
class="math inline">n</span> one has:</p>
<p><span class="math display">
\begin{aligned}
m_0 &amp;= x \\
m_{n+1} &amp;= m_{n+2} \; m_n
\end{aligned}
</span></p>
<p>(where equality is after performing <span
class="math inline">\beta</span>-reductions).</p>
<p><strong>Exercise 3:</strong> Representing side-effects as an
explicitly “passed around” state value, write (higher-order) functions
that represent the imperative constructs:</p>
<ol type="1">
<li><code>for</code>…<code>to</code>…</li>
<li><code>for</code>…<code>downto</code>…</li>
<li><code>while</code>…<code>do</code>…</li>
<li><code>do</code>…<code>while</code>…</li>
<li><code>repeat</code>…<code>until</code>…</li>
</ol>
<p>Rather than writing a lambda-term using the encodings that we have
learnt, just implement the functions in OCaml / F#, using built-in
<code>int</code> and <code>bool</code> types. You can use
<code>let rec</code> instead of <code>fix</code>.</p>
<ul>
<li>For example, in exercise (a), write a function
<code>let rec for_to f beg_i end_i s = ...</code> where <code>f</code>
takes arguments <code>i</code> ranging from <code>beg_i</code> to
<code>end_i</code>, state <code>s</code> at given step, and returns
state <code>s</code> at next step; the <code>for_to</code> function
returns the state after the last step.</li>
<li>And in exercise (c), write a function
<code>let rec while_do p f s = ...</code> where both <code>p</code> and
<code>f</code> take state <code>s</code> at given step, and if
<code>p s</code> returns true, then <code>f s</code> is computed to
obtain state at next step; the <code>while_do</code> function returns
the state after the last step.</li>
</ul>
<p>Do not use the imperative features of OCaml and F#! This exercise
demonstrates that imperative control flow can be encoded purely
functionally by threading state through function calls.</p>
<p>Although we will not cover imperative features in this course, it is
instructive to see the implementation using them, to better understand
what is actually required of a solution to Exercise 3:</p>
<p>```ocaml env=ch4 (* (a) *) let for_to f beg_i end_i s = let s = ref s
in for i = beg_i to end_i do s := f i !s done; !s</p>
<p>(* (b) *) let for_downto f beg_i end_i s = let s = ref s in for i =
beg_i downto end_i do s := f i !s done; !s</p>
<p>(* (c) *) let while_do p f s = let s = ref s in while p !s do s := f
!s done; !s</p>
<p>(* (d) *) let do_while p f s = let s = ref (f s) in while p !s do s
:= f !s done; !s</p>
<p>(* (e) *) let repeat_until p f s = let s = ref (f s) in while not (p
!s) do s := f !s done; !s</p>
<pre><code>

## Chapter 5: Polymorphism and Abstract Data Types

**In this chapter, you will:**

- Understand “unknowns vs parameters” in OCaml’s inferred types (and why the value restriction exists)
- Connect type inference to solving constraint systems (unification intuition)
- Use parametric types to design reusable, type-safe data structures
- Specify ADTs algebraically and implement maps with increasing efficiency (lists → BSTs → red-black trees)

This chapter explores how OCaml&#39;s type system supports generic programming through parametric polymorphism, and how abstract data types provide clean interfaces for data structures. We begin by examining how type inference actually works -- the process by which OCaml determines types for your code. Then we explore parametric types and show how they enable polymorphic functions to work with data of any shape. The second half of the chapter introduces algebraic specifications, the mathematical foundation for describing data structures, and applies these concepts to build progressively more sophisticated implementations of the map (dictionary) data structure, culminating in the elegant red-black tree.

*Reader feedback welcome: if you spot an error or unclear passage, please report it.*

### 5.1 Type Inference

We have seen the rules that govern the assignment of types to expressions, but how does OCaml actually guess what types to use? And how does it know when no correct types exist? The answer lies in a beautiful algorithm: OCaml solves equations. When you write code, the type checker generates a set of equations that must hold for the program to be well-typed, and then it solves those equations to discover the types.

#### Variables: Unknowns and Parameters

Variables in type inference play two distinct roles, and understanding this distinction is crucial for mastering OCaml&#39;s type system. A type variable can be either an *unknown* (standing for a specific but not-yet-determined type) or a *parameter* (standing for any type whatsoever).

Consider this example:

```ocaml env=ch5
# let f = List.hd;;
val f : &#39;a list -&gt; &#39;a = &lt;fun&gt;</code></pre>
<p>Here <code>'a</code> is a <em>parameter</em>: it can become any type.
When you use <code>f</code> with a list of integers, <code>'a</code>
becomes <code>int</code>; when you use it with a list of strings,
<code>'a</code> becomes <code>string</code>. Mathematically we write:
<span class="math inline">f : \forall \alpha . \alpha \ \text{list}
\rightarrow \alpha</span> – the quantified type is called a <em>type
scheme</em>. The <span class="math inline">\forall</span> symbol
indicates that this type works “for all” choices of <span
class="math inline">\alpha</span>.</p>
<p>In contrast, consider this example:</p>
<p><code>ocaml skip # let x = ref [];; val x : '_weak1 list ref = {contents = []}</code></p>
<p>Here <code>'_a</code> (displayed as <code>'_weak1</code> in recent
OCaml versions) is an <em>unknown</em>. Unlike a parameter, it stands
for a <em>particular</em> type – perhaps <code>float</code> or
<code>int -&gt; int</code> – but OCaml simply doesn’t know which type
yet. The underscore prefix signals this distinction. OCaml reports
unknowns like <code>'_a</code> in inferred types for reasons related to
mutable state (the “value restriction”), which are not relevant to
purely functional programming.</p>
<p>More precisely: the <em>value restriction</em> prevents unsoundness
that would otherwise arise from generalizing type variables in effectful
(mutable) expressions. When you see <code>'_weak...</code>, treat it as
“this will become one specific type later”.</p>
<p>When unknowns appear in inferred types against our expectations,
<em><span class="math inline">\eta</span>-expansion</em> may help. This
technique involves writing <code>let f x = expr x</code> instead of
<code>let f = expr</code>, essentially adding an extra parameter that
gets immediately applied. For example:</p>
<p><code>ocaml skip # let f = List.append [];; val f : '_weak2 list -&gt; '_weak2 list = &lt;fun&gt; # let f l = List.append [] l;; val f : 'a list -&gt; 'a list = &lt;fun&gt;</code></p>
<p>In the second definition, the eta-expanded form
<code>let f l = List.append [] l</code> allows full generalization,
giving us a truly polymorphic function that can work with lists of any
type.</p>
<h4 id="type-environments">Type Environments</h4>
<p>Before diving into the equation-solving process, we need to
understand how the type checker keeps track of what names are available.
A <em>type environment</em> specifies what names (corresponding to
parameters and definitions) are available for an expression because they
were introduced above it, and it specifies their types. Think of it as a
dictionary that maps variable names to their types at any given point in
your program.</p>
<h4 id="solving-type-equations">Solving Type Equations</h4>
<p>Type inference works by solving equations over unknowns. The central
question the algorithm asks is: “What has to hold so that <span
class="math inline">e : \tau</span> in type environment <span
class="math inline">\Gamma</span>?” The answer takes the form of
equations that constrain the possible types.</p>
<p>Let us walk through how the algorithm handles different expression
forms:</p>
<ul>
<li><p>If, for example, <span class="math inline">f : \forall \alpha .
\alpha \ \text{list} \rightarrow \alpha \in \Gamma</span>, then for
<span class="math inline">f : \tau</span> we introduce <span
class="math inline">\gamma \ \text{list} \rightarrow \gamma =
\tau</span> for some fresh unknown <span
class="math inline">\gamma</span>.</p></li>
<li><p>For function application <span class="math inline">e_1 \ e_2 :
\tau</span>, we introduce <span class="math inline">\beta = \tau</span>
and ask for <span class="math inline">e_1 : \gamma \rightarrow
\beta</span> and <span class="math inline">e_2 : \gamma</span>, for some
fresh unknowns <span class="math inline">\beta, \gamma</span>.</p></li>
<li><p>For a function <span class="math inline">\text{fun} \ x
\rightarrow e : \tau</span>, we introduce <span
class="math inline">\beta \rightarrow \gamma = \tau</span> and ask for
<span class="math inline">e : \gamma</span> in environment <span
class="math inline">\{x : \beta\} \cup \Gamma</span>, for some fresh
unknowns <span class="math inline">\beta, \gamma</span>.</p></li>
<li><p>The case <span class="math inline">\text{let} \ x = e_1 \
\text{in} \ e_2 : \tau</span> is different. One approach is to
<em>first</em> solve the equations that we get by asking for <span
class="math inline">e_1 : \beta</span>, for some fresh unknown <span
class="math inline">\beta</span>. Let us say a solution <span
class="math inline">\beta = \tau_\beta</span> has been found, <span
class="math inline">\alpha_1 \ldots \alpha_n \beta_1 \ldots
\beta_m</span> are the remaining unknowns in <span
class="math inline">\tau_\beta</span>, and <span
class="math inline">\alpha_1 \ldots \alpha_n</span> are all that do not
appear in <span class="math inline">\Gamma</span>. Then we ask for <span
class="math inline">e_2 : \tau</span> in environment <span
class="math inline">\{x : \forall \alpha_1 \ldots \alpha_n .
\tau_\beta\} \cup \Gamma</span>.</p></li>
<li><p>Remember that whenever we establish a solution <span
class="math inline">\beta = \tau_\beta</span> to an unknown <span
class="math inline">\beta</span>, it takes effect everywhere! The
substitution propagates through all the equations, potentially
triggering further unifications.</p></li>
<li><p>To find a type for <span class="math inline">e</span> (in
environment <span class="math inline">\Gamma</span>), we pick a fresh
unknown <span class="math inline">\beta</span> and ask for <span
class="math inline">e : \beta</span> (in <span
class="math inline">\Gamma</span>). The algorithm then generates and
solves equations until either a solution is found or a contradiction
reveals a type error.</p></li>
</ul>
<h4 id="polymorphism">Polymorphism</h4>
<p>The “top-level” definitions for which the system infers types with
variables are called <em>polymorphic</em>, which informally means
“working with different shapes of data.” A polymorphic function like
<code>List.hd</code> can operate on lists containing any type of element
– the function itself doesn’t care what the elements are, only that it’s
working with a list.</p>
<p>This kind of polymorphism is called <em>parametric polymorphism</em>,
since the types have parameters. The term “parametric” emphasizes that
the same code works uniformly for all type instantiations. A different
kind of polymorphism is provided by object-oriented programming
languages (sometimes called <em>subtype polymorphism</em> or <em>ad-hoc
polymorphism</em>), where different code may execute depending on the
runtime type of objects.</p>
<h3 id="parametric-types">5.2 Parametric Types</h3>
<p>Polymorphic functions truly shine when used with polymorphic data
types. The combination of the two is what makes ML-family languages so
expressive. Consider this definition of our own list type:</p>
<p><code>ocaml env=ch5 type 'a my_list = Empty | Cons of 'a * 'a my_list</code></p>
<p>We define lists that can store elements of any type <code>'a</code>.
The type parameter <code>'a</code> acts as a placeholder that gets
filled in when we create actual lists. Now we can write functions that
work on these lists:</p>
<p><code>ocaml env=ch5 # let tail l =     match l with     | Empty -&gt; invalid_arg "tail"     | Cons (_, tl) -&gt; tl;; val tail : 'a my_list -&gt; 'a my_list = &lt;fun&gt;</code></p>
<p>This is a polymorphic function: it works for lists with elements of
any type. Whether we have a list of integers, strings, or even lists of
lists, the same <code>tail</code> function handles them all.</p>
<p>A crucial point to understand: a <em>parametric type</em> like
<code>'a my_list</code> <em>is not</em> itself a data type but rather a
<em>family</em> of data types. The types <code>bool my_list</code>,
<code>int my_list</code>, etc. <em>are</em> different types – you cannot
mix elements of different types in a single list. We say that the type
<code>int my_list</code> <em>instantiates</em> the parametric type
<code>'a my_list</code>.</p>
<h4 id="multiple-type-parameters">Multiple Type Parameters</h4>
<p>Types can have multiple type parameters. In OCaml, the syntax might
seem a bit unusual at first: type parameters precede the type name,
enclosed in parentheses. For example:</p>
<p><code>ocaml env=ch5 type ('a, 'b) choice = Left of 'a | Right of 'b</code></p>
<p>This type has two parameters and represents a value that is either
something of type <code>'a</code> (wrapped in <code>Left</code>) or
something of type <code>'b</code> (wrapped in <code>Right</code>).
Mathematically we would write <span
class="math inline">\text{choice}(\alpha, \beta)</span>.</p>
<p>Not all functions that use parametric types need to be polymorphic. A
function may constrain the type parameters to specific types:</p>
<p><code>ocaml env=ch5 # let get_int c =     match c with     | Left i -&gt; i     | Right b -&gt; if b then 1 else 0;; val get_int : (int, bool) choice -&gt; int = &lt;fun&gt;</code></p>
<p>Here, the pattern matching on <code>Left i</code> and
<code>Right b</code> with arithmetic operations constrains the type to
<code>(int, bool) choice</code>.</p>
<h4 id="syntax-in-other-languages">Syntax in Other Languages</h4>
<p>Different functional languages have different syntactic conventions
for type parameters. In F#, we provide parameters (when more than one)
after the type name, using angle brackets:</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode fsharp"><code class="sourceCode fsharp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> choice&lt;&#39;a,&#39;b&gt; = Left <span class="kw">of</span> &#39;a | Right <span class="kw">of</span> &#39;b</span></code></pre></div>
<p>In Haskell, the syntax is arguably the cleanest – we provide type
parameters similarly to function arguments, separated by spaces:</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Choice</span> a b <span class="ot">=</span> <span class="dt">Left</span> a <span class="op">|</span> <span class="dt">Right</span> b</span></code></pre></div>
<p>Despite the syntactic differences, the underlying concept of
parametric polymorphism is the same across all these languages.</p>
<h3 id="type-inference-formally">5.3 Type Inference, Formally</h3>
<p>Now we present a more formal treatment of type inference. A statement
that an expression has a type in an environment is called a <em>type
judgement</em>. For environment <span class="math inline">\Gamma = \{x :
\forall \alpha_1 \ldots \alpha_n . \tau_x ; \ldots\}</span>, expression
<span class="math inline">e</span> and type <span
class="math inline">\tau</span> we write:</p>
<p><span class="math display">\Gamma \vdash e : \tau</span></p>
<p>This notation reads: “In environment <span
class="math inline">\Gamma</span>, expression <span
class="math inline">e</span> has type <span
class="math inline">\tau</span>.” The turnstile symbol <span
class="math inline">\vdash</span> can be thought of as “entails” or
“proves.”</p>
<p>We will derive all the constraint equations in one go using the
notation <span class="math inline">[\![ \cdot ]\!]</span>, to be solved
later by unification. Besides equations we will need to manage
introduced variables, using existential quantification to express that
“there exists some type variable satisfying these constraints.”</p>
<p>For local definitions we require remembering what constraints should
hold when the definition is used. Therefore we extend <em>type
schemes</em> in the environment to: <span class="math inline">\Gamma =
\{x : \forall \beta_1 \ldots \beta_m [\exists \alpha_1 \ldots \alpha_n .
D] . \tau_x ; \ldots\}</span> where <span class="math inline">D</span>
are equations – keeping the variables <span class="math inline">\alpha_1
\ldots \alpha_n</span> introduced while deriving <span
class="math inline">D</span> in front. A simpler form would be
sufficient: <span class="math inline">\Gamma = \{x : \forall \beta
[\exists \alpha_1 \ldots \alpha_n . D] . \beta ; \ldots\}</span></p>
<p>The formal constraint generation rules are:</p>
<p><span class="math display">[\![ \Gamma \vdash x : \tau ]\!] = \exists
\overline{\beta&#39;} \overline{\alpha&#39;} . (D[\overline{\beta}
\overline{\alpha} := \overline{\beta&#39;} \overline{\alpha&#39;}]
\wedge \tau_x[\overline{\beta} \overline{\alpha} :=
\overline{\beta&#39;} \overline{\alpha&#39;}] \doteq \tau)</span></p>
<p>where <span class="math inline">\Gamma(x) = \forall \overline{\beta}
[\exists \overline{\alpha} . D] . \tau_x</span>, <span
class="math inline">\overline{\beta&#39;} \overline{\alpha&#39;} \#
\text{FV}(\Gamma, \tau)</span></p>
<p><span class="math display">[\![ \Gamma \vdash \mathbf{fun} \ x
\texttt{-&gt;} e : \tau ]\!] = \exists \alpha_1 \alpha_2 . ([\![ \Gamma
\{x : \alpha_1\} \vdash e : \alpha_2 ]\!] \wedge \alpha_1 \rightarrow
\alpha_2 \doteq \tau)</span></p>
<p>where <span class="math inline">\alpha_1 \alpha_2 \#
\text{FV}(\Gamma, \tau)</span></p>
<p><span class="math display">[\![ \Gamma \vdash e_1 \ e_2 : \tau ]\!] =
\exists \alpha . ([\![ \Gamma \vdash e_1 : \alpha \rightarrow \tau ]\!]
\wedge [\![ \Gamma \vdash e_2 : \alpha ]\!]), \alpha \#
\text{FV}(\Gamma, \tau)</span></p>
<p><span class="math display">[\![ \Gamma \vdash K \ e_1 \ldots e_n :
\tau ]\!] = \exists \overline{\alpha&#39;} . (\bigwedge_i [\![ \Gamma
\vdash e_i : \tau_i[\overline{\alpha} := \overline{\alpha&#39;}] ]\!]
\wedge \varepsilon(\overline{\alpha&#39;}) \doteq \tau)</span></p>
<p>where <span class="math inline">K : \forall \overline{\alpha} .
\tau_1 \times \ldots \times \tau_n \rightarrow
\varepsilon(\overline{\alpha})</span>, <span
class="math inline">\overline{\alpha&#39;} \# \text{FV}(\Gamma,
\tau)</span></p>
<p>For let-expressions:</p>
<p><span class="math display">[\![ \Gamma \vdash \mathbf{let} \ x = e_1
\ \mathbf{in} \ e_2 : \tau ]\!] = (\exists \beta . C) \wedge [\![ \Gamma
\{x : \forall \beta [C] . \beta\} \vdash e_2 : \tau ]\!]</span></p>
<p>where <span class="math inline">C = [\![ \Gamma \vdash e_1 : \beta
]\!]</span></p>
<p>For recursive let-expressions:</p>
<p><span class="math display">[\![ \Gamma \vdash \mathbf{letrec} \ x =
e_1 \ \mathbf{in} \ e_2 : \tau ]\!] = (\exists \beta . C) \wedge [\![
\Gamma \{x : \forall \beta [C] . \beta\} \vdash e_2 : \tau
]\!]</span></p>
<p>where <span class="math inline">C = [\![ \Gamma \{x : \beta\} \vdash
e_1 : \beta ]\!]</span></p>
<p>For match expressions:</p>
<p><span class="math display">[\![ \Gamma \vdash \mathbf{match} \ e_v \
\mathbf{with} \ \overline{c} : \tau ]\!] = \exists \alpha_v . [\![
\Gamma \vdash e_v : \alpha_v ]\!] \bigwedge_i [\![ \Gamma \vdash p_i .
e_i : \alpha_v \rightarrow \tau ]\!]</span></p>
<p>where <span class="math inline">\overline{c} = p_1 . e_1 | \ldots |
p_n . e_n</span>, <span class="math inline">\alpha_v \#
\text{FV}(\Gamma, \tau)</span></p>
<p>For pattern clauses:</p>
<p><span class="math display">[\![ \Gamma, \Sigma \vdash p.e : \tau_1
\rightarrow \tau_2 ]\!] = [\![ \Sigma \vdash p \downarrow \tau_1 ]\!]
\wedge \exists \overline{\beta} . [\![ \Gamma \Gamma&#39; \vdash e :
\tau_2 ]\!]</span></p>
<p>where <span class="math inline">\exists \overline{\beta}
\Gamma&#39;</span> is <span class="math inline">[\![ \Sigma \vdash p
\uparrow \tau_1 ]\!]</span>, <span class="math inline">\overline{\beta}
\# \text{FV}(\Gamma, \tau_2)</span></p>
<p>The notation <span class="math inline">[\![ \Sigma \vdash p
\downarrow \tau_1 ]\!]</span> derives constraints on the type of the
matched value, while <span class="math inline">[\![ \Sigma \vdash p
\uparrow \tau_1 ]\!]</span> derives the environment for pattern
variables.</p>
<p>By <span class="math inline">\overline{\alpha}</span> or <span
class="math inline">\overline{\alpha_i}</span> we denote a sequence of
some length: <span class="math inline">\alpha_1 \ldots \alpha_n</span>.
By <span class="math inline">\bigwedge_i \varphi_i</span> we denote a
conjunction of <span class="math inline">\overline{\varphi_i}</span>:
<span class="math inline">\varphi_1 \wedge \ldots \wedge
\varphi_n</span>.</p>
<h4 id="polymorphic-recursion">Polymorphic Recursion</h4>
<p>There is an interesting limitation in standard type inference for
recursive functions. Note the limited polymorphism of
<code>let rec f = ...</code> – we cannot use <code>f</code>
polymorphically within its own definition. Why? Because when
type-checking the body of a recursive definition, we don’t yet know the
final type of <code>f</code>, so we must treat it as having a single,
unknown type.</p>
<p>In modern OCaml we can bypass this limitation if we provide the type
of <code>f</code> upfront:</p>
<pre><code>let rec f : &#39;a. &#39;a -&gt; &#39;a list = ...</code></pre>
<p>where <code>'a. 'a -&gt; 'a list</code> stands for <span
class="math inline">\forall \alpha . \alpha \rightarrow \alpha \
\text{list}</span>.</p>
<p>Using the recursively defined function with different types in its
definition is called <em>polymorphic recursion</em>. It is most useful
together with <em>irregular recursive datatypes</em> – data structures
where the recursive use has different type arguments than the actual
parameters. These “nested” or “non-uniform” datatypes enable some
remarkably elegant data structures.</p>
<h5
id="example-a-list-alternating-between-two-types-of-elements">Example: A
List Alternating Between Two Types of Elements</h5>
<p>Here is a fascinating example: a list that alternates between two
different types of elements. Notice how the recursive occurrence swaps
the type parameters:</p>
<p>```ocaml env=ch5 type (’x, ’o) alternating = | Stop | One of ’x *
(’o, ’x) alternating</p>
<p>let rec to_list : ’x ’o ’a. (’x -&gt; ’a) -&gt; (’o -&gt; ’a) -&gt;
(’x, ’o) alternating -&gt; ’a list = fun x2a o2a -&gt; function | Stop
-&gt; [] | One (x, rest) -&gt; x2a x :: to_list o2a x2a rest</p>
<p>let to_choice_list alt = to_list (fun x -&gt; Left x) (fun o -&gt;
Right o) alt</p>
<p>let it = to_choice_list (One (1, One (“o”, One (2, One (“oo”,
Stop)))))</p>
<pre><code>
Notice how the recursive call to `to_list` swaps `o2a` and `x2a` -- this is necessary because the alternating structure swaps the type parameters at each level. The polymorphic recursion annotation `&#39;x &#39;o &#39;a.` tells OCaml that we need to use `to_list` at different type instantiations within its own definition.

##### Example: Data-Structural Bootstrapping

Here is another powerful example of polymorphic recursion: a sequence data structure that stores elements in exponentially increasing chunks. This technique, known as *data-structural bootstrapping*, achieves logarithmic-time random access -- much faster than standard lists which require linear time.

```ocaml env=ch5
type &#39;a seq =
  | Nil
  | Zero of (&#39;a * &#39;a) seq
  | One of &#39;a * (&#39;a * &#39;a) seq</code></pre>
<p>The key insight is that this type is <em>non-uniform</em>: the
recursive occurrences use <code>('a * 'a) seq</code> rather than
<code>'a seq</code>. This means that as we go deeper into the structure,
elements get paired together, effectively doubling the “width” at each
level. We store a list of elements in exponentially increasing
chunks:</p>
<p><code>ocaml env=ch5 let example =   One (0, One ((1,2), Zero (One ((((3,4),(5,6)), ((7,8),(9,10))), Nil))))</code></p>
<p>The <code>cons</code> operation adds an element to the front.
Remarkably, appending an element to this data structure works exactly
like adding one to a binary number:</p>
<p>```ocaml env=ch5 let rec cons : ’a. ’a -&gt; ’a seq -&gt; ’a seq =
fun x -&gt; function | Nil -&gt; One (x, Nil) (* 1+0=1 <em>) | Zero ps
-&gt; One (x, ps) (</em> 1+…0=…1 <em>) | One (y, ps) -&gt; Zero (cons
(x,y) ps) (</em> 1+…1=[…+1]0 *)</p>
<p>let rec lookup : ’a. int -&gt; ’a seq -&gt; ’a = fun i s -&gt; match
i, s with | _, Nil -&gt; raise Not_found (* Rather than returning None :
’a option *) | 0, One (x, _) -&gt; x (* we raise exception, for
convenience. *) | i, One (_, ps) -&gt; lookup (i-1) (Zero ps) | i, Zero
ps -&gt; (* Random-access lookup works <em>) let x, y = lookup (i / 2)
ps in (</em> in logarithmic time – much faster <em>) if i mod 2 = 0 then
x else y (</em> than in standard lists. *)</p>
<pre><code>
The `Zero` and `One` constructors correspond to binary digits. A `Zero` means &quot;no singleton element at this level,&quot; while `One` carries a singleton (or pair, or quad, etc.) before recursing. The `lookup` function exploits this structure: when looking up index `i` in a `Zero ps`, it divides by 2 and looks in the paired structure, then extracts the appropriate half of the pair.

### 5.4 Algebraic Specification

Now we turn to a fundamental question in computer science: how do we formally describe what a data structure *is* and what it should *do*? The mathematical answer is *algebraic specification*.

The way we introduce a data structure, like complex numbers or strings, in mathematics is by specifying an *algebraic structure*. This approach gives us a precise language for describing data structures independent of any particular implementation.

Algebraic structures consist of a set (or several sets, for so-called *multisorted* algebras) and a bunch of functions (also known as operations) over this set (or sets). Think of integers with addition and multiplication, or strings with concatenation and character access.

A *signature* is a rough description of an algebraic structure: it provides *sorts* -- names for the sets (in the multisorted case) -- and names of the functions-operations together with their arity (and what sorts of arguments they take). A signature tells us what operations exist, but not how they behave.

We select a class of algebraic structures by providing axioms that have to hold. We will call such classes *algebraic specifications*. In mathematics, a rusty name for some algebraic specifications is a *variety*; a more modern name is *algebraic category*.

Here is the key connection to programming: algebraic structures correspond to &quot;implementations&quot; and signatures to &quot;interfaces&quot; in programming languages. We will say that an algebraic structure *implements* an algebraic specification when all axioms of the specification hold in the structure. An important point: all algebraic specifications are implemented by multiple structures! This is precisely what we want -- it gives us the freedom to choose different implementations with different performance characteristics while maintaining the same interface.

We say that an algebraic structure does not have *junk* when all its elements (i.e., elements in the sets corresponding to sorts) can be built using operations in its signature. Junk-free structures are &quot;minimal&quot; in some sense -- they contain only the values that can be constructed using the provided operations.

We allow parametric types as sorts. In that case, strictly speaking, we define a family of algebraic specifications (a different specification for each instantiation of the parametric type).

#### Algebraic Specifications: Examples

Let us look at some concrete examples to make these abstract ideas tangible. An algebraic specification can also use an earlier specification, building up complexity layer by layer. In &quot;impure&quot; languages like OCaml and F# we allow that the result of any operation be an $\text{error}$. In Haskell we would use `Maybe` to explicitly model potential failure.

**Specification $\text{nat}_p$ (bounded natural numbers):**

This specification describes natural numbers that wrap around at some bound $p$ (like machine integers):

| $\text{nat}_p$ |
|----------------|
| $0 : \text{nat}_p$ |
| $\text{succ} : \text{nat}_p \rightarrow \text{nat}_p$ |
| $+ : \text{nat}_p \rightarrow \text{nat}_p \rightarrow \text{nat}_p$ |
| $* : \text{nat}_p \rightarrow \text{nat}_p \rightarrow \text{nat}_p$ |
| Variables: $n, m : \text{nat}_p$ |
| Axioms: |
| $0 + n = n$, $n + 0 = n$ |
| $m + \text{succ}(n) = \text{succ}(m + n)$ |
| $0 * n = 0$, $n * 0 = 0$ |
| $m * \text{succ}(n) = m + (m * n)$ |
| $\underbrace{\text{succ}(\ldots\text{succ}(0))}_{\text{less than } p \text{ times}} \neq 0$ |
| $\underbrace{\text{succ}(\ldots\text{succ}(0))}_{p \text{ times}} = 0$ |

The axioms define how addition and multiplication work recursively, and the last two axioms capture the bounded nature: applying $\text{succ}$ less than $p$ times never gives zero, but exactly $p$ times wraps around to zero.

**Specification $\text{string}_p$ (bounded strings):**

This specification describes strings with a maximum length $p$:

| $\text{string}_p$ |
|-------------------|
| uses $\text{char}$, $\text{nat}_p$ |
| `&quot;&quot;` $: \text{string}_p$ |
| `&quot;c&quot;` $: \text{char} \rightarrow \text{string}_p$ |
| $\hat{\ } : \text{string}_p \rightarrow \text{string}_p \rightarrow \text{string}_p$ |
| $\cdot[\cdot] : \text{string}_p \rightarrow \text{nat}_p \rightarrow \text{char}$ |
| Variables: $s : \text{string}_p$, $c, c_1, \ldots, c_p : \text{char}$, $n : \text{nat}_p$ |
| Axioms: |
| `&quot;&quot;` $\hat{\ } s = s$, $s \hat{\ }$ `&quot;&quot;` $= s$ |
| $\underbrace{\text{``}c_1\text{&#39;&#39;} \hat{\ } (\ldots \hat{\ } \text{``}c_p\text{&#39;&#39;})}_{p \text{ times}} = \text{error}$ |
| $r \hat{\ } (s \hat{\ } t) = (r \hat{\ } s) \hat{\ } t$ |
| $(\text{``}c\text{&#39;&#39;} \hat{\ } s)[0] = c$ |
| $(\text{``}c\text{&#39;&#39;} \hat{\ } s)[\text{succ}(n)] = s[n]$ |
| `&quot;&quot;`$[n] = \text{error}$ |

The axioms specify that concatenation is associative, that the empty string is an identity for concatenation, that exceeding the length limit produces an error, and that indexing works by stripping characters from the front.

### 5.5 Homomorphisms

When do two implementations of the same specification &quot;behave the same&quot;? The mathematical answer involves *homomorphisms* -- structure-preserving mappings between algebraic structures.

Homomorphisms are mappings between algebraic structures with the same signature that preserve operations. Intuitively, if you apply an operation and then map, you get the same result as mapping first and then applying the corresponding operation.

A *homomorphism* from algebraic structure $(A, \{f^A, g^A, \ldots\})$ to $(B, \{f^B, g^B, \ldots\})$ is a function $h : A \rightarrow B$ such that:
- $h(f^A(a_1, \ldots, a_{n_f})) = f^B(h(a_1), \ldots, h(a_{n_f}))$ for all $(a_1, \ldots, a_{n_f})$
- $h(g^A(a_1, \ldots, a_{n_g})) = g^B(h(a_1), \ldots, h(a_{n_g}))$ for all $(a_1, \ldots, a_{n_g})$
- and so on for all operations.

Two algebraic structures are *isomorphic* if there are homomorphisms $h_1 : A \rightarrow B$, $h_2 : B \rightarrow A$ from one to the other and back, that when composed in any order form identity: $\forall (b \in B) \ h_1(h_2(b)) = b$ and $\forall (a \in A) \ h_2(h_1(a)) = a$.

An algebraic specification whose all implementations without junk are isomorphic is called &quot;*monomorphic*&quot;. This means the specification pins down the structure so precisely that there&#39;s essentially only one way to implement it (up to isomorphism).

We usually only add axioms that really matter to us to the specification, so that the implementations have room for optimization. For this reason, the resulting specifications will often not be monomorphic in the above sense -- and that&#39;s intentional! A non-monomorphic specification allows for multiple genuinely different implementations, which may have different performance characteristics.

### 5.6 Example: Maps

Now let us look at a practical example that will guide the rest of this chapter. A *map* (also called dictionary or associative array) associates keys with values. This is one of the most fundamental data structures in programming -- think of Python&#39;s dictionaries, Java&#39;s `HashMap`, or OCaml&#39;s `Map` module.

Here is an algebraic specification that captures the essential behavior of maps:

| $(\alpha, \beta) \ \text{map}$ |
|--------------------------------|
| uses $\text{bool}$, type parameters $\alpha, \beta$ |
| $\text{empty} : (\alpha, \beta) \ \text{map}$ |
| $\text{member} : \alpha \rightarrow (\alpha, \beta) \ \text{map} \rightarrow \text{bool}$ |
| $\text{add} : \alpha \rightarrow \beta \rightarrow (\alpha, \beta) \ \text{map} \rightarrow (\alpha, \beta) \ \text{map}$ |
| $\text{remove} : \alpha \rightarrow (\alpha, \beta) \ \text{map} \rightarrow (\alpha, \beta) \ \text{map}$ |
| $\text{find} : \alpha \rightarrow (\alpha, \beta) \ \text{map} \rightarrow \beta$ |
| Variables: $k, k_2 : \alpha$, $v, v_2 : \beta$, $m : (\alpha, \beta) \ \text{map}$ |
| Axioms: |
| $\text{member}(k, \text{add}(k, v, m)) = \text{true}$ |
| $\text{member}(k, \text{remove}(k, m)) = \text{false}$ |
| $\text{member}(k, \text{add}(k_2, v, m)) = \text{true} \wedge k \neq k_2 \Leftrightarrow \text{member}(k, m) = \text{true} \wedge k \neq k_2$ |
| $\text{member}(k, \text{remove}(k_2, m)) = \text{true} \wedge k \neq k_2 \Leftrightarrow \text{member}(k, m) = \text{true} \wedge k \neq k_2$ |
| $\text{find}(k, \text{add}(k, v, m)) = v$ |
| $\text{find}(k, \text{remove}(k, m)) = \text{error}$, $\text{find}(k, \text{empty}) = \text{error}$ |
| $\text{find}(k, \text{add}(k_2, v_2, m)) = v \wedge k \neq k_2 \Leftrightarrow \text{find}(k, m) = v \wedge k \neq k_2$ |
| $\text{find}(k, \text{remove}(k_2, m)) = v \wedge k \neq k_2 \Leftrightarrow \text{find}(k, m) = v \wedge k \neq k_2$ |
| $\text{remove}(k, \text{empty}) = \text{empty}$ |

The axioms capture the intuitive behavior: adding a key-value pair makes that key findable, removing a key makes it unfindable, and operations on different keys don&#39;t interfere with each other. Notice how the specification says nothing about *how* the map is implemented -- only about *what* behavior it must exhibit.

### 5.7 Modules and Interfaces (Signatures): Syntax

How do we express algebraic specifications in OCaml? The answer is the *module system*. In the ML family of languages, structures are given names by **module** bindings, and signatures are types of modules. From outside of a structure or signature, we refer to the values or types it provides with a dot notation: `Module.value`.

Module (and module type) names have to start with a capital letter (in ML languages). Since modules and module types have names, there is a convention to name the central type of a signature (the one that is &quot;specified&quot; by the signature), for brevity, `t`. Module types are often named with &quot;all-caps&quot; (all letters upper case).

Here is how we translate our map specification into an OCaml module signature:

```ocaml env=ch5
module type MAP = sig
  type (&#39;a, &#39;b) t
  val empty : (&#39;a, &#39;b) t
  val member : &#39;a -&gt; (&#39;a, &#39;b) t -&gt; bool
  val add : &#39;a -&gt; &#39;b -&gt; (&#39;a, &#39;b) t -&gt; (&#39;a, &#39;b) t
  val remove : &#39;a -&gt; (&#39;a, &#39;b) t -&gt; (&#39;a, &#39;b) t
  val find : &#39;a -&gt; (&#39;a, &#39;b) t -&gt; &#39;b
end

module ListMap : MAP = struct
  type (&#39;a, &#39;b) t = (&#39;a * &#39;b) list
  let empty = []
  let member = List.mem_assoc
  let add k v m = (k, v)::m
  let remove = List.remove_assoc
  let find = List.assoc
end</code></pre>
<p>The <code>ListMap</code> module implements <code>MAP</code> using
OCaml’s built-in list functions for association lists. The type
annotation <code>: MAP</code> after the module name tells OCaml to check
that the implementation provides everything the signature requires, and
hides any additional details.</p>
<h3 id="implementing-maps-association-lists">5.8 Implementing Maps:
Association Lists</h3>
<p>Let us now build an implementation of maps from the ground up,
exploring different approaches and their trade-offs. The most
straightforward implementation… might not be what you expected:</p>
<p>```ocaml env=ch5 module TrivialMap : MAP = struct type (’a, ’b) t = |
Empty | Add of ’a * ’b * (’a, ’b) t | Remove of ’a * (’a, ’b) t</p>
<p>let empty = Empty</p>
<p>let rec member k m = match m with | Empty -&gt; false | Add (k2,
<em>, </em>) when k = k2 -&gt; true | Remove (k2, <em>) when k = k2
-&gt; false | Add (</em>, <em>, m2) -&gt; member k m2 | Remove (</em>,
m2) -&gt; member k m2</p>
<p>let add k v m = Add (k, v, m) let remove k m = Remove (k, m)</p>
<p>let rec find k m = match m with | Empty -&gt; raise Not_found | Add
(k2, v, <em>) when k = k2 -&gt; v | Remove (k2, </em>) when k = k2 -&gt;
raise Not_found | Add (<em>, </em>, m2) -&gt; find k m2 | Remove (_, m2)
-&gt; find k m2 end</p>
<pre><code>
This &quot;trivial&quot; implementation is quite clever in its own way: it simply records all operations as a log! The data structure itself is a history of everything that has been done to it. The `add` and `remove` operations are $O(1)$ -- they just prepend a new node. However, `member` and `find` must traverse the entire history to determine the current state, giving them $O(n)$ complexity where $n$ is the number of operations performed.

This implementation illustrates an important point: there are many ways to satisfy the same specification, with very different performance characteristics.

Here is a more conventional implementation based on association lists, i.e., on lists of key-value pairs without the `Remove` constructor:

```ocaml env=ch5
module MyListMap : MAP = struct
  type (&#39;a, &#39;b) t = Empty | Add of &#39;a * &#39;b * (&#39;a, &#39;b) t

  let empty = Empty

  let rec member k m =
    match m with
    | Empty -&gt; false
    | Add (k2, _, _) when k = k2 -&gt; true
    | Add (_, _, m2) -&gt; member k m2

  let rec add k v m =
    match m with
    | Empty -&gt; Add (k, v, Empty)
    | Add (k2, _, m) when k = k2 -&gt; Add (k, v, m)
    | Add (k2, v2, m) -&gt; Add (k2, v2, add k v m)

  let rec remove k m =
    match m with
    | Empty -&gt; Empty
    | Add (k2, _, m) when k = k2 -&gt; m
    | Add (k2, v, m) -&gt; Add (k2, v, remove k m)

  let rec find k m =
    match m with
    | Empty -&gt; raise Not_found
    | Add (k2, v, _) when k = k2 -&gt; v
    | Add (_, _, m2) -&gt; find k m2
end</code></pre>
<p>This implementation maintains the invariant that each key appears at
most once in the structure. The <code>add</code> function replaces an
existing key’s value rather than creating a duplicate, and
<code>remove</code> actually removes the key-value pair. All operations
are still <span class="math inline">O(n)</span> in the worst case, but
the structure stays cleaner.</p>
<h3 id="implementing-maps-binary-search-trees">5.9 Implementing Maps:
Binary Search Trees</h3>
<p>Can we do better than linear time? Yes, by using a smarter data
structure. Binary search trees are binary trees with elements stored at
the interior nodes, such that elements to the left of a node are smaller
than, and elements to the right bigger than, elements within a node.
This ordering property is what makes them efficient.</p>
<p>For maps, we store key-value pairs as elements in binary search
trees, and compare the elements by keys alone. The tree structure allows
us to use “divide-and-conquer” to search for the value associated with a
key.</p>
<p>On average, binary search trees are fast – <span
class="math inline">O(\log n)</span> complexity for all operations. At
each node, we can eliminate half the remaining elements from
consideration. However, in the worst case (when keys are inserted in
sorted order), the tree degenerates into a linked list and operations
become <span class="math inline">O(n)</span>.</p>
<p>A note on our design: the simple polymorphic signature for maps is
only possible because OCaml provides polymorphic comparison (and
equality) operators that work on elements of most types (but not on
functions). These operators may not behave as you expect for all types!
Our signature for polymorphic maps is not the standard approach because
of this limitation; it is just to keep things simple for pedagogical
purposes.</p>
<p>```ocaml env=ch5 module BTreeMap : MAP = struct type (’a, ’b) t =
Empty | T of (’a, ’b) t * ’a * ’b * (’a, ’b) t</p>
<p>let empty = Empty</p>
<p>let rec member k m = (* “Divide and conquer” search through the tree.
*) match m with | Empty -&gt; false | T (<em>, k2, </em>, <em>) when k =
k2 -&gt; true | T (m1, k2, </em>, <em>) when k &lt; k2 -&gt; member k m1
| T (</em>, <em>, </em>, m2) -&gt; member k m2</p>
<p>let rec add k v m = (* Searches the tree in the same way as member
<em>) match m with (</em> but copies every node along the way. *) |
Empty -&gt; T (Empty, k, v, Empty) | T (m1, k2, _, m2) when k = k2 -&gt;
T (m1, k, v, m2) | T (m1, k2, v2, m2) when k &lt; k2 -&gt; T (add k v
m1, k2, v2, m2) | T (m1, k2, v2, m2) -&gt; T (m1, k2, v2, add k v
m2)</p>
<p>let rec split_rightmost m = (* A helper function, it does not belong
<em>) match m with (</em> to the “exported” signature. <em>) | Empty
-&gt; raise Not_found | T (Empty, k, v, Empty) -&gt; k, v, Empty (</em>
We remove one element, <em>) | T (m1, k, v, m2) -&gt; (</em> the one
that is on the bottom right. *) let rk, rv, rm = split_rightmost m2 in
rk, rv, T (m1, k, v, rm)</p>
<p>let rec remove k m = match m with | Empty -&gt; Empty | T (m1, k2,
<em>, Empty) when k = k2 -&gt; m1 | T (Empty, k2, </em>, m2) when k = k2
-&gt; m2 | T (m1, k2, _, m2) when k = k2 -&gt; let rk, rv, rm =
split_rightmost m1 in T (rm, rk, rv, m2) | T (m1, k2, v, m2) when k &lt;
k2 -&gt; T (remove k m1, k2, v, m2) | T (m1, k2, v, m2) -&gt; T (m1, k2,
v, remove k m2)</p>
<p>let rec find k m = match m with | Empty -&gt; raise Not_found | T
(<em>, k2, v, </em>) when k = k2 -&gt; v | T (m1, k2, <em>, </em>) when
k &lt; k2 -&gt; find k m1 | T (<em>, </em>, _, m2) -&gt; find k m2
end</p>
<pre><code>
The `member` and `find` functions use the &quot;divide-and-conquer&quot; strategy: compare the target key with the key at the current node, and recursively search in the appropriate subtree. The `add` function searches the tree in the same way but copies every node along the path to create the new tree (since we&#39;re using immutable data structures).

The `remove` function is trickier. When removing a node with two children, we need to replace it with another value that maintains the ordering property. The `split_rightmost` helper function finds and removes the rightmost (largest) element from a subtree -- this element is guaranteed to be smaller than everything in the right subtree and larger than everything remaining in the left subtree, making it the perfect replacement.

### 5.10 Implementing Maps: Red-Black Trees

The fatal weakness of ordinary binary search trees is that they can become unbalanced. If keys arrive in sorted order, each insertion adds a node at the bottom of a long chain, and we lose the logarithmic performance guarantee. How can we maintain balance automatically?

This section is based on Wikipedia&#39;s [Red-black tree article](http://en.wikipedia.org/wiki/Red-black_tree), Chris Okasaki&#39;s &quot;Purely Functional Data Structures&quot; and Matt Might&#39;s excellent blog post on [red-black tree deletion](http://matt.might.net/articles/red-black-delete/).

Binary search trees are good when we encounter keys in random order, because the cost of operations is limited by the depth of the tree which is small relative to the number of nodes... unless the tree grows unbalanced achieving large depth (which means there are sibling subtrees of vastly different sizes on some path).

To remedy this, we *rebalance* the tree while building it -- i.e., while adding elements. The key insight is to detect when the tree is becoming unbalanced and perform local rotations to restore balance.

In *red-black trees* we achieve balance by:
1. Remembering one of two colors (red or black) with each node
2. Keeping the same number of black nodes on every path from the root to a leaf
3. Not allowing a red node to have a red child

These invariants together guarantee that the tree cannot become too unbalanced: the depth is at most twice the depth of a perfectly balanced tree with the same number of nodes. Why? The &quot;black height&quot; (number of black nodes on any root-to-leaf path) is the same everywhere, and red nodes can only appear between black nodes, so the longest path can have at most twice as many nodes as the shortest.

#### B-trees of Order 4 (2-3-4 Trees)

To understand where red-black trees come from, it helps to first understand 2-3-4 trees (also known as B-trees of order 4).

How can we have perfectly balanced trees without worrying about having exactly $2^k - 1$ elements? The answer is to allow variable-width nodes. **2-3-4 trees** can store from 1 to 3 elements in each node and have 2 to 4 subtrees correspondingly. This flexibility lets us maintain perfect balance!

- A **2-node** contains one element and has two children
- A **3-node** contains two elements and has three children
- A **4-node** contains three elements and has four children

To insert into a 2-3-4 tree, we descend toward the appropriate leaf position. But if we encounter a full node (4-node) along the way, we &quot;split&quot; it: move the middle element up to the parent and split the remaining two elements into separate 2-nodes. This maintains perfect balance at all times -- all leaves are at the same depth.

The remarkable fact is that red-black trees are just a clever way to represent 2-3-4 trees as binary trees! To represent a 2-3-4 tree as a binary tree with one element per node, we color the &quot;primary&quot; element of each node black (the middle element of a 4-node, or the first element of a 2-/3-node) and make it the parent of its neighbor elements colored red. The red elements then become parents of the original subtrees. This correspondence provides the deep intuition behind red-black trees: the colors encode the structure of the underlying 2-3-4 tree.

#### Red-Black Trees, Without Deletion

Now let us implement red-black trees in OCaml. Red-black trees maintain two invariants:

**Invariant 1.** No red node has a red child. (No two consecutive red nodes on any path.)

**Invariant 2.** Every path from the root to an empty node contains the same number of black nodes. (The &quot;black height&quot; is uniform.)

For simplicity, we first implement red-black tree based *sets* (not maps) without deletion. The implementation proceeds almost exactly like for unbalanced binary search trees; we only need to add code to restore the invariants after each insertion.

The beautiful insight of Okasaki&#39;s approach is that by keeping balance at each step of constructing a node, it is enough to check *locally* (around the root of the subtree) whether a violation has occurred. We never need to examine the entire tree. For an understandable implementation of deletion, we need to introduce more colors -- see Matt Might&#39;s post for details.

```ocaml env=ch5
type color = R | B
type &#39;a t = E | T of color * &#39;a t * &#39;a * &#39;a t

let empty = E

let rec member x m =                     (* Like in unbalanced binary search tree. *)
  match m with
  | E -&gt; false
  | T (_, _, y, _) when x = y -&gt; true
  | T (_, a, y, _) when x &lt; y -&gt; member x a
  | T (_, _, _, b) -&gt; member x b

let balance = function                   (* Restoring the invariants. *)
  | B, T (R, T (R,a,x,b), y, c), z, d    (* On next figure: left, *)
  | B, T (R, a, x, T (R,b,y,c)), z, d    (* top, *)
  | B, a, x, T (R, T (R,b,y,c), z, d)    (* bottom, *)
  | B, a, x, T (R, b, y, T (R,c,z,d))    (* right, *)
      -&gt; T (R, T (B,a,x,b), y, T (B,c,z,d))    (* center tree. *)
  | color, a, x, b -&gt; T (color, a, x, b)   (* We allow red-red violation for now. *)

let insert x s =
  let rec ins = function                 (* Like in unbalanced binary search tree, *)
    | E -&gt; T (R, E, x, E)                (* but fix violation above created node. *)
    | T (color, a, y, b) as s -&gt;
        if x &lt; y then balance (color, ins a, y, b)
        else if x &gt; y then balance (color, a, y, ins b)
        else s
  in
  match ins s with                       (* We could still have red-red violation *)
  | T (_, a, y, b) -&gt; T (B, a, y, b)     (* at root, fixed by coloring it black. *)
  | E -&gt; failwith &quot;insert: impossible&quot;</code></pre>
<p>The <code>balance</code> function is the heart of the algorithm. It
handles four cases where a red-red violation occurs (a red node with a
red child). The four cases correspond to different positions of the
violation:</p>
<ul>
<li>A red left child with a red left grandchild</li>
<li>A red left child with a red right grandchild</li>
<li>A red right child with a red left grandchild</li>
<li>A red right child with a red right grandchild</li>
</ul>
<p>In each case, we perform a “rotation” that restructures the tree to
eliminate the violation while maintaining the binary search tree
property. Remarkably, all four cases produce the same balanced result: a
red root with two black children, with the subtrees <code>a</code>,
<code>b</code>, <code>c</code>, <code>d</code> properly distributed.</p>
<p>The <code>insert</code> function works like insertion into an
ordinary binary search tree, but calls <code>balance</code> after each
recursive step to fix any violations that may have been introduced. New
nodes are always created red (which might create a red-red violation
that <code>balance</code> will fix). At the very end, we color the root
black – this can never create a violation and ensures the root is always
black.</p>
<h3 id="exercises-3">Exercises</h3>
<p><strong>Exercise 1.</strong> Derive the equations and solve them to
find the type for:</p>
<p><code>ocaml env=ch5 let cadr l = List.hd (List.tl l) in cadr (1::2::[]), cadr (true::false::[])</code></p>
<p>in environment <span class="math inline">\Gamma = \{ \text{List.hd} :
\forall \alpha . \alpha \ \text{list} \rightarrow \alpha ;
\text{List.tl} : \forall \alpha . \alpha \ \text{list} \rightarrow
\alpha \ \text{list} \}</span>. You can take “shortcuts” if it is too
many equations to write down.</p>
<p><strong>Exercise 2.</strong> <em>Terms</em> <span
class="math inline">t_1, t_2, \ldots \in T(\Sigma, X)</span> are built
out of variables <span class="math inline">x, y, \ldots \in X</span> and
function symbols <span class="math inline">f, g, \ldots \in
\Sigma</span> the way you build values out of functions:</p>
<ul>
<li><span class="math inline">X \subset T(\Sigma, X)</span> – variables
are terms; usually an infinite set,</li>
<li>for terms <span class="math inline">t_1, \ldots, t_n \in T(\Sigma,
X)</span> and a function symbol <span class="math inline">f \in
\Sigma_n</span> of arity <span class="math inline">n</span>, <span
class="math inline">f(t_1, \ldots, t_n) \in T(\Sigma, X)</span> – bigger
terms arise from applying function symbols to smaller terms; <span
class="math inline">\Sigma = \dot{\cup}_n \Sigma_n</span> is called a
signature.</li>
</ul>
<p>In OCaml, we can define terms as:
<code>type term = V of string | T of string * term list</code>, where
for example <code>V("x")</code> is a variable <span
class="math inline">x</span> and <code>T("f", [V("x"); V("y")])</code>
is the term <span class="math inline">f(x, y)</span>.</p>
<p>By <em>substitutions</em> <span class="math inline">\sigma, \rho,
\ldots</span> we mean finite sets of variable-term pairs which we can
write as <span class="math inline">\{x_1 \mapsto t_1, \ldots, x_k
\mapsto t_k\}</span> or <span class="math inline">[x_1 := t_1; \ldots;
x_k := t_k]</span>, but also functions from terms to terms <span
class="math inline">\sigma : T(\Sigma, X) \rightarrow T(\Sigma,
X)</span> related to the pairs as follows: if <span
class="math inline">\sigma = \{x_1 \mapsto t_1, \ldots, x_k \mapsto
t_k\}</span>, then</p>
<ul>
<li><span class="math inline">\sigma(x_i) = t_i</span> for <span
class="math inline">x_i \in \{x_1, \ldots, x_k\}</span>,</li>
<li><span class="math inline">\sigma(x) = x</span> for <span
class="math inline">x \in X \setminus \{x_1, \ldots, x_k\}</span>,</li>
<li><span class="math inline">\sigma(f(t_1, \ldots, t_n)) =
f(\sigma(t_1), \ldots, \sigma(t_n))</span>.</li>
</ul>
<p>In OCaml, we can define substitutions <span
class="math inline">\sigma</span> as:
<code>type subst = (string * term) list</code>, together with a function
<code>apply : subst -&gt; term -&gt; term</code> which computes <span
class="math inline">\sigma(\cdot)</span>.</p>
<p>We say that a substitution <span class="math inline">\sigma</span> is
<em>more general</em> than all substitutions <span
class="math inline">\rho \circ \sigma</span>, where <span
class="math inline">(\rho \circ \sigma)(x) = \rho(\sigma(x))</span>. In
type inference, we are interested in most general solutions.</p>
<p>A <em>unification problem</em> is a finite set of equations <span
class="math inline">S = \{s_1 =^? t_1, \ldots, s_n =^? t_n\}</span>. A
solution, or <em>unifier</em> of <span class="math inline">S</span>, is
a substitution <span class="math inline">\sigma</span> such that <span
class="math inline">\sigma(s_i) = \sigma(t_i)</span> for <span
class="math inline">i = 1, \ldots, n</span>. A <em>most general
unifier</em>, or <em>MGU</em>, is a most general such substitution.</p>
<ol type="1">
<li><p>Implement an algorithm that, given a set of equations represented
as a list of pairs of terms, computes an idempotent most general unifier
of the equations.</p></li>
<li><p>(Ex. 4.22 in Franz Baader and Tobias Nipkow “Term Rewriting and
All That”, p. 82.) Modify the implementation of unification to achieve
linear space complexity by working with what could be called iterated
substitutions.</p></li>
</ol>
<p><strong>Exercise 3.</strong></p>
<ol type="1">
<li>What does it mean that an implementation has junk (as an algebraic
structure for a given signature)? Is it bad?</li>
<li>Define a monomorphic algebraic specification (other than, but
similar to, <span class="math inline">\text{nat}_p</span> or <span
class="math inline">\text{string}_p</span>, some useful data type).</li>
<li>Discuss an example of a (monomorphic) algebraic specification where
it would be useful to drop some axioms (giving up monomorphicity) to
allow more efficient implementations.</li>
</ol>
<p><strong>Exercise 4.</strong></p>
<ol type="1">
<li><p>Does the example <code>ListMap</code> meet the requirements of
the algebraic specification for maps? Hint: here is the definition of
<code>List.remove_assoc</code>; <code>compare a x</code> equals
<code>0</code> if and only if <code>a = x</code>.</p>
<p><code>ocaml env=ch5 let rec remove_assoc x = function   | [] -&gt; []   | (a, b as pair) :: l -&gt;       if compare a x = 0 then l else pair :: remove_assoc x l</code></p></li>
<li><p>Trick question: what is the computational complexity of
<code>ListMap</code> or <code>TrivialMap</code>?</p></li>
<li><p>(*) The implementation <code>MyListMap</code> is inefficient: it
performs a lot of copying and is not tail-recursive. Optimize it
(without changing the type definition).</p></li>
<li><p>Add (and specify) <span class="math inline">\text{isEmpty} :
(\alpha, \beta) \ \text{map} \rightarrow \text{bool}</span> to the
example algebraic specification of maps without increasing the burden on
its implementations. Hint: equational reasoning might be not enough;
consider an equivalence relation <span
class="math inline">\approx</span> meaning “have the same
keys”.</p></li>
</ol>
<p><strong>Exercise 5.</strong> Design an algebraic specification and
write a signature for first-in-first-out queues. Provide two
implementations: one straightforward using a list, and another one using
two lists: one for freshly added elements providing efficient queueing
of new elements, and “reversed” one for efficient popping of old
elements.</p>
<p><strong>Exercise 6.</strong> Design an algebraic specification and
write a signature for sets. Provide two implementations: one
straightforward using a list, and another one using a map into the unit
type.</p>
<p><strong>Exercise 7.</strong></p>
<ol type="1">
<li><p>(Ex. 2.2 in Chris Okasaki “Purely Functional Data Structures”) In
the worst case, <code>member</code> performs approximately <span
class="math inline">2d</span> comparisons, where <span
class="math inline">d</span> is the depth of the tree. Rewrite
<code>member</code> to take no more than <span class="math inline">d +
1</span> comparisons by keeping track of a candidate element that
<em>might</em> be equal to the query element (say, the last element for
which <span class="math inline">&lt;</span> returned false) and checking
for equality only when you hit the bottom of the tree.</p></li>
<li><p>(Ex. 3.10 in Chris Okasaki “Purely Functional Data Structures”)
The <code>balance</code> function currently performs several unnecessary
tests: when e.g. <code>ins</code> recurses on the left child, there are
no violations on the right child.</p>
<ul>
<li>Split <code>balance</code> into <code>lbalance</code> and
<code>rbalance</code> that test for violations of left resp. right child
only. Replace calls to <code>balance</code> appropriately.</li>
<li>One of the remaining tests on grandchildren is also unnecessary.
Rewrite <code>ins</code> so that it never tests the color of nodes not
on the search path.</li>
</ul></li>
</ol>
<p><strong>Exercise 8.</strong> (*) Implement maps (i.e. write a module
for the map signature) based on AVL trees. See
<code>http://en.wikipedia.org/wiki/AVL_tree</code>.</p>
<h2 id="chapter-6-folding-and-backtracking">Chapter 6: Folding and
Backtracking</h2>
<p><strong>In this chapter, you will:</strong></p>
<ul>
<li>Identify common recursion patterns and refactor them into
<code>map</code>/<code>fold</code> abstractions</li>
<li>Make folds tail-recursive using accumulators (and understand the
trade-offs)</li>
<li>Generalize <code>map</code>/<code>fold</code> beyond lists to trees
and expression grammars</li>
<li>Use backtracking (via lists) to solve search problems and
puzzles</li>
</ul>
<p>This chapter explores two fundamental programming paradigms in
functional programming: <strong>folding</strong> (also known as
reduction) and <strong>backtracking</strong>. We begin with the classic
<code>map</code> and <code>fold</code> higher-order functions, examine
how they generalize to trees and other data structures, then move on to
solving puzzles using backtracking with lists.</p>
<p>The material in this chapter draws from Martin Odersky’s “Functional
Programming Fundamentals,” Ralf Laemmel’s “Going Bananas,” Graham
Hutton’s “Programming in Haskell” (Chapter 11 on the Countdown Problem),
and Tomasz Wierzbicki’s Honey Islands Puzzle Solver.</p>
<h3 id="basic-generic-list-operations">6.1 Basic Generic List
Operations</h3>
<p>Functional programming emphasizes identifying common patterns and
abstracting them into reusable higher-order functions. Rather than
writing similar code repeatedly, we extract the common structure into a
single generic function. Let us see how this principle works in practice
through two motivating examples.</p>
<h4 id="the-map-function">The <code>map</code> Function</h4>
<p>How do we print a comma-separated list of integers? The
<code>String</code> module provides a function that joins strings with a
separator:</p>
<pre><code>val concat : string -&gt; string list -&gt; string</code></pre>
<p>But <code>String.concat</code> works on strings, not integers. So
first, we need to convert numbers into strings:</p>
<p>```ocaml env=ch6 let rec strings_of_ints = function | [] -&gt; [] |
hd::tl -&gt; string_of_int hd :: strings_of_ints tl</p>
<p>let comma_sep_ints = String.concat “,” -| strings_of_ints</p>
<pre><code>
Here is another common task: how do we sort strings from shortest to longest? We can pair each string with its length and then sort by the first component. First, let us compute the lengths:

```ocaml env=ch6
let rec strings_lengths = function
  | [] -&gt; []
  | hd::tl -&gt; (String.length hd, hd) :: strings_lengths tl

let by_size = List.sort compare -| strings_lengths</code></pre>
<p>Now, look carefully at <code>strings_of_ints</code> and
<code>strings_lengths</code>. Do you notice the common structure? Both
functions traverse a list and transform each element independently – one
applies <code>string_of_int</code>, the other applies a function that
pairs a string with its length. The recursive structure is identical;
only the transformation differs.</p>
<p>This is our cue to <em>extract the common pattern</em> into a generic
higher-order function. We call it <code>map</code>:</p>
<p><code>ocaml env=ch6 let rec list_map f = function   | [] -&gt; []   | hd::tl -&gt; f hd :: list_map f tl</code></p>
<p>Now we can rewrite our functions more concisely:</p>
<p>```ocaml env=ch6 let comma_sep_ints = String.concat “,” -| list_map
string_of_int</p>
<p>let by_size = List.sort compare -| list_map (fun s -&gt;
String.length s, s)</p>
<pre><code>
#### The `fold` Function

Now let us consider a different kind of pattern. How do we sum all the elements of a list?

```ocaml env=ch6
let rec balance = function
  | [] -&gt; 0
  | hd::tl -&gt; hd + balance tl</code></pre>
<p>And how do we multiply all the elements together (perhaps to compute
a cumulative ratio)?</p>
<p><code>ocaml env=ch6 let rec total_ratio = function   | [] -&gt; 1.   | hd::tl -&gt; hd *. total_ratio tl</code></p>
<p>Again, the recursive structure is the same. In both cases, we combine
each element with the result of processing the rest of the list. The
differences are: (1) what we return for the empty list (the “base case”
or “identity element”), and (2) how we combine the head with the
recursive result. This pattern is called <strong>folding</strong>:</p>
<p><code>ocaml env=ch6 let rec list_fold f base = function   | [] -&gt; base   | hd::tl -&gt; f hd (list_fold f base tl)</code></p>
<p><strong>Important:</strong> Note that <code>list_fold f base l</code>
equals <code>List.fold_right f l base</code>. The OCaml standard library
uses a different argument order, so be careful when using
<code>List.fold_right</code>.</p>
<p>The key insight is understanding the fundamental difference between
<code>map</code> and <code>fold</code>:</p>
<ul>
<li><strong><code>map</code></strong> alters the <em>contents</em> of a
data structure without changing its shape. The output list has the same
length as the input; we merely transform each element.</li>
<li><strong><code>fold</code></strong> <em>collapses</em> a data
structure down to a single value, using the structure itself as
scaffolding for the computation.</li>
</ul>
<p>Visually, consider what happens to the list
<code>[a; b; c; d]</code>:</p>
<ul>
<li><code>map f</code> transforms: <code>[a; b; c; d]</code> becomes
<code>[f a; f b; f c; f d]</code> – same structure, different
contents</li>
<li><code>fold f accu</code> collapses: <code>[a; b; c; d]</code>
becomes <code>f a (f b (f c (f d accu)))</code> – structure disappears,
single value remains</li>
</ul>
<h3 id="making-fold-tail-recursive">6.2 Making Fold Tail-Recursive</h3>
<p>Our <code>list_fold</code> function above is not tail-recursive: it
builds up a chain of deferred <code>f</code> applications on the call
stack. For very long lists, this can cause stack overflow. Can we make
folding tail-recursive?</p>
<p>Let us investigate some tail-recursive list functions to find a
pattern. Consider reversing a list:</p>
<p><code>ocaml env=ch6 let rec list_rev acc = function   | [] -&gt; acc   | hd::tl -&gt; list_rev (hd::acc) tl</code></p>
<p>The key technique here is the <em>accumulator</em> parameter
<code>acc</code>. Instead of building up work to do after the recursive
call returns, we do the work <em>before</em> the recursive call and pass
the intermediate result along.</p>
<p>Here is another example – computing an average by tracking both the
running sum and the count:</p>
<p><code>ocaml env=ch6 let rec average (sum, tot) = function   | [] when tot = 0. -&gt; 0.   | [] -&gt; sum /. tot   | hd::tl -&gt; average (hd +. sum, 1. +. tot) tl</code></p>
<p>Notice how these functions process elements from left to right,
threading an accumulator through the computation. This is the pattern of
<code>fold_left</code>:</p>
<p><code>ocaml env=ch6 let rec fold_left f accu = function   | [] -&gt; accu   | a::l -&gt; fold_left f (f accu a) l</code></p>
<p>With <code>fold_left</code>, expressing our earlier functions becomes
straightforward – we hide the accumulator inside the initial value:</p>
<p>```ocaml env=ch6 let list_rev l = fold_left (fun t h -&gt; h::t) []
l</p>
<p>let average = fold_left (fun (sum, tot) e -&gt; sum +. e, 1. +. tot)
(0., 0.)</p>
<pre><code>
Note that the `average` example is slightly trickier than `list_rev` because we need to track two values (sum and count) rather than one.

**Why the names `fold_right` and `fold_left`?** The names reflect the associativity of the combining operation:

- `fold_right f` makes `f` **right associative**, like the list constructor `::`:
  `List.fold_right f [a1; ...; an] b` is `f a1 (f a2 (... (f an b) ...))`

- `fold_left f` makes `f` **left associative**, like function application:
  `List.fold_left f a [b1; ...; bn]` is `f (... (f (f a b1) b2) ...) bn`

This &quot;backward&quot; structure of `fold_left` can be visualized by comparing the shape of the input list with the shape of the computation tree. The input list has a right-leaning spine (because `::` associates to the right), while `fold_left` produces a computation tree with a left-leaning spine:

::: {.figure}</code></pre>
<pre><code>Input list              Result computation

    ::                         f
   /  \                       / \
  a    ::                    f   d
      /  \                  / \
     b    ::               f   c
         /  \             / \
        c    ::          f   b
            /  \        / \
           d    []  accu   a</code></pre>
<pre><code>**Figure: List spine vs. fold_left computation tree**
:::

This reversal of structure is why `fold_left` naturally reverses lists when the combining operation is `cons`.

#### Useful Derived Functions

Many common list operations can be expressed elegantly using folds. List filtering selects elements satisfying a predicate -- naturally expressed using `fold_right` to preserve order:

```ocaml env=ch6
let list_filter p l =
  List.fold_right (fun h t -&gt; if p h then h::t else t) l []</code></pre>
<p>When we need a tail-recursive map and can tolerate reversed output,
<code>fold_left</code> gives us <code>rev_map</code>:</p>
<p><code>ocaml env=ch6 let list_rev_map f l =   List.fold_left (fun t h -&gt; f h :: t) [] l</code></p>
<h3 id="map-and-fold-for-trees-and-other-structures">6.3 Map and Fold
for Trees and Other Structures</h3>
<p>The <code>map</code> and <code>fold</code> patterns are not limited
to lists. They apply to any recursive data structure. The key insight is
that <code>map</code> preserves structure while transforming contents,
and <code>fold</code> collapses structure into a single value.</p>
<h4 id="binary-trees">Binary Trees</h4>
<p>Mapping binary trees is straightforward:</p>
<p>```ocaml env=ch6 type ’a btree = Empty | Node of ’a * ’a btree * ’a
btree</p>
<p>let rec bt_map f = function | Empty -&gt; Empty | Node (e, l, r)
-&gt; Node (f e, bt_map f l, bt_map f r)</p>
<p>let test = Node (3, Node (5, Empty, Empty), Node (7, Empty, Empty))
let _ = bt_map ((+) 1) test</p>
<pre><code>
**A note on terminology:** The `map` and `fold` functions we define here preserve and respect the structure of data. They are different from the `map` and `fold` operations you might find in abstract data type container libraries, which often behave more like `List.rev_map` and `List.fold_left` over container elements in arbitrary order. Here we are generalizing `List.map` and `List.fold_right` to other structures.

For binary trees, the most general form of `fold` processes each element together with the partial results already computed for its subtrees:

```ocaml env=ch6
let rec bt_fold f base = function
  | Empty -&gt; base
  | Node (e, l, r) -&gt;
    f e (bt_fold f base l) (bt_fold f base r)</code></pre>
<p>Here are two examples showing how <code>bt_fold</code> can compute
different properties of a tree:</p>
<p><code>ocaml env=ch6 let sum_els = bt_fold (fun i l r -&gt; i + l + r) 0 let depth t = bt_fold (fun _ l r -&gt; 1 + max l r) 1 t</code></p>
<p>The first computes the sum of all elements (the combining function
adds the current element to the sums of both subtrees). The second
computes the depth – we ignore the element value and take the maximum
depth of the subtrees, adding 1 for the current level.</p>
<h4 id="more-complex-structures-expressions">More Complex Structures:
Expressions</h4>
<p>Real-world data types often have more than two cases. To demonstrate
map and fold for more complex structures, let us recall the expression
type from Chapter 3:</p>
<p><code>ocaml env=ch6 type expression =     Const of float   | Var of string   | Sum of expression * expression    (* e1 + e2 *)   | Diff of expression * expression   (* e1 - e2 *)   | Prod of expression * expression   (* e1 * e2 *)   | Quot of expression * expression   (* e1 / e2 *)</code></p>
<p>The multitude of cases makes this datatype harder to work with than
binary trees. Fortunately, OCaml’s <em>or-patterns</em> help us handle
multiple similar cases together:</p>
<p><code>ocaml env=ch6 let rec vars = function   | Const _ -&gt; []   | Var x -&gt; [x]   | Sum (a,b) | Diff (a,b) | Prod (a,b) | Quot (a,b) -&gt;     vars a @ vars b</code></p>
<p>For a generic <code>map</code> and <code>fold</code> over
expressions, we need to specify behavior for each case. Since there are
many cases, we pack all the behaviors into records. This way, we can
define default behaviors and then override just the cases we care
about:</p>
<p>```ocaml env=ch6 type expression_map = { map_const : float -&gt;
expression; map_var : string -&gt; expression; map_sum : expression
-&gt; expression -&gt; expression; map_diff : expression -&gt;
expression -&gt; expression; map_prod : expression -&gt; expression
-&gt; expression; map_quot : expression -&gt; expression -&gt;
expression; }</p>
<p>(<em> Note: In expression_fold, we use ’a instead of expression
because fold produces values of arbitrary type, not necessarily
expressions. </em>) type ’a expression_fold = { fold_const : float -&gt;
’a; fold_var : string -&gt; ’a; fold_sum : ’a -&gt; ’a -&gt; ’a;
fold_diff : ’a -&gt; ’a -&gt; ’a; fold_prod : ’a -&gt; ’a -&gt; ’a;
fold_quot : ’a -&gt; ’a -&gt; ’a; }</p>
<pre><code>
Now we define standard &quot;default&quot; behaviors. The `identity_map` reconstructs the same expression (useful as a starting point when we only want to change one case), and `make_fold` creates a fold where all binary operators behave the same:

```ocaml env=ch6
let identity_map = {
  map_const = (fun c -&gt; Const c);
  map_var = (fun x -&gt; Var x);
  map_sum = (fun a b -&gt; Sum (a, b));
  map_diff = (fun a b -&gt; Diff (a, b));
  map_prod = (fun a b -&gt; Prod (a, b));
  map_quot = (fun a b -&gt; Quot (a, b));
}

let make_fold op base = {
  fold_const = (fun _ -&gt; base);
  fold_var = (fun _ -&gt; base);
  fold_sum = op; fold_diff = op;
  fold_prod = op; fold_quot = op;
}</code></pre>
<p>The actual <code>map</code> and <code>fold</code> functions:</p>
<p>```ocaml env=ch6 let rec expr_map emap = function | Const c -&gt;
emap.map_const c | Var x -&gt; emap.map_var x | Sum (a,b) -&gt;
emap.map_sum (expr_map emap a) (expr_map emap b) | Diff (a,b) -&gt;
emap.map_diff (expr_map emap a) (expr_map emap b) | Prod (a,b) -&gt;
emap.map_prod (expr_map emap a) (expr_map emap b) | Quot (a,b) -&gt;
emap.map_quot (expr_map emap a) (expr_map emap b)</p>
<p>let rec expr_fold efold = function | Const c -&gt; efold.fold_const c
| Var x -&gt; efold.fold_var x | Sum (a,b) -&gt; efold.fold_sum
(expr_fold efold a) (expr_fold efold b) | Diff (a,b) -&gt;
efold.fold_diff (expr_fold efold a) (expr_fold efold b) | Prod (a,b)
-&gt; efold.fold_prod (expr_fold efold a) (expr_fold efold b) | Quot
(a,b) -&gt; efold.fold_quot (expr_fold efold a) (expr_fold efold b)</p>
<pre><code>
Now here is the payoff. Using OCaml&#39;s `{record with field = value}` syntax, we can easily customize behaviors for specific uses by starting from the defaults and overriding just what we need:

```ocaml env=ch6
let prime_vars = expr_map
  {identity_map with map_var = fun x -&gt; Var (x ^ &quot;&#39;&quot;)}

let subst s =
  let apply x = try List.assoc x s with Not_found -&gt; Var x in
  expr_map {identity_map with map_var = apply}

let vars =
  expr_fold {(make_fold (@) []) with fold_var = fun x -&gt; [x]}

let size = expr_fold (make_fold (fun a b -&gt; 1 + a + b) 1)

let eval env = expr_fold {
  fold_const = id;
  fold_var = (fun x -&gt; List.assoc x env);
  fold_sum = (+.); fold_diff = (-.);
  fold_prod = ( *.); fold_quot = (/.);
}</code></pre>
<h3 id="point-free-programming">6.4 Point-Free Programming</h3>
<p>In 1977/78, John Backus – the designer of FORTRAN and BNF notation –
introduced <strong>FP</strong>, the first <em>function-level
programming</em> language. This was a radical departure from the
prevailing style: rather than manipulating variables and values,
programs were built entirely by combining functions. Over the next
decade, FP evolved into the <strong>FL</strong> language.</p>
<p>The philosophy behind function-level programming is captured in this
quote:</p>
<blockquote>
<p>“Clarity is achieved when programs are written at the function level
– that is, by putting together existing programs to form new ones,
rather than by manipulating objects and then abstracting from those
objects to produce programs.” – <em>The FL Project: The Design of a
Functional Language</em></p>
</blockquote>
<p>This style is sometimes called <strong>point-free</strong> or
<strong>tacit</strong> programming, because we never mention the
“points” (values) that functions operate on – we only talk about the
functions themselves and how they combine.</p>
<p>To write in this style, we need a toolkit of
<strong>combinators</strong> – higher-order functions that combine other
functions. Here are some common ones, similar to what you will find in
the <em>OCaml Batteries</em> library:</p>
<p><code>ocaml env=ch6 let const x _ = x let ( |- ) f g x = g (f x)          (* forward composition *) let ( -| ) f g x = f (g x)          (* backward composition *) let flip f x y = f y x let ( *** ) f g = fun (x,y) -&gt; (f x, g y) let ( &amp;&amp;&amp; ) f g = fun x -&gt; (f x, g x) let first f x = fst (f x) let second f x = snd (f x) let curry f x y = f (x,y) let uncurry f (x,y) = f x y</code></p>
<p>One way to understand point-free programming is to visualize the flow
of computation as a circuit. Values flow through the circuit, being
transformed by functions at each node. Cross-sections of the circuit can
be represented as tuples of intermediate values.</p>
<p>Consider this simple function that converts a character and an
integer to a string:</p>
<p><code>ocaml env=ch6 let print2 c i =   let a = Char.escaped c in   let b = string_of_int i in   a ^ b</code></p>
<p>We can visualize this as a circuit: <code>(c, i)</code> enters,
<code>c</code> flows through <code>Char.escaped</code>, <code>i</code>
flows through <code>string_of_int</code>, and the results meet at
<code>(^)</code>. In point-free style, we express this directly:</p>
<p><code>ocaml env=ch6 let print2 = curry   ((Char.escaped *** string_of_int) |- uncurry (^))</code></p>
<p>Here <code>***</code> applies two functions in parallel to the
components of a pair, <code>|-</code> is forward composition,
<code>uncurry</code> converts a curried function to take a pair, and
<code>curry</code> converts back.</p>
<p><strong>Why the name “currying”?</strong> Converting a C/Pascal-style
function (that takes all arguments as a tuple) into one that takes
arguments one at a time is called <em>currying</em>, after the logician
Haskell Brooks Curry. Since OCaml functions naturally take arguments one
at a time, we often need <code>uncurry</code> to interface with
tuple-based operations, and <code>curry</code> to convert back.</p>
<p>Another approach to point-free style avoids tuples entirely, using
function composition, <code>flip</code>, and the <strong>S</strong>
combinator:</p>
<p><code>ocaml env=ch6 let s x y z = x z (y z)</code></p>
<p>The S combinator allows us to pass one argument to two different
functions and combine their results. This can bring a particular
argument of a function to the “front” and pass it to another
function.</p>
<p>Here is an extended example showing step-by-step transformation of a
filter-map function into point-free style:</p>
<p><code>ocaml env=ch6 let func2 f g l = List.filter f (List.map g l) (* Step 1: Recognize that filter-after-map is composition *) let func2 f g = (-|) (List.filter f) (List.map g) (* Step 2: Eliminate l by composing with List.map *) let func2 f = (-|) (List.filter f) -| List.map (* Step 3: Rewrite without infix notation to see the structure *) let func2 f = (-|) ((-|) (List.filter f)) List.map (* Step 4: Use flip to rearrange arguments *) let func2 f = flip (-|) List.map ((-|) (List.filter f)) (* Step 5: Factor out f using composition *) let func2 f = (((|-) List.map) -| ((-|) -| List.filter)) f (* Step 6: Finally, f disappears (eta-reduction) *) let func2 = (|-) List.map -| ((-|) -| List.filter)</code></p>
<p>While point-free style can be elegant for simple cases, it can
quickly become obscure. Use it judiciously!</p>
<h3 id="reductions-and-more-higher-order-functions">6.5 Reductions and
More Higher-Order Functions</h3>
<p>Mathematics has a convenient notation for sums over intervals: <span
class="math inline">\sum_{n=a}^{b} f(n)</span>.</p>
<p>Can we express this in OCaml? The challenge is that OCaml does not
have a universal addition operator – <code>+</code> works only on
integers, <code>+.</code> only on floats. So we end up writing two
versions:</p>
<p>```ocaml env=ch6 let rec i_sum_fromto f a b = if a &gt; b then 0 else
f a + i_sum_fromto f (a+1) b</p>
<p>let rec f_sum_fromto f a b = if a &gt; b then 0. else f a +.
f_sum_fromto f (a+1) b</p>
<p>let pi2_over6 = f_sum_fromto (fun i -&gt; 1. /. float_of_int (i*i)) 1
5000</p>
<pre><code>
(The last example computes an approximation to $\pi^2/6$ using the Basel series.)

The natural generalization is to make the combining operation a parameter:

```ocaml env=ch6
let rec op_fromto op base f a b =
  if a &gt; b then base
  else op (f a) (op_fromto op base f (a+1) b)</code></pre>
<h4 id="collecting-results-concat_map">Collecting Results:
concat_map</h4>
<p>Sometimes a function produces not a single result but a
<em>collection</em> of results. In mathematics, such a function is
called a <strong>multifunction</strong> or set-valued function. If we
have a multifunction <span class="math inline">f</span> and want to
apply it to every element of a set <span class="math inline">A</span>,
we take the union of all results:</p>
<p><span class="math display">f(A) = \bigcup_{p \in A} f(p)</span></p>
<p>When we represent sets as lists, “union” becomes “append”. This gives
us the extremely useful <code>concat_map</code> operation:</p>
<p><code>ocaml env=ch6 let rec concat_map f = function   | [] -&gt; []   | a::l -&gt; f a @ concat_map f l</code></p>
<p>For better efficiency on long lists, here is a tail-recursive
version:</p>
<p><code>ocaml env=ch6 let concat_map f l =   let rec cmap_f accu = function     | [] -&gt; accu     | a::l -&gt; cmap_f (List.rev_append (f a) accu) l in   List.rev (cmap_f [] l)</code></p>
<p>The <code>concat_map</code> function is fundamental for backtracking
algorithms. We will use it extensively in the puzzle-solving sections
below.</p>
<h4 id="all-subsequences-of-a-list">All Subsequences of a List</h4>
<p>A classic example of a function that produces multiple results: given
a list, generate all its subsequences (subsets that preserve order). The
idea is simple: for each element, we either include it or exclude
it.</p>
<p><code>ocaml env=ch6 let rec subseqs l =   match l with     | [] -&gt; [[]]     | x::xs -&gt;       let pxs = subseqs xs in       List.map (fun px -&gt; x::px) pxs @ pxs</code></p>
<p>Tail-recursively:</p>
<p>```ocaml env=ch6 let rec rmap_append f accu = function | [] -&gt;
accu | a::l -&gt; rmap_append f (f a :: accu) l</p>
<p>let rec subseqs l = match l with | [] -&gt; [[]] | x::xs -&gt; let
pxs = subseqs xs in rmap_append (fun px -&gt; x::px) pxs pxs</p>
<pre><code>
#### Permutations and Choices

Generating all permutations of a list is another classic combinatorial problem. The key insight is the `interleave` function: given an element `x` and a list, it produces all ways of inserting `x` into the list:

```ocaml env=ch6
let rec interleave x = function
  | [] -&gt; [[x]]                 (* x can only go in one place: by itself *)
  | y::ys -&gt;
    (x::y::ys)                  (* x goes at the front, OR *)
    :: List.map (fun zs -&gt; y::zs) (interleave x ys)  (* x goes somewhere after y *)

let rec perms = function
  | [] -&gt; [[]]                  (* one way to permute empty list: empty list *)
  | x::xs -&gt; concat_map (interleave x) (perms xs)</code></pre>
<p>For example, <code>interleave 1 [2;3]</code> produces
<code>[[1;2;3]; [2;1;3]; [2;3;1]]</code> – all positions where 1 can be
inserted.</p>
<p>For the Countdown problem below, we will need all non-empty
subsequences with all their permutations – that is, all ways of choosing
and ordering elements from a list:</p>
<p><code>ocaml env=ch6 let choices l = concat_map perms (List.filter ((&lt;&gt;) []) (subseqs l))</code></p>
<h3 id="grouping-and-map-reduce">6.6 Grouping and Map-Reduce</h3>
<p>When processing large datasets, it is often useful to organize values
by some property – grouping all items with the same key together, then
processing each group. This pattern is so common it has a name:
<strong>map-reduce</strong> (popularized by Google for distributed
computing).</p>
<h4 id="collecting-by-key">Collecting by Key</h4>
<p>The first step is to collect elements from an association list,
grouping all values that share the same key:</p>
<p><code>ocaml env=ch6 let collect l =   match List.sort (fun x y -&gt; compare (fst x) (fst y)) l with   | [] -&gt; []                           (* Start with associations sorted by key *)   | (k0, v0)::tl -&gt;     let k0, vs, l = List.fold_left       (fun (k0, vs, l) (kn, vn) -&gt;     (* Collect values for current key *)         if k0 = kn then k0, vn::vs, l  (* Same key: add value to current group *)         else kn, [vn], (k0, List.rev vs)::l) (* New: save current group, start new *)       (k0, [v0], []) tl in             (* Why reverse? To preserve original order *)     List.rev ((k0, List.rev vs)::l)</code></p>
<p>Now we can group elements by an arbitrary property – we just need to
extract the property as the key:</p>
<p><code>ocaml env=ch6 let group_by p l = collect (List.map (fun e -&gt; p e, e) l)</code></p>
<h4 id="reduction-aggregation">Reduction (Aggregation)</h4>
<p>Grouping alone is often not enough – we want to <em>aggregate</em>
each group into a summary value, like SQL’s <code>SUM</code>,
<code>COUNT</code>, or <code>AVG</code>. This aggregation step is called
<strong>reduction</strong>:</p>
<p><code>ocaml env=ch6 let aggregate_by p red base l =   let ags = group_by p l in   List.map (fun (k, vs) -&gt; k, List.fold_right red vs base) ags</code></p>
<p>Using the <strong>feed-forward</strong> (pipe) operator
<code>let ( |&gt; ) x f = f x</code>:</p>
<p><code>ocaml env=ch6 let aggregate_by p redf base l =   group_by p l   |&gt; List.map (fun (k, vs) -&gt; k, List.fold_right redf vs base)</code></p>
<p>Often it is cleaner to extract both the key and the value we care
about upfront, before grouping. Since we first <strong>map</strong>
elements into key-value pairs, then group and <strong>reduce</strong>,
we call this pattern <code>map_reduce</code>:</p>
<p><code>ocaml env=ch6 let map_reduce mapf redf base l =   List.map mapf l   |&gt; collect   |&gt; List.map (fun (k, vs) -&gt; k, List.fold_right redf vs base)</code></p>
<h4 id="map-reduce-examples">Map-Reduce Examples</h4>
<p>Sometimes our mapping function produces multiple key-value pairs per
input (for example, when processing documents word by word). For this we
use <code>concat_reduce</code>, which uses <code>concat_map</code>
instead of <code>map</code>:</p>
<p><code>ocaml env=ch6 let concat_reduce mapf redf base l =   concat_map mapf l   |&gt; collect   |&gt; List.map (fun (k, vs) -&gt; k, List.fold_right redf vs base)</code></p>
<p><strong>Example 1: Word histogram.</strong> Count how many times each
word appears across a collection of documents:</p>
<p><code>ocaml env=ch6 let histogram documents =   let mapf doc =     Str.split (Str.regexp "[ \t.,;]+") doc     |&gt; List.map (fun word -&gt; word, 1) in   concat_reduce mapf (+) 0 documents</code></p>
<p><strong>Example 2: Inverted index.</strong> Build an index mapping
each word to the list of documents (identified by address) containing
it:</p>
<p>```ocaml env=ch6 let cons hd tl = hd::tl</p>
<p>let inverted_index documents = let mapf (addr, doc) = Str.split
(Str.regexp “[ ,;]+”) doc |&gt; List.map (fun word -&gt; word, addr) in
concat_reduce mapf cons [] documents</p>
<pre><code>
**Example 3: Simple search engine.** Once we have an inverted index, we can search for documents containing all of a given set of words. We need set intersection -- here implemented for sets represented as sorted lists:

```ocaml env=ch6
let intersect xs ys =                       (* Sets as sorted lists *)
  let rec aux acc = function
    | [], _ | _, [] -&gt; acc
    | (x::xs&#39; as xs), (y::ys&#39; as ys) -&gt;
      let c = compare x y in
      if c = 0 then aux (x::acc) (xs&#39;, ys&#39;)
      else if c &lt; 0 then aux acc (xs&#39;, ys)
      else aux acc (xs, ys&#39;) in
  List.rev (aux [] (xs, ys))</code></pre>
<p>Now we can build a simple search function that finds all documents
containing every word in a query:</p>
<p><code>ocaml env=ch6 let search index words =   match List.map (flip List.assoc index) words with   | [] -&gt; []   | idx::idcs -&gt; List.fold_left intersect idx idcs</code></p>
<h3 id="higher-order-functions-for-the-option-type">6.7 Higher-Order
Functions for the Option Type</h3>
<p>The <code>option</code> type is OCaml’s way of representing values
that might be absent. Rather than using null pointers (a common source
of bugs), we explicitly mark possibly-missing values with
<code>Some x</code> or <code>None</code>. Here are some useful
higher-order functions for working with options.</p>
<p>First, applying a function to an optional value:</p>
<p><code>ocaml env=ch6 let map_option f = function   | None -&gt; None   | Some e -&gt; f e</code></p>
<p>Second, mapping a partial function over a list and keeping only the
successful results:</p>
<p><code>ocaml env=ch6 let rec map_some f = function   | [] -&gt; []   | e::l -&gt; match f e with     | None -&gt; map_some f l     | Some r -&gt; r :: map_some f l</code></p>
<p>Tail-recursively:</p>
<p><code>ocaml env=ch6 let map_some f l =   let rec maps_f accu = function     | [] -&gt; accu     | a::l -&gt; maps_f (match f a with None -&gt; accu       | Some r -&gt; r::accu) l in   List.rev (maps_f [] l)</code></p>
<h3 id="the-countdown-problem-puzzle">6.8 The Countdown Problem
Puzzle</h3>
<p>Now we turn to solving puzzles, which will showcase the power of
backtracking with lists. The <strong>Countdown Problem</strong> is a
classic puzzle from a British TV game show:</p>
<ul>
<li>Using a given set of numbers and arithmetic operators +, -, *, /,
construct an expression with a given value.</li>
<li>All numbers, including intermediate results, must be positive
integers.</li>
<li>Each source number can be used at most once.</li>
</ul>
<p><strong>Example:</strong> - Source numbers: 1, 3, 7, 10, 25, 50 -
Target: 765 - One possible solution: (25-10) * (50+1) = 15 * 51 =
765</p>
<p>This example has 780 different solutions! Changing the target to 831
gives an example with no solutions at all.</p>
<p>Let us develop a solver step by step, starting with the data
types.</p>
<h4 id="data-types">Data Types</h4>
<p>```ocaml env=ch6 type op = Add | Sub | Mul | Div</p>
<p>let apply op x y = match op with | Add -&gt; x + y | Sub -&gt; x - y
| Mul -&gt; x * y | Div -&gt; x / y</p>
<p>let valid op x y = match op with | Add -&gt; true | Sub -&gt; x &gt;
y | Mul -&gt; true | Div -&gt; x mod y = 0</p>
<p>type expr = Val of int | App of op * expr * expr</p>
<p>let rec eval = function | Val n -&gt; if n &gt; 0 then Some n else
None | App (o, l, r) -&gt; eval l |&gt; map_option (fun x -&gt; eval r
|&gt; map_option (fun y -&gt; if valid o x y then Some (apply o x y)
else None))</p>
<p>let rec values = function | Val n -&gt; [n] | App (_, l, r) -&gt;
values l @ values r</p>
<p>let solution e ns n = list_diff (values e) ns = [] &amp;&amp;
is_unique (values e) &amp;&amp; eval e = Some n</p>
<pre><code>
#### Brute Force Solution

Our strategy is to generate all possible expressions from the source numbers, then filter for those that evaluate to the target. To build expressions, we need to split the numbers into two groups (for the left and right operands of an operator).

First, a helper to split a list into two non-empty parts in all possible ways:

```ocaml env=ch6
let split l =
  let rec aux lhs acc = function
    | [] | [_] -&gt; []
    | [y; z] -&gt; (List.rev (y::lhs), [z])::acc
    | hd::rhs -&gt;
      let lhs = hd::lhs in
      aux lhs ((List.rev lhs, rhs)::acc) rhs in
  aux [] [] l</code></pre>
<p>We introduce a convenient operator for working with multiple data
sources. The “bind” operator <code>|-&gt;</code> takes a list of values
and a function that produces a list from each value, then concatenates
all results:</p>
<p><code>ocaml env=ch6 let ( |-&gt; ) x f = concat_map f x</code></p>
<p>Now we can generate all expressions from a list of numbers. The
structure elegantly expresses the backtracking search:</p>
<p>```ocaml env=ch6 let combine l r = (* Combine two expressions using
each operator *) List.map (fun o -&gt; App (o, l, r)) [Add; Sub; Mul;
Div]</p>
<p>let rec exprs = function | [] -&gt; [] (* No expressions from empty
list <em>) | [n] -&gt; [Val n] (</em> Single number: just Val n <em>) |
ns -&gt; split ns |-&gt; (fun (ls, rs) -&gt; (</em> For each way to
split numbers… <em>) exprs ls |-&gt; (fun l -&gt; (</em> …for each
expression l from left half… <em>) exprs rs |-&gt; (fun r -&gt; (</em>
…for each expression r from right half… <em>) combine l r))) (</em>
…produce all l op r combinations *)</p>
<pre><code>
Read the nested `|-&gt;` as &quot;for each ... for each ... for each ...&quot;. This is the essence of backtracking: we explore all combinations systematically.

Finally, to find solutions, we try all choices of source numbers (all non-empty subsets with all orderings) and filter for expressions that evaluate to the target:

```ocaml env=ch6
let guard n =
  List.filter (fun e -&gt; eval e = Some n)

let solutions ns n =
  choices ns |-&gt; (fun ns&#39; -&gt;
    exprs ns&#39; |&gt; guard n)</code></pre>
<h4 id="optimization-fuse-generation-with-testing">Optimization: Fuse
Generation with Testing</h4>
<p>The brute force approach generates many invalid expressions (like
<code>5 - 7</code> which gives a negative result, or <code>5 / 3</code>
which is not an integer). We can do better by <em>fusing</em> generation
with evaluation: instead of generating an expression and then checking
if it is valid, we track the value alongside the expression and only
generate valid subexpressions.</p>
<p>The key insight is to work with pairs <code>(e, eval e)</code> so
that only valid subexpressions are ever generated:</p>
<p>```ocaml env=ch6 let combine’ (l, x) (r, y) = [Add; Sub; Mul; Div]
|&gt; List.filter (fun o -&gt; valid o x y) |&gt; List.map (fun o -&gt;
App (o, l, r), apply o x y)</p>
<p>let rec results = function | [] -&gt; [] | [n] -&gt; if n &gt; 0 then
[Val n, n] else [] | ns -&gt; split ns |-&gt; (fun (ls, rs) -&gt;
results ls |-&gt; (fun lx -&gt; results rs |-&gt; (fun ry -&gt; combine’
lx ry)))</p>
<p>let solutions’ ns n = choices ns |-&gt; (fun ns’ -&gt; results ns’
|&gt; List.filter (fun (e, m) -&gt; m = n) |&gt; List.map fst) (*
Discard memorized values *)</p>
<pre><code>
#### Eliminating Symmetric Cases

We can further improve performance by observing that addition and multiplication are commutative: `3 + 5` and `5 + 3` give the same result. Similarly, multiplying by 1 or adding/subtracting 0 are useless. We can eliminate these redundancies by strengthening the validity predicate:

```ocaml env=ch6
let valid op x y =
  match op with
  | Add -&gt; x &lt;= y
  | Sub -&gt; x &gt; y
  | Mul -&gt; x &lt;= y &amp;&amp; x &lt;&gt; 1 &amp;&amp; y &lt;&gt; 1
  | Div -&gt; x mod y = 0 &amp;&amp; y &lt;&gt; 1</code></pre>
<p>This eliminates symmetrical solutions on the <em>semantic</em> level
(based on values) rather than the <em>syntactic</em> level (based on
expression structure). This approach is both easier to implement and
more effective at pruning the search space.</p>
<h3 id="the-honey-islands-puzzle">6.9 The Honey Islands Puzzle</h3>
<p>Now let us tackle a different kind of puzzle that requires more
sophisticated backtracking.</p>
<p><strong>Be a bee!</strong> Imagine a honeycomb where you need to eat
honey from certain cells to prevent the remaining honey from going sour.
Sourness spreads through contact, so you want to divide the honey into
isolated “islands” – each small enough that it will be consumed before
spoiling.</p>
<p>More precisely: given a honeycomb with some cells initially marked
black (empty), mark additional cells as empty so that the remaining
(unmarked) cells form exactly <code>num_islands</code> disconnected
components, each with exactly <code>island_size</code> cells.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Task: 3 islands × 3 cells</th>
<th style="text-align: center;">Solution</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><img src="honey0.png"
style="width:45.0%" alt="Task" /></td>
<td style="text-align: center;"><img src="honey1.png"
style="width:45.0%" alt="Solution" /></td>
</tr>
</tbody>
</table>
<p>In the solution, yellow cells contain honey, black cells were
initially empty, and purple cells are the newly “eaten” cells that
separate the honey into 3 islands of 3 cells each.</p>
<h4 id="representing-the-honeycomb">Representing the Honeycomb</h4>
<p>We represent cells using Cartesian coordinates. The honeycomb
structure means that valid cells satisfy certain parity and boundary
constraints.</p>
<p>```ocaml env=ch6 type cell = int * int (* Cartesian coordinates
*)</p>
<p>module CellSet = (* Store cells in sets for efficient membership
tests *) Set.Make (struct type t = cell let compare = compare end)</p>
<p>type task = { (* For board size N, coordinates <em>) board_size :
int; (</em> range from (-2N, -N) to (2N, N) <em>) num_islands : int;
(</em> Required number of islands <em>) island_size : int; (</em>
Required cells per island <em>) empty_cells : CellSet.t; (</em>
Initially empty cells *) }</p>
<p>let cellset_of_list l = (* Convert list to set (inverse of
CellSet.elements) *) List.fold_right CellSet.add l CellSet.empty</p>
<pre><code>
**Neighborhood:** In a honeycomb, each cell has up to 6 neighbors. We filter out neighbors that are outside the board or already eaten:

```ocaml env=ch6
let even x = x mod 2 = 0

let inside_board n eaten (x, y) =
  even x = even y &amp;&amp; abs y &lt;= n &amp;&amp;
  abs x + abs y &lt;= 2*n &amp;&amp;
  not (CellSet.mem (x, y) eaten)

let neighbors n eaten (x, y) =
  List.filter
    (inside_board n eaten)
    [x-1,y-1; x+1,y-1; x+2,y;
     x+1,y+1; x-1,y+1; x-2,y]</code></pre>
<p><strong>Building the honeycomb:</strong> We generate all valid honey
cells by iterating over the coordinate range and filtering:</p>
<p><code>ocaml env=ch6 let honey_cells n eaten =   fromto (-2*n) (2*n) |-&gt; (fun x -&gt;     fromto (-n) n |-&gt; (fun y -&gt;      pred_guard (inside_board n eaten)         (x, y)))</code></p>
<h4 id="drawing-honeycombs">Drawing Honeycombs</h4>
<p>To visualize the honeycomb, we generate colored polygons. Each cell
is drawn as a hexagon by placing 6 points evenly spaced on a
circumcircle:</p>
<p><code>ocaml env=ch6 let draw_honeycomb ~w ~h task eaten =   let i2f = float_of_int in   let nx = i2f (4 * task.board_size + 2) in   let ny = i2f (2 * task.board_size + 2) in   let radius = min (i2f w /. nx) (i2f h /. ny) in   let x0 = w / 2 in   let y0 = h / 2 in   let dx = (sqrt 3. /. 2.) *. radius +. 1. in  (* Distance between *)   let dy = (3. /. 2.) *. radius +. 2. in       (* (x,y) and (x+1,y+1) *)   let draw_cell (x, y) =     Array.init 7                               (* Draw a closed polygon *)       (fun i -&gt;                            (* with 6 points evenly spaced *)         let phi = float_of_int i *. Float.pi /. 3. in   (* on circumcircle *)         x0 + int_of_float (radius *. sin phi +. float_of_int x *. dx),         y0 + int_of_float (radius *. cos phi +. float_of_int y *. dy)) in   let honey =     honey_cells task.board_size (CellSet.union task.empty_cells                                    (cellset_of_list eaten))     |&gt; List.map (fun p -&gt; draw_cell p, (255, 255, 0)) in   (* Yellow cells *)   let eaten = List.map     (fun p -&gt; draw_cell p, (50, 0, 50)) eaten in           (* Purple: eaten *)   let old_empty = List.map     (fun p -&gt; draw_cell p, (0, 0, 0))                      (* Black: empty *)     (CellSet.elements task.empty_cells) in   honey @ eaten @ old_empty</code></p>
<p><strong>Drawing to SVG:</strong> We can render the polygons to an SVG
image file:</p>
<p><code>ocaml env=ch6 let draw_to_svg file ~w ~h ?title ?desc curves =   let f = open_out file in   Printf.fprintf f "&lt;?xml version=\"1.0\" standalone=\"no\"?&gt; &lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"   \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt; &lt;svg width=\"%d\" height=\"%d\" viewBox=\"0 0 %d %d\"     xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; " w h w h;   (match title with None -&gt; ()   | Some title -&gt; Printf.fprintf f "  &lt;title&gt;%s&lt;/title&gt;\n" title);   (match desc with None -&gt; ()   | Some desc -&gt; Printf.fprintf f "  &lt;desc&gt;%s&lt;/desc&gt;\n" desc);   let draw_shape (points, (r, g, b)) =     uncurry (Printf.fprintf f "  &lt;path d=\"M %d %d") points.(0);     Array.iteri (fun i (x, y) -&gt;       if i &gt; 0 then Printf.fprintf f " L %d %d" x y) points;     Printf.fprintf f "\"\n       fill=\"rgb(%d, %d, %d)\" stroke-width=\"3\" /&gt;\n"       r g b in   List.iter draw_shape curves;   Printf.fprintf f "&lt;/svg&gt;%!"</code></p>
<p><strong>Drawing to screen:</strong> We can also draw interactively
using the <em>Bogue</em> library. Note that Bogue does not directly
support filled polygons, so we draw hexagons as line segments.</p>
<p><code>ocaml env=ch6 let draw_to_screen ~w ~h curves =   let open Bogue in   let area_widget = Widget.sdl_area ~w ~h () in   let area = Widget.get_sdl_area area_widget in   (* Queue drawing commands for when the area is rendered *)   Sdl_area.add area (fun _renderer -&gt;     (* Draw brown background *)     Sdl_area.fill_rectangle area ~color:(Draw.opaque (Draw.find_color "saddlebrown"))       ~w ~h (0, 0);     (* Draw each hexagon as connected line segments *)     List.iter (fun (points, (r, g, b)) -&gt;       let color = Draw.opaque (r, g, b) in       let n = Array.length points in       for i = 0 to n - 2 do         let (x0, y0) = points.(i) in         let (x1, y1) = points.(i + 1) in         (* Flip y-coordinate: Bogue uses top-left origin *)         Sdl_area.draw_line area ~color ~thick:3 (x0, h - y0) (x1, h - y1)       done) curves);   let layout = Layout.resident area_widget in   let board = Main.of_layout layout in   Main.run board</code></p>
<h4 id="testing-correctness">Testing Correctness</h4>
<p>Before generating solutions, let us write code to <em>test</em>
whether a proposed solution is correct. We walk through each island
counting its cells using depth-first search: having visited everything
reachable in one direction, we check whether any unvisited cells
remain.</p>
<p>```ocaml env=ch6 let check_correct n island_size num_islands
empty_cells = let honey = honey_cells n empty_cells in</p>
<p>let rec check_board been_islands unvisited visited = match unvisited
with | [] -&gt; been_islands = num_islands | cell::remaining when
CellSet.mem cell visited -&gt; check_board been_islands remaining
visited (* Keep looking <em>) | cell::remaining (</em> when not visited
<em>) -&gt; let (been_size, unvisited, visited) = check_island cell
(</em> Visit another island *) (1, remaining, CellSet.add cell visited)
in been_size = island_size &amp;&amp; check_board (been_islands+1)
unvisited visited</p>
<p>and check_island current state = neighbors n empty_cells current
|&gt; List.fold_left (* Walk into each direction <em>) (fun (been_size,
unvisited, visited as state) neighbor -&gt; if CellSet.mem neighbor
visited then state else let unvisited = remove neighbor unvisited in let
visited = CellSet.add neighbor visited in let been_size = been_size + 1
in check_island neighbor (been_size, unvisited, visited)) state in
(</em> Initial been_size is 1 *)</p>
<p>check_board 0 honey empty_cells</p>
<pre><code>
#### Multiple Results per Step: concat_fold

When processing lists, sometimes each step can produce multiple results (not just one as in `fold_left`, or many independent ones as in `concat_map`). We need a hybrid: process elements sequentially like `fold_left`, but allow multiple results at each step, collecting all the final states.

This is `concat_fold`:

```ocaml env=ch6
let rec concat_fold f a = function
  | [] -&gt; [a]
  | x::xs -&gt;
    f x a |-&gt; (fun a&#39; -&gt; concat_fold f a&#39; xs)</code></pre>
<h4 id="generating-solutions">Generating Solutions</h4>
<p>The key insight is that we can transform the <em>testing</em> code
into <em>generation</em> code by:</p>
<ol type="1">
<li>Passing around the current partial solution (the <code>eaten</code>
list)</li>
<li>Returning results in a list (empty list means no solutions from this
path)</li>
<li>At each neighbor cell, exploring <em>both</em> possibilities: eating
it (adding to <code>eaten</code>) or keeping it as honey (continuing to
walk the island)</li>
</ol>
<p>```ocaml env=ch6 let find_to_eat n island_size num_islands
empty_cells = let honey = honey_cells n empty_cells in</p>
<p>let rec find_board been_islands unvisited visited eaten = match
unvisited with | [] -&gt; if been_islands = num_islands then [eaten]
else [] | cell::remaining when CellSet.mem cell visited -&gt; find_board
been_islands remaining visited eaten | cell::remaining (* when not
visited <em>) -&gt; find_island cell (1, remaining, CellSet.add cell
visited, eaten) |-&gt; (</em> Concatenate solutions *) (fun (been_size,
unvisited, visited, eaten) -&gt; if been_size = island_size then
find_board (been_islands+1) unvisited visited eaten else [])</p>
<p>and find_island current state = neighbors n empty_cells current |&gt;
concat_fold (* Multiple results <em>) (fun neighbor (been_size,
unvisited, visited, eaten as state) -&gt; if CellSet.mem neighbor
visited then [state] else let unvisited = remove neighbor unvisited in
let visited = CellSet.add neighbor visited in (been_size, unvisited,
visited, neighbor::eaten):: (</em> solutions where neighbor is honey *)
find_island neighbor (been_size+1, unvisited, visited, eaten)) state
in</p>
<p>find_board 0 honey empty_cells []</p>
<pre><code>
#### Optimizations

The brute-force generation explores far too many possibilities. The key optimization principle is: **fail (drop solution candidates) as early as possible**.

Instead of blindly exploring all choices, we add guards to prune branches that cannot lead to solutions:

- Do not try to eat more cells if we have already eaten enough
- Do not add more cells to an island that is already full
- Track exactly how many cells still need to be eaten

```ocaml env=ch6
type state = {
  been_size: int;                           (* Honey cells in current island *)
  been_islands: int;                        (* Islands visited so far *)
  unvisited: cell list;                     (* Cells to visit *)
  visited: CellSet.t;                       (* Already visited *)
  eaten: cell list;                         (* Current solution candidate *)
  more_to_eat: int;                         (* Remaining cells to eat *)
}

let rec visit_cell s =
  match s.unvisited with
  | [] -&gt; None
  | c::remaining when CellSet.mem c s.visited -&gt;
    visit_cell {s with unvisited=remaining}
  | c::remaining (* when c not visited *) -&gt;
    Some (c, {s with
      unvisited=remaining;
      visited = CellSet.add c s.visited})

let eat_cell c s =
  {s with eaten = c::s.eaten;
    visited = CellSet.add c s.visited;
    more_to_eat = s.more_to_eat - 1}

let keep_cell c s =                         (* c is actually unused *)
  {s with been_size = s.been_size + 1;
    visited = CellSet.add c s.visited}

let fresh_island s =                 (* Increment been_size at start of find_island *)
  {s with been_size = 0;
    been_islands = s.been_islands + 1}

let init_state unvisited more_to_eat = {
  been_size = 0; been_islands = 0;
  unvisited; visited = CellSet.empty;
  eaten = []; more_to_eat;
}</code></pre>
<p>The optimized island loop only tries actions that make sense:</p>
<pre><code>  and find_island current s =
    let s = keep_cell current s in
    neighbors n empty_cells current
    |&gt; concat_fold
        (fun neighbor s -&gt;
          if CellSet.mem neighbor s.visited then [s]
          else
            let choose_eat =                (* Guard against failed actions *)
              if s.more_to_eat = 0 then []
              else [eat_cell neighbor s]
            and choose_keep =
              if s.been_size &gt;= island_size then []
              else find_island neighbor s in
            choose_eat @ choose_keep)
        s in
  (* Finally, compute the required eaten cells and start searching *)
  let cells_to_eat =
    List.length honey - island_size * num_islands in
  find_board (init_state honey cells_to_eat)</code></pre>
<h3 id="constraint-based-puzzles">6.10 Constraint-Based Puzzles</h3>
<p>Many puzzles can be understood in terms of <strong>constraint
satisfaction</strong>:</p>
<ol type="1">
<li>The puzzle defines the <em>general form</em> of solutions (what
variables need values)</li>
<li>The puzzle specifies <em>constraints</em> that valid solutions must
satisfy</li>
</ol>
<p>For example, in Sudoku, the variables are the 81 cells, each with
domain {1,…,9}, and the constraints require each row, column, and 3x3
box to contain all digits exactly once.</p>
<p>In the Honey Islands puzzle, we could view each cell as a variable
with domain {Honey, Empty}. The constraints specify which cells must be
empty initially, and the requirement of forming a specific number and
size of connected components.</p>
<h4 id="finite-domain-constraint-programming">Finite Domain Constraint
Programming</h4>
<p><strong>Constraint propagation</strong> is a powerful technique for
solving such puzzles efficiently. The key idea is to track <em>sets of
possible values</em> for each variable and systematically eliminate
impossibilities:</p>
<ol type="1">
<li><p><strong>Initialize:</strong> For each variable, start with the
full set of possible values (its domain). The current “partial solution”
is this collection of sets.</p></li>
<li><p><strong>Propagate and split:</strong> Repeat until all variables
have exactly one value:</p>
<ul>
<li><ol type="a">
<li><strong>Propagate constraints:</strong> If some value for a variable
is inconsistent with <em>all</em> possible values of related variables,
remove it</li>
</ol></li>
<li><ol start="2" type="a">
<li><strong>Prune failures:</strong> If any variable has an empty set of
possible values, this partial solution has no completions – abandon
it</li>
</ol></li>
<li><ol start="3" type="a">
<li><strong>Split:</strong> Select a variable with multiple possible
values. Create new partial solutions by partitioning its possibilities
(simplest: try each value separately, or split into “this value” vs “all
others”)</li>
</ol></li>
</ul></li>
<li><p><strong>Extract solutions:</strong> When all variables have
single values, we have found a solution.</p></li>
</ol>
<p>The efficiency comes from <em>early pruning</em>: constraint
propagation often eliminates many possibilities without explicitly
trying them, dramatically reducing the search space compared to
brute-force enumeration.</p>
<h3 id="exercises-4">6.11 Exercises</h3>
<ol type="1">
<li><p>Recall how we generated all subsequences of a list. Find
(generate) all:</p>
<ul>
<li>permutations of a list</li>
<li>ways of choosing without repetition from a list</li>
<li>combinations of K distinct objects chosen from N elements of a
list</li>
</ul></li>
<li><p>Using folding for the <code>expression</code> data type, compute
the degree of the corresponding polynomial.</p></li>
<li><p>Implement simplification of expressions using mapping for the
<code>expression</code> data type.</p></li>
<li><p>Express in terms of <code>fold_left</code> or
<code>fold_right</code>:</p>
<ul>
<li><code>indexed : 'a list -&gt; (int * 'a) list</code>, which pairs
elements with their indices</li>
<li><code>concat_fold</code> as used in Honey Islands</li>
<li>Run-length encoding of a list:
<code>encode ['a;'a;'a;'a;'b;'c;'c;'a;'a;'d] = [4,'a; 1,'b; 2,'c; 2,'a; 1,'d]</code></li>
</ul></li>
<li><p>Write more efficient variants:</p>
<ul>
<li><code>list_diff</code> computing difference of sets represented as
sorted lists</li>
<li><code>is_unique</code> in constant stack space</li>
</ul></li>
<li><p>Write functions <code>compose</code> and <code>perform</code>
that take a list of functions and return their composition:</p>
<ul>
<li><code>compose [f1; ...; fn] = x -&gt; f1 (... (fn x)...)</code></li>
<li><code>perform [f1; ...; fn] = x -&gt; fn (... (f1 x)...)</code></li>
</ul></li>
<li><p>Write a solver for the <em>Tents Puzzle</em>.</p></li>
<li><p><strong>Robot Squad</strong> (harder): Given a map with walls and
lidar readings (8 directions: E, NE, N, NW, W, SW, S, SE) for multiple
robots, determine possible robot positions.</p></li>
<li><p>Write a solver for the <em>Plinx Puzzle</em> (does not need to
solve all levels, but should handle initial ones).</p></li>
</ol>
<h2 id="chapter-7-laziness">Chapter 7: Laziness</h2>
<p><em>“Today’s lecture is about lazy evaluation. Thank you for coming,
goodbye!”</em></p>
<p>Well, perhaps you have some questions? This chapter explores one of
the most elegant ideas in functional programming: lazy evaluation. By
deferring computation until results are actually needed, we unlock
powerful techniques for working with infinite data structures, solving
differential equations symbolically, and building sophisticated
stream-processing pipelines.</p>
<p>We will examine different evaluation strategies, implement streams
and lazy lists, apply them to power series computation and differential
equations, build circular data structures, and develop a sophisticated
pipe-based pretty-printer. Along the way, we will see how laziness
transforms the way we think about computation itself.</p>
<p><strong>In this chapter, you will:</strong></p>
<ul>
<li>Distinguish evaluation strategies (call-by-value/name/need) and
their consequences</li>
<li>Build infinite data structures safely using streams and lazy
values</li>
<li>Apply laziness to nontrivial examples (power series, differential
equations, pretty-printing)</li>
<li>Learn where laziness interacts poorly with effects (I/O) and how to
reason about it</li>
</ul>
<h3 id="evaluation-strategies-and-parameter-passing">7.1 Evaluation
Strategies and Parameter Passing</h3>
<p><strong>Evaluation strategy</strong> is the order in which
expressions are computed – primarily, when arguments are computed.
Recall our problems with using <em>flow control</em> expressions like
<code>if_then_else</code> in examples from the lambda-calculus lecture.
There are many technical terms describing various evaluation
strategies:</p>
<p><strong>Strict evaluation</strong>: Arguments are always evaluated
completely before the function is applied.</p>
<p><strong>Non-strict evaluation</strong>: Arguments are not evaluated
unless they are actually used in the evaluation of the function
body.</p>
<p><strong>Eager evaluation</strong>: An expression is evaluated as soon
as it gets bound to a variable.</p>
<p><strong>Lazy evaluation</strong>: Non-strict evaluation which avoids
repeating computation.</p>
<p><strong>Call-by-value</strong>: The argument expression is evaluated,
and the resulting value is bound to the corresponding variable in the
function (frequently by copying the value into a new memory region).</p>
<p><strong>Call-by-reference</strong>: A function receives an implicit
reference to a variable used as argument, rather than a copy of its
value. In purely functional languages there is no difference between the
two strategies, so they are typically described as call-by-value even
though implementations use call-by-reference internally for efficiency.
Call-by-value languages like C and OCaml support explicit references
(objects that refer to other objects), and these can be used to simulate
call-by-reference.</p>
<p><strong>Normal order</strong>: Start computing function bodies before
evaluating their arguments. Do not even wait for arguments if they are
not needed.</p>
<p><strong>Call-by-name</strong>: Arguments are substituted directly
into the function body and then left to be evaluated whenever they
appear in the function. This means an argument might be evaluated
multiple times if it appears multiple times in the function body.</p>
<p><strong>Call-by-need</strong>: If the function argument is evaluated,
that value is stored for subsequent uses. This avoids the redundant
recomputation that can occur with call-by-name.</p>
<p>Almost all languages do not compute inside the body of an un-applied
function, but with curried functions you can pre-compute data before all
arguments are provided (recall the <code>search_bible</code> example
from earlier lectures, where preprocessing happened when the first
argument was supplied).</p>
<p>In eager / call-by-value languages we can simulate call-by-name by
taking a function to compute the value as an argument instead of the
value directly. “Our” languages have a <code>unit</code> type with a
single value <code>()</code> specifically for use as throw-away
arguments – we pass <code>fun () -&gt; expensive_computation</code>
instead of <code>expensive_computation</code> directly. Scala has
built-in support for call-by-name (i.e. direct, without the need to
build argument functions).</p>
<p>OCaml (like most ML-family languages) is <em>strict by default</em>
but provides explicit laziness (<code>lazy</code>,
<code>Lazy.force</code>, and <code>Lazy.t</code>) when you want it.
Haskell is <em>lazy by default</em> but provides explicit strictness
(e.g. <code>seq</code>, strict fields, bang patterns) when you need it.
This reflects the different design philosophies: OCaml defaults to
strict evaluation with opt-in laziness, while Haskell defaults to lazy
evaluation with opt-in strictness.</p>
<h3 id="call-by-name-streams">7.2 Call-by-name: Streams</h3>
<p>Call-by-name is useful not only for implementing flow control.
Remember how we struggled to define <code>if_then_else</code> as a
regular function in the lambda calculus lecture? The problem was that
both branches would be evaluated before the function could choose
between them. With call-by-name simulation, we can finally make it
work:</p>
<p><code>ocaml env=ch7 let if_then_else cond e1 e2 =   match cond with   | true -&gt; e1 ()   | false -&gt; e2 ()</code></p>
<p>Here <code>e1</code> and <code>e2</code> are functions that compute
their respective branches only when called. But call-by-name is useful
for more than just flow control – it also enables lazy data
structures.</p>
<p><strong>Streams</strong> are lists with call-by-name tails:</p>
<p><code>ocaml env=ch7 type 'a stream = SNil | SCons of 'a * (unit -&gt; 'a stream)</code></p>
<p>The key insight is that the tail is not a stream directly, but a
<em>function</em> that produces a stream when called. This means the
tail is not computed until we actually need it. Reading from a stream
into a regular list forces evaluation of the requested elements:</p>
<p><code>ocaml env=ch7 let rec stake n = function   | SCons (a, s) when n &gt; 0 -&gt; a :: (stake (n-1) (s ()))   | _ -&gt; []</code></p>
<p>Notice how we call <code>s ()</code> to get the next portion of the
stream. This is where the “lazy” computation happens. Because of this
delayed evaluation, streams can easily be infinite:</p>
<p>```ocaml env=ch7 let rec s_ones = SCons (1, fun () -&gt; s_ones)</p>
<p>let rec s_from n = SCons (n, fun () -&gt; s_from (n+1))</p>
<pre><code>
The stream `s_ones` is an infinite sequence of 1s -- it refers to itself as its own tail! The stream `s_from n` produces all integers starting from `n`. These definitions would cause infinite loops in a strict language, but with streams, we only compute as much as we request.

#### Stream Operations

Just as we can define higher-order functions on lists, streams admit similar operations. The key difference is that we must wrap recursive calls in functions to maintain laziness:

```ocaml env=ch7
let rec smap f = function
  | SNil -&gt; SNil
  | SCons (a, s) -&gt; SCons (f a, fun () -&gt; smap f (s ()))

let rec szip = function
  | SNil, SNil -&gt; SNil
  | SCons (a1, s1), SCons (a2, s2) -&gt;
      SCons ((a1, a2), fun () -&gt; szip (s1 (), s2 ()))
  | _ -&gt; raise (Invalid_argument &quot;szip&quot;)</code></pre>
<p>Streams can provide scaffolding for recursive algorithms, enabling
elegant definitions that would be impossible with strict data
structures. Consider the Fibonacci sequence:</p>
<p><code>ocaml env=ch7 let rec sfib =   SCons (1, fun () -&gt; smap (fun (a,b) -&gt; a+b)     (szip (sfib, SCons (1, fun () -&gt; sfib))))</code></p>
<p>This remarkably concise definition creates a stream where each
element is computed by adding pairs from the current stream and itself
shifted by one position. The stream effectively “builds itself” by
referring to its own earlier elements:</p>
<table>
<thead>
<tr>
<th>sfib</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>5</th>
<th>8</th>
<th>13</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr>
<td>sfib</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>8</td>
<td>13</td>
<td>…</td>
</tr>
<tr>
<td>shifted</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>8</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>The <code>+</code> operation between corresponding elements produces
the next values.</p>
<h4 id="streams-and-input-output">Streams and Input-Output</h4>
<p>Streams can be used to read from files lazily, but there is a catch –
they are less functional than one might expect in the context of
input-output effects:</p>
<p><code>ocaml env=ch7 let file_stream name =   let ch = open_in name in   let rec ch_read_line () =     try SCons (input_line ch, ch_read_line)     with End_of_file -&gt; SNil in   ch_read_line ()</code></p>
<p>The problem is that reading from a file is a side effect. If you
traverse the stream twice, you will not get the same results – the file
handle advances with each read. This is why <em>OCaml Batteries</em>
uses a stream type <code>enum</code> for interfacing between various
sequence-like data types, with careful documentation about when streams
can be safely reused.</p>
<p>The safest way to use streams is in a <em>linear</em> or
<em>ephemeral</em> manner: every value used only once. Streams minimize
space consumption at the expense of time for recomputation – if you need
to traverse the data multiple times, you will recompute it each time.
For data that should be computed once and accessed multiple times, we
need lazy lists.</p>
<h3 id="lazy-values">7.3 Lazy Values</h3>
<p>Lazy evaluation is more general than call-by-need as any value can be
lazy, not only a function parameter. While streams give us call-by-name
semantics (recomputing on each access), lazy values give us call-by-need
semantics (computing once and caching the result).</p>
<p>A <em>lazy value</em> is a value that “holds” an expression until its
result is needed, and from then on it “holds” the result. It is also
called a <em>suspension</em>. If it holds the expression (not yet
evaluated), it is called a <em>thunk</em> – a placeholder waiting to
become a real value.</p>
<p>In OCaml, we build lazy values explicitly using the <code>lazy</code>
keyword. In Haskell, all values are lazy by default, but functions can
have call-by-value parameters which “need” (force evaluation of) the
argument.</p>
<p>To create a lazy value: <code>lazy expr</code> – where
<code>expr</code> is the suspended computation. The expression
<code>expr</code> is not evaluated when the lazy value is created; it is
stored for later.</p>
<p>There are two ways to use a lazy value. Be careful to understand when
the result is computed! - In expressions: <code>Lazy.force l_expr</code>
– explicitly forces evaluation - In patterns:
<code>match l_expr with lazy v -&gt; ...</code> – forces evaluation
during pattern matching - Syntactically <code>lazy</code> behaves like a
data constructor, which is why it can appear in patterns.</p>
<h4 id="lazy-lists">Lazy Lists</h4>
<p>Lazy lists are the “memoizing” version of streams. Instead of a
function that recomputes the tail each time, we use a lazy value that
computes it once:</p>
<p><code>ocaml env=ch7 type 'a llist = LNil | LCons of 'a * 'a llist Lazy.t</code></p>
<p>The tail is of type <code>'a llist Lazy.t</code> – a lazy value that
will produce the rest of the list when forced. Reading from a lazy list
into a regular list forces evaluation of just the elements we need:</p>
<p><code>ocaml env=ch7 let rec ltake n = function   | LCons (a, lazy l) when n &gt; 0 -&gt; a :: (ltake (n-1) l)   | _ -&gt; []</code></p>
<p>Notice the <code>lazy l</code> pattern – this forces evaluation of
the lazy tail and binds the result to <code>l</code>. Lazy lists can
easily be infinite, just like streams:</p>
<p>```ocaml env=ch7 let rec l_ones = LCons (1, lazy l_ones)</p>
<p>let rec l_from n = LCons (n, lazy (l_from (n+1)))</p>
<pre><code>
The crucial difference from streams is that lazy lists support &quot;read once, access multiple times&quot; semantics. Once a portion of the list has been computed, subsequent accesses return the cached result:

```ocaml env=ch7
let file_llist name =
  let ch = open_in name in
  let rec ch_read_line () =
    try LCons (input_line ch, lazy (ch_read_line ()))
    with End_of_file -&gt; LNil in
  ch_read_line ()</code></pre>
<p>With <code>file_llist</code>, you can traverse the resulting list
multiple times and get the same data each time (as long as you keep a
reference to the head of the list). The file is read lazily, but each
line is cached after being read.</p>
<h4 id="lazy-list-operations">Lazy List Operations</h4>
<p>We can define the familiar higher-order functions on lazy lists.
Notice the subtle but important difference from streams – we must use
<code>Lazy.force</code> to access the lazy tail before passing it to
recursive calls:</p>
<p>```ocaml env=ch7 let rec lzip = function | LNil, LNil -&gt; LNil |
LCons (a1, ll1), LCons (a2, ll2) -&gt; LCons ((a1, a2), lazy ( lzip
(Lazy.force ll1, Lazy.force ll2))) | _ -&gt; raise (Invalid_argument
“lzip”)</p>
<p>let rec lmap f = function | LNil -&gt; LNil | LCons (a, ll) -&gt;
LCons (f a, lazy (lmap f (Lazy.force ll)))</p>
<pre><code>
Using these operations, we can define the factorial sequence in a beautifully self-referential way:

```ocaml env=ch7
let posnums = l_from 1

let rec lfact =
  LCons (1, lazy (lmap (fun (a,b) -&gt; a*b)
                    (lzip (lfact, posnums))))</code></pre>
<p>This produces: 1, 1, 2, 6, 24, 120, … The definition is elegant: each
factorial is the product of the previous factorial and the corresponding
positive integer. The lazy list <code>lfact</code> refers to itself to
get the previous factorials!</p>
<table>
<thead>
<tr>
<th>lfact</th>
<th>1</th>
<th>1</th>
<th>2</th>
<th>6</th>
<th>24</th>
<th>120</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr>
<td>lfact</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>6</td>
<td>24</td>
<td>120</td>
<td>…</td>
</tr>
<tr>
<td>posnums</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>The <code>*</code> operation between corresponding elements produces
the next values.</p>
<h3 id="power-series-and-differential-equations">7.4 Power Series and
Differential Equations</h3>
<p>This section presents a fascinating application of lazy lists:
computing power series and solving differential equations symbolically.
The differential equations idea is due to Henning Thielemann, and
demonstrates the expressive power of lazy evaluation.</p>
<p>The expression <span class="math inline">P(x) = \sum_{i=0}^{n} a_i
x^i</span> defines a polynomial when <span class="math inline">n &lt;
\infty</span> and a power series when <span class="math inline">n =
\infty</span>. We can represent both as lazy lists of coefficients <span
class="math inline">[a_0; a_1; a_2; \ldots]</span>.</p>
<p>If we define:</p>
<p><code>ocaml env=ch7 let rec lfold_right f l base =   match l with     | LNil -&gt; base     | LCons (a, lazy l) -&gt; f a (lfold_right f l base)</code></p>
<p>then we can compute polynomials using Horner’s method. Horner’s
method evaluates polynomials efficiently by factoring out powers of
<span class="math inline">x</span>: instead of computing <span
class="math inline">a_0 + a_1 x + a_2 x^2 + \ldots</span>, we compute
<span class="math inline">a_0 + x(a_1 + x(a_2 + \ldots))</span>:</p>
<p><code>ocaml env=ch7 let horner x l =   lfold_right (fun c sum -&gt; c +. x *. sum) l 0.</code></p>
<p>But this will not work for infinite power series! Two natural
questions arise: - Does it make sense to compute the value at <span
class="math inline">x</span> of a power series? - Does it make sense to
fold an infinite list?</p>
<p>The answer to both is “yes, sometimes.” If the power series converges
for <span class="math inline">x &gt; 1</span>, then when the elements
<span class="math inline">a_n</span> get small, the remaining sum <span
class="math inline">\sum_{i=n}^{\infty} a_i x^i</span> is also small. We
can truncate the computation when the contribution becomes
negligible.</p>
<p>The problem is that <code>lfold_right</code> falls into an infinite
loop on infinite lists – it tries to reach the end before computing
anything. We need call-by-name / call-by-need semantics for the argument
function <code>f</code>, so it can decide to stop early:</p>
<p><code>ocaml env=ch7 let rec lazy_foldr f l base =   match l with     | LNil -&gt; base     | LCons (a, ll) -&gt;       f a (lazy (lazy_foldr f (Lazy.force ll) base))</code></p>
<p>Now we need a stopping condition in the Horner algorithm step. We
stop when the coefficient becomes small enough that further terms are
negligible:</p>
<p>```ocaml env=ch7 let lhorner x l = (* This is a bit of a hack: <em>)
let upd c sum = (</em> we hope to “hit” the interval (0, epsilon]. <em>)
if c = 0. || abs_float c &gt; epsilon_float then c +. x </em>.
Lazy.force sum else 0. in (* Stop when c is tiny but nonzero. *)
lazy_foldr upd l 0.</p>
<p>let inv_fact = lmap (fun n -&gt; 1. /. float_of_int n) lfact let e =
lhorner 1. inv_fact</p>
<pre><code>
The `inv_fact` list contains $[1/0!; 1/1!; 1/2!; \ldots]$, which is the power series for $e^x$. Evaluating `lhorner 1. inv_fact` computes $e^1 = e$.

#### Power Series / Polynomial Operations

To work with power series, we need to define arithmetic operations on lazy lists of coefficients. For floating-point coefficients, we first need a float-based version of positive numbers:

```ocaml env=ch7
let rec l_from_f n = LCons (n, lazy (l_from_f (n +. 1.)))
let posnums_f = l_from_f 1.

(* Unary negation for series *)
let (~-:) = lmap (fun x -&gt; -.x)</code></pre>
<p>Now we can define the basic arithmetic operations on power series.
Addition and subtraction work coefficient-wise:</p>
<p>```ocaml env=ch7 let rec add xs ys = match xs, ys with | LNil, _
-&gt; ys | _, LNil -&gt; xs | LCons (x,xs), LCons (y,ys) -&gt; LCons (x
+. y, lazy (add (Lazy.force xs) (Lazy.force ys)))</p>
<p>let rec sub xs ys = match xs, ys with | LNil, _ -&gt; lmap (fun x
-&gt; -.x) ys | _, LNil -&gt; xs | LCons (x,xs), LCons (y,ys) -&gt;
LCons (x -. y, lazy (add (Lazy.force xs) (Lazy.force ys)))</p>
<p>let scale s = lmap (fun x -&gt; s *. x)</p>
<p>let rec shift n xs = if n = 0 then xs else if n &gt; 0 then LCons
(0., lazy (shift (n-1) xs)) (* Multiply by x^n <em>) else match xs with
(</em> Divide by x^|n| *) | LNil -&gt; LNil | LCons (0., lazy xs) -&gt;
shift (n+1) xs | _ -&gt; failwith “shift: fractional division”</p>
<p>(* Multiplication uses the convolution formula *) let rec mul xs =
function | LNil -&gt; LNil | LCons (y, ys) -&gt; add (scale y xs) (LCons
(0., lazy (mul xs (Lazy.force ys))))</p>
<p>(* Division is like long division of polynomials <em>) let rec div xs
ys = match xs, ys with | LNil, _ -&gt; LNil | LCons (0., xs’), LCons
(0., ys’) -&gt; (</em> Both start with zero: cancel x <em>) div
(Lazy.force xs’) (Lazy.force ys’) | LCons (x, xs’), LCons (y, ys’) -&gt;
let q = x /. y in (</em> Leading coefficient of quotient *) LCons (q,
lazy (div (sub (Lazy.force xs’) (scale q (Lazy.force ys’))) ys)) | LCons
_, LNil -&gt; failwith “div: division by zero”</p>
<p>(* Integration: integral of a_0 + a_1<em>x + a_2</em>x^2 + … is c +
a_0<em>x + a_1</em>x^2/2 + a_2<em>x^3/3 + … </em>) let integrate c xs =
LCons (c, lazy (lmap (uncurry (/.)) (lzip (xs, posnums_f))))</p>
<p>let ltail = function | LNil -&gt; invalid_arg “ltail” | LCons (_,
lazy tl) -&gt; tl</p>
<p>(* Differentiation: derivative of a_0 + a_1<em>x + a_2</em>x^2 + … is
a_1 + 2<em>a_2</em>x + 3<em>a_3</em>x^2 + … <em>) let differentiate xs =
lmap (uncurry ( </em>.)) (lzip (ltail xs, posnums_f))</p>
<pre><code>
#### Differential Equations

Now for the remarkable part: we can solve differential equations by representing the solutions as power series! Consider the differential equations for sine and cosine:

$$\frac{d \sin x}{dx} = \cos x, \quad \frac{d \cos x}{dx} = -\sin x, \quad \sin 0 = 0, \quad \cos 0 = 1$$

We will solve the corresponding integral equations. Why integral equations rather than differential equations? Because integration gives us a way to build up the solution coefficient by coefficient, starting from the initial conditions.

Our first attempt might be to define them by direct recursion:
</code></pre>
<p>let (~-:) = lmap (fun x -&gt; -.x) (* Unary negation for series
*)</p>
<p>let rec sin = integrate (of_int 0) cos and cos = integrate (of_int 1)
(~-:sin)</p>
<pre><code>
Unfortunately this fails with: `Error: This kind of expression is not allowed as right-hand side of &#39;let rec&#39;`

The problem is that OCaml&#39;s `let rec` requires the right-hand side to be a &quot;static&quot; value -- something like a function or a data constructor applied to arguments. Even changing the second argument of `integrate` to call-by-need does not help, because OCaml cannot represent the values that `sin` and `cos` refer to at the point of their definition.

The solution is to inline a bit of `integrate` so that OCaml knows how to start building the recursive structure. We provide the first coefficient explicitly:

```ocaml env=ch7
let integ xs = lmap (uncurry (/.)) (lzip (xs, posnums_f))

let rec sin = LCons (of_int 0, lazy (integ cos))
and cos = LCons (of_int 1, lazy (integ (~-:sin)))</code></pre>
<p>Now the <code>let rec</code> works because each right-hand side is
just <code>LCons</code> applied to a value and a lazy expression. The
lazy expressions are not evaluated during the definition, so there is no
problem with the mutual recursion. When we force the lazy tails, the
computation proceeds coefficient by coefficient.</p>
<p>The complete example would look much more elegant in Haskell, where
all values are lazy by default – we would not need the explicit
<code>LCons</code> and <code>lazy</code> wrappers.</p>
<p>Although this approach is not limited to linear equations, equations
like Lotka-Volterra or Lorentz are not “solvable” this way – the
computed coefficients quickly grow instead of quickly falling, so the
series does not converge well.</p>
<p>Drawing functions work like in the previous lecture, but with open
curves:</p>
<p><code>ocaml env=ch7 let plot_1D f ~w ~scale ~t_beg ~t_end =   let dt = (t_end -. t_beg) /. of_int w in   Array.init w (fun i -&gt;     let y = lhorner (dt *. of_int i) f in     i, to_int (scale *. y))</code></p>
<h3 id="arbitrary-precision-computation">7.5 Arbitrary Precision
Computation</h3>
<p>Putting together the power series computation with floating-point
numbers reveals drastic numerical errors for large <span
class="math inline">x</span>. There are two problems: 1. Floating-point
numbers have limited precision, so intermediate calculations accumulate
errors. 2. We break out of Horner method computations too quickly – the
stopping condition based on <code>epsilon_float</code> may stop before
we have enough precision.</p>
<figure>
<img src="sin_cos_1.png" style="width:70.0%"
alt="Numerical errors in sine/cosine computation" />
<figcaption aria-hidden="true">Numerical errors in sine/cosine
computation</figcaption>
</figure>
<p>For infinite precision on rational numbers we can use the
<code>nums</code> library, but it does not help by itself – the stopping
condition still causes us to truncate the computation prematurely.</p>
<p>The key insight is that instead of computing a single approximate
value, we should generate a <em>sequence of approximations</em> to the
power series limit at <span class="math inline">x</span>. Then we can
watch the sequence until it converges:</p>
<p><code>ocaml env=ch7 let infhorner x l =   let upd c sum =     LCons (c, lazy (lmap (fun apx -&gt; c +. x *. apx)                       (Lazy.force sum))) in   lazy_foldr upd l (LCons (of_int 0, lazy LNil))</code></p>
<p>The function <code>infhorner</code> returns a lazy list of partial
sums. Each element is a better approximation than the previous one. Now
we need to find where the series has converged to the precision we
need:</p>
<p><code>ocaml env=ch7 let rec exact f = function         (* We arbitrarily decide that convergence is *)   | LNil -&gt; assert false           (* when three consecutive results are the same. *)   | LCons (x0, lazy (LCons (x1, lazy (LCons (x2, _)))))       when f x0 = f x1 &amp;&amp; f x0 = f x2 -&gt; f x0   | LCons (_, lazy tl) -&gt; exact f tl</code></p>
<p>The function <code>exact</code> applies a test function
<code>f</code> to the approximations and stops when three consecutive
results give the same answer. Why three? Because some power series (like
those for sine and cosine) have alternating terms, and we want to be
sure the result has stabilized.</p>
<p>Draw the pixels of the graph at exact coordinates:</p>
<p><code>ocaml env=ch7 let plot_1D f ~w ~h0 ~scale ~t_beg ~t_end =   let dt = (t_end -. t_beg) /. of_int w in   let eval = exact (fun y -&gt; to_int (scale *. y)) in   Array.init w (fun i -&gt;     let y = infhorner (t_beg +. dt *. of_int i) f in     i, h0 + eval y)</code></p>
<p>If a power series had every third term contributing (zeros in a
regular pattern), we would have to check more terms in the function
<code>exact</code>. We could also use a different stopping criterion
like <code>f x0 = f x1 &amp;&amp; not (x0 =. x1)</code> (stop when the
transformed values match but the raw values are still changing), similar
to what we did in <code>lhorner</code>.</p>
<h4 id="example-nuclear-chain-reaction">Example: Nuclear Chain
Reaction</h4>
<p>Consider a nuclear chain reaction where substance A decays into B,
which then decays into C. This is a classic problem in nuclear physics.
The differential equations are:</p>
<p><span class="math display">\frac{dN_A}{dt} = -\lambda_A N_A, \quad
\frac{dN_B}{dt} = \lambda_A N_A - \lambda_B N_B</span></p>
<p>Here <span class="math inline">\lambda_A</span> and <span
class="math inline">\lambda_B</span> are the decay constants, and <span
class="math inline">N_A</span>, <span class="math inline">N_B</span> are
the amounts of each substance. Substance A decays at a rate proportional
to its amount. Substance B is produced by A’s decay and itself decays
into C.</p>
<p>We can solve these equations using the same technique as for sine and
cosine:</p>
<pre><code>let n_chain ~nA0 ~nB0 ~lA ~lB =
  let rec nA =
    LCons (nA0, lazy (integ (~-.lA *:. nA)))
  and nB =
    LCons (nB0, lazy (integ (~-.lB *:. nB +: lA *:. nA))) in
  nA, nB</code></pre>
<figure>
<img src="chain_reaction.png" style="width:70.0%"
alt="Nuclear chain reaction: A decays into B decays into C" />
<figcaption aria-hidden="true">Nuclear chain reaction: A decays into B
decays into C</figcaption>
</figure>
<p>(See <a
href="http://en.wikipedia.org/wiki/Radioactive_decay#Chain-decay_processes">Radioactive
decay chain processes</a> for more information.)</p>
<h3 id="circular-data-structures-double-linked-lists">7.6 Circular Data
Structures: Double-Linked Lists</h3>
<p>Without delayed computation, the ability to define data structures
with referential cycles is very limited. In a strict language, you
cannot create a structure that refers to itself – the reference would
have to exist before the structure is created.</p>
<p>Double-linked lists are a classic example of structures with inherent
cycles. Even if the list itself is not circular (it has a beginning and
an end), each pair of adjacent nodes forms a cycle: node A points
forward to node B, and node B points backward to node A:</p>
<pre><code>+--------+     +--------+     +--------+     +--------+     +--------+
| DLNil  | &lt;-&gt; |   a1   | &lt;-&gt; |   a2   | &lt;-&gt; |   a3   | &lt;-&gt; | DLNil  |
+--------+     +--------+     +--------+     +--------+     +--------+</code></pre>
<p>To represent such structures in OCaml, we need to “break” the cycles
by making some links lazy. The backward links will be lazy, allowing us
to construct the structure one node at a time:</p>
<p><code>ocaml env=ch7 type 'a dllist =   DLNil | DLCons of 'a dllist Lazy.t * 'a * 'a dllist</code></p>
<p>The type has three components: a lazy backward link, the element, and
a (strict) forward link. The backward link is lazy because when we
create a node, its predecessor may not exist yet.</p>
<p>We can navigate forward through the list, dropping elements from the
front:</p>
<p><code>ocaml env=ch7 let rec dldrop n l =   match l with     | DLCons (_, x, xs) when n &gt; 0 -&gt;        dldrop (n-1) xs     | _ -&gt; l</code></p>
<p>The tricky part is constructing a double-linked list from a regular
list. Each cell must know its predecessor, but the predecessor is
created first. We use a recursive lazy value to tie the knot:</p>
<p><code>ocaml env=ch7 let dllist_of_list l =   let rec dllist prev l =     match l with       | [] -&gt; DLNil       | x::xs -&gt;         let rec cell =           lazy (DLCons (prev, x, dllist cell xs)) in         Lazy.force cell in   dllist (lazy DLNil) l</code></p>
<p>The key trick is
<code>let rec cell = lazy (DLCons (prev, x, dllist cell xs))</code>. The
lazy value <code>cell</code> refers to itself! When we force
<code>cell</code>, it creates a <code>DLCons</code> node whose forward
link (<code>dllist cell xs</code>) receives <code>cell</code> as the
predecessor for the next node. This is only possible because the
backward link is lazy – when we create the next node, we do not need to
evaluate <code>cell</code>, just store a reference to it.</p>
<p>Taking elements going forward is straightforward:</p>
<p><code>ocaml env=ch7 let rec dltake n l =   match l with     | DLCons (_, x, xs) when n &gt; 0 -&gt;        x :: dltake (n-1) xs     | _ -&gt; []</code></p>
<p>Taking elements going backward shows the power of the double-linked
structure – we can traverse in either direction:</p>
<p><code>ocaml env=ch7 let rec dlbackwards n l =   match l with     | DLCons (lazy xs, x, _) when n &gt; 0 -&gt;       x :: dlbackwards (n-1) xs     | _ -&gt; []</code></p>
<h3 id="input-output-streams">7.7 Input-Output Streams</h3>
<p>Let us return to streams and generalize them. The stream type we
defined earlier used a throwaway argument to make a suspension:</p>
<p><code>ocaml env=ch7 type 'a stream = SNil | SCons of 'a * (unit -&gt; 'a stream)</code></p>
<p>The <code>unit</code> argument serves only to delay computation. But
what if we take a <em>real</em> argument – one that provides input to
the stream? This leads to a more powerful abstraction:</p>
<p><code>ocaml env=ch7 type ('a, 'b) iostream =   EOS | More of 'b * ('a -&gt; ('a, 'b) iostream)</code></p>
<p>This is an <em>interactive</em> stream: it produces an output value
of type <code>'b</code>, and when given an input value of type
<code>'a</code>, produces the rest of the stream. The stream alternates
between producing output and consuming input.</p>
<p><code>ocaml env=ch7 type 'a istream = (unit, 'a) iostream  (* Input stream produces output when "asked". *) type 'a ostream = ('a, unit) iostream  (* Output stream consumes provided input. *)</code></p>
<p>The terminology can be confusing. An “input stream”
(<code>istream</code>) is one that produces output when asked (like
reading from a file). An “output stream” (<code>ostream</code>) is one
that consumes input (like writing to a file). The confusion arises from
adapting the <em>input file / output file</em> terminology.</p>
<p>The power of this abstraction is that we can compose streams,
directing the output of one to the input of another:</p>
<p><code>ocaml env=ch7 let rec compose sf sg =   match sg with   | EOS -&gt; EOS                              (* No more output from sg. *)   | More (z, g) -&gt;     match sf with     | EOS -&gt; More (z, fun _ -&gt; EOS)         (* No more input from sf. *)     | More (y, f) -&gt;       let update x = compose (f x) (g y) in (* Feed sf's output y to sg. *)       More (z, update)</code></p>
<p>Think of it as connecting boxes with wires: every box has one
incoming wire and one outgoing wire. When composing <code>sf</code> and
<code>sg</code>, the output of <code>sf</code> becomes the input of
<code>sg</code>. Notice that the output stream is “ahead” of the input
stream – <code>sg</code> can produce its first output <code>z</code>
before <code>sf</code> has produced anything.</p>
<h3 id="pipes">7.8 Pipes</h3>
<p>The <code>iostream</code> type has a limitation: it must alternate
strictly between producing output and consuming input. In many
real-world scenarios, we need more flexibility: - A transformation might
consume several inputs before producing a single output (like computing
an average). - A transformation might produce several outputs from a
single input (like splitting a string). - A transformation might produce
output without needing any input (like a constant source).</p>
<p>Following the Haskell tradition, we call this more flexible data
structure a <code>pipe</code>:</p>
<p><code>ocaml env=ch7 type ('a, 'b) pipe =   EOP                                       (* End of pipe -- done processing *) | Yield of 'b * ('a, 'b) pipe               (* Produce output b, then continue *) | Await of ('a -&gt; ('a, 'b) pipe)            (* Wait for input a, then continue *)</code></p>
<p>A pipe can be in one of three states: finished (<code>EOP</code>),
ready to produce output (<code>Yield</code>), or waiting for input
(<code>Await</code>). The key insight is that <code>Yield</code>
includes the continuation pipe directly (not wrapped in a function), so
multiple outputs can be produced in sequence without requiring input.
For incremental processing where outputs should be lazy, you would
change <code>Yield</code> to hold a lazy pipe instead.</p>
<p>Again, we can specialize to input-only and output-only pipes:</p>
<p><code>ocaml env=ch7 type 'a ipipe = (unit, 'a) pipe type void type 'a opipe = ('a, void) pipe</code></p>
<p>Why <code>void</code> rather than <code>unit</code>, and why only for
<code>opipe</code>? Because an output pipe never yields values – if it
used <code>unit</code> as the output type, it could still yield
<code>()</code> values. But <code>void</code> is an abstract type with
no values, making it impossible for an <code>opipe</code> to yield
anything. This is a type-level guarantee that output pipes only
consume.</p>
<h4 id="pipe-composition">Pipe Composition</h4>
<p>Composition of pipes is like “concatenating them in space” or
connecting boxes. We plug the output of pipe <code>pf</code> into the
input of pipe <code>pg</code>:</p>
<p>```ocaml env=ch7 let rec compose pf pg = match pg with | EOP -&gt;
EOP (* pg is done – composition is done. <em>) | Yield (z, pg’) -&gt;
Yield (z, compose pf pg’) (</em> pg has output – pass it through. <em>)
| Await g -&gt; (</em> pg needs input – try to get it from pf. <em>)
match pf with | EOP -&gt; EOP (</em> pf is done – no more input for pg.
<em>) | Yield (y, pf’) -&gt; compose pf’ (g y) (</em> pf has output –
feed it to pg. <em>) | Await f -&gt; (</em> Both waiting – wait for
external input. *) let update x = compose (f x) pg in Await update</p>
<p>let (&gt;-&gt;) pf pg = compose pf pg</p>
<pre><code>
The `&gt;-&gt;` operator lets us chain pipes together like Unix pipes: `source &gt;-&gt; transform &gt;-&gt; sink`.

Appending pipes means &quot;concatenating them in time&quot; rather than in space. When the first pipe finishes, we continue with the second:

```ocaml env=ch7
let rec append pf pg =
  match pf with
  | EOP -&gt; pg                               (* pf is exhausted -- continue with pg. *)
  | Yield (z, pf&#39;) -&gt; Yield (z, append pf&#39; pg)  (* pf has output -- pass it through. *)
  | Await f -&gt;                              (* pf awaits input -- pass it through. *)
    let update x = append (f x) pg in
    Await update</code></pre>
<p>We can also append a list of ready results in front of a pipe. This
is useful for producing multiple outputs at once:</p>
<p><code>ocaml env=ch7 let rec yield_all l tail =   match l with   | [] -&gt; tail   | x::xs -&gt; Yield (x, yield_all xs tail)</code></p>
<p>Finally, the <code>iterate</code> function creates a pipe that
repeatedly applies a side-effecting function to its inputs. This is
<strong>not functional</strong> (it performs side effects), but it is
useful for output:</p>
<p><code>ocaml env=ch7 let rec iterate f : 'a opipe =   Await (fun x -&gt; let () = f x in iterate f)</code></p>
<h3 id="example-pretty-printing">7.9 Example: Pretty-Printing</h3>
<p>Now let us apply pipes to a substantial example: pretty-printing. The
goal is to print a hierarchically organized document with a limited line
width. When a group of text fits on the current line, we keep it
together; when it does not fit, we break it across multiple lines.</p>
<p><code>ocaml env=ch7 type doc =   Text of string | Line | Cat of doc * doc | Group of doc</code></p>
<p>The document type has four constructors: - <code>Text s</code> –
literal text - <code>Line</code> – a potential line break (rendered as a
space if the group fits, or a newline if it does not) -
<code>Cat (d1, d2)</code> – concatenation - <code>Group d</code> – a
group that should be kept together if possible</p>
<p>Some convenient operators for building documents:</p>
<p>```ocaml env=ch7 let (++) d1 d2 = Cat (d1, Cat (Line, d2)) let (!) s
= Text s</p>
<p>let test_doc = Group (!“Document” ++ Group (!“First part” ++ !“Second
part”))</p>
<pre><code>
The pretty-printer should produce different outputs depending on the available width:
</code></pre>
<h1 id="let-print_endline-pretty-30-test_doc">let () = print_endline
(pretty 30 test_doc);;</h1>
<p>Document First part Second part</p>
<h1 id="let-print_endline-pretty-20-test_doc">let () = print_endline
(pretty 20 test_doc);;</h1>
<p>Document First part Second part</p>
<h1 id="let-print_endline-pretty-60-test_doc">let () = print_endline
(pretty 60 test_doc);;</h1>
<p>Document First part Second part</p>
<pre><code>
#### Straightforward Solution

Before diving into pipes, let us implement a straightforward recursive solution:

```ocaml env=ch7
let pretty w d =               (* Allowed width of line w. *)
  let rec width = function     (* Compute total length of subdocument. *)
    | Text z -&gt; String.length z
    | Line -&gt; 1                (* A line break takes 1 character (space or newline). *)
    | Cat (d1, d2) -&gt; width d1 + width d2
    | Group d -&gt; width d in
  let rec format f r = function  (* f: flatten (no breaks)? r: remaining space. *)
    | Text z -&gt; z, r - String.length z
    | Line when f -&gt; &quot; &quot;, r-1  (* Flatten mode: render as space. *)
    | Line -&gt; &quot;\n&quot;, w          (* Break mode: newline, reset remaining to full width. *)
    | Cat (d1, d2) -&gt;
      let s1, r = format f r d1 in
      let s2, r = format f r d2 in
      s1 ^ s2, r
    | Group d -&gt; format (f || width d &lt;= r) r d  (* Flatten if group fits. *)
  in
  fst (format false w d)       (* Start outside any group (not flattening). *)</code></pre>
<p>The <code>format</code> function takes a boolean <code>f</code> (are
we in “flatten” mode?) and the remaining space <code>r</code>. When we
enter a <code>Group</code>, we check if the whole group fits in the
remaining space. If so, we format it in flatten mode (all
<code>Line</code>s become spaces).</p>
<h4 id="stream-based-solution">Stream-Based Solution</h4>
<p>The straightforward solution works, but it has a problem: for each
group, we compute <code>width</code> by traversing the entire subtree,
potentially doing redundant work. The stream-based solution processes
the document incrementally, computing positions as we go.</p>
<p>First, we define a type for document elements that can carry
annotations:</p>
<p><code>ocaml env=ch7 type ('a, 'b) doc_e =          (* Annotated nodes, special for group beginning. *)   TE of 'a * string | LE of 'a | GBeg of 'b | GEnd of 'a</code></p>
<p>The type parameters <code>'a</code> and <code>'b</code> allow
different annotations for different elements. <code>GBeg</code> (group
beginning) has a different type because it will eventually carry the end
position of the group.</p>
<p>Normalize a subdocument to remove empty groups:</p>
<p><code>ocaml env=ch7 let rec norm = function   | Group d -&gt; norm d   | Text "" -&gt; None   | Cat (Text "", d) -&gt; norm d   | d -&gt; Some d</code></p>
<p>Generate the stream of document elements by infix traversal:</p>
<p><code>ocaml env=ch7 let rec gen = function   | Text z -&gt; Yield (TE ((),z), EOP)   | Line -&gt; Yield (LE (), EOP)   | Cat (d1, d2) -&gt; append (gen d1) (gen d2)   | Group d -&gt;     match norm d with     | None -&gt; EOP     | Some d -&gt;       Yield (GBeg (),              append (gen d) (Yield (GEnd (), EOP)))</code></p>
<p>The next pipe computes the position (character count from the
beginning) of each element:</p>
<p>```ocaml env=ch7 let rec docpos curpos = Await (function (* Input
from a doc_e pipe, *) | TE (_, z) -&gt; Yield (TE (curpos, z), (* output
doc_e annotated with position. <em>) docpos (curpos + String.length z))
| LE _ -&gt; (</em> Spaces and line breaks: 1 character. <em>) Yield (LE
curpos, docpos (curpos + 1)) | GBeg _ -&gt; (</em> Groups themselves
have no width. *) Yield (GBeg curpos, docpos curpos) | GEnd _ -&gt;
Yield (GEnd curpos, docpos curpos))</p>
<p>let docpos = docpos 0 (* The whole document starts at position 0.
*)</p>
<pre><code>
Now comes the tricky part. We want to annotate each `GBeg` with the position where the group *ends*, so we can decide whether the group fits on the line. But we see `GBeg` before we see `GEnd`! We need to buffer elements until we see the end of each group:

```ocaml env=ch7
let rec grends grstack =
  Await (function
  | TE _ | LE _ as e -&gt;
    (match grstack with
    | [] -&gt; Yield (e, grends [])         (* No groups waiting -- yield immediately. *)
    | gr::grs -&gt; grends ((e::gr)::grs))  (* Inside a group -- buffer the element. *)
  | GBeg _ -&gt; grends ([]::grstack)       (* Start a new group: push empty buffer. *)
  | GEnd endp -&gt;
    match grstack with                   (* End the group on top of stack. *)
    | [] -&gt; failwith &quot;grends: unmatched group end marker&quot;
    | [gr] -&gt;                          (* Outermost group -- yield everything now. *)
      yield_all
        (GBeg endp::List.rev (GEnd endp::gr))  (* Annotate GBeg with end position. *)
        (grends [])
    | gr::par::grs -&gt;                    (* Nested group -- add to parent&#39;s buffer. *)
      let par = GEnd endp::gr @ [GBeg endp] @ par in
      grends (par::grs))               (* Could use catenable lists for efficiency. *)</code></pre>
<p>This works, but it has a problem: we wait until the entire group is
processed before yielding anything. For large groups (or groups that
exceed the line width), this is wasteful. We can optimize by flushing
the buffer when a group clearly exceeds the line width – if we know a
group will not fit, there is no need to remember where it ends:</p>
<p>```ocaml env=ch7 type grp_pos = Pos of int | Too_far</p>
<p>let rev_concat_map ~prep f l = let rec cmap_f accu = function | []
-&gt; accu | a::l -&gt; cmap_f (prep::List.rev_append (f a) accu) l in
cmap_f [] l</p>
<p>let rec grends w grstack = let flush tail = (* When a group exceeds
width w, <em>) yield_all (</em> flush the stack – yield everything
buffered. <em>) (rev_concat_map ~prep:(GBeg Too_far) snd grstack) tail
in (</em> Mark flushed groups as Too_far. *) Await (function | TE (curp,
_) | LE curp as e -&gt; (match grstack with (* Track beginning position
of each group. <em>) | [] -&gt; Yield (e, grends w []) (</em> No groups
– yield immediately. <em>) | (begp, <em>)::</em> when curp-begp &gt; w
-&gt; flush (Yield (e, grends w [])) (</em> Group too wide – flush and
yield. <em>) | (begp, gr)::grs -&gt; grends w ((begp, e::gr)::grs))
(</em> Buffer element. <em>) | GBeg begp -&gt; grends w ((begp,
[])::grstack) (</em> New group: remember start pos. <em>) | GEnd endp as
e -&gt; match grstack with (</em> No longer fail when stack is empty –
<em>) | [] -&gt; Yield (e, grends w []) (</em> could have been flushed
earlier. <em>) | (begp, <em>)::</em> when endp-begp &gt; w -&gt; flush
(Yield (e, grends w [])) (</em> Group exceeded width – flush. <em>) |
[_, gr] -&gt; (</em> Group fits – annotate with end position. *)
yield_all (GBeg (Pos endp)::List.rev (GEnd endp::gr)) (grends w []) |
(_, gr)::(par_begp, par)::grs -&gt; (* Nested group fits – add to
parent. *) let par = GEnd endp::gr @ [GBeg (Pos endp)] @ par in grends w
((par_begp, par)::grs))</p>
<p>let grends w = grends w [] (* Initial stack is empty. *)</p>
<pre><code>
Finally, the `format` pipe produces the resulting stream of strings. It maintains a stack of booleans indicating which groups are being &quot;flattened&quot; (rendered inline), and the position where the current line would end:

```ocaml env=ch7
let rec format w (inline, endlpos as st) = (* inline: stack of &quot;flatten this group?&quot; *)
  Await (function                          (* endlpos: position where line ends *)
  | TE (_, z) -&gt; Yield (z, format w st)    (* Text: output directly. *)
  | LE p when List.hd inline -&gt;
    Yield (&quot; &quot;, format w st)               (* In flatten mode: line break -&gt; space. *)
  | LE p -&gt; Yield (&quot;\n&quot;, format w (inline, p+w))  (* Break mode: update endlpos. *)
  | GBeg Too_far -&gt;                        (* Group too wide -- don&#39;t flatten. *)
    format w (false::inline, endlpos)
  | GBeg (Pos p) -&gt;                        (* Group fits if it ends before endlpos. *)
    format w ((p&lt;=endlpos)::inline, endlpos)
  | GEnd _ -&gt; format w (List.tl inline, endlpos))  (* Pop the inline stack. *)

let format w = format w ([false], w)   (* Start with no flattening, full line width. *)</code></pre>
<p>Put the pipes together into a complete pipeline:</p>
<pre><code>+--------+     +-------+     +---------+     +--------+     +----------------+
| gen doc| --&gt; |docpos | --&gt; |grends w | --&gt; |format w| --&gt; |iterate print_s |
+--------+     +-------+     +---------+     +--------+     +----------------+</code></pre>
<p>The data flows from left to right: <code>gen</code> produces document
elements, <code>docpos</code> annotates them with positions,
<code>grends</code> annotates group beginnings with their end positions,
<code>format</code> decides where to break lines and produces strings,
and <code>iterate print_string</code> prints the strings.</p>
<h4 id="factored-solution">Factored Solution</h4>
<p>For maximum flexibility, we can factorize <code>format</code> into
two parts: one that decides where to break lines (producing annotated
document elements), and one that converts those to strings. This allows
different line breaking strategies to be plugged in:</p>
<p>```ocaml env=ch7 (* breaks: decides where to break, outputs annotated
doc_e elements <em>) let rec breaks w (inline, endlpos as st) = Await
(function | TE _ as e -&gt; Yield (e, breaks w st) (</em> Pass through
text. <em>) | LE p when List.hd inline -&gt; Yield (TE (p, ” “), breaks
w st) (</em> Flatten: convert to space. <em>) | LE p as e -&gt; Yield
(e, breaks w (inline, p+w)) (</em> Break: keep as LE. *) | GBeg Too_far
as e -&gt; Yield (e, breaks w (false::inline, endlpos)) | GBeg (Pos p)
as e -&gt; Yield (e, breaks w ((p&lt;=endlpos)::inline, endlpos)) | GEnd
_ as e -&gt; Yield (e, breaks w (List.tl inline, endlpos)))</p>
<p>let breaks w = breaks w ([false], w)</p>
<p>(* emit: converts doc_e elements to strings *) let rec emit = Await
(function | TE (_, z) -&gt; Yield (z, emit) (* Text: output directly.
<em>) | LE _ -&gt; Yield (“”, emit) (</em> Line break: output newline.
<em>) | GBeg _ | GEnd _ -&gt; emit) (</em> Group markers: skip. *)</p>
<p>let pretty_print w doc = gen doc &gt;-&gt; docpos &gt;-&gt; grends w
&gt;-&gt; breaks w &gt;-&gt; emit &gt;-&gt; iterate print_string</p>
<pre><code>
Now `breaks` can be replaced with a different strategy (for example, one that adds indentation), and `emit` stays the same. The full pipeline reads like a description of what happens: generate elements, compute positions, annotate groups with their ends, decide where to break, convert to strings, and print.

### 7.10 Exercises

**Exercise 1:** My first impulse was to define lazy list functions as follows:

```ocaml env=ch7
let rec wrong_lzip = function
  | LNil, LNil -&gt; LNil
  | LCons (a1, lazy l1), LCons (a2, lazy l2) -&gt;
      LCons ((a1, a2), lazy (wrong_lzip (l1, l2)))
  | _ -&gt; raise (Invalid_argument &quot;lzip&quot;)

let rec wrong_lmap f = function
  | LNil -&gt; LNil
  | LCons (a, lazy l) -&gt; LCons (f a, lazy (wrong_lmap f l))</code></pre>
<p>What is wrong with these definitions – for which edge cases do they
not work as intended?</p>
<p><strong>Exercise 2:</strong> Cyclic lazy lists.</p>
<ol type="1">
<li><p>Implement a function <code>cycle : 'a list -&gt; 'a llist</code>
that creates a lazy list with elements from a standard list, and the
whole list as the tail after the last element from the input list:
<code>[a1; a2; ...; aN]</code> maps to a cyclic structure where
<code>aN</code> points back to <code>a1</code>. Your function
<code>cycle</code> can either return <code>LNil</code> or fail for an
empty list as argument.</p></li>
<li><p>Note that <code>inv_fact</code> from the lecture defines the
power series for the <span class="math inline">\exp(\cdot)</span>
function (<span class="math inline">\exp(x) = e^x</span>). Using
<code>cycle</code> and <code>inv_fact</code>, define the power series
for <span class="math inline">\sin(\cdot)</span> and <span
class="math inline">\cos(\cdot)</span>, and draw their graphs using
helper functions from the lecture script <code>Lec7.ml</code>.</p></li>
</ol>
<p><strong>Exercise 3:</strong> Modify one of the puzzle solving
programs (either from the previous lecture or from your previous
homework) to work with lazy lists. Implement the necessary higher-order
lazy list functions. Check that indeed displaying only the first
solution when there are multiple solutions in the result takes shorter
than computing solutions by the original program.</p>
<p><strong>Exercise 4:</strong> <em>Hamming’s problem</em>. Generate in
increasing order the numbers of the form <span
class="math inline">2^{a_1} 3^{a_2} 5^{a_3} \ldots p_k^{a_k}</span>,
that is numbers not divisible by prime numbers greater than the <span
class="math inline">k</span>th prime number.</p>
<p>In the original Hamming’s problem posed by Dijkstra, <span
class="math inline">k = 3</span>, which is related to <a
href="http://en.wikipedia.org/wiki/Regular_number">regular
numbers</a>.</p>
<p>Starter code is available in the lecture script
<code>Lec7.ml</code>:</p>
<p>```ocaml env=ch7 let rec lfilter f = function | LNil -&gt; LNil |
LCons (n, ll) -&gt; if f n then LCons (n, lazy (lfilter f (Lazy.force
ll))) else lfilter f (Lazy.force ll)</p>
<p>let primes = let rec sieve = function | LCons(p, nf) -&gt; LCons(p,
lazy (sieve (sift p (Lazy.force nf)))) | LNil -&gt; failwith
“Impossible! Internal error.” and sift p = lfilter (fun n -&gt; n mod p
&lt;&gt; 0) in sieve (l_from 2)</p>
<p>let times ll n = lmap (fun i -&gt; i * n) ll</p>
<p>let rec merge xs ys = match xs, ys with | LCons (x, lazy xr), LCons
(y, lazy yr) -&gt; if x &lt; y then LCons (x, lazy (merge xr ys)) else
if x &gt; y then LCons (y, lazy (merge xs yr)) else LCons (x, lazy
(merge xr yr)) | r, LNil | LNil, r -&gt; r</p>
<p>let hamming k = let _pr = ltake k primes in (* TODO: use primes to
generate smooth numbers <em>) let rec h = LCons (1, lazy ( (</em> TODO:
replace this placeholder with the real generator; <code>h</code> keeps
the snippet compiling. *) h )) in h</p>
<pre><code>
**Exercise 5:** Modify `format` and/or `breaks` to use just a single number instead of a stack of booleans to keep track of what groups should be inlined.

**Exercise 6:** Add **indentation** to the pretty-printer for groups: if a group does not fit in a single line, its consecutive lines are indented by a given amount `tab` of spaces deeper than its parent group lines would be. For comparison, let&#39;s do several implementations.

1. Modify the straightforward implementation of `pretty`.
2. Modify the first pipe-based implementation of `pretty` by modifying the `format` function.
3. Modify the second pipe-based implementation of `pretty` by modifying the `breaks` function. Recover the positions of elements -- the number of characters from the beginning of the document -- by keeping track of the growing offset.
4. (Harder) Modify a pipe-based implementation to provide a different style of indentation: indent the first line of a group, when the group starts on a new line, at the same level as the consecutive lines (rather than at the parent level of indentation).

**Exercise 7:** Write a pipe that takes document elements annotated with linear position, and produces document elements annotated with (line, column) coordinates.

Write another pipe that takes so annotated elements and adds a line number indicator in front of each line. Do not update the column coordinate. Test the pipes by plugging them before the `emit` pipe.
</code></pre>
<p>1: first line 2: second line, etc.</p>
<pre><code>
**Exercise 8:** Write a pipe that consumes document elements `doc_e` and yields the toplevel subdocuments `doc` which would generate the corresponding elements.

You can modify the definition of documents to allow annotations, so that the element annotations are preserved (`gen` should ignore annotations to keep things simple):

```ocaml env=ch7
type &#39;a doc =
  Text of &#39;a * string | Line of &#39;a | Cat of &#39;a doc * &#39;a doc | Group of &#39;a * &#39;a doc</code></pre>
<p><strong>Exercise 9:</strong> (Harder) Design and implement a way to
duplicate arrows outgoing from a pipe-box, that would memoize the
stream, i.e. not recompute everything “upstream” for the composition of
pipes. Such duplicated arrows would behave nicely with pipes reading
from files.</p>
<h2 id="chapter-8-monads">Chapter 8: Monads</h2>
<p><strong>In this chapter, you will:</strong></p>
<ul>
<li>Recognize the “bind + return” pattern behind list comprehensions and
other effects</li>
<li>Learn the monad laws (and what they do and do not guarantee)</li>
<li>Use monad-plus for nondeterministic/backtracking computation</li>
<li>Work through several concrete monads (lazy, list, exception, state,
probability)</li>
<li>Combine effects with monad transformers and model cooperative
concurrency</li>
</ul>
<p>This chapter explores one of functional programming’s most powerful
abstractions: monads. We begin with equivalents of list comprehensions
as a motivating example, then introduce monadic concepts and examine the
monad laws. We explore the monad-plus extension that adds
non-determinism, then work through various monad instances including the
lazy, list, state, exception, and probability monads. We conclude with
monad transformers for combining monads and cooperative lightweight
threads for concurrency.</p>
<p>The material draws on several excellent resources: Jeff Newbern’s
“All About Monads,” Martin Erwig and Steve Kollmansberger’s
“Probabilistic Functional Programming in Haskell,” and Jerome Vouillon’s
“Lwt: a Cooperative Thread Library.”</p>
<h3 id="list-comprehensions">8.1 List Comprehensions</h3>
<p>Recall the somewhat awkward syntax we used in the Countdown Problem
example from earlier chapters. The nested callback style, while
functional, is hard to read and understand at a glance. The brute-force
generation of expressions looked like this:</p>
<p>```ocaml env=ch8 let combine l r = List.map (fun o -&gt; App (o, l,
r)) [Add; Sub; Mul; Div]</p>
<p>let rec exprs = function | [] -&gt; [] | [n] -&gt; [Val n] | ns -&gt;
split ns |-&gt; (fun (ls, rs) -&gt; exprs ls |-&gt; (fun l -&gt; exprs
rs |-&gt; (fun r -&gt; combine l r)))</p>
<pre><code>
Notice how the nested callbacks pile up: each `|-&gt;` introduces another level of indentation. The generate-and-test scheme used similar nesting:

```ocaml env=ch8
let guard p e = if p e then [e] else []

let solutions ns n =
  choices ns |-&gt; (fun ns&#39; -&gt;
  exprs ns&#39; |-&gt;
    guard (fun e -&gt; eval e = Some n))</code></pre>
<p>The key insight is that we introduced the operator
<code>|-&gt;</code> defined as:</p>
<p><code>ocaml env=ch8 let ( |-&gt; ) x f = concat_map f x</code></p>
<p>This pattern of “for each element in a list, apply a function that
returns a list, then flatten the results” is so common that many
languages provide special syntax for it. We can express such
computations much more elegantly with <em>list comprehensions</em>, a
syntax that originated in languages like Haskell and Python.</p>
<p>With list comprehensions, we can write expressions that read almost
like set-builder notation in mathematics:</p>
<p><code>ocaml skip let test = [i * 2 | i &lt;- from_to 2 22; i mod 3 = 0]</code></p>
<p>This reads as: “the list of <code>i * 2</code> for each
<code>i</code> drawn from <code>from_to 2 22</code> where
<code>i mod 3 = 0</code>.” The <code>&lt;-</code> arrow draws elements
from a generator, and conditions filter which elements are kept.</p>
<p>The translation rules that define list comprehension semantics are
straightforward:</p>
<ul>
<li><code>[expr | ]</code> translates to <code>[expr]</code> – the base
case, a singleton list</li>
<li><code>[expr | v &lt;- generator; more]</code> translates to
<code>generator |-&gt; (fun v -&gt; [expr | more])</code> – draw from a
generator, then recurse</li>
<li><code>[expr | condition; more]</code> translates to
<code>if condition then [expr | more] else []</code> – filter by a
condition</li>
</ul>
<p>The list comprehension syntax has not caught on in modern OCaml;
there were a couple syntax extensions providing it, but none gained
popularity. It is a nice syntax to build intuition but the examples in
this section need additional setup to compile, you can treat them as
pseudo-code.</p>
<h4 id="revisiting-countdown-with-list-comprehensions">Revisiting
Countdown with List Comprehensions</h4>
<p>Now let us revisit the Countdown Problem code with list
comprehensions. The brute-force generation becomes dramatically cleaner
– compare this to the deeply nested version above:</p>
<p><code>ocaml skip let rec exprs = function   | [] -&gt; []   | [n] -&gt; [Val n]   | ns -&gt;       [App (o, l, r) | (ls, rs) &lt;- split ns;        l &lt;- exprs ls; r &lt;- exprs rs;        o &lt;- [Add; Sub; Mul; Div]]</code></p>
<p>The intent is immediately clear: we split the numbers, recursively
build expressions for left and right parts, and try each operator. The
generate-and-test scheme becomes equally elegant:</p>
<p><code>ocaml skip let solutions ns n =   [e | ns' &lt;- choices ns;    e &lt;- exprs ns'; eval e = Some n]</code></p>
<p>The guard condition <code>eval e = Some n</code> filters out
expressions that do not evaluate to the target value.</p>
<h4 id="more-list-comprehension-examples">More List Comprehension
Examples</h4>
<p>List comprehensions shine when expressing combinatorial algorithms.
Here is computing all subsequences of a list (note that this generates
some intermediate garbage, but the intent is clear):</p>
<p><code>ocaml skip let rec subseqs l =   match l with   | [] -&gt; [[]]   | x::xs -&gt; [ys | px &lt;- subseqs xs; ys &lt;- [px; x::px]]</code></p>
<p>For each element <code>x</code>, we recursively compute subsequences
of the tail, then for each such subsequence we include both the version
without <code>x</code> and the version with <code>x</code>
prepended.</p>
<p>Computing permutations can be done via insertion – inserting an
element at every possible position:</p>
<p>```ocaml skip let rec insert x = function | [] -&gt; [[x]] | y::ys’
as ys -&gt; (x::ys) :: [y::zs | zs &lt;- insert x ys’]</p>
<p>let rec ins_perms = function | [] -&gt; [[]] | x::xs -&gt; [zs | ys
&lt;- ins_perms xs; zs &lt;- insert x ys]</p>
<pre><code>
The `insert` function generates all ways to insert `x` into a list. Then `ins_perms` recursively permutes the tail and inserts the head at every position.

Alternatively, we can compute permutations via selection -- repeatedly choosing which element comes first:

```ocaml skip
let rec select = function
  | [x] -&gt; [x, []]
  | x::xs -&gt; (x, xs) :: [y, x::ys | y, ys &lt;- select xs]

let rec sel_perms = function
  | [] -&gt; [[]]
  | xs -&gt; [x::ys | x, xs&#39; &lt;- select xs; ys &lt;- sel_perms xs&#39;]</code></pre>
<p>The <code>select</code> function returns all ways to pick one element
from a list, along with the remaining elements. Then
<code>sel_perms</code> chooses a first element and recursively permutes
the rest.</p>
<h3 id="generalized-comprehensions-binding-operators">8.2 Generalized
Comprehensions: Binding Operators</h3>
<p>The pattern we saw with list comprehensions is remarkably general. In
fact, the same <code>|-&gt;</code> pattern (applying a function that
returns a container, then flattening) works for many types beyond lists.
This is the essence of monads.</p>
<p>OCaml 4.08 introduced <strong>binding operators</strong>
(<code>let*</code>, <code>let+</code>, <code>and*</code>, …) that
provide a clean, native syntax for such computations. Instead of
external syntax extensions like the old Camlp4-based
<code>pa_monad</code>, we can now define custom operators that integrate
naturally with the language.</p>
<p>For the list monad, we define these binding operators:</p>
<p><code>ocaml env=ch8 let ( let* ) x f = concat_map f x      (* bind: sequence computations *) let ( let+ ) x f = List.map f x        (* map: apply pure function *) let ( and* ) x y = concat_map (fun a -&gt; List.map (fun b -&gt; (a, b)) y) x let ( and+ ) = ( and* )                (* parallel binding *) let return x = [x]                     (* inject a value into the monad *) let fail = []                          (* the empty computation *)</code></p>
<p>The <code>let*</code> operator is the key: it sequences computations
where each step can produce multiple results. The <code>and*</code>
operator allows binding multiple values in parallel. With these
operators, the expression generation code becomes:</p>
<pre><code>let rec exprs = function
  | [] -&gt; []
  | [n] -&gt; [Val n]
  | ns -&gt;
      let* (ls, rs) = split ns in
      let* l = exprs ls in
      let* r = exprs rs in
      let* o = [Add; Sub; Mul; Div] in
      [App (o, l, r)]</code></pre>
<p>Each <code>let*</code> introduces a binding: the variable on the left
is bound to each value produced by the expression on the right, and the
computation continues with <code>in</code>. This is much more readable
than the nested callbacks we started with.</p>
<p>However, the <code>let*</code> syntax does not directly support
guards (conditions that filter results). If we try to write:</p>
<pre><code>let solutions ns n =
  let* ns&#39; = choices ns in
  let* e = exprs ns&#39; in
  eval e = Some n;  (* Error! *)
  e</code></pre>
<p>We get a type error: the expression expects a list, but
<code>eval e = Some n</code> is a boolean. What can we do?</p>
<p>One approach is to explicitly decide whether to return anything:</p>
<pre><code>let solutions ns n =
  let* ns&#39; = choices ns in
  let* e = exprs ns&#39; in
  if eval e = Some n then [e] else []</code></pre>
<p>But what if we want to check a condition earlier in the computation,
or check multiple conditions? We need a general “guard check” function.
The key insight is that we can use the monad itself to represent success
or failure:</p>
<p><code>ocaml env=ch8 let guard p = if p then [()] else []</code></p>
<p>When the condition <code>p</code> is true, <code>guard</code> returns
<code>[()]</code> – a list with one element (the unit value). When
false, it returns <code>[]</code> – an empty list. Now we can use it in
a binding:</p>
<pre><code>let solutions ns n =
  let* ns&#39; = choices ns in
  let* e = exprs ns&#39; in
  let* () = guard (eval e = Some n) in
  [e]</code></pre>
<p>Why does this work? When the guard succeeds,
<code>let* () = [()]</code> binds unit and continues. When it fails,
<code>let* () = []</code> produces no results – the empty list – so the
rest of the computation is never reached for that branch. This is
exactly the filtering behavior we want!</p>
<h3 id="monads">8.3 Monads</h3>
<p>Now we are ready to define monads properly. A <strong>monad</strong>
is a polymorphic type <code>'a monad</code> (or <code>'a Monad.t</code>)
that supports at least two operations:</p>
<ul>
<li><code>bind : 'a monad -&gt; ('a -&gt; 'b monad) -&gt; 'b monad</code>
– sequence two computations, passing the result of the first to the
second</li>
<li><code>return : 'a -&gt; 'a monad</code> – inject a pure value into
the monad</li>
<li>The infix <code>&gt;&gt;=</code> is commonly used for
<code>bind</code>: <code>let (&gt;&gt;=) a b = bind a b</code></li>
</ul>
<p>The <code>bind</code> operation is the heart of the monad: it takes a
computation that produces an <code>'a</code>, and a function that takes
an <code>'a</code> and produces a new computation yielding
<code>'b</code>. The result is a combined computation that yields
<code>'b</code>.</p>
<p>With OCaml 5’s binding operators, we define <code>let*</code> as an
alias for <code>bind</code>:</p>
<p>```ocaml env=ch8 let bind a b = concat_map b a let return x = [x] let
( let* ) = bind</p>
<p>let solutions ns n = let* ns’ = choices ns in let* e = exprs ns’ in
let* () = guard (eval e = Some n) in return e</p>
<pre><code>
But why does `guard` look the way it does? Let us examine more carefully:

```ocaml env=ch8
let fail = []
let guard p = if p then return () else fail</code></pre>
<p>Steps in monadic computation are composed with <code>let*</code> (or
<code>&gt;&gt;=</code>, which is like <code>|-&gt;</code> for lists).
The key insight is understanding what happens when we bind with an empty
list versus a singleton:</p>
<ul>
<li><code>let* _ = [] in ...</code> does not produce anything – the
continuation is never called, so the computation fails (produces no
results)</li>
<li><code>let* _ = [()] in ...</code> calls the continuation once with
<code>()</code>, which simply continues the computation unchanged</li>
</ul>
<p>This is why <code>guard</code> works: returning <code>[()]</code>
means “succeed with unit” and returning <code>[]</code> means “fail with
no results.” The unit value itself is a dummy – we only care whether the
list is empty or not.</p>
<p>Throwing away the binding argument is a common pattern. With binding
operators, we use <code>let* () = ...</code> or
<code>let* _ = ...</code> to indicate we do not need the bound
value:</p>
<p><code>ocaml env=ch8 let (&gt;&gt;=) a b = bind a b let (&gt;&gt;) m f = m &gt;&gt;= (fun _ -&gt; f)</code></p>
<p>The <code>&gt;&gt;</code> operator (called “sequence” or “then”) is
useful when you want to perform a computation for its effect but discard
its result.</p>
<h4 id="the-binding-operator-syntax">The Binding Operator Syntax</h4>
<p>For reference, OCaml 5’s binding operators translate as follows:</p>
<table>
<colgroup>
<col style="width: 38%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr>
<th>Source</th>
<th>Translation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>let* x = exp in body</code></td>
<td><code>bind exp (fun x -&gt; body)</code></td>
</tr>
<tr>
<td><code>let+ x = exp in body</code></td>
<td><code>map (fun x -&gt; body) exp</code></td>
</tr>
<tr>
<td><code>let* () = exp in body</code></td>
<td><code>bind exp (fun () -&gt; body)</code></td>
</tr>
<tr>
<td><code>let* x = e1 and* y = e2 in body</code></td>
<td><code>bind (and* e1 e2) (fun (x, y) -&gt; body)</code></td>
</tr>
</tbody>
</table>
<p>The binding operators <code>let*</code>, <code>let+</code>,
<code>and*</code>, and <code>and+</code> must be defined in scope. These
are regular OCaml operators and require no syntax extensions – a
significant improvement over the old Camlp4 approach.</p>
<p>Note: For pattern matching in bindings, if the pattern is refutable
(can fail to match), the monadic operation should handle the failure
appropriately. For example, <code>let* Some x = e in body</code>
requires a way to handle the <code>None</code> case.</p>
<h3 id="monad-laws">8.4 Monad Laws</h3>
<p>Not every type with <code>bind</code> and <code>return</code>
operations is a proper monad. A parametric data type is a monad only if
its <code>bind</code> and <code>return</code> operations meet three
fundamental axioms:</p>
<p><span class="math display">
\begin{aligned}
\text{bind}\ (\text{return}\ a)\ f &amp;\approx f\ a &amp; \text{(left
identity)} \\
\text{bind}\ a\ (\lambda x.\text{return}\ x) &amp;\approx a &amp;
\text{(right identity)} \\
\text{bind}\ (\text{bind}\ a\ (\lambda x.b))\ (\lambda y.c) &amp;\approx
\text{bind}\ a\ (\lambda x.\text{bind}\ b\ (\lambda y.c)) &amp;
\text{(associativity)}
\end{aligned}
</span></p>
<p>Let us understand what these laws mean:</p>
<ul>
<li><strong>Left identity</strong>: If you inject a value with
<code>return</code> and immediately bind it to a function, you get the
same result as just applying the function. The <code>return</code>
operation should not add any extra “effects.”</li>
<li><strong>Right identity</strong>: If you bind a computation to
<code>return</code>, you get back the same computation. The
<code>return</code> operation is neutral.</li>
<li><strong>Associativity</strong>: Binding is associative – it does not
matter how you group nested binds. This means
<code>let* x = (let* y = a in b) in c</code> is equivalent to
<code>let* y = a in let* x = b in c</code> (when <code>x</code> does not
appear free in <code>b</code>).</li>
</ul>
<p>You should verify that these laws hold for our list monad:</p>
<p><code>ocaml env=ch8 let bind a b = concat_map b a let return x = [x]</code></p>
<p>For example, to verify left identity: <code>bind (return a) f</code>
= <code>bind [a] f</code> = <code>concat_map f [a]</code> =
<code>f a</code>. The other laws can be verified similarly.</p>
<h3 id="monoid-laws-and-monad-plus">8.5 Monoid Laws and Monad-Plus</h3>
<p>The list monad has an additional structure beyond just
<code>bind</code> and <code>return</code>: it supports combining
multiple computations and representing failure. This leads us to the
concept of a <strong>monoid</strong>.</p>
<p>A monoid is a type with at least two operations:</p>
<ul>
<li><code>mzero : 'a monoid</code> – an identity element (think: zero,
or the empty container)</li>
<li><code>mplus : 'a monoid -&gt; 'a monoid -&gt; 'a monoid</code> – a
combining operation (think: addition, or concatenation)</li>
</ul>
<p>These operations must meet the standard monoid laws:</p>
<p><span class="math display">
\begin{aligned}
\text{mplus}\ \text{mzero}\ a &amp;\approx a &amp; \text{(left
identity)} \\
\text{mplus}\ a\ \text{mzero} &amp;\approx a &amp; \text{(right
identity)} \\
\text{mplus}\ a\ (\text{mplus}\ b\ c) &amp;\approx \text{mplus}\
(\text{mplus}\ a\ b)\ c &amp; \text{(associativity)}
\end{aligned}
</span></p>
<p>We define <code>fail</code> as a synonym for <code>mzero</code> and
infix <code>++</code> for <code>mplus</code>. For lists,
<code>mzero</code> is <code>[]</code> and <code>mplus</code> is
<code>@</code> (append).</p>
<p>Fusing monads and monoids gives the most popular general flavor of
monads, which we call <strong>monad-plus</strong> after Haskell. A
monad-plus is a monad that also has monoid structure, with additional
axioms relating the “addition” (<code>mplus</code>) and “multiplication”
(<code>bind</code>):</p>
<p><span class="math display">
\begin{aligned}
\text{bind}\ \text{mzero}\ f &amp;\approx \text{mzero} \\
\text{bind}\ m\ (\lambda x.\text{mzero}) &amp;\approx \text{mzero}
\end{aligned}
</span></p>
<p>These laws say that <code>mzero</code> acts like a “zero” for
<code>bind</code>: binding from zero produces zero, and binding to a
function that always returns zero also produces zero. This is analogous
to how <span class="math inline">0 \times x = 0</span> and <span
class="math inline">x \times 0 = 0</span> in arithmetic.</p>
<p>Using infix notation with <span class="math inline">\oplus</span> for
<code>mplus</code>, <span class="math inline">\mathbf{0}</span> for
<code>mzero</code>, <span class="math inline">\triangleright</span> for
<code>bind</code>, and <span class="math inline">\mathbf{1}</span> for
<code>return</code>, the complete monad-plus axioms are:</p>
<p><span class="math display">
\begin{aligned}
\mathbf{0} \oplus a &amp;\approx a \\
a \oplus \mathbf{0} &amp;\approx a \\
a \oplus (b \oplus c) &amp;\approx (a \oplus b) \oplus c \\
\mathbf{1}\ x \triangleright f &amp;\approx f\ x \\
a \triangleright \lambda x.\mathbf{1}\ x &amp;\approx a \\
(a \triangleright \lambda x.b) \triangleright \lambda y.c &amp;\approx a
\triangleright (\lambda x.b \triangleright \lambda y.c) \\
\mathbf{0} \triangleright f &amp;\approx \mathbf{0} \\
a \triangleright (\lambda x.\mathbf{0}) &amp;\approx \mathbf{0}
\end{aligned}
</span></p>
<p>The list type has a natural monad and monoid structure:</p>
<p><code>ocaml env=ch8 let mzero = [] let mplus = (@) let bind a b = concat_map b a let return a = [a]</code></p>
<p>Given any monad-plus, we can define useful derived operations:</p>
<p><code>ocaml env=ch8 let fail = mzero let (++) = mplus let (&gt;&gt;=) a b = bind a b let guard p = if p then return () else fail</code></p>
<p>Now we can see that <code>guard</code> is defined in terms of the
monad-plus structure: it returns the identity element
(<code>return ()</code>) on success, or the zero element
(<code>fail</code>) on failure.</p>
<h3 id="backtracking-computation-with-choice">8.6 Backtracking:
Computation with Choice</h3>
<p>We have seen <code>mzero</code> (i.e., <code>fail</code>) in the
countdown problem – it represents a computation that produces no
results. But what about <code>mplus</code>? The <code>mplus</code>
operation combines two computations, giving us a way to express
<em>choice</em>: try this computation, or try that one.</p>
<p>Here is an example from a puzzle solver where <code>mplus</code>
creates a choice point:</p>
<p>```ocaml skip let find_to_eat n island_size num_islands empty_cells =
let honey = honey_cells n empty_cells in</p>
<p>let rec find_board s = match visit_cell s with | None -&gt; let* () =
guard (s.been_islands = num_islands) in return s.eaten | Some (cell, s)
-&gt; let* s = find_island cell (fresh_island s) in let* () = guard
(s.been_size = island_size) in find_board s</p>
<p>and find_island current s = let s = keep_cell current s in neighbors
n empty_cells current |&gt; foldM (fun neighbor s -&gt; if CellSet.mem
neighbor s.visited then return s else let choose_eat = if s.more_to_eat
&lt;= 0 then fail else return (eat_cell neighbor s) and choose_keep = if
s.been_size &gt;= island_size then fail else find_island neighbor s in
mplus choose_eat choose_keep) (* Choice point! *) s in</p>
<p>let cells_to_eat = List.length honey - island_size * num_islands in
find_board (init_state honey cells_to_eat)</p>
<pre><code>
The line `mplus choose_eat choose_keep` creates a choice point: the algorithm can either eat the cell (removing it from consideration) or keep it as part of the current island. When we use the list monad as our monad-plus, this explores *all* possible choices, collecting all solutions. The monad-plus structure handles the bookkeeping of backtracking automatically -- we just express the choices declaratively.

### 8.7 Monad Flavors

Monads &quot;wrap around&quot; a type, but some monads need an additional type parameter. For example, a state monad might be parameterized by the type of state it carries. Usually the additional type does not change while within a monad, so we stick to `&#39;a monad` rather than `(&#39;s, &#39;a) monad`.

As monad-plus shows, things get interesting when we add more operations to a basic monad. Different &quot;flavors&quot; of monads provide different capabilities. Here are the most common ones:

**Monads with access:**
</code></pre>
<p>access : ’a monad -&gt; ’a</p>
<pre><code>
An `access` operation lets you extract the value from the monad. Not all monads support this -- some only allow you to &quot;run&quot; the monad at the top level. Example: the lazy monad, where `access` is `Lazy.force`.

**Monad-plus (non-deterministic computation):**
</code></pre>
<p>mzero : ’a monad mplus : ’a monad -&gt; ’a monad -&gt; ’a monad</p>
<pre><code>
We have already seen this. The monad-plus flavor supports failure and choice, enabling backtracking search.

**Monads with state (parameterized by type `store`):**
</code></pre>
<p>get : store monad put : store -&gt; unit monad</p>
<pre><code>
These operations let you read and write a piece of state that is threaded through the computation. There is a &quot;canonical&quot; state monad we will examine later. Related monads include:
- The **writer monad**: has `tell` (append to a log) and `listen` (read the log)
- The **reader monad**: has `ask` (read an environment) and `local` to modify the environment for a sub-computation:
</code></pre>
<p>local : (store -&gt; store) -&gt; ’a monad -&gt; ’a monad</p>
<pre><code>
**Exception/error monads (parameterized by type `excn`):**
</code></pre>
<p>throw : excn -&gt; ’a monad catch : ’a monad -&gt; (excn -&gt; ’a
monad) -&gt; ’a monad</p>
<pre><code>
These provide structured error handling within the monad. The `throw` operation raises an exception; `catch` handles it.

**Continuation monad:**
</code></pre>
<p>callCC : ((’a -&gt; ’b monad) -&gt; ’a monad) -&gt; ’a monad</p>
<pre><code>
The continuation monad gives you access to the &quot;rest of the computation&quot; as a first-class value. This is powerful but complex; we will not cover continuations in detail here.

**Probabilistic computation:**
</code></pre>
<p>choose : float -&gt; ’a monad -&gt; ’a monad -&gt; ’a monad</p>
<pre><code>
The `choose p a b` operation selects `a` with probability `p` and `b` with probability `1-p`. This enables reasoning about probability distributions. The laws ensure that probability behaves correctly:

$$
\begin{aligned}
a \oplus_0 b &amp;\approx b \\
a \oplus_p b &amp;\approx b \oplus_{1-p} a \\
a \oplus_p (b \oplus_q c) &amp;\approx (a \oplus_{\frac{p}{p+q-pq}} b) \oplus_{p+q-pq} c \\
a \oplus_p a &amp;\approx a
\end{aligned}
$$

**Parallel computation (monad with access and parallel bind):**
</code></pre>
<p>parallel : ’a monad -&gt; ’b monad -&gt; (’a -&gt; ’b -&gt; ’c monad)
-&gt; ’c monad</p>
<pre><code>
The `parallel` operation runs two computations concurrently and combines their results. Example: lightweight threads like in the Lwt library.

### 8.8 Interlude: The Module System

Before we implement various monads, we need to understand OCaml&#39;s module system, which provides the infrastructure for defining monads in a reusable, generic way. This section provides a brief overview of the key concepts.

Modules collect related type definitions and operations together. Module values are introduced with `struct ... end` (called *structures*), and module types with `sig ... end` (called *signatures*). A structure is a package of definitions; a signature is an interface that specifies what a structure must provide.

A source file `source.ml` defines a module `Source`. A file `source.mli` defines its type.

In the module level, modules are defined with `module ModuleName = ...` or `module ModuleName : MODULE_TYPE = ...`, and module types with `module type MODULE_TYPE = ...`.

Locally in expressions, modules are defined with `let module M = ... in ...`.

The content of a module is made visible with `open Module`. Module `Pervasives` (now `Stdlib`) is initially visible.

Content of a module is included into another module with `include Module`.

**Functors** are module functions -- functions from modules to modules. They are the key to writing generic code that works with any monad:
</code></pre>
<p>module Funct = functor (Arg : sig … end) -&gt; struct … end (* Or
equivalently: *) module Funct (Arg : sig … end) = struct … end</p>
<pre><code>
Functors can return functors, and modules can be parameterized by multiple modules. Functor application always uses parentheses: `Funct (struct ... end)`.

A signature `MODULE_TYPE with type t_name = ...` is like `MODULE_TYPE` but with `t_name` made more specific. This is useful when you want to expose the concrete type after applying a functor. We can also include signatures with `include MODULE_TYPE`.

Finally, we can pass around modules in normal functions using first-class modules:

```ocaml env=ch8
module type T = sig val g : int -&gt; int end

let f mod_v x =
  let module M = (val mod_v : T) in
  M.g x
(* val f : (module T) -&gt; int -&gt; int = &lt;fun&gt; *)

let test = f (module struct let g i = i*i end : T)
(* val test : int -&gt; int = &lt;fun&gt; *)</code></pre>
<h3 id="the-two-metaphors">8.9 The Two Metaphors</h3>
<p>Monads are abstract, but two complementary metaphors can help build
intuition for what they are and how they work.</p>
<h4 id="monads-as-containers">Monads as Containers</h4>
<p>The first metaphor views a monad as a <strong>quarantine
container</strong>. Think of it like a sealed box:</p>
<ul>
<li>We can put something into the container with <code>return</code> –
this “seals” a pure value inside the monad</li>
<li>We can operate on the contents, but the result must stay in the
container – we cannot simply extract values</li>
</ul>
<p>The <code>lift</code> function applies a pure function to the
contents of a monad, keeping the result wrapped:</p>
<p><code>ocaml env=ch8 let lift f m =   let* x = m in   return (f x) (* val lift : ('a -&gt; 'b) -&gt; 'a monad -&gt; 'b monad *)</code></p>
<p>We can also “flatten” nested containers. If we have a monad
containing another monad, <code>join</code> unwraps one layer – but the
result is still in a monad, so the quarantine is not broken:</p>
<p><code>ocaml env=ch8 let join m =   let* x = m in   x (* val join : ('a monad) monad -&gt; 'a monad *)</code></p>
<p>The quarantine container for a <strong>monad-plus</strong> is more
like a collection: it can be empty (failure), contain one element
(success), or contain multiple elements (multiple solutions).</p>
<p>Monads with access allow us to extract the resulting element from the
container. Other monads provide a <code>run</code> operation that
exposes “what really happened behind the quarantine” – for example, the
state monad’s <code>run</code> takes an initial state and returns both
the final value and the final state.</p>
<h4 id="monads-as-computation">Monads as Computation</h4>
<p>The second metaphor views a monad as a way to structure computation.
Each <code>let*</code> binding is a step in a sequence, and the monad
controls how steps are connected. The physical metaphor is an
<strong>assembly line</strong>:</p>
<pre><code>let assemblyLine w =
  let* c = makeChopsticks w in    (* Worker makes chopsticks *)
  let* c&#39; = polishChopsticks c in (* Worker polishes them *)
  let* c&#39;&#39; = wrapChopsticks c&#39; in (* Worker wraps them *)
  return c&#39;&#39;                       (* Final product goes out *)</code></pre>
<p>Each worker (operation) takes material from the previous step and
produces something for the next step. The monad defines what happens
between steps – for lists, it means “do this for each element”; for
state, it means “thread the state through”; for exceptions, it means
“propagate errors.”</p>
<p>Any expression can be systematically translated into a monadic form.
For lambda-terms:</p>
<p><span class="math display">
\begin{aligned}
[\![ N ]\!] &amp;= \text{return}\ N &amp; \text{(constant)} \\
[\![ x ]\!] &amp;= \text{return}\ x &amp; \text{(variable)} \\
[\![ \lambda x.a ]\!] &amp;= \text{return}\ (\lambda x.[\![ a ]\!])
&amp; \text{(function)} \\
[\![ \text{let}\ x = a\ \text{in}\ b ]\!] &amp;= \text{bind}\ [\![ a
]\!]\ (\lambda x.[\![ b ]\!]) &amp; \text{(local definition)} \\
[\![ a\ b ]\!] &amp;= \text{bind}\ [\![ a ]\!]\ (\lambda
v_a.\text{bind}\ [\![ b ]\!]\ (\lambda v_b.v_a\ v_b)) &amp;
\text{(application)}
\end{aligned}
</span></p>
<p>This translation inserts <code>bind</code> at every point where
execution flows from one subexpression to another. The beauty of this
approach is that once an expression is spread over a monad, its
computation can be monitored, logged, or affected without modifying the
expression itself. This is the key to implementing effects like state,
exceptions, or non-determinism in a purely functional way.</p>
<h3 id="monad-classes-and-instances">8.10 Monad Classes and
Instances</h3>
<p>Now we will see how to implement monads in OCaml using the module
system. To implement a monad, we need to provide the implementation
type, <code>return</code>, and <code>bind</code> operations. Here is the
minimal signature:</p>
<p><code>ocaml env=ch8 module type MONAD = sig   type 'a t   val return : 'a -&gt; 'a t   val bind : 'a t -&gt; ('a -&gt; 'b t) -&gt; 'b t end</code></p>
<p>This is the “class” that all monads must implement. Alternatively, we
could start from <code>return</code>, <code>lift</code>, and
<code>join</code> operations – these are mathematically equivalent
starting points.</p>
<p>The power of functors is that we can define a suite of
general-purpose functions that work for <em>any</em> monad, just based
on these two operations:</p>
<p>```ocaml env=ch8 module type MONAD_OPS = sig type ’a monad include
MONAD with type ’a t := ’a monad val ( let* ) : ’a monad -&gt; (’a -&gt;
’b monad) -&gt; ’b monad val ( let+ ) : ’a monad -&gt; (’a -&gt; ’b)
-&gt; ’b monad val ( &gt;&gt;= ) : ’a monad -&gt; (’a -&gt; ’b monad)
-&gt; ’b monad val foldM : (’a -&gt; ’b -&gt; ’a monad) -&gt; ’a -&gt;
’b list -&gt; ’a monad val whenM : bool -&gt; unit monad -&gt; unit
monad val lift : (’a -&gt; ’b) -&gt; ’a monad -&gt; ’b monad val
(&gt;&gt;|) : ’a monad -&gt; (’a -&gt; ’b) -&gt; ’b monad val join : ’a
monad monad -&gt; ’a monad val ( &gt;=&gt;) : (’a -&gt; ’b monad) -&gt;
(’b -&gt; ’c monad) -&gt; ’a -&gt; ’c monad end</p>
<p>module MonadOps (M : MONAD) = struct open M type ‘a monad = ’a t let
run x = x let ( let* ) a b = bind a b let ( let+ ) a f = bind a (fun x
-&gt; return (f x)) let (&gt;&gt;=) a b = bind a b let rec foldM f a =
function | [] -&gt; return a | x::xs -&gt; let* a’ = f a x in foldM f a’
xs let whenM p s = if p then s else return () let lift f m = let* x = m
in return (f x) let (&gt;&gt;|) a b = lift b a let join m = let* x = m
in x let (&gt;=&gt;) f g = fun x -&gt; let* y = f x in g y end</p>
<pre><code>
We make the monad &quot;safe&quot; by keeping its type abstract. The `run` function exposes the underlying representation -- &quot;what really happened behind the scenes&quot;:

```ocaml env=ch8
module Monad (M : MONAD) : sig
  include MONAD_OPS
  val run : &#39;a monad -&gt; &#39;a M.t
end = struct
  include M
  include MonadOps(M)
end</code></pre>
<p>The pattern here is important: we take a minimal implementation
(<code>M : MONAD</code>) and produce a full-featured monad module with
all the derived operations.</p>
<h4 id="monad-plus-classes">Monad-Plus Classes</h4>
<p>The monad-plus class extends the basic monad with failure and choice.
Implementations need to provide <code>mzero</code> and
<code>mplus</code> in addition to <code>return</code> and
<code>bind</code>:</p>
<p>```ocaml env=ch8 module type MONAD_PLUS = sig include MONAD val mzero
: ’a t val mplus : ’a t -&gt; ’a t -&gt; ’a t end</p>
<p>module type MONAD_PLUS_OPS = sig include MONAD_OPS val mzero : ’a
monad val mplus : ’a monad -&gt; ’a monad -&gt; ’a monad val fail : ’a
monad val (++) : ’a monad -&gt; ’a monad -&gt; ’a monad val guard : bool
-&gt; unit monad val msum_map : (’a -&gt; ’b monad) -&gt; ’a list -&gt;
’b monad end</p>
<p>module MonadPlusOps (M : MONAD_PLUS) = struct open M include
MonadOps(M) let fail = mzero let (++) a b = mplus a b let guard p = if p
then return () else fail let msum_map f l = List.fold_right (fun a acc
-&gt; mplus (f a) acc) l mzero end</p>
<p>module MonadPlus (M : MONAD_PLUS) : sig include MONAD_PLUS_OPS val
run : ’a monad -&gt; ’a M.t end = struct include M include
MonadPlusOps(M) end</p>
<pre><code>
We also need a class for computations with state. This signature will be included in state monads:

```ocaml env=ch8
module type STATE = sig
  type store
  type &#39;a t
  val get : store t
  val put : store -&gt; unit t
end</code></pre>
<h3 id="monad-instances">8.11 Monad Instances</h3>
<p>Now let us see concrete implementations of various monads.</p>
<h4 id="the-lazy-monad">The Lazy Monad</h4>
<p>If you find OCaml’s laziness notation (with <code>lazy</code> and
<code>Lazy.force</code> everywhere) too heavy, you can use a monad! The
lazy monad wraps lazy computations:</p>
<p>```ocaml env=ch8 module LazyM = Monad (struct type ’a t = ’a Lazy.t
let bind a b = lazy (Lazy.force (b (Lazy.force a))) let return a = lazy
a end)</p>
<p>let laccess m = Lazy.force (LazyM.run m)</p>
<pre><code>
The `bind` operation creates a new lazy value that, when forced, forces `a`, passes the result to `b`, and forces the result. The `laccess` function forces the final lazy value to get the result.

#### The List Monad

Our familiar list monad is a monad-plus, supporting non-deterministic computation:

```ocaml env=ch8
module ListM = MonadPlus (struct
  type &#39;a t = &#39;a list
  let bind a b = concat_map b a
  let return a = [a]
  let mzero = []
  let mplus = List.append
end)</code></pre>
<h4 id="backtracking-parameterized-by-monad-plus">Backtracking
Parameterized by Monad-Plus</h4>
<p>Here is the power of abstraction: we can write the Countdown solver
parameterized by <em>any</em> monad-plus. The same code works with lists
(exploring all solutions), lazy lists (computing solutions on demand),
or any other monad-plus implementation:</p>
<p>```ocaml env=ch8 module Countdown (M : MONAD_PLUS_OPS) = struct open
M (* Open the module to make monad operations visible *)</p>
<p>let rec insert x = function (* All choice-introducing operations
<em>) | [] -&gt; return [x] (</em> need to happen in the monad <em>) |
y::ys as xs -&gt; let</em> xys = insert x ys in return (x::xs) ++ return
(y::xys)</p>
<p>let rec choices = function | [] -&gt; return [] | x::xs -&gt; let*
cxs = choices xs in (* Choosing which numbers in what order <em>) return
cxs ++ insert x cxs (</em> and now whether with or without x *)</p>
<p>type op = Add | Sub | Mul | Div</p>
<p>let apply op x y = match op with | Add -&gt; x + y | Sub -&gt; x - y
| Mul -&gt; x * y | Div -&gt; x / y</p>
<p>let valid op x y = match op with | Add -&gt; x &lt;= y | Sub -&gt; x
&gt; y | Mul -&gt; x &lt;= y &amp;&amp; x &lt;&gt; 1 &amp;&amp; y
&lt;&gt; 1 | Div -&gt; x mod y = 0 &amp;&amp; y &lt;&gt; 1</p>
<p>type expr = Val of int | App of op * expr * expr</p>
<p>let op2str = function | Add -&gt; “+” | Sub -&gt; “-” | Mul -&gt; “*”
| Div -&gt; “/”</p>
<p>let rec expr2str = function (* We will provide solutions as strings
*) | Val n -&gt; string_of_int n | App (op, l, r) -&gt; “(” ^ expr2str l
^ op2str op ^ expr2str r ^ “)”</p>
<p>let combine (l, x) (r, y) o = (* Try out an operator <em>) let</em>
() = guard (valid o x y) in return (App (o, l, r), apply o x y)</p>
<p>let split l = (* Another choice: which numbers go into which argument
<em>) let rec aux lhs = function | [] | [_] -&gt; fail (</em> Both
arguments need numbers *) | [y; z] -&gt; return (List.rev (y::lhs), [z])
| hd::rhs -&gt; let lhs = hd::lhs in return (List.rev lhs, rhs) ++ aux
lhs rhs in aux [] l</p>
<p>let rec results = function (* Build possible expressions once numbers
<em>) | [] -&gt; fail (</em> have been picked <em>) | [n] -&gt; let</em>
() = guard (n &gt; 0) in return (Val n, n) | ns -&gt; let* (ls, rs) =
split ns in let* lx = results ls in let* ly = results rs in (* Collect
solutions using each operator *) msum_map (combine lx ly) [Add; Sub;
Mul; Div]</p>
<p>let solutions ns n = (* Solve the problem: <em>) let</em> ns’ =
choices ns in (* pick numbers and their order, <em>) let</em> (e, m) =
results ns’ in (* build possible expressions, <em>) let</em> () = guard
(m = n) in (* check if the expression gives target value, <em>) return
(expr2str e) (</em> “print” the solution *) end</p>
<pre><code>
#### Understanding Laziness

Now let us explore a practical question: what if we only want *one* solution, not all of them? With the list monad, we compute all solutions even if we only look at the first one. Can laziness help?

Let us sketch how you might measure execution times to find out (the numbers will vary wildly between machines, and the full Countdown search is expensive enough that it is better left out of mdx tests):

```ocaml env=ch8
let time f =
  let tbeg = Sys.time () in
  let res = f () in
  let tend = Sys.time () in
  tend -. tbeg, res</code></pre>
<p>With the list monad:</p>
<p><code>ocaml skip module ListCountdown = Countdown (ListM) let test1 () = ListM.run (ListCountdown.solutions [1;3;7;10;25;50] 765) let t1, sol1 = time test1 (* val t1 : float = 2.28... *) (* val sol1 : string list = ["((25-(3+7))*(1+50))"; "(((25-3)-7)*(1+50))"; ...] *)</code></p>
<p>Finding all 49 solutions takes about 2.3 seconds. What if we want
only one solution? Laziness to the rescue!</p>
<p>Our first attempt uses an “odd lazy list” – a list where the tail is
lazy but the head is strict:</p>
<p>```ocaml env=ch8 type ’a llist = LNil | LCons of ’a * ’a llist
Lazy.t</p>
<p>let rec ltake n = function | LCons (a, lazy l) when n &gt; 0 -&gt;
a::(ltake (n-1) l) | _ -&gt; []</p>
<p>let rec lappend l1 l2 = match l1 with | LNil -&gt; l2 | LCons (hd,
tl) -&gt; LCons (hd, lazy (lappend (Lazy.force tl) l2))</p>
<p>let rec lconcat_map f = function | LNil -&gt; LNil | LCons (a, lazy
l) -&gt; lappend (f a) (lconcat_map f l)</p>
<p>module LListM = MonadPlus (struct type ’a t = ’a llist let bind a b =
lconcat_map b a let return a = LCons (a, lazy LNil) let mzero = LNil let
mplus = lappend end)</p>
<pre><code>
But testing shows disappointing results: the odd lazy list still takes about 2.5 seconds just to create the lazy list! The elements are almost all computed by the time we get the first one.

Why? Because whenever we pattern match on `LCons (hd, tl)`, we have already evaluated the head. And when building lists with `mplus`, the head of the first list is computed immediately.

What about using the **option monad** to find just the first solution?

```ocaml env=ch8
module OptionM = MonadPlus (struct
  type &#39;a t = &#39;a option
  let bind a b =
    match a with None -&gt; None | Some x -&gt; b x
  let return a = Some a
  let mzero = None
  let mplus a b = match a with None -&gt; b | Some _ -&gt; a
end)</code></pre>
<p>This very quickly computes… nothing! The option monad returns
<code>None</code>.</p>
<p>Why? The <code>OptionM</code> monad (Haskell’s <code>Maybe</code>
monad) is good for computations that might fail, but it does not
<em>search</em> – its <code>mplus</code> just picks the first
non-<code>None</code> value. Since our search often needs to backtrack
when a choice leads to failure, option gives up too early.</p>
<p>Our odd lazy list type is not lazy <em>enough</em>. Whenever we
“make” a choice with <code>a ++ b</code> or <code>msum_map</code>, it
computes the first candidate for each choice path immediately. We need
<strong>even lazy lists</strong> – lists where even the outermost
constructor is wrapped in <code>lazy</code>:</p>
<p>```ocaml env=ch8 type ’a lazy_list = ’a lazy_list_ Lazy.t and ’a
lazy_list_ = LazNil | LazCons of ’a * ’a lazy_list</p>
<p>let rec laztake n = function | lazy (LazCons (a, l)) when n &gt; 0
-&gt; a::(laztake (n-1) l) | _ -&gt; []</p>
<p>let rec append_aux l1 l2 = match l1 with | lazy LazNil -&gt;
Lazy.force l2 | lazy (LazCons (hd, tl)) -&gt; LazCons (hd, lazy
(append_aux tl l2))</p>
<p>let lazappend l1 l2 = lazy (append_aux l1 l2)</p>
<p>let rec concat_map_aux f = function | lazy LazNil -&gt; LazNil | lazy
(LazCons (a, l)) -&gt; append_aux (f a) (lazy (concat_map_aux f l))</p>
<p>let lazconcat_map f l = lazy (concat_map_aux f l)</p>
<p>module LazyListM = MonadPlus (struct type ’a t = ’a lazy_list let
bind a b = lazconcat_map b a let return a = lazy (LazCons (a, lazy
LazNil)) let mzero = lazy LazNil let mplus = lazappend end)</p>
<pre><code>
Now the first solution takes only about 0.37 seconds -- considerably less time than the 2.3 seconds for all solutions! The next 9 solutions are almost computed once the first one is (just 0.23 seconds more). But computing all 49 solutions takes about 4 seconds -- nearly twice as long as without laziness. This is the price we pay for lazy computation: overhead when we do need all results.

The lesson: even lazy lists enable true lazy search, but they come with overhead. Choose the right monad for your use case.

#### The Exception Monad

OCaml has built-in exceptions that are efficient and flexible. However, monadic exceptions have advantages in certain situations:

- They are safer in multi-threading contexts (no risk of unhandled exceptions escaping)
- They compose well with other monads (via monad transformers)
- They make the possibility of failure explicit in the type

The monadic lightweight-thread library Lwt has `throw` (called `fail` there) and `catch` operations in its monad for exactly these reasons.

```ocaml env=ch8
module ExceptionM (Excn : sig type t end) : sig
  type excn = Excn.t
  type &#39;a t = OK of &#39;a | Bad of excn
  include MONAD_OPS
  val run : &#39;a monad -&gt; &#39;a t
  val throw : excn -&gt; &#39;a monad
  val catch : &#39;a monad -&gt; (excn -&gt; &#39;a monad) -&gt; &#39;a monad
end = struct
  type excn = Excn.t
  module M = struct
    type &#39;a t = OK of &#39;a | Bad of excn
    let return a = OK a
    let bind m b = match m with
      | OK a -&gt; b a
      | Bad e -&gt; Bad e
  end
  include M
  include MonadOps(M)
  let throw e = Bad e
  let catch m handler = match m with
    | OK _ -&gt; m
    | Bad e -&gt; handler e
end</code></pre>
<h4 id="the-state-monad">The State Monad</h4>
<p>The state monad threads a piece of mutable state through a
computation without actually using mutation. The key insight is that a
stateful computation can be represented as a <em>function</em> from the
current state to a pair of (result, new state):</p>
<p><code>ocaml env=ch8 module StateM (Store : sig type t end) : sig   type store = Store.t   type 'a t = store -&gt; 'a * store  (* A stateful computation *)   include MONAD_OPS   include STATE with type 'a t := 'a monad                  and type store := store   val run : 'a monad -&gt; 'a t end = struct   type store = Store.t   module M = struct     type 'a t = store -&gt; 'a * store     let return a = fun s -&gt; a, s     (* Return value, keep state unchanged *)     let bind m b = fun s -&gt; let a, s' = m s in b a s'   end                          (* Run m, then pass result and new state to b *)   include M   include MonadOps(M)   let get = fun s -&gt; s, s            (* Return the current state *)   let put s' = fun _ -&gt; (), s'       (* Replace the state, return unit *) end</code></p>
<p>The <code>bind</code> operation sequences two stateful computations:
it runs the first one with the initial state, then passes both the
result and the new state to the second computation.</p>
<p>The state monad is useful to hide the threading of a “current” value
through a computation. Here is an example that renames variables in
lambda-terms to eliminate potential name clashes (alpha-conversion):</p>
<p>```ocaml env=ch8 type term = | Var of string | Lam of string * term |
App of term * term</p>
<p>module TermOps = struct let (!) x = Var x let (|-&gt;) x t = Lam (x,
t) let (@) t1 t2 = App (t1, t2) end let test = TermOps.(“x” |-&gt; (“x”
|-&gt; !“y” @ !“x”) @ !“x”)</p>
<p>module S = StateM (struct type t = int * (string * string) list end)
open S</p>
<p>let rec alpha_conv = function | Var x as v -&gt; (* Function from
terms to StateM monad <em>) let</em> (<em>, env) = get in (* Seeing a
variable does not change state <em>) let v = try Var (List.assoc x env)
(</em> but we need its new name <em>) with Not_found -&gt; v in (</em>
Free variables don’t change name <em>) return v | Lam (x, t) -&gt;
(</em> We rename each bound variable <em>) let</em> (fresh, env) = get
in (* We need a fresh number <em>) let x’ = x ^ string_of_int fresh in
let</em> () = put (fresh+1, (x, x’)::env) in (* Remember new name,
update number <em>) let</em> t’ = alpha_conv t in let* (fresh’, </em>) =
get in (* We need to restore names, <em>) let</em> () = put (fresh’,
env) in (* but keep the number fresh <em>) return (Lam (x’, t’)) | App
(t1, t2) -&gt; let</em> t1 = alpha_conv t1 in (* Passing around of names
<em>) let</em> t2 = alpha_conv t2 in (* and the currently fresh number
<em>) return (App (t1, t2)) (</em> is done by the monad *)</p>
<p>(* # StateM.run (alpha_conv test) (5, []);; *)</p>
<pre><code>
The state consists of a fresh counter and an environment mapping old names to new names. The `get` and `put` operations access and modify this state, while `let*` sequences the operations. Without the state monad, we would have to explicitly pass the state through every recursive call -- tedious and error-prone.

Note: This alpha-conversion does not make a lambda-term safe for multiple steps of beta-reduction. Can you find a counter-example?

### 8.12 Monad Transformers

Sometimes we need the capabilities of multiple monads at the same time. For example, we might want both state (to track information) and non-determinism (to explore choices). The straightforward idea is to nest one monad within another: either `&#39;a AM.monad BM.monad` or `&#39;a BM.monad AM.monad`. But this does not work well -- we want a single monad that has operations of *both* `AM` and `BM`.

The solution is a **monad transformer**. A monad transformer `AT` takes a monad `BM` and produces a new monad `AT(BM)` that has operations of both. The transformed monad wraps around `BM` in a specific way to make the operations interact correctly.

We will develop a monad transformer `StateT` which adds state to any monad-plus. The resulting monad has all the operations: `return`, `bind`, `mzero`, `mplus`, `put`, `get`, and all their derived functions.

Why do we need monad transformers in OCaml? Because &quot;monads are contagious&quot;: although we have built-in state and exceptions, we need to use *monadic* state and exceptions when we are inside a monad. For example, using OCaml&#39;s native `ref` cells inside a list monad would give the wrong semantics for backtracking. This is also why Lwt is both a concurrency monad and an exception monad -- it needs monadic exceptions to interact correctly with its concurrency model.

To understand how the transformer works, let us compare the regular state monad with the transformed version. The regular state monad uses ordinary OCaml binding:

```ocaml skip
type &#39;a state = store -&gt; (&#39;a * store)

let return (a : &#39;a) : &#39;a state =
  fun s -&gt; (a, s)

let bind (u : &#39;a state) (f : &#39;a -&gt; &#39;b state) : &#39;b state =
  fun s -&gt; let (a, s&#39;) = u s in f a s&#39;</code></pre>
<p>The transformed version wraps everything in the underlying monad
<code>M</code>:</p>
<p>```ocaml skip (* Monad M transformed to add state, in pseudo-code:
<em>) type ’a stateT(M) = store -&gt; (’a </em> store) M (* Note: this
is store -&gt; (’a * store) M, not (’a M) state *)</p>
<p>let return (a : ’a) : ’a stateT(M) = fun s -&gt; M.return (a, s) (*
Use M.return instead of just returning *)</p>
<p>let bind (u : ‘a stateT(M)) (f : ’a -&gt; ’b stateT(M)) : ’b
stateT(M) = fun s -&gt; M.bind (u s) (fun (a, s’) -&gt; f a s’) (* Use
M.bind instead of let *)</p>
<pre><code>
The key insight is that the result type is `(&#39;a * store) M` -- the result and state are wrapped *together* in the underlying monad. This ensures that backtracking (in a monad-plus) correctly restores the state.

#### State Transformer Implementation

```ocaml env=ch8
module StateT (MP : MONAD_PLUS_OPS) (Store : sig type t end) : sig
  type store = Store.t
  type &#39;a t = store -&gt; (&#39;a * store) MP.monad
  include MONAD_PLUS_OPS         (* Exporting all monad-plus operations *)
  include STATE with type &#39;a t := &#39;a monad
                 and type store := store  (* and state operations *)
  val run : &#39;a monad -&gt; &#39;a t     (* Expose &quot;what happened&quot; -- resulting states *)
  val runT : &#39;a monad -&gt; store -&gt; &#39;a MP.monad
end = struct              (* Run the state transformer -- get resulting values *)
  type store = Store.t
  module M = struct
    type &#39;a t = store -&gt; (&#39;a * store) MP.monad
    let return a = fun s -&gt; MP.return (a, s)
    let bind m b = fun s -&gt;
      MP.bind (m s) (fun (a, s&#39;) -&gt; b a s&#39;)
    let mzero = fun _ -&gt; MP.mzero            (* Lift the monad-plus operations *)
    let mplus ma mb = fun s -&gt; MP.mplus (ma s) (mb s)
  end
  include M
  include MonadPlusOps(M)
  let get = fun s -&gt; MP.return (s, s)        (* Instead of just returning, *)
  let put s&#39; = fun _ -&gt; MP.return ((), s&#39;)   (* MP.return *)
  let runT m s = MP.lift fst (m s)
end</code></pre>
<h4 id="backtracking-with-state">Backtracking with State</h4>
<p>Now we can combine backtracking with state for our puzzle solver. The
state tracks which cells have been visited, eaten, and how many islands
we have found. The monad-plus structure handles the backtracking when a
choice leads to a dead end:</p>
<p>```ocaml env=ch8 module HoneyIslands (M : MONAD_PLUS_OPS) = struct
type state = { been_size : int; been_islands : int; unvisited : cell
list; visited : CellSet.t; eaten : cell list; more_to_eat : int; }</p>
<p>let init_state unvisited more_to_eat = { been_size = 0; been_islands
= 0; unvisited; visited = CellSet.empty; eaten = []; more_to_eat; }</p>
<p>module BacktrackingM = StateT (M) (struct type t = state end) open
BacktrackingM</p>
<p>let rec visit_cell () = (* State update actions <em>) let</em> s =
get in match s.unvisited with | [] -&gt; return None | c::remaining when
CellSet.mem c s.visited -&gt; let* () = put {s with unvisited=remaining}
in visit_cell () (* Throwaway argument because of recursion <em>) |
c::remaining -&gt; let</em> () = put {s with unvisited=remaining;
visited = CellSet.add c s.visited} in return (Some c) (* This action
returns a value *)</p>
<p>let eat_cell c = let* s = get in let* () = put {s with eaten =
c::s.eaten; visited = CellSet.add c s.visited; more_to_eat =
s.more_to_eat - 1} in return () (* Remaining state update actions just
affect the state *)</p>
<p>let keep_cell c = let* s = get in let* () = put {s with visited =
CellSet.add c s.visited; been_size = s.been_size + 1} in return ()</p>
<p>let fresh_island = let* s = get in let* () = put {s with been_size =
0; been_islands = s.been_islands + 1} in return ()</p>
<p>let find_to_eat n island_size num_islands empty_cells = let honey =
honey_cells n empty_cells in let rec find_board () = let* cell =
visit_cell () in match cell with | None -&gt; let* s = get in let* () =
guard (s.been_islands = num_islands) in return s.eaten | Some cell -&gt;
let* () = fresh_island in let* () = find_island cell in let* s = get in
let* () = guard (s.been_size = island_size) in find_board ()</p>
<pre><code>and find_island current =
  let* () = keep_cell current in
  neighbors n empty_cells current
  |&gt; foldM
       (fun () neighbor -&gt;
          let* s = get in
          whenM (not (CellSet.mem neighbor s.visited))
            (let choose_eat =
               let* () = guard (s.more_to_eat &gt; 0) in
               eat_cell neighbor
             and choose_keep =
               let* () = guard (s.been_size &lt; island_size) in
               find_island neighbor in
             choose_eat ++ choose_keep)) () in

let cells_to_eat =
  List.length honey - island_size * num_islands in
init_state honey cells_to_eat
|&gt; runT (find_board ())</code></pre>
<p>end</p>
<p>module HoneyL = HoneyIslands (ListM) let find_to_eat a b c d =
ListM.run (HoneyL.find_to_eat a b c d)</p>
<pre><code>
### 8.13 Probabilistic Programming

Using a random number generator, we can define procedures that produce various outputs. This is **not functional** in the mathematical sense -- mathematical functions have deterministic results for fixed arguments.

Just as we can &quot;simulate&quot; mutable variables with the state monad and non-determinism with the list monad, we can &quot;simulate&quot; random computation with a **probability monad**. But the probability monad is more than just randomized computation -- it lets us *reason* about probabilities. We can ask questions like &quot;what is the probability of this outcome?&quot; or &quot;what is the distribution of possible results?&quot;

Different monad implementations make different tradeoffs:
- **Exact distribution**: Track all possible outcomes and their probabilities precisely
- **Sampling (Monte Carlo)**: Approximate probabilities by running many random trials

#### The Probability Monad

The essential functions for the probability monad class are `choose` (for making probabilistic choices) and `distrib` (for extracting the probability distribution). Other operations could be defined in terms of these but are provided by each instance for efficiency.

**Inside-monad operations** (building probabilistic computations):

- `choose : float -&gt; &#39;a monad -&gt; &#39;a monad -&gt; &#39;a monad`: `choose p a b` represents an event which is `a` with probability $p$ and `b` with probability $1-p$.
- `pick : (&#39;a * float) list -&gt; &#39;a monad`: Draw a result from a given probability distribution. The argument must be a valid distribution: positive probabilities summing to 1.
- `uniform : &#39;a list -&gt; &#39;a monad`: Uniform distribution -- each element equally likely.
- `flip : float -&gt; bool monad`: A biased coin: `true` with probability `p`, `false` otherwise.
- `coin : bool monad`: A fair coin: `flip 0.5`.

**Outside-monad operations** (querying probabilistic computations):

- `prob : (&#39;a -&gt; bool) -&gt; &#39;a monad -&gt; float`: Returns the probability that a predicate holds.
- `distrib : &#39;a monad -&gt; (&#39;a * float) list`: Returns the full distribution of probabilities over outcomes.
- `access : &#39;a monad -&gt; &#39;a`: Samples a random result from the distribution -- this is **non-functional** behavior (different calls may return different results).

```ocaml env=ch8
module type PROBABILITY = sig
  include MONAD_OPS
  val choose : float -&gt; &#39;a monad -&gt; &#39;a monad -&gt; &#39;a monad
  val pick : (&#39;a * float) list -&gt; &#39;a monad
  val uniform : &#39;a list -&gt; &#39;a monad
  val coin : bool monad
  val flip : float -&gt; bool monad
  val prob : (&#39;a -&gt; bool) -&gt; &#39;a monad -&gt; float
  val distrib : &#39;a monad -&gt; (&#39;a * float) list
  val access : &#39;a monad -&gt; &#39;a
end</code></pre>
<p>Helper functions:</p>
<p>```ocaml env=ch8 let total dist = List.fold_left (fun a (_,b) -&gt; a
+. b) 0. dist</p>
<p>let merge dist = map_reduce (fun x -&gt; x) (+.) 0. dist (* Merge
repeating elements *)</p>
<p>let normalize dist = (* Normalize a measure into a distribution *)
let tot = total dist in if tot = 0. then dist else List.map (fun (e,w)
-&gt; e, w /. tot) dist</p>
<p>let roulette dist = (* Roulette wheel from a distribution/measure *)
let tot = total dist in let rec aux r = function | [] -&gt; assert false
| (e, w)::_ when w &lt;= r -&gt; e | (_, w)::tl -&gt; aux (r -. w) tl in
aux (Random.float tot) dist</p>
<pre><code>
#### Exact Distribution Monad

```ocaml env=ch8
module DistribM : PROBABILITY = struct
  module M = struct       (* Exact probability distribution -- naive implementation *)
    type &#39;a t = (&#39;a * float) list
    let bind a b = merge             (* x w.p. p and then y w.p. q happens = *)
      (List.concat_map (fun (x, p) -&gt;
        List.map (fun (y, q) -&gt; (y, q *. p)) (b x)) a)  (* y results w.p. p*q *)
    let return a = [a, 1.]           (* Certainly a *)
  end
  include M
  include MonadOps (M)
  let choose p a b =
    List.append
      (List.map (fun (e,w) -&gt; e, p *. w) a)
      (List.map (fun (e,w) -&gt; e, (1. -. p) *. w) b)
  let pick dist = dist
  let uniform elems = normalize
    (List.map (fun e -&gt; e, 1.) elems)
  let coin = [true, 0.5; false, 0.5]
  let flip p = [true, p; false, 1. -. p]
  let prob p m = m
    |&gt; List.filter (fun (e,_) -&gt; p e)    (* All cases where p holds, *)
    |&gt; List.map snd |&gt; List.fold_left (+.) 0.  (* add up *)
  let distrib m = m
  let access m = roulette m
end</code></pre>
<h4 id="sampling-monad">Sampling Monad</h4>
<p><code>ocaml env=ch8 module SamplingM (S : sig val samples : int end) : PROBABILITY = struct   module M = struct                      (* Parameterized by how many samples *)     type 'a t = unit -&gt; 'a               (* used to approximate prob or distrib *)     let bind a b () = b (a ()) ()        (* Randomized computation -- each call a() *)     let return a = fun () -&gt; a           (* is an independent sample. Always a. *)   end   include M   include MonadOps (M)   let choose p a b () =     if Random.float 1. &lt;= p then a () else b ()   let pick dist = fun () -&gt; roulette dist   let uniform elems =     let n = List.length elems in     fun () -&gt; List.nth elems (Random.int n)   let coin = Random.bool   let flip p = choose p (return true) (return false)   let prob p m =     let count = ref 0 in     for i = 1 to S.samples do       if p (m ()) then incr count     done;     float_of_int !count /. float_of_int S.samples   let distrib m =     let dist = ref [] in     for i = 1 to S.samples do       dist := (m (), 1.) :: !dist done;     normalize (merge !dist)   let access m = m () end</code></p>
<h4 id="example-the-monty-hall-problem">Example: The Monty Hall
Problem</h4>
<p>The Monty Hall problem is a famous probability puzzle. In search of a
new car, the player picks a door, say 1. The game host (who knows what
is behind each door) then opens one of the other doors, say 3, to reveal
a goat and offers to let the player switch to door 2 instead of door 1.
Should the player switch?</p>
<p>Most people’s intuition says it does not matter, but let us compute
the actual probabilities:</p>
<p>```ocaml env=ch8 module MontyHall (P : PROBABILITY) = struct open P
type door = A | B | C let doors = [A; B; C]</p>
<p>let monty_win switch = let* prize = uniform doors in let* chosen =
uniform doors in let* opened = uniform (list_diff doors [prize; chosen])
in let final = if switch then List.hd (list_diff doors [opened; chosen])
else chosen in return (final = prize) end</p>
<p>module MontyExact = MontyHall (DistribM) module Sampling1000 =
SamplingM (struct let samples = 1000 end) module MontySimul = MontyHall
(Sampling1000)</p>
<p>(* DistribM.distrib (MontyExact.monty_win false);; <em>) (</em>
DistribM.distrib (MontyExact.monty_win true);; *)</p>
<pre><code>
The famous result: switching doubles your chances of winning! Counter-intuitively, the host&#39;s choice of which door to open gives you information -- by switching, you are betting that your initial choice was wrong (which it is 2/3 of the time).

#### Conditional Probabilities

So far we have computed unconditional probabilities. But what if we want to answer questions like &quot;given that X happened, what is the probability of Y?&quot; This is a conditional probability $P(Y|X)$.

Wouldn&#39;t it be nice to have a monad-plus rather than just a monad? Then we could use `guard` for conditional probabilities!

To compute $P(A|B)$:
1. Compute what is needed for both $A$ and $B$
2. Guard $B$
3. Return $A$

For the exact distribution monad, we allow intermediate distributions to be *unnormalized* (probabilities sum to less than 1) and normalize at the end. For the sampling monad, we use *rejection sampling*: generate samples and discard those that do not satisfy the condition (though `mplus` has no straightforward correct implementation in this approach).

```ocaml env=ch8
module type COND_PROBAB = sig
  include PROBABILITY
  include MONAD_PLUS_OPS with type &#39;a monad := &#39;a monad
end

module DistribMP : COND_PROBAB = struct
  module MP = struct
    type &#39;a t = (&#39;a * float) list      (* Measures no longer restricted to *)
    let bind a b = merge               (* probability distributions *)
      (List.concat_map (fun (x, p) -&gt;
        List.map (fun (y, q) -&gt; (y, q *. p)) (b x)) a)
    let return a = [a, 1.]
    let mzero = []                     (* Measure equal 0 everywhere is OK *)
    let mplus = List.append
  end
  include MP
  include MonadPlusOps (MP)
  let choose p a b =              (* It isn&#39;t a w.p. p &amp; b w.p. (1-p) since a and b *)
    List.map (fun (e,w) -&gt; e, p *. w) a @  (* are not normalized! *)
      List.map (fun (e,w) -&gt; e, (1. -. p) *. w) b
  let pick dist = dist
  let uniform elems = normalize
    (List.map (fun e -&gt; e, 1.) elems)
  let coin = [true, 0.5; false, 0.5]
  let flip p = [true, p; false, 1. -. p]
  let prob p m = normalize m           (* Final normalization step *)
    |&gt; List.filter (fun (e,_) -&gt; p e)
    |&gt; List.map snd |&gt; List.fold_left (+.) 0.
  let distrib m = normalize m
  let access m = roulette m
end

module SamplingMP (S : sig val samples : int end) : COND_PROBAB = struct
  exception Rejected              (* For rejecting current sample *)
  module MP = struct              (* Monad operations are exactly as for SamplingM *)
    type &#39;a t = unit -&gt; &#39;a
    let bind a b () = b (a ()) ()
    let return a = fun () -&gt; a
    let mzero = fun () -&gt; raise Rejected  (* but now we can fail *)
    let mplus a b = fun () -&gt;
      failwith &quot;SamplingMP.mplus not implemented&quot;
  end
  include MP
  include MonadPlusOps (MP)
  let choose p a b () =                (* Inside-monad operations don&#39;t change *)
    if Random.float 1. &lt;= p then a () else b ()
  let pick dist = fun () -&gt; roulette dist
  let uniform elems =
    let n = List.length elems in
    fun () -&gt; List.nth elems (Random.int n)
  let coin = Random.bool
  let flip p = choose p (return true) (return false)
  let prob p m =                  (* Getting out of monad: handle rejected samples *)
    let count = ref 0 and tot = ref 0 in
    while !tot &lt; S.samples do          (* Count up to the required *)
      try                              (* number of samples *)
        if p (m ()) then incr count;   (* m() can fail *)
        incr tot                       (* But if we got here it hasn&#39;t *)
      with Rejected -&gt; ()              (* Rejected, keep sampling *)
    done;
    float_of_int !count /. float_of_int S.samples
  let distrib m =
    let dist = ref [] and tot = ref 0 in
    while !tot &lt; S.samples do
      try
        dist := (m (), 1.) :: !dist;
        incr tot
      with Rejected -&gt; ()
    done;
    normalize (merge !dist)
  let rec access m =
    try m () with Rejected -&gt; access m
end</code></pre>
<h4 id="burglary-example-encoding-a-bayes-net">Burglary Example:
Encoding a Bayes Net</h4>
<p>Consider a problem with this dependency structure:</p>
<ul>
<li>An alarm can be due to either a burglary or an earthquake</li>
<li>You are on vacation and have asked neighbors John and Mary to call
if the alarm rings</li>
<li>Mary only calls when she is really sure about the alarm, but John
has better hearing</li>
<li>Earthquakes are twice as probable as burglaries</li>
<li>The alarm has about 30% chance of going off during an
earthquake</li>
<li>You can check on the radio if there was an earthquake, but you might
miss the news</li>
</ul>
<p>Probability tables:</p>
<ul>
<li><span class="math inline">P(\text{Burglary}) = 0.001</span></li>
<li><span class="math inline">P(\text{Earthquake}) = 0.002</span></li>
<li><span class="math inline">P(\text{Alarm}|\text{B}, \text{E})</span>
varies (0.001 for FF, 0.29 for FT, 0.94 for TF, 0.95 for TT)</li>
<li><span class="math inline">P(\text{John calls}|\text{Alarm})</span>
is 0.9 if alarm, 0.05 otherwise</li>
<li><span class="math inline">P(\text{Mary calls}|\text{Alarm})</span>
is 0.7 if alarm, 0.01 otherwise</li>
</ul>
<p>```ocaml env=ch8 module Burglary (P : COND_PROBAB) = struct open P
type what_happened = | Safe | Burgl | Earthq | Burgl_n_earthq</p>
<p>let check ~john_called ~mary_called ~radio = let* earthquake = flip
0.002 in let* () = guard (radio = None || radio = Some earthquake) in
let* burglary = flip 0.001 in let alarm_p = match burglary, earthquake
with | false, false -&gt; 0.001 | false, true -&gt; 0.29 | true, false
-&gt; 0.94 | true, true -&gt; 0.95 in let* alarm = flip alarm_p in let
john_p = if alarm then 0.9 else 0.05 in let* john_calls = flip john_p in
let* () = guard (john_calls = john_called) in let mary_p = if alarm then
0.7 else 0.01 in let* mary_calls = flip mary_p in let* () = guard
(mary_calls = mary_called) in match burglary, earthquake with | false,
false -&gt; return Safe | true, false -&gt; return Burgl | false, true
-&gt; return Earthq | true, true -&gt; return Burgl_n_earthq end</p>
<p>module BurglaryExact = Burglary (DistribMP) module Sampling2000 =
SamplingMP (struct let samples = 2000 end) module BurglarySimul =
Burglary (Sampling2000)</p>
<pre><code>
### 8.14 Lightweight Cooperative Threads

Running multiple tasks asynchronously can hide I/O latency and utilize multi-core architectures. Traditional operating system threads are &quot;heavyweight&quot; -- they have significant overhead for context switching and memory. **Lightweight threads** are managed by the application rather than the OS, allowing many concurrent tasks with lower overhead.

Lightweight threads can be:
- **Preemptive**: The scheduler interrupts running threads to switch between them
- **Cooperative**: Threads voluntarily give up control at specific points (like I/O operations)

**Lwt** is a popular OCaml library for lightweight cooperative threads, implemented as a monad. The monadic structure ensures that thread switching happens at well-defined points (whenever you use `let*`), making the code easier to reason about.

The `bind` operation is inherently sequential: `bind a (fun x -&gt; b)` computes `a`, and only resumes computing `b` once the result `x` is known.

For concurrency, we need to &quot;suppress&quot; this sequentiality. We introduce a parallel bind:
</code></pre>
<p>parallel : ’a monad -&gt; ’b monad -&gt; (’a -&gt; ’b -&gt; ’c monad)
-&gt; ’c monad</p>
<pre><code>
With `parallel a b (fun x y -&gt; c)`, computations `a` and `b` can proceed concurrently. The continuation `c` runs once both results are available.

If the monad starts computing right away (as in the Lwt library), `parallel ea eb c` is equivalent to:
</code></pre>
<p>let a = ea in let b = eb in let* x = a in let* y = b in c x y</p>
<pre><code>
#### Fine-Grained vs. Coarse-Grained Concurrency

There are two approaches to when threads switch:

**Fine-grained** concurrency suspends at every `bind`. The scheduler runs other threads and comes back to complete the `bind` before running threads created since the suspension. This gives maximum interleaving but has higher overhead.

**Coarse-grained** concurrency only suspends when explicitly requested via a `suspend` (often called `yield`) operation. Library operations that need to wait for I/O should call `suspend` internally. This is more efficient but requires careful placement of suspension points.

#### Thread Monad Signatures

The thread monad extends the basic monad with parallel composition:

```ocaml env=ch8
module type THREADS = sig
  include MONAD
  val parallel :
    &#39;a t -&gt; &#39;b t -&gt; (&#39;a -&gt; &#39;b -&gt; &#39;c t) -&gt; &#39;c t
end

module type THREAD_OPS = sig
  include MONAD_OPS
  include THREADS with type &#39;a t := &#39;a monad
  val parallel_map :
    &#39;a list -&gt; (&#39;a -&gt; &#39;b monad) -&gt; &#39;b list monad
  val (&gt;||=) :
    &#39;a monad -&gt; &#39;b monad -&gt; (&#39;a -&gt; &#39;b -&gt; &#39;c monad) -&gt; &#39;c monad
  val (&gt;||) :
    &#39;a monad -&gt; &#39;b monad -&gt; (unit -&gt; &#39;c monad) -&gt; &#39;c monad
end

module type THREADSYS = sig
  include THREADS
  val access : &#39;a t -&gt; &#39;a
  val kill_threads : unit -&gt; unit
end

module ThreadOps (M : THREADS) = struct
  open M
  include MonadOps (M)
  let parallel_map l f =
    List.fold_right (fun a bs -&gt;
      parallel (f a) bs
        (fun a bs -&gt; return (a::bs))) l (return [])
  let (&gt;||=) = parallel
  let (&gt;||) a b c = parallel a b (fun _ _ -&gt; c ())
end

module Threads (M : THREADSYS) : sig
  include THREAD_OPS
  val access : &#39;a monad -&gt; &#39;a
  val kill_threads : unit -&gt; unit
end = struct
  include M
  include ThreadOps(M)
end</code></pre>
<h4 id="cooperative-thread-implementation">Cooperative Thread
Implementation</h4>
<p>The implementation uses a mutable state to track thread progress.
Each thread is in one of three states: completed (<code>Return</code>),
waiting (<code>Sleep</code> with a list of callbacks to invoke when
done), or forwarded to another thread (<code>Link</code>):</p>
<p>```ocaml env=ch8 module Cooperative = Threads(struct type ’a state =
| Return of ’a (* The thread has returned <em>) | Sleep of (’a -&gt;
unit) list (</em> When thread returns, wake up waiters <em>) | Link of
’a t (</em> A link to the actual thread <em>) and ’a t = {mutable state
: ’a state} (</em> State of the thread can change <em>) (</em> – it can
return, or more waiters added <em>) let rec find t = (</em> Union-find
style link chasing *) match t.state with | Link t -&gt; find t | _ -&gt;
t</p>
<p>let jobs = Queue.create () (* Work queue – will store unit -&gt; unit
procedures *)</p>
<p>let wakeup m a = (* Thread m has actually finished – <em>) let m =
find m in (</em> updating its state <em>) match m.state with | Return _
-&gt; assert false | Sleep waiters -&gt; m.state &lt;- Return a; (</em>
Set the state, and only then <em>) List.iter ((|&gt;) a) waiters (</em>
wake up the waiters *) | Link _ -&gt; assert false</p>
<p>let return a = {state = Return a}</p>
<p>let connect t t’ = (* t was a placeholder for t’ <em>) let t’ = find
t’ in match t’.state with | Sleep waiters’ -&gt; let t = find t in
(match t.state with | Sleep waiters -&gt; (</em> If both sleep, collect
their waiters <em>) t.state &lt;- Sleep (waiters’ @ waiters); t’.state
&lt;- Link t (</em> and link one to the other <em>) | _ -&gt; assert
false) | Return x -&gt; wakeup t x (</em> If t’ returned, wake up the
placeholder *) | Link _ -&gt; assert false</p>
<p>let rec bind a b = let a = find a in let m = {state = Sleep []} in (*
The resulting monad <em>) (match a.state with | Return x -&gt; (</em> If
a returned, we suspend further work <em>) let job () = connect m (b x)
in (</em> (In exercise 11, this should <em>) Queue.push job jobs (</em>
only happen after suspend) <em>) | Sleep waiters -&gt; (</em> If a
sleeps, we wait for it to return *) let job x = connect m (b x) in
a.state &lt;- Sleep (job::waiters) | Link _ -&gt; assert false); m</p>
<p>let parallel a b c = (* Since in our implementation <em>) bind a (fun
x -&gt; (</em> the threads run as soon as they are created, <em>) bind b
(fun y -&gt; (</em> parallel is redundant *) c x y))</p>
<p>let rec access m = (* Accessing not only gets the result of m, <em>)
let m = find m in (</em> but spins the thread loop till m terminates
<em>) match m.state with | Return x -&gt; x (</em> No further work <em>)
| Sleep _ -&gt; (try Queue.pop jobs () (</em> Perform suspended work *)
with Queue.Empty -&gt; failwith “access: result not available”); access
m | Link _ -&gt; assert false</p>
<p>let kill_threads () = Queue.clear jobs (* Remove pending work *)
end)</p>
<pre><code>
#### Testing the Thread Implementation

Let us test the implementation with two threads that each print a sequence of numbers:

```ocaml env=ch8
module TTest (T : THREAD_OPS) = struct
  open T
  let rec loop s n =
    let* () = return (Printf.printf &quot;-- %s(%d)\n%!&quot; s n) in
    if n &gt; 0 then loop s (n-1)     (* We cannot use whenM because the thread *)
    else return ()                 (* would be created regardless of condition *)
end

module TT = TTest (Cooperative)

let test =
  Cooperative.kill_threads ();     (* Clean-up after previous tests *)
  let thread1 = TT.loop &quot;A&quot; 5 in
  let thread2 = TT.loop &quot;B&quot; 4 in
  Cooperative.access thread1;      (* We ensure threads finish computing *)
  Cooperative.access thread2       (* before we proceed *)</code></pre>
<p>The output shows that the threads interleave their execution
beautifully: A(5), B(4), A(4), B(3), and so on. Each <code>bind</code>
(the <code>let*</code>) causes a context switch to the other thread.
This is fine-grained concurrency in action.</p>
<p>The key insight is that monadic structure gives us precise control
over concurrency. Every <code>let*</code> is a potential suspension
point, making the code’s behavior predictable and debuggable – a
significant advantage over preemptive threading where context switches
can happen anywhere.</p>
<h3 id="exercises-5">8.15 Exercises</h3>
<p><strong>Exercise 1.</strong> (Puzzle via Oleg Kiselyov)</p>
<p>“U2” has a concert that starts in 17 minutes and they must all cross
a bridge to get there. All four men begin on the same side of the
bridge. It is night. There is one flashlight. A maximum of two people
can cross at one time. Any party who crosses, either 1 or 2 people, must
have the flashlight with them. The flashlight must be walked back and
forth, it cannot be thrown, etc. Each band member walks at a different
speed. A pair must walk together at the rate of the slower man’s
pace:</p>
<ul>
<li>Bono: 1 minute to cross</li>
<li>Edge: 2 minutes to cross</li>
<li>Adam: 5 minutes to cross</li>
<li>Larry: 10 minutes to cross</li>
</ul>
<p>For example: if Bono and Larry walk across first, 10 minutes have
elapsed when they get to the other side of the bridge. If Larry then
returns with the flashlight, a total of 20 minutes have passed and you
have failed the mission.</p>
<p>Find all answers to the puzzle using <code>let*</code> notation. The
expression will be a bit long but recursion is not needed.</p>
<p><strong>Exercise 2.</strong> Assume <code>concat_map</code> as
defined in lecture 6 and the binding operators defined above. What will
the following expressions return? Why?</p>
<ol type="1">
<li><code>let* _ = return 5 in return 7</code></li>
<li><code>let guard p = if p then [()] else [] in let* () = guard false in return 7</code></li>
<li><code>let* _ = return 5 in let* () = guard false in return 7</code></li>
</ol>
<p><strong>Exercise 3.</strong> Define <code>bind</code> in terms of
<code>lift</code> and <code>join</code>.</p>
<p><strong>Exercise 4.</strong> Define a monad-plus implementation based
on binary trees, with constant-time <code>mzero</code> and
<code>mplus</code>. Starter code:</p>
<p>```ocaml skip type ’a tree = Empty | Leaf of ’a | T of ’a tree * ’a
tree</p>
<p>module TreeM = MonadPlus (struct type ’a t = ’a tree let bind a b =
(* TODO <em>) let return a = (</em> TODO <em>) let mzero = (</em> TODO
<em>) let mplus a b = (</em> TODO *) end)</p>
<pre><code>
**Exercise 5.** Show the monad-plus laws for one of:
1. `TreeM` from your solution of exercise 4
2. `ListM` from lecture

**Exercise 6.** Why is the following monad-plus not lazy enough?

```ocaml skip
let rec badappend l1 l2 =
  match l1 with lazy LazNil -&gt; l2
  | lazy (LazCons (hd, tl)) -&gt;
      lazy (LazCons (hd, badappend tl l2))

let rec badconcatmap f = function
  | lazy LazNil -&gt; lazy LazNil
  | lazy (LazCons (a, l)) -&gt;
      badappend (f a) (badconcatmap f l)

module BadyListM = MonadPlus (struct
  type &#39;a t = &#39;a lazylist
  let bind a b = badconcatmap b a
  let return a = lazy (LazCons (a, lazy LazNil))
  let mzero = lazy LazNil
  let mplus = badappend
end)</code></pre>
<p><strong>Exercise 7.</strong> Convert a “rectangular” list of lists of
strings, representing a matrix with inner lists being rows, into a
string, where elements are column-aligned. (Exercise not related to
monads.)</p>
<p><strong>Exercise 8.</strong> Recall the enriched monad signature with
<code>('s, 'a) t</code> type. Design the signatures for the exception
monad operations to provide more flexibility than our exception monad.
Does the implementation need to change?</p>
<p><strong>Exercise 9.</strong> Implement the following constructs for
<em>all</em> monads:</p>
<ol type="1">
<li><code>for...to...</code></li>
<li><code>for...downto...</code></li>
<li><code>while...do...</code></li>
<li><code>do...while...</code></li>
<li><code>repeat...until...</code></li>
</ol>
<p>Explain how, when your implementation is instantiated with the StateM
monad, we get the solution to exercise 2 from lecture 4.</p>
<p><strong>Exercise 10.</strong> A canonical example of a probabilistic
model is that of a lawn whose grass may be wet because it rained,
because the sprinkler was on, or for some other reason. The probability
tables are:</p>
<p><span class="math display">
\begin{aligned}
P(\text{cloudy}) &amp;= 0.5 \\
P(\text{rain}|\text{cloudy}) &amp;= 0.8 \\
P(\text{rain}|\neg\text{cloudy}) &amp;= 0.2 \\
P(\text{sprinkler}|\text{cloudy}) &amp;= 0.1 \\
P(\text{sprinkler}|\neg\text{cloudy}) &amp;= 0.5 \\
P(\text{wet\_roof}|\neg\text{rain}) &amp;= 0 \\
P(\text{wet\_roof}|\text{rain}) &amp;= 0.7 \\
P(\text{wet\_grass}|\text{rain} \land \neg\text{sprinkler}) &amp;= 0.9
\\
P(\text{wet\_grass}|\text{sprinkler} \land \neg\text{rain}) &amp;= 0.9
\end{aligned}
</span></p>
<p>We observe whether the grass is wet and whether the roof is wet. What
is the probability that it rained?</p>
<p><strong>Exercise 11.</strong> Implement the coarse-grained
concurrency model:</p>
<ul>
<li>Modify <code>bind</code> to compute the resulting monad straight
away if the input monad has returned.</li>
<li>Introduce <code>suspend</code> to do what in the fine-grained model
was the effect of <code>bind (return a) b</code>, i.e., suspend the work
although it could already be started.</li>
<li>One possibility is to introduce <code>suspend</code> of type
<code>unit monad</code>, introduce a “dummy” monadic value
<code>Suspend</code> (besides <code>Return</code> and
<code>Sleep</code>), and define <code>bind suspend b</code> to do what
<code>bind (return ()) b</code> would formerly do.</li>
</ul>
<h2 id="chapter-9-algebraic-effects">Chapter 9: Algebraic Effects</h2>
<p><strong>In this chapter, you will:</strong></p>
<ul>
<li>Learn about algebraic effects and handlers as a powerful alternative
to monads</li>
<li>Implement lightweight cooperative threads using effects (comparing
with the monad-based version)</li>
<li>Model probabilistic programming with effect handlers</li>
<li>Build interpreters for probabilistic programs: rejection sampling
and particle filtering</li>
<li>Understand the replay-with-fast-forward pattern for efficient
inference</li>
</ul>
<p>OCaml 5 introduced a game-changing feature: algebraic effects with
effect handlers. While monads provide a disciplined way to structure
effectful computations, they require threading computations explicitly
through bind operations. Algebraic effects offer a different approach:
effects can be performed directly, and handlers define how those effects
are interpreted.</p>
<p>This chapter explores algebraic effects through two substantial
examples. First, we will reimplement the cooperative lightweight threads
from the previous chapter, showing how effects simplify the code. Then
we will tackle probabilistic programming, building interpreters that can
answer questions about probability distributions.</p>
<h3 id="from-monads-to-effects">9.1 From Monads to Effects</h3>
<p>In the previous chapter, we saw how monads structure effectful
computations. Every monadic operation had to be sequenced with
<code>let*</code>:</p>
<p><code>ocaml skip let rec loop s n =   let* () = return (Printf.printf "-- %s(%d)\n%!" s n) in   let* () = yield in  (* yielding could be implicit in the monad's bind *)   if n &gt; 0 then loop s (n-1)   else return ()</code></p>
<p>This works, but it is infectious: once you are inside a monad,
everything must be monadic. You cannot simply call a regular function
that might perform effects – you must lift it into the monad. Even a
simple <code>Printf.printf</code> must be wrapped in
<code>return</code>.</p>
<p>Algebraic effects take a different approach. Effects are
<em>performed</em> as regular function calls, and <em>handled</em> at a
distance:</p>
<p><code>ocaml skip let rec loop s n =   Printf.printf "-- %s(%d)\n%!" s n;   yield ();  (* explicit effect, but looks like a normal call *)   if n &gt; 0 then loop s (n-1)</code></p>
<p>The key difference is not that effects happen implicitly – you still
call <code>yield ()</code> explicitly at suspension points. The
difference is that:</p>
<ol type="1">
<li><strong>Direct style</strong>: Effects look like ordinary function
calls, not monadic binds</li>
<li><strong>Non-infectious</strong>: Code that does not perform effects
(like <code>Printf.printf</code>) remains unchanged</li>
<li><strong>Separation of concerns</strong>: The program says
<em>what</em> effects occur; the handler decides <em>how</em> to
interpret them</li>
</ol>
<h4 id="a-first-example">A First Example</h4>
<p>Before diving into the full API, let us see the simplest possible
effect: one that asks for an integer value.</p>
<p>```ocaml env=ch9 type _ Effect.t += Ask : int Effect.t</p>
<p>let ask () = Effect.perform Ask</p>
<p>let program () = let x = ask () in x + 1</p>
<p>let answer_42 () = try program () with | effect Ask, k -&gt;
Effect.Deep.continue k 42</p>
<p>let () = assert (answer_42 () = 43)</p>
<pre><code>
The `try ... with | effect Ask, k -&gt; ...` syntax handles effects similarly to how `try ... with` handles exceptions. When the `Ask` effect is performed, the pattern `effect Ask, k` matches. The variable `k` is the *continuation*: it represents &quot;the rest of the computation&quot; from the point where the effect was performed. By calling `Effect.Deep.continue k 42`, we resume the computation with `42` as the result of `ask ()`.

#### Declaring Effects

Effects are declared by extending the built-in extensible GADT `Effect.t`. The type parameter indicates what the effect returns:

```ocaml env=ch9
type _ Effect.t += Yield : unit Effect.t</code></pre>
<p>This declares a <code>Yield</code> effect that returns
<code>unit</code>. The <code>type _ Effect.t +=</code> syntax is similar
to how exceptions extend the <code>exn</code> type.</p>
<p>Effects can carry data and return values:</p>
<p><code>ocaml env=ch9 type _ Effect.t += Get : int Effect.t type _ Effect.t += Put : int -&gt; unit Effect.t</code></p>
<p>Here <code>Get</code> is an effect that returns an <code>int</code>,
and <code>Put</code> takes an <code>int</code> argument and returns
<code>unit</code>.</p>
<h4 id="performing-effects">Performing Effects</h4>
<p>To perform an effect, we use <code>Effect.perform</code>:</p>
<p><code>ocaml env=ch9 let yield () = Effect.perform Yield let get () = Effect.perform Get let put n = Effect.perform (Put n)</code></p>
<p>When <code>Effect.perform</code> is called, control transfers to the
nearest enclosing handler for that effect. If no handler exists, OCaml
raises <code>Effect.Unhandled</code>.</p>
<p><strong>Note:</strong> The effect system API is marked as unstable in
OCaml 5.x and may change in future versions. Effects can only be
performed synchronously – not from signal handlers, finalisers, or C
callbacks.</p>
<h4 id="handling-effects">Handling Effects</h4>
<p>OCaml 5.3+ provides a convenient syntax for handling effects. The
simplest form uses <code>try ... with</code> when you just want to
return the result unchanged. When you need to transform the result, and
especially if you want to pattern match on it,
<code>match ... with</code> is more elegant.</p>
<p><code>ocaml env=ch9 let () =   let state = ref 0 in   let result =     try put 10; get () + get () with     | effect Get, k -&gt; Effect.Deep.continue k !state     | effect (Put n), k -&gt; state := n; Effect.Deep.continue k ()   in   assert (result = 20)</code></p>
<p>The <code>effect E, k</code> pattern matches when effect
<code>E</code> is performed. The continuation <code>k</code> captures
everything that would happen after <code>Effect.perform</code> returns.
We can: - <strong>Continue</strong> by calling
<code>Effect.Deep.continue k value</code>, where <code>value</code>
becomes the return value of <code>perform</code> -
<strong>Discontinue</strong> by calling
<code>Effect.Deep.discontinue k exn</code>, raising an exception at the
effect site - <strong>Store</strong> the continuation and resume it
later (useful for schedulers)</p>
<p><strong>Important:</strong> OCaml continuations are <em>one-shot</em>
– each continuation must be resumed exactly once with
<code>continue</code> or <code>discontinue</code>. Attempting to resume
a continuation twice raises
<code>Effect.Continuation_already_resumed</code>. Not resuming a
continuation might work in specific cases but risks leaking resources
(e.g. open files).</p>
<p>The three kinds of patterns in a handler correspond to three cases: -
Regular patterns handle normal return values - <code>exception</code>
patterns handle raised exceptions - <code>effect</code> patterns handle
performed effects</p>
<p>This mirrors the explicit handler record form
<code>{ retc; exnc; effc }</code> used by
<code>Effect.Deep.match_with</code>.</p>
<h4 id="deep-vs-shallow-handlers">Deep vs Shallow Handlers</h4>
<p>OCaml provides two kinds of handlers in <code>Effect.Deep</code> and
<code>Effect.Shallow</code>:</p>
<ul>
<li><p><strong>Deep handlers</strong> (which we use throughout this
chapter) automatically re-install themselves when you continue a
computation. Effects performed after resumption are handled by the same
handler.</p></li>
<li><p><strong>Shallow handlers</strong> handle only the first effect
encountered. After continuing, subsequent effects are not automatically
handled. This gives more control but requires more explicit
management.</p></li>
</ul>
<p>For most use cases, deep handlers are simpler and sufficient. We will
use <code>Effect.Deep</code> exclusively in this chapter.</p>
<p>This ability to capture and manipulate continuations is what makes
algebraic effects so powerful. Let us see this in action.</p>
<h3 id="lightweight-threads-with-effects">9.2 Lightweight Threads with
Effects</h3>
<p>In the previous chapter, we implemented cooperative threads using a
monad. The implementation involved mutable state to track thread status,
a work queue, and careful management of continuations encoded as
closures. With effects, we can write a much simpler implementation.</p>
<h4 id="the-thread-interface">The Thread Interface</h4>
<p>Our goal is to support concurrent computations that can yield control
to other threads and eventually produce results. Here is a simple
interface:</p>
<p><code>ocaml env=ch9 module type THREADS = sig   type 'a promise   val async : (unit -&gt; 'a) -&gt; 'a promise  (* Start a new thread *)   val await : 'a promise -&gt; 'a            (* Wait for a thread to complete *)   val yield : unit -&gt; unit                (* Yield control to other threads *)   val run : (unit -&gt; 'a) -&gt; 'a            (* Run the scheduler *) end</code></p>
<p>A <em>promise</em> represents a computation that will eventually
produce a value. We can start new threads with <code>async</code>, wait
for their results with <code>await</code>, and voluntarily give up
control with <code>yield</code>.</p>
<h4 id="declaring-the-effects">Declaring the Effects</h4>
<p>We need three effects:</p>
<p>```ocaml env=ch9 type ’a promise_state = | Pending of (’a, unit)
Effect.Deep.continuation list (* Waiting continuations <em>) | Done of
’a (</em> Completed with value *)</p>
<p>type ’a promise = ’a promise_state ref</p>
<p>type _ Effect.t += | Async : (unit -&gt; ’a) -&gt; ’a promise
Effect.t (* Fork a new thread <em>) | Await : ’a promise -&gt; ’a
Effect.t (</em> Wait for completion <em>) | TYield : unit Effect.t
(</em> Give up control *)</p>
<pre><code>
The `Async` effect carries a thunk and returns a promise. The `Await` effect takes a promise and returns its value (potentially blocking). The `TYield` effect temporarily suspends the current thread.

A promise is a mutable reference that starts as `Pending` (with a list of continuations waiting for the result) and becomes `Done` once the computation completes.

#### The Scheduler

The scheduler maintains a queue of ready threads (continuations waiting to run):

```ocaml env=ch9
module Threads : THREADS = struct
  type &#39;a promise_state =
    | Pending of (&#39;a, unit) Effect.Deep.continuation list
    | Done of &#39;a
  type &#39;a promise = &#39;a promise_state ref

  type _ Effect.t +=
    | Async : (unit -&gt; &#39;a) -&gt; &#39;a promise Effect.t
    | Await : &#39;a promise -&gt; &#39;a Effect.t
    | TYield : unit Effect.t

  let async f = Effect.perform (Async f)
  let await p = Effect.perform (Await p)
  let yield () = Effect.perform TYield

  let run_queue : (unit -&gt; unit) Queue.t = Queue.create ()
  let enqueue f = Queue.push f run_queue
  let dequeue () = if Queue.is_empty run_queue then () else Queue.pop run_queue ()

  let fulfill p v =
    match !p with
    | Done _ -&gt; failwith &quot;Promise already fulfilled&quot;
    | Pending waiters -&gt;
        p := Done v;
        List.iter (fun k -&gt; enqueue (fun () -&gt; Effect.Deep.continue k v)) waiters

  let rec run_thread : &#39;a. (unit -&gt; &#39;a) -&gt; &#39;a promise = fun f -&gt;
    let p = ref (Pending []) in
    let () = match f () with
      | v -&gt; fulfill p v; dequeue ()
      | effect (Async g), k -&gt;
          let p&#39; = run_thread g in
          Effect.Deep.continue k p&#39;
      | effect (Await p&#39;), k -&gt;
          (match !p&#39; with
           | Done v -&gt; Effect.Deep.continue k v
           | Pending ks -&gt; p&#39; := Pending (k :: ks); dequeue ())
      | effect TYield, k -&gt;
          enqueue (fun () -&gt; Effect.Deep.continue k ());
          dequeue ()
    in p

  let run f =
    Queue.clear run_queue;
    let p = run_thread f in
    while not (Queue.is_empty run_queue) do dequeue () done;
    match !p with
    | Done v -&gt; v
    | Pending _ -&gt; failwith &quot;Main thread did not complete&quot;
end</code></pre>
<p>Let us understand how each effect is handled:</p>
<p><strong>Async</strong>: When a thread calls <code>async g</code>, we
start a new thread running <code>g</code> by calling
<code>run_thread g</code>. This returns a promise immediately, which we
pass back to the parent thread by continuing its continuation.</p>
<p><strong>Await</strong>: When a thread calls <code>await p</code>, we
check the promise. If it is already <code>Done</code>, we continue
immediately with the value. If it is <code>Pending</code>, we add the
current continuation to the list of waiters and run another thread from
the queue.</p>
<p><strong>TYield</strong>: When a thread calls <code>yield ()</code>,
we add the current continuation to the back of the queue and run the
next thread. This implements round-robin scheduling.</p>
<h4 id="testing-the-implementation">Testing the Implementation</h4>
<p>Let us test with a simple example:</p>
<p>```ocaml env=ch9 let test_threads () = let open Threads in run (fun
() -&gt; let rec loop s n = Printf.printf “– %s(%d)%!” s n; yield (); if
n &gt; 0 then loop s (n-1) in let p1 = async (fun () -&gt; loop “A” 3)
in let p2 = async (fun () -&gt; loop “B” 2) in await p1; await p2;
Printf.printf “Done!%!”)</p>
<p>let () = test_threads ()</p>
<pre><code>
This creates two threads that print messages and yield control. The output shows interleaving:
</code></pre>
<p>– A(3) – B(2) – A(2) – B(1) – A(1) – B(0) – A(0) Done!</p>
<pre><code>
Compare this to the monadic version from the previous chapter. The code is more direct: we write `yield ()` instead of `let* () = suspend in`, and `Printf.printf` is just a regular function call. The complexity of managing thread state has moved from the user code into the handler.

### 9.3 State with Effects

Before diving into probabilistic programming, let us see how to implement mutable state using effects. This demonstrates another common pattern.

```ocaml env=ch9
module State = struct
  type _ Effect.t +=
    | SGet : int Effect.t
    | SPut : int -&gt; unit Effect.t

  let get () = Effect.perform SGet
  let put n = Effect.perform (SPut n)

  let run : type a. int -&gt; (unit -&gt; a) -&gt; a = fun init f -&gt;
    let state = ref init in
    try f () with
    | effect SGet, k -&gt; Effect.Deep.continue k !state
    | effect (SPut n), k -&gt; state := n; Effect.Deep.continue k ()
end</code></pre>
<p>Now we can write stateful computations:</p>
<p>```ocaml env=ch9 let counter () = let open State in for _ = 1 to 5 do
put (get () + 1) done; get ()</p>
<p>let result = State.run 0 counter (* result = 5 *) let () =
Printf.printf “Counter result: %d” result</p>
<pre><code>
The key insight is that effects let us *separate the description of what effects occur* from *how those effects are implemented*. The `counter` function describes a computation that gets and puts state. The `State.run` handler interprets those effects using a mutable reference.

### 9.4 Probabilistic Programming with Effects

Now we are ready to tackle something more ambitious: probabilistic programming. In the previous chapter, we implemented probability monads that could compute exact distributions or approximate them via sampling. Effect handlers give us a different, more flexible approach.

#### The Key Idea

A probabilistic program is a program with random choices. Instead of thinking about distributions as data, we think about *sampling* and *conditioning*:

- **Sample**: Draw a value from a probability distribution
- **Observe/Condition**: Assert that a certain event occurred, affecting the posterior probability

Effect handlers let us *reify* these operations. When a program performs a `Sample` effect, the handler can decide: &quot;run this with value X and probability P&quot;. When a program performs an `Observe` effect, the handler can adjust weights or reject samples that do not match the observation.

#### Declaring Probability Effects

```ocaml env=ch9
type _ Effect.t +=
  | Sample : (string * float array) -&gt; int Effect.t  (* name, weights -&gt; index *)
  | Observe : float -&gt; unit Effect.t                 (* observe with likelihood *)
  | Fail : &#39;a Effect.t                               (* reject this execution *)</code></pre>
<p><code>Sample</code> takes a name (for debugging) and an array of
weights, returning the index of the chosen alternative.
<code>Observe</code> records a likelihood weight. <code>Fail</code>
indicates this execution path should be abandoned.</p>
<p><code>ocaml env=ch9 let sample name weights = Effect.perform (Sample (name, weights)) let observe likelihood = Effect.perform (Observe likelihood) let fail () = Effect.perform Fail</code></p>
<p>We can build familiar probabilistic primitives:</p>
<p>```ocaml env=ch9 let flip p = let i = sample “flip” [| p; 1.0 -. p |]
in i = 0</p>
<p>let uniform choices = let n = Array.length choices in let weights =
Array.make n (1.0 /. float_of_int n) in let i = sample “uniform” weights
in choices.(i)</p>
<p>let bernoulli p = flip p</p>
<p>let categorical weights = let total = Array.fold_left (+.) 0.0
weights in let normalized = Array.map (fun w -&gt; w /. total) weights
in sample “categorical” normalized</p>
<pre><code>
#### Example: Monty Hall

Let us encode the Monty Hall problem:

```ocaml env=ch9
type door = A | B | C

let monty_hall ~switch =
  let doors = [| A; B; C |] in
  let prize = uniform doors in
  let chosen = uniform doors in
  (* Host opens a door that is neither prize nor chosen *)
  let can_open =
    doors
    |&gt; Array.to_list
    |&gt; List.filter (fun d -&gt; d &lt;&gt; prize &amp;&amp; d &lt;&gt; chosen)
    |&gt; Array.of_list
  in
  let opened = uniform can_open in
  (* Player&#39;s final choice *)
  let final =
    if switch then
      (* Switch to the remaining door *)
      List.hd (List.filter (fun d -&gt; d &lt;&gt; opened &amp;&amp; d &lt;&gt; chosen) [A; B; C])
    else chosen in
  final = prize</code></pre>
<p>This is cleaner than the monadic version: we just write the
generative model directly. The <code>uniform</code> calls represent
random choices, and we return whether the player wins.</p>
<h4 id="example-burglary-network">Example: Burglary Network</h4>
<p>Here is the Bayesian network example from the previous chapter:</p>
<p>```ocaml env=ch9 type outcome = Safe | Burglary | Earthquake |
Both</p>
<p>let burglary ~john_called ~mary_called = let earthquake = flip 0.002
in let burglary = flip 0.001 in let alarm_prob = match burglary,
earthquake with | false, false -&gt; 0.001 | false, true -&gt; 0.29 |
true, false -&gt; 0.94 | true, true -&gt; 0.95 in let alarm = flip
alarm_prob in let john_prob = if alarm then 0.9 else 0.05 in let
mary_prob = if alarm then 0.7 else 0.01 in (* Condition on observations
<em>) if flip john_prob &lt;&gt; john_called then fail (); if flip
mary_prob &lt;&gt; mary_called then fail (); (</em> Return the outcome
*) match burglary, earthquake with | false, false -&gt; Safe | true,
false -&gt; Burglary | false, true -&gt; Earthquake | true, true -&gt;
Both</p>
<pre><code>
The key difference from the monad version: we use `fail ()` to reject executions that do not match our observations. This is *rejection sampling*: we run the program many times and keep only the runs where the observations match.

### 9.5 Rejection Sampling Interpreter

Our first interpreter uses rejection sampling: run the probabilistic program many times, rejecting executions that fail, and collect statistics on the successful runs.

```ocaml env=ch9
module Rejection = struct
  exception Rejected

  let sample_index weights =
    let total = Array.fold_left (+.) 0.0 weights in
    let r = Random.float total in
    let rec find i acc =
      if i &gt;= Array.length weights then Array.length weights - 1
      else
        let acc&#39; = acc +. weights.(i) in
        if r &lt; acc&#39; then i else find (i + 1) acc&#39;
    in
    find 0 0.0

  let run_once : type a. (unit -&gt; a) -&gt; a option = fun f -&gt;
    match f () with
    | result -&gt; Some result
    | effect (Sample (_, weights)), k -&gt;
        Effect.Deep.continue k (sample_index weights)
    | effect (Observe w), k -&gt;
        if Random.float 1.0 &lt; w
        then Effect.Deep.continue k ()
        else Effect.Deep.discontinue k Rejected
    | effect Fail, k -&gt; Effect.Deep.discontinue k Rejected
    | exception Rejected -&gt; None

  let infer ?(samples=10000) f =
    let results = Hashtbl.create 16 in
    let successes = ref 0 in
    for _ = 1 to samples do
      match run_once f with
      | None -&gt; ()
      | Some v -&gt;
          incr successes;
          let count = try Hashtbl.find results v with Not_found -&gt; 0 in
          Hashtbl.replace results v (count + 1)
    done;
    let n = float_of_int !successes in
    if n &gt; 0.0 then
      Hashtbl.fold (fun v c acc -&gt;
        (v, float_of_int c /. n) :: acc) results []
      |&gt; List.sort (fun (_, p1) (_, p2) -&gt; compare p2 p1)
    else []
end</code></pre>
<p>Let us test it:</p>
<p>```ocaml env=ch9 let () = Printf.printf “=== Rejection Sampling Tests
===”; Printf.printf “Monty Hall (no switch):”; let dist =
Rejection.infer (fun () -&gt; monty_hall ~switch:false) in List.iter
(fun (win, p) -&gt; Printf.printf “%s: %.3f” (if win then “win” else
“lose”) p) dist; print_newline ()</p>
<p>let () = Printf.printf “Monty Hall (switch):”; let dist =
Rejection.infer (fun () -&gt; monty_hall ~switch:true) in List.iter (fun
(win, p) -&gt; Printf.printf “%s: %.3f” (if win then “win” else “lose”)
p) dist; print_newline ()</p>
<pre><code>
The famous result: switching doubles your chances of winning!

#### Limitations of Rejection Sampling

Rejection sampling is simple but has a major limitation: if the observations are unlikely, most samples are rejected, making inference very slow. For example, if we observe both John and Mary called (a rare event), rejection sampling needs many attempts to find a valid sample:

```ocaml env=ch9
let () =
  Printf.printf &quot;Burglary (john=true, mary=true):\n&quot;;
  let dist = Rejection.infer ~samples:100000 (fun () -&gt;
    burglary ~john_called:true ~mary_called:true) in
  List.iter (fun (outcome, p) -&gt;
    let s = match outcome with
      | Safe -&gt; &quot;Safe&quot; | Burglary -&gt; &quot;Burglary&quot;
      | Earthquake -&gt; &quot;Earthquake&quot; | Both -&gt; &quot;Both&quot; in
    Printf.printf &quot;  %s: %.4f\n&quot; s p) dist</code></pre>
<p>With rare observations, we need many more samples to get accurate
estimates. This is where more sophisticated inference methods help.</p>
<h3 id="importance-sampling">9.6 Importance Sampling</h3>
<p>Rejection sampling throws away information: every rejected sample is
wasted computation. <em>Importance sampling</em> does better by keeping
track of weights. Instead of rejecting unlikely executions, we weight
them by their likelihood.</p>
<p>The idea is simple: run particles and track a weight for each. When
an observation occurs, multiply the particle’s weight by the likelihood
instead of rejecting.</p>
<p>```ocaml env=ch9 module Importance = struct exception HardFail</p>
<p>let sample_index weights = let total = Array.fold_left (+.) 0.0
weights in let r = Random.float total in let rec find i acc = if i &gt;=
Array.length weights then Array.length weights - 1 else if r &lt; acc +.
weights.(i) then i else find (i + 1) (acc +. weights.(i)) in find 0
0.0</p>
<p>let run_once : type a. (unit -&gt; a) -&gt; (a * float) option = fun
f -&gt; let weight = ref 1.0 in match f () with | result -&gt; Some
(result, !weight) | effect (Sample (_, weights)), k -&gt;
Effect.Deep.continue k (sample_index weights) | effect (Observe
likelihood), k -&gt; weight := !weight *. likelihood;
Effect.Deep.continue k () | effect Fail, k -&gt; Effect.Deep.discontinue
k HardFail | exception HardFail -&gt; None</p>
<p>let infer ?(samples=10000) f = let results = Hashtbl.create 16 in let
total_weight = ref 0.0 in for _ = 1 to samples do match run_once f with
| None -&gt; () | Some (v, w) -&gt; total_weight := !total_weight +. w;
let prev = try Hashtbl.find results v with Not_found -&gt; 0.0 in
Hashtbl.replace results v (prev +. w) done; if !total_weight &gt; 0.0
then Hashtbl.fold (fun v w acc -&gt; (v, w /. !total_weight) :: acc)
results [] |&gt; List.sort (fun (<em>, p1) (</em>, p2) -&gt; compare p2
p1) else [] end</p>
<pre><code>
### 9.7 Soft Conditioning with Observe

So far our burglary example uses hard conditioning with `fail ()`. Let us rewrite it to use soft conditioning with `observe`:

```ocaml env=ch9
let burglary_soft ~john_called ~mary_called =
  let earthquake = flip 0.002 in
  let burglary = flip 0.001 in
  let alarm_prob = match burglary, earthquake with
    | false, false -&gt; 0.001
    | false, true -&gt; 0.29
    | true, false -&gt; 0.94
    | true, true -&gt; 0.95 in
  let alarm = flip alarm_prob in
  (* Soft conditioning: observe the likelihood of the evidence *)
  let john_prob = if alarm then 0.9 else 0.05 in
  let mary_prob = if alarm then 0.7 else 0.01 in
  let john_like = if john_called then john_prob else 1.0 -. john_prob in
  let mary_like = if mary_called then mary_prob else 1.0 -. mary_prob in
  observe john_like;
  observe mary_like;
  (* Return the outcome *)
  match burglary, earthquake with
  | false, false -&gt; Safe
  | true, false -&gt; Burglary
  | false, true -&gt; Earthquake
  | true, true -&gt; Both

let () =
  Printf.printf &quot;\n=== Importance Sampling Tests ===\n&quot;;
  Printf.printf &quot;Burglary soft (john=true, mary=true):\n&quot;;
  let dist = Importance.infer ~samples:50000 (fun () -&gt;
    burglary_soft ~john_called:true ~mary_called:true) in
  List.iter (fun (outcome, p) -&gt;
    let s = match outcome with
      | Safe -&gt; &quot;Safe&quot; | Burglary -&gt; &quot;Burglary&quot;
      | Earthquake -&gt; &quot;Earthquake&quot; | Both -&gt; &quot;Both&quot; in
    Printf.printf &quot;  %s: %.4f\n&quot; s p) dist</code></pre>
<p>The soft conditioning version is more efficient because every
particle contributes to the estimate, weighted by how well it matches
the observations.</p>
<h3 id="particle-filter-with-replay">9.8 Particle Filter with
Replay</h3>
<p>For models where observations occur at multiple points during
execution, we can do even better with <em>particle filtering</em>. The
key idea is to run multiple particles in parallel, periodically
<em>resampling</em> to focus computation on high-weight particles.</p>
<p>The challenge is that OCaml’s continuations are one-shot, so we
cannot simply “clone” a particle. Instead, we use <strong>replay-based
inference</strong>: store the sequence of sampling choices (a
<em>trace</em>), and when we need to continue a particle, re-run the
program from the beginning but fast-forward through already-recorded
choices. Each <code>Sample</code> effect serves as a natural
synchronization point.</p>
<p>```ocaml env=ch9 module ParticleFilter = struct type trace = int list
exception HardFail</p>
<p>(* Result of running one step <em>) type ’a step = | Done of ’a </em>
trace * float (* completed with result, trace, weight <em>) | Paused of
trace </em> float (* paused at Sample with trace, weight <em>) | Failed
(</em> hard failure *)</p>
<p>let sample_index weights = let total = Array.fold_left (+.) 0.0
weights in let r = Random.float total in let rec find i acc = if i &gt;=
Array.length weights then Array.length weights - 1 else if r &lt; acc +.
weights.(i) then i else find (i + 1) (acc +. weights.(i)) in find 0
0.0</p>
<p>(* Run until the next fresh Sample, replaying recorded choices *) let
run_one_step : type a. (unit -&gt; a) -&gt; trace -&gt; a step = fun f
trace -&gt; let remaining = ref trace in let recorded = ref [] in let
weight = ref 1.0 in match f () with | result -&gt; Done (result,
List.rev !recorded, !weight) | effect (Sample (_, weights)), k -&gt;
(match !remaining with | choice :: rest -&gt; (* Replay: use recorded
choice <em>) remaining := rest; recorded := choice :: !recorded;
Effect.Deep.continue k choice | [] -&gt; (</em> Fresh sample: make
choice and pause <em>) let choice = sample_index weights in recorded :=
choice :: !recorded; Paused (List.rev !recorded, !weight)) | effect
(Observe likelihood), k -&gt; weight := !weight </em>. likelihood;
Effect.Deep.continue k () | effect Fail, k -&gt; Effect.Deep.discontinue
k HardFail | exception HardFail -&gt; Failed</p>
<p>(* Resample: select n indices according to weights *) let
resample_indices n weights = let total = Array.fold_left (+.) 0.0
weights in if total &lt;= 0.0 then Array.init n (fun i -&gt; i mod n)
else begin let cumulative = Array.make n 0.0 in let acc = ref 0.0 in
Array.iteri (fun i w -&gt; acc := !acc +. w /. total; cumulative.(i)
&lt;- !acc) weights; Array.init n (fun _ -&gt; let r = Random.float 1.0
in let rec find i = if i &gt;= n - 1 || cumulative.(i) &gt;= r then i
else find (i + 1) in find 0) end</p>
<p>(* Effective sample size relative to n (returns value in [0, 1])
<em>) let effective_sample_size weights = let n = float_of_int
(Array.length weights) in let total = Array.fold_left (+.) 0.0 weights
in if total &lt;= 0.0 then 0.0 else begin let sum_sq = Array.fold_left
(fun acc w -&gt; let nw = w /. total in acc +. nw </em>. nw) 0.0 weights
in 1.0 /. sum_sq /. n end</p>
<p>let infer ?(n=1000) ?(resample_threshold=0.5) f = (* Each particle:
trace, weight *) let traces = Array.make n [] in let weights =
Array.make n 1.0 in let active = Array.make n true in let final_results
= ref [] in let n_active = ref n in</p>
<pre><code>while !n_active &gt; 0 do
  (* Advance each active particle by one Sample *)
  for i = 0 to n - 1 do
    if active.(i) then
      match run_one_step f traces.(i) with
      | Done (result, trace, w) -&gt;
          final_results := (result, weights.(i) *. w) :: !final_results;
          active.(i) &lt;- false;
          decr n_active
      | Paused (trace, w) -&gt;
          traces.(i) &lt;- trace;
          weights.(i) &lt;- weights.(i) *. w
      | Failed -&gt;
          active.(i) &lt;- false;
          decr n_active
  done;

  (* Resample if ESS is low and there are still active particles *)
  if !n_active &gt; 0 then begin
    let active_weights = Array.of_list (
      Array.to_list weights |&gt; List.filteri (fun i _ -&gt; active.(i))) in
    if effective_sample_size active_weights &lt; resample_threshold then begin
      let active_indices = Array.of_list (
        List.init n (fun i -&gt; i) |&gt; List.filter (fun i -&gt; active.(i))) in
      let active_n = Array.length active_indices in
      let indices = resample_indices active_n active_weights in
      let new_traces = Array.map (fun j -&gt;
        traces.(active_indices.(j))) indices in
      let new_weight = 1.0 /. float_of_int active_n in
      Array.iteri (fun j _ -&gt;
        traces.(active_indices.(j)) &lt;- new_traces.(j);
        weights.(active_indices.(j)) &lt;- new_weight) indices
    end
  end
done;

(* Aggregate results *)
let combined = Hashtbl.create 16 in
let total = ref 0.0 in
List.iter (fun (v, w) -&gt;
  total := !total +. w;
  let prev = try Hashtbl.find combined v with Not_found -&gt; 0.0 in
  Hashtbl.replace combined v (prev +. w)) !final_results;
if !total &gt; 0.0 then
  Hashtbl.fold (fun v w acc -&gt; (v, w /. !total) :: acc) combined []
  |&gt; List.sort (fun (_, p1) (_, p2) -&gt; compare p2 p1)
else []</code></pre>
<p>end</p>
<pre><code>
The particle filter works by:

1. **Initialization**: Start n particles with empty traces and equal weights
2. **Extension**: Advance each particle to the next `Sample`. During replay, recorded choices are reused; at a fresh `Sample`, we make a new choice and pause
3. **Weight accumulation**: `Observe` effects multiply the particle&#39;s weight
4. **Resampling**: If the effective sample size drops below the threshold, resample traces proportional to weights
5. **Completion**: When a particle finishes, record its result weighted by its final weight

Let us test the particle filter:

```ocaml env=ch9
let () =
  Printf.printf &quot;\n=== Particle Filter Tests ===\n&quot;;
  Printf.printf &quot;Monty Hall (no switch): &quot;;
  let dist = ParticleFilter.infer ~n:5000 (fun () -&gt; monty_hall ~switch:false) in
  List.iter (fun (win, p) -&gt;
    Printf.printf &quot;%s: %.3f  &quot; (if win then &quot;win&quot; else &quot;lose&quot;) p) dist;
  print_newline ()

let () =
  Printf.printf &quot;Monty Hall (switch): &quot;;
  let dist = ParticleFilter.infer ~n:5000 (fun () -&gt; monty_hall ~switch:true) in
  List.iter (fun (win, p) -&gt;
    Printf.printf &quot;%s: %.3f  &quot; (if win then &quot;win&quot; else &quot;lose&quot;) p) dist;
  print_newline ()

let () =
  Printf.printf &quot;Burglary soft (particle filter):\n&quot;;
  let dist = ParticleFilter.infer ~n:10000 (fun () -&gt;
    burglary_soft ~john_called:true ~mary_called:true) in
  List.iter (fun (outcome, p) -&gt;
    let s = match outcome with
      | Safe -&gt; &quot;Safe&quot; | Burglary -&gt; &quot;Burglary&quot;
      | Earthquake -&gt; &quot;Earthquake&quot; | Both -&gt; &quot;Both&quot; in
    Printf.printf &quot;  %s: %.4f\n&quot; s p) dist</code></pre>
<h3 id="comparing-inference-methods">9.9 Comparing Inference
Methods</h3>
<p>We have seen three approaches to probabilistic inference:</p>
<table>
<colgroup>
<col style="width: 40%" />
<col style="width: 30%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr>
<th>Method</th>
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr>
<td>Rejection Sampling</td>
<td>Simple, exact for accepted samples</td>
<td>Wasteful when observations are rare</td>
</tr>
<tr>
<td>Importance Sampling</td>
<td>Uses all samples</td>
<td>Can suffer from weight degeneracy</td>
</tr>
<tr>
<td>Particle Filtering</td>
<td>Adaptive resampling</td>
<td>More complex, replay overhead</td>
</tr>
</tbody>
</table>
<p>The effect-based approach has a key advantage: the <em>same
probabilistic program</em> can be interpreted by different handlers. We
write <code>monty_hall</code> once and run it with any inference
engine.</p>
<p><code>ocaml env=ch9 let () =   Printf.printf "\n=== Comparison ===\n";   let test name infer =     let dist = infer (fun () -&gt; monty_hall ~switch:true) in     let win_prob = try List.assoc true dist with Not_found -&gt; 0.0 in     Printf.printf "%s: P(win|switch) = %.4f\n" name win_prob   in   test "Rejection" (Rejection.infer ~samples:10000);   test "Importance" (Importance.infer ~samples:10000);   test "Particle Filter" (ParticleFilter.infer ~n:5000)</code></p>
<h3 id="summary">9.10 Summary</h3>
<p>Algebraic effects provide a powerful alternative to monads for
structuring effectful computations:</p>
<ol type="1">
<li><p><strong>Separation of concerns</strong>: Effect declarations
specify <em>what</em> effects can occur. Handlers specify <em>how</em>
effects are interpreted.</p></li>
<li><p><strong>Direct style</strong>: Code performing effects looks like
ordinary code. No <code>let*</code> or bind operators needed.</p></li>
<li><p><strong>Flexibility</strong>: The same effectful code can be
interpreted different ways by different handlers.</p></li>
<li><p><strong>Continuations</strong>: Handlers receive continuations,
enabling sophisticated control flow patterns like coroutines and
particle filtering.</p></li>
</ol>
<p>We saw two substantial applications:</p>
<ul>
<li><p><strong>Lightweight threads</strong>: Effects make cooperative
concurrency straightforward. The <code>Yield</code>, <code>Async</code>,
and <code>Await</code> effects are handled by a scheduler that manages
continuations.</p></li>
<li><p><strong>Probabilistic programming</strong>: <code>Sample</code>,
<code>Observe</code>, and <code>Fail</code> effects describe
probabilistic models. Different handlers implement different inference
strategies.</p></li>
</ul>
<p>The key insight is that effects are a <em>programming interface</em>
that can have multiple <em>implementations</em>. This makes code more
modular and reusable.</p>
<h3 id="exercises-6">9.11 Exercises</h3>
<p><strong>Exercise 1.</strong> Extend the <code>Threads</code> module
to support timeouts. Add an effect
<code>Timeout : float -&gt; 'a promise -&gt; 'a option Effect.t</code>
that waits for a promise with a timeout, returning <code>None</code> if
the timeout expires. You will need to track elapsed “time” (perhaps
measured in yields).</p>
<p><strong>Exercise 2.</strong> Implement a simple generator/iterator
pattern using effects. Define a
<code>YieldGen : 'a -&gt; unit Effect.t</code> and write: - A function
<code>generate : (unit -&gt; unit) -&gt; 'a Seq.t</code> that converts a
procedure using <code>YieldGen</code> into a sequence. - Use it to
implement a generator for Fibonacci numbers.</p>
<p><strong>Exercise 3.</strong> The <code>State</code> module above only
handles integer state. Generalize it to handle state of any type using a
functor or first-class modules.</p>
<p><strong>Exercise 4.</strong> Write a probabilistic program for the
following scenario: You have two coins, a fair one (50% heads) and a
biased one (70% heads). You pick a coin uniformly at random, flip it
three times, and observe that all three flips came up heads. What is the
probability that you picked the biased coin? Run inference with both
<code>Rejection</code> and <code>Importance</code> and compare the
results and efficiency.</p>
<p><strong>Exercise 5.</strong> Implement a <em>likelihood
weighting</em> version of inference that is between rejection sampling
and full importance sampling. In likelihood weighting, we sample from
the prior for <code>Sample</code> effects but weight by the likelihood
for <code>Observe</code> effects. Compare with rejection sampling on the
burglary example.</p>
<p><strong>Exercise 6.</strong> Our probabilistic programming interface
uses <code>Sample : int -&gt; int</code> to choose an index, which
callers then use to select from their list of options. Consider a more
direct <code>Choose : 'a list -&gt; 'a</code> effect.</p>
<ol type="1">
<li>Why is <code>Choose : 'a list -&gt; 'a Effect.t</code> problematic
for OCaml’s type system? (Hint: effect handlers must handle all
occurrences of an effect uniformly, but different <code>Choose</code>
calls may have different types.)</li>
<li>Even if we could define the effect, explain why replay-based
handlers (rejection sampling, importance sampling, particle filter) face
additional difficulty: traces would need to store values of different
types.</li>
<li>One workaround uses existential types:
<code>type packed = Pack : 'a -&gt; packed</code> with traces as
<code>packed list</code>, and <code>Obj.magic</code> during replay.
Implement this for the rejection sampler and discuss why it’s
unsafe.</li>
</ol>
<p><strong>Exercise 7.</strong> The particle filter currently pauses at
every <code>Sample</code>, which may cause excessive resampling
overhead. Modify it to pause more selectively: only pause at a
<code>Sample</code> that occurs after at least one <code>Observe</code>
since the last pause. This focuses resampling on points where weights
have actually changed. (Hint: track whether any <code>Observe</code> has
occurred since the last pause.)</p>
<p><strong>Exercise 8.</strong> Optimize the particle filter by storing
the suspended continuation alongside the trace in <code>Paused</code>.
When advancing a particle, first try to resume the stored continuation
directly. If resampling duplicated the particle (i.e., another particle
already consumed the continuation), the resume will raise
<code>Effect.Continuation_already_resumed</code> – catch this and fall
back to replay. This avoids replay overhead for particles that weren’t
duplicated during resampling.</p>
<h2 id="chapter-10-functional-reactive-programming">Chapter 10:
Functional Reactive Programming</h2>
<p>How do we deal with change and interaction in functional programming?
This is one of the most challenging questions in the field, and over the
years programmers have developed increasingly sophisticated answers.
This chapter explores a progression of techniques: we begin with
<em>zippers</em>, a clever data structure for navigating and modifying
positions within larger structures. We then advance to <em>adaptive
programming</em> (also known as incremental computing), which
automatically propagates changes through computations. Finally, we
arrive at <em>Functional Reactive Programming</em> (FRP), a declarative
approach to handling time-varying values and event streams. We conclude
with practical examples including graphical user interfaces.</p>
<p><strong>Recommended Reading:</strong></p>
<ul>
<li><em>“The Zipper”</em> by Gérard Huet – the original paper
introducing zippers</li>
<li><a href="https://en.wikibooks.org/wiki/Haskell/Zippers">Zippers
(Haskell Wikibook)</a> – visual intuition and examples</li>
<li><a href="how-froc-works-a.png"><em>How <code>froc</code>
works</em></a> – a slide-friendly walk through dependency graphs (this
chapter includes the figures)</li>
<li><a href="https://github.com/let-def/lwd"><code>lwd</code>
documentation</a> – lightweight reactive documents for OCaml</li>
<li><a
href="https://github.com/janestreet/incremental"><code>incremental</code>
documentation</a> – Jane Street’s industrial incremental engine</li>
<li><em>“The Haskell School of Expression”</em> by Paul Hudak – a
classic FRP source</li>
<li><em>“Deprecating the Observer Pattern with
<code>Scala.React</code>”</em> by Ingo Maier and Martin Odersky</li>
<li>If you want background on OCaml 5 effect handlers (used in Section
10.7), see the OCaml manual and OCaml 5 release material.</li>
</ul>
<h3 id="zippers">10.1 Zippers</h3>
<p>Imagine you are editing a document, a tree structure, or navigating
through a file system. You need to keep track of where you are, easily
access and modify the data at that location, and move around
efficiently. This is exactly the problem that zippers solve.</p>
<p>Recall from earlier chapters how we defined <em>context types</em>
for datatypes – types that represent a data structure with one of its
elements missing. We discovered that taking the derivative of an
algebraic datatype gives us exactly this context type. Now we will put
this theory to practical use.</p>
<p>Consider binary trees:</p>
<p><code>ocaml skip type btree = Tip | Node of int * btree * btree</code></p>
<p>Using our algebraic datatype calculus, where <span
class="math inline">T</span> represents the tree type:</p>
<p><span class="math display">
\begin{matrix}
T &amp; = &amp; 1 + xT^2 \\
\frac{\partial T}{\partial x} &amp; = &amp; 0 + T^2 + 2xT\frac{\partial
T}{\partial x} = TT + 2xT\frac{\partial T}{\partial x}
\end{matrix}
</span></p>
<p>This derivative gives us the context type:</p>
<p><code>ocaml skip type btree_dir = LeftBranch | RightBranch type btree_deriv =   | Here of btree * btree   | Below of btree_dir * int * btree * btree_deriv</code></p>
<p>The key insight is that <strong>Location = context +
subtree</strong>! A location in a data structure consists of two parts:
the context (everything around the focused element) and the subtree
(what we are currently looking at).</p>
<p>However, there is a problem with the representation above: we cannot
easily move the location if <code>Here</code> is at the bottom of our
context representation. Think about it: if we want to move up from our
current position, we need to access the innermost layer of the context
first. The part closest to the location should be on top, not buried at
the bottom.</p>
<h4 id="revisiting-the-equations">Revisiting the Equations</h4>
<p>Let us revisit the equations for trees and lists:</p>
<p><span class="math display">
\begin{matrix}
T &amp; = &amp; 1 + xT^2 \\
\frac{\partial T}{\partial x} &amp; = &amp; 0 + T^2 + 2xT\frac{\partial
T}{\partial x} \\
\frac{\partial T}{\partial x} &amp; = &amp; \frac{T^2}{1 - 2xT} \\
L(y) &amp; = &amp; 1 + yL(y) \\
L(y) &amp; = &amp; \frac{1}{1 - y} \\
\frac{\partial T}{\partial x} &amp; = &amp; T^2 L(2xT)
\end{matrix}
</span></p>
<p>This algebraic manipulation reveals something beautiful: the context
can be stored as a list with the root as the last node. The <span
class="math inline">L(2xT)</span> factor tells us that we have a list
where each element consists of <span class="math inline">2xT</span> –
that is, a direction indicator (left or right, hence the factor of 2),
the element at that node (<span class="math inline">x</span>), and the
sibling subtree (<span class="math inline">T</span>).</p>
<p>It does not matter whether we use built-in OCaml lists or define a
custom type with <code>Above</code> and <code>Root</code> variants – the
structure is the same.</p>
<p>In practice, contexts of subtrees are more useful than contexts of
single elements. Rather than tracking where a single value lives, we
track the position of an entire subtree within the larger structure:</p>
<p>```ocaml env=ch10 type ’a tree = Tip | Node of ’a tree * ’a * ’a tree
type tree_dir = Left_br | Right_br type ’a context = (tree_dir * ’a * ’a
tree) list type ’a location = {sub: ’a tree; ctx: ’a context}</p>
<p>let access {sub; _} = sub (* Get the current subtree *) let change
{ctx; _} sub = {sub; ctx} (* Replace the subtree, keep context <em>) let
modify f {sub; ctx} = {sub = f sub; ctx} (</em> Transform the subtree
*)</p>
<pre><code>
There is a wonderful visual intuition for zippers: imagine taking a tree and pinning it at one of its nodes, then letting it hang down under gravity. The pinned node becomes &quot;the current focus,&quot; and all the other parts of the tree dangle from it. This mental picture helps understand how movement works: moving to a child means letting a new node become the pin point, with the old parent now hanging above. For excellent visualizations, see [Zippers (Haskell Wikibook)](https://en.wikibooks.org/wiki/Haskell/Zippers).

#### Moving Around

Navigation functions allow us to traverse the structure. Each movement operation restructures the zipper: what was context becomes part of the subtree, and vice versa. Watch how ascending rebuilds a parent node from the context, while descending breaks apart a node to create new context:

```ocaml env=ch10
let ascend loc =
  match loc.ctx with
  | [] -&gt; loc  (* At root already, or raise exception *)
  | (Left_br, n, l) :: up_ctx -&gt;
    (* We were in the right subtree; rebuild the parent node *)
    {sub = Node (l, n, loc.sub); ctx = up_ctx}
  | (Right_br, n, r) :: up_ctx -&gt;
    (* We were in the left subtree; rebuild the parent node *)
    {sub = Node (loc.sub, n, r); ctx = up_ctx}

let desc_left loc =
  match loc.sub with
  | Tip -&gt; loc  (* Cannot descend into a tip, or raise exception *)
  | Node (l, n, r) -&gt;
    (* Focus on left child; right sibling goes into context *)
    {sub = l; ctx = (Right_br, n, r) :: loc.ctx}

let desc_right loc =
  match loc.sub with
  | Tip -&gt; loc  (* Cannot descend into a tip, or raise exception *)
  | Node (l, n, r) -&gt;
    (* Focus on right child; left sibling goes into context *)
    {sub = r; ctx = (Left_br, n, l) :: loc.ctx}</code></pre>
<h4 id="trees-with-arbitrary-branching">Trees with Arbitrary
Branching</h4>
<p>Following <em>The Zipper</em> by Gerard Huet, let us look at a tree
with an arbitrary number of branches. This is particularly useful for
representing document structures where a group can contain any number of
children:</p>
<p><code>ocaml env=ch10 type doc = Text of string | Line | Group of doc list type context = (doc list * doc list) list  (* left siblings, right siblings *) type location = {sub: doc; ctx: context}</code></p>
<p>In this design, the context at each level stores two lists: the
siblings to the left of our current position (in reverse order for
efficient access) and the siblings to the right. This allows us to move
not just up and down, but also left and right among siblings.</p>
<p>The navigation functions for this more complex structure show how we
reconstruct the parent when going up, and how we split the sibling list
when going down:</p>
<p>```ocaml env=ch10 let go_up loc = match loc.ctx with | [] -&gt;
invalid_arg “go_up: at top” | (left, right) :: up_ctx -&gt; (*
Reconstruct the Group: reverse left siblings, add current, then right *)
{sub = Group (List.rev left @ loc.sub :: right); ctx = up_ctx}</p>
<p>let go_left loc = match loc.ctx with | [] -&gt; invalid_arg “go_left:
at top” | (l :: left, right) :: up_ctx -&gt; (* Move to left sibling;
current element moves to right siblings *) {sub = l; ctx = (left,
loc.sub :: right) :: up_ctx} | ([], <em>) :: </em> -&gt; invalid_arg
“go_left: at first”</p>
<p>let go_right loc = match loc.ctx with | [] -&gt; invalid_arg
“go_right: at top” | (left, r :: right) :: up_ctx -&gt; (* Move to right
sibling; current element moves to left siblings *) {sub = r; ctx =
(loc.sub :: left, right) :: up_ctx} | (<em>, []) :: </em> -&gt;
invalid_arg “go_right: at last”</p>
<p>let go_down loc = (* Go to the first (i.e. leftmost) subdocument
<em>) match loc.sub with | Text _ -&gt; invalid_arg “go_down: at text” |
Line -&gt; invalid_arg “go_down: at line” | Group [] -&gt; invalid_arg
“go_down: at empty” | Group (doc :: docs) -&gt; (</em> First child
becomes focus; rest become right siblings *) {sub = doc; ctx = ([],
docs) :: loc.ctx}</p>
<pre><code>
### 10.2 Example: Context Rewriting

Let us put zippers to work on a real problem. Imagine a friend working on string theory asks us for help simplifying equations. The task is to pull out particular subexpressions as far to the left as possible, while changing the whole expression as little as possible. This kind of algebraic manipulation is common in symbolic computation.

We can illustrate our algorithm using mathematical notation. Let:
- $x$ be the thing we pull out
- $C[e]$ and $D[e]$ be big expressions with subexpression $e$
- operator $\circ$ stand for one of: $*, +$

The rewriting rules are:

$$
\begin{matrix}
D[(C[x] \circ e_1) \circ e_2] &amp; \Rightarrow &amp; D[C[x] \circ (e_1 \circ e_2)] \\
D[e_2 \circ (C[x] \circ e_1)] &amp; \Rightarrow &amp; D[C[x] \circ (e_1 \circ e_2)] \\
D[(C[x] + e_1) e_2] &amp; \Rightarrow &amp; D[C[x] e_2 + e_1 e_2] \\
D[e_2 (C[x] + e_1)] &amp; \Rightarrow &amp; D[C[x] e_2 + e_1 e_2] \\
D[e \circ C[x]] &amp; \Rightarrow &amp; D[C[x] \circ e]
\end{matrix}
$$

These rules encode the algebraic properties we need: associativity (first two rules), distributivity of multiplication over addition (third and fourth rules), and commutativity (last rule, which lets us swap operands). The key insight is that we can implement these transformations efficiently using a zipper, since each rule only needs to look at a small neighborhood of the current position.

First, the groundwork. We define expression types and a zipper for navigating them:

```ocaml env=ch10
type op = Add | Mul
type expr = Val of int | Var of string | App of expr * op * expr
type expr_dir = Left_arg | Right_arg
type context = (expr_dir * op * expr) list
type location = {sub: expr; ctx: context}</code></pre>
<p>To locate the subexpression described by predicate <code>p</code>, we
search the expression tree and build up the context as we go. Notice
that we build the context in reverse order during the search, then
reverse it at the end so the innermost context comes first (as required
for efficient navigation):</p>
<p>```ocaml env=ch10 let rec find_aux p e = if p e then Some (e, [])
else match e with | Val _ | Var _ -&gt; None | App (l, op, r) -&gt;
match find_aux p l with | Some (sub, up_ctx) -&gt; Some (sub,
(Right_arg, op, r) :: up_ctx) | None -&gt; match find_aux p r with |
Some (sub, up_ctx) -&gt; Some (sub, (Left_arg, op, l) :: up_ctx) | None
-&gt; None</p>
<p>let find p e = match find_aux p e with | None -&gt; None | Some (sub,
ctx) -&gt; Some {sub; ctx = List.rev ctx}</p>
<pre><code>
Now we can implement the pull-out transformation. This is where the zipper shines: we pattern match on the context to decide which rewriting rule to apply, then modify the context directly. The function recursively moves the target subexpression outward until it reaches the root:

```ocaml env=ch10
let rec pull_out loc =
  match loc.ctx with
  | [] -&gt; loc  (* Done: reached the root *)
  | (Left_arg, op, l) :: up_ctx -&gt;
    (* D[e . C[x]] =&gt; D[C[x] . e] -- use commutativity to swap sides *)
    pull_out {loc with ctx = (Right_arg, op, l) :: up_ctx}
  | (Right_arg, op1, e1) :: (_, op2, e2) :: up_ctx
      when op1 = op2 -&gt;
    (* D[(C[x] . e1) . e2] =&gt; D[C[x] . (e1 . e2)] -- associativity *)
    pull_out {loc with ctx = (Right_arg, op1, App(e1, op1, e2)) :: up_ctx}
  | (Right_arg, Add, e1) :: (_, Mul, e2) :: up_ctx -&gt;
    (* D[(C[x] + e1) * e2] =&gt; D[C[x] * e2 + e1 * e2] -- distributivity *)
    pull_out {loc with ctx =
        (Right_arg, Mul, e2) ::
          (Right_arg, Add, App(e1, Mul, e2)) :: up_ctx}
  | (Right_arg, op, r) :: up_ctx -&gt;
    (* No rule applies: move up by incorporating current context *)
    pull_out {sub = App(loc.sub, op, r); ctx = up_ctx}</code></pre>
<p>Since we assume operators are commutative, we can ignore the
direction for the second piece of context above – both
<code>(C[x] . e1) . e2</code> and <code>e2 . (C[x] . e1)</code> are
handled by the same associativity rule.</p>
<p>Let us test the implementation with a concrete example:</p>
<p>```ocaml env=ch10 let rec expr_to_string = function | Val n -&gt;
string_of_int n | Var v -&gt; v | App (l, Add, r) -&gt; “(” ^
expr_to_string l ^ “+” ^ expr_to_string r ^ “)” | App (l, Mul, r) -&gt;
“(” ^ expr_to_string l ^ “*” ^ expr_to_string r ^ “)”</p>
<p>module ExprOps = struct let (+) a b = App (a, Add, b) let ( * ) a b =
App (a, Mul, b) let (!) a = Val a end let x = Var “x” let y = Var
“y”</p>
<p>(* Original: 5 + y * (7 + x) * (3 + y) – we want to pull x to the
front <em>) let ex = ExprOps.(!5 + y </em> (!7 + x) * (!3 + y)) let loc
= find (fun e -&gt; e = x) ex let sol = match loc with | None -&gt;
raise Not_found | Some loc -&gt; pull_out loc let result =
expr_to_string sol.sub let () = assert (result =
“(((x<em>y)</em>(3+y))+(((7<em>y)</em>(3+y))+5))”)</p>
<pre><code>
The transformation successfully pulled `x` from deep inside the expression to the outermost left position. For best results on complex expressions, we can iterate the `pull_out` function until a fixpoint is reached, ensuring all instances of the target are pulled out as far as possible.

### 10.3 Adaptive Programming (Incremental Computing)

Zippers gave us a way to make *local* edits to a large structure while keeping enough context to put the structure back together. But they do not, by themselves, solve a more global problem:

&gt; if we change an input, how do we update *all* the derived results efficiently, without rewriting the whole program to “thread the context around”?

**Incremental computing** (also called **self-adjusting computation** or **adaptive programming**) answers this by letting us write code in a direct style while the runtime system records *dependencies* between intermediate results. When an input changes, only the part of the computation graph that depends on that input is recomputed; everything else is reused.

#### A Mental Model: Traces and Change Propagation

Think of an incremental program as building a directed acyclic graph (DAG):

- **Leaves** are *changeable inputs* (mutable cells).
- **Internal nodes** are *pure computations* (maps, combinations, binds).
- **Roots** are *observers* (the results we care to keep up-to-date).

When a leaf changes, the system does two logically separate things:

1. **Invalidate** cached results that (transitively) depend on the changed leaf.
2. **Recompute** just enough of the graph to bring the observed roots back to a consistent state.

Different libraries make different choices about *when* recomputation happens (eager stabilization vs. lazy sampling), *how* they avoid redundant work (timestamps vs. boolean dirty flags), and *what* extra guarantees they provide (cutoffs, resource lifetimes, “no glitches”).

#### The Core Idea: Write Normal Code, Get a DAG

Consider a simple expression:
</code></pre>
<p>u = v / w + x * y + z</p>
<pre><code>
As ordinary code, this just computes a number. As an *incremental* computation, it implicitly defines a dependency graph:

- `n0 = v / w`
- `n1 = x * y`
- `n2 = n0 + n1`
- `u  = n2 + z`

When `v` changes, we should update `n0`, then `n2`, then `u`. When `z` changes, we should update only `u`. The point of incremental computing is that you should not have to maintain this update order yourself.

Most libraries expose a “lifted arithmetic” style: you still write expressions like `v / w + x * y + z`, but the operators build graph nodes rather than eagerly computing.

#### A Worked Picture: *How `froc` Works*

Jacob Donham’s short note *How `froc` works* explains incremental computation using pictures of a dependency graph (the `froc` library is historically important, but in this book we will use modern OCaml libraries in the same design space).

The expression `u = v / w + x * y + z` as a dependency graph:

![](how-froc-works-a.png){width=75%}

The same graph after memoizing intermediate results:

![](how-froc-works-b.png){width=75%}

If multiple inputs change, the engine must update nodes in a safe order (a topological schedule). The picture uses grey numbers to indicate a recomputation order:

![](how-froc-works-c.png){width=75%}

The subtle case is **dynamic dependency** (a `bind`/`join` that can choose a different subgraph). If we recompute “everything that ever depended on `x`”, we may attempt to update a branch that is no longer relevant:

![](how-froc-works-d.png){width=75%}

One approach (as described in the note) is to track not just a single timestamp but an *interval* for a node’s computation, detach the old subgraph interval when a dynamic node is recomputed, and reattach only what the new branch actually needs:

![](how-froc-works-e.png){width=75%}

Two practical lessons fall out of this:

- **Prefer applicative combinators** (`map`, `map2`, `map3`, …) for static dependency structure.
- Use **dynamic dependency** (`bind`/`join`) only when the structure truly depends on values (conditionals, switching, dynamic collections).

#### Conditional Dependencies (Dynamic Graphs)

The most interesting case is when the dependency graph itself depends on data:

```ocaml skip
(* Pseudocode: the dependencies of [out] depend on [use_fast]. *)
let out =
  if use_fast then fast_path input
  else slow_path input</code></pre>
<p>If <code>use_fast</code> flips, we must stop depending on the old
branch and start depending on the new one. Incremental systems support
this with a <em>dynamic dependency</em> operator:</p>
<ul>
<li><code>bind</code> / <code>join</code> / <code>switch</code> (names
vary): pick which subgraph is active <em>based on a value</em>.</li>
</ul>
<p>Operationally, this means: detach edges to the old branch, attach
edges to the new branch, then recompute along the newly relevant
dependencies. This is also where “glitch freedom” matters: we want each
observed root to be updated as if we recomputed in a topological order
on a single, consistent snapshot of inputs.</p>
<p>Here is the classic pitfall:</p>
<p><code>ocaml skip (* Pseudocode: [x] is a changeable input. *) let b  = map x ~f:(fun x -&gt; x = 0) let n0 = map x ~f:(fun x -&gt; 100 / x) let y  = bind b ~f:(fun b -&gt; if b then return 0 else n0)</code></p>
<p>If we naïvely “recompute everything that ever depended on
<code>x</code>”, then changing <code>x</code> to <code>0</code> would
try to compute <code>100 / 0</code> even though the branch containing
<code>n0</code> is no longer relevant. Dynamic dependency operators
solve this by making <em>reachability</em> part of correctness: when the
branch switches, the old subgraph becomes inactive and stops being
demanded by observers.</p>
<h4 id="two-modern-ocaml-libraries-lwd-and-incremental">Two Modern OCaml
Libraries: <code>lwd</code> and <code>incremental</code></h4>
<p>Many ideas above can be packaged behind a small “conceptual API”:</p>
<p>```ocaml env=ch10 module type INCREMENTAL = sig type ’a t type ’a var
type ’a obs</p>
<p>val var : ’a -&gt; ’a var val get : ’a var -&gt; ’a t val set : ’a
var -&gt; ’a -&gt; unit</p>
<p>val map : ’a t -&gt; f:(’a -&gt; ’b) -&gt; ’b t val map2 : ’a t -&gt;
’b t -&gt; f:(’a -&gt; ’b -&gt; ’c) -&gt; ’c t val bind : ’a t -&gt;
f:(’a -&gt; ’b t) -&gt; ’b t</p>
<p>val observe : ’a t -&gt; ’a obs val sample : ’a obs -&gt; ’a end</p>
<pre><code>
OCaml has at least two widely used implementations of this idea, with different priorities.

##### `Lwd` (Lightweight Reactive Documents)

`Lwd` is designed around building *reactive trees* (most famously, UI trees). Its model is **invalidate eagerly, recompute lazily**:

- `Lwd.var` / `Lwd.set` mutate leaves and immediately invalidate dependent nodes.
- Values are recomputed on demand when you `Lwd.sample` a **root** (an observer).
- It tracks *liveness*: nodes not reachable from any root are released, and `Lwd.prim` supports `acquire`/`release` for resource lifetimes (subscriptions, DOM nodes, etc.).

```ocaml env=ch10
(* Using Lwd as an incremental engine *)
let a = Lwd.var 10
let b = Lwd.var 32

let sum : int Lwd.t =
  Lwd.map2 (Lwd.get a) (Lwd.get b) ~f:( + )

let root = Lwd.observe sum
let now () = Lwd.quick_sample root

let () =
  let s0 = now () in  (* 42 *)
  Lwd.set a 11;
  let s1 = now () in  (* 43 *)
  ignore (s0, s1)</code></pre>
<h5 id="incremental-jane-street"><code>Incremental</code> (Jane
Street)</h5>
<p><code>Incremental</code> is a general-purpose industrial incremental
engine. Its model is <strong>batch updates into a stabilization
pass</strong>:</p>
<ul>
<li><code>Incr.Var.set</code> records changes to leaves.</li>
<li><code>Incr.stabilize</code> recomputes all stale <em>necessary</em>
nodes in an order based on node heights (a topological schedule).</li>
<li>It supports <strong>cutoffs</strong> (don’t propagate if “unchanged
enough”), rich observer hooks, and scoping mechanisms that help manage
dynamic graphs.</li>
</ul>
<p>```ocaml env=ch10 module Incr = Incremental.Make ()</p>
<p>let a = Incr.Var.create 10 let b = Incr.Var.create 32 let sum =
Incr.map2 (Incr.Var.watch a) (Incr.Var.watch b) ~f:( + )</p>
<p>let obs = Incr.observe sum let now () = Incr.stabilize ();
Incr.Observer.value_exn obs</p>
<p>let () = let s0 = now () in (* 42 <em>) Incr.Var.set a 11; let s1 =
now () in (</em> 43 *) ignore (s0, s1)</p>
<pre><code>
##### Comparing Design Choices (Why Two Libraries?)

Both libraries implement self-adjusting computation, but they optimize for different problem shapes. A quick high-level summary:

- **When recomputation happens**
  - `Lwd`: recompute on `sample` (pull), after eager invalidation (push).
  - `Incremental`: recompute during `stabilize` (push), sampling is just reading.
- **Graph shape expectations**
  - `Lwd`: typically tree-ish with occasional sharing; optimized to be small.
  - `Incremental`: arbitrary large DAGs with heavy sharing; optimized to schedule recomputation precisely.
- **Change propagation policy**
  - `Lwd`: simple invalidation flags; minimal bookkeeping.
  - `Incremental`: timestamps/heights, recompute heaps, cutoffs; more bookkeeping, more guarantees and knobs.
- **Lifetimes**
  - `Lwd`: explicit `acquire`/`release` on primitives; roots control liveness.
  - `Incremental`: observers/scopes and finalizers; “necessary” vs “unnecessary” nodes.

As a rule of thumb:

- Choose **`Lwd`** when your reactive graph is primarily a *view tree* (documents/widgets/DOM-ish nodes), and you care about explicit resource lifetimes and keeping the runtime lightweight.
- Choose **`Incremental`** when you have a large shared DAG, you need cutoffs and richer scheduling/inspection tools, or you want to build higher-level frameworks (e.g. component systems) on top.

The moral is not “one is better”; it is that incremental computing is a *design space*. Your choice should match how you expect your graph to evolve (tree vs. DAG, dynamic dependencies, scale) and how much control you need over scheduling and cutoffs.

#### When Incremental Computing Wins (and When It Doesn’t)

Incremental computing has overhead: it builds and maintains a dependency graph and caches intermediate results. It tends to win when you have:

- a large computation that you will update *many times*,
- each update changes a *small part* of the inputs,
- and you need outputs after each update.

If you build something once and throw it away, plain recomputation can be faster and simpler.

### 10.4 Functional Reactive Programming

Incremental computing is about efficiently updating a *pure* computation when some inputs change. **Functional Reactive Programming (FRP)** is about structuring programs that interact with a changing world—key presses, network packets, sensor readings, animations—*without giving up declarative composition*.

FRP revolves around a small vocabulary:

- A **behavior** is a value that exists “at every time” (mouse position, window size, current score).
- An **event** is a discrete occurrence (a key press, a click, a timer tick).
- A **signal** is a generic name for either kind of thing (terminology varies across libraries).

Two constraints shape every FRP design:

1. **Causality**. A signal at time `t` may depend on the past and present, but not on the future. Feedback loops must include a delay (e.g. “previous value”, integration, an explicit state step).
2. **Efficiency and consistency**. We want to avoid replaying the entire history of the world on every sample, and we want to avoid *glitches*—temporarily observing inconsistent intermediate states because dependencies update in the wrong order.

In practice, FRP systems implement some notion of an **update step** (also called a tick, a frame, a stabilization pass). During an update step we incorporate all inputs that “happened simultaneously” and then recompute derived signals in a schedule that respects dependencies.

#### Idealized Definitions (and Why We Don’t Implement Them Directly)

In the most mathematical presentation, we might write:

```ocaml skip
type time = float
type &#39;a behavior = time -&gt; &#39;a
type &#39;a event = (time * &#39;a) stream  (* increasing time stamps *)</code></pre>
<p>This says: a behavior has a value at every time; an event is a
(possibly infinite) stream of timestamped occurrences.</p>
<p>The trouble is that real programs must react to <em>external</em>
events (mouse moves, clicks, window resize). If we define behaviors as
“functions of time”, we still need some representation of “the history
of inputs so far”, and we need to compute behavior values without
rescanning that history from the beginning each time.</p>
<p>The usual move is to turn behaviors into <strong>stream
transformers</strong> that process time and inputs incrementally:</p>
<p><code>ocaml skip type 'a behavior = user_action event -&gt; time -&gt; 'a type 'a behavior = user_action event -&gt; time stream -&gt; 'a stream type 'a behavior = (user_action option * time) stream -&gt; 'a stream</code></p>
<p>This transformation from functions-of-time to stream transformers is
analogous to a classic algorithm optimization. Computing the
intersection of two lists naively checks every pair, giving <span
class="math inline">O(mn)</span> time. If the lists are sorted, the
smart approach walks through both lists simultaneously, giving <span
class="math inline">O(m + n)</span> time. Similarly, our stream-based
behaviors process time and events together in a single pass.</p>
<p>Once behaviors are stream transformers, a very convenient
representation for events is:</p>
<p><code>ocaml skip type 'a event = 'a option behavior</code></p>
<p>An event is just a behavior that yields <code>None</code> most of the
time and <code>Some v</code> at the instants where the event occurs.</p>
<h4 id="behaviors-as-applicative-static-wiring">Behaviors as Applicative
(Static Wiring)</h4>
<p>Pointwise behaviors form an applicative functor (and, in idealized
presentations, a monad). For
<code>type 'a behavior = time -&gt; 'a</code> we can define:</p>
<p><code>ocaml env=ch10 let pure a = fun _t -&gt; a let map f b = fun t -&gt; f (b t) let ap bf ba = fun t -&gt; (bf t) (ba t)</code></p>
<p>From <code>ap</code> we get the familiar lifting operators:</p>
<p><code>ocaml env=ch10 let lift2 f a b = ap (map f a) b let lift3 f a b c = ap (lift2 f a b) c</code></p>
<p>In practice, most FRP code is written in this <em>applicative</em>
style: it gives a static “wiring diagram”, which is easier to implement
efficiently and avoids surprising dynamic dependencies.</p>
<h4 id="converting-between-events-and-behaviors">Converting Between
Events and Behaviors</h4>
<p>Four combinators show up again and again:</p>
<ul>
<li><code>step : init:'a -&gt; 'a event -&gt; 'a behavior</code> (hold
last event value)</li>
<li><code>switch : init:'a behavior -&gt; 'a behavior event -&gt; 'a behavior</code>
(switch behaviors over time)</li>
<li><code>until : 'a behavior -&gt; 'a behavior event -&gt; 'a behavior</code>
(switch once)</li>
<li><code>snapshot : 'a event -&gt; 'b behavior -&gt; ('a * 'b) event</code>
(sample a behavior when an event fires)</li>
</ul>
<p>Section 10.5 builds a small stream-based FRP core where these are
concrete functions on lazy streams.</p>
<h4 id="a-concrete-input-model">A Concrete Input Model</h4>
<p>To keep the discussion concrete, we will package external inputs
(user actions) together with sampling times:</p>
<p>```ocaml env=ch10 type time = float</p>
<p>type user_action = | Key of char * bool | Button of int * int * bool
* bool | MouseMove of int * int | Resize of int * int</p>
<pre><code>
We will present two implementations:

1. A **stream-processing** implementation (Section 10.5) that makes time explicit and computes signals by consuming an input stream.
2. An **incremental** implementation (Section 10.6) that represents signals as nodes in an incremental dependency graph and updates them by invalidation/stabilization.

Conceptually, in the stream-processing interpretation we will treat:

```ocaml skip
(* Conceptual types (we refine the representation in Section 10.5). *)
type &#39;a behavior = (user_action option * time) stream -&gt; &#39;a stream
type &#39;a event = &#39;a option behavior</code></pre>
<h3 id="reactivity-by-stream-processing">10.5 Reactivity by Stream
Processing</h3>
<p>Now let us implement FRP using the stream processing techniques from
Chapter 7. The infrastructure should be familiar:</p>
<p>```ocaml env=ch10 type ’a stream = ’a stream_ Lazy.t and ’a stream_ =
Cons of ’a * ’a stream</p>
<p>let rec lmap f l = lazy ( let Cons (x, xs) = Lazy.force l in Cons (f
x, lmap f xs))</p>
<p>(* Infinite loop: only exits via an exception, either from forcing
e.g. “end of stream”, or from f e.g. “exit”. *) let rec liter (f : ’a
-&gt; unit) (l : ’a stream) : unit = let Cons (x, xs) = Lazy.force l in
f x; liter f xs</p>
<p>let rec lmap2 f xs ys = lazy ( let Cons (x, xs) = Lazy.force xs in
let Cons (y, ys) = Lazy.force ys in Cons (f x y, lmap2 f xs ys))</p>
<p>let rec lmap3 f xs ys zs = lazy ( let Cons (x, xs) = Lazy.force xs in
let Cons (y, ys) = Lazy.force ys in let Cons (z, zs) = Lazy.force zs in
Cons (f x y z, lmap3 f xs ys zs))</p>
<p>let rec lfold acc f (l : ’a stream) = lazy ( let Cons (x, xs) =
Lazy.force l in (* Fold a function over the stream <em>) let acc = f acc
x in (</em> producing a stream of partial results *) Cons (acc, lfold
acc f xs))</p>
<pre><code>
Since a behavior is a function from the input stream to an output stream, we face a subtle sharing problem: if we apply the same behavior function twice to the &quot;same&quot; input, we might create two separate streams that diverge. We need to ensure that for any actual input stream, each behavior creates exactly one output stream. This requires memoization:

```ocaml env=ch10
type (&#39;a, &#39;b) memo1 =
  {memo_f : &#39;a -&gt; &#39;b; mutable memo_r : (&#39;a * &#39;b) option}

let memo1 f = {memo_f = f; memo_r = None}

let memo1_app f x =
  match f.memo_r with
  | Some (y, res) when x == y -&gt; res  (* Physical equality check *)
  | _ -&gt;
    let res = f.memo_f x in
    f.memo_r &lt;- Some (x, res);  (* Cache for next call *)
    res

let ($) = memo1_app  (* Convenient infix for memoized application *)

type &#39;a behavior =
  ((user_action option * time) stream, &#39;a stream) memo1

type &#39;a event = &#39;a option behavior</code></pre>
<p>We use physical equality (<code>==</code>) rather than structural
equality (<code>=</code>) because the external input stream is a single
physical object – if we see the same pointer, we know it is the same
stream. During debugging, we can verify that <code>memo_r</code> is
<code>None</code> before the first call and <code>Some</code>
afterwards.</p>
<h4 id="building-complex-behaviors">Building Complex Behaviors</h4>
<p>Now we can build the monadic/applicative functions for composing
behaviors. A practical tip: when working with these higher-order types,
type annotations are essential. If you do not provide type annotations
in <code>.ml</code> files, work together with an <code>.mli</code>
interface file to catch type problems early.</p>
<p>```ocaml env=ch10 (* A constant behavior: returns the same value at
all times <em>) let returnB x : ’a behavior = let rec xs = lazy (Cons
(x, xs)) in (</em> Infinite stream of x *) memo1 (fun _ -&gt; xs)</p>
<p>let ( !* ) = returnB (* Convenient prefix operator for constants
*)</p>
<p>(* Lift a unary function to work on behaviors *) let liftB f fb =
memo1 (fun uts -&gt; lmap f (fb $ uts))</p>
<p>(* Lift binary and ternary functions similarly *) let liftB2 f fb1
fb2 = memo1 (fun uts -&gt; lmap2 f (fb1 $ uts) (fb2 $ uts))</p>
<p>let liftB3 f fb1 fb2 fb3 = memo1 (fun uts -&gt; lmap3 f (fb1 $ uts)
(fb2 $ uts) (fb3 $ uts))</p>
<p>(* Lift a function to work on events (None -&gt; None, Some e -&gt;
Some (f e)) *) let liftE f (fe : ’a event) : ’b event = memo1 (fun uts
-&gt; lmap (function Some e -&gt; Some (f e) | None -&gt; None) (fe $
uts))</p>
<p>let (=&gt;&gt;) fe f = liftE f fe (* Map over events, infix style
<em>) let (-&gt;&gt;) e v = e =&gt;&gt; fun _ -&gt; v (</em> Replace
event value with constant *)</p>
<pre><code>
We also need to create events from behaviors and vice versa. Creating events out of behaviors:

```ocaml env=ch10
(* whileB: produces an event at every moment the behavior is true *)
let whileB (fb : bool behavior) : unit event =
  memo1 (fun uts -&gt;
    lmap (function true -&gt; Some () | false -&gt; None)
      (fb $ uts))

(* unique: filters out duplicate consecutive events *)
let unique fe : &#39;a event =
  memo1 (fun uts -&gt;
    let xs = fe $ uts in
    lmap2 (fun x y -&gt; if x = y then None else y)
      (lazy (Cons (None, xs))) xs)  (* Compare with previous value *)

(* whenB: produces an event when the behavior becomes true (edge detection) *)
let whenB fb =
  memo1 (fun uts -&gt; unique (whileB fb) $ uts)

(* snapshot: when an event occurs, capture both the event value
   and current behavior value *)
let snapshot fe fb : (&#39;a * &#39;b) event =
  memo1 (fun uts -&gt; lmap2
    (fun x -&gt; function Some y -&gt; Some (y, x) | None -&gt; None)
      (fb $ uts) (fe $ uts))</code></pre>
<p>Creating behaviors out of events:</p>
<p>```ocaml env=ch10 (* step: holds the value of the most recent event,
starting with ‘acc’ *) let step acc fe = memo1 (fun uts -&gt; lfold acc
(fun acc -&gt; function None -&gt; acc | Some v -&gt; v) (fe $ uts))</p>
<p>(* step_accum: accumulates by applying functions from events to
current value *) let step_accum acc ff = memo1 (fun uts -&gt; lfold acc
(fun acc -&gt; function | None -&gt; acc | Some f -&gt; f acc) (ff $
uts))</p>
<pre><code>
For physics simulations like our upcoming paddle game, we need to integrate behaviors over time. This requires access to the sampling timestamps:

```ocaml env=ch10
let integral fb =
  let rec loop t0 acc uts bs =
    let Cons ((_, t1), uts) = Lazy.force uts in
    let Cons (b, bs) = Lazy.force bs in
    (* Rectangle rule: b is fb(t1), acc approximates integral up to t0 *)
    let acc = acc +. (t1 -. t0) *. b in
    Cons (acc, lazy (loop t1 acc uts bs)) in
  memo1 (fun uts -&gt; lazy (
    let Cons ((_, t), uts&#39;) = Lazy.force uts in
    Cons (0., lazy (loop t 0. uts&#39; (fb $ uts)))))</code></pre>
<p>In our upcoming <em>paddle game</em> example, we will express
position and velocity in a mutually recursive manner – position is the
integral of velocity, but velocity changes when position hits a wall.
This seems paradoxical: how can we define position in terms of velocity
if velocity depends on position?</p>
<p>The trick is the same as we saw in Chapter 7: integration introduces
one step of delay. The integral at time <span
class="math inline">t</span> depends on velocities at times
<em>before</em> <span class="math inline">t</span>, while the bounce
detection at time <span class="math inline">t</span> uses the position
at time <span class="math inline">t</span>. This breaks the cyclic
dependency and makes the recursion well-founded.</p>
<p>We define behaviors for user actions by extracting them from the
input stream:</p>
<p>```ocaml env=ch10 (* Left button press event *) let lbp : unit event
= memo1 (fun uts -&gt; lmap (function Some (Button (<em>, </em>, true,
<em>)), </em> -&gt; Some () | _ -&gt; None) uts)</p>
<p>(* Mouse movement event (carries coordinates) <em>) let mm : (int
</em> int) event = memo1 (fun uts -&gt; lmap (function Some (MouseMove
(x, y)), _ -&gt; Some (x, y) | _ -&gt; None) uts)</p>
<p>(* Window resize event <em>) let screen : (int </em> int) event =
memo1 (fun uts -&gt; lmap (function Some (Resize (x, y)), _ -&gt; Some
(x, y) | _ -&gt; None) uts)</p>
<p>(* Behaviors derived from events using step <em>) let mouse_x : int
behavior = step 0 (liftE fst mm) (</em> Current mouse X <em>) let
mouse_y : int behavior = step 0 (liftE snd mm) (</em> Current mouse Y
<em>) let width : int behavior = step 640 (liftE fst screen) (</em>
Window width <em>) let height : int behavior = step 512 (liftE snd
screen) (</em> Window height *)</p>
<pre><code>
#### The Paddle Game Example

Now let us put all these pieces together to build a classic paddle game (similar to Pong). A ball bounces around the screen, and the player controls a paddle at the bottom to prevent the ball from falling.

First, we define a *scene graph*, a data structure that represents a &quot;world&quot; which can be drawn on screen. Since we will use Bogue&#39;s `Sdl_area` for rendering, we use simple line-based shapes (rectangles drawn as outlines, circles approximated by line segments):

```ocaml env=ch10
type color = int * int * int  (* RGB components *)

type scene =
  | Rect of int * int * int * int  (* x, y, width, height *)
  | Circle of int * int * int      (* x, y, radius *)
  | Group of scene list
  | Color of color * scene         (* color of subscene objects *)
  | Translate of float * float * scene  (* offset *)</code></pre>
<p>The drawing function interprets the scene graph. We use Bogue’s
<code>Sdl_area</code> to draw lines:</p>
<p><code>ocaml env=ch10 let draw area ~h sc =   let open Bogue in   let f2i = int_of_float in   let flip_y y = h - y in  (* Bogue uses top-left origin *)   let rec aux t_x t_y (r, g, b) = function     | Rect (x, y, w, ht) -&gt;       let color = Draw.opaque (r, g, b) in       let x0, y0 = f2i t_x + x, flip_y (f2i t_y + y + ht) in       Sdl_area.draw_rectangle area ~color ~thick:2 ~w ~h:ht (x0, y0)     | Circle (x, y, rad) -&gt;       let color = Draw.opaque (r, g, b) in       let cx, cy = f2i t_x + x, flip_y (f2i t_y + y) in       Sdl_area.draw_circle area ~color ~thick:2 ~radius:rad (cx, cy)     | Group scs -&gt;       List.iter (aux t_x t_y (r, g, b)) scs     | Color (c, sc) -&gt;       aux t_x t_y c sc     | Translate (dx, dy, sc) -&gt;       aux (t_x +. dx) (t_y +. dy) (r, g, b) sc   in   aux 0. 0. (255, 255, 255) sc  (* Default color: white *)</code></p>
<p>An <em>animation</em> is simply a scene behavior – a time-varying
scene. The <code>reactimate</code> function runs the animation loop: it
creates the input stream (user actions paired with sampling times),
feeds it to the scene behavior to get a stream of scenes, and draws each
scene. We use double buffering to avoid flickering.</p>
<p>For the game logic, we define lifted operators so we can write
behavior expressions naturally:</p>
<p><code>ocaml env=ch10 let (+*) = liftB2 (+) let (-*) = liftB2 (-) let ( *** ) = liftB2 ( * ) let (/*) = liftB2 (/) let (&amp;&amp;*) = liftB2 (&amp;&amp;) let (||*) = liftB2 (||) let (&lt;*) = liftB2 (&lt;) let (&gt;*) = liftB2 (&gt;)</code></p>
<p>Now we can define the game elements. The walls are drawn on the left,
top and right borders of the window:</p>
<p>```ocaml env=ch10 let blue = (0, 0, 255)</p>
<p>let walls = liftB2 (fun w h -&gt; Color (blue, Group [Rect (0, 0, 20,
h-1); Rect (0, h-21, w-1, 20); Rect (w-21, 0, 20, h-1)])) width
height</p>
<pre><code>
The paddle is tied to the mouse at the bottom border of the window:

```ocaml env=ch10
let black = (0, 0, 0)

let paddle = liftB (fun mx -&gt;
  Color (black, Rect (mx, 0, 50, 10))) mouse_x</code></pre>
<p>The ball has a velocity in pixels per second and bounces from the
walls.</p>
<p>The key ideas in the ball implementation:</p>
<ul>
<li><p><code>xbounce -&gt;&gt; (~-.)</code> – When an
<code>xbounce</code> event fires, emit the negation function
<code>(~-.)</code>. This will be used to flip the velocity
sign.</p></li>
<li><p><code>step_accum vel (xbounce -&gt;&gt; (~-.))</code> – Start
with velocity <code>vel</code>, and whenever a bounce event occurs,
apply the negation function to flip the sign. This creates a velocity
that bounces back and forth.</p></li>
<li><p><code>liftB int_of_float (integral xvel) +* width /* !*2</code> –
Integrate velocity to get position (as a float), truncate to integers,
and offset to center the ball in the window.</p></li>
<li><p><code>whenB ((xpos &gt;* width -* !*27) ||* (xpos &lt;* !*27))</code>
– Fire an event the <em>first</em> time the position exceeds the wall
boundaries (27 pixels from edges, accounting for wall thickness and ball
radius). The <code>whenB</code> combinator produces an event only on the
<em>transition</em> from false to true, ensuring we do not keep bouncing
while inside the wall.</p></li>
</ul>
<p><strong>Tying the knot with memo1 records.</strong> The mutual
recursion between <code>xvel</code>, <code>xpos</code>, and
<code>xbounce</code> requires care. If we naively wrote mutually
recursive <em>functions</em> that call each other, we would get an
infinite loop at definition time (before any stream is consumed). The
trick is to define the recursion at the <em>memo1 record</em> level: we
use <code>let rec ... and ...</code> to create mutually recursive
records where each record’s <code>memo_f</code> field references the
other records by name. The actual computation is deferred until
<code>$ uts</code> is applied.</p>
<p>```ocaml env=ch10 let red = (255, 0, 0)</p>
<p>let ball : scene behavior = let wall_margin = 27 in let vel = 100.0
in (* Horizontal motion with bouncing. The mutual recursion is between
memo1 records, not function calls. <em>) let rec xvel_ uts = step_accum
vel (xbounce -&gt;&gt; (~-.)) $ uts and xvel = {memo_f = xvel_; memo_r =
None} and xpos_ uts = (liftB int_of_float (integral xvel) +</em> width
/* !<em>2) $ uts and xpos = {memo_f = xpos_; memo_r = None} and xbounce_
uts = whenB ((xpos &gt;</em> width -* !<em>wall_margin) ||</em> (xpos
&lt;* !<em>wall_margin)) $ uts and xbounce = {memo_f = xbounce_; memo_r
= None} in (</em> Vertical motion with bouncing <em>) let rec yvel_ uts
= step_accum vel (ybounce -&gt;&gt; (~-.)) $ uts and yvel = {memo_f =
yvel_; memo_r = None} and ypos_ uts = (liftB int_of_float (integral
yvel) +</em> height /* !<em>2) $ uts and ypos = {memo_f = ypos_; memo_r
= None} and ybounce_ uts = whenB ((ypos &gt;</em> height -*
!<em>wall_margin) ||</em> (ypos &lt;* !*wall_margin)) $ uts and ybounce
= {memo_f = ybounce_; memo_r = None} in liftB2 (fun x y -&gt; Color
(red, Circle (x, y, 7))) xpos ypos</p>
<pre><code>
Finally, we compose everything into the complete game scene:

```ocaml skip
let game : scene behavior =
  liftB3 (fun w p b -&gt; Group [w; p; b]) walls paddle ball</code></pre>
<p>The animation loop drives the system. With Bogue, we integrate with
its event loop by using a timer and connection callbacks:</p>
<p><code>ocaml skip let reactimate (scene : scene behavior) =   let open Bogue in   let w, h = 640, 480 in   let area_widget = Widget.sdl_area ~w ~h () in   let area = Widget.get_sdl_area area_widget in   let uts_ref = ref (lazy (assert false)) in  (* Input stream state *)   let t0 = Unix.gettimeofday () in   uts_ref := lazy (Cons ((None, t0), lazy (Cons ((None, t0), !uts_ref))));   (* Redraw on each frame *)   Sdl_area.add area (fun _renderer -&gt;     (* Clear the area *)     Sdl_area.fill_rectangle area ~color:(Draw.opaque (Draw.grey 50))       ~w ~h (0, 0);     let Cons (sc, uts') = Lazy.force (scene $ !uts_ref) in     draw area ~h sc;     let t = Unix.gettimeofday () in     (* For simplicity, we poll mouse position as the action *)     uts_ref := lazy (Cons ((Some (MouseMove (0, 0)), t), uts')));   let layout = Layout.resident area_widget in   (* Use Bogue's connection to handle mouse motion events *)   let action _w _l ev =     let mx, my = Trigger.pointer_pos ev in     let t = Unix.gettimeofday () in     uts_ref := lazy (Cons ((Some (MouseMove (mx, my)), t), Lazy.force !uts_ref));     Sdl_area.update area   in   Widget.add_connection area_widget area_widget action Trigger.pointer_motion;   let board = Main.of_layout layout in   Main.run board</code></p>
<p>The stream-based implementation is elegant but has a limitation: in
strict OCaml, recursive signal definitions require care. In the ball
example we “tie the knot” at the level of <code>memo1</code> records (so
recursion is in <em>data</em>, not immediate function calls), and we
rely on the integrator to introduce the one-step delay that makes the
dependency causal. In a lazy language like Haskell, the same kind of
recursive definition often reads more directly, but it still needs a
delay to be meaningful.</p>
<h3 id="frp-by-incremental-computing-lwd">10.6 FRP by Incremental
Computing (Lwd)</h3>
<p>The stream-processing implementation from Section 10.5 makes time
explicit and computes signals by consuming an input stream. An
alternative is to let an incremental engine maintain the dependency
graph for you, and to put “time” and “inputs” into mutable cells.</p>
<p>This is the same picture as Section 10.3:</p>
<ol type="1">
<li><strong>Inputs</strong> live in mutable variables
(<code>Lwd.var</code>).</li>
<li><strong>Derived signals</strong> are pure computations over those
vars (<code>Lwd.map</code>, <code>Lwd.map2</code>,
<code>Lwd.join</code>, …).</li>
<li>The host program chooses an <strong>update step</strong> and samples
a root once per step.</li>
</ol>
<p>This “one sample per step” discipline establishes an <strong>update
cycle</strong>:</p>
<ul>
<li>You may update many input vars; the step ends when you sample the
root.</li>
<li>Inputs updated within the same step are treated as
<strong>simultaneous</strong> (one consistent snapshot).</li>
<li>Glitch-freedom – do not interleave “half-updated inputs” with
sampling: set everything first, then sample once.</li>
</ul>
<h4 id="mapping-frp-concepts-to-lwd">Mapping FRP Concepts to Lwd</h4>
<p>A useful correspondence is:</p>
<ul>
<li><strong>Behavior</strong>: <code>'a Lwd.t</code></li>
<li><strong>Event</strong>: <code>'a option Lwd.t</code> (a pulse) or a
queue/list carried by a var</li>
<li><strong>Observer/root</strong>: <code>'a Lwd.root</code></li>
</ul>
<p>```ocaml env=ch10 module LwdFrp = struct type ’a behavior = ’a Lwd.t
type ’a event = ’a option Lwd.t</p>
<p>let returnB = Lwd.return let mapB = Lwd.map let mapB2 = Lwd.map2</p>
<p>let mapE e ~f = Lwd.map e ~f:(Option.map f) let filterE e ~f =
Lwd.map e ~f:(function None -&gt; None | Some x -&gt; f x)</p>
<p>let mergeE a b = Lwd.map2 a b ~f:(fun a b -&gt; match a with Some _
-&gt; a | None -&gt; b) end</p>
<pre><code>
`Lwd` does not have a built-in notion of time; you supply one (usually as a `float` variable updated each frame):

```ocaml env=ch10
let time_v : float Lwd.var = Lwd.var 0.0
let time_b : float Lwd.t = Lwd.get time_v

let mouse_v : (int * int) Lwd.var = Lwd.var (0, 0)
let mouse_b : (int * int) Lwd.t = Lwd.get mouse_v
let mouse_x : int Lwd.t = Lwd.map mouse_b ~f:fst
let mouse_y : int Lwd.t = Lwd.map mouse_b ~f:snd</code></pre>
<h4 id="events-as-pulses-and-a-caveat">Events as Pulses (and a
Caveat)</h4>
<p>The simplest event representation is a one-step pulse:</p>
<p><code>ocaml env=ch10 let click_v : unit option Lwd.var = Lwd.var None let click_e : unit option Lwd.t = Lwd.get click_v</code></p>
<p>In the host program, you set <code>click_v</code> to
<code>Some ()</code> for one update step and then clear it to
<code>None</code> after sampling. This gives you “happened this step?”
semantics.</p>
<p>The caveat: if many events can occur between samples, a single
<code>option</code> cell will lose information. In that case, represent
events as a list/queue (e.g. <code>user_action list</code>) accumulated
by the host program and drained once per step.</p>
<p>One more practical rule: keep mutations (<code>Lwd.set</code>) in the
host program. If a derived signal needs to “request” an output event,
model that request as data (e.g. return <code>Some msg</code>) and let
the host send it on the next step.</p>
<h4 id="stateful-signal-combinators-one-step-memory">Stateful Signal
Combinators (One-Step Memory)</h4>
<p>In FRP, feedback loops require <em>delay</em> (“previous value”). In
a stream-based model, delay falls out of stream processing. With
incremental engines, you can implement the same idea with a bit of
internal state.</p>
<p>Here are two classic combinators implemented with internal
references. They are intentionally “single-sample” oriented: sample once
per step.</p>
<p>```ocaml env=ch10 (* step: hold the last event value, starting from
[init] *) let step (init : ’a) (e : ’a option Lwd.t) : ’a Lwd.t = let
last = ref init in Lwd.map e ~f:(function | None -&gt; !last | Some v
-&gt; last := v; v)</p>
<p>(* rising_edge: None most of the time, Some () exactly when b flips
false-&gt;true *) let rising_edge (b : bool Lwd.t) : unit option Lwd.t =
let was_true = ref false in Lwd.map b ~f:(fun now -&gt; let fire = now
&amp;&amp; not !was_true in was_true := now; if fire then Some () else
None)</p>
<pre><code>
These are not “pure” in the mathematical FRP sense, but they capture a key idea: **signals can have local memory**, and that memory is exactly what causality demands.

#### Integration (Discrete Time)

We can also integrate a velocity signal by accumulating over time. This is effectively a discrete-time integrator driven by your chosen update step:

```ocaml env=ch10
let integral (v : float Lwd.t) (t : float Lwd.t) : float Lwd.t =
  let acc = ref 0.0 in
  let prev_t = ref 0.0 in
  Lwd.map2 v t ~f:(fun v t -&gt;
    let dt = t -. !prev_t in
    prev_t := t;
    acc := !acc +. dt *. v;
    !acc)</code></pre>
<h4 id="example-reimplementing-the-paddle-scene-with-lwd">Example:
Reimplementing the Paddle Scene with Lwd</h4>
<p>We reuse the <code>scene</code> type and <code>draw</code> function
from Section 10.5. The idea is:</p>
<ul>
<li>treat <code>mouse_x</code>, <code>width</code>, <code>height</code>,
<code>time</code> as input behaviors,</li>
<li>build a reactive scene graph as an <code>Lwd.t</code>,</li>
<li>sample and draw once per frame.</li>
</ul>
<p>```ocaml env=ch10 let time_v : float Lwd.var = Lwd.var 0.0 let time_b
: float Lwd.t = Lwd.get time_v</p>
<p>let mouse_v : (int * int) Lwd.var = Lwd.var (0, 0) let mouse_x : int
Lwd.t = Lwd.map (Lwd.get mouse_v) ~f:fst</p>
<p>let width_v : int Lwd.var = Lwd.var 640 let height_v : int Lwd.var =
Lwd.var 512 let width : int Lwd.t = Lwd.get width_v let height : int
Lwd.t = Lwd.get height_v</p>
<p>let blue = (0, 0, 255) let black = (0, 0, 0) let red = (255, 0,
0)</p>
<p>let walls : scene Lwd.t = Lwd.map2 width height ~f:(fun w h -&gt;
Color (blue, Group [Rect (0, 0, 20, h-1); Rect (0, h-21, w-1, 20); Rect
(w-21, 0, 20, h-1)]))</p>
<p>let paddle : scene Lwd.t = Lwd.map mouse_x ~f:(fun mx -&gt; Color
(black, Rect (mx, 0, 50, 10)))</p>
<p>let ball : scene Lwd.t = let wall_margin = 27 in let x = ref 0.0 in
let y = ref 0.0 in let xvel = ref 120.0 in let yvel = ref 160.0 in let
prev_t : float option ref = ref None in Lwd.map2 (Lwd.pair width height)
time_b ~f:(fun (w, h) t -&gt; let dt = match !prev_t with | None -&gt;
0.0 | Some t0 -&gt; t -. t0 in prev_t := Some t; x := !x +. dt <em>.
!xvel; y := !y +. dt </em>. !yvel; let xi = int_of_float !x + w / 2 in
let yi = int_of_float !y + h / 2 in if xi &gt; w - wall_margin || xi
&lt; wall_margin then xvel := -. !xvel; if yi &gt; h - wall_margin || yi
&lt; wall_margin then yvel := -. !yvel; Color (red, Circle (xi, yi,
7)))</p>
<p>let game : scene Lwd.t = Lwd.map2 walls (Lwd.pair paddle ball)
~f:(fun w (p, b) -&gt; Group [w; p; b])</p>
<pre><code>
Because `ball` above uses internal mutable state, you should sample the root scene **exactly once per update step** (otherwise the physics will advance multiple times).

Keep the sampled root (and anything you need for its computation) reachable. In `Lwd`, nodes not reachable from any root are considered dead and can be released.

This is “FRP by incremental computing” in a nutshell: the engine caches and reuses computations in the scene graph; the host program decides what constitutes a step and updates the input vars accordingly.

#### Stream FRP vs. Lwd FRP (A Practical Contrast)

- Stream-based FRP is *purely functional* and makes time explicit, but in strict OCaml mutual recursion can be awkward.
- Lwd-based FRP makes dependency tracking automatic and integrates naturally with an imperative “main loop”, but stateful signal combinators must be handled with care (sample once per step; avoid depending on evaluation order).

### 10.7 Direct Control (Effects)

FRP shines when the program is mostly “wiring”: combine signals, transform values, render a view. But many interactions are naturally **staged**:

- wait for a click,
- then track mouse movement until release,
- then wait for the next click,
- and so on.

You *can* encode staged workflows in pure FRP, but it often becomes awkward: you start building explicit state machines “in the large”.

Think of a recipe:

1. preheat the oven,
2. mix ingredients,
3. bake,
4. take out and cool.

That is not a static wiring diagram: it is a program that *proceeds through stages*. We want a *flow* that can proceed through events in sequence: when the first relevant event arrives, we process it and then wait for the next event—**ignoring** any further occurrences of the “earlier-stage” event after we have moved on.

Standard FRP combinators like “map an event” (or “whenever behavior changes, do …”) are not designed to express this “move forward and never look back” semantics. In Chapter 9 we learned that algebraic effects let us express such workflows in **direct style**, while still keeping the effectful interface abstract and interpretable by different handlers.

Here is a tiny effect-based interface for staged reactive programs:

```ocaml env=ch10
type _ Effect.t +=
  | Await : (user_action -&gt; &#39;a option) -&gt; &#39;a Effect.t
  | Emit : string -&gt; unit Effect.t

let await p = Effect.perform (Await p)
let emit (s : string) = Effect.perform (Emit s)</code></pre>
<p><code>Await p</code> means: “pause until you receive a
<code>user_action</code> for which <code>p</code> returns
<code>Some v</code>, then resume and return <code>v</code>.” This neatly
expresses “ignore everything else until the thing I’m waiting for
happens”. Operationally, this is the effect-based analog of the old
<code>next e</code> idea (“the next occurrence of event <code>e</code>,
and only that one”).</p>
<p>We are implementing <em>coarse-grained threads</em> (cooperative
scripts): a script runs in direct style until it reaches
<code>Await</code>, at which point it yields back to the surrounding
driver. There is no explicit <code>Yield</code>: <code>Await</code> is
the suspension point.</p>
<p>Sometimes we need to wait for <em>one of several</em> possible
events. With the predicate-based <code>await</code>, this is a
one-liner:</p>
<p>``<code>ocaml env=ch10 let await_either p q =   await (fun u -&gt;     match p u with     | Some a -&gt; Some (</code>A
a) | None -&gt; match q u with | Some b -&gt; Some (`B b) | None -&gt;
None)</p>
<p>let race = await_either</p>
<pre><code>
#### A Driver: “Step Until You Need Input”

To integrate a script with a GUI event loop (and to make it testable), it is useful to *step* the script until it blocks on `Await`, and then resume it only when an input arrives.

One convenient representation is a paused computation that either finished, or is waiting and provides a function to feed the next input action:

```ocaml env=ch10
type &#39;a paused =
  | Done of &#39;a
  | Awaiting of {feed : user_action -&gt; &#39;a paused}

let step ~(on_emit : string -&gt; unit) (th : unit -&gt; &#39;a) : &#39;a paused =
  Effect.Deep.match_with th () {
    retc = (fun v -&gt; Done v);
    exnc = raise;
    effc = fun (type c) (eff : c Effect.t) -&gt;
      match eff with
      | Emit x -&gt;
        Some (fun (k : (c, _) Effect.Deep.continuation) -&gt;
          on_emit x;
          Effect.Deep.continue k ())
      | Await p -&gt;
        Some (fun (k : (c, _) Effect.Deep.continuation) -&gt;
          let rec feed (u : user_action) =
            match p u with
            | None -&gt; Awaiting {feed}  (* ignore and keep waiting *)
            | Some v -&gt; Effect.Deep.continue k v
          in
          Awaiting {feed})
      | _ -&gt; None
  }</code></pre>
<p>This is the “flow as a lightweight thread” idea, but without a monad:
the state of the thread is the (closed-over) continuation stored inside
<code>feed</code>.</p>
<h4 id="a-handler-replay-a-script-of-inputs">A Handler: Replay a Script
of Inputs</h4>
<p>Using the stepping driver, we can interpret <code>Await</code> by
consuming a pre-recorded list of <code>user_action</code>s (useful for
tests and examples):</p>
<p><code>ocaml env=ch10 let run_script (type a) ~(inputs : user_action list) ~(on_emit : string -&gt; unit)     (f : unit -&gt; a) : a =   let rec drive (st : a paused) (inputs : user_action list) : a =     match st with     | Done a -&gt; a     | Awaiting {feed} -&gt;       (match inputs with        | [] -&gt; failwith "run_script: no more inputs"        | u :: us -&gt; drive (feed u) us)   in   drive (step ~on_emit f) inputs</code></p>
<p>In a real GUI, you keep the current <code>paused</code> state in a
mutable cell. On each incoming event <code>u</code>, if the script is
<code>Awaiting {feed}</code>, you update the state to
<code>feed u</code>; if the script is <code>Done _</code>, you stop.
This also gives a simple form of <strong>cancellation</strong>: to
cancel a running script “from the outside”, you overwrite the stored
state (dropping the continuation) and stop feeding it inputs.</p>
<p>Here is the basic shape of such a driver loop:</p>
<p>```ocaml skip (* This snippet uses paint_forever defined below. See
chapter10.ml for a runnable version. *) let st : unit paused ref = ref
(step ~on_emit:(fun _ -&gt; ()) paint_forever)</p>
<p>let on_user_action (u : user_action) = match !st with | Done () -&gt;
() | Awaiting {feed} -&gt; st := feed u</p>
<pre><code>
#### Example: “Click-and-Drag” in Direct Style

We can now write staged logic as straightforward recursion:

```ocaml env=ch10
let is_down = function
  | Button (x, y, true, _) -&gt; Some (x, y)
  | _ -&gt; None

let is_move = function
  | MouseMove (x, y) -&gt; Some (x, y)
  | _ -&gt; None

let is_up = function
  | Button (_, _, false, _) -&gt; Some ()
  | _ -&gt; None

let rec drag_loop acc =
  match await_either is_move is_up with
  | `A p -&gt;
    let acc = p :: acc in
    emit (Printf.sprintf &quot;polyline points=%d&quot; (List.length acc));
    drag_loop acc
  | `B () -&gt;
    List.rev acc

let paint_once () =
  let start = await is_down in
  emit &quot;start&quot;;
  let path = drag_loop [start] in
  emit (Printf.sprintf &quot;done, points=%d&quot; (List.length path));
  path</code></pre>
<p>This is the same idea as the old “flow” construction, but in OCaml 5
direct style: the code reads like a state machine, yet it is still
<em>interpretable</em>. The script <code>paint_once</code> does not
commit to any particular GUI framework: it only commits to “there exists
some source of <code>user_action</code>s and some place to send
outputs”.</p>
<p>Looping a flow is now just recursion:</p>
<p><code>ocaml env=ch10 let rec paint_forever () =   ignore (paint_once ());   paint_forever ()</code></p>
<p>Because each <code>await</code> suspends until a <em>future</em>
input is fed to the script, each new iteration automatically starts
“after” the previous one (you do not need a special <code>repeat</code>
combinator to get the timing right).</p>
<p>One practical tip (mirroring the “flows and state” warning from the
monadic version): keep the script itself as a thunk
<code>unit -&gt; _</code>, and run it <em>inside</em> a handler/driver.
If you accidentally <em>call</em> it while <em>building</em> a larger
structure, you may trigger effects too early (or outside any
handler).</p>
<h3 id="summary-1">10.8 Summary</h3>
<p>This chapter explored a progression of techniques for handling change
and interaction in functional programming.</p>
<p><strong>Zippers</strong> make “where am I in the structure?”
explicit, by representing a location as <em>context + focused
subtree</em>. This turns local navigation and rewriting problems (like
our algebraic manipulation example) into simple, efficient code.</p>
<p><strong>Incremental computing</strong> makes “what depends on what?”
explicit, by building a dependency graph behind the scenes. You write
normal-looking code; the system tracks dependencies and recomputes only
what is necessary after an update. We compared two modern OCaml
libraries:</p>
<ul>
<li><code>Lwd</code>: lightweight, pull-based sampling, explicit
resource lifetimes (<code>prim</code> acquire/release); a good fit for
reactive view trees.</li>
<li><code>Incremental</code>: stabilization-based recomputation with
cutoffs and rich observer tooling; a good fit for large DAGs and complex
dependency structure.</li>
</ul>
<p><strong>Functional Reactive Programming (FRP)</strong> adds the time
dimension. We modernized the standard vocabulary (behaviors, events,
signals), emphasized causality and glitch freedom, and kept a
stream-based implementation that makes time explicit.</p>
<p><strong>Direct control with effects</strong> complements FRP: many
interactions are staged state machines. With algebraic effects (Chapter
9), we can write reactive “scripts” in direct style (<code>await</code>,
<code>race</code>, …) and interpret them with different handlers (real
GUI loop, replayed test script, simulation).</p>
<p>A note on practice: OCaml UI and dataflow systems today often embed
an incremental engine under the hood (<code>Lwd</code>, or
<code>Incremental</code> via frameworks like Bonsai). Even without
adopting a full FRP framework, the core ideas transfer: choose a clear
update-step boundary, keep effectful input/output at the edge, and make
dependencies explicit so the runtime can do less work.</p>
<h3 id="exercises-7">10.9 Exercises</h3>
<p><strong>Exercise 1.</strong> Extend the context rewriting “pull out
subexpression” example to include <code>-</code> and <code>/</code>.
Remember: they are not commutative.</p>
<p><strong>Exercise 2.</strong> Implement a simple text editor
zipper:</p>
<ol type="1">
<li>Define a type for a text buffer as a zipper over characters, with
the cursor position represented by the split between left context and
right content.</li>
<li>Implement <code>insert_char</code>, <code>delete_char</code>,
<code>move_left</code>, <code>move_right</code>,
<code>move_to_start</code>, and <code>move_to_end</code>
operations.</li>
<li>Add word-based movement: <code>move_word_left</code> and
<code>move_word_right</code>.</li>
</ol>
<p><strong>Exercise 3.</strong> Add the following features to the paddle
game example:</p>
<ol type="1">
<li>Score keeping: increment score when the ball bounces off the
paddle</li>
<li>Game over: detect when the ball falls below the paddle</li>
<li>Restart: press a key to restart after game over</li>
<li>Speed increase: gradually increase ball speed as the game
progresses</li>
</ol>
<p><strong>Exercise 4.</strong> Our numerical integration function uses
the rectangle rule (left endpoint). Implement and compare:</p>
<ol type="1">
<li>The midpoint rule: <span class="math inline">\int_a^b f(x)dx \approx
(b-a) \cdot f\left(\frac{a+b}{2}\right)</span></li>
<li>The trapezoidal rule: <span class="math inline">\int_a^b f(x)dx
\approx (b-a) \cdot \frac{f(a) + f(b)}{2}</span></li>
<li>Simpson’s rule: <span class="math inline">\int_a^b f(x)dx \approx
\frac{b-a}{6} \left( f(a) + 4f\left(\frac{a+b}{2}\right) + f(b)
\right)</span></li>
</ol>
<p>Test the accuracy by integrating <span
class="math inline">\sin(x)</span> from 0 to <span
class="math inline">\pi</span> (exact answer: 2).</p>
<p><strong>Exercise 5.</strong> Implement <code>switch</code> and
<code>until</code> for the stream-based FRP system:</p>
<ul>
<li><code>switch : 'a behavior -&gt; 'a behavior event -&gt; 'a behavior</code>
– behaves as the most recent behavior from events</li>
<li><code>until : 'a behavior -&gt; 'a behavior event -&gt; 'a behavior</code>
– switches once on the first event</li>
</ul>
<p><strong>Exercise 6.</strong> Implement a <code>debounce</code>
combinator for events:</p>
<pre><code>val debounce : float -&gt; &#39;a event -&gt; &#39;a event</code></pre>
<p>The debounced event only fires if the original event has not fired
for the specified time interval. This is useful for handling rapid user
input like typing. Example: throttling API requests for auto-complete in
a text field.</p>
<p><strong>Exercise 7.</strong> Build a tiny “spreadsheet” with either
<code>Lwd</code> or <code>Incremental</code>: cells are variables; other
cells are formulas over them. Measure how much recomputation happens
when you update a single input cell.</p>
<p><strong>Exercise 8.</strong> Using <code>Lwd.join</code> (or
<code>Incremental.bind</code>), build a reactive computation with
<em>dynamic dependencies</em> (e.g. a toggle that chooses which subgraph
is active). Explain what should be recomputed when the toggle flips.</p>
<p><strong>Exercise 9.</strong> Extend the effect-based interface in
Section 10.7 with timeouts. Add a new input action
<code>Tick of float</code> (or reuse the <code>time</code> idea from
earlier sections) and implement:</p>
<p><code>ocaml skip val await_timeout : deadline:float -&gt; (user_action -&gt; 'a option) -&gt; 'a option</code></p>
<p>The function should return <code>Some v</code> if the awaited action
happens before the deadline, and <code>None</code> otherwise. Write a
small scripted test with <code>run_script</code>.</p>
<p><strong>Exercise 10.</strong> Implement <code>parallel</code> for
effect-based flows:</p>
<pre><code>val parallel : (unit -&gt; &#39;a) list -&gt; &#39;a list</code></pre>
<p>This should run multiple flows concurrently and collect their
results. Think about: - How do you handle flows that await events? -
What happens if one flow fails? - How do you handle cancellation?</p>
<p><strong>Exercise 11.</strong> The FRP implementations in this chapter
handle time as wall-clock time from <code>Unix.gettimeofday</code>.
Implement a version with <em>virtual time</em> that can be controlled
programmatically: 1. Create a <code>Clock</code> module with
<code>advance : float -&gt; unit</code> and
<code>now : unit -&gt; float</code> functions 2. Modify the integration
function to use virtual time 3. Write tests that use virtual time to
verify physics behavior deterministically</p>
<p><strong>Exercise 12.</strong> Compare the memory characteristics of
the three FRP approaches: 1. Create a benchmark that builds a dependency
graph with N nodes 2. Measure memory usage for each approach
(stream-based, Lwd-based, effect-based) 3. Measure update time when one
input changes 4. Plot the results and explain the tradeoffs</p>
<h2 id="chapter-11-the-expression-problem">Chapter 11: The Expression
Problem</h2>
<p><strong>In this chapter, you will:</strong></p>
<ul>
<li>Understand the expression problem and why it matters for evolving
codebases</li>
<li>Compare extensibility trade-offs across ADTs, objects, and variants
in OCaml</li>
<li>Learn how polymorphic variants and recursive modules enable modular
extension</li>
<li>Build a practical capstone: parser combinators (including dynamic
loading)</li>
</ul>
<p>This chapter explores <strong>the expression problem</strong>, a
classic challenge in software engineering that addresses how to design
systems that can be extended with both new data variants and new
operations without modifying existing code, while maintaining static
type safety. The expression problem lies at the heart of code
organization, extensibility, and reuse, so understanding the various
solutions helps us write more maintainable and flexible software.</p>
<p>We will examine multiple approaches in OCaml, ranging from algebraic
data types through object-oriented programming to polymorphic variants
with recursive modules. Each approach has different trade-offs in terms
of type safety, code organization, and ease of use. The chapter
concludes with a practical application: parser combinators with dynamic
code loading, demonstrating how these techniques apply to real-world
problems.</p>
<h3 id="the-expression-problem-definition">11.1 The Expression Problem:
Definition</h3>
<p>The <strong>Expression Problem</strong> concerns the design of an
implementation for expressions where:</p>
<ul>
<li><strong>Datatype extensibility</strong>: New variants of expressions
can be added</li>
<li><strong>Functional extensibility</strong>: New operations on
expressions can be added</li>
</ul>
<p>By <em>extensibility</em> we mean three conditions:</p>
<ol type="1">
<li><strong>Code-level modularization</strong>: The new datatype
variants and new operations are in separate files</li>
<li><strong>Separate compilation</strong>: The files can be compiled and
distributed separately</li>
<li><strong>Static type safety</strong>: We do not lose type checking
help and guarantees</li>
</ol>
<p>The name comes from a classic example: extending a language of
expressions with new constructs. Consider two sub-languages:</p>
<ul>
<li><strong>Lambda calculus</strong>: variables <code>Var</code>, <span
class="math inline">\lambda</span>-abstractions <code>Abs</code>,
function applications <code>App</code></li>
<li><strong>Arithmetic</strong>: variables <code>Var</code>, constants
<code>Num</code>, addition <code>Add</code>, multiplication
<code>Mult</code></li>
</ul>
<p>And operations we want to support:</p>
<ul>
<li>Evaluation <code>eval</code></li>
<li>Pretty-printing to strings <code>string_of</code></li>
<li>Free variables computation <code>free_vars</code></li>
</ul>
<p>The challenge is to combine these sub-languages and add new
operations without breaking existing code or sacrificing type safety.
This is a fundamental tension in programming language design: functional
languages typically make it easy to add new operations (just write a new
function with pattern matching), while object-oriented languages
typically make it easy to add new data variants (just add a new
subclass). Finding a solution that provides both kinds of extensibility
simultaneously, with static type safety and separate compilation, is the
essence of the expression problem.</p>
<h4 id="references">References</h4>
<ul>
<li>Ralf Lammel lectures on MSDN’s Channel 9: <a
href="http://channel9.msdn.com/Shows/Going+Deep/C9-Lectures-Dr-Ralf-Laemmel-Advanced-Functional-Programming-The-Expression-Problem">The
Expression Problem</a>, <a
href="http://channel9.msdn.com/Shows/Going+Deep/C9-Lectures-Dr-Ralf-Lmmel-Advanced-Functional-Programming-Type-Classes">Haskell’s
Type Classes</a></li>
<li>The book <em>Developing Applications with Objective Caml</em>: <a
href="http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora153.html">Comparison
of Modules and Objects</a>, <a
href="http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora154.html">Extending
Components</a></li>
<li><em>Real World OCaml</em>: <a
href="https://realworldocaml.org/v1/en/html/objects.html">Chapter 11:
Objects</a>, <a
href="https://realworldocaml.org/v1/en/html/classes.html">Chapter 12:
Classes</a></li>
<li>Jacques Garrigue’s <a
href="http://www.math.nagoya-u.ac.jp/~garrigue/papers/variant-reuse.ps.gz">Code
reuse through polymorphic variants</a>, and <a
href="http://www.math.nagoya-u.ac.jp/~garrigue/papers/nakata-icfp2006.pdf">Recursive
Modules for Programming</a> with Keiko Nakata</li>
<li><a
href="http://caml.inria.fr/pub/docs/manual-ocaml/extn.html#sec246">Extensible
variant types</a></li>
<li>Graham Hutton’s and Erik Meijer’s <a
href="https://www.cs.nott.ac.uk/~gmh/monparsing.pdf">Monadic Parser
Combinators</a></li>
</ul>
<h3
id="functional-programming-non-solution-ordinary-algebraic-datatypes">11.2
Functional Programming Non-Solution: Ordinary Algebraic Datatypes</h3>
<p>Pattern matching makes <strong>functional extensibility</strong> easy
in functional programming. When we want to add a new operation, we
simply write a new function that pattern-matches on the existing
datatype. However, ensuring <strong>datatype extensibility</strong> is
complicated when using standard variant types, because adding a new
variant requires modifying the type definition and all functions that
pattern-match on it.</p>
<p>For brevity, we place examples in a single file, but the component
type and function definitions are not mutually recursive, so they can be
put in separate modules for separate compilation.</p>
<p><strong>Non-solution penalty points:</strong></p>
<ul>
<li>Functions implemented for a broader language (e.g.,
<code>lexpr_t</code>) cannot be used with a value from a narrower
language (e.g., <code>expr_t</code>). This breaks the intuition that a
smaller language should be usable wherever a larger one is
expected.</li>
<li>Significant memory (and some time) overhead due to <em>tagging</em>:
the work of the <code>wrap</code> and <code>unwrap</code> functions,
adding tags such as <code>Lambda</code> and <code>Expr</code> to
distinguish which sub-language an expression belongs to.</li>
<li>Some code bloat due to tagging. For example, deep pattern matching
needs to be manually unrolled and interspersed with calls to
<code>unwrap</code>, making the code harder to read and maintain.</li>
</ul>
<p><strong>Verdict:</strong> Non-solution, but better than the
extensible variant types-based approach and the direct OOP approach.</p>
<p>Here is the implementation. Note how we use type parameters and
wrap/unwrap functions to achieve a form of extensibility:</p>
<p>```ocaml env=sol1 type var = string (* Variables constitute a
sub-language of its own <em>) (</em> We treat this sub-language slightly
differently – no need for a dedicated variant *)</p>
<p>let eval_var wrap sub (s : var) = try List.assoc s sub with Not_found
-&gt; wrap s</p>
<p>type ’a lambda = (* Here we define the sub-language of
lambda-expressions <em>) VarL of var | Abs of string </em> ’a | App of
’a * ’a</p>
<p>(* During evaluation, we need to freshen variables to avoid capture
<em>) (</em> (mistaking distinct variables with the same name) *) let
gensym = let n = ref 0 in fun () -&gt; incr n; “_” ^ string_of_int
!n</p>
<p>let eval_lambda eval_rec wrap unwrap subst e = match unwrap e with (*
Alternatively, unwrapping could use an exception <em>) | Some (VarL v)
-&gt; eval_var (fun v -&gt; wrap (VarL v)) subst v | Some (App (l1, l2))
-&gt; (</em> but we use the option type as it is safer <em>) let l1’ =
eval_rec subst l1 (</em> and more flexible in this context <em>) and l2’
= eval_rec subst l2 in (</em> Recursive processing returns expression
<em>) (match unwrap l1’ with (</em> of the completed language, we need
<em>) | Some (Abs (s, body)) -&gt; (</em> to unwrap it into the current
sub-language <em>) eval_rec [s, l2’] body (</em> The recursive call is
already wrapped <em>) | _ -&gt; wrap (App (l1’, l2’))) (</em> Wrap into
the completed language <em>) | Some (Abs (s, l1)) -&gt; let s’ = gensym
() in (</em> Rename variable to avoid capture (alpha-equivalence) <em>)
wrap (Abs (s’, eval_rec ((s, wrap (VarL s’))::subst) l1)) | None -&gt; e
(</em> Falling-through when not in the current sub-language *)</p>
<p>type lambda_t = Lambda_t of lambda_t lambda (* Lambdas as the
completed language *)</p>
<p>let rec eval1 subst = (* and the corresponding eval function *)
eval_lambda eval1 (fun e -&gt; Lambda_t e) (fun (Lambda_t e) -&gt; Some
e) subst</p>
<pre><code>
Now we define the arithmetic sub-language:

```ocaml env=sol1
type &#39;a expr =  (* The sub-language of arithmetic expressions *)
  VarE of var | Num of int | Add of &#39;a * &#39;a | Mult of &#39;a * &#39;a

let eval_expr eval_rec wrap unwrap subst e =
  match unwrap e with
  | Some (Num _) -&gt; e
  | Some (VarE v) -&gt;
    eval_var (fun x -&gt; wrap (VarE x)) subst v
  | Some (Add (m, n)) -&gt;
    let m&#39; = eval_rec subst m
    and n&#39; = eval_rec subst n in
    (match unwrap m&#39;, unwrap n&#39; with  (* Unwrapping to check if the subexpressions *)
    | Some (Num m&#39;), Some (Num n&#39;) -&gt;  (* got computed to values *)
      wrap (Num (m&#39; + n&#39;))
    | _ -&gt; wrap (Add (m&#39;, n&#39;)))  (* Here m&#39; and n&#39; are wrapped *)
  | Some (Mult (m, n)) -&gt;
    let m&#39; = eval_rec subst m
    and n&#39; = eval_rec subst n in
    (match unwrap m&#39;, unwrap n&#39; with
    | Some (Num m&#39;), Some (Num n&#39;) -&gt;
      wrap (Num (m&#39; * n&#39;))
    | _ -&gt; wrap (Mult (m&#39;, n&#39;)))
  | None -&gt; e

type expr_t = Expr_t of expr_t expr  (* Defining arithmetic as the completed lang *)

let rec eval2 subst =  (* aka &quot;tying the recursive knot&quot; *)
  eval_expr eval2
    (fun e -&gt; Expr_t e) (fun (Expr_t e) -&gt; Some e) subst</code></pre>
<p>Finally, we merge the two sub-languages. The key insight is that we
can compose evaluators by using the “fall-through” property: when one
evaluator does not recognize an expression (returning it unchanged via
the <code>None</code> case), we pass it to the next evaluator:</p>
<p>```ocaml env=sol1 type ’a lexpr = (* The language merging
lambda-expressions and arithmetic exprs <em>) Lambda of ’a lambda | Expr
of ’a expr (</em> can also be used in further extensions *)</p>
<p>let eval_lexpr eval_rec wrap unwrap subst e = eval_lambda eval_rec
(fun e -&gt; wrap (Lambda e)) (fun e -&gt; match unwrap e with | Some
(Lambda e) -&gt; Some e | _ -&gt; None) subst (eval_expr eval_rec (* We
use the “fall-through” property of eval_expr <em>) (fun e -&gt; wrap
(Expr e)) (</em> to combine the evaluators *) (fun e -&gt; match unwrap
e with | Some (Expr e) -&gt; Some e | _ -&gt; None) subst e)</p>
<p>type lexpr_t = LExpr_t of lexpr_t lexpr (* Tying the recursive knot
one last time *)</p>
<p>let rec eval3 subst = eval_lexpr eval3 (fun e -&gt; LExpr_t e) (fun
(LExpr_t e) -&gt; Some e) subst</p>
<pre><code>
### 11.3 Lightweight FP Non-Solution: Extensible Variant Types

Exceptions have always formed an extensible variant type in OCaml, whose pattern matching is done using the `try...with` syntax. Since OCaml 4.02, the same mechanism is available for ordinary types via **extensible variant types** (`type t = ..`). This augments the normal function extensibility of FP with straightforward data extensibility, providing a seemingly elegant solution.

The syntax is simple: `type expr = ..` declares an extensible type, and `type expr += Var of string` adds a new variant case to it. This mirrors how exceptions work in OCaml, but for arbitrary types.

**Non-solution penalty points:**

- **Giving up exhaustivity checking**, which is an important aspect of static type safety. The compiler cannot warn you when you forget to handle a case, because new cases can be added at any time.
- More natural with &quot;single inheritance&quot; extension chains, although merging is possible and demonstrated in our example. The sub-languages are not differentiated by types, which is a significant shortcoming.
- Requires &quot;tying the recursive knot&quot; for functions, similar to the previous approach.

**Verdict:** Pleasant-looking, but arguably the worst approach because of possible bugginess. The loss of exhaustivity checking means that bugs from unhandled cases will only be discovered at runtime. However, if bug-proneness is not a concern (e.g., for rapid prototyping), this is actually the most concise approach.

```ocaml env=sol2
type expr = ..  (* This is how extensible variant types are defined *)

type var_name = string
type expr += Var of string  (* We add a variant case *)

let eval_var sub = function
  | Var s as v -&gt; (try List.assoc s sub with Not_found -&gt; v)
  | e -&gt; e

let gensym = let n = ref 0 in fun () -&gt; incr n; &quot;_&quot; ^ string_of_int !n

type expr += Abs of string * expr | App of expr * expr
(* The sub-languages are not differentiated by types,
   a shortcoming of this non-solution *)

let eval_lambda eval_rec subst = function
  | Var _ as v -&gt; eval_var subst v
  | App (l1, l2) -&gt;
    let l2&#39; = eval_rec subst l2 in
    (match eval_rec subst l1 with
    | Abs (s, body) -&gt;
      eval_rec [s, l2&#39;] body
    | l1&#39; -&gt; App (l1&#39;, l2&#39;))
  | Abs (s, l1) -&gt;
    let s&#39; = gensym () in
    Abs (s&#39;, eval_rec ((s, Var s&#39;)::subst) l1)
  | e -&gt; e

let freevars_lambda freevars_rec = function
  | Var v -&gt; [v]
  | App (l1, l2) -&gt; freevars_rec l1 @ freevars_rec l2
  | Abs (s, l1) -&gt;
    List.filter (fun v -&gt; v &lt;&gt; s) (freevars_rec l1)
  | _ -&gt; []

let rec eval1 subst e = eval_lambda eval1 subst e
let rec freevars1 e = freevars_lambda freevars1 e

let test1 = App (Abs (&quot;x&quot;, Var &quot;x&quot;), Var &quot;y&quot;)
let e_test = eval1 [] test1
let fv_test = freevars1 test1</code></pre>
<p>Now we extend with arithmetic:</p>
<p>```ocaml env=sol2 type expr += Num of int | Add of expr * expr | Mult
of expr * expr</p>
<p>let map_expr f = function | Add (e1, e2) -&gt; Add (f e1, f e2) |
Mult (e1, e2) -&gt; Mult (f e1, f e2) | e -&gt; e</p>
<p>let eval_expr eval_rec subst e = match map_expr (eval_rec subst) e
with | Add (Num m, Num n) -&gt; Num (m + n) | Mult (Num m, Num n) -&gt;
Num (m * n) | (Num _ | Add _ | Mult _) as e -&gt; e | e -&gt; e</p>
<p>let freevars_expr freevars_rec = function | Num _ -&gt; [] | Add (e1,
e2) | Mult (e1, e2) -&gt; freevars_rec e1 @ freevars_rec e2 | _ -&gt;
[]</p>
<p>let rec eval2 subst e = eval_expr eval2 subst e let rec freevars2 e =
freevars_expr freevars2 e</p>
<p>let test2 = Add (Mult (Num 3, Var “x”), Num 1) let e_test2 = eval2 []
test2 let fv_test2 = freevars2 test2</p>
<pre><code>
Merging the sub-languages:

```ocaml env=sol2
let eval_lexpr eval_rec subst e =
  eval_expr eval_rec subst (eval_lambda eval_rec subst e)

let freevars_lexpr freevars_rec e =
  freevars_lambda freevars_rec e @ freevars_expr freevars_rec e

let rec eval3 subst e = eval_lexpr eval3 subst e
let rec freevars3 e = freevars_lexpr freevars3 e

let test3 =
  App (Abs (&quot;x&quot;, Add (Mult (Num 3, Var &quot;x&quot;), Num 1)),
       Num 2)
let e_test3 = eval3 [] test3
let fv_test3 = freevars3 test3</code></pre>
<h3 id="object-oriented-programming-subtyping">11.4 Object-Oriented
Programming: Subtyping</h3>
<p>Before examining OOP solutions to the expression problem, let us
understand OCaml’s object system.</p>
<p>OCaml’s <strong>objects</strong> are values, somewhat similar to
records. Viewed from the outside, an OCaml object has only
<strong>methods</strong>, identifying the code with which to respond to
messages (method invocations). All methods are
<strong>late-bound</strong>; the object determines what code is run
(i.e., <em>virtual</em> in C++ parlance). This is in contrast to
records, where field access is resolved at compile time.</p>
<p><strong>Subtyping</strong> determines if an object can be used in
some context. OCaml has <strong>structural subtyping</strong>: the
content of the types concerned (the methods they provide) decides if an
object can be used, not the name of the type or class. Parametric
polymorphism can be used to infer if an object has the required
methods.</p>
<p><code>ocaml env=oop_intro let f x = x#m  (* Method invocation: object#method *) (* val f : &lt; m : 'a; .. &gt; -&gt; 'a *) (* Type polymorphic in two ways: 'a is the method type, *) (* .. means that objects with more methods will be accepted *)</code></p>
<p>Methods are computed when they are invoked, even if they do not take
arguments (unlike record fields, which are computed once when the record
is created). We define objects inside <code>object...end</code>
(compare: records <code>{...}</code>) using keywords:</p>
<ul>
<li><code>method</code> for methods (always late-bound)</li>
<li><code>val</code> for constant fields (only accessible within the
object)</li>
<li><code>val mutable</code> for mutable fields</li>
</ul>
<p>Constructor arguments can often be used instead of constant fields.
Here is a simple example:</p>
<p><code>ocaml env=oop_intro let square w = object   method area = float_of_int (w * w)   method width = w end</code></p>
<p>Subtyping often needs to be explicit: we write
<code>(object :&gt; supertype)</code> or in more complex cases
<code>(object : type :&gt; supertype)</code>.</p>
<p>Technically speaking, subtyping in OCaml always is explicit, and
<em>open types</em>, containing <code>..</code>, use <strong>row
polymorphism</strong> rather than subtyping.</p>
<p>```ocaml env=oop_intro let a = object method m = 7 method x = “a” end
(* Toy example: object types <em>) let b = object method m = 42 method y
= “b” end (</em> share some but not all methods *)</p>
<p>(* let l = [a; b] – Error: the exact types of the objects do not
agree <em>) (</em> Error: This expression has type &lt; m : int; y :
string &gt; but an expression was expected of type &lt; m : int; x :
string &gt; The second object type has no method y *)</p>
<p>let l = [(a :&gt; &lt;m : ’a&gt;); (b :&gt; &lt;m : ’a&gt;)] (* But
the types share a supertype <em>) (</em> val l : &lt; m : int &gt; list
*)</p>
<pre><code>
#### Object-Oriented Programming: Inheritance

The system of object classes in OCaml is similar to the module system. Object classes are not types; rather, classes are a way to build object *constructors*, which are functions that return objects. Classes have their types, called class types (compare: modules and signatures).

In OCaml parlance:

- **Late binding** is not called anything special, since all methods are late-bound (called *virtual* in C++)
- A method or field declared to be defined in sub-classes is called **virtual** (called *abstract* in C++); classes that use virtual methods or fields are also called virtual
- A method that is only visible in sub-classes is called **private** (called *protected* in C++)
- A method not visible outside the class is achieved by omitting it from the class type (called *private* in C++) -- you provide the type for the class and omit the method in the class type, similar to module signatures and `.mli` files

OCaml allows **multiple inheritance**, which can be used to implement *mixins* as virtual/abstract classes. Inheritance works somewhat similarly to textual inclusion: the inherited class&#39;s methods and fields are copied into the inheriting class, but with late binding preserved.

The `{&lt; ... &gt;}` syntax creates a *clone* of the current object with some fields changed. This is essential for functional-style object programming, where we create new objects rather than mutating existing ones.

### 11.5 Direct Object-Oriented Non-Solution

It turns out that although object-oriented programming was designed with data extensibility in mind, it is a bad fit for recursive types like those in the expression problem. Below is an attempt at solving our problem using classes.

We can try to solve the expression problem using objects directly. However, adding new functionality still requires modifying old code, so this approach does not fully solve the expression problem.

**Non-solution penalty points:**

- No way to add functionality without modifying old code (in particular, the abstract class and all concrete classes must be extended with new methods)
- Functions implemented for a broader language cannot handle values from a narrower one
- No deep pattern matching: we cannot examine the structure of nested expressions

**Verdict:** Non-solution, and probably the worst approach.

Here is an implementation using objects. The abstract class `evaluable` defines the interface that all expression objects must implement. For lambda calculus, we need helper methods: `rename` for renaming free variables (needed for alpha-conversion), and `apply` for beta-reduction when possible:

```ocaml env=sol3
type var_name = string

let gensym = let n = ref 0 in fun () -&gt; incr n; &quot;_&quot; ^ string_of_int !n

class virtual [&#39;lang] evaluable =
object
  method virtual eval : (var_name * &#39;lang) list -&gt; &#39;lang
  method virtual rename : var_name -&gt; var_name -&gt; &#39;lang
  method apply (_arg : &#39;lang)
    (fallback : unit -&gt; &#39;lang) (_subst : (var_name * &#39;lang) list) =
    fallback ()
end

class [&#39;lang] var (v : var_name) =
object (self)  (* We name the current object `self` for later reference *)
  inherit [&#39;lang] evaluable
  val v = v
  method eval subst =
    try List.assoc v subst with Not_found -&gt; self
  method rename v1 v2 =  (* Renaming a variable: *)
    if v = v1 then {&lt; v = v2 &gt;} else self  (* clone with new name if matched *)
end

class [&#39;lang] abs (v : var_name) (body : &#39;lang) =
object (self)
  inherit [&#39;lang] evaluable
  val v = v
  val body = body
  method eval subst =  (* We do alpha-conversion prior to evaluation *)
    let v&#39; = gensym () in  (* Generate fresh name to avoid capture *)
    {&lt; v = v&#39;; body = (body#rename v v&#39;)#eval subst &gt;}
  method rename v1 v2 =  (* Renaming the free variable v1 *)
    if v = v1 then self  (* If v=v1, then v1 is bound here, not free -- no work *)
    else {&lt; body = body#rename v1 v2 &gt;}
  method apply arg _ subst =  (* Beta-reduction: substitute arg for v in body *)
    body#eval ((v, arg)::subst)
end

class [&#39;lang] app (f : &#39;lang) (arg : &#39;lang) =
object (self)
  inherit [&#39;lang] evaluable
  val f = f
  val arg = arg
  method eval subst =  (* We use `apply` to differentiate between f=abs *)
    let arg&#39; = arg#eval subst in  (* (beta-redexes) and f&lt;&gt;abs *)
    f#apply arg&#39; (fun () -&gt; {&lt; f = f#eval subst; arg = arg&#39; &gt;}) subst
  method rename v1 v2 =  (* Cloning ensures result is subtype of &#39;lang *)
    {&lt; f = f#rename v1 v2; arg = arg#rename v1 v2 &gt;}  (* not just &#39;lang app *)
end

type evaluable_t = evaluable_t evaluable
let new_var1 v : evaluable_t = new var v
let new_abs1 v (body : evaluable_t) : evaluable_t = new abs v body
let new_app1 (arg1 : evaluable_t) (arg2 : evaluable_t) : evaluable_t =
  new app arg1 arg2

let test1 = new_app1 (new_abs1 &quot;x&quot; (new_var1 &quot;x&quot;)) (new_var1 &quot;y&quot;)
let e_test1 = test1#eval []</code></pre>
<p>Extending with arithmetic requires additional mixins. To use
lambda-expressions together with arithmetic expressions, we need to
upgrade them with a helper method <code>compute</code> that returns the
numeric value if one exists:</p>
<p>```ocaml env=sol3 class virtual compute_mixin = object method compute
: int option = None end</p>
<p>class [’lang] var_c v = object inherit [’lang] var v inherit
compute_mixin end</p>
<p>class [’lang] abs_c v body = object inherit [’lang] abs v body
inherit compute_mixin end</p>
<p>class [’lang] app_c f arg = object inherit [’lang] app f arg inherit
compute_mixin end</p>
<p>class [’lang] num (i : int) = object (self) inherit [’lang] evaluable
val i = i method eval <em>subst = self method rename </em> _ = self
method compute = Some i end</p>
<p>class virtual [’lang] operation (num_inst : int -&gt; ‘lang) (n1 :
’lang) (n2 : ’lang) = object (self) inherit [’lang] evaluable val n1 =
n1 val n2 = n2 method eval subst = let self’ = {&lt; n1 = n1#eval subst;
n2 = n2#eval subst &gt;} in match self’#compute with | Some i -&gt;
num_inst i | _ -&gt; self’ method rename v1 v2 = {&lt; n1 = n1#rename v1
v2; n2 = n2#rename v1 v2 &gt;} end</p>
<p>class [’lang] add num_inst n1 n2 = object (self) inherit [’lang]
operation num_inst n1 n2 method compute = match n1#compute, n2#compute
with | Some i1, Some i2 -&gt; Some (i1 + i2) | _ -&gt; None end</p>
<p>class [’lang] mult num_inst n1 n2 = object (self) inherit [’lang]
operation num_inst n1 n2 method compute = match n1#compute, n2#compute
with | Some i1, Some i2 -&gt; Some (i1 * i2) | _ -&gt; None end</p>
<p>class virtual [’lang] computable = object inherit [’lang] evaluable
inherit compute_mixin end</p>
<p>type computable_t = computable_t computable let new_var2 v :
computable_t = new var_c v let new_abs2 v (body : computable_t) :
computable_t = new abs_c v body let new_app2 v (body : computable_t) :
computable_t = new app_c v body let new_num2 i : computable_t = new num
i let new_add2 (n1 : computable_t) (n2 : computable_t) : computable_t =
new add new_num2 n1 n2 let new_mult2 (n1 : computable_t) (n2 :
computable_t) : computable_t = new mult new_num2 n1 n2</p>
<p>let test2 = new_app2 (new_abs2 “x” (new_add2 (new_mult2 (new_num2 3)
(new_var2 “x”)) (new_num2 1))) (new_num2 2) let e_test2 = test2#eval
[]</p>
<pre><code>
### 11.6 OOP Non-Solution: The Visitor Pattern

The **visitor pattern** is an object-oriented programming pattern for turning objects into variants with shallow pattern-matching (i.e., dispatch based on which variant a value is). It effectively replaces data extensibility with operation extensibility: instead of being able to add new data variants easily, we can add new operations easily.

The key idea is that each data variant has an `accept` method that takes a visitor object and calls the appropriate `visit` method on it. This inverts the usual pattern matching: instead of the function choosing which branch to take based on the data, the data chooses which method to call on the visitor.

**Non-solution penalty points:**

- Adding new functionality requires modifying old code (the abstract visitor class must declare new `visit` methods)
- Heavy code bloat compared to pattern matching
- No deep pattern matching: we can only dispatch on the outermost constructor
- Side-effects appear to be required for returning results (we store computation results in mutable fields because keeping the visitor polymorphic while having the result type depend on the visitor is difficult)

**Verdict:** Poor solution, better than approaches we considered so far, and worse than approaches we consider next.

```ocaml env=sol4
type &#39;visitor visitable = &lt; accept : &#39;visitor -&gt; unit &gt;
(* The variants need be visitable *)
(* We store the computation as side effect because of the difficulty *)
(* to keep the visitor polymorphic but have the result type depend on the visitor *)

type var_name = string

class [&#39;visitor] var (v : var_name) =
object (self)  (* The &#39;visitor will determine the (sub)language *)
               (* to which a given var variant belongs *)
  method v = v
  method accept : &#39;visitor -&gt; unit =  (* The visitor pattern inverts the way *)
    fun visitor -&gt; visitor#visitVar self  (* pattern matching proceeds: *)
end                              (* the variant selects the computation *)
let new_var v = (new var v :&gt; &#39;a visitable)

class [&#39;visitor] abs (v : var_name) (body : &#39;visitor visitable) =
object (self)
  method v = v
  method body = body
  method accept : &#39;visitor -&gt; unit =
    fun visitor -&gt; visitor#visitAbs self
end
let new_abs v body = (new abs v body :&gt; &#39;a visitable)

class [&#39;visitor] app (f : &#39;visitor visitable) (arg : &#39;visitor visitable) =
object (self)
  method f = f
  method arg = arg
  method accept : &#39;visitor -&gt; unit =
    fun visitor -&gt; visitor#visitApp self
end
let new_app f arg = (new app f arg :&gt; &#39;a visitable)

class virtual [&#39;visitor] lambda_visit =
object
  method virtual visitVar : &#39;visitor var -&gt; unit
  method virtual visitAbs : &#39;visitor abs -&gt; unit
  method virtual visitApp : &#39;visitor app -&gt; unit
end

let gensym = let n = ref 0 in fun () -&gt; incr n; &quot;_&quot; ^ string_of_int !n

class [&#39;visitor] eval_lambda
  (subst : (var_name * &#39;visitor visitable) list)
  (result : &#39;visitor visitable ref) =
object (self)
  inherit [&#39;visitor] lambda_visit
  val mutable subst = subst
  val mutable beta_redex : (var_name * &#39;visitor visitable) option = None
  method visitVar var =
    beta_redex &lt;- None;
    try result := List.assoc var#v subst
    with Not_found -&gt; result := (var :&gt; &#39;visitor visitable)
  method visitAbs abs =
    let v&#39; = gensym () in
    let orig_subst = subst in
    subst &lt;- (abs#v, new_var v&#39;)::subst;
    (abs#body)#accept self;
    let body&#39; = !result in
    subst &lt;- orig_subst;
    beta_redex &lt;- Some (v&#39;, body&#39;);
    result := new_abs v&#39; body&#39;
  method visitApp app =
    app#arg#accept self;
    let arg&#39; = !result in
    app#f#accept self;
    let f&#39; = !result in
    match beta_redex with
    | Some (v&#39;, body&#39;) -&gt;
      beta_redex &lt;- None;
      let orig_subst = subst in
      subst &lt;- (v&#39;, arg&#39;)::subst;
      body&#39;#accept self;
      subst &lt;- orig_subst
    | None -&gt; result := new_app f&#39; arg&#39;
end

class [&#39;visitor] freevars_lambda (result : var_name list ref) =
object (self)
  inherit [&#39;visitor] lambda_visit
  method visitVar var =
    result := var#v :: !result
  method visitAbs abs =
    (abs#body)#accept self;
    result := List.filter (fun v&#39; -&gt; v&#39; &lt;&gt; abs#v) !result
  method visitApp app =
    app#arg#accept self; app#f#accept self
end

type lambda_visit_t = lambda_visit_t lambda_visit
type lambda_t = lambda_visit_t visitable

let eval1 (e : lambda_t) subst : lambda_t =
  let result = ref (new_var &quot;&quot;) in
  e#accept (new eval_lambda subst result :&gt; lambda_visit_t);
  !result

let freevars1 (e : lambda_t) =
  let result = ref [] in
  e#accept (new freevars_lambda result);
  !result

let test1 =
  (new_app (new_abs &quot;x&quot; (new_var &quot;x&quot;)) (new_var &quot;y&quot;) :&gt; lambda_t)
let e_test = eval1 test1 []
let fv_test = freevars1 test1</code></pre>
<p>Extending with arithmetic expressions follows a similar pattern, and
the merged language visitor inherits from both <code>lambda_visit</code>
and <code>expr_visit</code>.</p>
<h3 id="polymorphic-variants">11.7 Polymorphic Variants</h3>
<p><strong>Polymorphic variants</strong> provide a flexible alternative
to standard variants. They are to ordinary variants as objects are to
records: both enable <em>open types</em> and subtyping, both allow
different types to share the same components.</p>
<p>Interestingly, they are <em>dual</em> concepts: if we replace
“product” of records/objects by “sum” (as we discussed in earlier
chapters), we get variants/polymorphic variants. This duality implies
many behaviors are opposite. For example:</p>
<ul>
<li>While object subtypes have <em>more</em> methods, polymorphic
variant subtypes have <em>fewer</em> tags</li>
<li>The <code>&gt;</code> sign means “these tags or more” (open for
adding tags)</li>
<li>The <code>&lt;</code> sign means “these tags or less” (closed to
these tags only)</li>
<li>No sign means a closed type</li>
</ul>
<p>Because distinct polymorphic variant types can share the same tags,
the solution to the Expression Problem becomes straightforward: we can
define sub-languages with overlapping tags and compose them.</p>
<p><strong>Penalty points:</strong></p>
<ul>
<li>Requires explicit type annotations more often than regular
variants</li>
<li>Requires “tying the recursive knots” for types, e.g.,
<code>type lambda_t = lambda_t lambda</code></li>
<li>The need to tie the recursive knot separately at both the type level
and the function level. At the function level, an eta-expansion is
sometimes required due to the <em>value recursion</em> problem</li>
<li>There can be a slight time cost compared to the visitor pattern:
additional dispatch at each level of type aggregation (i.e., merging
sub-languages)</li>
</ul>
<p><strong>Verdict:</strong> A flexible and concise solution,
second-best place overall.</p>
<p>``<code>ocaml env=sol5 type var = [</code>Var of string]</p>
<p>let eval_var sub (`Var s as v : var) = try List.assoc s sub with
Not_found -&gt; v</p>
<p>type ’a lambda = [<code>Var of string |</code>Abs of string * ’a |
`App of ’a * ’a]</p>
<p>let gensym = let n = ref 0 in fun () -&gt; incr n; “_” ^
string_of_int !n</p>
<p>let eval_lambda eval_rec subst : ’a lambda -&gt; ’a = function | #var
as v -&gt; eval_var subst v (* We could also leave the type open *) |
<code>App (l1, l2) -&gt;               (* rather than closing it to</code>lambda<code>*)     let l2' = eval_rec subst l2 in     (match eval_rec subst l1 with     |</code>Abs
(s, body) -&gt; eval_rec [s, l2’] body | l1’ -&gt;
<code>App (l1', l2'))   |</code>Abs (s, l1) -&gt; let s’ = gensym () in
<code>Abs (s', eval_rec ((s,</code>Var s’)::subst) l1)</p>
<p>let freevars_lambda freevars_rec : ’a lambda -&gt; ’b = function |
<code>Var v -&gt; [v]   |</code>App (l1, l2) -&gt; freevars_rec l1 @
freevars_rec l2 | `Abs (s, l1) -&gt; List.filter (fun v -&gt; v &lt;&gt;
s) (freevars_rec l1)</p>
<p>type lambda_t = lambda_t lambda</p>
<p>let rec eval1 subst e : lambda_t = eval_lambda eval1 subst e let rec
freevars1 (e : lambda_t) = freevars_lambda freevars1 e</p>
<p>let test1 = (<code>App (</code>Abs (“x”, <code>Var "x"),</code>Var
“y”) :&gt; lambda_t) let e_test = eval1 [] test1 let fv_test = freevars1
test1</p>
<pre><code>
The arithmetic expression sub-language:

```ocaml env=sol5
type &#39;a expr =
  [`Var of string | `Num of int | `Add of &#39;a * &#39;a | `Mult of &#39;a * &#39;a]

let map_expr (f : _ -&gt; &#39;a) : &#39;a expr -&gt; &#39;a = function
  | #var as v -&gt; v
  | `Num _ as n -&gt; n
  | `Add (e1, e2) -&gt; `Add (f e1, f e2)
  | `Mult (e1, e2) -&gt; `Mult (f e1, f e2)

let eval_expr eval_rec subst (e : &#39;a expr) : &#39;a =
  match map_expr (eval_rec subst) e with
  | #var as v -&gt; eval_var subst v  (* Here and elsewhere, we could also *)
  | `Add (`Num m, `Num n) -&gt; `Num (m + n)  (* factor-out the sub-language *)
  | `Mult (`Num m, `Num n) -&gt; `Num (m * n)  (* of variables *)
  | e -&gt; e

let freevars_expr freevars_rec : &#39;a expr -&gt; &#39;b = function
  | `Var v -&gt; [v]
  | `Num _ -&gt; []
  | `Add (e1, e2) | `Mult (e1, e2) -&gt; freevars_rec e1 @ freevars_rec e2

type expr_t = expr_t expr

let rec eval2 subst e : expr_t = eval_expr eval2 subst e
let rec freevars2 (e : expr_t) = freevars_expr freevars2 e

let test2 = (`Add (`Mult (`Num 3, `Var &quot;x&quot;), `Num 1) : expr_t)
let e_test2 = eval2 [&quot;x&quot;, `Num 2] test2
let fv_test2 = freevars2 test2</code></pre>
<p>Merging the sub-languages:</p>
<p>```ocaml env=sol5 type ’a lexpr = [’a lambda | ’a expr]</p>
<p>let eval_lexpr eval_rec subst : ’a lexpr -&gt; ’a = function |
#lambda as x -&gt; eval_lambda eval_rec subst x | #expr as x -&gt;
eval_expr eval_rec subst x</p>
<p>let freevars_lexpr freevars_rec : ’a lexpr -&gt; ’b = function |
#lambda as x -&gt; freevars_lambda freevars_rec x | #expr as x -&gt;
freevars_expr freevars_rec x</p>
<p>type lexpr_t = lexpr_t lexpr</p>
<p>let rec eval3 subst e : lexpr_t = eval_lexpr eval3 subst e let rec
freevars3 (e : lexpr_t) = freevars_lexpr freevars3 e</p>
<p>let test3 = (<code>App (</code>Abs (“x”, <code>Add (</code>Mult
(<code>Num 3,</code>Var “x”), <code>Num 1)),</code>Num 2) : lexpr_t) let
e_test3 = eval3 [] test3 let fv_test3 = freevars3 test3 let e_old_test =
eval3 [] (test2 :&gt; lexpr_t) let fv_old_test = freevars3 (test2 :&gt;
lexpr_t)</p>
<pre><code>
### 11.8 Polymorphic Variants with Recursive Modules

Using recursive modules, we can clean up the confusing or cluttering aspects of tying the recursive knots: type variables and recursive call arguments. The module system handles the recursion for us, making the code cleaner and more modular.

We need **private types**, which for objects and polymorphic variants means *private rows*. We can conceive of open row types, e.g., `[&gt; \`Int of int | \`String of string]` as using a *row variable*, e.g., `&#39;a`:
</code></pre>
<p>[<code>Int of int |</code>String of string | ’a]</p>
<pre><code>
and then of private row types as abstracting the row variable:
</code></pre>
<p>type ’row t = [<code>Int of int |</code>String of string | ’row]</p>
<pre><code>
But the actual formalization of private row types is more complex. The key point is that private row types allow us to specify that a type is &quot;at least&quot; a certain set of variants, while still being extensible.

**Penalty points:**

- We still need to tie the recursive knots for types, for example `private [&gt; &#39;a lambda] as &#39;a`
- There can be slight time costs due to the use of functors and dispatch on merging of sub-languages

**Verdict:** A clean solution, best place. The recursive module approach is the most elegant solution we have seen so far.

```ocaml env=sol6
type var = [`Var of string]

let eval_var subst (`Var s as v : var) =
  try List.assoc s subst with Not_found -&gt; v

type &#39;a lambda =
  [`Var of string | `Abs of string * &#39;a | `App of &#39;a * &#39;a]

module type Eval =
sig type exp val eval : (string * exp) list -&gt; exp -&gt; exp end

module LF(X : Eval with type exp = private [&gt; &#39;a lambda] as &#39;a) =
struct
  type exp = X.exp lambda

  let gensym = let n = ref 0 in fun () -&gt; incr n; &quot;_&quot; ^ string_of_int !n

  let eval subst : exp -&gt; X.exp = function
    | #var as v -&gt; eval_var subst v
    | `App (l1, l2) -&gt;
      let l2&#39; = X.eval subst l2 in
      (match X.eval subst l1 with
      | `Abs (s, body) -&gt;
        X.eval [s, l2&#39;] body
      | l1&#39; -&gt; `App (l1&#39;, l2&#39;))
    | `Abs (s, l1) -&gt;
      let s&#39; = gensym () in
      `Abs (s&#39;, X.eval ((s, `Var s&#39;)::subst) l1)
end
module rec Lambda : (Eval with type exp = Lambda.exp lambda) =
  LF(Lambda)

module type FreeVars =
sig type exp val freevars : exp -&gt; string list end

module LFVF(X : FreeVars with type exp = private [&gt; &#39;a lambda] as &#39;a) =
struct
  type exp = X.exp lambda

  let freevars : exp -&gt; &#39;b = function
    | `Var v -&gt; [v]
    | `App (l1, l2) -&gt; X.freevars l1 @ X.freevars l2
    | `Abs (s, l1) -&gt;
      List.filter (fun v -&gt; v &lt;&gt; s) (X.freevars l1)
end
module rec LambdaFV : (FreeVars with type exp = LambdaFV.exp lambda) =
  LFVF(LambdaFV)

let test1 = (`App (`Abs (&quot;x&quot;, `Var &quot;x&quot;), `Var &quot;y&quot;) : Lambda.exp)
let e_test = Lambda.eval [] test1
let fv_test = LambdaFV.freevars test1</code></pre>
<p>The arithmetic expression sub-language:</p>
<p>``<code>ocaml env=sol6 type 'a expr =   [</code>Var of string |
<code>Num of int |</code>Add of ’a * ’a | `Mult of ’a * ’a]</p>
<p>module type Operations = sig include Eval include FreeVars with type
exp := exp end</p>
<p>module EF(X : Operations with type exp = private [&gt; ’a expr] as
’a) = struct type exp = X.exp expr</p>
<p>let map_expr f = function | #var as v -&gt; v |
<code>Num _ as n -&gt; n     |</code>Add (e1, e2) -&gt;
<code>Add (f e1, f e2)     |</code>Mult (e1, e2) -&gt; `Mult (f e1, f
e2)</p>
<p>let eval subst (e : exp) : X.exp = match map_expr (X.eval subst) e
with | #var as v -&gt; eval_var subst v | <code>Add (</code>Num m,
<code>Num n) -&gt;</code>Num (m + n) | <code>Mult (</code>Num m,
<code>Num n) -&gt;</code>Num (m * n) | e -&gt; e</p>
<p>let freevars : exp -&gt; ’b = function |
<code>Var v -&gt; [v]     |</code>Num _ -&gt; [] |
<code>Add (e1, e2) |</code>Mult (e1, e2) -&gt; X.freevars e1 @
X.freevars e2 end module rec Expr : (Operations with type exp = Expr.exp
expr) = EF(Expr)</p>
<p>let test2 = (<code>Add (</code>Mult (<code>Num 3,</code>Var “x”),
<code>Num 1) : Expr.exp) let e_test2 = Expr.eval ["x",</code>Num 2]
test2 let fvs_test2 = Expr.freevars test2</p>
<pre><code>
Merging the sub-languages:

```ocaml env=sol6
type &#39;a lexpr = [&#39;a lambda | &#39;a expr]

module LEF(X : Operations with type exp = private [&gt; &#39;a lexpr] as &#39;a) =
struct
  type exp = X.exp lexpr
  module LambdaX = LF(X)
  module LambdaFVX = LFVF(X)
  module ExprX = EF(X)

  let eval subst : exp -&gt; X.exp = function
    | #LambdaX.exp as x -&gt; LambdaX.eval subst x
    | #ExprX.exp as x -&gt; ExprX.eval subst x

  let freevars : exp -&gt; &#39;b = function
    | #lambda as x -&gt; LambdaFVX.freevars x  (* Either of #lambda or #LambdaX.exp ok *)
    | #expr as x -&gt; ExprX.freevars x  (* Either of #expr or #ExprX.exp is fine *)
end
module rec LExpr : (Operations with type exp = LExpr.exp lexpr) =
  LEF(LExpr)

let test3 =
  (`App (`Abs (&quot;x&quot;, `Add (`Mult (`Num 3, `Var &quot;x&quot;), `Num 1)),
         `Num 2) : LExpr.exp)
let e_test3 = LExpr.eval [] test3
let fv_test3 = LExpr.freevars test3
let e_old_test = LExpr.eval [] (test2 :&gt; LExpr.exp)
let fv_old_test = LExpr.freevars (test2 :&gt; LExpr.exp)</code></pre>
<h3 id="parser-combinators">11.9 Parser Combinators</h3>
<p>We now turn to an application that demonstrates the extensibility
concepts we have been discussing. Large-scale parsing in OCaml is
typically done using external languages like OCamlLex and Menhir, which
generate efficient parsers from grammar specifications. But it is often
convenient to have parsers written directly in OCaml, especially for
smaller grammars or when we want to extend the parser dynamically.</p>
<p>Language <strong>combinators</strong> are ways of defining languages
by composing definitions of smaller languages. This is exactly the kind
of compositional, extensible design we have been exploring with the
expression problem. For example, the combinators of the <strong>Extended
Backus-Naur Form</strong> notation are:</p>
<ul>
<li><strong>Concatenation</strong>: <span class="math inline">S = A,
B</span> stands for <span class="math inline">S = \{ ab \mid a \in A, b
\in B \}</span></li>
<li><strong>Alternation</strong>: <span class="math inline">S = A \mid
B</span> stands for <span class="math inline">S = \{ a \mid a \in A \vee
a \in B \}</span></li>
<li><strong>Option</strong>: <span class="math inline">S = [A]</span>
stands for <span class="math inline">S = \{ \epsilon \} \cup A</span>,
where <span class="math inline">\epsilon</span> is an empty string</li>
<li><strong>Repetition</strong>: <span class="math inline">S = \{ A
\}</span> stands for <span class="math inline">S = \{ \epsilon \} \cup
\{ as \mid a \in A, s \in S \}</span></li>
<li><strong>Terminal string</strong>: <span class="math inline">S =
&quot;a&quot;</span> stands for <span class="math inline">S = \{ a
\}</span></li>
</ul>
<p>Parsers implemented directly in a functional programming paradigm are
functions from character streams to the parsed values. Algorithmically
they are <strong>recursive descent parsers</strong>.</p>
<p><strong>Parser combinators</strong> approach builds parsers as
<strong>monad plus</strong> values:</p>
<ul>
<li><strong>Bind</strong>:
<code>val (&gt;&gt;=) : 'a parser -&gt; ('a -&gt; 'b parser) -&gt; 'b parser</code>
<ul>
<li><code>p &gt;&gt;= f</code> is a parser that first parses
<code>p</code>, and makes the result available for parsing
<code>f</code></li>
</ul></li>
<li><strong>Return</strong>:
<code>val return : 'a -&gt; 'a parser</code>
<ul>
<li><code>return x</code> parses an empty string, symbolically <span
class="math inline">S = \{ \epsilon \}</span>, and returns
<code>x</code></li>
</ul></li>
<li><strong>MZero</strong>: <code>val fail : 'a parser</code>
<ul>
<li><code>fail</code> fails to parse anything, symbolically <span
class="math inline">S = \varnothing = \{ \}</span></li>
</ul></li>
<li><strong>MPlus</strong>:
<code>val (&lt;|&gt;) : 'a parser -&gt; 'a parser -&gt; 'a parser</code>
<ul>
<li><code>p &lt;|&gt; q</code> tries <code>p</code>, and if
<code>p</code> succeeds, its result is returned, otherwise the parser
<code>q</code> is used</li>
</ul></li>
</ul>
<p>The only non-monad-plus operation that has to be built into the monad
is some way to consume a single character from the input stream, for
example:</p>
<ul>
<li><code>val satisfy : (char -&gt; bool) -&gt; char parser</code>
<ul>
<li><code>satisfy (fun c -&gt; c = 'a')</code> consumes the character
“a” from the input stream and returns it; if the input stream starts
with a different character, this parser fails</li>
</ul></li>
</ul>
<p>Ordinary monadic recursive descent parsers <strong>do not
allow</strong> <em>left-recursion</em>: if a cycle of calls not
consuming any character can be entered when a parse failure should
occur, the cycle will keep repeating indefinitely.</p>
<p>For example, if we define numbers <span class="math inline">N := D
\mid N D</span>, where <span class="math inline">D</span> stands for
digits, then a stack of uses of the rule <span class="math inline">N
\rightarrow N D</span> will build up when the next character is not a
digit. The parser will try to match <span class="math inline">N</span>,
which requires matching <span class="math inline">N D</span>, which
requires matching <span class="math inline">N</span> again, leading to
infinite recursion.</p>
<p>On the other hand, rules can share common prefixes, and the
backtracking monad will handle trying alternatives correctly.</p>
<h3 id="parser-combinators-implementation">11.10 Parser Combinators:
Implementation</h3>
<p>The parser monad is actually a composition of two monads:</p>
<ul>
<li>The <strong>state monad</strong> for storing the stream of
characters that remain to be parsed (specifically, the current position
in the input string)</li>
<li>The <strong>backtracking monad</strong> for handling parse failures
and ambiguities (allowing us to try alternatives when one parse
fails)</li>
</ul>
<p>Alternatively, one can split the state monad into a reader monad with
the parsed string, and a state monad with the parsing position. This is
the approach we take here.</p>
<p>We experiment with a different approach to monad-plus:
<strong>lazy-monad-plus</strong>. The difference from regular monad-plus
is that the second argument to <code>mplus</code> is lazy:</p>
<pre><code>val mplus : &#39;a monad -&gt; &#39;a monad Lazy.t -&gt; &#39;a monad</code></pre>
<p>This laziness prevents the second alternative from being evaluated
until it is actually needed, which is important for avoiding infinite
recursion in some parsing scenarios.</p>
<h4 id="implementation-of-lazy-monad-plus">Implementation of
lazy-monad-plus</h4>
<p>First a brief reminder about monads with backtracking. Starting with
an operation from <code>MonadPlusOps</code>:</p>
<p><code>ocaml skip let msum_map f l =   List.fold_left  (* Folding left reverses the apparent order of composition *)     (fun acc a -&gt; mplus acc (lazy (f a))) mzero l  (* order from l is preserved *)</code></p>
<p>The implementation of the lazy-monad-plus using lazy lists:</p>
<p>```ocaml env=parsec type ’a llist = LNil | LCons of ’a * ’a llist
Lazy.t</p>
<p>let rec ltake n = function | LCons (a, l) when n &gt; 1 -&gt;
a::(ltake (n-1) (Lazy.force l)) | LCons (a, l) when n = 1 -&gt; [a] (*
Avoid forcing the tail if not needed *) | _ -&gt; []</p>
<p>let rec lappend l1 l2 = match l1 with LNil -&gt; Lazy.force l2 |
LCons (hd, tl) -&gt; LCons (hd, lazy (lappend (Lazy.force tl) l2))</p>
<p>let rec lconcat_map f = function | LNil -&gt; LNil | LCons (a, l)
-&gt; lappend (f a) (lazy (lconcat_map f (Lazy.force l)))</p>
<p>module LListM = MonadPlus (struct type ’a t = ’a llist let bind a b =
lconcat_map b a let return a = LCons (a, lazy LNil) let mzero = LNil let
mplus = lappend end)</p>
<pre><code>
#### The Parsec Monad

File `Parsec.ml`:

```ocaml env=parsec
module type PARSE = sig
  type &#39;a backtracking_monad  (* Name for the underlying monad-plus *)
  type &#39;a parsing_state = int -&gt; (&#39;a * int) backtracking_monad  (* State: position *)
  type &#39;a t = string -&gt; &#39;a parsing_state  (* Reader for the parsed text *)
  include MONAD_PLUS_OPS
  val (&lt;|&gt;) : &#39;a monad -&gt; &#39;a monad Lazy.t -&gt; &#39;a monad  (* A synonym for mplus *)
  val run : &#39;a monad -&gt; &#39;a t
  val runT : &#39;a monad -&gt; string -&gt; int -&gt; &#39;a backtracking_monad
  val satisfy : (char -&gt; bool) -&gt; char monad  (* Consume a character of the class *)
  val end_of_text : unit monad  (* Check for end of the processed text *)
end

module ParseT (MP : MONAD_PLUS_OPS) :
  PARSE with type &#39;a backtracking_monad := &#39;a MP.monad =
struct
  type &#39;a backtracking_monad = &#39;a MP.monad
  type &#39;a parsing_state = int -&gt; (&#39;a * int) MP.monad
  module M = struct
    type &#39;a t = string -&gt; &#39;a parsing_state
    let return a = fun s p -&gt; MP.return (a, p)
    let bind m b = fun s p -&gt;
      MP.bind (m s p) (fun (a, p&#39;) -&gt; b a s p&#39;)
    let mzero = fun _ p -&gt; MP.mzero
    let mplus ma mb = fun s p -&gt;
      MP.mplus (ma s p) (lazy (Lazy.force mb s p))
  end
  include M
  include MonadPlusOps(M)
  let (&lt;|&gt;) ma mb = mplus ma mb
  let runT m s p = MP.lift fst (m s p)
  let satisfy f s p =
    if p &lt; String.length s &amp;&amp; f s.[p]  (* Consuming a character means accessing it *)
    then MP.return (s.[p], p + 1) else MP.mzero  (* and advancing the parsing pos *)
  let end_of_text s p =
    if p &gt;= String.length s then MP.return ((), p) else MP.mzero
end</code></pre>
<h4 id="additional-parser-operations">Additional Parser Operations</h4>
<p>```ocaml env=parsec module type PARSE_OPS = sig include PARSE val
many : ’a monad -&gt; ’a list monad val opt : ’a monad -&gt; ’a option
monad val (?|) : ’a monad -&gt; ’a option monad val seq : ’a monad -&gt;
’b monad Lazy.t -&gt; (’a * ’b) monad (* Exercise: why lazy? <em>) val
(&lt;</em>&gt;) : ’a monad -&gt; ’b monad Lazy.t -&gt; (’a * ’b) monad
(* Synonym for seq <em>) val lowercase : char monad val uppercase : char
monad val digit : char monad val alpha : char monad val alphanum : char
monad val literal : string -&gt; unit monad (</em> Consume characters of
the given string <em>) val (&lt;&lt;&gt;) : string -&gt; ’a monad -&gt;
’a monad (</em> Prefix and postfix keywords *) val (&lt;&gt;&gt;) : ’a
monad -&gt; string -&gt; ’a monad end</p>
<p>module ParseOps (R : MONAD_PLUS_OPS) (P : PARSE with type ’a
backtracking_monad := ’a R.monad) : PARSE_OPS with type ’a
backtracking_monad := ’a R.monad = struct include P let rec many p =
(let* r = p in let* rs = many p in return (r::rs)) ++ lazy (return [])
let opt p = (let* x = p in return (Some x)) ++ lazy (return None) let
(?|) p = opt p let seq p q = let* x = p in let* y = Lazy.force q in
return (x, y) let (&lt;<em>&gt;) p q = seq p q let lowercase = satisfy
(fun c -&gt; c &gt;= ‘a’ &amp;&amp; c &lt;= ‘z’) let uppercase = satisfy
(fun c -&gt; c &gt;= ‘A’ &amp;&amp; c &lt;= ‘Z’) let digit = satisfy
(fun c -&gt; c &gt;= ‘0’ &amp;&amp; c &lt;= ‘9’) let alpha = lowercase
++ lazy uppercase let alphanum = alpha ++ lazy digit let literal l = let
rec loop pos = if pos = String.length l then return () else satisfy (fun
c -&gt; c = l.[pos]) &gt;&gt;- loop (pos + 1) in loop 0 let
(&lt;&lt;&gt;) bra p = literal bra &gt;&gt;- p let (&lt;&gt;&gt;) p ket
= let</em> x = p in literal ket &gt;&gt;- return x end</p>
<pre><code>
### 11.11 Parser Combinators: Tying the Recursive Knot

Now we come to the key insight connecting parser combinators to the expression problem: how do we allow the grammar to be extended dynamically? The answer is to use a mutable reference holding a list of grammar rules, and tie the recursive knot lazily.

File `PluginBase.ml`:

```ocaml env=parsec
module ParseM = ParseOps (LListM) (ParseT (LListM))
open ParseM

let grammar_rules : (int monad -&gt; int monad) list ref = ref []

let get_language () : int monad =
  let rec result =
    lazy
      (List.fold_left
         (fun acc lang -&gt; acc &lt;|&gt; lazy (lang (Lazy.force result)))
          mzero !grammar_rules) in
  let* r = Lazy.force result in
  let* () = end_of_text in return r  (* Ensure we parse the whole text *)</code></pre>
<h3 id="parser-combinators-dynamic-code-loading">11.12 Parser
Combinators: Dynamic Code Loading</h3>
<p>OCaml supports dynamic code loading through the <code>Dynlink</code>
module. This allows us to load compiled modules at runtime, which can
register new grammar rules by mutating the <code>grammar_rules</code>
reference. This is a powerful form of extensibility: we can add new
syntax to our language without recompiling the main program.</p>
<p>File <code>PluginRun.ml</code>:</p>
<p>```ocaml skip let load_plug fname : unit = let fname =
Dynlink.adapt_filename fname in if Sys.file_exists fname then try
Dynlink.loadfile fname with | (Dynlink.Error err) as e -&gt;
Printf.printf “loading plugin: %s%!” (Dynlink.error_message err); raise
e | e -&gt; Printf.printf “error while loading plugin%!” else (
Printf.printf “file %s does not exist%!” fname; exit (-1))</p>
<p>let () = for i = 2 to Array.length Sys.argv - 1 do load_plug
Sys.argv.(i) done; let lang = PluginBase.get_language () in let result =
Monad.LListM.run (PluginBase.ParseM.runT lang Sys.argv.(1) 0) in match
Monad.ltake 1 result with | [] -&gt; Printf.printf “error%!” | r::_
-&gt; Printf.printf “: %d%!” r</p>
<pre><code>
### 11.13 Parser Combinators: Toy Example

Let us see how this works with a concrete example. We will define two plugins: one for parsing numbers and addition, and another for parsing multiplication. Each plugin registers its grammar rules by appending to the `grammar_rules` list.

File `Plugin1.ml`:

```ocaml env=parsec
open ParseM
let digit_of_char d = int_of_char d - int_of_char &#39;0&#39;

let number _ =  (* Numbers: N := D N | D where D is digits *)
  let rec num =  (* Note: we avoid left-recursion by having the digit first *)
    lazy ((let* d = digit in
           let* (n, b) = Lazy.force num in
           return (digit_of_char d * b + n, b * 10))
      &lt;|&gt; lazy (let* d = digit in return (digit_of_char d, 10))) in
  Lazy.force num &gt;&gt;| fst

let addition lang =  (* Addition rule: S -&gt; (S + S) *)
  (* Requiring a parenthesis &#39;(&#39; turns the rule into non-left-recursive *)
  (* because we consume a character before recursing *)
  let* () = literal &quot;(&quot; in
  let* n1 = lang in
  let* () = literal &quot;+&quot; in
  let* n2 = lang in
  let* () = literal &quot;)&quot; in
  return (n1 + n2)

let () = grammar_rules := number :: addition :: !grammar_rules</code></pre>
<p>File <code>Plugin2.ml</code> adds multiplication to the language.
Notice how we can add this functionality without modifying any existing
code:</p>
<p>```ocaml env=parsec open ParseM</p>
<p>let multiplication lang = (* Multiplication rule: S -&gt; (S * S)
<em>) let</em> () = literal “(” in let* n1 = lang in let* () = literal
“<em>” in let</em> n2 = lang in let* () = literal”)” in return (n1 *
n2)</p>
<p>let () = grammar_rules := multiplication :: !grammar_rules ```</p>
<h4 id="chapter-summary-what-to-remember">Chapter Summary (What to
Remember)</h4>
<ul>
<li>The expression problem asks for <em>two independent dimensions of
extension</em>: add new cases (data) and add new operations, while
keeping separate compilation and static typing.</li>
<li>Ordinary ADTs make new operations easy and new cases hard; OO makes
new cases easy and new operations hard; extensible variants make new
cases easy but weaken exhaustiveness guarantees.</li>
<li>Polymorphic variants (especially with recursive modules) support a
pragmatic “structural” style of extension: you can grow a language in
separate files with less tagging boilerplate, at the cost of more
sophisticated typing.</li>
<li>Parser combinators are a capstone example because they <em>are</em>
a language combinator library: you extend the language by adding new
combinators/rules, and dynamic loading makes the modularity aspect very
concrete.</li>
</ul>
<h3 id="exercises-8">11.14 Exercises</h3>
<p>The following exercises will help you deepen your understanding of
the expression problem and the various solutions we have explored. They
range from implementing additional operations to refactoring the code
for better organization.</p>
<p><strong>Exercise 1:</strong> Implement the <code>string_of_</code>
functions or methods, covering all data cases, corresponding to the
<code>eval_</code> functions in at least two examples from the lecture,
including both an object-based example and a variant-based example
(either standard, or polymorphic, or extensible variants). This will
help you understand how functional extensibility works in each
approach.</p>
<p><strong>Exercise 2:</strong> Split at least one of the examples from
the previous exercise into multiple files and demonstrate separate
compilation.</p>
<p><strong>Exercise 3:</strong> Can we drop the tags
<code>Lambda_t</code>, <code>Expr_t</code> and <code>LExpr_t</code> used
in the examples based on standard variants (file
<code>FP_ADT.ml</code>)? When using polymorphic variants, such tags are
not needed.</p>
<p><strong>Exercise 4:</strong> Factor-out the sub-language consisting
only of variables, thus eliminating the duplication of tags
<code>VarL</code>, <code>VarE</code> in the examples based on standard
variants (file <code>FP_ADT.ml</code>).</p>
<p><strong>Exercise 5:</strong> Come up with a scenario where the
extensible variant types-based solution leads to a non-obvious or hard
to locate bug. This exercise illustrates why exhaustivity checking is so
valuable for static type safety.</p>
<p><strong>Exercise 6:</strong> Re-implement the direct object-based
solution to the expression problem (file <code>Objects.ml</code>) to
make it more satisfying. For example, eliminate the need for some of the
<code>rename</code>, <code>apply</code>, <code>compute</code>
methods.</p>
<p><strong>Exercise 7:</strong> Re-implement the visitor pattern-based
solution to the expression problem (file <code>Visitor.ml</code>) in a
functional way, i.e., replace the mutable fields <code>subst</code> and
<code>beta_redex</code> in the <code>eval_lambda</code> class with a
different solution to the problem of treating <code>abs</code> and
non-<code>abs</code> expressions differently.</p>
<p><strong>Exercise 8:</strong> Extend the sub-language
<code>expr_visit</code> with variables, and add to arguments of the
evaluation constructor <code>eval_expr</code> the substitution. Handle
the problem of potentially duplicate fields <code>subst</code>. (One
approach might be to use ideas from exercise 6.)</p>
<p><strong>Exercise 9:</strong> Implement the following modifications to
the example from the file <code>PolyV.ml</code>:</p>
<ol type="1">
<li>Factor-out the sub-language of variables, around the already present
<code>var</code> type.</li>
<li>Open the types of functions <code>eval3</code>,
<code>freevars3</code> and other functions as required, so that explicit
subtyping, e.g., in <code>eval3 [] (test2 :&gt; lexpr_t)</code>, is not
necessary.</li>
<li>Remove the double-dispatch currently in <code>eval_lexpr</code> and
<code>freevars_lexpr</code>, by implementing a cascading design rather
than a “divide-and-conquer” design.</li>
</ol>
<p><strong>Exercise 10:</strong> Streamline the solution
<code>PolyRecM.ml</code> by extending the language of <span
class="math inline">\lambda</span>-expressions with arithmetic
expressions, rather than defining the sub-languages separately and then
merging them. See slide on page 15 of Jacques Garrigue <em>Structural
Types, Recursive Modules, and the Expression Problem</em>.</p>
<p><strong>Exercise 11:</strong> Transform a parser monad, or rewrite
the parser monad transformer, by adding state for the line and column
numbers.</p>
<p><strong>Exercise 12:</strong> Implement <code>_of_string</code>
functions as parser combinators on top of the example
<code>PolyRecM.ml</code>. Sections 4.3 and 6.2 of <em>Monadic Parser
Combinators</em> by Graham Hutton and Erik Meijer might be helpful.
Split the result into multiple files as in Exercise 2 and demonstrate
dynamic loading of code.</p>
<p><strong>Exercise 13:</strong> What are the benefits and drawbacks of
our lazy-monad-plus (built on top of <em>odd lazy lists</em>) approach,
as compared to regular monad-plus built on top of <em>even lazy
lists</em>? To additionally illustrate your answer:</p>
<ol type="1">
<li>Rewrite the parser combinators example to use regular monad-plus and
even lazy lists.</li>
<li>Select one example from Lecture 8 and rewrite it using
lazy-monad-plus and odd lazy lists.</li>
</ol>
<p>(In an “odd” lazy list, the first element is strict and only the tail
is lazy. In an “even” lazy list, the entire list is wrapped in laziness.
The choice affects when computation happens and how infinite structures
are handled.)</p>
</body>
</html>
