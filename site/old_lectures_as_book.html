<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Lukasz Stafiniak" />
  <meta name="author" content="Claude Opus 4.5" />
  <meta name="author" content="GPT-5.2" />
  <title>Functional Programming 2012-2013</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {  background-color: #f8f8f8; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ef2929; } /* Alert */
    code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #204a87; } /* Attribute */
    code span.bn { color: #0000cf; } /* BaseN */
    code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4e9a06; } /* Char */
    code span.cn { color: #8f5902; } /* Constant */
    code span.co { color: #8f5902; font-style: italic; } /* Comment */
    code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
    code span.dt { color: #204a87; } /* DataType */
    code span.dv { color: #0000cf; } /* DecVal */
    code span.er { color: #a40000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #0000cf; } /* Float */
    code span.fu { color: #204a87; font-weight: bold; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
    code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
    code span.ot { color: #8f5902; } /* Other */
    code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
    code span.sc { color: #ce5c00; font-weight: bold; } /* SpecialChar */
    code span.ss { color: #4e9a06; } /* SpecialString */
    code span.st { color: #4e9a06; } /* String */
    code span.va { color: #000000; } /* Variable */
    code span.vs { color: #4e9a06; } /* VerbatimString */
    code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
  <script>
  document.addEventListener('DOMContentLoaded', function() {
    const toc = document.getElementById('TOC');
    if (!toc) return;

    const tocLinks = toc.querySelectorAll('a[href^="#"]');
    const headings = [];

    tocLinks.forEach(link => {
      const id = link.getAttribute('href').slice(1);
      const heading = document.getElementById(id);
      if (heading) {
        headings.push({ id, link, heading });
      }
    });

    function updateActiveLink() {
      const scrollPos = window.scrollY + 100;

      let current = null;
      for (const item of headings) {
        if (item.heading.offsetTop <= scrollPos) {
          current = item;
        } else {
          break;
        }
      }

      tocLinks.forEach(link => link.classList.remove('toc-active'));
      toc.querySelectorAll('li').forEach(li => li.classList.remove('toc-active'));

      if (current) {
        current.link.classList.add('toc-active');
        let parent = current.link.closest('li');
        while (parent && toc.contains(parent)) {
          parent.classList.add('toc-active');
          parent = parent.parentElement?.closest('li');
        }
        if (window.innerWidth > 900) {
          current.link.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        }
      }
    }

    let ticking = false;
    window.addEventListener('scroll', function() {
      if (!ticking) {
        requestAnimationFrame(function() {
          updateActiveLink();
          ticking = false;
        });
        ticking = true;
      }
    });

    updateActiveLink();
  });
  </script>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = {"\\hyp": "\\substack{#1 \\\\[-0.5em] \\vdots \\\\ #2}"};
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Functional Programming 2012-2013</h1>
<p class="author">Lukasz Stafiniak</p>
<p class="author">Claude Opus 4.5</p>
<p class="author">GPT-5.2</p>
</header>
<nav id="TOC" role="doc-toc"><button id="toc-lock-toggle" title="Toggle auto-fold">&#x1f512;</button><script>document.addEventListener("DOMContentLoaded",function(){var btn=document.getElementById("toc-lock-toggle");var toc=document.getElementById("TOC");if(!btn||!toc)return;var locked=localStorage.getItem("tocLocked")==="true";function updateState(){if(locked){toc.classList.add("toc-locked");btn.classList.add("locked");btn.innerHTML="&#x1f513;";btn.title="Click to enable auto-fold";}else{toc.classList.remove("toc-locked");btn.classList.remove("locked");btn.innerHTML="&#x1f512;";btn.title="Click to expand all &amp; disable auto-fold";}}updateState();btn.addEventListener("click",function(){locked=!locked;localStorage.setItem("tocLocked",locked);updateState();});});</script>
<ul>
<li><a href="#in-the-beginning-there-was-logos"
id="toc-in-the-beginning-there-was-logos">1 In the Beginning there was
Logos</a></li>
<li><a href="#rules-for-logical-connectives"
id="toc-rules-for-logical-connectives">2 Rules for Logical
Connectives</a></li>
<li><a href="#logos-was-programmed-in-ocaml"
id="toc-logos-was-programmed-in-ocaml">3 Logos was Programmed in
OCaml</a>
<ul>
<li><a href="#definitions" id="toc-definitions">3.1 Definitions</a></li>
</ul></li>
<li><a href="#exercises" id="toc-exercises">4 Exercises</a></li>
<li><a href="#a-glimpse-at-type-inference"
id="toc-a-glimpse-at-type-inference">1 A Glimpse at Type Inference</a>
<ul>
<li><a href="#curried-form" id="toc-curried-form">1.1 Curried
form</a></li>
</ul></li>
<li><a href="#algebraic-data-types" id="toc-algebraic-data-types">2
Algebraic Data Types</a></li>
<li><a href="#syntactic-bread-and-sugar"
id="toc-syntactic-bread-and-sugar">3 Syntactic Bread and Sugar</a></li>
<li><a href="#pattern-matching" id="toc-pattern-matching">4 Pattern
Matching</a></li>
<li><a href="#interpreting-algebraic-dts-as-polynomials"
id="toc-interpreting-algebraic-dts-as-polynomials">5 Interpreting
Algebraic DTs as Polynomials</a>
<ul>
<li><a href="#differentiating-algebraic-data-types"
id="toc-differentiating-algebraic-data-types">5.1 Differentiating
Algebraic Data Types</a></li>
</ul></li>
<li><a href="#homework" id="toc-homework">6 Homework</a></li>
<li><a href="#chapter-2-derivation-example"
id="toc-chapter-2-derivation-example">Chapter 2: Derivation
example</a></li>
<li><a href="#lecture-2-type-inference-example-derivation"
id="toc-lecture-2-type-inference-example-derivation">Lecture 2: Type
inference example derivation</a></li>
<li><a href="#function-composition" id="toc-function-composition">1
Function Composition</a></li>
<li><a href="#evaluation-rules-reduction-semantics"
id="toc-evaluation-rules-reduction-semantics">2 Evaluation Rules
(reduction semantics)</a></li>
<li><a href="#symbolic-derivation-example"
id="toc-symbolic-derivation-example">3 Symbolic Derivation
Example</a></li>
<li><a href="#tail-calls-and-tail-recursion"
id="toc-tail-calls-and-tail-recursion">4 Tail Calls (and tail
recursion)</a></li>
<li><a href="#first-encounter-of-continuation-passing-style"
id="toc-first-encounter-of-continuation-passing-style">5 First Encounter
of Continuation Passing Style</a></li>
<li><a href="#homework-1" id="toc-homework-1">6 Homework</a></li>
<li><a href="#review-a-computation-by-hand-example"
id="toc-review-a-computation-by-hand-example">1 Review: a “computation
by hand” example</a></li>
<li><a href="#language-and-rules-of-the-untyped-lambda-calculus"
id="toc-language-and-rules-of-the-untyped-lambda-calculus">2 Language
and rules of the untyped <span
class="math inline">\lambda</span>-calculus</a></li>
<li><a href="#booleans" id="toc-booleans">3 Booleans</a></li>
<li><a href="#if-then-else-and-pairs" id="toc-if-then-else-and-pairs">4
If-then-else and pairs</a></li>
<li><a href="#pair-encoded-natural-numbers"
id="toc-pair-encoded-natural-numbers">5 Pair-encoded natural
numbers</a></li>
<li><a href="#church-numerals-natural-numbers-in-ch.-enc."
id="toc-church-numerals-natural-numbers-in-ch.-enc.">6 Church numerals
(natural numbers in Ch. enc.)</a></li>
<li><a href="#recursion-fixpoint-combinator"
id="toc-recursion-fixpoint-combinator">7 Recursion: Fixpoint
Combinator</a></li>
<li><a href="#encoding-of-lists-and-trees"
id="toc-encoding-of-lists-and-trees">8 Encoding of Lists and
Trees</a></li>
<li><a href="#looping-recursion" id="toc-looping-recursion">9 Looping
Recursion</a></li>
<li><a href="#in-class-work-and-homework"
id="toc-in-class-work-and-homework">10 In-class Work and
Homework</a></li>
<li><a href="#type-inference" id="toc-type-inference">1 Type
Inference</a></li>
<li><a href="#parametric-types" id="toc-parametric-types">2 Parametric
Types</a></li>
<li><a href="#type-inference-formally"
id="toc-type-inference-formally">3 Type Inference, Formally</a>
<ul>
<li><a href="#polymorphic-recursion" id="toc-polymorphic-recursion">3.1
Polymorphic Recursion</a>
<ul>
<li><a
href="#polymorphic-rec-a-list-alternating-between-two-types-of-elements"
id="toc-polymorphic-rec-a-list-alternating-between-two-types-of-elements">3.1.1
Polymorphic Rec: A list alternating between two types of
elements</a></li>
<li><a href="#polymorphic-rec-data-structural-bootstrapping"
id="toc-polymorphic-rec-data-structural-bootstrapping">3.1.2 Polymorphic
Rec: Data-Structural Bootstrapping</a></li>
</ul></li>
</ul></li>
<li><a href="#algebraic-specification"
id="toc-algebraic-specification">4 Algebraic Specification</a>
<ul>
<li><a href="#algebraic-specifications-examples"
id="toc-algebraic-specifications-examples">4.1 Algebraic specifications:
examples</a></li>
</ul></li>
<li><a href="#homomorphisms" id="toc-homomorphisms">5
Homomorphisms</a></li>
<li><a href="#example-maps" id="toc-example-maps">6 Example:
Maps</a></li>
<li><a href="#modules-and-interfaces-signatures-syntax"
id="toc-modules-and-interfaces-signatures-syntax">7 Modules and
interfaces (signatures): syntax</a></li>
<li><a href="#implementing-maps-association-lists"
id="toc-implementing-maps-association-lists">8 Implementing maps:
Association lists</a></li>
<li><a href="#implementing-maps-binary-search-trees"
id="toc-implementing-maps-binary-search-trees">9 Implementing maps:
Binary search trees</a></li>
<li><a href="#implementing-maps-red-black-trees"
id="toc-implementing-maps-red-black-trees">10 Implementing maps:
red-black trees</a>
<ul>
<li><a href="#b-trees-of-order-4-2-3-4-trees"
id="toc-b-trees-of-order-4-2-3-4-trees">10.1 B-trees of order 4 (2-3-4
trees)</a></li>
<li><a href="#red-black-trees-without-deletion"
id="toc-red-black-trees-without-deletion">10.2 Red-Black trees, without
deletion</a></li>
</ul></li>
<li><a href="#homework-2" id="toc-homework-2">11 Homework</a></li>
<li><a href="#plan" id="toc-plan">1 Plan</a></li>
<li><a href="#basic-generic-list-operations"
id="toc-basic-generic-list-operations">2 Basic generic list
operations</a>
<ul>
<li><a href="#always-extract-common-patterns"
id="toc-always-extract-common-patterns">2.1 Always extract common
patterns</a></li>
<li><a href="#can-we-make-fold-tail-recursive"
id="toc-can-we-make-fold-tail-recursive">2.2 Can we make
<code>fold</code> tail-recursive?</a></li>
</ul></li>
<li><a href="#map-and-fold-for-trees-and-other-structures"
id="toc-map-and-fold-for-trees-and-other-structures">3 <code>map</code>
and <code>fold</code> for trees and other structures</a>
<ul>
<li><a href="#map-and-fold-for-more-complex-structures"
id="toc-map-and-fold-for-more-complex-structures">3.1 <code>map</code>
and <code>fold</code> for more complex structures</a></li>
</ul></li>
<li><a href="#point-free-programming" id="toc-point-free-programming">4
Point-free Programming</a></li>
<li><a href="#reductions.-more-higher-orderlist-functions"
id="toc-reductions.-more-higher-orderlist-functions">5 Reductions. More
higher-order/list functions</a>
<ul>
<li><a href="#list-manipulation-all-subsequences-of-a-list"
id="toc-list-manipulation-all-subsequences-of-a-list">5.1 List
manipulation: All subsequences of a list</a></li>
<li><a href="#by-key-group_by-and-map_reduce"
id="toc-by-key-group_by-and-map_reduce">5.2 By key:
<code>group_by</code> and <code>map_reduce</code></a>
<ul>
<li><a href="#map_reduceconcat_reduce-examples"
id="toc-map_reduceconcat_reduce-examples">5.2.1
<code>map_reduce</code>/<code>concat_reduce</code> examples</a></li>
<li><a href="#tail-recursive-variants"
id="toc-tail-recursive-variants">5.2.2 Tail-recursive variants</a></li>
<li><a href="#helper-functions-for-inverted-index-demonstration"
id="toc-helper-functions-for-inverted-index-demonstration">5.2.3 Helper
functions for inverted index demonstration</a></li>
</ul></li>
<li><a href="#higher-order-functions-for-the-option-type"
id="toc-higher-order-functions-for-the-option-type">5.3 Higher-order
functions for the <code>option</code> type</a></li>
</ul></li>
<li><a href="#the-countdown-problem-puzzle"
id="toc-the-countdown-problem-puzzle">6 The Countdown Problem Puzzle</a>
<ul>
<li><a href="#brute-force-solution" id="toc-brute-force-solution">6.1
Brute force solution</a></li>
<li><a href="#fuse-the-generate-phase-with-the-test-phase"
id="toc-fuse-the-generate-phase-with-the-test-phase">6.2 Fuse the
generate phase with the test phase</a></li>
<li><a href="#eliminate-symmetric-cases"
id="toc-eliminate-symmetric-cases">6.3 Eliminate symmetric
cases</a></li>
</ul></li>
<li><a href="#the-honey-islands-puzzle"
id="toc-the-honey-islands-puzzle">7 The Honey Islands Puzzle</a>
<ul>
<li><a href="#representing-the-honeycomb"
id="toc-representing-the-honeycomb">7.1 Representing the honeycomb</a>
<ul>
<li><a href="#neighborhood" id="toc-neighborhood">7.1.1
Neighborhood</a></li>
<li><a href="#building-the-honeycomb"
id="toc-building-the-honeycomb">7.1.2 Building the honeycomb</a></li>
<li><a href="#drawing-honeycombs" id="toc-drawing-honeycombs">7.1.3
Drawing honeycombs</a></li>
</ul></li>
<li><a href="#testing-correctness-of-a-solution"
id="toc-testing-correctness-of-a-solution">7.2 Testing correctness of a
solution</a></li>
<li><a href="#interlude-multiple-results-per-step"
id="toc-interlude-multiple-results-per-step">7.3 Interlude: multiple
results per step</a></li>
<li><a href="#generating-a-solution" id="toc-generating-a-solution">7.4
Generating a solution</a></li>
<li><a href="#optimizations-for-honey-islands"
id="toc-optimizations-for-honey-islands">7.5 Optimizations for <em>Honey
Islands</em></a></li>
</ul></li>
<li><a href="#constraint-based-puzzles"
id="toc-constraint-based-puzzles">8 Constraint-based puzzles</a></li>
<li><a href="#laziness" id="toc-laziness">1 Laziness</a></li>
<li><a href="#evaluation-strategies-and-parameter-passing"
id="toc-evaluation-strategies-and-parameter-passing">2 Evaluation
strategies and parameter passing</a></li>
<li><a href="#call-by-name-streams" id="toc-call-by-name-streams">3
Call-by-name: streams</a></li>
<li><a href="#lazy-values" id="toc-lazy-values">4 Lazy values</a></li>
<li><a href="#power-series-and-differential-equations"
id="toc-power-series-and-differential-equations">5 Power series and
differential equations</a>
<ul>
<li><a href="#power-series-polynomial-operations"
id="toc-power-series-polynomial-operations">5.1 Power series /
polynomial operations</a></li>
<li><a href="#differential-equations"
id="toc-differential-equations">5.2 Differential equations</a></li>
</ul></li>
<li><a href="#arbitrary-precision-computation"
id="toc-arbitrary-precision-computation">6 Arbitrary precision
computation</a></li>
<li><a href="#circular-data-structures-double-linked-list"
id="toc-circular-data-structures-double-linked-list">7 Circular data
structures: double-linked list</a></li>
<li><a href="#input-output-streams" id="toc-input-output-streams">8
Input-Output streams</a>
<ul>
<li><a href="#pipes" id="toc-pipes">8.1 Pipes</a></li>
<li><a href="#example-pretty-printing"
id="toc-example-pretty-printing">8.2 Example: pretty-printing</a></li>
</ul></li>
<li><a href="#list-comprehensions" id="toc-list-comprehensions">1 List
comprehensions</a></li>
<li><a href="#generalized-comprehensions-aka.-do-notation"
id="toc-generalized-comprehensions-aka.-do-notation">2 Generalized
comprehensions aka. <em>do-notation</em></a></li>
<li><a href="#monads" id="toc-monads">3 Monads</a>
<ul>
<li><a href="#monad-laws" id="toc-monad-laws">3.1 Monad laws</a></li>
<li><a href="#monoid-laws-and-monad-plus"
id="toc-monoid-laws-and-monad-plus">3.2 Monoid laws and
<em>monad-plus</em></a></li>
<li><a href="#backtracking-computation-with-choice"
id="toc-backtracking-computation-with-choice">3.3 Backtracking:
computation with choice</a></li>
</ul></li>
<li><a href="#monad-flavors" id="toc-monad-flavors">4 Monad
“flavors”</a></li>
<li><a href="#interlude-the-module-system"
id="toc-interlude-the-module-system">5 Interlude: the module
system</a></li>
<li><a href="#the-two-metaphors" id="toc-the-two-metaphors">6 The two
metaphors</a>
<ul>
<li><a href="#monads-as-containers" id="toc-monads-as-containers">6.1
Monads as containers</a></li>
<li><a href="#monads-as-computation" id="toc-monads-as-computation">6.2
Monads as computation</a></li>
</ul></li>
<li><a href="#monad-classes" id="toc-monad-classes">7 Monad
classes</a></li>
<li><a href="#monad-instances" id="toc-monad-instances">8 Monad
instances</a>
<ul>
<li><a href="#backtracking-parameterized-by-monad-plus"
id="toc-backtracking-parameterized-by-monad-plus">8.1 Backtracking
parameterized by monad-plus</a></li>
<li><a href="#understanding-laziness"
id="toc-understanding-laziness">8.2 Understanding laziness</a></li>
<li><a href="#the-exception-monad" id="toc-the-exception-monad">8.3 The
exception monad</a></li>
<li><a href="#the-state-monad" id="toc-the-state-monad">8.4 The state
monad</a></li>
</ul></li>
<li><a href="#monad-transformers" id="toc-monad-transformers">9 Monad
transformers</a>
<ul>
<li><a href="#state-transformer" id="toc-state-transformer">9.1 State
transformer</a></li>
<li><a href="#backtracking-with-state"
id="toc-backtracking-with-state">9.2 Backtracking with state</a></li>
</ul></li>
<li><a href="#probabilistic-programming"
id="toc-probabilistic-programming">10 Probabilistic Programming</a>
<ul>
<li><a href="#the-probability-monad" id="toc-the-probability-monad">10.1
The probability monad</a></li>
<li><a href="#example-the-monty-hall-problem"
id="toc-example-the-monty-hall-problem">10.2 Example: The Monty Hall
problem</a></li>
<li><a href="#burglary-example-encoding-a-bayes-net"
id="toc-burglary-example-encoding-a-bayes-net">10.4 Burglary example:
encoding a Bayes net</a></li>
</ul></li>
<li><a href="#lightweight-cooperative-threads"
id="toc-lightweight-cooperative-threads">11 Lightweight cooperative
threads</a></li>
<li><a href="#ocaml-compilers" id="toc-ocaml-compilers">1 OCaml
Compilers</a>
<ul>
<li><a href="#compiling-multiple-file-projects"
id="toc-compiling-multiple-file-projects">1.1 Compiling multiple-file
projects</a></li>
<li><a href="#editors" id="toc-editors">1.2 Editors</a></li>
</ul></li>
<li><a href="#imperative-features-in-ocaml"
id="toc-imperative-features-in-ocaml">2 Imperative features in OCaml</a>
<ul>
<li><a href="#parsing-command-line-arguments"
id="toc-parsing-command-line-arguments">2.1 Parsing command-line
arguments</a></li>
</ul></li>
<li><a href="#ocaml-garbage-collection"
id="toc-ocaml-garbage-collection">3 OCaml Garbage Collection</a>
<ul>
<li><a href="#representation-of-values"
id="toc-representation-of-values">3.1 Representation of values</a></li>
<li><a href="#generational-garbage-collection"
id="toc-generational-garbage-collection">3.2 Generational Garbage
Collection</a></li>
<li><a href="#stop-copy-gc" id="toc-stop-copy-gc">3.3 Stop &amp; Copy
GC</a></li>
<li><a href="#mark-sweep-gc" id="toc-mark-sweep-gc">3.4 Mark &amp; Sweep
GC</a></li>
</ul></li>
<li><a href="#stack-frames-and-closures"
id="toc-stack-frames-and-closures">4 Stack Frames and Closures</a>
<ul>
<li><a href="#tail-recursion" id="toc-tail-recursion">4.1 Tail
Recursion</a></li>
<li><a href="#generated-assembly" id="toc-generated-assembly">4.2
Generated assembly</a></li>
</ul></li>
<li><a href="#profiling-and-optimization"
id="toc-profiling-and-optimization">5 Profiling and Optimization</a>
<ul>
<li><a href="#profiling" id="toc-profiling">5.1 Profiling</a></li>
<li><a href="#algorithmic-optimizations"
id="toc-algorithmic-optimizations">5.2 Algorithmic
optimizations</a></li>
<li><a href="#low-level-optimizations"
id="toc-low-level-optimizations">5.3 Low-level optimizations</a></li>
<li><a href="#comparison-of-data-structure-implementations"
id="toc-comparison-of-data-structure-implementations">5.4 Comparison of
data structure implementations</a></li>
</ul></li>
<li><a href="#parsing-ocamllex-and-menhir"
id="toc-parsing-ocamllex-and-menhir">6 Parsing: ocamllex and Menhir</a>
<ul>
<li><a href="#lexing-with-ocamllex" id="toc-lexing-with-ocamllex">6.1
Lexing with <em>ocamllex</em></a>
<ul>
<li><a href="#example-finding-email-addresses"
id="toc-example-finding-email-addresses">6.1.1 Example: Finding email
addresses</a></li>
</ul></li>
<li><a href="#parsing-with-menhir" id="toc-parsing-with-menhir">6.2
Parsing with Menhir</a>
<ul>
<li><a href="#example-parsing-arithmetic-expressions"
id="toc-example-parsing-arithmetic-expressions">6.2.1 Example: parsing
arithmetic expressions</a></li>
<li><a href="#example-a-toy-sentence-grammar"
id="toc-example-a-toy-sentence-grammar">6.2.2 Example: a toy sentence
grammar</a></li>
</ul></li>
</ul></li>
<li><a href="#example-phrase-search" id="toc-example-phrase-search">7
Example: Phrase search</a>
<ul>
<li><a href="#naive-implementation-of-phrase-search"
id="toc-naive-implementation-of-phrase-search">1 Naive implementation of
phrase search</a></li>
<li><a href="#replace-association-list-with-hash-table"
id="toc-replace-association-list-with-hash-table">2 Replace association
list with hash table</a></li>
<li><a href="#replace-naive-merging-with-ordered-merging"
id="toc-replace-naive-merging-with-ordered-merging">3 Replace naive
merging with ordered merging</a></li>
<li><a href="#bruteforce-optimization-biword-indexes"
id="toc-bruteforce-optimization-biword-indexes">4 Bruteforce
optimization: biword indexes</a></li>
<li><a href="#smart-way-information-retrieval-g.v.-cormack-et-al."
id="toc-smart-way-information-retrieval-g.v.-cormack-et-al.">7.1 Smart
way: <em>Information Retrieval</em> G.V. Cormack et al.</a>
<ul>
<li><a href="#the-phrase-search-algorithm"
id="toc-the-phrase-search-algorithm">7.1.1 The phrase search
algorithm</a></li>
<li><a href="#naive-but-purely-functional-inverted-index"
id="toc-naive-but-purely-functional-inverted-index">7.1.2 Naive but
purely functional inverted index</a></li>
<li><a href="#binary-search-based-inverted-index"
id="toc-binary-search-based-inverted-index">7.1.3 Binary search based
inverted index</a></li>
<li><a href="#imperative-linear-scan"
id="toc-imperative-linear-scan">7.1.4 Imperative, linear scan</a></li>
<li><a href="#imperative-galloping-search"
id="toc-imperative-galloping-search">7.1.5 Imperative, galloping
search</a></li>
</ul></li>
</ul></li>
<li><a href="#zippers" id="toc-zippers">1 Zippers</a>
<ul>
<li><a href="#example-context-rewriting"
id="toc-example-context-rewriting">1.1 Example: Context
rewriting</a></li>
</ul></li>
<li><a href="#adaptive-programming-aka.incremental-computing"
id="toc-adaptive-programming-aka.incremental-computing">2 Adaptive
Programming aka.Incremental Computing</a>
<ul>
<li><a href="#dependency-graphs-explained-by-jake-dunham"
id="toc-dependency-graphs-explained-by-jake-dunham">1 Dependency Graphs
(explained by Jake Dunham)</a></li>
<li><a href="#example-using-froc" id="toc-example-using-froc">2.1
Example using <em>Froc</em></a></li>
</ul></li>
<li><a href="#functional-reactive-programming"
id="toc-functional-reactive-programming">3 Functional Reactive
Programming</a></li>
<li><a href="#reactivity-by-stream-processing"
id="toc-reactivity-by-stream-processing">4 Reactivity by Stream
Processing</a>
<ul>
<li><a href="#the-paddle-game-example"
id="toc-the-paddle-game-example">1 The Paddle Game example</a></li>
</ul></li>
<li><a href="#reactivity-by-incremental-computing"
id="toc-reactivity-by-incremental-computing">5 Reactivity by Incremental
Computing</a>
<ul>
<li><a href="#reimplementing-the-paddle-game-example"
id="toc-reimplementing-the-paddle-game-example">1 Reimplementing the
Paddle Game example</a></li>
</ul></li>
<li><a href="#direct-control" id="toc-direct-control">6 Direct
Control</a>
<ul>
<li><a href="#flows-and-state" id="toc-flows-and-state">1 Flows and
state</a></li>
</ul></li>
<li><a href="#graphical-user-interfaces"
id="toc-graphical-user-interfaces">7 Graphical User Interfaces</a>
<ul>
<li><a href="#calculator-flow" id="toc-calculator-flow">7.1 Calculator
Flow</a></li>
<li><a href="#tk-labltk" id="toc-tk-labltk">7.2 <em>Tk</em>:
<em>LablTk</em></a></li>
<li><a href="#gtk-lablgtk" id="toc-gtk-lablgtk">7.3 <em>GTk+</em>:
<em>LablGTk</em></a></li>
</ul></li>
<li><a href="#the-expression-problem-exercises"
id="toc-the-expression-problem-exercises">The Expression Problem –
Exercises</a></li>
<li><a href="#exam-set-0" id="toc-exam-set-0">Exam set 0</a></li>
<li><a href="#exam-set-1" id="toc-exam-set-1">Exam set 1</a></li>
<li><a href="#exam-set-2" id="toc-exam-set-2">Exam set 2</a></li>
<li><a href="#exam-set-3" id="toc-exam-set-3">Exam set 3</a></li>
</ul>
</nav>
<!-- Do NOT modify this file, it is automatically generated -->
<p>Lecture 1: Logic</p>
<p>From logic rules to programming constructs</p>
<h1 id="in-the-beginning-there-was-logos">1 In the Beginning there was
Logos</h1>
<p>What logical connectives do you know?</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th><span class="math inline">\top</span></th>
<th><span class="math inline">\bot</span></th>
<th><span class="math inline">\wedge</span></th>
<th><span class="math inline">\vee</span></th>
<th><span class="math inline">\rightarrow</span></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td><span class="math inline">a \wedge b</span></td>
<td><span class="math inline">a \vee b</span></td>
<td><span class="math inline">a \rightarrow b</span></td>
</tr>
<tr>
<td>truth</td>
<td>falsehood</td>
<td>conjunction</td>
<td>disjunction</td>
<td>implication</td>
</tr>
<tr>
<td>“trivial”</td>
<td>“impossible”</td>
<td><span class="math inline">a</span> and <span
class="math inline">b</span></td>
<td><span class="math inline">a</span> or <span
class="math inline">b</span></td>
<td><span class="math inline">a</span> gives <span
class="math inline">b</span></td>
</tr>
<tr>
<td></td>
<td>shouldn’t get</td>
<td>got both</td>
<td>got at least one</td>
<td>given <span class="math inline">a</span>, we get <span
class="math inline">b</span></td>
</tr>
</tbody>
</table>
<p>How can we define them? Think in terms of <em>derivation
trees</em>:</p>
<p><span class="math display"> \frac{\begin{matrix}
     \frac{\begin{matrix}
       \frac{\,}{\text{a premise}} &amp; \frac{\,}{\text{another
premise}}
     \end{matrix}}{\text{some fact}} &amp; \frac{\frac{\,}{\text{this we
have by
     default}}}{\text{another fact}}
   \end{matrix}}{\text{final conclusion}} </span></p>
<p>Define by providing rules for using the connectives: for example, a
rule <span class="math inline">\frac{\begin{matrix}   a &amp; b
\end{matrix}}{c}</span> matches parts of the tree that have two
premises, represented by variables <span class="math inline">a</span>
and <span class="math inline">b</span>, and have any conclusion,
represented by variable <span class="math inline">c</span>.</p>
<p>Try to use only the connective you define in its definition.</p>
<h1 id="rules-for-logical-connectives">2 Rules for Logical
Connectives</h1>
<p>Introduction rules say how to produce a connective.</p>
<p>Elimination rules say how to use it.</p>
<p>Text in parentheses is comments. Letters are variables: stand for
anything.</p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 40%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr>
<th>Connective</th>
<th>Introduction Rules</th>
<th>Elimination Rules</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\top</span></td>
<td><span class="math inline">\frac{}{\top}</span></td>
<td>doesn’t have</td>
</tr>
<tr>
<td><span class="math inline">\bot</span></td>
<td>doesn’t have</td>
<td><span class="math inline">\frac{\bot}{a}</span> (i.e. anything)</td>
</tr>
<tr>
<td><span class="math inline">\wedge</span></td>
<td><span class="math inline">\frac{a \; b}{a \wedge b}</span></td>
<td><span class="math inline">\frac{a \wedge b}{a}</span> (take first)
<span class="math inline">\frac{a \wedge b}{b}</span> (take second)</td>
</tr>
<tr>
<td><span class="math inline">\vee</span></td>
<td><span class="math inline">\frac{a}{a \vee b}</span> (put first)
<span class="math inline">\frac{b}{a \vee b}</span> (put second)</td>
<td><span class="math inline">\frac{a \vee b \quad
\genfrac{}{}{0pt}{}{[a]^x}{\vdots \; c} \quad
\genfrac{}{}{0pt}{}{[b]^y}{\vdots \; c}}{c}</span> using <span
class="math inline">x, y</span></td>
</tr>
<tr>
<td><span class="math inline">\rightarrow</span></td>
<td><span class="math inline">\frac{\genfrac{}{}{0pt}{}{[a]^x}{\vdots \;
b}}{a \rightarrow b}</span> using <span
class="math inline">x</span></td>
<td><span class="math inline">\frac{a \rightarrow b \quad
a}{b}</span></td>
</tr>
</tbody>
</table>
<p>Notations</p>
<p><span class="math display"> \genfrac{}{}{0pt}{}{[a]^x}{\vdots \; b}
\text{, \ \ or \ \ } \genfrac{}{}{0pt}{}{[a]^x}{\vdots \; c} </span></p>
<p>match any subtree that derives <span class="math inline">b</span> (or
<span class="math inline">c</span>) and can use <span
class="math inline">a</span> (by assumption <span
class="math inline">\frac{\,}{a} \tiny{x}</span>) although otherwise
<span class="math inline">a</span> might not be warranted. For
example:</p>
<p><span class="math display">
\frac{\frac{\frac{\frac{\frac{\,}{\text{sunny}} \small{x}}{\text{go
   outdoor}}}{\text{playing}}}{\text{happy}}}{\text{sunny} \rightarrow
   \text{happy}} \small{\text{ using } x} </span></p>
<p>Such assumption can only be used in the matched subtree! But it can
be used several times, e.g. if someone’s mood is more difficult to
influence:</p>
<p><span class="math display"> \frac{\frac{\begin{matrix}
     \frac{\frac{\frac{\,}{\text{sunny}} \small{x}}{\text{go
     outdoor}}}{\text{playing}} &amp; \frac{\begin{matrix}
       \frac{\,}{\text{sunny}} \small{x} &amp;
\frac{\frac{\,}{\text{sunny}}
       \small{x}}{\text{go outdoor}}
     \end{matrix}}{\text{nice view}}
   \end{matrix}}{\text{happy}}}{\text{sunny} \rightarrow \text{happy}}
   \small{\text{ using } x} </span></p>
<p>Elimination rule for disjunction represents <strong>reasoning by
cases</strong>.</p>
<p>How can we use the fact that it is sunny<span
class="math inline">\vee</span>cloudy (but not rainy)?</p>
<p><span class="math display"> \frac{\begin{matrix}
     \frac{\,}{\text{sunny} \vee \text{cloudy}} \tiny{\text{ forecast}}
&amp;
     \frac{\frac{\,}{\text{sunny}} \tiny{x}}{\text{no-umbrella}} &amp;
     \frac{\frac{\,}{\text{cloudy}} \tiny{y}}{\text{no-umbrella}}
   \end{matrix}}{\text{no-umbrella}} \small{\text{ using } x, y}
</span></p>
<p>We know that it will be sunny or cloudy, by watching weather
forecast. If it will be sunny, we won’t need an umbrella. If it will be
cloudy, we won’t need an umbrella. Therefore, won’t need an umbrella.We
need one more kind of rules to do serious math: <strong>reasoning by
induction</strong> (it is somewhat similar to reasoning by cases).
Example rule for induction on natural numbers:</p>
<p><span class="math display"> \frac{p(0) \quad
\genfrac{}{}{0pt}{}{[p(x)]^x}{\vdots \; p(x+1)}}{p(n)} \text{ by
induction, using } x </span></p>
<p>So we get any <span class="math inline">p</span> for any natural
number <span class="math inline">n</span>, provided we can get it for
<span class="math inline">0</span>, and using it for <span
class="math inline">x</span> we can derive it for the successor <span
class="math inline">x + 1</span>, where <span
class="math inline">x</span> is a unique variable (we cannot substitute
for it some particular number, because we write “using <span
class="math inline">x</span>” on the side).</p>
<h1 id="logos-was-programmed-in-ocaml">3 Logos was Programmed in
OCaml</h1>
<table>
<thead>
<tr>
<th>Logic</th>
<th>Type</th>
<th>Expression</th>
<th>Introduction Rules</th>
<th>Elimination Rules</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\top</span></td>
<td><code>unit</code></td>
<td><code>()</code></td>
<td><span class="math inline">\frac{\;}{\texttt{()} :
\texttt{unit}}</span></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="definitions">3.1 Definitions</h2>
<p>Writing out expressions and types repetitively is tedious: we need
definitions. <strong>Definitions for types</strong> are written:
<code>type ty =</code> some type.</p>
<ul>
<li><p>Writing <code>A (</code><span
class="math inline">s</span><code>) : A of</code><span
class="math inline">a</span><code>| B of</code><span
class="math inline">b</span><code></code> in the table was cheating.
Usually we have to define the type and then use it, e.g. using
<code>int</code> for <span class="math inline">a</span> and
<code>string</code> for <span class="math inline">b</span>:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> int_string_choice = A <span class="kw">of</span> <span class="dt">int</span> | B <span class="kw">of</span> <span class="dt">string</span></span></code></pre></div>
<p>allows us to write <code>A (</code><span
class="math inline">s</span><code>) : int_string_choice</code>.</p></li>
<li><p>Without the type definition, it is difficult to know what other
variants there are when one <em>infers</em> (i.e. “guesses”, computes)
the type!</p></li>
<li><p>In OCaml we can write <code>`A(s) : [`A of a | `B of b]</code>.
With “<code>`</code>” variants, OCaml does guess what other variants
are. These types are fun, but we will not use them in future
lectures.</p></li>
<li><p>Tuple elements don’t need labels because we always know at which
position a tuple element stands. But having labels makes code more
clear, so we can define a <em>record type</em>:</p></li>
</ul>
<div class="sourceCode" id="cb2"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> int_string_record = {a: <span class="dt">int</span>; b: <span class="dt">string</span>}</span></code></pre></div>
<p>and create its values: <code>{a = 7; b = "Mary"}</code>. * We access
the <em>fields</em> of records using the dot notation:</p>
<p><code>{a=7; b="Mary"}.b = "Mary"</code>.Recursive expression <span
class="math inline">{\texttt{rec}} \; x \; {\texttt{=}} \; e</span> in
the table was cheating: <code>rec</code> (usually called
<code>fix</code>) cannot appear alone in OCaml! It must be part of a
definition.</p>
<p><strong>Definitions for expressions</strong> are introduced by rules
a bit more complex than these:</p>
<p><span class="math display"> \frac{e_1 : a \quad
\genfrac{}{}{0pt}{}{[x : a]}{\vdots \; e_2 : b}}{\texttt{let } x = e_1
\texttt{ in } e_2 : b} </span></p>
<p>(note that this rule is the same as introducing and eliminating <span
class="math inline">\rightarrow</span>), and:</p>
<p><span class="math display"> \frac{\genfrac{}{}{0pt}{}{[x : a]}{\vdots
\; e_1 : a} \quad \genfrac{}{}{0pt}{}{[x : a]}{\vdots \; e_2 :
b}}{\texttt{let rec } x = e_1 \texttt{ in } e_2 : b} </span></p>
<p>We will cover what is missing in above rules when we will talk about
<strong>polymorphism.</strong>* Type definitions we have seen above are
<em>global</em>: they need to be at the top-level, not nested in
expressions, and they extend from the point they occur till the end of
the source file or interactive session. *
<code>let</code>-<code>in</code> definitions for expressions: <span
class="math inline">{\texttt{let}} \; x \;
  {\texttt{=}} \; e_{1} \; {\texttt{in}} \; e_{2}</span> are
<em>local</em>, <span class="math inline">x</span> is only visible in
<span class="math inline">e_{2}</span>. But <code>let</code> definitions
are global: placing <span class="math inline">{\texttt{let}} \; x \;
  {\texttt{=}} \; e_{1}</span> at the top-level makes <span
class="math inline">x</span> visible from after <span
class="math inline">e_{1}</span> till the end of the source file or
interactive session. * In the interactive session, we mark an end of a
top-level “sentence” by ;; – it is unnecessary in source files. *
Operators like +, *, &lt;, =, are names of functions. Just like other
names, you can use operator names for your own functions:</p>
<p>let (+:) a b = String.concat “” [a; b];;Special way of
defining”Alpha” +: “Beta”;;but normal way of using operators. *
Operators in OCaml are <strong>not overloaded</strong>. It means, that
every type needs its own set of operators. For example, +, <em>, / work
for intigers, while +., </em>., /. work for floating point numbers.
<strong>Exception:</strong> comparisons &lt;, =, etc. work for all
values other than functions.</p>
<h1 id="exercises">4 Exercises</h1>
<p>Exercises from <em>Think OCaml. How to Think Like a Computer
Scientist</em> by Nicholas Monje and Allen Downey.</p>
<ol type="1">
<li><p>Assume that we execute the following assignment statements:</p>
<p>let width = 17;;let height = 12.0;;let delimiter = ‘.’;;</p>
<p>For each of the following expressions, write the value of the
expression and the type (of the value of the expression), or the
resulting type error.</p>
<ol type="1">
<li>width/2</li>
<li>width/.2.0</li>
<li>height/3</li>
<li>1 + 2 * 5</li>
<li>delimiter * 5</li>
</ol></li>
<li><p>Practice using the OCaml interpreter as a calculator:</p>
<ol type="1">
<li><p>The volume of a sphere with radius <span
class="math inline">r</span> is <span class="math inline">\frac{4}{3}
\pi r^3</span>. What is the volume of a sphere with radius 5?</p>
<p>Hint: 392.6 is wrong!</p></li>
<li><p>Suppose the cover price of a book is $24.95, but bookstores get a
40% discount. Shipping costs $3 for the first copy and 75 cents for each
additional copy. What is the total wholesale cost for 60
copies?</p></li>
<li><p>If I leave my house at 6:52 am and run 1 mile at an easy pace
(8:15 per mile), then 3 miles at tempo (7:12 per mile) and 1 mile at
easy pace again, what time do I get home for breakfast?</p></li>
</ol></li>
<li><p>You’ve probably heard of the fibonacci numbers before, but in
case you haven’t, they’re defined by the following recursive
relationship:</p>
<p><span class="math display"> \left\lbrace\begin{matrix}
  f (0) &amp; = &amp; 0 &amp;  \\\\\\
  f (1) &amp; = &amp; 1 &amp;  \\\\\\
  f (n + 1) &amp; = &amp; f (n) + f (n - 1) &amp; \text{for } n = 2, 3,
\ldots
\end{matrix}\right. </span></p>
<p>Write a recursive function to calculate these numbers.</p></li>
<li><p>A palindrome is a word that is spelled the same backward and
forward, like “noon” and “redivider”. Recursively, a word is a
palindrome if the first and last letters are the same and the middle is
a palindrome.</p>
<p>The following are functions that take a string argument and return
the first, last, and middle letters:</p>
<p>let firstchar word = word.[0];;let lastchar word = let len =
String.length word - 1 in word.[len];;let middle word = let len =
String.length word - 2 in String.sub word 1 len;;</p>
<ol type="1">
<li>Enter these functions into the toplevel and test them out. What
happens if you call middle with a string with two letters? One letter?
What about the empty string, which is written ““?</li>
<li>Write a function called is_palindrome that takes a string argument
and returns true if it is a palindrome and false otherwise.</li>
</ol></li>
<li><p>The greatest common divisor (GCD) of <span
class="math inline">a</span> and <span class="math inline">b</span> is
the largest number that divides both of them with no remainder.</p>
<p>One way to find the GCD of two numbers is Euclid’s algorithm, which
is based on the observation that if <span class="math inline">r</span>
is the remainder when <span class="math inline">a</span> is divided by
<span class="math inline">b</span>, then <span class="math inline">\gcd
(a, b) = \gcd (b, r)</span>. As a base case, we can consider <span
class="math inline">\gcd (a, 0) = a</span>.</p>
<p>Write a function called gcd that takes parameters a and b and returns
their greatest common divisor.</p>
<p>If you need help, see <a
href="http://en.wikipedia.org/wiki/Euclidean_algorithm">http://en.wikipedia.org/wiki/Euclidean_algorithm</a>.</p></li>
</ol>
<p>Lecture 2: Algebra</p>
<p>Algebraic Data Types and some curious analogies</p>
<h1 id="a-glimpse-at-type-inference">1 A Glimpse at Type Inference</h1>
<p>For a refresher, let’s try to use the rules we introduced last time
on some simple examples. Starting with <code>fun x -&gt; x</code>. <span
class="math inline">[?]</span> will mean “dunno yet”.</p>
<p><span class="math display"> \begin{matrix}
  &amp; \frac{[?]}{{\texttt{fun x -&gt; x}} : [?]} &amp; \text{use }
  \rightarrow \text{ introduction:}\\\\\\
  &amp; \frac{\frac{\,}{{\texttt{x}} : a}
  \tiny{x}}{{\texttt{fun x -&gt; x}} : [?] \rightarrow [?]}
  &amp; \frac{\,}{{\texttt{x}} : a} \tiny{x} \text{ matches with }
\genfrac{}{}{0pt}{}{[x : a]^x}{\vdots \; e : b}
\text{ since } e = {\texttt{x}}\\\\\\
  &amp; \frac{\frac{\,}{{\texttt{x}} : a}
  \tiny{x}}{{\texttt{fun x -&gt; x}} : a \rightarrow a} &amp;
  \text{since } b = a \text{ because } x : a \text{ matched with } e : b
\end{matrix} </span></p>
<p>Because <span class="math inline">a</span> is arbitrary, OCaml puts a
<em>type variable</em> <code>'a</code> for it:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">fun</span> x -&gt; x;;</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>- : &#39;a -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
<p>Let’s try <code>fun x -&gt; x+1</code>, which is the same as
<code>fun x -&gt; ((+) x)  1</code>(try it with OCaml/F#!). <span
class="math inline">[? \alpha]</span> will mean “dunno yet, but the same
as in other places with <span class="math inline">[?
\alpha]</span>”.</p>
<p><span class="math display"> \begin{matrix}
  &amp; \frac{[?]}{{\texttt{fun x -&gt; ((+) x) 1}} : [?]} &amp;
  \text{use } \rightarrow \text{ introduction:}\\\\\\
  &amp; \frac{\frac{[?]}{{\texttt{((+) x) 1}} : [?
  \alpha]}}{{\texttt{fun x -&gt; ((+) x) 1}} : [?]
\rightarrow [?
  \alpha]} &amp; \text{use } \rightarrow \text{ elimination:}\\\\\\
  &amp; \frac{\frac{\begin{matrix}
    \frac{[?]}{{\texttt{(+) x}} : [? \beta] \rightarrow [?
    \alpha]} &amp; \frac{[?]}{{\texttt{1}} : [? \beta]}
  \end{matrix}}{{\texttt{((+) x) 1}} : [?
  \alpha]}}{{\texttt{fun x -&gt; ((+) x) 1}} : [?]
\rightarrow [?
  \alpha]} &amp; \text{we know that {\texttt{1}}} :
  {\texttt{int}}\\\\\\
  &amp; \frac{\frac{\begin{matrix}
    \frac{[?]}{{\texttt{(+) x}} :
    {\texttt{int}} \rightarrow [? \alpha]} &amp;
    \frac{\,}{{\texttt{1}} : {\texttt{int}}}
    \tiny{\text{(constant)}}
  \end{matrix}}{{\texttt{((+) x) 1}} : [?
  \alpha]}}{{\texttt{fun x -&gt; ((+) x) 1}} : [?]
\rightarrow [?
  \alpha]} &amp; \text{application again:}\\\\\\
  &amp; \frac{\frac{\begin{matrix}
    \frac{\begin{matrix}
      \frac{[?]}{{\texttt{(+)}} : [? \gamma] \rightarrow
      {\texttt{int}} \rightarrow [? \alpha]} &amp;
      \frac{[?]}{{\texttt{x}} : [? \gamma]}
    \end{matrix}}{{\texttt{(+) x}} :
    {\texttt{int}} \rightarrow [? \alpha]} &amp;
    \frac{\,}{{\texttt{1}} : {\texttt{int}}}
    \tiny{\text{(constant)}}
  \end{matrix}}{{\texttt{((+) x) 1}} : [?
  \alpha]}}{{\texttt{fun x -&gt; ((+) x) 1}} : [?]
\rightarrow [?
  \alpha]} &amp; \text{it&#39;s our {\texttt{x}}!}\\\\\\
  &amp; \frac{\frac{\begin{matrix}
    \frac{\begin{matrix}
      \frac{[?]}{{\texttt{(+)}} : [? \gamma] \rightarrow
      {\texttt{int}} \rightarrow [? \alpha]} &amp;
      \frac{\,}{{\texttt{x}} : [? \gamma]}
      \tiny{{\texttt{x}}}
    \end{matrix}}{{\texttt{(+) x}} :
    {\texttt{int}} \rightarrow [? \alpha]} &amp;
    \frac{\,}{{\texttt{1}} : {\texttt{int}}}
    \tiny{\text{(constant)}}
  \end{matrix}}{{\texttt{((+) x) 1}} : [?
  \alpha]}}{{\texttt{fun x -&gt; ((+) x) 1}} : [? \gamma]
  \rightarrow [? \alpha]} &amp; \text{but {\texttt{(+)}}} :
  {\texttt{int}} \rightarrow {\texttt{int}}
  \rightarrow {\texttt{int}}\\\\\\
  &amp; \frac{\frac{\begin{matrix}
    \frac{\begin{matrix}
      \frac{\,}{{\texttt{(+)}} : {\texttt{int}}
      \rightarrow {\texttt{int}} \rightarrow
      {\texttt{int}}} \tiny{\text{(constant)}} &amp;
      \frac{\,}{{\texttt{x}} : {\texttt{int}}}
      \tiny{{\texttt{x}}}
    \end{matrix}}{{\texttt{(+) x}} :
    {\texttt{int}} \rightarrow {\texttt{int}}}
    &amp; \frac{\,}{{\texttt{1}} : {\texttt{int}}}
    \tiny{\text{(constant)}}
  \end{matrix}}{{\texttt{((+) x) 1}} :
  {\texttt{int}}}}{\text{{\texttt{fun x -&gt; ((+) x)
  1}}} : {\texttt{int}} \rightarrow
  {\texttt{int}}} &amp;
\end{matrix} </span></p>
<h2 id="curried-form">1.1 Curried form</h2>
<p>When there are several arrows “on the same depth” in a function type,
it means that the function returns a function: e.g. <span
class="math inline">{\texttt{(+)}} :
{\texttt{int}} \rightarrow {\texttt{int}}
\rightarrow {\texttt{int}}</span> is just a shorthand for <span
class="math inline">{\texttt{(+)}} : {\texttt{int}} \rightarrow
\left( {\texttt{int}} \rightarrow
{\texttt{int}} \right)</span>. It is very different from</p>
<p><span class="math display"> {\texttt{fun f -&gt; (f 1) + 1}} : \left(
   {\texttt{int}} \rightarrow {\texttt{int}}
   \right) \rightarrow {\texttt{int}} </span></p>
<p>For addition, instead of <code>(fun x -&gt; x+1)</code> we can write
<code>((+) 1)</code>. What expanded form does <code>((+) 1)</code>
correspond to exactly (computationally)?</p>
<p>We will get used to functions returning functions when learning about
the <em>lambda calculus</em>.</p>
<h1 id="algebraic-data-types">2 Algebraic Data Types</h1>
<ul>
<li>Last time we learned about the <code>unit</code> type, variant types
like:</li>
</ul>
<div class="sourceCode" id="cb4"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> int_string_choice = A <span class="kw">of</span> <span class="dt">int</span> | B <span class="kw">of</span> <span class="dt">string</span></span></code></pre></div>
<p>and also tuple types, record types, and type definitions. * Variants
don’t have to have arguments: instead of <code>A of unit</code> just use
<code>A</code>. * In OCaml, variants take multiple arguments rather than
taking tuples as arguments: <code>A of int * string</code> is different
than<code>A of (int * string)</code>. But it’s not important unless you
get bitten by it. * Type definitions can be recursive!</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> int_list = Empty | Cons <span class="kw">of</span> <span class="dt">int</span> * int_list</span></code></pre></div>
<p>Let’s see what we have in <code>int_list</code>:<code>Empty</code>,
<code>Cons (5, Cons (7, Cons (13,    Empty)))</code>, etc. * Type
<code>bool</code> can be seen as <code>type bool = true | false</code>,
type <code>int</code> can be seen as a very large
<code>type int = 0 | -1 | 1 | -2 | 2 | …</code> * Type definitions can
be <em>parametric</em> with respect to types of their components (more
on this in lecture about polymorphism), for example a list elements of
arbitrary type:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;elem <span class="dt">list</span> = Empty | Cons <span class="kw">of</span> &#39;elem * &#39;elem <span class="dt">list</span></span></code></pre></div>
<ul>
<li>Type variables must start with ’, but since OCaml will not remember
the names we give, it’s customary to use the names OCaml uses:
<code>'a</code>, <code>'b</code>, <code>'c</code>, <code>'d</code>…</li>
<li>The syntax in OCaml is a bit strange: in F# we write
<code>list&lt;'elem&gt;</code>. OCaml syntax mimics English, silly
example:</li>
</ul>
<pre><code>  type &#39;white_color dog = Dog of &#39;white_color</code></pre>
<ul>
<li>With multiple parameters:
<ul>
<li>OCaml:<code>type ('a, 'b) choice = Left of 'a | Right of 'b</code></li>
<li>F#:<code>type choice&lt;'a,'b&gt; = Left of 'a | Right of 'b</code></li>
<li>Haskell:<code>data Choice a b = Left a | Right b</code></li>
</ul></li>
</ul>
<h1 id="syntactic-bread-and-sugar">3 Syntactic Bread and Sugar</h1>
<ul>
<li>Names of variants, called <em>constructors</em>, must start with
capital letter – so if we wanted to define our own booleans, it would
be</li>
</ul>
<div class="sourceCode" id="cb8"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> my_bool = True | False</span></code></pre></div>
<p>Only constructors and module names can start with capital letter. *
<em>Modules</em> are “shelves” with values. For example,
<code>List</code> has operations on lists, like <code>List.map</code>
and <code>List.filter</code>. * Did I mention that we can use
<code>record.field</code> to access a field? *
<code>fun x y -&gt; e</code> stands for
<code>fun x -&gt; fun y -&gt; e</code>, etc. – and of
course,<code>fun x -&gt; fun y -&gt; e</code> parses as
<code>fun x -&gt; (fun y -&gt;    e)</code> *
<code>function A x -&gt; e1 | B y -&gt; e2</code> stands for
<code>fun p -&gt; match p    with A x -&gt; e1 | B y -&gt; e2</code>,
etc. * the general form is: <code>function *PATTERN-MATCHING*</code>
stands for<code>fun v -&gt;      match v with *PATTERN-MATCHING*</code>
* <code>let f ARGS = e</code> is a shorthand for
<code>let f = fun ARGS -&gt; e</code></p>
<h1 id="pattern-matching">4 Pattern Matching</h1>
<ul>
<li>Recall that we introduced <code>fst</code> and <code>snd</code> as
means to access elements of a pair. But what about bigger tuples? The
“basic” way of accessing any tuple reuses the <code>match</code>
construct. Functions <code>fst</code> and <code>snd</code> can easily be
defined!</li>
</ul>
<div class="sourceCode" id="cb9"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">fst</span> = <span class="kw">fun</span> p -&gt; <span class="kw">match</span> p <span class="kw">with</span> (a, b) -&gt; a</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">snd</span> = <span class="kw">fun</span> p -&gt; <span class="kw">match</span> p <span class="kw">with</span> (a, b) -&gt; b</span></code></pre></div>
<ul>
<li>It also works with records:</li>
</ul>
<div class="sourceCode" id="cb10"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> person = {name: <span class="dt">string</span>; surname: <span class="dt">string</span>; age: <span class="dt">int</span>}</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> {name=<span class="st">&quot;Walker&quot;</span>; surname=<span class="st">&quot;Johnnie&quot;</span>; age=<span class="dv">207</span>}</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">with</span> {name=n; surname=sn; age=a} -&gt; <span class="st">&quot;Hi &quot;</span>^sn^<span class="st">&quot;!&quot;</span></span></code></pre></div>
<ul>
<li>The left-hand-sides of -&gt; in <code>match</code> expressions are
called <strong>patterns</strong>.</li>
<li>Patterns can be nested:</li>
</ul>
<div class="sourceCode" id="cb11"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> <span class="dt">Some</span> (<span class="dv">5</span>, <span class="dv">7</span>) <span class="kw">with</span> <span class="dt">None</span> -&gt; <span class="st">&quot;sum: nothing&quot;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  | <span class="dt">Some</span> (x, y) -&gt; <span class="st">&quot;sum: &quot;</span> ^ <span class="dt">string_of_int</span> (x+y)</span></code></pre></div>
<ul>
<li>A pattern can just match the whole value, without performing
destructuring: <code>match f x with v -&gt;</code>… is the same as
<code>let v = f x in</code> …</li>
<li>When we do not need a value in a pattern, it is good practice to use
the underscore: <code>_</code> (which is not a variable!)</li>
</ul>
<div class="sourceCode" id="cb12"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">fst</span> (a,_) = a</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">snd</span> (_,b) = b</span></code></pre></div>
<ul>
<li>A variable can only appear once in a pattern (it is called
<em>linearity</em>).</li>
<li>But we can add conditions to the patterns after <code>when</code>,
so linearity is not really a problem!</li>
</ul>
<div class="sourceCode" id="cb13"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> p <span class="kw">with</span> (x, y) <span class="kw">when</span> x = y -&gt; <span class="st">&quot;diag&quot;</span> | _ -&gt; <span class="st">&quot;off-diag&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb14"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">compare</span> a b = <span class="kw">match</span> a, b <span class="kw">with</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  | (x, y) <span class="kw">when</span> x &lt; y -&gt; <span class="dv">-1</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  | (x, y) <span class="kw">when</span> x = y -&gt; <span class="dv">0</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; <span class="dv">1</span></span></code></pre></div>
<ul>
<li>We can skip over unused fields of a record in a pattern.</li>
<li>We can compress our patterns by using | inside a single
pattern:</li>
</ul>
<div class="sourceCode" id="cb15"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> month =</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  | Jan | Feb | Mar | Apr | May | Jun</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  | Jul | Aug | Sep | Oct | Nov | Dec</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> weekday = Mon | Tue | Wed | Thu | Fri | Sat | Sun</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date =</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  {year: <span class="dt">int</span>; month: month; day: <span class="dt">int</span>; weekday: weekday}</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> day =</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>  {year = <span class="dv">2012</span>; month = Feb; day = <span class="dv">14</span>; weekday = Wed};;</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> day <span class="kw">with</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>  | {weekday = Sat | Sun} -&gt; <span class="st">&quot;Weekend!&quot;</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; <span class="st">&quot;Work day&quot;</span></span></code></pre></div>
<ul>
<li>We use <code>(pattern **as** v)</code> to name a nested
pattern:</li>
</ul>
<div class="sourceCode" id="cb16"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> day <span class="kw">with</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  | {weekday = (Mon | Tue | Wed | Thu | Fri **<span class="kw">as</span>** wday)}</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">when</span> <span class="dt">not</span> (day.month = Dec &amp;&amp; day.day = <span class="dv">24</span>) -&gt;</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Some</span> (work (get_plan wday))</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; <span class="dt">None</span></span></code></pre></div>
<h1 id="interpreting-algebraic-dts-as-polynomials">5 Interpreting
Algebraic DTs as Polynomials</h1>
<p>Let’s do a peculiar translation: take a data type and replace | with
<span class="math inline">+</span>, * with <span
class="math inline">\times</span>, treating record types as tuple types
(i.e. erasing field names and translationg ; as <span
class="math inline">\times</span>).</p>
<p>There is a special type for which we cannot build a value:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> void</span></code></pre></div>
<p>(yes, it is its definition, no <code>= something</code> part).
Translate it as <span class="math inline">0</span>.</p>
<p>Translate the <code>unit</code> type as <span
class="math inline">1</span>. Since variants without arguments behave as
variants <code>of unit</code>, translate them as <span
class="math inline">1</span> as well. Translate <code>bool</code> as
<span class="math inline">2</span>.</p>
<p>Translate <code>int</code>, <code>string</code>, <code>float</code>,
type parameters and other types of interest as variables. Translate
defined types by their translations (substituting variables if
necessary).</p>
<p>Give name to the type being defined (denoting a function of the
variables introduced). Now interpret the result as ordinary numeric
polynomial! (Or “rational function” if it is recursively defined.)</p>
<p>Let’s have fun with it.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = {year: <span class="dt">int</span>; month: <span class="dt">int</span>; day: <span class="dt">int</span>}</span></code></pre></div>
<p><span class="math display"> D = xxx = x^3 </span></p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a <span class="dt">option</span> = <span class="dt">None</span> | <span class="dt">Some</span> <span class="kw">of</span> &#39;a   <span class="co">(* built-in type *)</span></span></code></pre></div>
<p><span class="math display"> O = 1 + x </span></p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a my_list = Empty | Cons <span class="kw">of</span> &#39;a * &#39;a my_list</span></code></pre></div>
<p><span class="math display"> L = 1 + xL </span></p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree = Tip | Node <span class="kw">of</span> <span class="dt">int</span> * btree * btree</span></code></pre></div>
<p><span class="math display"> T = 1 + xTT = 1 + xT^2 </span></p>
<p>When translations of two types are equal according to laws of
high-school algebra, the types are <em>isomorphic</em>, that is, there
exist 1-to-1 functions from one type to the other.</p>
<p>Let’s play with the type of binary trees:</p>
<p><span class="math display"> \begin{matrix}
  T &amp; = &amp; 1 + xT^2 = 1 + xT + x^2 T^3 = 1 + x + x^2 T^2 + x^2
T^3 =\\\\\\
  &amp; = &amp; 1 + x + x^2 T^2  (1 + T) = 1 + x (1 + xT^2  (1 + T))
\end{matrix} </span></p>
<p>Now let’s translate the resulting type:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> repr =</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">int</span> * (<span class="dt">int</span> * btree * btree * btree <span class="dt">option</span>) <span class="dt">option</span>) <span class="dt">option</span></span></code></pre></div>
<p>Try to find the isomorphism functions <code>iso1</code> and
<code>iso2</code></p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> iso1 : btree -&gt; repr</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> iso2 : repr -&gt; btree</span></code></pre></div>
<p>i.e. functions such that for all trees <code>t</code>,
<code>iso2 (iso1 t) = t</code>, and for all representations
<code>r</code>, <code>iso1 (iso2 r) = r</code>.</p>
<p>My first failed attempt:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> iso1 (t : btree) : repr =</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> t <span class="kw">with</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    | Tip -&gt; <span class="dt">None</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    | Node (x, Tip, Tip) -&gt; <span class="dt">Some</span> (x, <span class="dt">None</span>)</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    | Node (x, Node (y, t1, t2), Tip) -&gt;</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Some</span> (x, <span class="dt">Some</span> (y, t1, t2, <span class="dt">None</span>))</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    | Node (x, Node (y, t1, t2), t3) -&gt;</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Some</span> (x, <span class="dt">Some</span> (y, t1, t2, <span class="dt">Some</span> t3));;</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>            Characters <span class="dv">32-261</span>: […]</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>Warning <span class="dv">8</span>: this pattern-matching is <span class="dt">not</span> exhaustive.</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>Here is an example <span class="kw">of</span> a value that is <span class="dt">not</span> matched:</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>Node (_, Tip, Node (_, _, _))</span></code></pre></div>
<p>I forgot about one case. It seems difficult to guess the solution,
have you found it on your try?</p>
<p>Let’s divide the task into smaller steps corresponding to selected
intermediate points in the transformation of the polynomial:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (&#39;a, &#39;b) choice = Left <span class="kw">of</span> &#39;a | Right <span class="kw">of</span> &#39;b</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> interm1 =</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  ((<span class="dt">int</span> * btree, <span class="dt">int</span> * <span class="dt">int</span> * btree * btree * btree) choice)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">option</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> interm2 =</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>  ((<span class="dt">int</span>, <span class="dt">int</span> * <span class="dt">int</span> * btree * btree * btree <span class="dt">option</span>) choice)</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">option</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> step1r (t : btree) : interm1 =</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> t <span class="kw">with</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    | Tip -&gt; <span class="dt">None</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    | Node (x, t1, Tip) -&gt; <span class="dt">Some</span> (Left (x, t1))</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    | Node (x, t1, Node (y, t2, t3)) -&gt;</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Some</span> (Right (x, y, t1, t2, t3))</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> step2r (r : interm1) : interm2 =</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> r <span class="kw">with</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">None</span> -&gt; <span class="dt">None</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (Left (x, Tip)) -&gt; <span class="dt">Some</span> (Left x)</span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (Left (x, Node (y, t1, t2))) -&gt;</span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Some</span> (Right (x, y, t1, t2, <span class="dt">None</span>))</span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (Right (x, y, t1, t2, t3)) -&gt;</span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Some</span> (Right (x, y, t1, t2, <span class="dt">Some</span> t3))</span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> step3r (r : interm2) : repr =</span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> r <span class="kw">with</span></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">None</span> -&gt; <span class="dt">None</span></span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (Left x) -&gt; <span class="dt">Some</span> (x, <span class="dt">None</span>)</span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (Right (x, y, t1, t2, t3opt)) -&gt;</span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Some</span> (x, <span class="dt">Some</span> (y, t1, t2, t3opt))</span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> iso1 (t : btree) : repr =</span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a>  step3r (step2r (step1r t))</span></code></pre></div>
<p>Define <code>step1l</code>, <code>step2l</code>, <code>step3l</code>,
and <code>iso2</code>. Hint: now it’s trivial!</p>
<p>Take-home lessons:</p>
<ul>
<li>Try to define data structures so that only information that makes
sense can be represented – as long as it does not overcomplicate the
data structures. Avoid catch-all clauses when defining functions. The
compiler will then tell you if you have forgotten about a case.</li>
<li>Divide solutions into small steps so that each step can be easily
understood and checked.</li>
</ul>
<h2 id="differentiating-algebraic-data-types">5.1 Differentiating
Algebraic Data Types</h2>
<p>Of course, you would say, the pompous title is wrong, we will
differentiate the translated polynomials. But what sense does it
make?</p>
<p>It turns out, that taking the partial derivative of a polynomial
resulting from translating a data type, gives us, when translated back,
a type representing how to change one occurrence of a value of type
corresponding to the variable with respect to which we computed the
partial derivative.</p>
<p>Take the “date” example:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = {year: <span class="dt">int</span>; month: <span class="dt">int</span>; day: <span class="dt">int</span>}</span></code></pre></div>
<p><span class="math display"> \begin{matrix}
  D &amp; = &amp; xxx = x^3\\\\\\
  \frac{\partial D}{\partial x} &amp; = &amp; 3 x^2 = xx + xx + xx
\end{matrix} </span></p>
<p>(we could have left it at <span class="math inline">3 xx</span> as
well). Now we construct the type:</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date_deriv =</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  Year <span class="kw">of</span> <span class="dt">int</span> * <span class="dt">int</span> | Month <span class="kw">of</span> <span class="dt">int</span> * <span class="dt">int</span> | Day <span class="kw">of</span> <span class="dt">int</span> * <span class="dt">int</span></span></code></pre></div>
<p>Now we need to introduce and use (“eliminate”) the type
<code>date_deriv</code>.</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> date_deriv {year=y; month=m; day=d} =</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  [Year (m, d); Month (y, d); Day (y, m)]</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> date_integr n = <span class="kw">function</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>  | Year (m, d) -&gt; {year=n; month=m; day=d}</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>  | Month (y, d) -&gt; {year=y; month=n; day=d}</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>  | Day (y, m) -&gt; {year=y; month=m, day=n}</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>;;</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.map (date_integr <span class="dv">7</span>)</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>  (date_deriv {year=<span class="dv">2012</span>; month=<span class="dv">2</span>; day=<span class="dv">14</span>})</span></code></pre></div>
<p>Let’s do now the more difficult case of binary trees:</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree = Tip | Node <span class="kw">of</span> <span class="dt">int</span> * btree * btree</span></code></pre></div>
<p><span class="math display"> \begin{matrix}
  T &amp; = &amp; 1 + xT^2\\\\\\
  \frac{\partial T}{\partial x} &amp; = &amp; 0 + T^2 + 2 xT
\frac{\partial
  T}{\partial x} = TT + 2 xT \frac{\partial T}{\partial x}
\end{matrix} </span></p>
<p>(again, we could expand further into <span
class="math inline">\frac{\partial T}{\partial x} = TT + xT
\frac{\partial T}{\partial x} + xT \frac{\partial T}{\partial
x}</span>).</p>
<p>Instead of translating <span class="math inline">2</span> as
<code>bool</code>, we will introduce new type for clarity:</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree_dir = LeftBranch | RightBranch</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree_deriv =</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  | Here <span class="kw">of</span> btree * btree</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>  | Below <span class="kw">of</span> btree_dir * <span class="dt">int</span> * btree * btree_deriv</span></code></pre></div>
<p>(You might someday hear about <em>zippers</em> – they are “inverted”
w.r.t. our type, in zippers the hole comes first.)</p>
<p>Write a function that takes a number and a <code>btree_deriv</code>,
and builds a <code>btree</code> by putting the number into the “hole” in
<code>btree_deriv</code>.</p>
<p>Solution:</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> btree_integr n =</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>  | Here (ltree, rtree) -&gt; Node (n, ltree, rtree)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>  | Below (LeftBranch, m, rtree) -&gt;</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    Node (m, btree_integr n ltree, rtree)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>  | Below (RightBranch, m, ltree) -&gt;</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    Node (m, ltree, btree_integr n rtree)</span></code></pre></div>
<h1 id="homework">6 Homework</h1>
<p>Write a function <code>btree_deriv_at</code> that takes a predicate
over integers (i.e. a function <code>f: int -&gt; bool</code>), and a
<code>btree</code>, and builds a <code>btree_deriv</code> whose “hole”
is in the first position for which the predicate returns true. It should
actually return a <code>btree_deriv option</code>, with
<code>None</code> in case the predicate does not hold for any node.</p>
<p><em>This homework is due for the class <strong>after</strong> the
Computation class, i.e. for (before) the Functions class.</em></p>
<h1 id="chapter-2-derivation-example">Chapter 2: Derivation example</h1>
<h1 id="lecture-2-type-inference-example-derivation">Lecture 2: Type
inference example derivation</h1>
<p><span class="math display"> \frac{[?]}{{\texttt{fun x -&gt; ((+) x)
1}} : [?]} </span></p>
<p><span class="math display"> \text{use } \rightarrow \text{
introduction:} </span></p>
<p><span class="math display"> \frac{\frac{[?]}{{\texttt{((+) x) 1}} :
[?
   \alpha]}}{{\texttt{fun x -&gt; ((+) x) 1}} : [?]
\rightarrow
   [? \alpha]} </span></p>
<p><span class="math display"> \text{use } \rightarrow \text{
elimination:} </span></p>
<p><span class="math display"> \frac{\frac{\begin{matrix}
     \frac{[?]}{{\texttt{(+) x}} : [? \beta] \rightarrow [?
     \alpha]} &amp; \frac{[?]}{{\texttt{1}} : [? \beta]}
   \end{matrix}}{{\texttt{((+) x) 1}} : [?
   \alpha]}}{{\texttt{fun x -&gt; ((+) x) 1}} : [?]
\rightarrow
   [? \alpha]} </span></p>
<p><span class="math display"> \text{we know that {\texttt{1}}} :
{\texttt{int}} </span></p>
<p><span class="math display"> \frac{\frac{\begin{matrix}
     \frac{[?]}{{\texttt{(+) x}} :
     {\texttt{int}} \rightarrow [? \alpha]} &amp;
     \frac{\,}{{\texttt{1}} : {\texttt{int}}}
     \tiny{\text{(constant)}}
   \end{matrix}}{{\texttt{((+) x) 1}} : [?
   \alpha]}}{{\texttt{fun x -&gt; ((+) x) 1}} : [?]
\rightarrow
   [? \alpha]} </span></p>
<p><span class="math display"> \text{application again:} </span></p>
<p><span class="math display"> \frac{\frac{\begin{matrix}
     \frac{\begin{matrix}
       \frac{[?]}{{\texttt{(+)}} : [? \gamma] \rightarrow
       {\texttt{int}} \rightarrow [? \alpha]} &amp;
       \frac{[?]}{{\texttt{x}} : [? \gamma]}
     \end{matrix}}{{\texttt{(+) x}} :
     {\texttt{int}} \rightarrow [? \alpha]} &amp;
     \frac{\,}{{\texttt{1}} : {\texttt{int}}}
     \tiny{\text{(constant)}}
   \end{matrix}}{{\texttt{((+) x) 1}} : [?
   \alpha]}}{{\texttt{fun x -&gt; ((+) x) 1}} : [?]
\rightarrow
   [? \alpha]} </span></p>
<p><span class="math display"> \text{it&#39;s our {\texttt{x}}!}
</span></p>
<p><span class="math display"> \frac{\frac{\begin{matrix}
     \frac{\begin{matrix}
       \frac{[?]}{{\texttt{(+)}} : [? \gamma] \rightarrow
       {\texttt{int}} \rightarrow [? \alpha]} &amp;
       \frac{\,}{{\texttt{x}} : [? \gamma]}
       {\texttt{x}}
     \end{matrix}}{{\texttt{(+) x}} :
     {\texttt{int}} \rightarrow [? \alpha]} &amp;
     \frac{\,}{{\texttt{1}} : {\texttt{int}}}
     \tiny{\text{(constant)}}
   \end{matrix}}{{\texttt{((+) x) 1}} : [?
   \alpha]}}{{\texttt{fun x -&gt; ((+) x) 1}} : [? \gamma]
   \rightarrow [? \alpha]} </span></p>
<p><span class="math display"> \text{but {\texttt{(+)}}} :
{\texttt{int}}
   \rightarrow {\texttt{int}} \rightarrow
   {\texttt{int}} </span></p>
<p><span class="math display"> \frac{\frac{\begin{matrix}
     \frac{\begin{matrix}
       \frac{\,}{{\texttt{(+)}} : {\texttt{int}}
       \rightarrow {\texttt{int}} \rightarrow
       {\texttt{int}}} \tiny{\text{(constant)}} &amp;
       \frac{\,}{{\texttt{x}} : {\texttt{int}}}
       {\texttt{x}}
     \end{matrix}}{{\texttt{(+) x}} :
     {\texttt{int}} \rightarrow
     {\texttt{int}}} &amp; \frac{\,}{{\texttt{1}} :
     {\texttt{int}}} \tiny{\text{(constant)}}
   \end{matrix}}{{\texttt{((+) x) 1}} :
   {\texttt{int}}}}{\text{{\texttt{fun x -&gt; ((+) x)
   1}}} : {\texttt{int}} \rightarrow
   {\texttt{int}}} </span></p>
<p>Exercise 1.</p>
<p>Due to Yaron Minsky.</p>
<p>Consider a datatype to store internet connection information. The
time <code>when_initiated</code> marks the start of connecting and is
not needed after the connection is established (it is only used to
decide whether to give up trying to connect). The ping information is
available for established connection but not straight away.</p>
<p>type connectionstate = | Connecting | Connected | Disconnectedtype
connectioninfo = { state : connectionstate; server : Inetaddr.t;<br />
lastpingtime : Time.t option; lastpingid : int option; sessionid :
string option; wheninitiated : Time.t option; whendisconnected : Time.t
option;}</p>
<p>(The types Time.t and Inetaddr.t come from the library <em>Core</em>
used where Yaron Minsky works. You can replace them with
<code>float</code> and Unix.inet_addr. Load the Unix library in the
interactive toplevel by <code>#load "unix.cma";;</code>.) Rewrite the
type definitions so that the datatype will contain only reasonable
combinations of information.</p>
<p>Exercise 2.</p>
<p>In OCaml, functions can have named arguments, and also default
arguments (parameters, possibly with default values, which can be
omitted when providing arguments). The names of arguments are called
labels. The labels can be different from the names of the argument
values:</p>
<p>let f <span class="math inline">\sim</span>meaningfulname:n = n+1let
= f <span class="math inline">\sim</span>meaningfulname:5We do not need
the result so we ignore it.</p>
<p>When the label and value names are the same, the syntax is
shorter:</p>
<p>let g <span class="math inline">\sim</span>pos <span
class="math inline">\sim</span>len = StringLabels.sub
“0123456789abcdefghijklmnopqrstuvwxyz” <span
class="math inline">\sim</span>pos <span
class="math inline">\sim</span>lenlet () =A nicer way to mark
computations that do not produce a result (return <code>unit</code>).
let pos = Random.int 26 in let len = Random.int 10 in printstring (g
<span class="math inline">\sim</span>pos <span
class="math inline">\sim</span>len)</p>
<p>When some function arguments are optional, the function has to take
non-optional arguments after the last optional argument. When the
optional parameters have default values:</p>
<p>let h ?(len=1) pos = g <span class="math inline">\sim</span>pos <span
class="math inline">\sim</span>lenlet () = printstring (h 10)</p>
<p>Optional arguments are implemented as parameters of an option type.
This allows us to check whether the argument was actually provided:</p>
<p>let foo ?bar n = match bar with | None -&gt; “Argument =” stringofint
n | Some m -&gt; “Sum =” stringofint (m + n);;foo 5;;foo <span
class="math inline">\sim</span>bar:5 7;;</p>
<p>We can also provide the option value directly:</p>
<p>let bar = if Random.int 10 &lt; 5 then None else Some 7 infoo ?bar
7;;</p>
<ol type="1">
<li>Observe the types that functions with labelled and optional
arguments have. Come up with coding style guidelines, e.g. when to use
labeled arguments.</li>
<li>Write a rectangle-drawing procedure that takes three optional
arguments: left-upper corner, right-lower corner, and a width-height
pair. It should draw a correct rectangle whenever two arguments are
given, and raise exception otherwise. Load the graphics library in the
interactive toplevel by <code>#load "graphics.cma";;</code>. Use
“functions” <code>invalid_arg</code>, Graphics.<code>open_graph</code>
and Graphics.<code>draw_rect</code>.</li>
<li>Write a function that takes an optional argument of arbitrary type
and a function argument, and passes the optional argument to the
function without inspecting it.</li>
</ol>
<p>Exercise 3.</p>
<p>From last year’s exam.</p>
<ol type="1">
<li>Give the (most general) types of the following expressions, either
by guessing or inferring by hand:
<ol type="1">
<li>let double f y = f (f y) in fun g x -&gt; double (g x)</li>
<li>let rec tails l = match l with [] -&gt; [] | x::xs -&gt; xs::tails
xs infun l -&gt; List.combine l (tails l)</li>
</ol></li>
<li>Give example expressions that have the following types (without
using type constraints):
<ol type="1">
<li><code>(int -&gt; int) -&gt; bool</code></li>
<li><code>'a option -&gt; 'a list</code></li>
</ol></li>
</ol>
<p>Exercise 4.</p>
<p>We have seen in the class, that algebraic data types can be related
to analytic functions (the subset that can be defined out of polynomials
via recursion) – by literally interpreting sum types (i.e. variant
types) as sums and product types (i.e. tuple and record types) as
products. We can extend this interpretation to all OCaml types that we
introduced, by interpreting a function type <span class="math inline">a
\rightarrow b</span> as <span class="math inline">b^a</span>, <span
class="math inline">b</span> to the power of <span
class="math inline">a</span>. Note that the <span
class="math inline">b^a</span> notation is actually used to denote
functions in set theory.</p>
<ol type="1">
<li>Translate <span class="math inline">a^{b + cd}</span> and <span
class="math inline">a^b  (a^c)^d</span> into OCaml types, using any
distinct types for <span class="math inline">a, b, c, d</span>, and
using the <code>('a,'b) choice = Left of 'a  | Right of 'b</code>
datatype for <span class="math inline">+</span>. Write the bijection
function in both directions.</li>
<li>Come up with a type <code>'t exp</code>, that shares with the
exponential function the following property: <span
class="math inline">\frac{\partial \exp (t)}{\partial t} = \exp
(t)</span>, where we translate a derivative of a type as a context,
i.e. the type with a “hole”, as in the lecture. Explain why your answer
is correct. Hint: in computer science, our logarithms are mostly base
2.</li>
</ol>
<p>Further reading: <a
href="http://bababadalgharaghtakamminarronnkonnbro.blogspot.com/2012/10/algebraic-type-systems-combinatorial.html">http://bababadalgharaghtakamminarronnkonnbro.blogspot.com/2012/10/algebraic-type-systems-combinatorial.html</a></p>
<p>Lecture 3: Computation</p>
<p>‘‘Using, Understanding and Unraveling the OCaml Language’’ Didier
Rémy, chapter 1</p>
<p>‘‘The OCaml system’’ manual, the tutorial part, chapter 1</p>
<h1 id="function-composition">1 Function Composition</h1>
<ul>
<li>The usual way function composition is defined in math is “backward”:
<ul>
<li>math: <span class="math inline">(f \circ g) (x) = f (g
(x))</span></li>
<li>OCaml: <code>let (-|) f g x = f (g x)</code></li>
<li>F#: <code>let (&lt;&lt;) f g x = f (g x)</code></li>
<li>Haskell: <code>(.) f g = \x -&gt; f (g x)</code></li>
</ul></li>
<li>It looks like function application, but needs less parentheses. Do
you recall the functions <code>iso1</code> and <code>iso2</code> from
previous lecture?</li>
</ul>
<div class="sourceCode" id="cb32"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> iso2 = step1l -| step2l -| step3l</span></code></pre></div>
<ul>
<li>A more natural definition of function composition is “forward”:
<ul>
<li>OCaml: <code>let (|-) f g x = g (f x)</code></li>
<li>F#: <code>let (&gt;&gt;) f g x = g (f x)</code></li>
</ul></li>
<li>It follows the order in which computation proceeds.</li>
</ul>
<div class="sourceCode" id="cb33"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> iso1 = step1r |- step2r |- step3r</span></code></pre></div>
<ul>
<li><em>Partial application</em> is e.g. <code>((+) 1)</code> from last
week: we don’t pass all arguments a function needs, in result we get a
function that requires the remaining arguments. How is it used
above?</li>
<li>Now we define <span class="math inline">f^n (x) := (f \circ \ldots
\circ f) (x)</span> (<span class="math inline">f</span> appears <span
class="math inline">n</span> times).</li>
</ul>
<div class="sourceCode" id="cb34"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> power f n =</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> (<span class="kw">fun</span> x -&gt; x) <span class="kw">else</span> f -| power f (n<span class="dv">-1</span>)</span></code></pre></div>
<ul>
<li>Now we define a numerical derivative:</li>
</ul>
<div class="sourceCode" id="cb35"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> derivative dx f = <span class="kw">fun</span> x -&gt; (f(x +. dx) -. f(x)) /. dx</span></code></pre></div>
<p>where the intent to use with two arguments is stressed, or for
short:</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> derivative dx f x = (f(x +. dx) -. f(x)) /. dx</span></code></pre></div>
<ul>
<li>We have <code>(+): int -&gt; int -&gt; int</code>, so cannot use
with <code>float</code>ing point numbers – operators followed by dot
work on <code>float</code> numbers.</li>
</ul>
<div class="sourceCode" id="cb37"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pi = <span class="fl">4.0</span> *. <span class="dt">atan</span> <span class="fl">1.0</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> sin&#39;&#39;&#39; = (power (derivative <span class="fl">1e-5</span>) <span class="dv">3</span>) <span class="dt">sin</span>;;</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>sin&#39;&#39;&#39; pi;;</span></code></pre></div>
<h1 id="evaluation-rules-reduction-semantics">2 Evaluation Rules
(reduction semantics)</h1>
<ul>
<li><p>Programs consist of <strong>expressions</strong>:</p>
<p><span class="math display"> \begin{matrix}
a := &amp; x &amp; \text{variables}\\\\\\
| &amp; {\texttt{fun }} x {\texttt{-&gt;}} a &amp;
\text{(defined) functions}\\\\\\
| &amp; a a &amp; \text{applications}\\\\\\
| &amp; C^0 &amp; \text{value constructors of arity } 0\\\\\\
| &amp; C^n (a, \ldots, a) &amp; \text{value constructors of arity } n
\\\\\\
| &amp; f^n &amp; \text{built-in values (primitives) of a. } n\\\\\\
| &amp; {\texttt{let }} x = a {\texttt{ in }} a
&amp; \text{name bindings (local definitions)}\\\\\\
| &amp; {\texttt{match }} a {\texttt{ with} \ \
\ \ \ \ \ } &amp;  \\\\\\
&amp; p {\texttt{-&gt;}} a \text{{\texttt{ \textbar
}}}
\ldots {\texttt{ \textbar }} p
{\texttt{-&gt;}}
a &amp; \text{pattern matching}\\\\\\
p := &amp; x &amp; \text{pattern variables}\\\\\\
| &amp; (p, \ldots, p) &amp; \text{tuple patterns}\\\\\\
| &amp; C^0 &amp; \text{variant patterns of arity } 0\\\\\\
| &amp; C^n (p, \ldots, p) &amp; \text{variant patterns of arity } n
\end{matrix} </span></p></li>
<li><p><em>Arity</em> means how many arguments something requires; (and
for tuples, the length of a tuple).</p></li>
<li><p>To simplify presentation, we will use a primitive
<code>fix</code> to define a limited form of <code>let rec</code>:</p>
<p><span class="math display"> {\texttt{let rec }} f {\texttt{ }} x =
e_{1} {\texttt{ in }} e_{2} \equiv
{\texttt{let }} f = {\texttt{fix (fun }} f
{\texttt{ }} x {\texttt{-&gt;}} e_{1}
{\texttt{) in }} e_{2} </span></p></li>
<li><p>Expressions evaluate (i.e. compute) to
<strong>values</strong>:</p>
<p><span class="math display"> \begin{matrix}
v := &amp; {\texttt{fun }} x {\texttt{-&gt;}} a
&amp;
\text{(defined) functions}\\\\\\
| &amp; C^n (v_{1}, \ldots, v_{n}) &amp; \text{constructed values}\\\\\\
| &amp; f^n v_{1} \ldots v_{k} &amp; k &lt; n \text{ partially applied
primitives} \end{matrix} </span></p></li>
<li><p>To <em>substitute</em> a value <span class="math inline">v</span>
for a variable <span class="math inline">x</span> in expression <span
class="math inline">a</span> we write <span class="math inline">a
[x := v]</span> – it behaves as if every occurrence of <span
class="math inline">x</span> in <span class="math inline">a</span> was
<em>rewritten</em> by <span class="math inline">v</span>.</p>
<ul>
<li>(But actually the value <span class="math inline">v</span> is not
duplicated.)</li>
</ul></li>
<li><p>Reduction (i.e. computation) proceeds as follows: first we give
<em>redexes</em></p>
<p><span class="math display"> \begin{matrix}
\left( {\texttt{fun }} x {\texttt{-&gt;}} a
\right) v &amp; \rightsquigarrow &amp; a [x := v]\\\\\\
{\texttt{let }} x = v {\texttt{ in }} a &amp;
\rightsquigarrow &amp; a [x := v]\\\\\\
f^n v_{1} \ldots v_{n} &amp; \rightsquigarrow &amp; f (v_{1}, \ldots,
v_{n})\\\\\\
{\texttt{match }} v {\texttt{ with} } x
{\texttt{-&gt;}} a {\texttt{ \textbar }}
\ldots
&amp; \rightsquigarrow &amp; a [x := v]\\\\\\
{\texttt{match }} C_{1}^n (v_{1}, \ldots, v_{n})
{\texttt{ with}} &amp;  &amp;  \\\\\\
C_{2}^n (p_{1}, \ldots, p_{k}) {\texttt{-&gt;}} a
{\texttt{ \textbar }} \operatorname{pm} &amp; \rightsquigarrow &amp;
{\texttt{match }} C_{1}^n (v_{1}, \ldots, v_{n})\\\\\\
&amp;  &amp; {\texttt{with} } \operatorname{pm}\\\\\\
{\texttt{match }} C_{1}^n (v_{1}, \ldots, v_{n})
{\texttt{ with}} &amp;  &amp;  \\\\\\
C_{1}^n (x_{1}, \ldots, x_{n}) {\texttt{-&gt;}} a
{\texttt{ \textbar }} \ldots &amp; \rightsquigarrow &amp; a [x_{1}
\:= v_{1} ; \ldots ; x_{n} := v_{n}] \end{matrix} </span></p>
<p>If <span class="math inline">n = 0</span>, <span
class="math inline">C_{1}^n (v_{1}, \ldots, v_{n})</span> stands for
<span class="math inline">C^0_{1}</span>, etc. By <span
class="math inline">f (v_{1}, \ldots, v_{n})</span> we denote the actual
value resulting from computing the primitive. We omit the more complex
cases of pattern matching.</p></li>
<li><p>Rule variables: <span class="math inline">x</span> matches any
expression/pattern variable; <span class="math inline">a, a_{1},
\ldots, a_{n}</span> match any expression; <span class="math inline">v,
v_{1}, \ldots, v_{n}</span> match any value. Substitute them so that the
left-hand-side of a rule is your expression, then the right-hand-side is
the reduced expression.</p></li>
<li><p>The remaining rules evaluate the arguments in arbitrary order,
but keep the order in which <code>let</code>…<code>in</code> and
<code>match</code>…<code>with</code> is evaluated.</p>
<p>If <span class="math inline">a_{i} \rightsquigarrow
a_{i}&#39;</span>, then:</p>
<p><span class="math display"> \begin{matrix}
a_{1} a_{2} &amp; \rightsquigarrow &amp; a_{1}&#39; a_{2}\\\\\\
a_{1} a_{2} &amp; \rightsquigarrow &amp; a_{1} a_{2}&#39;\\\\\\
C^n (a_{1}, \ldots, a_{i}, \ldots, a_{n}) &amp; \rightsquigarrow &amp;
C^n
(a_{1}, \ldots, a_{i}&#39;, \ldots, a_{n})\\\\\\
{\texttt{let }} x = a_{1} {\texttt{ in }}
a_{2} &amp; \rightsquigarrow &amp; {\texttt{let }} x = a_{1}&#39;
{\texttt{ in }} a_{2}\\\\\\
{\texttt{match }} a_{1} {\texttt{ with} }
\operatorname{pm} &amp; \rightsquigarrow &amp; {\texttt{match }}
a_{1}&#39; {\texttt{ with} } \operatorname{pm} \end{matrix}
</span></p></li>
<li><p>Finally, we give the rule for the primitive <code>fix</code> – it
is a binary primitive:</p>
<p><span class="math display"> \begin{matrix}
{\texttt{fix}}^2 v_{1} v_{2} &amp; \rightsquigarrow &amp; v_{1}
\left( {\texttt{fix}}^2 v_{1} \right) v_{2} \end{matrix} </span></p>
<p>Because <code>fix</code> is binary, <span class="math inline">\left(
{\texttt{fix}}^2 v_{1}
\right)</span> is already a value so it will not be further computed
until it is applied inside of <span
class="math inline">v_{1}</span>.</p></li>
<li><p>Compute some programs using the rules by hand.</p></li>
</ul>
<h1 id="symbolic-derivation-example">3 Symbolic Derivation Example</h1>
<p>Go through the examples from the <code>Lec3.ml</code> file in the
toplevel.</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>eval_1_2 &lt;-- <span class="fl">3.00</span> * x + <span class="fl">2.00</span> * y + x * x * y</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>  eval_1_2 &lt;-- x * x * y</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    eval_1_2 &lt;-- y</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    eval_1_2 --&gt; <span class="dv">2</span>.</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>    eval_1_2 &lt;-- x * x</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>      eval_1_2 &lt;-- x</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>      eval_1_2 --&gt; <span class="dv">1</span>.</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>      eval_1_2 &lt;-- x</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>      eval_1_2 --&gt; <span class="dv">1</span>.</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>    eval_1_2 --&gt; <span class="dv">1</span>.</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>  eval_1_2 --&gt; <span class="dv">2</span>.</span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>  eval_1_2 &lt;-- <span class="fl">3.00</span> * x + <span class="fl">2.00</span> * y</span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>    eval_1_2 &lt;-- <span class="fl">2.00</span> * y</span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>      eval_1_2 &lt;-- y</span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>      eval_1_2 --&gt; <span class="dv">2</span>.</span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>      eval_1_2 &lt;-- <span class="fl">2.00</span></span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>      eval_1_2 --&gt; <span class="dv">2</span>.</span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>    eval_1_2 --&gt; <span class="dv">4</span>.</span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>    eval_1_2 &lt;-- <span class="fl">3.00</span> * x</span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a>      eval_1_2 &lt;-- x</span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a>      eval_1_2 --&gt; <span class="dv">1</span>.</span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a>      eval_1_2 &lt;-- <span class="fl">3.00</span></span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a>      eval_1_2 --&gt; <span class="dv">3</span>.</span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a>    eval_1_2 --&gt; <span class="dv">3</span>.</span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a>  eval_1_2 --&gt; <span class="dv">7</span>.</span>
<span id="cb38-26"><a href="#cb38-26" aria-hidden="true" tabindex="-1"></a>eval_1_2 --&gt; <span class="dv">9</span>.</span>
<span id="cb38-27"><a href="#cb38-27" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">float</span> = <span class="dv">9</span>.</span></code></pre></div>
<h1 id="tail-calls-and-tail-recursion">4 Tail Calls (and tail
recursion)</h1>
<ul>
<li>Excuse me for not defining what a <em>function call</em> is…</li>
<li>Computers normally evaluate programs by creating <em>stack
frames</em> on the stack for function calls (roughly like indentation
levels in the above example).</li>
<li>A <strong>tail call</strong> is a function call that is performed
last when computing a function.</li>
<li>Functional language compilers will often insert a “jump” for a tail
call instead of creating a stack frame.</li>
<li>A function is <strong>tail recursive</strong> if it calls itself,
and functions it mutually-recursively depends on, only using a tail
call.</li>
<li>Tail recursive functions often have special <em>accumulator</em>
arguments that store intermediate computation results which in a
non-tail-recursive function would just be values of subexpressions.</li>
<li>The accumulated result is computed in “reverse order” – while
climbing up the recursion rather than while descending (i.e. returning)
from it.</li>
<li>The issue is more complex for <em>lazy</em> programming languages
like Haskell.</li>
<li>Compare:</li>
</ul>
<div class="sourceCode" id="cb39"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> <span class="kw">rec</span> unfold n = <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> [] <span class="kw">else</span> n :: unfold (n<span class="dv">-1</span>);;</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> unfold : <span class="dt">int</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a># unfold <span class="dv">100000</span>;;</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> =</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>[<span class="dv">100000</span>; <span class="dv">99999</span>; <span class="dv">99998</span>; <span class="dv">99997</span>; <span class="dv">99996</span>; <span class="dv">99995</span>; <span class="dv">99994</span>; <span class="dv">99993</span>; …]</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a># unfold <span class="dv">1000000</span>;;</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a><span class="dt">Stack</span> overflow during evaluation (looping recursion?).</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> <span class="kw">rec</span> unfold_tcall acc n =</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> acc <span class="kw">else</span> unfold_tcall (n::acc) (n<span class="dv">-1</span>);;</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> unfold_tcall : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a># unfold_tcall [] <span class="dv">100000</span>;;</span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> =</span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">5</span>; <span class="dv">6</span>; <span class="dv">7</span>; <span class="dv">8</span>; <span class="dv">9</span>; <span class="dv">10</span>; <span class="dv">11</span>; <span class="dv">12</span>; <span class="dv">13</span>; <span class="dv">14</span>; <span class="dv">15</span>; <span class="dv">16</span>; <span class="dv">17</span>; <span class="dv">18</span>; …]</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a># unfold_tcall [] <span class="dv">1000000</span>;;</span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> =</span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">5</span>; <span class="dv">6</span>; <span class="dv">7</span>; <span class="dv">8</span>; <span class="dv">9</span>; <span class="dv">10</span>; <span class="dv">11</span>; <span class="dv">12</span>; <span class="dv">13</span>; <span class="dv">14</span>; <span class="dv">15</span>; <span class="dv">16</span>; <span class="dv">17</span>; <span class="dv">18</span>; …]</span></code></pre></div>
<ul>
<li>Is it possible to find the depth of a tree using a tail-recursive
function?</li>
</ul>
<h1 id="first-encounter-of-continuation-passing-style">5 First Encounter
of Continuation Passing Style</h1>
<p>We can postpone doing the actual work till the last moment:</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> depth tree k = <span class="kw">match</span> tree <span class="kw">with</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    | Tip -&gt; k <span class="dv">0</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    | Node(_,left,right) -&gt;</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>      depth left (<span class="kw">fun</span> dleft -&gt;</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>        depth right (<span class="kw">fun</span> dright -&gt;</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>          k (<span class="dv">1</span> + (<span class="dt">max</span> dleft dright))))</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> depth tree = depth tree (<span class="kw">fun</span> d -&gt; d)</span></code></pre></div>
<h1 id="homework-1">6 Homework</h1>
<p>By “traverse a tree” below we mean: write a function that takes a
tree and returns a list of values in the nodes of the tree.</p>
<ol type="1">
<li>Write a function (of type <code>btree -&gt; int list</code>) that
traverses a binary tree: in prefix order – first the value stored in a
node, then values in all nodes to the left, then values in all nodes to
the right;</li>
<li>in infix order – first values in all nodes to the left, then value
stored in a node, then values in all nodes to the right (so it is
“left-to-right” order);</li>
<li>in breadth-first order – first values in more shallow nodes.</li>
<li>Turn the function from ex. 1 or 2 into continuation passing
style.</li>
<li>Do the homework from the end of last week slides: write
<code>btree_deriv_at</code>.</li>
<li>Write a function <code>simplify: expression -&gt; expression</code>
that simplifies the expression a bit, so that for example the result of
<code>simplify (deriv  exp dv)</code> looks more like what a human would
get computing the derivative of <code>exp</code> with respect to
<code>dv</code>.
<ul>
<li>Write a <code>simplify_once</code> function that performs a single
step of the simplification, and wrap it using a general
<code>fixpoint</code> function that performs an operation until a
<em>fixed point</em> is reached: given <span
class="math inline">f</span> and <span class="math inline">x</span>, it
computes <span class="math inline">f^n (x)</span> such that <span
class="math inline">f^n (x) = f^{n + 1} (x)</span>.</li>
</ul></li>
</ol>
<p>Functional Programming</p>
<p>Computation</p>
<p><strong>Exercise 1:</strong> <span id="TravTreeEx"></span>By
“traverse a tree” below we mean: write a function that takes a tree and
returns a list of values in the nodes of the tree.</p>
<ol type="1">
<li><em>Write a function (of type</em>
<code>*btree -&gt; int list*</code><em>) that traverses a binary tree:
in prefix order – first the value stored in a node, then values in all
nodes to the left, then values in all nodes to the right;</em></li>
<li><em>in infix order – first values in all nodes to the left, then
value stored in a node, then values in all nodes to the right (so it is
“left-to-right” order);</em></li>
<li><em>in breadth-first order – first values in more shallow
nodes.</em></li>
</ol>
<p><strong>Exercise 2:</strong> Turn the function from ex. <a
href="#TravTreeEx">1</a> point 1 or 2 into continuation passing
style.</p>
<p><strong>Exercise 3:</strong> Do the homework from the end of last
week slides: write <code>btree_deriv_at</code>.</p>
<p><strong>Exercise 4:</strong> Write a function
<code>simplify: expression -&gt; expression</code> that simplifies the
expression a bit, so that for example the result of
<code>simplify  (deriv exp dv)</code> looks more like what a human would
get computing the derivative of <code>exp</code> with respect to
<code>dv</code>:</p>
<p><em>Write a <code>simplify_once</code> function that performs a
single step of the simplification, and wrap it using a general
<code>fixpoint</code> function that performs an operation until a
</em>fixed point* is reached: given <span class="math inline">f</span>
and <span class="math inline">x</span>, it computes <span
class="math inline">f^n (x)</span> such that <span
class="math inline">f^n (x) = f^{n + 1} (x)</span>.*</p>
<p><strong>Exercise 5:</strong> Write two sorting algorithms, working on
lists: merge sort and quicksort.</p>
<ol type="1">
<li><em>Merge sort splits the list roughly in half, sorts the parts, and
merges the sorted parts into the sorted result.</em></li>
<li><em>Quicksort splits the list into elements smaller/greater than the
first element, sorts the parts, and puts them together.</em></li>
</ol>
<p>Lecture 4: Functions.</p>
<p>Programming in untyped <span
class="math inline">\lambda</span>-calculus.</p>
<p><em>Introduction to Lambda Calculus</em> Henk Barendregt, Erik
Barendsen</p>
<p><em>Lecture Notes on the Lambda Calculus</em> Peter Selinger</p>
<h1 id="review-a-computation-by-hand-example">1 Review: a “computation
by hand” example</h1>
<p>Let’s compute some larger, recursive program.Recall that we use fix
instead of let rec to simplify rules for recursion. Also remember our
syntactic conventions: <code>fun x y -&gt; e</code> stands for
<code>fun x -&gt; (fun y -&gt; e)</code>, etc.</p>
<p>let rec fix f x = f (fix f) xPreparations.type intlist = Nil | Cons
of int * intlistWe will evaluate (reduce) the following expression.let
length = fix (fun f l -&gt; match l with | Nil -&gt; 0 | Cons (x, xs)
-&gt; 1 + f xs) inlength (Cons (1, (Cons (2, Nil))))</p>
<p>let length = fix (fun f l -&gt; match l with | Nil -&gt; 0 | Cons (x,
xs) -&gt; 1 + f xs) inlength (Cons (1, (Cons (2, Nil))))</p>
<p><span class="math display"> \begin{matrix}
  {\texttt{let }} x = v {\texttt{ in }} a &amp;
  \Downarrow &amp; a [x := v]
\end{matrix} </span></p>
<p>fix (fun f l -&gt; match l with | Nil -&gt; 0 | Cons (x, xs) -&gt; 1
+ f xs) (Cons (1, (Cons (2, Nil))))</p>
<p><span class="math display"> \begin{matrix}
  {\texttt{fix}}^2 v_{1} v_{2} &amp;
  \Downarrow &amp; v_{1}  \left(
  {\texttt{fix}}^2 v_{1} \right) v_{2}
\end{matrix} </span></p>
<p><span class="math display"> \begin{matrix}
  {\texttt{fix}}^2 v_{1} v_{2} &amp;
  \Downarrow &amp; v_{1}  \left(
  {\texttt{fix}}^2 v_{1} \right) v_{2}
\end{matrix} </span></p>
<p>(fun f l -&gt; match l with | Nil -&gt; 0 | Cons (x, xs) -&gt; 1 + f
xs) (fix (fun f l -&gt; match l with | Nil -&gt; 0 | Cons (x, xs) -&gt;
1 + f xs)) (Cons (1, (Cons (2, Nil))))</p>
<p><span class="math display"> \begin{matrix}
  \left( {\texttt{fun }} x {\texttt{-&gt;}} a
  \right) v &amp; \rightsquigarrow &amp; a [x := v]\\\\\\
  a_{1} a_{2} &amp; \Downarrow &amp;
  a_{1}&#39; a_{2}
\end{matrix} </span></p>
<p><span class="math display"> \begin{matrix}
  \left( {\texttt{fun }} x {\texttt{-&gt;}} a
  \right) v &amp; \rightsquigarrow &amp; a [x := v]\\\\\\
  a_{1} a_{2} &amp; \Downarrow &amp;
  a_{1}&#39; a_{2}
\end{matrix} </span></p>
<p>(fun l -&gt; match l with | Nil -&gt; 0 | Cons (x, xs) -&gt; 1 + (fix
(fun f l -&gt; match l with | Nil -&gt; 0<br />
| Cons (x, xs) -&gt; 1 + f xs)) xs) (Cons (1, (Cons (2, Nil))))</p>
<p><span class="math display"> \begin{matrix}
  \left( {\texttt{fun }} x {\texttt{-&gt;}} a
  \right) v &amp; \Downarrow &amp; a [x :=
  v]
\end{matrix} </span></p>
<p><span class="math display"> \begin{matrix}
  \left( {\texttt{fun }} x {\texttt{-&gt;}} a
  \right) v &amp; \Downarrow &amp; a [x :=
  v]
\end{matrix} </span></p>
<p>(match Cons (1, (Cons (2, Nil))) with | Nil -&gt; 0 | Cons (x, xs)
-&gt; 1 + (fix (fun f l -&gt; match l with | Nil -&gt; 0<br />
| Cons (x, xs) -&gt; 1 + f xs)) xs)</p>
<p><span class="math display"> \begin{matrix}
  {\texttt{match }} C_{1}^n (v_{1}, \ldots, v_{n})
  {\texttt{ with}} &amp;  &amp;  \\\\\\
  C_{2}^n (p_{1}, \ldots, p_{k}) {\texttt{-&gt;}} a
  {\texttt{ \textbar }} \operatorname{pm} &amp;
  \Downarrow &amp;
  {\texttt{match }} C_{1}^n (v_{1}, \ldots, v_{n})\\\\\\
  &amp;  &amp; {\texttt{with} } \operatorname{pm}
\end{matrix} </span></p>
<p><span class="math display"> \begin{matrix}
  {\texttt{match }} C_{1}^n (v_{1}, \ldots, v_{n})
  {\texttt{ with}} &amp;  &amp;  \\\\\\
  C_{2}^n (p_{1}, \ldots, p_{k}) {\texttt{-&gt;}} a
  {\texttt{ \textbar }} \operatorname{pm} &amp;
  \Downarrow &amp;
  {\texttt{match }} C_{1}^n (v_{1}, \ldots, v_{n})\\\\\\
  &amp;  &amp; {\texttt{with} } \operatorname{pm}
\end{matrix} </span></p>
<p>(match Cons (1, (Cons (2, Nil))) with | Cons (x, xs) -&gt; 1 + (fix
(fun f l -&gt; match l with | Nil -&gt; 0 | Cons (x, xs) -&gt; 1 + f
xs)) xs)</p>
<p><span class="math display"> \begin{matrix}
  {\texttt{match }} C_{1}^n (v_{1}, \ldots, v_{n})
  {\texttt{ with}} &amp;  &amp;  \\\\\\
  C_{1}^n (x_{1}, \ldots, x_{n}) {\texttt{-&gt;}} a
  {\texttt{ \textbar }} \ldots &amp;
  \Downarrow &amp; a [x_{1} := v_{1}
  ; \ldots ; x_{n} := v_{n}]
\end{matrix} </span></p>
<p><span class="math display"> \begin{matrix}
  {\texttt{match }} C_{1}^n (v_{1}, \ldots, v_{n})
  {\texttt{ with}} &amp;  &amp;  \\\\\\
  C_{1}^n (x_{1}, \ldots, x_{n}) {\texttt{-&gt;}} a
  {\texttt{ \textbar }} \ldots &amp;
  \Downarrow &amp; a [x_{1} := v_{1}
  ; \ldots ; x_{n} := v_{n}]
\end{matrix} </span></p>
<p>1 + (fix (fun f l -&gt; match l with | Nil -&gt; 0 | Cons (x, xs)
-&gt; 1 + f xs)) (Cons (2, Nil))</p>
<p><span class="math display"> \begin{matrix}
  {\texttt{fix}}^2 v_{1} v_{2} &amp; \rightsquigarrow &amp; v_{1}
  \left( {\texttt{fix}}^2 v_{1} \right) v_{2}\\\\\\
  a_{1} a_{2} &amp; \Downarrow &amp;
  a_{1} a_{2}&#39;
\end{matrix} </span></p>
<p><span class="math display"> \begin{matrix}
  {\texttt{fix}}^2 v_{1} v_{2} &amp; \rightsquigarrow &amp; v_{1}
  \left( {\texttt{fix}}^2 v_{1} \right) v_{2}\\\\\\
  a_{1} a_{2} &amp; \Downarrow &amp;
  a_{1} a_{2}&#39;
\end{matrix} </span></p>
<p>1 + (fun f l -&gt; match l with | Nil -&gt; 0 | Cons (x, xs) -&gt; 1
+ f xs)) (fix (fun f l -&gt; match l with | Nil -&gt; 0 | Cons (x, xs)
-&gt; 1 + f xs)) (Cons (2, Nil))</p>
<p><span class="math display"> \begin{matrix}
  \left( {\texttt{fun }} x {\texttt{-&gt;}} a
  \right) v &amp; \rightsquigarrow &amp; a [x := v]\\\\\\
  a_{1} a_{2} &amp; \Downarrow &amp;
  a_{1} a_{2}&#39;
\end{matrix} </span></p>
<p><span class="math display"> \begin{matrix}
  \left( {\texttt{fun }} x {\texttt{-&gt;}} a
  \right) v &amp; \rightsquigarrow &amp; a [x := v]\\\\\\
  a_{1} a_{2} &amp; \Downarrow &amp;
  a_{1} a_{2}&#39;
\end{matrix} </span></p>
<p>1 + (fun l -&gt; match l with | Nil -&gt; 0 | Cons (x, xs) -&gt; 1 +
(fix (fun f l -&gt; match l with<br />
| Nil -&gt; 0 | Cons (x, xs) -&gt; 1 + f xs)) xs))<br />
(Cons (2, Nil))</p>
<p><span class="math display"> \begin{matrix}
  \left( {\texttt{fun }} x {\texttt{-&gt;}} a
  \right) v &amp; \rightsquigarrow &amp; a [x := v]\\\\\\
  a_{1} a_{2} &amp; \Downarrow &amp;
  a_{1} a_{2}&#39;
\end{matrix} </span></p>
<p><span class="math display"> \begin{matrix}
  \left( {\texttt{fun }} x {\texttt{-&gt;}} a
  \right) v &amp; \rightsquigarrow &amp; a [x := v]\\\\\\
  a_{1} a_{2} &amp; \Downarrow &amp;
  a_{1} a_{2}&#39;
\end{matrix} </span></p>
<p>1 + (match Cons (2, Nil) with | Nil -&gt; 0 | Cons (x, xs) -&gt; 1 +
(fix (fun f l -&gt; match l with | Nil -&gt; 0 | Cons (x, xs) -&gt; 1 +
f xs)) xs))</p>
<p><span class="math display"> \begin{matrix}
  {\texttt{match }} C_{1}^n (v_{1}, \ldots, v_{n})
  {\texttt{ with}} &amp;  &amp;  \\\\\\
  C_{2}^n (p_{1}, \ldots, p_{k}) {\texttt{-&gt;}} a
  {\texttt{ \textbar }} \operatorname{pm} &amp; \rightsquigarrow &amp;
  {\texttt{match }} C_{1}^n (v_{1}, \ldots, v_{n})\\\\\\
  &amp;  &amp; {\texttt{with} } \operatorname{pm}\\\\\\
  a_{1} a_{2} &amp; \Downarrow &amp;
  a_{1} a_{2}&#39;
\end{matrix} </span></p>
<p><span class="math display"> \begin{matrix}
  {\texttt{match }} C_{1}^n (v_{1}, \ldots, v_{n})
  {\texttt{ with}} &amp;  &amp;  \\\\\\
  C_{2}^n (p_{1}, \ldots, p_{k}) {\texttt{-&gt;}} a
  {\texttt{ \textbar }} \operatorname{pm} &amp; \rightsquigarrow &amp;
  {\texttt{match }} C_{1}^n (v_{1}, \ldots, v_{n})\\\\\\
  &amp;  &amp; {\texttt{with} } \operatorname{pm}\\\\\\
  a_{1} a_{2} &amp; \Downarrow &amp;
  a_{1} a_{2}&#39;
\end{matrix} </span></p>
<p>1 + (match Cons (2, Nil) with | Cons (x, xs) -&gt; 1 + (fix (fun f l
-&gt; match l with | Nil -&gt; 0 | Cons (x, xs) -&gt; 1 + f xs)) xs)</p>
<p><span class="math display"> \begin{matrix}
  {\texttt{match }} C_{1}^n (v_{1}, \ldots, v_{n})
  {\texttt{ with}} &amp;  &amp;  \\\\\\
  C_{1}^n (x_{1}, \ldots, x_{n}) {\texttt{-&gt;}} a
  {\texttt{ \textbar }} \ldots &amp;
  \Downarrow &amp; a [x_{1} := v_{1}
  ; \ldots ; x_{n} := v_{n}]\\\\\\
  &amp;  &amp;
\end{matrix} </span></p>
<p><span class="math display"> \begin{matrix}
  {\texttt{match }} C_{1}^n (v_{1}, \ldots, v_{n})
  {\texttt{ with}} &amp;  &amp;  \\\\\\
  C_{1}^n (x_{1}, \ldots, x_{n}) {\texttt{-&gt;}} a
  {\texttt{ \textbar }} \ldots &amp; \rightsquigarrow &amp; a [x_{1}
  \:= v_{1} ; \ldots ; x_{n} := v_{n}]\\\\\\
  a_{1} a_{2} &amp; \Downarrow &amp;
  a_{1} a_{2}&#39;
\end{matrix} </span></p>
<p>1 + (1 + (fix (fun f l -&gt; match l with | Nil -&gt; 0 | Cons (x,
xs) -&gt; 1 + f xs)) Nil)</p>
<p><span class="math display"> \begin{matrix}
  {\texttt{fix}}^2 v_{1} v_{2} &amp; \rightsquigarrow &amp; v_{1}
  \left( {\texttt{fix}}^2 v_{1} \right) v_{2}\\\\\\
  a_{1} a_{2} &amp; \Downarrow &amp;
  a_{1} a_{2}&#39;\\\\\\
  a_{1} a_{2} &amp; \Downarrow &amp;
  a_{1} a_{2}&#39;
\end{matrix} </span></p>
<p><span class="math display"> \begin{matrix}
  {\texttt{fix}}^2 v_{1} v_{2} &amp; \rightsquigarrow &amp; v_{1}
  \left( {\texttt{fix}}^2 v_{1} \right) v_{2}\\\\\\
  a_{1} a_{2} &amp; \Downarrow &amp;
  a_{1} a_{2}&#39;\\\\\\
  a_{1} a_{2} &amp; \Downarrow &amp;
  a_{1} a_{2}&#39;
\end{matrix} </span></p>
<p>1 + (1 + (fun f l -&gt; match l with | Nil -&gt; 0 | Cons (x, xs)
-&gt; 1 + f xs) (fix (fun f l -&gt;<br />
match l with | Nil -&gt; 0 | Cons (x, xs) -&gt; 1 + f xs)) Nil)</p>
<p><span class="math display"> \begin{matrix}
  \left( {\texttt{fun }} x {\texttt{-&gt;}} a
  \right) v &amp; \rightsquigarrow &amp; a [x := v]\\\\\\
  a_{1} a_{2} &amp; \Downarrow &amp;
  a_{1} a_{2}&#39;\\\\\\
  a_{1} a_{2} &amp; \Downarrow &amp;
  a_{1} a_{2}&#39;
\end{matrix} </span></p>
<p><span class="math display"> \begin{matrix}
  \left( {\texttt{fun }} x {\texttt{-&gt;}} a
  \right) v &amp; \rightsquigarrow &amp; a [x := v]\\\\\\
  a_{1} a_{2} &amp; \Downarrow &amp;
  a_{1} a_{2}&#39;\\\\\\
  a_{1} a_{2} &amp; \Downarrow &amp;
  a_{1} a_{2}&#39;
\end{matrix} </span></p>
<p>1 + (1 + (fun l -&gt; match l with | Nil -&gt; 0 | Cons (x, xs) -&gt;
1 + (fix (fun f l -&gt;<br />
match l with | Nil -&gt; 0 | Cons (x, xs) -&gt; 1 + f xs)) xs) Nil)</p>
<p><span class="math display"> \begin{matrix}
  \left( {\texttt{fun }} x {\texttt{-&gt;}} a
  \right) v &amp; \rightsquigarrow &amp; a [x := v]\\\\\\
  a_{1} a_{2} &amp; \Downarrow &amp;
  a_{1} a_{2}&#39;\\\\\\
  a_{1} a_{2} &amp; \Downarrow &amp;
  a_{1} a_{2}&#39;
\end{matrix} </span></p>
<p><span class="math display"> \begin{matrix}
  \left( {\texttt{fun }} x {\texttt{-&gt;}} a
  \right) v &amp; \rightsquigarrow &amp; a [x := v]\\\\\\
  a_{1} a_{2} &amp; \Downarrow &amp;
  a_{1} a_{2}&#39;\\\\\\
  a_{1} a_{2} &amp; \Downarrow &amp;
  a_{1} a_{2}&#39;
\end{matrix} </span></p>
<p>1 + (1 + (match Nil with | Nil -&gt; 0 | Cons (x, xs) -&gt; 1 + (fix
(fun f l -&gt; match l with<br />
| Nil -&gt; 0 | Cons (x, xs) -&gt; 1 + f xs)) xs))</p>
<p><span class="math display"> \begin{matrix}
  {\texttt{match }} C_{1}^n (v_{1}, \ldots, v_{n})
  {\texttt{ with}} &amp;  &amp;  \\\\\\
  C_{1}^n (x_{1}, \ldots, x_{n}) {\texttt{-&gt;}} a
  {\texttt{ \textbar }} \ldots &amp; \rightsquigarrow &amp; a [x_{1}
  \:= v_{1} ; \ldots ; x_{n} := v_{n}]\\\\\\
  a_{1} a_{2} &amp; \Downarrow &amp;
  a_{1} a_{2}&#39;\\\\\\
  a_{1} a_{2} &amp; \Downarrow &amp;
  a_{1} a_{2}&#39;
\end{matrix} </span></p>
<p><span class="math display"> \begin{matrix}
  {\texttt{match }} C_{1}^n (v_{1}, \ldots, v_{n})
  {\texttt{ with}} &amp;  &amp;  \\\\\\
  C_{1}^n (x_{1}, \ldots, x_{n}) {\texttt{-&gt;}} a
  {\texttt{ \textbar }} \ldots &amp; \rightsquigarrow &amp; a [x_{1}
  \:= v_{1} ; \ldots ; x_{n} := v_{n}]\\\\\\
  a_{1} a_{2} &amp; \Downarrow &amp;
  a_{1} a_{2}&#39;\\\\\\
  a_{1} a_{2} &amp; \Downarrow &amp;
  a_{1} a_{2}&#39;
\end{matrix} </span></p>
<p>1 + (1 + 0)</p>
<p><span class="math display"> \begin{matrix}
  f^n v_{1} \ldots v_{n} &amp; \rightsquigarrow &amp; f (v_{1}, \ldots,
  v_{n})\\\\\\
  a_{1} a_{2} &amp; \Downarrow &amp;
  a_{1} a_{2}&#39;
\end{matrix} </span></p>
<p>1 + 1</p>
<p><span class="math display"> \begin{matrix}
  f^n v_{1} \ldots v_{n} &amp;
  \Downarrow &amp; f (v_{1}, \ldots,
  v_{n})
\end{matrix} </span></p>
<p>2</p>
<h1 id="language-and-rules-of-the-untyped-lambda-calculus">2 Language
and rules of the untyped <span
class="math inline">\lambda</span>-calculus</h1>
<ul>
<li><p>First, let’s forget about types.</p></li>
<li><p>Next, let’s introduce a shortcut:</p>
<ul>
<li>We write <span class="math inline">\lambda x.a</span> for
<code>fun x-&gt;a</code>, <span class="math inline">\lambda x y.a</span>
for <code>fun x  y-&gt;a</code>, etc.</li>
</ul></li>
<li><p>Let’s forget about all other constructions, only fun and
variables.</p></li>
<li><p>The real <span class="math inline">\lambda</span>-calculus has a
more general reduction:</p>
<p><span class="math display"> \begin{matrix}
\left( {\texttt{fun }} x {\texttt{-&gt;}}
a_{1} \right) a_{2} &amp; \rightsquigarrow &amp; a_{1} [x := a_{2}]
\end{matrix} </span></p>
<p>(called <em><span class="math inline">\beta</span>-reduction</em>)
and uses <em>bound variable renaming</em> (called <em><span
class="math inline">\alpha</span>-conversion</em>), or some other trick,
to avoid <em>variable capture</em>. But let’s not over-complicate
things.</p>
<ul>
<li>We will look into the <span
class="math inline">\beta</span>-reduction rule in the
<strong>laziness</strong> lecture.</li>
<li>Why is <span class="math inline">\beta</span>-reduction more general
than the rule we use?</li>
</ul></li>
</ul>
<h1 id="booleans">3 Booleans</h1>
<ul>
<li>Alonzo Church introduced <span
class="math inline">\lambda</span>-calculus to encode logic.</li>
<li>There are multiple ways to encode various sorts of data in <span
class="math inline">\lambda</span>-calculus. Not all of them make sense
in a typed setting, i.e. the straightforward encode/decode functions do
not type-check for them.</li>
<li>Define <code>c_true</code>=<span class="math inline">\lambda x
y.x</span> and <code>c_false</code>=<span class="math inline">\lambda x
y.y</span>.</li>
<li>Define <code>c_and</code>=<span class="math inline">\lambda x y.x y
{\texttt{c\_false}}</span>. Check that it works!
<ul>
<li>I.e. that <code>c_and c_true c_true</code> =
<code>c_true</code>,otherwise <code>c_and a b</code> =
<code>c_false</code>.</li>
</ul></li>
</ul>
<p>let ctrue = fun x y -&gt; x‘‘True’’ is projection on the first
argument.let cfalse = fun x y -&gt; yAnd ‘‘false’’ on the second
argument.let cand = fun x y -&gt; x y cfalseIf one is false, then return
false.let encodebool b = if b then ctrue else cfalselet decodebool c = c
true falseTest the functions in the toplevel.</p>
<ul>
<li>Define <code>c_or</code> and <code>c_not</code> yourself!</li>
</ul>
<h1 id="if-then-else-and-pairs">4 If-then-else and pairs</h1>
<ul>
<li>We will just use the OCaml syntax from now.</li>
</ul>
<p>let ifthenelse = fun b -&gt; bBooleans select the argument!</p>
<p>Remember to play with the functions in the toplevel.</p>
<p>let cpair m n = fun x -&gt; x m nWe couple thingslet cfirst = fun p
-&gt; p ctrueby passing them together.let csecond = fun p -&gt; p
cfalseCheck that it works!</p>
<p>let encodepair encfst encsnd (a, b) = cpair (encfst a) (encsnd b)let
decodepair defst desnd c = c (fun x y -&gt; defst x, desnd y)let
decodeboolpair c = decodepair decodebool decodebool c</p>
<ul>
<li><p>We can define larger tuples in the same manner:</p>
<p>let ctriple l m n = fun x -&gt; x l m n</p></li>
</ul>
<h1 id="pair-encoded-natural-numbers">5 Pair-encoded natural
numbers</h1>
<ul>
<li>Our first encoding of natural numbers is as the depth of nested
pairs whose rightmost leaf is <span class="math inline">\lambda
x.x</span> and whose left elements are <code>c_false</code>.</li>
</ul>
<p>let pn0 = fun x -&gt; xStart with the identity function.let pnsucc n
= cpair cfalse nStack another pair.let pnpred = fun x -&gt; x
cfalse[Explain these functions.]let pniszero = fun x -&gt; x ctrue</p>
<p>We program in untyped lambda calculus as an exercise, and we need
encoding / decoding to verify our exercises, so using “magic” for
encoding / decoding is “fair game”.</p>
<p>let rec encodepnat n =We use Obj.<code>magic</code> to forget types.
if n <span class="math inline">&lt;</span>= 0 then Obj.magic pn0 else
pnsucc (Obj.magic (encodepnat (n-1)))Disregarding types,let rec
decodepnat pn =these functions are straightforward! if decodebool
(pniszero pn) then 0 else 1 + decodepnat (pnpred (Obj.magic pn))</p>
<h1 id="church-numerals-natural-numbers-in-ch.-enc.">6 Church numerals
(natural numbers in Ch. enc.)</h1>
<ul>
<li>Do you remember our function <code>power f n</code>? We will use its
variant for a different representation of numbers:</li>
</ul>
<p>let cn0 = fun f x -&gt; xThe same as <code>c_false</code>.let cn1 =
fun f x -&gt; f xBehaves like identity.let cn2 = fun f x -&gt; f (f
x)let cn3 = fun f x -&gt; f (f (f x))</p>
<ul>
<li>This is the original Alonzo Church encoding.</li>
</ul>
<p>let cnsucc = fun n f x -&gt; f (n f x)</p>
<ul>
<li>Define addition, multiplication, comparing to zero, and the
predecesor function “-1” for Church numerals.</li>
<li>Turns out even Alozno Church couldn’t define predecesor right away!
But try to make some progress before you turn to the next slide.
<ul>
<li>His student Stephen Kleene found it.</li>
</ul></li>
</ul>
<p>let rec encodecnat n f = if n <span class="math inline">&lt;</span>=
0 then (fun x -&gt; x) else f -| encodecnat (n-1) flet decodecnat n = n
((+) 1) 0let cn7 f x = encodecnat 7 f xWe need to <em><span
class="math inline">\eta</span>-expand</em> these definitionslet cn13 f
x = encodecnat 13 f xfor type-system reasons.(Because OCaml allows
<em>side-effects</em>.)let cnadd = fun n m f x -&gt; n f (m f x)Put
<code>n</code> of <code>f</code> in front.let cnmult = fun n m f -&gt; n
(m f)Repeat <code>n</code> timesputting <code>m</code> of <code>f</code>
in front.let cnprev n =<br />
fun f x -&gt;This is the ‘‘Church numeral signature’‘. nThe only thing
we have is an <code>n</code>-step loop. (fun g v -&gt; v (g f))We need
sth that operates on <code>f</code>. (fun z-&gt;x)We need to ignore the
innermost step.<br />
(fun z-&gt;z)We’ve build a ‘‘machine’’ not results – start the
machine.</p>
<p><code>cn_is_zero</code> left as an exercise.</p>
<p>decodecnat (cn_prev cn3)</p>
<p><span class="math display"> \Downarrow </span></p>
<p>(cn_prev cn3) ((+) 1) 0</p>
<p><span class="math display"> \Downarrow </span></p>
<p>(fun f x -&gt; cn3 (fun g v -&gt; v (g f)) (fun z-&gt;x)<br />
(fun z-&gt;z)) ((+) 1) 0</p>
<p><span class="math display"> \Downarrow </span></p>
<p>((fun f x -&gt; f (f (f x))) (fun g v -&gt; v (g ((+) 1))) (fun
z-&gt;0) (fun z-&gt;z))</p>
<p><span class="math display"> \Downarrow </span></p>
<p>((fun g v -&gt; v (g ((+) 1))) ((fun g v -&gt; v (g ((+) 1))) ((fun g
v -&gt; v (g ((+) 1))) (fun z-&gt;0)))) (fun z-&gt;z))</p>
<p><span class="math display"> \Downarrow </span></p>
<p>((fun z-&gt;z) (((fun g v -&gt; v (g ((+) 1))) ((fun g v -&gt; v (g
((+) 1))) (fun z-&gt;0)))) ((+) 1)))</p>
<p><span class="math display"> \Downarrow </span></p>
<p>(fun g v -&gt; v (g ((+) 1))) ((fun g v -&gt; v (g ((+) 1))) (fun
z-&gt;0)) ((+) 1)</p>
<p><span class="math display"> \Downarrow </span></p>
<p>((+) 1) ((fun g v -&gt; v (g ((+) 1))) (fun z-&gt;0) ((+) 1))</p>
<p><span class="math display"> \Downarrow </span></p>
<p>((+) 1) (((+) 1) ((fun z-&gt;0) ((+) 1)))</p>
<p><span class="math display"> \Downarrow </span></p>
<p>((+) 1) (((+) 1) (0))</p>
<p><span class="math display"> \Downarrow </span></p>
<p>((+) 1) 1</p>
<p><span class="math display"> \Downarrow </span></p>
<p>2</p>
<h1 id="recursion-fixpoint-combinator">7 Recursion: Fixpoint
Combinator</h1>
<ul>
<li><p>Turing’s fixpoint combinator: <span class="math inline">\Theta =
(\lambda x y.y (x x y))  (\lambda x
y.y (x x y))</span></p>
<p><span class="math display"> \begin{matrix}
N &amp; = &amp; \Theta F\\\\\\
&amp; = &amp; (\lambda x y.y (x x y))  (\lambda x y.y (x x y)) F\\\\\\
&amp; =_{\rightarrow \rightarrow} &amp; F ((\lambda x y.y (x x
y))  (\lambda x y.y
(x x y)) F)\\\\\\
&amp; = &amp; F (\Theta F) = F N \end{matrix} </span></p></li>
<li><p>Curry’s fixpoint combinator: <span
class="math inline">\boldsymbol{Y}= \lambda f. (\lambda x.f (x x))
(\lambda x.f (x x))</span></p>
<p><span class="math display"> \begin{matrix}
N &amp; = &amp; \boldsymbol{Y}F\\\\\\
&amp; = &amp; (\lambda f. (\lambda x.f (x x))  (\lambda x.f (x x)))
F\\\\\\
&amp; =_{\rightarrow} &amp; (\lambda x.F (x x))  (\lambda x.F (x
x))\\\\\\
&amp; =_{\rightarrow} &amp; F ((\lambda x.F (x x))  (\lambda x.F (x
x)))\\\\\\
&amp; =_{\leftarrow} &amp; F ((\lambda f. (\lambda x.f (x x))  (\lambda
x.f (x
x))) F)\\\\\\
&amp; = &amp; F (\boldsymbol{Y}F) = F N \end{matrix} </span></p></li>
<li><p>Call-by-value <em>fix</em>point combinator: <span
class="math inline">\lambda f&#39; . (\lambda f x.f&#39;  (f f) x)
(\lambda f x.f&#39;  (f f) x)</span></p>
<p><span class="math display"> \begin{matrix}
N &amp; = &amp; \operatorname{fix}F\\\\\\
&amp; = &amp; (\lambda f&#39; . (\lambda f x.f&#39;  (f f) x)  (\lambda
f x.f&#39;  (f f) x))
F\\\\\\
&amp; =_{\rightarrow} &amp; (\lambda f x.F (f f) x)  (\lambda f x.F (f
f) x)\\\\\\
&amp; =_{\rightarrow} &amp; \lambda x.F ((\lambda f x.F (f f)
x)  (\lambda f x.F
(f f) x)) x\\\\\\
&amp; =_{\leftarrow} &amp; \lambda x.F ((\lambda f&#39; . (\lambda f
x.f&#39;  (f f) x)
(\lambda f x.f&#39;  (f f) x)) F) x\\\\\\
&amp; = &amp; \lambda x.F (\operatorname{fix}F) x = \lambda x.F N
x\\\\\\
&amp; =_{\eta} &amp; F N \end{matrix} </span></p></li>
<li><p>The <span class="math inline">\lambda</span>-terms we have seen
above are <strong>fixpoint combinators</strong> – means inside <span
class="math inline">\lambda</span>-calculus to perform
recursion.</p></li>
<li><p>What is the problem with the first two combinators?</p>
<p><span class="math display"> \begin{matrix}
\Theta F &amp; \rightsquigarrow \rightsquigarrow &amp; F ((\lambda x y.y
(x x y))
(\lambda x y.y (x x y)) F)\\\\\\
&amp; \rightsquigarrow \rightsquigarrow &amp; F (F ((\lambda x y.y (x x
y))
(\lambda x y.y (x x y)) F))\\\\\\
&amp; \rightsquigarrow \rightsquigarrow &amp; F (F (F ((\lambda x y.y (x
x y))
(\lambda x y.y (x x y)) F)))\\\\\\
&amp; \rightsquigarrow \rightsquigarrow &amp; \ldots \end{matrix}
</span></p></li>
<li><p>Recall the distinction between <em>expressions</em> and
<em>values</em> from the previous lecture <em>Computation</em>.</p></li>
<li><p>The reduction rule for <span
class="math inline">\lambda</span>-calculus is just meant to determine
which expressions are considered “equal” – it is highly
<em>non-deterministic</em>, while on a computer, computation needs to go
one way or another.</p></li>
<li><p>Using the general reduction rule of <span
class="math inline">\lambda</span>-calculus, for a recursive definition,
it is always possible to find an infinite reduction sequence (which
means that you couldn’t complain when a nasty <span
class="math inline">\lambda</span>-calculus compiler generates infinite
loops for all recursive definitions).</p>
<ul>
<li>Why?</li>
</ul></li>
<li><p>Therefore, we need more specific rules. For example, most
languages use <span class="math inline">\left( {\texttt{fun }} x
{\texttt{-&gt;}}
a \right) v \rightsquigarrow a [x := v]</span>, which is called
<em>call-by-value</em>, or <strong>eager</strong> computation (because
the program <em>eagerly</em> computes the arguments before starting to
compute the function). (It’s exactly the rule we introduced in
<em>Computation</em> lecture.)</p></li>
<li><p>What happens with call-by-value fixpoint combinator?</p>
<p><span class="math display"> \begin{matrix}
\operatorname{fix}F &amp; \rightsquigarrow &amp; (\lambda f x.F (f f)
x)  (\lambda f
x.F (f f) x)\\\\\\
&amp; \rightsquigarrow &amp; \lambda x.F ((\lambda f x.F (f f)
x)  (\lambda f x.F
(f f) x)) x \end{matrix} </span></p>
<p>Voila – if we use <span class="math inline">\left( {\texttt{fun }} x
{\texttt{-&gt;}} a \right) v \rightsquigarrow a [x := v]</span> as the
rulerather than <span class="math inline">\left( {\texttt{fun }} x
{\texttt{-&gt;}} a_{1} \right) a_{2} \rightsquigarrow
a_{1} [x := a_{2}]</span>, the computation stops. Let’s compute the
function on some input:</p>
<p><span class="math display"> \begin{matrix}
\operatorname{fix}F v &amp; \rightsquigarrow &amp; (\lambda f x.F (f f)
x)  (\lambda
f x.F (f f) x) v\\\\\\
&amp; \rightsquigarrow &amp; (\lambda x.F ((\lambda f x.F (f f)
x)  (\lambda f x.F
(f f) x)) x) v\\\\\\
&amp; \rightsquigarrow &amp; F ((\lambda f x.F (f f) x)  (\lambda f x.F
(f f) x))
v\\\\\\
&amp; \rightsquigarrow &amp; F (\lambda x.F ((\lambda f x.F (f f)
x)  (\lambda f
x.F (f f) x)) x) v\\\\\\
&amp; \rightsquigarrow &amp; \text{depends on } F \end{matrix}
</span></p></li>
<li><p>Why the name <em>fixpoint</em>? If you look at our derivations,
you’ll see that they show what in math can be written as <span
class="math inline">x = f (x)</span>. Such values <span
class="math inline">x</span> are called fixpoints of <span
class="math inline">f</span>. An arithmetic function can have several
fixpoints, for example <span class="math inline">f (x) = x^2</span>
(which <span class="math inline">x</span>es are fixpoints?) or no
fixpoints, for example <span class="math inline">f (x) = x +
1</span>.</p></li>
<li><p>When you define a function (or another object) by recursion, it
has very similar meaning: there is a name that is on both sides of <span
class="math inline">=</span>.</p></li>
<li><p>In <span class="math inline">\lambda</span>-calculus, there are
functions like <span class="math inline">\Theta</span> and <span
class="math inline">\boldsymbol{Y}</span>, that take <em>any</em>
function as an argument, and return its fixpoint.</p></li>
<li><p>We turn a specification of a recursive object into a definition,
by solving it with respect to the recurring name: deriving <span
class="math inline">x = f (x)</span> where <span
class="math inline">x</span> is the recurring name. We then have <span
class="math inline">x =\operatorname{fix} (f)</span>.</p></li>
<li><p>Let’s walk through it for the factorial function (we omit the
prefix <code>cn_</code> – could be <code>pn_</code> if <code>pn1</code>
was used instead of <code>cn1</code> – for numeric functions, and we
shorten <code>if_then_else</code> into <code>if_t_e</code>):</p>
<p><span class="math display"> \begin{matrix}
{\texttt{fact}} n &amp; = &amp; {\texttt{if\_t\_e}}
\left( {\texttt{is\_zero}} n \right)
{\texttt{cn1}}  \left( {\texttt{mult}} n
\left( {\texttt{fact}}  \left(
{\texttt{pred}} n \right) \right) \right)\\\\\\
{\texttt{fact}} &amp; = &amp; \lambda n.
{\texttt{if\_t\_e}}  \left(
{\texttt{is\_zero}} n \right)
{\texttt{cn1}}  \left( {\texttt{mult}} n
\left( {\texttt{fact}}  \left(
{\texttt{pred}} n \right) \right) \right)\\\\\\
{\texttt{fact}} &amp; = &amp; \left( \lambda f n.
{\texttt{if\_t\_e}}  \left(
{\texttt{is\_zero}} n \right)
{\texttt{cn1}}  \left( {\texttt{mult}} n
\left( f \left( {\texttt{pred}} n \right) \right) \right)
\right)  {\texttt{fact}}\\\\\\
{\texttt{fact}} &amp; = &amp; \operatorname{fix} \left( \lambda f n.
{\texttt{if\_t\_e}}  \left(
{\texttt{is\_zero}} n \right)
{\texttt{cn1}}  \left( {\texttt{mult}} n
\left( f \left( {\texttt{pred}} n \right) \right) \right)
\right) \end{matrix} </span></p>
<p>The last specification is a valid definition: we just give a name to
a (<em>ground</em>, a.k.a. <em>closed</em>) expression.</p></li>
<li><p>We have seen how fix works already!</p>
<ul>
<li>Compute <code>fact cn2</code>.</li>
</ul></li>
<li><p>What does <code>fix (fun x -&gt; cn_succ x)</code> mean?</p></li>
</ul>
<h1 id="encoding-of-lists-and-trees">8 Encoding of Lists and Trees</h1>
<ul>
<li><p>A list is either empty, which we often call <code>Empty</code> or
<code>Nil</code>, or it consists of an element followed by another list
(called “tail”), the other case often called <code>Cons</code>.</p></li>
<li><p>Define <code>nil</code><span class="math inline">= \lambda x
y.y</span> and <code>cons</code><span class="math inline">H T = \lambda
x y.x H T</span>.</p></li>
<li><p>Add numbers stored inside a list:</p>
<p><span class="math display"> \begin{matrix}
{\texttt{addlist}} l &amp; = &amp; l \left( \lambda h t.
{\texttt{cn\_add}} h \left(
{\texttt{addlist}} t \right) \right)
{\texttt{cn0}} \end{matrix} </span></p>
<p>To make a proper definition, we need to apply <span
class="math inline">\operatorname{fix}</span> to the solution of above
equation.</p>
<p><span class="math display"> \begin{matrix}
{\texttt{addlist}} &amp; = &amp; \operatorname{fix} \left( \lambda f
l.l \left( \lambda h t. {\texttt{cn\_add}} h (f t) \right)
{\texttt{cn0}} \right) \end{matrix} </span></p></li>
<li><p>For trees, let’s use a different form of binary trees than so
far: instead of keeping elements in inner nodes, we will keep elements
in leaves.</p></li>
<li><p>Define <code>leaf</code><span class="math inline">n = \lambda x
y.x n</span> and <code>node</code><span class="math inline">L R =
\lambda x y.y L R</span>.</p></li>
<li><p>Add numbers stored inside a tree:</p>
<p><span class="math display"> \begin{matrix}
{\texttt{addtree}} t &amp; = &amp; t (\lambda n.n)  \left( \lambda l
r. {\texttt{cn\_add}}  \left(
{\texttt{addtree}} l \right)  \left(
{\texttt{addtree}} r \right) \right) \end{matrix} </span></p>
<p>and, in solved form:</p>
<p><span class="math display"> \begin{matrix}
{\texttt{addtree}} &amp; = &amp; \operatorname{fix} \left( \lambda f
t.t (\lambda n.n)  \left( \lambda l r. {\texttt{cn\_add}}
(f l)  (f r) \right) \right) \end{matrix} </span></p></li>
</ul>
<p>let nil = fun x y -&gt; ylet cons h t = fun x y -&gt; x h tlet
addlist l =<br />
fix (fun f l -&gt; l (fun h t -&gt; cnadd h (f t)) cn0)
l;;decodecnat<br />
(addlist (cons cn1 (cons cn2 (cons cn7 nil))));;let leaf n = fun x y
-&gt; x nlet node l r = fun x y -&gt; y l rlet addtree t = fix (fun f t
-&gt; t (fun n -&gt; n) (fun l r -&gt; cnadd (f l) (f r)) )
t;;decodecnat (addtree (node (node (leaf cn3) (leaf cn7)) (leaf
cn1)));;</p>
<ul>
<li><p>Observe a regularity: when we encode a variant type with <span
class="math inline">n</span> variants, for each variant we define a
function that takes <span class="math inline">n</span>
arguments.</p></li>
<li><p>If the <span class="math inline">k</span>th variant <span
class="math inline">C_{k}</span> has <span
class="math inline">m_{k}</span> parameters, then the function <span
class="math inline">c_{k}</span> that encodes it will have the form:</p>
<p><span class="math display"> C_{k} (v_{1}, \ldots, v_{m_{k}}) \sim
c_{k} v_{1} \ldots
v_{m_{k}}
= \lambda x_{1} \ldots x_{n} .x_{k} v_{1} \ldots v_{m_{k}}
</span></p></li>
<li><p>The encoded variants serve as a shallow pattern matching with
guaranteed exhaustiveness: <span class="math inline">k</span>th argument
corresponds to <span class="math inline">k</span>th branch of pattern
matching.</p></li>
</ul>
<h1 id="looping-recursion">9 Looping Recursion</h1>
<ul>
<li>Let’s come back to numbers defined as lengths lists and define
addition:</li>
</ul>
<p>let pnadd m n = fix (fun f m n -&gt; ifthenelse (pniszero m) n
(pnsucc (f (pnpred m) n)) ) m n;;decodepnat (pnadd pn3 pn3);;</p>
<ul>
<li>Oops… OCaml
says:<code>Stack overflow during evaluation (looping  recursion?).</code></li>
<li>What is wrong? Nothing as far as <span
class="math inline">\lambda</span>-calculus is concerned. But OCaml and
F# always compute arguments before calling a function. By definition of
fix, <code>f</code> corresponds to recursively calling
<code>pn_add</code>. Therefore,(pnsucc (f (pnpred m) n)) will be called
regardless of what(pniszero m) returns!</li>
<li>Why <code>addlist</code> and <code>addtree</code> work?</li>
<li><code>addlist</code> and <code>addtree</code> work because their
recursive calls are “guarded” by corresponding fun. What is inside of
fun is not computed immediately, only when the function is applied to
argument(s).</li>
<li>To avoid looping recursion, you need to guard all recursive calls.
Besides putting them inside fun, in OCaml or F# you can also put them in
branches of a match clause, as long as one of the branches does not have
unguarded recursive calls!</li>
<li>The trick to use with functions like <code>if_then_else</code>, is
to guard their arguments with fun <code>x</code> -&gt;, where
<code>x</code> is not used, and apply the <em>result</em> of
<code>if_then_else</code> to some dummy value.
<ul>
<li>In OCaml or F# we would guard by fun () -&gt;, and then apply to (),
but we do not have datatypes like <code>unit</code> in <span
class="math inline">\lambda</span>-calculus.</li>
</ul></li>
</ul>
<p>let pnadd m n = fix (fun f m n -&gt; (ifthenelse (pniszero m) (fun x
-&gt; n) (fun x -&gt; pnsucc (f (pnpred m) n))) id ) m n;;decodepnat
(pnadd pn3 pn3);;decodepnat (pnadd pn3 pn7);;</p>
<h1 id="in-class-work-and-homework">10 In-class Work and Homework</h1>
<p>Define (implement) and verify: 1. <code>c_or</code> and
<code>c_not</code>; 1. exponentiation for Church numerals; 1. is-zero
predicate for Church numerals; 1. even-number predicate for Church
numerals; 1. multiplication for pair-encoded natural numbers; 1.
factorial <span class="math inline">n!</span> for pair-encoded natural
numbers. 1. Construct <span class="math inline">\lambda</span>-terms
<span class="math inline">m_{0}, m_{1}, \ldots</span> such that for all
<span class="math inline">n</span> one has:</p>
<p><span class="math display"> \begin{matrix}
   m_{0} &amp; = &amp; x \\\\\\
   m_{n + 1} &amp; = &amp; m_{n + 2} m_{n} \end{matrix} </span></p>
<p>(where equality is after performing <span
class="math inline">\beta</span>-reductions). 1. Define (implement) and
verify a function computing: the length of a list (in Church numerals);
1. <code>cn_max</code> – maximum of two Church numerals; 1. the depth of
a tree (in Church numerals). 1. Representing side-effects as an
explicitly “passed around” state value, write combinators that represent
the imperative constructs: 1. for…to… 1. for…downto… 1. while…do… 1.
do…while… 1. repeat…until…</p>
<p>Rather than writing a <span class="math inline">\lambda</span>-term
using the encodings that we’ve learnt, just implement the functions in
OCaml / F#, using built-in int and bool types. You can use let rec
instead of fix. * For example, in exercise (a), write a function let rec
<code>for_to f beg_i       end_i s</code> =… where <code>f</code> takes
arguments <code>i</code> ranging from <code>beg_i</code> to
<code>end_i</code>, state <code>s</code> at given step, and returns
state <code>s</code> at next step; the <code>for_to</code> function
returns the state after the last step. * And in exercise (c), write a
function let rec <code>while_do p f s</code> =… where both
<code>p</code> and <code>f</code> take state <code>s</code> at given
step, and if <code>p s</code> returns true, then <code>f s</code> is
computed to obtain state at next step; the <code>while_do</code>
function returns the state after the last step.</p>
<p>Do not use the imperative features of OCaml and F#, we will not even
cover them in this course!</p>
<p>Although we will not cover them, it is instructive to see the
implementation using the imperative features, to better understand what
is actually required of a solution to the last exercise.</p>
<ol type="1">
<li>let forto f begi endi s = let s = ref s in for i = begi to endi
do<br />
s := f i !s done; !s</li>
<li>let fordownto f begi endi s = let s = ref s in for i = begi downto
endi do s := f i !s done; !s</li>
<li>let whiledo p f s = let s = ref s in while p !s do s := f !s
done;<br />
!s</li>
<li>let dowhile p f s = let s = ref (f s) in while p !s do s := f
!s<br />
done; !s</li>
<li>let repeatuntil p f s = let s = ref (f s) in while not (p !s) do s
:= f !s done; !s</li>
</ol>
<p>Functional Programming</p>
<p>Functions</p>
<p><strong>Exercise 1:</strong> Define (implement) and test on a couple
of examples functions corresponding to / computing:</p>
<ol type="1">
<li><code>*c_or*</code> <em>and</em> <code>*c_not*</code>;</li>
<li><em>exponentiation for Church numerals;</em></li>
<li><em>is-zero predicate for Church numerals;</em></li>
<li><em>even-number predicate for Church numerals;</em></li>
<li><em>multiplication for pair-encoded natural numbers;</em></li>
<li><em>factorial</em> <span class="math inline">n!</span> <em>for
pair-encoded natural numbers.</em></li>
<li><em>the length of a list (in Church numerals);</em></li>
<li><code>*cn_max*</code> <em>– maximum of two Church
numerals;</em></li>
<li><em>the depth of a tree (in Church numerals).</em></li>
</ol>
<p><strong>Exercise 2:</strong> Representing side-effects as an
explicitly “passed around” state value, write (higher-order) functions
that represent the imperative constructs:</p>
<ol type="1">
<li>*for<strong>…</strong>to**…*</li>
<li>*for<strong>…</strong>downto**…*</li>
<li>*while<strong>…</strong>do**…*</li>
<li>*do<strong>…</strong>while**…*</li>
<li>*repeat<strong>…</strong>until**…*</li>
</ol>
<p><em>Rather than writing a <span
class="math inline">\lambda</span>-term using the encodings that we’ve
learnt, just implement the functions in OCaml / F#, using built-in int
and bool types. You can use let rec instead of fix.</em></p>
<ul>
<li><em>For example, in exercise (a), write a function</em> <em>let
rec</em> <code>*for_to f beg_i end_i s*</code> =<em>… where</em>
<code>*f*</code> <em>takes arguments</em> <code>*i*</code> <em>ranging
from</em> <code>*beg_i*</code> <em>to</em> <code>*end_i*</code><em>,
state</em> <code>*s*</code> <em>at given step, and returns state</em>
<code>*s*</code> <em>at next step; the</em> <code>*for_to*</code>
<em>function returns the state after the last step.</em></li>
<li><em>And in exercise (c), write a function</em> <em>let rec</em>
<code>*while_do p f s*</code> =<em>… where both</em> <code>*p*</code>
<em>and</em> <code>*f*</code> <em>take state</em> <code>*s*</code>
<em>at given step, and if</em> <code>*p s*</code> <em>returns true,
then</em> <code>*f s*</code> <em>is computed to obtain state at next
step; the</em> <code>*while_do*</code> <em>function returns the state
after the last step.</em></li>
</ul>
<p><em>Do not use the imperative features of OCaml and F#, we will not
even cover them in this course!</em></p>
<p>Despite we will not cover them, it is instructive to see the
implementation using the imperative features, to better understand what
is actually required of a solution to this exercise.</p>
<ol type="1">
<li>let forto f begi endi s = let s = ref s in for i = begi to endi
do<br />
s := f i !s done; !s</li>
<li>let fordownto f begi endi s = let s = ref s in for i = begi downto
endi do s := f i !s done; !s</li>
<li>let whiledo p f s = let s = ref s in while p !s do s := f !s
done;<br />
!s</li>
<li>let dowhile p f s = let s = ref (f s) in while p !s do s := f
!s<br />
done; !s</li>
<li>let repeatuntil p f s = let s = ref (f s) in while not (p !s) do s
:= f !s done; !s</li>
</ol>
<p>Lecture 5: Polymorphism &amp; ADTs</p>
<p>Parametric types. Abstract Data Types.</p>
<p>Example: maps using red-black trees.</p>
<p>If you see any error on the slides, let me know!</p>
<h1 id="type-inference">1 Type Inference</h1>
<p>We have seen the rules that govern the assignment of types to
expressions, but how does OCaml guess what types to use, and when no
correct types exist? It solves equations.</p>
<ul>
<li>Variables play two roles: of <em>unknowns</em> and of
<em>parameters</em>.
<ul>
<li><p>Inside:</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> f = <span class="dt">List</span>.hd;;</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : &#39;a <span class="dt">list</span> -&gt; &#39;a</span></code></pre></div>
<p><code>'a</code> is a parameter: it can become any type.
Mathematically we write: <span class="math inline">f :
\forall \alpha . \alpha \operatorname{list} \rightarrow \alpha</span> –
the quantified type is called a <em>type scheme</em>.</p></li>
<li><p>Inside:</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> x = <span class="dt">ref</span> [];;</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> x : &#39;a <span class="dt">list</span> <span class="dt">ref</span></span></code></pre></div>
<p><code>'_a</code> is an unknown. It stands for a particular type like
float or (int -&gt; int), OCaml just doesn’t yet know the type.</p></li>
<li><p>OCaml only reports unknowns like <code>'_a</code> in inferred
types for reasons not relevant to functional programming. When unknowns
appear in inferred type against our expectations, <em><span
class="math inline">\eta</span>-expansion</em> may help: writing let f x
= expr x instead of let f = expr – for example:</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> f = <span class="dt">List</span>.append [];;</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> f l = <span class="dt">List</span>.append [] l;;</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div></li>
</ul></li>
<li>A <em>type environment</em> specifies what names (corresponding to
parameters and definitions) are available for an expression, because
they were introduced above it, and it specifies their types.</li>
<li>Type inference solves equations over unknowns. “What has to hold so
that <span class="math inline">e : \tau</span> in type environment <span
class="math inline">\Gamma</span>?”
<ul>
<li>If, for example, <span class="math inline">f : \forall \alpha .
\alpha \operatorname{list}
\rightarrow \alpha \in \Gamma</span>, then for <span
class="math inline">f : \tau</span> we introduce <span
class="math inline">\gamma
\operatorname{list} \rightarrow \gamma = \tau</span> for some fresh
unknown <span class="math inline">\gamma</span>.</li>
<li>For <span class="math inline">e_{1} e_{2} : \tau</span> we introduce
<span class="math inline">\beta = \tau</span> and ask for <span
class="math inline">e_{1} : \gamma \rightarrow \beta</span> and <span
class="math inline">e_{2} : \gamma</span>, for some fresh unknowns <span
class="math inline">\beta, \gamma</span>.</li>
<li>For <span class="math inline">\operatorname{fun}x \rightarrow e :
\tau</span> we introduce <span class="math inline">\beta
\rightarrow \gamma = \tau</span> and ask for <span class="math inline">e
: \gamma</span> in environment <span class="math inline">\lbrace x :
\beta \rbrace \cup \Gamma</span>, for some fresh unknowns <span
class="math inline">\beta,
\gamma</span>.</li>
<li>Case <span class="math inline">\operatorname{let}x = e_{1}
\operatorname{in}e_{2} : \tau</span> is different. One approach is to
<em>first</em> solve the equations that we get by asking for <span
class="math inline">e_{1} : \beta</span>, for some fresh unknown <span
class="math inline">\beta</span>. Let’s say a solution <span
class="math inline">\beta = \tau_{\beta}</span> has been found, <span
class="math inline">\alpha_{1} \ldots
\alpha_{n} \beta_{1} \ldots \beta_{m}</span> are the remaining unknowns
in <span class="math inline">\tau_{\beta}</span>, and <span
class="math inline">\alpha_{1} \ldots \alpha_{n}</span> are all that do
not appear in <span class="math inline">\Gamma</span>. Then we ask for
<span class="math inline">e_{2} : \tau</span> in environment <span
class="math inline">\lbrace x : \forall \alpha_{1} \ldots \alpha_{n} .
\tau_{\beta}
\rbrace \cup \Gamma</span>.</li>
<li>Remember that whenever we establish a solution <span
class="math inline">\beta = \tau_{\beta}</span> to an unknown <span
class="math inline">\beta</span>, it takes effect everywhere!</li>
<li>To find a type for <span class="math inline">e</span> (in
environment <span class="math inline">\Gamma</span>), we pick a fresh
unknown <span class="math inline">\beta</span> and ask for <span
class="math inline">e : \beta</span> (in <span
class="math inline">\Gamma</span>).</li>
</ul></li>
<li>The “top-level” definitions for which the system infers types with
variables are called <em>polymorphic</em>, which informally means
“working with different shapes of data”.
<ul>
<li>This kind of polymorphism is called <em>parametric
polymorphism</em>, since the types have parameters. A different kind of
polymorphism is provided by object-oriented programming languages.</li>
</ul></li>
</ul>
<h1 id="parametric-types">2 Parametric Types</h1>
<ul>
<li><p>Polymorphic functions shine when used with polymorphic data
types. In:</p>
<p>type ’a mylist = Empty | Cons of ’a * ’a mylist</p>
<p>we define lists that can store elements of any type <code>'a</code>.
Now:</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> tail l =  <span class="kw">match</span> l <span class="kw">with</span>    | Empty -&gt; invalidarg <span class="st">&quot;tail&quot;</span>    | Cons </span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>(, tl) -&gt; tl;;      <span class="kw">val</span> tail : &#39;a mylist -&gt; &#39;a mylist</span></code></pre></div>
<p>is a polymorphic function: works for lists with elements of any
type.</p></li>
<li><p>A <em>parametric type</em> like ’a mylist <em>is not</em> itself
a data type but a family of data types: bool mylist, int mylist etc.
<em>are</em> different types.</p>
<ul>
<li>We say that the type int mylist <em>instantiates</em> the parametric
type ’a mylist.</li>
</ul></li>
<li><p>In OCaml, the syntax is a bit confusing: type parameters precede
type name. For example:</p>
<p>type (’a, ’b) choice = Left of ’a | Right of ’b</p>
<p>has two parameters. Mathematically we would write <span
class="math inline">\operatorname{choice}
(\alpha, \beta)</span>.</p>
<ul>
<li><p>Functions do not have to be polymorphic:</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> getint c =  <span class="kw">match</span> c <span class="kw">with</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>    | Left i -&gt; i</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>    | Right b -&gt; <span class="kw">if</span> b <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>;;</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> getint : (<span class="dt">int</span>, <span class="dt">bool</span>) choice -&gt; <span class="dt">int</span></span></code></pre></div></li>
</ul></li>
<li><p>In F#, we provide parameters (when more than one) after type
name:</p>
<p>type choice&lt;<code>'a,'</code>b&gt; = Left of <code>'a</code> |
<code>Right of</code> ’b</p></li>
<li><p>In Haskell, we provide type parameters similarly to function
arguments:</p>
<p>data Choice a b = Left a | Right b</p></li>
</ul>
<h1 id="type-inference-formally">3 Type Inference, Formally</h1>
<ul>
<li><p>A statement that an expression has a type in an environment is
called a <em>type judgement</em>. For environment <span
class="math inline">\Gamma = \lbrace x : \forall \alpha
_{1} \ldots \alpha_{n} . \tau_{x} ; \ldots \rbrace</span>, expression
<span class="math inline">e</span> and type <span
class="math inline">\tau</span> we write</p>
<p><span class="math display">\Gamma \vdash e : \tau</span></p></li>
<li><p>We will derive the equations in one go using <span
class="math inline">[\![ \cdot ]\!]</span>, to be solved later. Besides
equations we will need to manage introduced variables, using existential
quantification.</p></li>
<li><p>For local definitions we require to remember what constraints
should hold when the definition is used. Therefore we extend <em>type
schemes</em> in the environment to: <span class="math inline">\Gamma =
\lbrace x : \forall \beta_{1} \ldots \beta_{m}
[\exists \alpha_{1} \ldots \alpha_{n} .D] . \tau_{x} ; \ldots
\rbrace</span> where <span class="math inline">D</span> are equations –
keeping the variables <span class="math inline">\alpha_{1} \ldots \alpha
_{n}</span> introduced while deriving <span class="math inline">D</span>
in front.</p>
<ul>
<li>A simpler form would be enough: <span class="math inline">\Gamma =
\lbrace x : \forall \beta
[\exists \alpha_{1} \ldots \alpha_{n} .D] . \beta ; \ldots
\rbrace</span></li>
</ul></li>
</ul>
<p><span class="math display"> \begin{matrix}
  [\![ \Gamma \vdash x : \tau ]\!] &amp; = &amp; \exists
\overline{\beta&#39;}
  \bar{\alpha}&#39; . (D [\bar{\beta} \bar{\alpha} :=
\overline{\beta&#39;}
  \bar{\alpha}&#39;] \wedge \tau_{x} [\bar{\beta} \bar{\alpha} :=
  \overline{\beta&#39;} \bar{\alpha}&#39;] \dot{=} \tau)\\\\\\
  &amp;  &amp; \text{where } \Gamma (x) = \forall \bar{\beta} [\exists
\bar{\alpha}
  .D] . \tau_{x}, \overline{\beta&#39;} \bar{\alpha}&#39;
\#\operatorname{FV}
  (\Gamma, \tau)\\\\\\
  &amp;  &amp;  \\\\\\
  [\![ \Gamma \vdash \boldsymbol{\operatorname{fun}} x
  {\texttt{-&gt;}} e : \tau ]\!] &amp; = &amp; \exists
\alpha
_{1} \alpha_{2} . ([\![ \Gamma \lbrace x : \alpha_{1} \rbrace
  \vdash e : \alpha_{2} ]\!] \wedge \alpha_{1} \rightarrow \alpha
_{2} \dot{=} \tau),\\\\\\
  &amp;  &amp; \text{where } \alpha_{1} \alpha_{2} \#\operatorname{FV}
(\Gamma,
  \tau)\\\\\\
  &amp;  &amp;  \\\\\\
  [\![ \Gamma \vdash e_{1} e_{2} : \tau ]\!] &amp; = &amp; \exists
  \alpha . ([\![ \Gamma \vdash e_{1} : \alpha \rightarrow \tau
  ]\!] \wedge [\![ \Gamma \vdash e_{2} : \alpha ]\!]),
  \alpha \#\operatorname{FV} (\Gamma, \tau)\\\\\\
  &amp;  &amp;  \\\\\\
  [\![ \Gamma \vdash K e_{1} \ldots e_{n} : \tau ]\!] &amp; = &amp;
  \exists \bar{\alpha}&#39; . (\wedge_{i} [\![ \Gamma \vdash e_{i} :
\tau
_{i} [\bar{\alpha} := \bar{\alpha}&#39;] ]\!] \wedge \varepsilon
  (\bar{\alpha}&#39;) \dot{=} \tau),\\\\\\
  &amp;  &amp; \text{w. } K \,:\, \forall \bar{\alpha} . \tau_{1} \times
\ldots
  \times \tau_{n} \rightarrow \varepsilon (\bar{\alpha}),
\bar{\alpha}&#39;
  \#\operatorname{FV} (\Gamma, \tau)\\\\\\
  &amp;  &amp;  \\\\\\
  [\![ \Gamma \vdash e : \tau ]\!] &amp; = &amp; (\exists \beta .C)
\wedge
  [\![ \Gamma \lbrace x : \forall \beta [C] . \beta \rbrace \vdash
  e_{2} : \tau ]\!]\\\\\\
  e = \boldsymbol{\operatorname{let}} x = e_{1}
  \boldsymbol{\operatorname{in}} e_{2} &amp;  &amp; \text{where } C =
  [\![ \Gamma \vdash e_{1} : \beta ]\!]\\\\\\
  &amp;  &amp;  \\\\\\
  [\![ \Gamma \vdash e : \tau ]\!] &amp; = &amp; (\exists \beta .C)
\wedge
  [\![ \Gamma \lbrace x : \forall \beta [C] . \beta \rbrace \vdash
  e_{2} : \tau ]\!]\\\\\\
  e = \boldsymbol{\operatorname{letrec}} x = e_{1}
  \boldsymbol{\operatorname{in}} e_{2} &amp;  &amp; \text{where } C =
  [\![ \Gamma \lbrace x : \beta \rbrace \vdash e_{1} : \beta
  ]\!]\\\\\\
  &amp;  &amp;  \\\\\\
  [\![ \Gamma \vdash e : \tau ]\!] &amp; = &amp; \exists \alpha_{v} .
  [\![ \Gamma \vdash e_{v} : \alpha_{v} ]\!] \wedge_{i}
  [\![ \Gamma \vdash p_{i} .e_{i} : \alpha_{v} \rightarrow \tau
  ]\!],\\\\\\
  e = \boldsymbol{\operatorname{match}} e_{v}
  \boldsymbol{\operatorname{with}} \bar{c} &amp;  &amp; \alpha_{v}
  \#\operatorname{FV} (\Gamma, \tau)\\\\\\
  \bar{c} = p_{1} .e_{1} | \ldots |p_{n} .e_{n} &amp;  &amp;  \\\\\\
  &amp;  &amp;  \\\\\\
  [\![ \Gamma, \Sigma \vdash p.e : \tau_{1} \rightarrow \tau_{2}
  ]\!] &amp; = &amp; [\![ \Sigma \vdash p \downarrow \tau_{1} ]\!]
  \wedge \exists \bar{\beta} . [\![ \Gamma \Gamma&#39; \vdash e :
\tau_{2}
  ]\!]\\\\\\
  &amp;  &amp; \text{where } \exists \bar{\beta} \Gamma&#39; \text{ is }
[\![
  \Sigma \vdash p \uparrow \tau_{1} ]\!], \bar{\beta}
  \#\operatorname{FV} (\Gamma, \tau_{2})\\\\\\
  &amp;  &amp;  \\\\\\
  [\![ \Sigma \vdash p \downarrow \tau_{1} ]\!] &amp;  &amp;
  \text{derives constraints on type of matched value}\\\\\\
  &amp;  &amp;  \\\\\\
  [\![ \Sigma \vdash p \uparrow \tau_{1} ]\!] &amp;  &amp; \text{derives
  environment for pattern variables}
\end{matrix} </span></p>
<ul>
<li>By <span class="math inline">\bar{\alpha}</span> or <span
class="math inline">\overline{\alpha_{i}}</span> we denote a sequence of
some length: <span class="math inline">\alpha_{1} \ldots
\alpha_{n}</span></li>
<li>By <span class="math inline">\wedge_{i} \varphi_{i}</span> we denote
a conjunction of <span
class="math inline">\overline{\varphi_{i}}</span>: <span
class="math inline">\varphi_{1} \ldots \varphi_{n}</span>.</li>
</ul>
<h2 id="polymorphic-recursion">3.1 Polymorphic Recursion</h2>
<ul>
<li>Note the limited polymorphism of let rec f = … – we cannot use
<code>f</code> polymorphically in its definition.
<ul>
<li>In modern OCaml we can bypass the problem if we provide type of
<code>f</code> upfront: let rec f : ’a. ’a -&gt; ’a list = …</li>
<li>where ’a. ’a -&gt; ’a list stands for <span
class="math inline">\forall \alpha . \alpha
\rightarrow \alpha \operatorname{list}</span>.</li>
</ul></li>
<li>Using the recursively defined function with different types in its
definition is called polymorphic recursion.</li>
<li>It is most useful together with irregular recursive datatypes where
the recursive use has different type arguments than the actual
parameters.</li>
</ul>
<h3
id="polymorphic-rec-a-list-alternating-between-two-types-of-elements">3.1.1
Polymorphic Rec: A list alternating between two types of elements</h3>
<p>type (’x, ’o) alterning =| Stop| One of ’x * (’o, ’x) alterninglet
rec tolist : ’x ’o ’a. (’x-&gt;’a) -&gt; (’o-&gt;’a) -&gt; (’x, ’o)
alterning -&gt; ’a list = fun x2a o2a -&gt; function | Stop -&gt; [] |
One (x, rest) -&gt; x2a x::tolist o2a x2a restlet tochoicelist alt =
tolist (fun x-&gt;Left x) (fun o-&gt;Right o) altlet it = tochoicelist
(One (1, One (“o”, One (2, One (“oo”, Stop)))))</p>
<h3 id="polymorphic-rec-data-structural-bootstrapping">3.1.2 Polymorphic
Rec: Data-Structural Bootstrapping</h3>
<p>type ’a seq = Nil | Zero of (’a * ’a) seq | One of ’a * (’a * ’a)
seqWe store a list of elements in exponentially increasing chunks.let
example = One (0, One ((1,2), Zero (One ((((3,4),(5,6)),
((7,8),(9,10))), Nil))))let rec cons : ’a. ’a -&gt; ’a seq -&gt; ’a seq
= fun x -&gt; functionAppending an element to the datastructure is like
| Nil -&gt; One (x, Nil)adding one to a binary number: 1+0=1 | Zero ps
-&gt; One (x, ps)1+…0=…1 | One (y, ps) -&gt; Zero (cons (x,y)
ps)1+…1=[…+1]0let rec lookup : ’a. int -&gt; ’a seq -&gt; ’a = fun i s
-&gt; match i, s withRather than returning <code>None : 'a option</code>
| , Nil -&gt; raise Notfoundwe raise exception, for convenience. | 0,
One (x, ) -&gt; x | i, One (, ps) -&gt; lookup (i-1) (Zero ps) | i, Zero
ps -&gt;Random-Access lookup works let x, y = lookup (i / 2) ps inin
logarithmic time – much faster than if i mod 2 = 0 then x else yin
standard lists.</p>
<h1 id="algebraic-specification">4 Algebraic Specification</h1>
<ul>
<li>The way we introduce a data structure, like complex numbers or
strings, in mathematics, is by specifying an <em>algebraic
structure</em>.</li>
<li>Algebraic structures consist of a set (or several sets, for
so-called <em>multisorted</em> algebras) and a bunch of functions (aka.
operations) over this set (or sets).</li>
<li>A <em>signature</em> is a rough description of an algebraic
structure: it provides sorts – names for the sets (in multisorted case)
and names of the functions-operations together with their arity (and
what sorts of arguments they take).</li>
<li>We select a class of algebraic structures by providing axioms that
have to hold. We will call such classes <em>algebraic
specifications</em>.
<ul>
<li>In mathematics, a rusty name for some algebraic specifications is a
<em>variety</em>, a more modern and name is <em>algebraic
category</em>.</li>
</ul></li>
<li>Algebraic structures correspond to “implementations” and signatures
to “interfaces” in programming languages.</li>
<li>We will say that an algebraic structure implements an algebraic
specification when all axioms of the specification hold in the
structure.</li>
<li>All algebraic specifications are implemented by multiple
structures!</li>
<li>We say that an algebraic structure does not have junk, when all its
elements (i.e. elements in the sets corresponding to sorts) can be built
using operations in its signature.</li>
<li>We allow parametric types as sorts. In that case, strictly speaking,
we define a family of algebraic specifications (a different
specification for each instantiation of the parametric type).</li>
</ul>
<h2 id="algebraic-specifications-examples">4.1 Algebraic specifications:
examples</h2>
<ul>
<li>An algebraic specification can also use an earlier
specification.</li>
<li>In “impure” languages like OCaml and F# we allow that the result of
any operation be an <span
class="math inline">\operatorname{error}</span>. In Haskell we could use
<code>Maybe</code>.</li>
</ul>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
</tbody>
</table>
<table style="display: inline-table; vertical-align: 
middle">
<tbody>
<tr>
<td>
</td>
</tr>
<tr>
<td>
uses ,
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
</tbody>
</table>
<h1 id="homomorphisms">5 Homomorphisms</h1>
<ul>
<li>Mappings between algebraic structures with the same signature
preserving operations.</li>
<li>A <em>homomorphism</em> from algebraic structure <span
class="math inline">(A, \lbrace f^A, g^A, \ldots
\rbrace)</span> to <span class="math inline">(B, \lbrace f^B, g^B,
\ldots \rbrace)</span> is a function <span class="math inline">h : A
\rightarrow B</span> such that <span class="math inline">h (f^A (a_{1},
\ldots, a_{n_{f}})) = f^B (h
(a_{1}), \ldots, h (a_{n_{f}}))</span> for all <span
class="math inline">(a_{1}, \ldots, a_{n_{f}})</span>, <span
class="math inline">h (g^A (a_{1}, \ldots, a_{n_{g}})) = g^B (h (a_{1}),
\ldots, h
(a_{n_{g}}))</span> for all <span class="math inline">(a_{1}, \ldots,
a_{n_{g}})</span>, …</li>
<li>Two algebraic structures are <em>isomorphic</em> if there are
homomorphisms <span class="math inline">h_{1} : A \rightarrow B, h_{2} :
B \rightarrow A</span> from one to the other and back, that when
composed in any order form identity: <span class="math inline">\forall
(b \in B)
h_{1} (h_{2} (b)) = b</span>, <span class="math inline">\forall (a \in
A) h_{2} (h_{1} (a)) = a</span>.</li>
<li>An algebraic specification whose all implementations without junk
are isomorphic is called “<em>monomorphic</em>”.
<ul>
<li>We usually only add axioms that really matter to us to the
specification, so that the implementations have room for optimization.
For this reason, the resulting specifications will often not be
monomorphic in the above sense.</li>
</ul></li>
</ul>
<h1 id="example-maps">6 Example: Maps</h1>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
, or
</td>
</tr>
<tr>
<td>
uses , type parameters
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
, ,
</td>
</tr>
<tr>
<td>
</td>
</tr>
</tbody>
</table>
<h1 id="modules-and-interfaces-signatures-syntax">7 Modules and
interfaces (signatures): syntax</h1>
<ul>
<li>In the ML family of languages, structures are given names by
<strong>module</strong> bindings, and signatures are types of
modules.</li>
<li>From outside of a structure or signature, we refer to the values or
types it provides with a dot notation: <code>Module.value</code>.</li>
<li>Module (and module type) names have to start with a capital letter
(in ML languages).</li>
<li>Since modules and module types have names, there is a tradition to
name the central type of a signature (the one that is “specified” by the
signature), for brevity, <code>t</code>.</li>
<li>Module types are often named with “all-caps” (all letters upper
case).</li>
</ul>
<p>module type MAP = sig type (’a, ’b) t val empty : (’a, ’b) t val
member : ’a -&gt; (’a, ’b) t -&gt; bool val add : ’a -&gt; ’b -&gt; (’a,
’b) t -&gt; (’a, ’b) t val remove : ’a -&gt; (’a, ’b) t -&gt; (’a, ’b) t
val find : ’a -&gt; (’a, ’b) t -&gt; ’bendmodule ListMap : MAP = struct
type (’a, ’b) t = (’a * ’b) list let empty = [] let member =
List.memassoc let add k v m = (k, v)::m let remove = List.removeassoc
let find = List.assocend</p>
<h1 id="implementing-maps-association-lists">8 Implementing maps:
Association lists</h1>
<p>Let’s now build an implementation of maps from the ground up. The
most straightforward implementation… might not be what you expected:</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> TrivialMap : MAP = <span class="kw">struct</span>  <span class="kw">type</span> (&#39;a, &#39;b) t =    | Empty    | Add <span class="kw">of</span> &#39;a </span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>\* &#39;b \* (&#39;a, &#39;b) t    | Remove <span class="kw">of</span> &#39;a \* (&#39;a, &#39;b) t          <span class="kw">let</span> empty = Empty </span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> member k m =    <span class="kw">match</span> m <span class="kw">with</span>      | Empty -&gt; <span class="kw">false</span>      | Add </span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>(k2, , ) <span class="kw">when</span> k = k2 -&gt; <span class="kw">true</span>      | Remove (k2, ) <span class="kw">when</span> k = k2 -&gt; <span class="kw">false</span> </span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>     | Add (, , m2) -&gt; member k m2      | Remove (, m2) -&gt; member k m2 </span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> add k v m = Add (k, v, m)  <span class="kw">let</span> remove k m = Remove (k, m)  <span class="kw">let</span> <span class="kw">rec</span> find k </span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>m =    <span class="kw">match</span> m <span class="kw">with</span>      | Empty -&gt; <span class="dt">raise</span> <span class="dt">Not_found</span>      | Add (k2, v, ) </span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a><span class="kw">when</span> k = k2 -&gt; v      | Remove (k2, ) <span class="kw">when</span> k = k2 -&gt; <span class="dt">raise</span> Notfound    </span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>  | Add (, , m2) -&gt; find k m2      | Remove (, m2) -&gt; find k m2 <span class="kw">end</span></span></code></pre></div>
<p>Here is an implementation based on association lists, i.e. on lists
of key-value pairs.</p>
<div class="sourceCode" id="cb47"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> MyListMap : MAP = <span class="kw">struct</span>  <span class="kw">type</span> (&#39;a, &#39;b) t = Empty | Add <span class="kw">of</span> &#39;a \* &#39;b \* </span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>(&#39;a, &#39;b) t  <span class="kw">let</span> empty = Empty  <span class="kw">let</span> <span class="kw">rec</span> member k m =    <span class="kw">match</span> m <span class="kw">with</span>      | </span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>Empty -&gt; <span class="kw">false</span>      | Add (k2, , ) <span class="kw">when</span> k = k2 -&gt; <span class="kw">true</span>      | Add (, , </span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>m2) -&gt; member k m2  <span class="kw">let</span> <span class="kw">rec</span> add k v m =    <span class="kw">match</span> m <span class="kw">with</span>      | </span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>Empty -&gt; Add (k, v, Empty)      | Add (k2, , m) <span class="kw">when</span> k = k2 -&gt; Add (k, </span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>v, m)      | Add (k2, v2, m) -&gt; Add (k2, v2, add k v m)</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> remove k m =    <span class="kw">match</span> m <span class="kw">with</span>      | Empty -&gt; Empty      | Add </span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>(k2, , m) <span class="kw">when</span> k = k2 -&gt; m      | Add (k2, v, m) -&gt; Add (k2, v, remove </span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>k m)  <span class="kw">let</span> <span class="kw">rec</span> find k m =    <span class="kw">match</span> m <span class="kw">with</span>      | Empty -&gt; <span class="dt">raise</span> <span class="dt">Error</span>      </span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>| Add (k2, v, ) <span class="kw">when</span> k = k2 -&gt; v      | Add (, , m2) -&gt; find k m2 <span class="kw">end</span></span></code></pre></div>
<h1 id="implementing-maps-binary-search-trees">9 Implementing maps:
Binary search trees</h1>
<ul>
<li>Binary search trees are binary trees with elements stored at the
interior nodes, such that elements to the left of a node are smaller
than, and elements to the right bigger than, elements within a
node.</li>
<li>For maps, we store key-value pairs as elements in binary search
trees, and compare the elements by keys alone.</li>
<li>On average, binary search trees are fast because they use
“divide-and-conquer” to search for the value associated with a key.
(<span class="math inline">O
(\log n)</span> compl.)
<ul>
<li>In worst case they reduce to association lists.</li>
</ul></li>
<li>The simple polymorphic signature for maps is only possible with
implementations based on some total order of keys because OCaml has
polymorphic comparison (and equality) operators.
<ul>
<li>These operators work on elements of most types, but not on
functions. They may not work in a way you would want though!</li>
<li>Our signature for polymorphic maps is not the standard approach
because of the problem of needing the order of keys; it is just to keep
things simple.</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb48"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> BTreeMap : MAP = <span class="kw">struct</span>  <span class="kw">type</span> (&#39;a, &#39;b) t = Empty | T <span class="kw">of</span> (&#39;a, &#39;b) t \* </span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>&#39;a \* &#39;b \* (&#39;a, &#39;b) t  <span class="kw">let</span> empty = Empty  <span class="kw">let</span> <span class="kw">rec</span> member k m =‘‘Divide <span class="kw">and</span> </span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>conquer&#39;&#39; search through the tree.    <span class="kw">match</span> m <span class="kw">with</span>      | Empty -&gt; <span class="kw">false</span>   </span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>   | T (, k2, , ) <span class="kw">when</span> k = k2 -&gt; <span class="kw">true</span>      | T (m1, k2, , ) <span class="kw">when</span> k &lt; </span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>k2 -&gt; member k m1      | T (, , , m2) -&gt; member k m2  <span class="kw">let</span> <span class="kw">rec</span> add k v </span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>m =Searches the tree <span class="kw">in</span> the same way <span class="kw">as</span> `member`    <span class="kw">match</span> m withbut copies </span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>every node along the way.      | Empty -&gt; T (Empty, k, v, Empty)      | T </span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>(m1, k2, , m2) <span class="kw">when</span> k = k2 -&gt; T (m1, k, v, m2)      | T (m1, k2, v2, m2) </span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a><span class="kw">when</span> k &lt; k2 -&gt; T (add k v m1, k2, v2, m2)      | T (m1, k2, v2, </span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>m2) -&gt; T (m1, k2, v2, add k v m2)</span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> splitrightmost m = <span class="co">(* A helper </span></span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a><span class="co">function, it does not belong *)</span></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a>   <span class="kw">match</span> m <span class="kw">with</span> <span class="co">(* to the ‘‘exported&#39;&#39; signature.     *)</span></span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a> | Empty -&gt; <span class="dt">raise</span> Notfound      | T (Empty, k, v, Empty) -&gt; k, v, </span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>EmptyWe remove one element,      | T (m1, k, v, m2) -&gt;the one that is on </span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a>the bottom right.        <span class="kw">let</span> rk, rv, rm = splitrightmost m2 <span class="kw">in</span>        rk, rv, </span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a>T (m1, k, v, rm)</span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-20"><a href="#cb48-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> remove k m =    <span class="kw">match</span> m <span class="kw">with</span>      | Empty -&gt; Empty      | T (m1, </span>
<span id="cb48-21"><a href="#cb48-21" aria-hidden="true" tabindex="-1"></a>k2, , Empty) <span class="kw">when</span> k = k2 -&gt; m1      | T (Empty, k2, , m2) <span class="kw">when</span> k = </span>
<span id="cb48-22"><a href="#cb48-22" aria-hidden="true" tabindex="-1"></a>k2 -&gt; m2      | T (m1, k2, , m2) <span class="kw">when</span> k = k2 -&gt;        <span class="kw">let</span> rk, rv, rm </span>
<span id="cb48-23"><a href="#cb48-23" aria-hidden="true" tabindex="-1"></a>= splitrightmost m1 <span class="kw">in</span>        T (rm, rk, rv, m2)      | T (m1, k2, v, m2) <span class="kw">when</span> </span>
<span id="cb48-24"><a href="#cb48-24" aria-hidden="true" tabindex="-1"></a>k &lt; k2 -&gt; T (remove k m1, k2, v, m2)      | T (m1, k2, v, m2) -&gt; </span>
<span id="cb48-25"><a href="#cb48-25" aria-hidden="true" tabindex="-1"></a>T (m1, k2, v, remove k m2)  <span class="kw">let</span> <span class="kw">rec</span> find k m =    <span class="kw">match</span> m <span class="kw">with</span>      | </span>
<span id="cb48-26"><a href="#cb48-26" aria-hidden="true" tabindex="-1"></a>Empty -&gt; <span class="dt">raise</span> Notfound      | T (, k2, v, ) <span class="kw">when</span> k = k2 -&gt; v      | T </span>
<span id="cb48-27"><a href="#cb48-27" aria-hidden="true" tabindex="-1"></a>(m1, k2, , ) <span class="kw">when</span> k &lt; k2 -&gt; find k m1      | T (, , , m2) -&gt; find </span>
<span id="cb48-28"><a href="#cb48-28" aria-hidden="true" tabindex="-1"></a>k m2 <span class="kw">end</span></span></code></pre></div>
<h1 id="implementing-maps-red-black-trees">10 Implementing maps:
red-black trees</h1>
<p>Based on Wikipedia <a
href="http://en.wikipedia.org/wiki/Red-black_tree">http://en.wikipedia.org/wiki/Red-black_tree</a>,
Chris Okasaki’s “Functional Data Structures” and Matt Might’s excellent
blog post <a
href="http://matt.might.net/articles/red-black-delete/">http://matt.might.net/articles/red-black-delete/</a>.</p>
<ul>
<li>Binary search trees are good when we encounter keys in random order,
because the cost of operations is limited by the depth of the tree which
is small relatively to the number of nodes…</li>
<li>…unless the tree grows unbalanced achieving large depth (which means
there are sibling subtrees of vastly different sizes on some path).</li>
<li>To remedy it, we rebalance the tree while building it – i.e. while
adding elements.</li>
<li>In <em>red-black trees</em> we achieve balance by remembering one of
two colors with each node, keeping the same length of each root-leaf
path if only black nodes are counted, and not allowing a red node to
have a red child.
<ul>
<li>This way the depth is at most twice the depth of a perfectly
balanced tree with the same number of nodes.</li>
</ul></li>
</ul>
<h2 id="b-trees-of-order-4-2-3-4-trees">10.1 B-trees of order 4 (2-3-4
trees)</h2>
<p>How can we have perfectly balanced trees without worrying about
having <span class="math inline">2^k -
1</span> elements? <strong>2-3-4 trees</strong> can store from 1 to 3
elements in each node and have 2 to 4 subtrees correspondingly. Lots of
freedom!</p>
<p>To insert “25” into (“.” stand for leaves, ignored later)</p>
<p>we descend right, but it is a full node, so we move the middle up and
split the remaining elements:</p>
<p>Now there is a place between 24 and 29: next to 29</p>
<p>To represent 2-3-4 tree as a binary tree with one element per node,
we color the middle element of a 4-node, or the first element of
2-/3-node, black and make it the parent of its neighbor elements, and
make them parents of the original subtrees. Turning this:</p>
<p>Red-black_tree_B-tree.png</p>
<p>into this Red-Black tree:</p>
<p>Red-black_tree_example.png</p>
<h2 id="red-black-trees-without-deletion">10.2 Red-Black trees, without
deletion</h2>
<ul>
<li><strong>Invariant 1.</strong> No red node has a red child.</li>
<li><strong>Invariant 2</strong>. Every path from the root to an empty
node contains the same number of black nodes.</li>
<li>First we implement Red-Black tree based sets without deletion.</li>
<li>The implementation proceeds almost exactly like for unbalanced
binary search trees, we only need to restore invariants.</li>
<li>By keeping balance at each step of constructing a node, it is enough
to check locally (around the root of the subtree).</li>
<li>For understandable implementation of deletion, we need to introduce
more colors. See Matt Might’s post edited in a separate file.</li>
</ul>
<div class="sourceCode" id="cb49"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> color = R | Btype &#39;a t = E | T <span class="kw">of</span> color \* &#39;a t \* &#39;a \* &#39;a tlet empty = </span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>Elet <span class="kw">rec</span> member x m =  <span class="kw">match</span> m withLike <span class="kw">in</span> unbalanced binary search tree.  | </span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>Empty -&gt; <span class="kw">false</span>  | T (, , y, ) <span class="kw">when</span> x = y -&gt; <span class="kw">true</span>  | T (, a, y, ) <span class="kw">when</span> </span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>x &lt; y -&gt; member x a  | T (, , , b) -&gt; member x blet balance = </span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>functionRestoring the invariants.  | B,T (R,T (R,a,x,b),y,c),z,dOn next </span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>figure: left,  | B,T (R,a,x,T (R,b,y,c)),z,dtop,  | B,a,x,T (R,T </span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>(R,b,y,c),z,d)bottom,  | B,a,x,T (R,b,y,T (R,c,z,d))right,    -&gt; T (R,T </span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>(B,a,x,b),y,T (B,c,z,d))center tree.  | color,a,x,b -&gt; T (color,a,x,b)We </span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>allow red-red violation <span class="kw">for</span> now.</span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> insert x s =  <span class="kw">let</span> <span class="kw">rec</span> ins = functionLike <span class="kw">in</span> unbalanced binary search tree, </span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>   | E -&gt; T (R,E,x,E)but fix violation above created node.    | T </span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a>(color,a,y,b) <span class="kw">as</span> s -&gt;      <span class="kw">if</span> x&lt;y <span class="kw">then</span> balance (color,ins a,y,b)      </span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a><span class="kw">else</span> <span class="kw">if</span> x&gt;y <span class="kw">then</span> balance (color,a,y,ins b)      <span class="kw">else</span> s <span class="kw">in</span></span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> ins s <span class="kw">with</span> <span class="co">(* We could still have red-red violation at root, *)</span></span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a>  | T (,a,y,b) -&gt; T (B,a,y,b) <span class="co">(* fixed by coloring it black. *)</span></span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a>  | E -&gt; <span class="dt">failwith</span> <span class="st">&quot;insert: impossible&quot;</span></span></code></pre></div>
<h1 id="homework-2">11 Homework</h1>
<ol type="1">
<li><p>Derive the equations and solve them to find the type for:</p>
<p>let cadr l = List.hd (List.tl l) in cadr (1::2::[]), cadr
(true::false::[])</p>
<p>in environ. <span class="math inline">\Gamma = \left\lbrace
\text{{\textcolor{green}{List}}{\textcolor{blue}{.}}{\textcolor{brown}{hd}}}
: \forall \alpha . \alpha
\operatorname{list} \rightarrow \alpha ;
\text{{\textcolor{green}{List}}{\textcolor{blue}{.}}{\textcolor{brown}{tl}}}
: \forall \alpha . \alpha
\operatorname{list} \rightarrow \alpha \operatorname{list}
\right\rbrace</span>. You can take “shortcuts” if it is too many
equations to write down.</p></li>
<li><p>What does it mean that an implementation has junk (as an
algebraic structure for a given signature)? Is it bad?</p></li>
<li><p>Define a monomorphic algebraic specification (other than, but
similar to, <span class="math inline">\operatorname{nat}_{p}</span> or
<span class="math inline">\operatorname{string}_{p}</span>, some useful
data type).</p></li>
<li><p>Discuss an example of a (monomorphic) algebraic specification
where it would be useful to drop some axioms (giving up monomorphicity)
to allow more efficient implementations.</p></li>
<li><p>Does the example ListMap meet the requirements of the algebraic
specification for maps? Hint: here is the definition of
List.removeassoc; <code>compare a x</code> equals 0 if and only if
<code>a</code> = <code>x</code>.</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> removeassoc x = <span class="kw">function</span>  | [] -&gt; []  | (a, b <span class="kw">as</span> pair) :: l -&gt;</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> <span class="dt">compare</span> a x = <span class="dv">0</span> <span class="kw">then</span> l <span class="kw">else</span> pair :: removeassoc x l</span></code></pre></div></li>
<li><p>Trick question: what is the computational complexity of ListMap
or TrivialMap?</p></li>
<li><p>* The implementation MyListMap is inefficient: it performs a lot
of copying and is not tail-recursive. Optimize it (without changing the
type definition).</p></li>
<li><p>Add (and specify) <span
class="math inline">\operatorname{isEmpty}: (\alpha, \beta)
\operatorname{map} \rightarrow \operatorname{bool}</span> to the example
algebraic specification of maps without increasing the burden on its
implementations (i.e. without affecting implementations of other
operations). Hint: equational reasoning might be not enough; consider an
equivalence relation <span class="math inline">\approx</span> meaning
“have the same keys”, defined and used just in the axioms of the
specification.</p></li>
<li><p>Design an algebraic specification and write a signature for
first-in-first-out queues. Provide two implementations: one
straightforward using a list, and another one using two lists: one for
freshly added elements providing efficient queueing of new elements, and
“reversed” one for efficient popping of old elements.</p></li>
<li><p>Design an algebraic specification and write a signature for sets.
Provide two implementations: one straightforward using a list, and
another one using a map into the unit type.</p></li>
<li><p>(Ex. 2.2 in Chris Okasaki “Purely Functional Data Structures”) In
the worst case, <code>member</code> performs approximately <span
class="math inline">2 d</span> comparisons, where <span
class="math inline">d</span> is the depth of the tree. Rewrite
<code>member</code> to take no mare than <span class="math inline">d +
1</span> comparisons by keeping track of a candidate element that
<em>might</em> be equal to the query element (say, the last element for
which <span class="math inline">&lt;</span> returned false) and checking
for equality only when you hit the bottom of the tree.</p></li>
<li><p>(Ex. 3.10 in Chris Okasaki “Purely Functional Data Structures”)
The <code>balance</code> function currently performs several unnecessary
tests: when e.g.  <code>ins</code> recurses on the left child, there are
no violations on the right child.</p>
<ol type="1">
<li>Split <code>balance</code> into <code>lbalance</code> and
<code>rbalance</code> that test for violations of left resp. right child
only. Replace calls to <code>balance</code> appropriately.</li>
<li>One of the remaining tests on grandchildren is also unnecessary.
Rewrite <code>ins</code> so that it never tests the color of nodes not
on the search path.</li>
</ol></li>
<li><p>* Implement maps (i.e. write a module for the map signature)
based on AVL trees. See
<code>http://en.wikipedia.org/wiki/AVL_tree</code>.</p></li>
</ol>
<p>Functional Programming</p>
<p>Type Inference</p>
<p>Abstract Data Types</p>
<p><strong>Exercise 1:</strong> Derive the equations and solve them to
find the type for:</p>
<p><em>let cadr l = List.hd (List.tl l) in cadr (1::2::[]), cadr
(true::false::[])</em></p>
<p><em>in environment <span class="math inline">\Gamma = \left\lbrace
\text{{\textcolor{green}{List}}{\textcolor{blue}{.}}{\textcolor{brown}{hd}}}
: \forall \alpha . \alpha
\operatorname{list} \rightarrow \alpha ;
\text{{\textcolor{green}{List}}{\textcolor{blue}{.}}{\textcolor{brown}{tl}}}
: \forall \alpha . \alpha
\operatorname{list} \rightarrow \alpha \operatorname{list}
\right\rbrace</span>. You can take “shortcuts” if it is too many
equations to write down.</em></p>
<p><strong>Exercise 2:</strong> <em>Terms</em> <span
class="math inline">t_{1}, t_{2}, \ldots \in T (\Sigma, X)</span> are
built out of variables <span class="math inline">x, y, \ldots \in
X</span> and function symbols <span class="math inline">f, g, \ldots \in
\Sigma</span> the way you build values out of functions:</p>
<ul>
<li><span class="math inline">X \subset T (\Sigma, X)</span> <em>–
variables are terms; usually an infinite set,</em></li>
<li><em>for terms</em> <span class="math inline">t_{1}, \ldots, t_{n}
\in T (\Sigma, X)</span> <em>and a function symbol</em> <span
class="math inline">f \in \Sigma _{n}</span> <em>of arity</em> <span
class="math inline">n</span>,<span class="math inline">f (t_{1}, \ldots,
t_{n}) \in
T (\Sigma, X)</span> <em>– bigger terms arise from applying function
symbols to smaller terms;</em> <span class="math inline">\Sigma =
\dot{\cup}_{n} \Sigma _{n}</span> <em>is called a signature.</em></li>
</ul>
<p><em>In OCaml, we can define terms as: type term = V of string | T of
string </em> term list5mm, where for example V(“x”) is a variable <span
class="math inline">x</span> and T(“f”, [V(“x”); V(“y”)]) is the term
<span class="math inline">f (x, y)</span>.*</p>
<p><em>By </em>substitutions* <span class="math inline">\sigma, \rho,
\ldots</span> we mean finite sets of variable, term pairs which we can
write as <span class="math inline">\lbrace x_{1} \mapsto t_{1}, \ldots,
x_{k} \mapsto t_{k} \rbrace</span> or <span class="math inline">[x_{1}
:= t_{1} ; \ldots ; x_{k} :=
t_{k}]</span>, but also functions from terms to terms <span
class="math inline">\sigma : T (\Sigma, X)
\rightarrow T (\Sigma, X)</span> related to the pairs as follows: if
<span class="math inline">\sigma =
\lbrace x_{1} \mapsto t_{1}, \ldots, x_{k} \mapsto t_{k} \rbrace</span>,
then*</p>
<ul>
<li><span class="math inline">\sigma (x_{i}) = t_{i}</span> <em>for</em>
<span class="math inline">x_{i} \in \lbrace x_{1}, \ldots, x_{k}
\rbrace</span>,</li>
<li><span class="math inline">\sigma (x) = x</span> <em>for</em> <span
class="math inline">x \in X\backslash \lbrace x_{1}, \ldots, x_{k}
\rbrace</span>,</li>
<li><span class="math inline">\sigma (f (t_{1}, \ldots, t_{n})) = f
(\sigma (t_{1}), \ldots, \sigma
(t_{n}))</span>.</li>
</ul>
<p><em>In OCaml, we can define substitutions <span
class="math inline">\sigma</span> as: type subst = (string </em> term)
list, together with a function apply : subst -&gt; term -&gt; term which
computes <span class="math inline">\sigma (\cdot)</span>.*</p>
<p><em>We say that a substitution <span
class="math inline">\sigma</span> is </em>more general* than all
substitutions <span class="math inline">\rho \circ \sigma</span>, where
<span class="math inline">(\rho \circ \sigma) (x) = \rho (\sigma
(x))</span>. In type inference, we are interested in most general
solutions: the less general type judgement <span
class="math inline">\text{{\textcolor{green}{List}}{\textcolor{blue}{.}}{\textcolor{brown}{hd}}}
:
\operatorname{int}\operatorname{list} \rightarrow
\operatorname{int}</span>, although valid, is less useful than <span
class="math inline">\text{{\textcolor{green}{List}}{\textcolor{blue}{.}}{\textcolor{brown}{hd}}}
: \forall \alpha . \alpha
\operatorname{list} \rightarrow \alpha</span> because it limits the
usage of List.hd.*</p>
<p><em>A </em>unification problem* is a finite set of equations <span
class="math inline">S = \lbrace s_{1} =^?
t_{1}, \ldots, s_{n} =^? t_{n} \rbrace</span> which we can also write as
<span class="math inline">s_{1}
\dot{=} t_{1} \wedge \ldots \wedge s_{n} \dot{=} t_{n}</span>. A
solution, or <em>unifier</em> of <span class="math inline">S</span>, is
a substitution <span class="math inline">\sigma</span> such that <span
class="math inline">\sigma (s_{i}) =
\sigma (t_{i})</span> for <span class="math inline">i = 1, \ldots,
n</span>. A <em>most general unifier</em>, for short <em>MGU</em>, is a
most general such substitution.*</p>
<p><em>A substitution is </em>idempotent* when <span
class="math inline">\sigma = \sigma \circ \sigma</span>. If <span
class="math inline">\sigma = \lbrace x_{1} \mapsto t_{1}, \ldots, x_{k}
\mapsto t_{k}
\rbrace</span>, then <span class="math inline">\sigma</span> is
idempotent exactly when no <span class="math inline">t_{i}</span>
contains any of the variables <span class="math inline">\lbrace x_{1},
\ldots, x_{n} \rbrace</span>; i.e. <span class="math inline">\lbrace
x_{1},
\ldots, x_{n} \rbrace \cap \operatorname{Vars} (t_{1}, \ldots, t_{n}) =
\varnothing</span>.*</p>
<ol type="1">
<li><em>Implement an algorithm that, given a set of equations
represented as a list of pairs of terms, computes an idempotent most
general unifier of the equations.</em></li>
<li>** (Ex. 4.22 in* *Franz Baader and Tobias Nipkov “Term Rewriting and
All That”**, p. 82.) Modify the implementation of unification to achieve
linear space complexity by working with what could be called iterated
substitutions. For example, the solution to* <span
class="math inline">\lbrace x =^? f (y), y =^? g
(z), z =^? a \rbrace</span> <em>should be represented as variable, term
pairs</em> <span class="math inline">(x,
f (y)), (y, g (z)), (z, a)</span><em>. (Hint: iterated substitutions
should be unfolded lazily, i.e. only so far that either a non-variable
term or the end of the instantiation chain is found.)</em></li>
</ol>
<p><strong>Exercise 3:</strong></p>
<ol type="1">
<li><em>What does it mean that an implementation has junk (as an
algebraic structure for a given signature)? Is it bad?</em></li>
<li><em>Define a monomorphic algebraic specification (other than, but
similar to,</em> <span class="math inline">\operatorname{nat}_{p}</span>
<em>or</em> <span
class="math inline">\operatorname{string}_{p}</span><em>, some useful
data type).</em></li>
<li><em>Discuss an example of a (monomorphic) algebraic specification
where it would be useful to drop some axioms (giving up monomorphicity)
to allow more efficient implementations.</em></li>
</ol>
<p><strong>Exercise 4:</strong></p>
<ol type="1">
<li><p><em>Does the example</em> <em>ListMap</em> <em>meet the
requirements of the algebraic specification for maps? Hint: here is the
definition of</em>
<em>List</em>.<em>removeassoc</em>;<code>*compare a x*</code>
<em>equals</em> <em>0</em> <em>if and only if</em>
<code>*a*</code>=<code>*x*</code>.</p>
<p><em>let rec removeassoc x = function | [] -&gt; [] | (a, b as pair)
:: l -&gt; if compare a x = 0 then l else pair :: removeassoc x
l</em></p></li>
<li><p><em>Trick question: what is the computational complexity of</em>
<em>ListMap</em> <em>or</em> <em>TrivialMap</em>?</p></li>
<li><p>** The implementation* <em>MyListMap</em> <em>is inefficient: it
performs a lot of copying and is not tail-recursive. Optimize it
(without changing the type definition).</em></p></li>
<li><p><em>Add (and specify)</em> <span
class="math inline">\operatorname{isEmpty}: (\alpha, \beta)
\operatorname{map} \rightarrow \operatorname{bool}</span> <em>to the
example algebraic specification of maps without increasing the burden on
its implementations (i.e. without affecting implementations of other
operations). Hint: equational reasoning might be not enough; consider an
equivalence relation</em> <span class="math inline">\approx</span>
<em>meaning “have the same keys”, defined and used just in the axioms of
the specification.</em></p></li>
</ol>
<p><strong>Exercise 5:</strong> Design an algebraic specification and
write a signature for first-in-first-out queues. Provide two
implementations: one straightforward using a list, and another one using
two lists: one for freshly added elements providing efficient queueing
of new elements, and “reversed” one for efficient popping of old
elements.</p>
<p><strong>Exercise 6:</strong> Design an algebraic specification and
write a signature for sets. Provide two implementations: one
straightforward using a list, and another one using a map into the unit
type.</p>
<ul>
<li><em>To allow for a more complete specification of sets here, augment
the maps ADT with generally useful operations that you find necessary or
convenient for map-based implementation of sets.</em></li>
</ul>
<p><strong>Exercise 7:</strong></p>
<ol type="1">
<li><em>(Ex. 2.2 in</em> *Chris Okasaki “Purely Functional Data
Structures”**) In the worst case,* <code>*member*</code> <em>performs
approximately</em> <span class="math inline">2 d</span> <em>comparisons,
where</em> <span class="math inline">d</span> <em>is the depth of the
tree. Rewrite</em> <code>*member*</code> <em>to take no mare than</em>
<span class="math inline">d + 1</span> <em>comparisons by keeping track
of a candidate element that</em> <em>might</em> <em>be equal to the
query element (say, the last element for which</em> <span
class="math inline">&lt;</span> <em>returned false) and checking for
equality only when you hit the bottom of the tree.</em></li>
<li><em>(Ex. 3.10 in</em> *Chris Okasaki “Purely Functional Data
Structures”**) The<em> <code>*balance*</code> </em>function currently
performs several unnecessary tests: when e.g.* <code>*ins*</code>
<em>recurses on the left child, there are no violations on the right
child.</em>
<ol type="1">
<li><em>Split</em> <code>*balance*</code> <em>into</em>
<code>*lbalance*</code> <em>and</em> <code>*rbalance*</code> <em>that
test for violations of left resp. right child only. Replace calls
to</em> <code>*balance*</code> <em>appropriately.</em></li>
<li><em>One of the remaining tests on grandchildren is also unnecessary.
Rewrite</em> <code>*ins*</code> <em>so that it never tests the color of
nodes not on the search path.</em></li>
</ol></li>
</ol>
<p>Lecture 6: Folding and Backtracking</p>
<p>Mapping and folding.Backtracking using lists. Constraint solving.</p>
<p>Martin Odersky ‘‘Functional Programming Fundamentals’’ Lectures 2, 5
and 6</p>
<p>Bits of Ralf Laemmel ‘‘Going Bananas’’</p>
<p>Graham Hutton ‘‘Programming in Haskell’’ Chapter 11 ‘‘Countdown
Problem’’</p>
<p>Tomasz Wierzbicki ‘‘<em>Honey Islands</em> Puzzle Solver’’</p>
<p>If you see any error on the slides, let me know!</p>
<h1 id="plan">1 Plan</h1>
<ul>
<li><code>map</code> and <code>fold_right</code>: recursive function
examples, abstracting over gets the higher-order functions.</li>
<li>Reversing list example, tail-recursive variant,
<code>fold_left</code>.</li>
<li>Trimming a list: <code>filter</code>.
<ul>
<li>Another definition via <code>fold_right</code>.</li>
</ul></li>
<li><code>map</code> and <code>fold</code> for trees and other data
structures.</li>
<li>The point-free programming style. A bit of history: the FP
language.</li>
<li>Sum over an interval example: <span class="math inline">\sum_{n =
a}^b f (n)</span>.</li>
<li>Combining multiple results: <code>concat_map</code>.</li>
<li>Interlude: generating all subsets of a set (as list), and as
exercise: all permutations of a list.</li>
<li>The Google problem: the <code>map_reduce</code> higher-order
function.
<ul>
<li>Homework reference: modified <code>map_reduce</code> to
<ol type="1">
<li>build a histogram of a list of documents</li>
<li>build an inverted index for a list of documents</li>
</ol>
Later: use <code>fold</code> (?) to search for a set of words
(conjunctive query).</li>
</ul></li>
<li>Puzzles: checking correctness of a solution.</li>
<li>Combining bags of intermediate results: the <code>concat_fold</code>
functions.</li>
<li>From checking to generating solutions.</li>
<li>Improving “generate-and-test” by filtering (propagating constraints)
along the way.</li>
<li>Constraint variables, splitting and constraint propagation.</li>
<li>Another example with “heavier” constraint propagation.</li>
</ul>
<h1 id="basic-generic-list-operations">2 Basic generic list
operations</h1>
<p>How to print a comma-separated list of integers? In module
<code>String</code>:</p>
<p>val concat : string -&gt; string list -&gt; string</p>
<p>First convert numbers into strings:</p>
<p>let rec stringsofints = function | [] -&gt; [] | hd::tl -&gt;
stringofint hd :: stringsofints tllet commasepints = String.concat “,”
-| stringsofints</p>
<p>How to get strings sorted from shortest to longest? First find the
length:</p>
<p>let rec stringslengths = function | [] -&gt; [] | hd::tl -&gt;
(String.length hd, hd) :: stringslengths tllet bysize = List.sort
compare -| stringslengths</p>
<h2 id="always-extract-common-patterns">2.1 Always extract common
patterns</h2>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
</tbody>
</table>
<p>1.589482.889124.91267032676283.016123164439747.15635335361822.783288133350976.098012303214712.127116682100812.139816774705652.127116682100811.483645323455482.296451250165373.70616-0.561076.6695164704326-0.4552354808837159.37886955946554-0.6034032279402048.15119394099749-1.323075142214584.36233298055298-1.19607421616616-8.062594.51897-5.437905146183364.62480156105305-2.538050668077794.56130109802884-3.5117244344493.79929554173833-7.575754067998413.92629646778674-7.914421.15344-4.506565021828281.30161066278608-2.453383384045510.984108347665035-3.659892181505490.391437359439079-7.575754067998410.4549378224632891.483652.27528-0.506035851303082-3.630258632094194.34117-1.217240.255969704987432-3.63025863209419-7.639253.88396-7.66042135203069-2.1485811615293-3.659890.370271-6.55974665961106-2.12741434052123-8.16843-2.31792-5.94590885037703-2.21208162455351-4.16789588569917-2.27558208757772-4.76056687392512-2.88941989681175-7.78742227807911-2.86825307580368-2.72855-3.79959-0.506035851303082-3.630258632094190.742806588173039-4.053595052255590.213636062971293-4.60393239846541-2.79205252017463-4.41343100939278-5.840072.78329-2.919053446223053.01612316443974-1.05637319751292.78328813335097-1.691377827754992.14828350310888-5.395571504167222.23295078714116-5.33207-0.476402-0.992872734488689-0.2647340918110861.75881399656039-0.5399027649159940.785140230189178-1.21724103717423-4.52773184283635-1.19607421616616-5.459072.19062-5.62840653525599-3.71492591612647-4.52773-1.23841-5.45907196719143-3.778426379150680cm</p>
<p>Now use the generic function:</p>
<p>let commasepints = String.concat “,” -| listmap stringofintlet bysize
=<br />
List.sort compare -| listmap (fun s-&gt;String.length s, s)</p>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td style="text-align: right">
How to sum elements of a list?
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td style="text-align: right">
How to multiply elements in a list?
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td style="text-align: right">
Generic solution:
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
Caution: <tt class="verbatim">list_fold f base l</tt> =
<tt class="verbatim">List.fold_right f l base</tt>.
</td>
</tr>
</tbody>
</table>
<p>-6.968285.20805-5.592439476121185.48321537240376-4.237762931604715.22921352030692-4.576432067733834.72120981611324-6.354445032411694.70004299510517-6.693111.18635-4.682266172774181.24985117078979-2.756085461039821.1016834237333-3.306422807249640.509012435507342-6.354445032411690.466678793491203-2.269253.7687-0.8722383913216043.7687028707501-0.1102328350310893.45120055562905-0.5759028972086263.04903095647572-2.692584998015613.11253141949993-2.37508-0.549329-0.512402434184416-0.3799940468315911.73128059267099-0.591662256912291.05394232041275-1.16316642413018-2.03641354676544-1.12083278211404-6.92595-2.36968-4.02609472152401-2.11567336949332-0.999239317370023-2.34850840058209-1.48607620055563-2.87767892578383-6.07927635930679-2.87767892578383-2.26925-3.914851.49844556158222-3.809019050138913.40345945230851-4.063020902235752.93778939013097-4.52869096441328-1.27440799047493-4.61335824844556-6.354454.70004-6.10044318031486-2.2003406535256-3.306420.509012-5.10853954194466-2.14605530848409-2.734923.11253-1.38460084405009-3.806950349498371.05394-1.184330.19997872622222-3.78626681481166-3.560423.4512-3.200588702209293.133698240508-3.073587776160873.64170194470168-3.58159-0.760997-2.90425320809631-0.54932861489615-2.75608546103982-0.866830930017198-4.70343-4.21119-4.08959518454822-4.10535454425189-4.1742624685805-4.48635732239714-3.242923.11253-4.3859306786612-3.87251951316312-3.26132-1.28056-4.23776293160471-3.95718679719540cm</p>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
<tt class="verbatim">map</tt> alters the contents of data
</td>
<td>
</td>
<td>
</td>
<td>
<tt class="verbatim">fold</tt> computes a value using
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
without changing the structure:
</td>
<td>
</td>
<td>
</td>
<td>
the structure as a scaffolding:
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td style="text-align: center; vertical-align: bottom">
</td>
<td style="vertical-align: middle">
</td>
<td>
</td>
<td>
</td>
<td style="text-align: center; vertical-align: middle">
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h2 id="can-we-make-fold-tail-recursive">2.2 Can we make
<code>fold</code> tail-recursive?</h2>
<p>Let’s investigate some tail-recursive functions. (Not hidden as
helpers.)</p>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<tt class="verbatim">acc</tt>
</td>
</tr>
<tr>
<td>
<tt class="verbatim"><br />
hd</tt>
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<br />
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
tot
</td>
</tr>
<tr>
<td>
<tt class="verbatim"> </tt> hd<tt 
class="verbatim"> tl</tt>
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<br />
</td>
</tr>
<tr>
<td>
<br />
</td>
</tr>
<tr>
<td>
<br />
</td>
</tr>
</tbody>
</table>
<p>-5.909944.94728-3.729759227411035.01078184945099-1.486076200555634.88378092340257-2.099914009789654.33344357719275-5.338437624024344.26994311416854-5.867611.47592-2.756085461039821.666424130175950.7152731842836351.49708956211139-0.4489019711602060.925585394893504-4.936268024871010.925585394893504-6.01578-2.79978-2.69258499801561-2.56694007143802-0.152566477047228-2.79977510252679-0.427735150152137-3.30777880672047-4.57643206773383-3.35011244873661-3.750933.06343-2.121080830797723.29626934779733-0.5970697182166953.04226749570049-2.226914935838072.55543061251488-4.02609-1.1911-2.45974996692684-0.852427569784363-1.21090752745072-1.25459716893769-2.43858314591877-1.63559994708295-4.5341-4.40845-2.37508268289456-4.28145257309168-0.343067866119857-4.4084534991401-1.02040613837809-4.93762402434184-3.83559333245138-4.93762402434184-0.1102333.296271.498445561582223.423270273845752.874288927106763.232768884773122.175783833840452.555430612514880.1437690170657492.57659743352295-0.491236-0.9582623.61512766238921-0.8100939277682237.04415266569652-1.064095779865065.71064294218812-1.720267231115230.524771795211007-1.677933589099090.376604-4.302622.21811747585659-4.239118931075543.61512766238921-4.429620320148173.17062442121974-4.916457203333770.799940468315915-4.95879084534991-5.338444.29111-6.07927635930679-2.16477047228469-5.69827358116153-2.69394099748644-4.957430.967919-5.48660537108083-1.97426908321207-5.44427172906469-2.6516073554703-2.226912.55543-2.03641354676544-3.62528112184151-2.37508268289456-4.28145257309168-2.41742-1.61443-2.69258499801561-3.79461568990607-2.80072853017803-4.283284085867292.895463.253945.64714247916391-2.397605503373463.72096176742955-4.429620320148174.73754-1.786764.14429818759095-3.413612911760813.50929355734886-4.323786215107820.5036052.70363.00128985315518-4.49312078317238-0.0678992-1.50862.89545574811483-4.598954888212731.752452.70361.62544648763064-4.450787141156242.47212-1.57213.04362349517132-2.461105966397676.17631-1.50863.04362349517132-2.461105966397673.04362-2.461112.02761608678397-4.366119857123960cm</p>
<ul>
<li><p>With <code>fold_left</code>, it is easier to hide the
accumulator. The <code>average</code> example is a bit more tricky than
<code>list_rev</code>.</p>
<p>let listrev l = foldleft (fun t h-&gt;h::t) [] llet average =
foldleft (fun (sum,tot) e-&gt;sum +. e, 1. +. tot) (0.,0.)</p></li>
<li><p>The function names and order of arguments for
<code>List.fold_right</code> / <code>List.fold_left</code> are due
to:</p>
<ul>
<li><p><code>fold_right f</code> makes <code>f</code> <em>right
associative</em>, like list constructor ::</p>
<p>List.foldright f [a1; …; an] b is f a1 (f a2 (… (f an b)
…)).</p></li>
<li><p><code>fold_left f</code> makes <code>f</code> <em>left
associative</em>, like function application</p>
<p>List.foldleft f a [b1; …; bn] is f (… (f (f a b1) b2) …) bn.</p></li>
</ul></li>
<li><p>The “backward” structure of <code>fold_left</code>
computation:</p>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
</td>
<td style="text-align: center; vertical-align: 
middle">
</td>
<td>
</td>
</tr>
</tbody>
</table></li>
<li><p>List filtering, already rather generic (a polymorphic
higher-order function)</p>
<p>let listfilter p l = List.foldright (fun h t-&gt;if p h then h::t
else t) l []</p></li>
<li><p>Tail-recursive map returning elements in reverse order:</p>
<p>let listrevmap f l = List.foldleft (fun t h-&gt;f h::t) [] l</p></li>
</ul>
<h1 id="map-and-fold-for-trees-and-other-structures">3 <code>map</code>
and <code>fold</code> for trees and other structures</h1>
<ul>
<li><p>Mapping binary trees is straightforward:</p>
<p>type ’a btree = Empty | Node of ’a * ’a btree * ’a btree let rec
btmap f = function | Empty -&gt; Empty | Node (e, l, r) -&gt; Node (f e,
btmap f l, btmap f r) let test = Node (3, Node (5, Empty, Empty), Node
(7, Empty, Empty))let = btmap ((+) 1) test</p></li>
<li><p><code>map</code> and <code>fold</code> we consider in this
section preserve / respect the structure of the data, they <strong>do
not</strong> correspond to <code>map</code> and <code>fold</code> of
<em>abstract data type</em> containers, which are like
<code>List.rev_map</code> and <code>List.fold_left</code> over container
elements listed in arbitrary order.</p>
<ul>
<li>I.e. here we generalize <code>List.map</code> and
<code>List.fold_right</code> to other structures.</li>
</ul></li>
<li><p><code>fold</code> in most general form needs to process the
element together with partial results for the subtrees.</p>
<p>let rec btfold f base = function | Empty -&gt; base | Node (e, l,</p>
<ol start="18" type="a">
<li>-&gt; f e (btfold f base l) (btfold f base r)</li>
</ol></li>
<li><p>Examples:</p>
<p>let sumels = btfold (fun i l r -&gt; i + l + r) 0let depth t = btfold
(fun<br />
l r -&gt; 1 + max l r) 1 t</p></li>
</ul>
<h2 id="map-and-fold-for-more-complex-structures">3.1 <code>map</code>
and <code>fold</code> for more complex structures</h2>
<p>To have a data structure to work with, we recall expressions from
lecture 3.</p>
<p>type expression = Const of float | Var of string | Sum of expression
* expression (* e1 + e2 <em>) | Diff of expression </em> expression (*
e1 - e2 <em>) | Prod of expression </em> expression (* e1 * e2 <em>) |
Quot of expression </em> expression (* e1 / e2 *)</p>
<p>Multitude of cases make the datatype harder to work with.
Fortunately, <em>or-patterns</em> help a bit:</p>
<p>let rec vars = function | Const -&gt; [] | Var x -&gt; [x] | Sum
(a,b) | Diff (a,b) | Prod (a,b) | Quot (a,b) -&gt; vars a @ vars b</p>
<p>Mapping and folding needs to be specialized for each case. We pack
the behaviors into a record.</p>
<p>type expressionmap = { mapconst : float -&gt; expression; mapvar :
string -&gt; expression; mapsum : expression -&gt; expression -&gt;
expression; mapdiff : expression -&gt; expression -&gt;
expression;<br />
mapprod : expression -&gt; expression -&gt; expression; mapquot :
expression -&gt; expression -&gt; expression;}Note how
<code>expression</code> from above is substituted by <code>'a</code>
below, explain why?type ’a expressionfold = {<br />
foldconst : float -&gt; ’a; foldvar : string -&gt; ’a; foldsum : ’a
-&gt; ’a -&gt; ’a; folddiff : ’a -&gt; ’a -&gt; ’a; foldprod : ’a -&gt;
’a -&gt; ’a; foldquot : ’a -&gt; ’a -&gt; ’a;}</p>
<p>Next we define standard behaviors for <code>map</code> and
<code>fold</code>, which can be tailored to needs for particular
case.</p>
<p>let identitymap = { mapconst = (fun c -&gt; Const c); mapvar = (fun x
-&gt; Var x); mapsum = (fun a b -&gt; Sum (a, b)); mapdiff = (fun a b
-&gt; Diff (a, b)); mapprod = (fun a b -&gt; Prod (a, b)); mapquot =
(fun a b -&gt; Quot (a, b));}let makefold op base = { foldconst = (fun
-&gt; base); foldvar = (fun -&gt; base); foldsum = op; folddiff =
op;<br />
foldprod = op; foldquot = op;}</p>
<p>The actual <code>map</code> and <code>fold</code> functions are
straightforward:</p>
<p>let rec exprmap emap = function | Const c -&gt; emap.mapconst c | Var
x -&gt; emap.mapvar x | Sum (a,b) -&gt; emap.mapsum (exprmap emap a)
(exprmap emap b) | Diff (a,b) -&gt; emap.mapdiff (exprmap emap a)
(exprmap emap b) | Prod (a,b) -&gt; emap.mapprod (exprmap emap a)
(exprmap emap b) | Quot (a,b) -&gt; emap.mapquot (exprmap emap a)
(exprmap emap b)let rec exprfold efold = function | Const c -&gt;
efold.foldconst c | Var x -&gt; efold.foldvar x | Sum (a,b) -&gt;
efold.foldsum (exprfold efold a) (exprfold efold b) | Diff (a,b) -&gt;
efold.folddiff (exprfold efold a) (exprfold efold b) | Prod (a,b) -&gt;
efold.foldprod (exprfold efold a) (exprfold efold b) | Quot (a,b) -&gt;
efold.foldquot (exprfold efold a) (exprfold efold b)</p>
<p>Now examples. We use {record with field=<code>value</code>} syntax
which copies <code>record</code> but puts <code>value</code> instead of
<code>record.field</code> in the result.</p>
<p>let primevars = exprmap {identitymap with mapvar = fun x -&gt; Var
(x”’“)}let subst s = let apply x = try List.assoc x s with Notfound
-&gt; Var x in exprmap {identitymap with mapvar = apply}let vars =
exprfold {(makefold (@) []) with foldvar = fun x-&gt; [x]}let size =
exprfold (makefold (fun a b-&gt;1+a+b) 1)let eval env = exprfold {
foldconst = id;<br />
foldvar = (fun x -&gt; List.assoc x env); foldsum = (+.); folddiff =
(-.);<br />
foldprod = ( *.); foldquot = (/.);}</p>
<h1 id="point-free-programming">4 Point-free Programming</h1>
<ul>
<li><p>In 1977/78, John Backus designed <strong>FP</strong>, the first
<em>function-level programming</em> language. Over the next decade it
evolved into the <strong>FL</strong> language.</p>
<ul>
<li>”Clarity is achieved when programs are written at the function level
–that is, by putting together existing programs to form new ones, rather
than by manipulating objects and then abstracting from those objects to
produce programs.” <em>The FL Project: The Design of a Functional
Language</em></li>
</ul></li>
<li><p>For functionl-level programming style, we need
functionals/combinators, like these from <em>OCaml Batteries</em>: let
const x = xlet ( |- ) f g x = g (f x)let ( -| ) f g x = f (g x)let flip
f x y = f y xlet ( *** ) f g = fun (x,y) -&gt; (f x, g y)let (
&amp;&amp;&amp; ) f g = fun x -&gt; (f x, g x)let first f x = fst (f
x)let second f x = snd (f x)let curry f x y = f (x,y)let uncurry f (x,y)
= f x y</p></li>
<li><p>The flow of computation can be seen as a circuit where the
results of nodes-functions are connected to further nodes as inputs.</p>
<p>We can represent the cross-sections of the circuit as tuples of
intermediate values.</p></li>
<li><p>let print2 c i = let a = Char.escaped c in let b = stringofint i
in a b</p></li>
</ul>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
<br />
</td>
</tr>
<tr>
<td>
<br />
</td>
</tr>
</tbody>
</table>
<p>-9.51-4.01.0-9.4935-0.00601931-4.00.0<code>Char.escaped</code>-41<code>string_of_int</code>-4.05-5.47857e-050.513.50.50.5395720333377430.0151475062839<code>uncurry (^)</code>3.50.57.50.510.50.50cm</p>
<ul>
<li><p>Since we usually work by passing arguments one at a time rather
than in tuples, we need <code>uncurry</code> to access multi-argument
functions, and we pack the result with <code>curry</code>.</p>
<ul>
<li>Turning C/Pascal-like function into one that takes arguments one at
a time is called <em>currification</em>, after the logician Haskell
Brooks Curry.</li>
</ul></li>
<li><p>Another option to remove explicit use of function parameters,
rather than to pack intermediate values as tuples, is to use function
composition, <code>flip</code>, and the so called <strong>S</strong>
combinator:</p>
<p>let s x y z = x z (y z)</p>
<p>to bring a particular argument of a function to “front”, and pass it
a result of another function. Example: a filter-map function</p>
<p>let func2 f g l = List.filter f (List.map g (l))Definition of
function composition.let func2 f g = (-|) (List.filter f) (List.map
g)let func2 f = (-|) (List.filter f) -| List.mapCompositionagain, below
without the infix notation.let func2 f = (-|) ((-|) (List.filter f))
List.maplet func2 f = flip (-|) List.map ((-|) (List.filter f))let func2
f = (((|-) List.map) -| ((-|) -| List.filter)) flet func2 = (|-)
List.map -| ((-|) -| List.filter)</p></li>
</ul>
<h1 id="reductions.-more-higher-orderlist-functions">5 Reductions. More
higher-order/list functions</h1>
<p>Mathematics has notation for sum over an interval: <span
class="math inline">\sum_{n = a}^b f (n)</span>.</p>
<p>In OCaml, we do not have a universal addition operator:</p>
<p>let rec isumfromto f a b = if a &gt; b then 0 else f a + isumfromto f
(a+1) blet rec fsumfromto f a b = if a &gt; b then 0. else f a +.
fsumfromto f (a+1) blet pi2over6 = fsumfromto (fun i-&gt;1. /.
floatofint (i*i)) 1 5000</p>
<p>It is natural to generalize:</p>
<p>let rec opfromto op base f a b = if a &gt; b then base else op (f a)
(opfromto op base f (a+1) b)</p>
<p>Let’s collect the results of a multifunction (i.e. a set-valued
function) for a set of arguments, in math notation:</p>
<p><span class="math display"> f (A) = \bigcup_{p \in A} f (p)
</span></p>
<p>It is a useful operation over lists with <code>union</code>
translated as <code>append</code>:</p>
<p>let rec concatmap f = function | [] -&gt; [] | a::l -&gt; f a @
concatmap f l</p>
<p>and more efficiently:</p>
<p>let concatmap f l = let rec cmapf accu = function | [] -&gt; accu |
a::l -&gt; cmapf (List.revappend (f a) accu) l in List.rev (cmapf []
l)</p>
<h2 id="list-manipulation-all-subsequences-of-a-list">5.1 List
manipulation: All subsequences of a list</h2>
<p>let rec subseqs l = match l with | [] -&gt; [[]] | x::xs -&gt;<br />
let pxs = subseqs xs in List.map (fun px -&gt; x::px) pxs @ pxs</p>
<p>Tail-recursively:</p>
<p>let rec rmapappend f accu = function | [] -&gt; accu | a::l -&gt;
rmapappend f (f a :: accu) l</p>
<p>let rec subseqs l = match l with | [] -&gt; [[]] | x::xs -&gt;<br />
let pxs = subseqs xs in rmapappend (fun px -&gt; x::px) pxs pxs</p>
<p><strong>In-class work:</strong> Return a list of all possible ways of
splitting a list into two non-empty parts.</p>
<p><strong>Homework:</strong></p>
<p>Find all permutations of a list.</p>
<p>Find all ways of choosing without repetition from a list.</p>
<h2 id="by-key-group_by-and-map_reduce">5.2 By key:
<code>group_by</code> and <code>map_reduce</code></h2>
<p>It is often useful to organize values by some property.</p>
<p>First we collect an elements from an association list by key.</p>
<p>let collect l = match List.sort (fun x y -&gt; compare (fst x) (fst
y)) l with | [] -&gt; []Start with associations sorted by key. | (k0,
v0)::tl -&gt; let k0, vs, l = List.foldleft (fun (k0, vs, l) (kn, vn)
-&gt;Collect values for the current key if k0 = kn then k0, vn::vs,
<code>l</code>and when the key changes else kn, [vn], (k0,List.rev
vs)::l)stack the collected values. (k0, [v0], []) tl inWhat do we gain
by reversing?<br />
List.rev ((k0,List.rev vs)::l)</p>
<p>Now we can group by an arbitrary property:</p>
<p>let groupby p l = collect (List.map (fun e-&gt;p e, e) l)</p>
<p>But we want to process the results, like with an <em>aggregate
operation</em> in SQL. The aggregation operation is called
<strong>reduction</strong>.</p>
<p>let aggregateby p red base l = let ags = groupby p l in List.map (fun
(k,vs)-&gt;k, List.foldright red vs base) ags</p>
<p>We can use the <strong>feed-forward</strong> operator: let ( |&gt; )
x f = f x</p>
<p>let aggregateby p redf base l = groupby p l |&gt; List.map (fun
(k,vs)-&gt;k, List.foldright redf vs base)</p>
<p>Often it is easier to extract the property over which we aggregate
upfront. Since we first map the elements into the extracted key-value
pairs, we call the operation <code>map_reduce</code>:</p>
<p>let mapreduce mapf redf base l = List.map mapf l |&gt; collect |&gt;
List.map (fun (k,vs)-&gt;k, List.foldright redf vs base)</p>
<h3 id="map_reduceconcat_reduce-examples">5.2.1
<code>map_reduce</code>/<code>concat_reduce</code> examples</h3>
<p>Sometimes we have multiple sources of information rather than
records.</p>
<p>let concatreduce mapf redf base l = concatmap mapf l |&gt; collect
|&gt; List.map (fun (k,vs)-&gt;k, List.foldright redf vs base)</p>
<p>Compute the merged histogram of several documents:</p>
<p>let histogram documents = let mapf doc = Str.split (Str.regexp “[
t.,;]+”) doc |&gt; List.map (fun
<code>word</code>-&gt;<code>word</code>,1) in concatreduce mapf (+) 0
documents</p>
<p>Now compute the <em>inverted index</em> of several documents (which
come with identifiers or addresses).</p>
<p>let cons hd tl = hd::tllet invertedindex documents = let mapf (addr,
doc) =<br />
Str.split (Str.regexp “[ t.,;]+”) doc |&gt; List.map (fun
word-&gt;word,addr) in concatreduce mapf cons [] documents</p>
<p>And now… a “search engine”:</p>
<p>let search index words = match List.map (flip List.assoc index) words
with | [] -&gt; [] | idx::idcs -&gt; List.foldleft intersect idx
idcs</p>
<p>where <code>intersect</code> computes intersection of sets
represented as lists.</p>
<h3 id="tail-recursive-variants">5.2.2 Tail-recursive variants</h3>
<p>let revcollect l = match List.sort (fun x y -&gt; compare (fst x)
(fst y)) l with | [] -&gt; [] | (k0, v0)::tl -&gt; let k0, vs, l =
List.foldleft<br />
(fun (k0, vs, l) (kn, vn) -&gt; if k0 = kn then k0, vn::vs, l<br />
else kn, [vn], (k0, vs)::l) (k0, [v0], []) tl in List.rev ((k0,
vs)::l)</p>
<p>let trconcatreduce mapf redf base l = concatmap mapf l |&gt;
revcollect<br />
|&gt; List.revmap (fun (k,vs)-&gt;k, List.foldleft redf base vs)</p>
<p>let rcons tl hd = hd::tllet invertedindex documents = let mapf (addr,
doc) = … in trconcatreduce mapf rcons [] documents</p>
<h3 id="helper-functions-for-inverted-index-demonstration">5.2.3 Helper
functions for inverted index demonstration</h3>
<p>let intersect xs ys =Sets as <strong>sorted</strong> lists. let rec
aux acc = function<br />
| [], | , [] -&gt; acc | (x::xs’ as xs), (y::ys’ as ys) -&gt; let c =
compare x y in if c = 0 then aux (x::acc) (xs’, ys’) else if c &lt; 0
then aux acc (xs’, ys) else aux acc (xs, ys’) in List.rev (aux [] (xs,
ys))</p>
<pre><code>let readlines file =
  let input = open_in file in
  let rec read lines =
    (* The Scanf library uses continuation passing. *)
    try Scanf.fscanf input &quot;%[\r\n]\n&quot;
      (fun x -&gt; read (x :: lines))
    with End_of_file -&gt; lines
  in
  List.rev (read [])</code></pre>
<p>let indexed l =Index elements by their positions. Array.oflist l
|&gt; Array.mapi (fun i e-&gt;i,e) |&gt; Array.tolist</p>
<p>let searchengine lines = let lines = indexed lines in let index =
invertedindex lines in fun words -&gt; let ans = search index words
in<br />
List.map (flip List.assoc lines) ans</p>
<p>let searchbible = searchengine (readlines “./bible-kjv.txt”)let
testresult =<br />
searchbible [“Abraham”; “sons”; “wife”]</p>
<h2 id="higher-order-functions-for-the-option-type">5.3 Higher-order
functions for the <code>option</code> type</h2>
<p>Operate on an optional value:</p>
<p>let mapoption f = function | None -&gt; None | Some e -&gt; f e</p>
<p>Map an operation over a list and filter-out cases when it does not
succeed:</p>
<p>let rec mapsome f = function | [] -&gt; [] | e::l -&gt; match f e
with<br />
| None -&gt; mapsome f l | Some r -&gt; r :: mapsome f
lTail-recurively:</p>
<p>let mapsome f l = let rec mapsf accu = function | [] -&gt; accu |
a::l -&gt; mapsf (match f a with None -&gt; accu | Some r -&gt; r::accu)
l in List.rev (mapsf [] l)</p>
<h1 id="the-countdown-problem-puzzle">6 The Countdown Problem
Puzzle</h1>
<ul>
<li><p>Using a given set of numbers and arithmetic operators +, -, *, /,
construct an expression with a given value.</p></li>
<li><p>All numbers, including intermediate results, must be positive
integers.</p></li>
<li><p>Each of the source numbers can be used at most once when
constructing the expression.</p></li>
<li><p>Example:</p>
<ul>
<li>numbers 1, 3, 7, 10, 25, 50</li>
<li>target 765</li>
<li>possible solution (25-10) * (50+1)</li>
</ul></li>
<li><p>There are 780 solutions for this example.</p></li>
<li><p>Changing the target to 831 gives an example that has no
solutions.</p></li>
<li><p>Operators:</p>
<p>type op = Add | Sub | Mul | Div</p></li>
<li><p>Apply an operator:</p>
<p>let apply op x y = match op with | Add -&gt; x + y | Sub -&gt; x - y
| Mul -&gt; x * y | Div -&gt; x / y</p></li>
<li><p>Decide if the result of applying an operator to two positive
integers is another positive integer:</p>
<p>let valid op x y = match op with | Add -&gt; true | Sub -&gt; x &gt;
y | Mul -&gt; true | Div -&gt; x mod y = 0</p></li>
<li><p>Expressions:</p>
<p>type expr = Val of int | App of op * expr * expr</p></li>
<li><p>Return the overall value of an expression, provided that it is a
positive integer:</p>
<p>let rec eval = function | Val n -&gt; if n &gt; 0 then Some n else
None<br />
| App (o,l,r) -&gt; eval l |&gt; mapoption (fun x -&gt; eval r |&gt;
mapoption (fun y -&gt; if valid o x y then Some (apply o x y)<br />
else None))</p></li>
<li><p><strong>Homework:</strong> Return a list of all possible ways of
choosing zero or more elements from a list –
<code>choices</code>.</p></li>
<li><p>Return a list of all the values in an expression:</p>
<p>let rec values = function | Val n -&gt; [n] | App (,l,r) -&gt; values
l @ values r</p></li>
<li><p>Decide if an expression is a solution for a given list of source
numbers and a target number:</p>
<p>let solution e ns n = listdiff (values e) ns = [] &amp;&amp; isunique
(values e) &amp;&amp; eval e = Some n</p></li>
</ul>
<h2 id="brute-force-solution">6.1 Brute force solution</h2>
<ul>
<li><p>Return a list of all possible ways of splitting a list into two
non-empty parts:</p>
<p>let split l = let rec aux lhs acc = function | [] | [] -&gt; [] | [y;
z] -&gt; (List.rev (y::lhs), [z])::acc | hd::rhs -&gt; let lhs = hd::lhs
in aux lhs ((List.rev lhs, rhs)::acc) rhs in aux [] [] l</p></li>
<li><p>We introduce an operator to work on multiple sources of data,
producing even more data for the next stage of computation:</p>
<p>let ( |-&gt; ) x f = concatmap f x</p></li>
<li><p>Return a list of all possible expressions whose values are
precisely a given list of numbers:</p>
<p>let combine l r =Combine two expressions using each operator.
List.map (fun o-&gt;App (o,l,r)) [Add; Sub; Mul; Div]let rec exprs =
function | [] -&gt; [] | [n] -&gt; [Val n] | ns -&gt; split ns |-&gt;
(fun (ls,rs) -&gt;For each split ls,rs of numbers, exprs ls |-&gt; (fun
l -&gt;for each expression <code>l</code> over <code>ls</code> exprs rs
|-&gt; (fun r -&gt;and expression <code>r</code> over <code>rs</code>
combine l r)))produce all <code>l ?  r</code> expressions.</p></li>
<li><p>Return a list of all possible expressions that solve an instance
of the countdown problem:</p>
<p>let guard n = List.filter (fun e -&gt; eval e = Some n)</p>
<p>let solutions ns n = choices ns |-&gt; (fun ns’ -&gt; exprs ns’ |&gt;
guard n)</p></li>
<li><p>Another way to express this:</p>
<p>let guard p e = if p e then [e] else []</p>
<p>let solutions ns n = choices ns |-&gt; (fun ns’ -&gt; exprs ns’
|-&gt; guard (fun e -&gt; eval e = Some n))</p></li>
</ul>
<h2 id="fuse-the-generate-phase-with-the-test-phase">6.2 Fuse the
generate phase with the test phase</h2>
<ul>
<li><p>We seek to define a function that fuses together the generation
and evaluation of expressions:</p>
<ul>
<li>We memorize the value together with the expression – in pairs
<code>(e, eval  e)</code> – so only valid subexpressions are ever
generated.</li>
</ul>
<p>let combine’ (l,x) (r,y) = [Add; Sub; Mul; Div] |&gt; List.filter
(fun o-&gt;valid o x y) |&gt; List.map (fun o-&gt;App (o,l,r), apply o x
y)let rec results = function | [] -&gt; [] | [n] -&gt; if n &gt; 0 then
[Val n, n] else [] | ns -&gt; split ns |-&gt; (fun (ls,rs) -&gt;<br />
results ls |-&gt; (fun lx -&gt; results rs |-&gt; (fun ry -&gt;<br />
combine’ lx ry)))</p></li>
<li><p>Once the result is generated its value is already computed, we
only check if it equals the target.</p>
<p>let solutions’ ns n = choices ns |-&gt; (fun ns’ -&gt; results ns’
|&gt; List.filter (fun (e,m)-&gt; m=n) |&gt; List.map fst)We discard the
memorized values.</p></li>
</ul>
<h2 id="eliminate-symmetric-cases">6.3 Eliminate symmetric cases</h2>
<ul>
<li><p>Strengthening the valid predicate to take account of
commutativity and identity properties:</p>
<p>let valid op x y = match op with | Add -&gt; x &lt;= y | Sub -&gt; x
&gt; y | Mul -&gt; x &lt;= y &amp;&amp; x &lt;&gt; 1 &amp;&amp; y
&lt;&gt; 1 | Div -&gt; x mod y = 0 &amp;&amp; y &lt;&gt; 1</p>
<ul>
<li>We eliminate repeating symmetrical solutions on the semantic level,
i.e.  on values, rather than on the syntactic level of expressions – it
is both easier and gives better results.</li>
</ul></li>
<li><p>Now recompile combine’, results and solutions’.</p></li>
</ul>
<h1 id="the-honey-islands-puzzle">7 The Honey Islands Puzzle</h1>
<ul>
<li>Be a bee! Find the cells to eat honey out of, so that the least
amount of honey becomes sour, assuming that sourness spreads through
contact.
<ul>
<li>Honey sourness is totally made up, sorry.</li>
</ul></li>
<li>Each honeycomb cell is connected with 6 other cells, unless it is a
border cell. Given a honeycomb with some cells initially marked as
black, mark some more cells so that unmarked cells form
<code>num_islands</code> disconnected components, each with
<code>island_size</code> cells.</li>
</ul>
<p>Task: 3 islands x 3<embed src="honey0.eps" />Solution:<embed
src="honey1.eps" /></p>
<h2 id="representing-the-honeycomb">7.1 Representing the honeycomb</h2>
<p>type cell = int * intWe address cells using ‘‘cartesian’’
coordinatesmodule CellSet =and store them in either lists or sets.
Set.Make (struct type t = cell let compare = compare end)type task =
{For board ‘‘size’’ <span class="math inline">N</span>, the honeycomb
coordinates boardsize : int;range from <span class="math inline">(- 2 N,
- N)</span> to <span class="math inline">2 N, N</span>.<br />
numislands : int;Required number of islands islandsize : int;and
required number of cells in an island. emptycells : CellSet.t;The cells
that are initially without honey.}</p>
<p>let cellsetoflist l =List into set, inverse of CellSet.elements<br />
List.foldright CellSet.add l CellSet.empty</p>
<h3 id="neighborhood">7.1.1 Neighborhood</h3>
<p><embed
src="honey_min2.eps" /><code>x,y</code>-0.902203-0.291672<code>x+2,y</code>2.23049-0.376339<code>x+1,y+1</code>0.410142.35418<code>x-1,y+1</code>-2.637882.33301<code>x-2,y</code>-4.20423-0.418673<code>x-1,y-1</code>-2.65905-3.08569<code>x+1,y-1</code>0.431307-3.191530cm</p>
<p>let neighbors n eaten (x,y) = List.filter (insideboard n eaten)
[x-1,y-1; x+1,y-1; x+2,y; x+1,y+1; x-1,y+1; x-2,y]</p>
<h3 id="building-the-honeycomb">7.1.2 Building the honeycomb</h3>
<p><embed
src="honey_demo.eps" />0,0-0.373032-0.1543520,2-0.3730323.041840,-2-0.394199-3.541041,10.5159741.496664,03.33116-0.239023,12.505661.496662,21.510813.063-2,0-2.23571-0.1543520cm</p>
<p>let even x = x mod 2 = 0</p>
<p>let insideboard n eaten (x, y) = even x = even y &amp;&amp; abs y
&lt;= n &amp;&amp; abs x + abs y &lt;= 2*n &amp;&amp; not (CellSet.mem
(x,y) eaten)</p>
<p>let honeycells n eaten = fromto (-2<em>n) (2</em>n)|-&gt;(fun x -&gt;
fromto (-n) n |-&gt; (fun y -&gt; guard (insideboard n eaten) (x,
y)))</p>
<h3 id="drawing-honeycombs">7.1.3 Drawing honeycombs</h3>
<p>We separately generate colored polygons:</p>
<p>let drawhoneycomb <span class="math inline">\sim</span>w <span
class="math inline">\sim</span>h task eaten = let i2f = floatofint in
let nx = i2f (4 * task.boardsize + 2) in let ny = i2f (2 *
task.boardsize + 2) in let radius = min (i2f w /. nx) (i2f h /. ny) in
let x0 = w / 2 in let y0 = h / 2 in let dx = (sqrt 3. /. 2.) <em>.
radius +. 1. inThe distance between let dy = (3. /. 2.) </em>. radius +.
2. in<span class="math inline">(x, y)</span> and <span
class="math inline">(x + 1, y + 1)</span>. let drawcell (x,y) =
Array.init 7We draw a closed polygon by placing 6 points (fun i
-&gt;evenly spaced on a circumcircle. let phi = floatofint i <em>. pi /.
3. in x0 + intoffloat (radius </em>. sin phi +. floatofint x <em>. dx),
y0 + intoffloat (radius </em>. cos phi +. floatofint y *. dy)) in let
honey = honeycells task.boardsize (CellSet.union task.emptycells
(cellsetoflist eaten)) |&gt; List.map (fun p-&gt;drawcell p, (255, 255,
0)) in let eaten = List.map (fun p-&gt;drawcell p, (50, 0, 50)) eaten in
let oldempty = List.map (fun p-&gt;drawcell p, (0, 0, 0))
(CellSet.elements task.emptycells) in honey @ eaten @ oldempty</p>
<p>We can draw the polygons to an <em>SVG</em> image:</p>
let drawtosvg file <span class="math inline">\sim</span>w <span
class="math inline">\sim</span>h ?title ?desc curves = let f = openout
file in Printf.fprintf f
“<?xml version="1.0" standalone="no"?>&lt;!DOCTYPE svg
PUBLIC”-//W3C//DTD SVG 1.1//EN”
“http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd”&gt;<svg width="%d" height="%d" viewBox="0 0 %d %d"     xmlns="http://www.w3.org/2000/svg" version="1.1">”
w h w h; (match title with None -&gt; () | Some title -&gt;
Printf.fprintf f ”
<title>
%s
</title>
<p>n” title); (match desc with None -&gt; () | Some desc -&gt;
Printf.fprintf f ” <desc>%s</desc>n” desc); let drawshape (points,
(r,g,b)) = uncurry (Printf.fprintf f ” &lt;path d=“M %d %d”) points.(0);
Array.iteri (fun i (x, y) -&gt; if i &gt; 0 then Printf.fprintf f ” L %d
%d” x y) points; Printf.fprintf f ““n fill=”rgb(%d, %d, %d)”
stroke-width=“3” /&gt;n” r g b in List.iter drawshape curves;
Printf.fprintf f “</svg>%!”</p>
<p>But we also want to draw on a screen window – we need to link the
<code>Graphics</code> library. In the interactive toplevel:</p>
<p>##load “graphics.cma”;;</p>
<p>When compiling we just provide <code>graphics.cma</code> to the
command.</p>
<p>let drawtoscreen <span class="math inline">\sim</span>w <span
class="math inline">\sim</span>h curves = Graphics.opengraph (”
“stringofint w”x”stringofint h); Graphics.setcolor (Graphics.rgb 50 50
0);We draw a brown background. Graphics.fillrect 0 0 (Graphics.sizex ())
(Graphics.sizey ()); List.iter (fun (points, (r,g,b)) -&gt;
Graphics.setcolor (Graphics.rgb r g b); Graphics.fillpoly points)
curves; if Graphics.readkey () = <code>'q'</code>We wait so that
solutions can be seen then failwith “User interrupted finding
solutions.”;as they’re computed. Graphics.closegraph ()</p>
<h2 id="testing-correctness-of-a-solution">7.2 Testing correctness of a
solution</h2>
<p>We walk through each island counting its cells, depth-first: having
visited everything possible in one direction, we check whether something
remains in another direction.</p>
<p>Correctness means there are <code>numislands</code> components each
with <code>islandsize</code> cells. We start by computing the cells to
walk on: <code>honey</code>.</p>
<p>let checkcorrect n islandsize numislands emptycells = let honey =
honeycells n emptycells in</p>
<p>We keep track of already visited cells and islands. When an unvisited
cell is there after walking around an island, it must belong to a
different island.</p>
<p>let rec checkboard beenislands unvisited visited = match unvisited
with<br />
| [] -&gt; beenislands = numislands | cell::remaining when CellSet.mem
cell visited -&gt;
<code>checkboard been_islands remaining visited</code>Keep
looking.<br />
| cell::remaining (* when not visited *) -&gt; let (beensize, unvisited,
visited) = <code>checkisland cell</code>Visit another island.(1,
remaining, CellSet.add cell visited) in beensize = islandsize &amp;&amp;
checkboard (beenislands+1) unvisited visited</p>
<p>When walking over an island, besides the <code>unvisited</code> and
<code>visited</code> cells, we need to remember <code>been_size</code> –
number of cells in the island visited so far.</p>
<p>and checkisland current state = neighbors n emptycells current |&gt;
List<code>.foldleft</code> Walk into each direction and accumulate
visits.(fun (beensize, unvisited, visited as state) neighbor -&gt; if
CellSet.mem neighbor visited then state else let unvisited = remove
neighbor unvisited in let visited = CellSet.add neighbor visited
in<br />
let beensize = beensize + 1 in checkisland neighbor<br />
(beensize, unvisited, visited)) <code>state</code> inStart from the
current overall state (initial <code>been_size</code> is 1).</p>
<p>Initially there are no islands already visited.</p>
<p>checkboard 0 honey emptycells</p>
<h2 id="interlude-multiple-results-per-step">7.3 Interlude: multiple
results per step</h2>
<p>When there is only one possible result per step, we work through a
list using List.foldright and List.foldleft functions.</p>
<p>What if there are multiple results? Recall that when we have multiple
sources of data and want to collect multiple results, we use
<code>concat_map</code>:</p>
<p>-4.568261.32331-3.509921.34447-2.218751.32331-0.9699031.323310.3424391.30214-4.568261.32331-5.541936764122240.264965603915862-4.568261.32331-4.695263923799440.328466066940071-4.568261.32331-4.039092472549280.286132424923932-3.509921.34447-3.573422410371740.391966529964281-3.509921.34447-2.896084138113510.370799708956211-2.218751.32331-2.451580896944040.434300171980421-0.9699031.32331-1.604908056621250.413133350972351-0.9699031.32331-0.8640693213388010.3919665299642811.316111.386811.316111.386810.405939939145390.4554669929884911.316111.386811.083278211403620.476633813996561.316111.386811.8029501256780.4131333509723511.316111.386812.586122502976580.54013427702077-5.541940.264966-5.541940.264966-4.695260.328466-4.039090.286132-3.573420.391967-2.896080.3708-2.451580.4343-1.604910.413133-0.8640690.3919670.405940.4554671.083280.4766341.802950.4131332.586120.540134-5.774770.624802-6.007606826299780.56130109802884-6.02877364730784-0.0525367112051859-5.73243815319487-0.116037174229395-4.017930.794136-3.890924725492790.56130109802884-3.933258367508930.0109637518190237-4.22959386162191-0.116037174229395-3.763920.878803-3.679256515412090.0532973938351634-3.44642148432332-0.031369890197116-2.874920.89997-2.769083212065090.688302024077259-2.76908321206509-0.0102030691890462-2.98075142214579-0.031369890197116-2.557420.89997-2.557415001984390.0956310358513031-2.45158089694404-0.0737035322132557-2.091740.815303-2.007077655774570.688302024077259-2.070578118798780.0744642148432332-2.23991268686334-0.031369890197116-1.668410.878803-1.816576266701940.794136129117608-1.837743087710010.0532973938351634-1.62607487762932-0.137203995237465-0.6312340.878803-0.4830665431935440.794136129117608-0.5254001852096840.0956310358513031-0.821735679322662-0.0948703532213256-0.01739650.857637-0.1443974070644270.794136129117608-0.2078978700886360.264965603915862-0.1443974070644270.1379646778674430.1731050.7518020.0672708030162720.1591314988755130.469440.8788030.300105834105040.9634706971821670.278939013096970.05329739383516340.4271067601534590.05329739383516342.649620.9423042.882457997089560.8999702341579572.84012435507342-0.0313698901971162.48028839793623-0.0525367112051859-5.541940.264966-5.54193676412224-0.539373594390792-4.695260.328466-4.71643074480751-0.560540415398862-3.573420.391967-3.55225558936367-0.539373594390792-2.896080.3708-2.89608413811351-0.539373594390792-1.604910.413133-1.62607487762932-0.560540415398862-0.8640690.391967-0.864069321338801-0.5817072364069320.405940.4554670.38477311813732-0.5605404153988621.083280.4766341.06211139039556-0.4970399523746531.802950.4131331.78178330466993-0.4758731313665832.586120.5401342.5014552189443-0.497039952374653-5.54194-0.539374-4.71643-0.56054-3.55226-0.539374-2.89608-0.539374-1.62607-0.56054-0.864069-0.5817070.384773-0.560541.06211-0.497041.78178-0.4758732.50146-0.49704-5.541941.55614-5.859439079243291.47147440137584-5.859439079243291.11163844423866-5.626604048154520.9846375181902372.120451.534972.416787934912031.492641222383912.416787934912031.196305728270942.205119724831331.13280526524673-5.98644-0.306539-6.28277549940468-0.348872205318164-6.24044185738854-0.687541341447281-5.9229395422675-0.856875909511842.96713-0.2218713.30579441725096-0.3700390263262343.30579441725096-0.6452076994311422.88245799708956-0.85687590951184<code>concat_map</code>-11.06650.984638<code>f xs =</code>-10.34680.264966<code>List.map f xs</code>3.707961.04814<code>|&gt; List.concat</code>3.87730.0744642</p>
<p>We shortened <code>concat_map</code> calls using “work |-&gt; (fun
a_result -&gt; …)” scheme. Here we need to collect results once per
step.</p>
<p>let rec concatfold f a = function | [] -&gt; [a] | x::xs -&gt; f x a
|-&gt; (fun a’ -&gt; concatfold f a’ xs)</p>
<h2 id="generating-a-solution">7.4 Generating a solution</h2>
<p>We turn the code for testing a solution into one that generates a
correct solution.</p>
<ul>
<li>We pass around the current solution <code>eaten</code>.</li>
<li>The results will be in a list.</li>
<li>Empty list means that in a particular case there are no (further)
results.</li>
<li>When walking an island, we pick a new neighbor and try eating from
it in one set of possible solutions – which ends walking in its
direction, and walking through it in another set of possible solutions.
<ul>
<li>When testing a solution, we never decided to eat from a cell.</li>
</ul></li>
</ul>
<p>The generating function has the same signature as the testing
function:</p>
<p>let findtoeat n islandsize numislands emptycells = let honey =
honeycells n emptycells in</p>
<p>Since we return lists of solutions, if we are done with current
solution <code>eaten</code> we return <code>[eaten]</code>, and if we
are in a “dead corner” we return [].</p>
<p>let rec findboard beenislands unvisited visited eaten = match
unvisited with | [] -&gt; if beenislands = numislands then [eaten] else
[] | cell::remaining when CellSet.mem cell visited -&gt; findboard
beenislands remaining visited eaten | cell::remaining (* when not
visited *) -&gt; findisland cell (1, remaining, CellSet.add cell
visited, eaten) |-&gt;Concatenate solutions for each way of eating cells
around and island. (fun (beensize, unvisited, visited, eaten)
-&gt;<br />
if beensize = islandsize then findboard (beenislands+1)<br />
unvisited visited eaten else [])</p>
<p>We step into each neighbor of a current cell of the island, and
either eat it or walk further.</p>
<p>and findisland current state = neighbors n emptycells current |&gt;
<code>concatfold</code>Instead of <code>fold_left</code> since multiple
results.(fun neighbor<br />
(beensize, unvisited, visited, eaten as state) -&gt; if CellSet.mem
neighbor visited then [state] else let unvisited = remove neighbor
unvisited in let visited = CellSet.add neighbor visited in (beensize,
unvisited, visited,<br />
neighbor::eaten):: (* solutions where neighbor is honey *)<br />
findisland neighbor (beensize+1, unvisited, visited, eaten)) state
in</p>
<p>The initial partial solution is – nothing eaten yet.</p>
<p>checkboard 0 honey emptycells []</p>
<p>We can test it now:</p>
<p>let w = 800 and h = 800let ans0 = findtoeat testtask0.boardsize
testtask0.islandsize testtask0.numislands testtask0.emptycellslet =
drawtoscreen <span class="math inline">\sim</span>w <span
class="math inline">\sim</span>h (drawhoneycomb <span
class="math inline">\sim</span>w <span class="math inline">\sim</span>h
testtask0 (List.hd ans0))</p>
<p>But in a more complex case, finding all solutions takes too long:</p>
<p>let ans1 = findtoeat testtask1.boardsize testtask1.islandsize
testtask1.numislands testtask1.emptycellslet = drawtoscreen <span
class="math inline">\sim</span>w <span class="math inline">\sim</span>h
(drawhoneycomb <span class="math inline">\sim</span>w <span
class="math inline">\sim</span>h testtask1 (List.hd ans1))</p>
<p>(See <code>Lec6.ml</code> for definitions of test cases.)</p>
<h2 id="optimizations-for-honey-islands">7.5 Optimizations for <em>Honey
Islands</em></h2>
<ul>
<li>Main rule: <strong>fail</strong> (drop solution candidates)
<strong>as early as possible</strong>.
<ul>
<li>Is the number of solutions generated by the more brute-force
approach above <span class="math inline">2^n</span> for <span
class="math inline">n</span> honey cells, or smaller?</li>
</ul></li>
<li>We will guard both choices (eating a cell and keeping it in
island).</li>
<li>We know exactly how much honey needs to be eaten.</li>
<li>Since the state has many fields, we define a record for it.</li>
</ul>
<p>type state = { beensize: int;Number of honey cells in current
island.<br />
beenislands: int;Number of islands visited so far. unvisited: cell
list;Cells that need to be visited. visited: CellSet.t;Already visited.
eaten: cell list;Current solution candidate. moretoeat: int;Remaining
cells to eat for a complete solution.}</p>
<p>We define the basic operations on the state up-front. If you could
keep them inlined, the code would remain more similar to the previous
version.</p>
<p>let rec visitcell s = match s.unvisited with | [] -&gt; None |
c::remaining when CellSet.mem c s.visited -&gt; visitcell {s with
unvisited=remaining} | c::remaining (* when c not visited *) -&gt; Some
(c, {s with unvisited=remaining; visited = CellSet.add c s.visited})</p>
<p>let eatcell c s = {s with eaten = c::s.eaten; visited = CellSet.add c
s.visited; moretoeat = s.moretoeat - 1}</p>
<p>let keepcell c s =Actually <code>c</code> is not used… {s with
beensize = s.beensize + 1; visited = CellSet.add c s.visited}</p>
<p>let freshisland s =We increase <code>been_size</code> at the start of
<code>find_island</code> {s with beensize = 0;rather than before calling
it. beenislands = s.beenislands + 1}</p>
<p>let initstate unvisited moretoeat = { beensize =5mm 0; beenislands =
0;<br />
unvisited; visited = CellSet.empty; eaten = []; moretoeat;}</p>
<p>We need a state to begin with:</p>
<p>let initstate unvisited moretoeat = { beensize = 0; beenislands =
0;<br />
unvisited; visited = CellSet.empty; eaten = []; moretoeat;}</p>
<p>The “main loop” only changes because of the different handling of
state.</p>
<p>let rec findboard s = match visitcell s with | None -&gt; if
s.beenislands = numislands then [eaten] else [] | Some (cell, s)
-&gt;<br />
findisland cell (freshisland s) |-&gt; (fun s -&gt; if s.beensize =
s.islandsize then findboard s else [])</p>
<p>In the “island loop” we only try actions that make sense:</p>
<p>and findisland current s = let s = keepcell current s in neighbors n
emptycells current |&gt; concatfold (fun neighbor s -&gt;<br />
if CellSet.mem neighbor s.visited then [s] else let chooseeat =Guard
against actions that would fail. if s.moretoeat = 0 then [] else
[eatcell neighbor s] and choosekeep = if s.beensize &gt;= islandsize
then [] else findisland neighbor s in chooseeat @ choosekeep) s in</p>
<p>Finally, we compute the required length of <code>eaten</code> and
start searching.</p>
<p>let cellstoeat = List.length honey - islandsize * numislands in<br />
findboard (initstate honey cellstoeat)</p>
<h1 id="constraint-based-puzzles">8 Constraint-based puzzles</h1>
<ul>
<li><p>Puzzles can be presented by providing the general form of
solutions, and additional requirements that the solutions must
meet.</p></li>
<li><p>For many puzzles, the general form of solutions for a given
problem can be decomposed into a fixed number of variables.</p>
<ul>
<li>A domain of a variable is a set of possible values the variable can
have in any solution.</li>
<li>In the <em>Honey Islands</em> puzzle, the variables correspond to
cells and the domains are <span class="math inline">\lbrace
\operatorname{Honey}, \operatorname{Empty} \rbrace</span> (either a cell
has honey, or is empty – without distinguishing “initially empty” and
“eaten”).</li>
<li>In the <em>Honey Islands</em> puzzle, the constraints are: a
selection of cells that have to be empty, the number and size of
connected components of cells that are not empty. The neighborhood graph
– which cell-variable is connected with which – is part of the
constraints.</li>
</ul></li>
<li><p>There is a general and often efficient scheme of solving
constraint-based problems. <strong>Finite Domain Constraint
Programming</strong> algorithm:</p>
<ol type="1">
<li>With each variable, associate a set of values, initially equal to
the domain of the variable. The singleton containing the association is
the initial set of partial solutions.</li>
<li>While there is a solution with more than one value associated to
some variable in the set of partial solutions, select it and:
<ol type="1">
<li>If there is a possible value for some variable, such that for all
possible assignments of values to other variables, the requirements
fail, remove this value from the set associated with this variable.</li>
<li>If there is a variable with empty set of possible values associated
to it, remove the solution from the set of partial solutions.</li>
<li>Select the variable with the smallest non-singleton set associated
with it (i.e. the smallest greater than 2 size). Split that set into
similarly-sized parts. Replace the solution with two solutions where the
variable is associated with either of the two parts.</li>
</ol></li>
<li>The final solutions are built from partial solutions by assigning to
a variable the single possible value associated with it.</li>
</ol></li>
<li><p>This general algorithm can be simplified. For example, in step
(2.c), instead of splitting into two equal-sized parts, we can partition
into a singleton and remainder, or partition “all the way” into several
singletons.</p></li>
<li><p>The above definition of <em>finite domain constraint solving</em>
algorithm is sketchy. Questions?</p></li>
<li><p>We will not discuss a complete implementation example, but you
can exploit ideas from the algorithm in your homework.</p></li>
<li><p>Recall how we generated all subsequences of a list. Find
(i.e. generate) all:</p>
<ol type="1">
<li>permutations of a list;</li>
<li>ways of choosing without repetition from a list;</li>
<li>combinations of K distinct objects chosen from the N elements of a
list.</li>
</ol></li>
<li><p>Using folding for the <code>expression</code> data type, compute
the degree of the corresponding polynomial. See <a
href="http://en.wikipedia.org/wiki/Degree_of_a_polynomial">http://en.wikipedia.org/wiki/Degree_of_a_polynomial</a>.</p></li>
<li><p>Implement simplification of expressions using mapping for the
<code>expression</code> data type.</p></li>
<li><p>Express in terms of <code>fold_left</code> or
<code>fold_right</code>:</p>
<ol type="1">
<li>indexed : ’a list -&gt; (int * ’a) list, which pairs elements with
their indices in the list;</li>
<li>* <code>concat_fold</code>, as used in the solution of <em>Honey
Islands</em> puzzle:
<ul>
<li>let rec concatfold f a = function | [] -&gt; [a] | x::xs -&gt;<br />
f x a |-&gt; (fun a’ -&gt; concatfold f a’ xs)</li>
<li>Hint – consider the function:let rec concatfoldl f a = function | []
-&gt; a | x::xs -&gt; concatfoldl f (concatmap (f x) a) xs</li>
</ul></li>
<li>run-length encoding of a list (exercise 10 from <em>99
Problems</em>).
<ul>
<li><code>encode [‘a;‘a;‘a;‘a;‘b;‘c;‘c;‘a;‘a;‘d] = [4,‘a; 1,‘b; 2,‘c; 2,‘a;  1,‘d]</code></li>
</ul></li>
</ol></li>
<li><ol type="1">
<li>Write a more efficient variant of <code>list_diff</code> that
computes the difference of sets represented as sorted lists.</li>
<li><code>is_unique</code> in the provided code takes quadratic time –
optimize it.</li>
</ol></li>
<li><p>Write functions <code>compose</code> and <code>perform</code>
that take a list of functions and return their composition, i.e. a
function <code>compose [f1; ...; fn] = x -&gt; f1 (... (fn x)...)</code>
and
<code>perform [f1; ...; fn] = x -&gt; fn (... (f1 x)...)</code>.</p></li>
<li><p>Write a solver for the <em>Tents Puzzle</em> <a
href="http://www.mathsisfun.com/games/tents-puzzle.html">http://www.mathsisfun.com/games/tents-puzzle.html</a>.</p></li>
<li><p>* <strong>Robot Squad</strong>. We are given a map of terrain
with empty spaces and walls, and lidar readings for multiple robots, 8
readings of the distance to wall or another robot, for each robot.
Robots are equipped with compasses, the lidar readings are in directions
E, NE, N, NW, W, SW, S, SE. Determine the possible positions of
robots.</p></li>
<li><p>* Write a solver for the <em>Plinx Puzzle</em> <a
href="http://www.mathsisfun.com/games/plinx-puzzle.html">http://www.mathsisfun.com/games/plinx-puzzle.html</a>.
It does not need to always return correct solutions but it should
correctly solve the initial levels from the game.</p></li>
</ul>
<p>Lecture 7: Laziness</p>
<p>Lazy evaluation. Stream processing.</p>
<p>M. Douglas McIlroy <em>‘‘Power Series, Power Serious’’</em></p>
<p>Oleg Kiselyov, Simon Peyton-Jones, Amr Sabry <em>‘‘Lazy v. Yield:
Incremental, Linear Pretty-Printing’’</em></p>
<p>If you see any error on the slides, let me know!</p>
<h1 id="laziness">1 Laziness</h1>
<ul>
<li>Today’s lecture is about lazy evaluation.</li>
<li>Thank you for coming, goodbye!</li>
<li>But perhaps, do you have any questions?</li>
</ul>
<h1 id="evaluation-strategies-and-parameter-passing">2 Evaluation
strategies and parameter passing</h1>
<ul>
<li><p><strong>Evaluation strategy</strong> is the order in which
expressions are computed.</p>
<ul>
<li>For the most part: when are arguments computed.</li>
</ul></li>
<li><p>Recall our problems with using <em>flow control</em> expressions
like <code>if_then_else</code> in examples from <span
class="math inline">\lambda</span>-calculus lecture.</p></li>
<li><p>There are many technical terms describing various strategies.
Wikipedia:</p>
<p>Strict evaluationArguments are always evaluated completely before
function is applied. Non-strict evaluationArguments are not evaluated
unless they are actually used in the evaluation of the function body.
Eager evaluationAn expression is evaluated as soon as it gets bound to a
variable. Lazy evaluationNon-strict evaluation which avoids repeating
computation. Call-by-valueThe argument expression is evaluated, and the
resulting value is bound to the corresponding variable in the function
(frequently by copying the value into a new memory region).
Call-by-referenceA function receives an implicit reference to a variable
used as argument, rather than a copy of its value.</p>
<ul>
<li>In purely functional languages there is no difference between the
two strategies, so they are typically described as call-by-value even
though implementations use call-by-reference internally for
efficiency.</li>
<li>Call-by-value languages like C and OCaml support explicit references
(objects that refer to other objects), and these can be used to simulate
call-by-reference. Normal order Start computing function bodies before
evaluating their arguments. Do not even wait for arguments if they are
not needed. Call-by-nameArguments are substituted directly into the
function body and then left to be evaluated whenever they appear in the
function. Call-by-needIf the function argument is evaluated, that value
is stored for subsequent uses.</li>
</ul></li>
<li><p>Almost all languages do not compute inside the body of un-applied
function, but with curried functions you can pre-compute data before all
arguments are provided.</p>
<ul>
<li>Recall the <code>search_bible</code> example.</li>
</ul></li>
<li><p>In eager / call-by-value languages we can simulate call-by-name
by taking a function to compute the value as an argument instead of the
value directly.</p>
<ul>
<li>”Our” languages have a <code>unit</code> type with a single value ()
specifically for use as throw-away arguments.</li>
<li>Scala has a built-in support for call-by-name (i.e. direct, without
the need to build argument functions).</li>
</ul></li>
<li><p>ML languages have built-in support for lazy evaluation.</p></li>
<li><p>Haskell has built-in support for eager evaluation.</p></li>
</ul>
<h1 id="call-by-name-streams">3 Call-by-name: streams</h1>
<ul>
<li><p>Call-by-name is useful not only for implementing flow control</p>
<ul>
<li>let ifthenelse cond e1 e2 = match cond with true -&gt; e1 () | false
-&gt; e2 ()</li>
</ul>
<p>but also for arguments of value constructors, i.e. for data
structures.</p></li>
<li><p><strong>Streams</strong> are lists with call-by-name tails.</p>
<p>type ’a stream = SNil | SCons of ’a * (unit -&gt; ’a stream)</p></li>
<li><p>Reading from a stream into a list.</p>
<p>let rec stake n = function | SCons (a, s) when n &gt; 0 -&gt;
a::(stake (n-1) (s ())) | -&gt; []</p></li>
<li><p>Streams can easily be infinite.</p>
<p>let rec sones = SCons (1, fun () -&gt; sones)let rec sfrom n = SCons
(n, fun () -&gt;sfrom (n+1))</p></li>
<li><p>Streams admit list-like operations.</p>
<p>let rec smap f = function | SNil -&gt; SNil | SCons (a, s) -&gt;
SCons (f a, fun () -&gt; smap f (s ()))let rec szip = function | SNil,
SNil -&gt; SNil | SCons (a1, s1), SCons (a2, s2) -&gt; SCons ((a1, a2),
fun () -&gt; szip (s1 (), s2 ())) | -&gt; raise (Invalidargument
“szip”)</p></li>
<li><p>Streams can provide scaffolding for recursive algorithms:</p>
<p>let rec sfib = SCons (1, fun () -&gt; smap (fun (a,b)-&gt; a+b) (szip
(sfib, SCons (1, fun () -&gt; sfib))))</p>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
</tbody>
</table>
<p>-3.45314-0.974534-3.85530493451515-0.297195396216431-3.262633946289190.020306918904617-3.89764-0.254862-3.876471755523220.464810160074084-3.241467125281120.930480222251621-2.33129-1.0592-2.60646249503903-0.276028575208361-2.267793358909910.0414737399126869-1.46345-0.9957-1.73862283370816-0.276028575208361-1.442287339595180.0626405609207567-1.73862-0.254862-2.013791506813070.676478370154782-1.548121444635531.03631432729197-2.62763-0.276029-2.796963884111650.507143802090224-2.373627463950261.0151475062839+-3.7833-0.582834+-2.55958-0.567776+-1.69025-0.5390640cm</p></li>
<li><p>Streams are less functional than could be expected in context of
input-output effects.</p>
<p>let filestream name = let ch = openin name in let rec chreadline ()
=<br />
try SCons (inputline ch, chreadline) with Endoffile -&gt; SNil in<br />
chreadline ()</p></li>
<li><p><em>OCaml Batteries</em> use a stream type <code>enum</code> for
interfacing between various sequence-like data types.</p>
<ul>
<li>The safest way to use streams in a <em>linear</em> /
<em>ephemeral</em> manner: every value used only once.</li>
<li>Streams minimize space consumption at the expense of time for
recomputation.</li>
</ul></li>
</ul>
<h1 id="lazy-values">4 Lazy values</h1>
<ul>
<li><p>Lazy evaluation is more general than call-by-need as any value
can be lazy, not only a function parameter.</p></li>
<li><p>A <em>lazy value</em> is a value that “holds” an expression until
its result is needed, and from then on it “holds” the result.</p>
<ul>
<li>Also called: a <em>suspension</em>. If it holds the expression,
called a <em>thunk</em>.</li>
</ul></li>
<li><p>In OCaml, we build lazy values explicitly. In Haskell, all values
are lazy but functions can have call-by-value parameters which “need”
the argument.</p></li>
<li><p>To create a lazy value: lazy expr – where <code>expr</code> is
the suspended computation.</p></li>
<li><p>Two ways to use a lazy value, be careful when the result is
computed!</p>
<ul>
<li>In expressions: Lazy.force l_expr</li>
<li>In patterns: match lexpr with lazy v -&gt; …
<ul>
<li>Syntactically lazy behaves like a data constructor.</li>
</ul></li>
</ul></li>
<li><p>Lazy lists:</p>
<p>type ’a llist = LNil | LCons of ’a * ’a llist Lazy.t</p></li>
<li><p>Reading from a lazy list into a list:</p>
<p>let rec ltake n = function | LCons (a, lazy l) when n &gt; 0 -&gt;
a::(ltake (n-1) l) | -&gt; []</p></li>
<li><p>Lazy lists can easily be infinite:</p>
<p>let rec lones = LCons (1, lazy lones)let rec lfrom n = LCons (n, lazy
(lfrom (n+1)))</p></li>
<li><p>Read once, access multiple times:</p>
<p>let filellist name = let ch = openin name in let rec chreadline ()
=<br />
try LCons (inputline ch, lazy (chreadline ())) with Endoffile -&gt; LNil
in chreadline ()</p></li>
<li><p>let rec lzip = function | LNil, LNil -&gt; LNil | LCons (a1,
ll1), LCons (a2, ll2) -&gt; LCons ((a1, a2), lazy ( lzip (Lazy.force
ll1, Lazy.force ll2))) | -&gt; raise (Invalidargument “lzip”)</p>
<p>let rec lmap f = function | LNil -&gt; LNil | LCons (a, ll) -&gt;
LCons (f a, lazy (lmap f (Lazy.force ll)))</p></li>
<li><p>let posnums = lfrom 1let rec lfact = LCons (1, lazy (lmap (fun
(a,b)-&gt; a*b) (lzip (lfact, posnums))))</p>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
</tbody>
</table>
<p>-3.24858-1.02259-3.5449133483265-0.239416589495965-3.290911496229660.0569189046170128-2.40191-1.00142-2.65590686598756-0.281750231512105-2.380738192882660.0145852626008731-1.5129-0.980255-1.70339992062442-0.218249768487895-1.512898531551790.0145852626008731-0.327557-1.02259-0.772059796269348-0.0489152004233364-0.3063897340918110.1839198306654320.878952-1.022590.392115359174494-0.2394165894959650.6037835692551920.0780857256250827-3.56608-0.260583-3.629580632358780.691923534859108-3.33324513824581.03059267098823-2.67707-0.260583-2.69824050800370.734257176875248-2.42307183489881.0517594919963-1.7034-0.21825-1.872734488688980.670756713851039-1.555232173567931.0517594919963-0.77206-0.0489152-0.9413943643339070.903591744939807-0.6238920492128591.094093134012440.392115-0.2394170.2862812541341450.6284230718348990.6249503902632621.0517594919963<em>-2.60922-0.546619</em>-1.66302-0.503353<em>-0.632667-0.5082</em>0.504955-0.500198*-3.48713460768869-0.5100825754830590cm</p></li>
</ul>
<h1 id="power-series-and-differential-equations">5 Power series and
differential equations</h1>
<ul>
<li><p>Differential equations idea due to Henning Thielemann.
<strong>Just an example.</strong></p></li>
<li><p>Expression <span class="math inline">P (x) = \sum_{i = 0}^n a_{i}
x^i</span> defines a polynomial for <span class="math inline">n
&lt; \infty</span> and a power series for <span class="math inline">n =
\infty</span>.</p></li>
<li><p>If we define</p>
<p>let rec lfoldright f l base = match l with | LNil -&gt; base | LCons
(a, lazy l) -&gt; f a (lfoldright f l base)</p>
<p>then we can compute polynomials</p>
<p>let horner x l = lfoldright (fun c sum -&gt; c +. x *. sum) l
0.</p></li>
<li><p>But it will not work for infinite power series!</p>
<ul>
<li>Does it make sense to compute the value at <span
class="math inline">x</span> of a power series?</li>
<li>Does it make sense to fold an infinite list?</li>
</ul></li>
<li><p>If the power series converges for <span class="math inline">x
&gt; 1</span>, then when the elements <span
class="math inline">a_{n}</span> get small, the remaining sum <span
class="math inline">\sum_{i = n}^{\infty} a_{i} x^i</span> is also
small.</p></li>
<li><p><code>lfold_right</code> falls into an infinite loop on infinite
lists. We need call-by-name / call-by-need semantics for the argument
function <code>f</code>.</p>
<p>let rec lazyfoldr f l base = match l with | LNil -&gt; base | LCons
(a, ll) -&gt; f a (lazy (lazyfoldr f (Lazy.force ll) base))</p></li>
<li><p>We need a stopping condition in the Horner algorithm step:</p>
<p>let lhorner x l =This is a bit of a hack, let upd c sum =we hope to
‘‘hit’’ the interval <span class="math inline">(0, \varepsilon]</span>.
if c = 0. || absfloat c &gt; epsilonfloat then c +. x *. Lazy.force sum
else 0. in lazyfoldr upd l 0.</p>
<p>let invfact = lmap (fun n -&gt; 1. /. floatofint n) lfactlet e =
lhorner 1. invfact</p></li>
</ul>
<h2 id="power-series-polynomial-operations">5.1 Power series /
polynomial operations</h2>
<ul>
<li>let rec add xs ys = match xs, ys with | LNil, -&gt; ys | , LNil
-&gt; xs | LCons (x,xs), LCons (y,ys) -&gt; LCons (x +. y, lazy (add
(Lazy.force xs) (Lazy.force ys)))</li>
<li>let rec sub xs ys = match xs, ys with | LNil, -&gt; lmap (fun x-&gt;
<span class="math inline">\sim</span>-.x) ys | , LNil -&gt; xs | LCons
(x,xs), LCons (y,ys) -&gt;<br />
LCons (x-.y, lazy (add (Lazy.force xs) (Lazy.force ys)))</li>
<li>let scale s = lmap (fun x-&gt;s*.x)</li>
<li>let rec shift n xs = if n = 0 then xs else if n &gt; 0 then LCons
(0. , lazy (shift (n-1) xs)) else match xs with | LNil -&gt; LNil |
LCons (0., lazy xs) -&gt; shift (n+1) xs | -&gt; failwith “shift:
fractional division”</li>
<li>let rec mul xs = function | LNil -&gt; LNil | LCons (y, ys) -&gt;
add (scale y xs) (LCons (0., lazy (mul xs (Lazy.force ys))))</li>
<li>let rec div xs ys = match xs, ys with | LNil, -&gt; LNil | LCons
(0., xs’), LCons (0., ys’) -&gt; div (Lazy.force xs’) (Lazy.force ys’) |
LCons (x, xs’), LCons (y, ys’) -&gt; let q = x /. y in LCons (q, lazy
(divSeries (sub (Lazy.force xs’) (scale q (Lazy.force ys’))) ys)) |
LCons , LNil -&gt; failwith “divSeries: division by zero”</li>
<li>let integrate c xs = LCons (c, lazy (lmap (uncurry (/.)) (lzip (xs,
posnums))))</li>
<li>let ltail = function | LNil -&gt; invalidarg “ltail” | LCons (, lazy
tl) -&gt; tl</li>
<li>let differentiate xs = lmap (uncurry ( *.)) (lzip (ltail xs,
posnums))</li>
</ul>
<h2 id="differential-equations">5.2 Differential equations</h2>
<ul>
<li><p><span class="math inline">\frac{\mathrm{d} \sin x}{\mathrm{d} x}
= \cos x, \frac{\mathrm{d} \cos
x}{\mathrm{d} x} = - \sin x, \sin 0 = 0, \cos 0 = 1</span>.</p></li>
<li><p>We will solve the corresponding integral equations.
<em>Why?</em></p></li>
<li><p>We cannot define the integral by direct recursion like this:</p>
<p>let rec sin = integrate (ofint 0) cosUnary op. let (<span
class="math inline">\sim</span>-:) =and cos = integrate (ofint 1) <span
class="math inline">\sim</span>-:sin lmap (fun x-&gt; <span
class="math inline">\sim</span>-.x)</p>
<p>unfortunately fails:</p>
<p><code>Error: This kind of expression is not allowed as right-hand side of ‘let  rec'</code></p>
<ul>
<li>Even changing the second argument of <code>integrate</code> to
call-by-need does not help, because OCaml cannot represent the values
that <code>x</code> and <code>y</code> refer to.</li>
</ul></li>
<li><p>We need to inline a bit of <code>integrate</code> so that OCaml
knows how to start building the recursive structure.</p>
<p>let integ xs = lmap (uncurry (/.)) (lzip (xs, posnums))let rec sin =
LCons (ofint 0, lazy (integ cos))and cos = LCons (ofint 1, lazy (integ
<span class="math inline">\sim</span>-:sin))</p></li>
<li><p>The complete example would look much more elegant in
Haskell.</p></li>
<li><p>Although this approach is not limited to linear equations,
equations like Lotka-Volterra or Lorentz are not “solvable” – computed
coefficients quickly grow instead of quickly falling…</p></li>
<li><p>Drawing functions are like in previous lecture, but with open
curves.</p></li>
<li><p>let plot1D f <span class="math inline">\sim</span>w <span
class="math inline">\sim</span>scale <span
class="math inline">\sim</span>tbeg <span
class="math inline">\sim</span>tend = let dt = (tend -. tbeg) /. ofint w
in Array.init w (fun i -&gt; let y = lhorner (dt <em>. ofint i) f in i,
to_int (scale </em>. y))</p></li>
</ul>
<h1 id="arbitrary-precision-computation">6 Arbitrary precision
computation</h1>
<ul>
<li><p>Putting it all together reveals drastic numerical errors for
large <span class="math inline">x</span>.</p>
<p>let graph = let scale = ofint h /. ofint 8 in [plot1D sin <span
class="math inline">\sim</span>w <span
class="math inline">\sim</span>h0:(h/2) <span
class="math inline">\sim</span>scale <span
class="math inline">\sim</span>tbeg:(ofint 0) <span
class="math inline">\sim</span>tend:(ofint 15),<br />
(250,250,0); plot1D cos <span class="math inline">\sim</span>w <span
class="math inline">\sim</span>h0:(h/2) <span
class="math inline">\sim</span>scale<br />
<span class="math inline">\sim</span>tbeg:(ofint 0) <span
class="math inline">\sim</span>tend:(ofint 15), (250,0,250)]let () =
drawtoscreen <span class="math inline">\sim</span>w <span
class="math inline">\sim</span>h graph</p>
<ul>
<li>Floating-point numbers have limited precision.</li>
<li>We break out of Horner method computations too quickly.</li>
</ul>
<p><embed src="sin_cos_1.eps" /></p></li>
<li><p>For infinite precision on rational numbers we use the
<code>nums</code> library.</p>
<ul>
<li>It does not help – yet.</li>
</ul></li>
<li><p>Generate a sequence of approximations to the power series limit
at <span class="math inline">x</span>.</p>
<p>let infhorner x l = let upd c sum = LCons (c, lazy (lmap (fun apx
-&gt; c+.x*.apx) (Lazy.force sum))) in lazyfoldr upd l (LCons (ofint 0,
lazy LNil))</p></li>
<li><p>Find where the series converges – as far as a given test is
concerned.</p>
<p>let rec exact f = functionWe arbitrarily decide that convergence is |
LNil -&gt; assert falsewhen three consecutive results are the same. |
LCons (x0, lazy (LCons (x1, lazy (LCons (x2, ))))) when f x0 = f x1
&amp;&amp; f x0 = f x2 -&gt; f x0 | LCons (, lazy tl) -&gt; exact f
tl</p></li>
<li><p>Draw the pixels of the graph at exact coordinates.</p>
<p>let plot1D f <span class="math inline">\sim</span>w <span
class="math inline">\sim</span>h0 <span
class="math inline">\sim</span>scale <span
class="math inline">\sim</span>tbeg <span
class="math inline">\sim</span>tend = let dt = (tend -. tbeg) /. ofint w
in let eval = exact (fun y-&gt; toint (scale <em>. y)) in Array.init w
(fun i -&gt; let y = infhorner (tbeg +. dt </em>. ofint i) f in i, h0 +
eval y)</p></li>
<li><p>Success! If a power series had every third term contributing we
would have to check three terms in the function <code>exact</code>…</p>
<ul>
<li>We could like in <code>lhorner</code> test for
<code>f x0 = f x1 &amp;&amp; not x0 =. x1</code></li>
</ul></li>
<li><p>Example <code>n_chain</code>: nuclear chain reaction–<em>A decays
into B decays into C</em></p>
<ul>
<li><a
href="http://en.wikipedia.org/wiki/Radioactive_decay#Chain-decay_processes">http://en.wikipedia.org/wiki/Radioactive_decay#Chain-decay_processes</a></li>
</ul>
<p>let nchain <span class="math inline">\sim</span>nA0 <span
class="math inline">\sim</span>nB0 <span
class="math inline">\sim</span>lA <span
class="math inline">\sim</span>lB = let rec nA = LCons (nA0, lazy (integ
(<span class="math inline">\sim</span>-.lA <em>:. nA))) and nB = LCons
(nB0, lazy (integ (<span class="math inline">\sim</span>-.lB </em>:. nB
+: lA *:. nA))) in nA, nB</p></li>
</ul>
<p><embed src="chain_reaction.eps" /></p>
<h1 id="circular-data-structures-double-linked-list">7 Circular data
structures: double-linked list</h1>
<ul>
<li><p>Without delayed computation, the ability to define data
structures with referential cycles is very limited.</p></li>
<li><p>Double-linked lists contain such cycles between any two nodes
even if they are not cyclic when following only <em>forward</em> or
<em>backward</em> links.</p>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>-5.517280.0390925-4.670607884640830.102592935573489-4.564773779600480.0602592935573488-4.1626-0.00324117-4.88227609472152-0.214909379547559-5.05161066278608-0.10907527450721-2.215260.0179257-1.516751554438420.229593861621908-1.410917449398070.123759756581558-0.987581-0.00324117-1.68608612250298-0.15140891652335-1.8130870485514-0.06674163249107020.9809330.01792571.615937954755920.1660933985976981.827606164836620.01792565154120922.20861-0.06674161.57360431273978-0.2784098425717691.40426974467522-0.151408916523354.198290.03909254.812127926974470.1872602196057684.981462495039030.1237597565815585.44713-0.0244084.74862746395026-0.172575737531424.5792928958857-0.151408916523350cm</p></li>
<li><p>We need to “break” the cycles by making some links lazy.</p></li>
<li><p>type ’a dllist = DLNil | DLCons of ’a dllist Lazy.t * ’a * ’a
dllist</p></li>
<li><p>let rec dldrop n l = match l with | DLCons (, x, xs) when n&gt;0
-&gt; dldrop (n-1) xs | -&gt; l</p></li>
<li><p>let dllistoflist l = let rec dllist prev l = match l with | []
-&gt; DLNil | x::xs -&gt; let rec cell = lazy (DLCons (prev, x, dllist
cell xs)) in Lazy.force cell in dllist (lazy DLNil) l</p></li>
<li><p>let rec dltake n l = match l with | DLCons (, x, xs) when n&gt;0
-&gt; x::dltake (n-1) xs | -&gt; []</p></li>
<li><p>let rec dlbackwards n l = match l with | DLCons (lazy xs, x, )
when n&gt;0 -&gt; x::dlbackwards (n-1) xs | -&gt; []</p></li>
</ul>
<h1 id="input-output-streams">8 Input-Output streams</h1>
<ul>
<li><p>The stream type used a throwaway argument to make a
suspension</p>
<p>type ’a stream = SNil | SCons of ’a * (unit -&gt; ’a stream)</p>
<p>What if we take a real argument?</p>
<p>type (’a, ’b) iostream = EOS | More of ’b * (’a -&gt; (’a, ’b)
iostream)</p>
<p>A stream that for a single input value produces an output
value.</p></li>
<li><p>type ’a istream = (unit, ’a) iostreamInput stream produces output
when “asked”.</p>
<p>type ’a ostream = (’a, unit) iostreamOutput stream consumes provided
input.</p>
<ul>
<li>Sorry, the confusion arises from adapting the <em>input file /
output file</em> terminology, also used for streams.</li>
</ul></li>
<li><p>We can compose streams: directing output of one to input of
another.</p>
<p>let rec compose sf sg = match sg with | EOS -&gt; EOSNo more output.|
More (z, g) -&gt; match sf withNo more | EOS -&gt; More (z, fun -&gt;
EOS)input ‘‘processing power’’. | More (y, f) -&gt; let update x =
compose (f x) (g y) in More (z, update)</p>
<ul>
<li>Every box has one incoming and one outgoing wire:
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
</td>
</tr>
<tr>
<td style="vertical-align: middle">
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
<tr>
<td>
</td>
</tr>
</tbody>
</table>
0.02903822.280180.02903823257044581.41233959518455-0.03446220.459833-0.0344622304537637-0.492674295541738-0.0132954-1.40285-0.0132954094456939-2.228353618203470cm</li>
<li>Notice how the output stream is ahead of the input stream.</li>
</ul></li>
</ul>
<h2 id="pipes">8.1 Pipes</h2>
<ul>
<li><p>We need a more flexible input-output stream definition.</p>
<ul>
<li>Consume several inputs to produce a single output.</li>
<li>Produce several outputs after a single input (or even without
input).</li>
<li>No need for a dummy when producing output requires input.</li>
</ul></li>
<li><p>After Haskell, we call the data structure <code>pipe</code>.</p>
<p>type (’a, ’b) pipe = EOP| Yield of ’b * (’a, ’b) <code>pipe</code>For
incremental streams change to lazy.|Await of ’a -&gt; (’a, ’b)
pipe</p></li>
<li><p>Again, we can have producing output only <em>input pipes</em> and
consuming input only <em>output pipes</em>.</p>
<p>type ’a ipipe = (unit, ’a) pipetype voidtype ’a opipe = (’a, void)
pipe</p>
<ul>
<li>Why <code>void</code> rather than <code>unit</code>, and why only
for <code>opipe</code>?</li>
</ul></li>
<li><p>Composition of pipes is like “concatenating them in space” or
connecting boxes:</p>
<p>let rec compose pf pg = match pg with | EOP -&gt; EOPDone producing
results. | Yield (z, pg’) -&gt; Yield (z, compose pf pg’)Ready result. |
Await g -&gt; match pf with | EOP -&gt; EOPEnd of input. | Yield (y,
pf’) -&gt; compose pf’ (g y)Compute next result. | Await f -&gt;<br />
let update x = compose (f x) pg in Await updateWait for more input.</p>
<p>let (&gt;-&gt;) pf pg = compose pf pg</p></li>
<li><p>Appending pipes means “concatenating them in time” or adding more
fuel to a box:</p>
<p>let rec append pf pg = match pf with | EOP -&gt; <code>pg</code>When
<code>pf</code> runs out, use <code>pg</code>.|Yield (z, pf’) -&gt;
Yield (z, append pf’ pg) | Await f -&gt;If <code>pf</code> awaits input,
continue when it comes. let update x = append (f x) pg in Await
update</p></li>
<li><p>Append a list of ready results in front of a pipe.</p>
<p>let rec yieldall l tail = match l with | [] -&gt; tail | x::xs -&gt;
Yield (x, yieldall xs tail)</p></li>
<li><p>Iterate a pipe (<strong>not functional</strong>).</p>
<p>let rec iterate f : ’a opipe = Await (fun x -&gt; let () = f x in
iterate</p>
<ol start="6" type="a">
<li></li>
</ol></li>
</ul>
<h2 id="example-pretty-printing">8.2 Example: pretty-printing</h2>
<ul>
<li><p>Print hierarchically organized document with a limited line
width.</p>
<p>type doc = Text of string | Line | Cat of doc * doc | Group of
doc</p></li>
<li><p>let (++) d1 d2 = Cat (d1, Cat (Line, d2))let (!) s = Text slet
testdoc =<br />
Group (!“Document” ++ Group (!“First part” ++ !“Second part”))</p>
<div class="sourceCode" id="cb52"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> () = printendline (pretty <span class="dv">30</span> testdoc);;</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>DocumentFirst part Second part</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> () = printendline (pretty <span class="dv">20</span> testdoc);;</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>DocumentFirst partSecond part</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> () = printendline (pretty <span class="dv">60</span> testdoc);;</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>Document First part Second part</span></code></pre></div></li>
<li><p>Straightforward solution:</p></li>
</ul>
<pre><code>let pretty w d =  (* Allowed width of line `w`. *)
  let rec width = function  (* Total length of subdocument. *)
    | Text z -&gt; String.length z
    | Line -&gt; 1
    | Cat (d1, d2) -&gt; width d1 + width d2
    | Group d -&gt; width d
  in
  let rec format f r = function  (* Remaining space `r`. *)
    | Text z -&gt; z, r - String.length z
    | Line when f -&gt; &quot; &quot;, r-1  (* If `not f` then line breaks. *)
    | Line -&gt; &quot;\n&quot;, w
    | Cat (d1, d2) -&gt;
      let s1, r = format f r d1 in
      let s2, r = format f r d2 in
      s1 ^ s2, r
    (* If following group fits, then without line breaks. *)
    | Group d -&gt; format (f || width d &lt;= r) r d
  in
  fst (format false w d)</code></pre>
<ul>
<li><p>Working with a stream of nodes.</p>
<p>type (’a, ’b) doce =Annotated nodes, special for group beginning. TE
of ’a</p>
<ul>
<li>string | LE of ’a | GBeg of ’b | GEnd of ’a</li>
</ul></li>
<li><p>Normalize a subdocument – remove empty groups.</p>
<p>let rec norm = function | Group d -&gt; norm d | Text “” -&gt; None |
Cat (Text ““, d) -&gt; norm d | d -&gt; Some d</p></li>
<li><p>Generate the stream by infix traversal.</p>
<p>let rec gen = function | Text z -&gt; Yield (TE ((),z), EOP) | Line
-&gt; Yield (LE (), EOP) | Cat (d1, d2) -&gt; append (gen d1) (gen d2) |
Group d -&gt; match norm d with | None -&gt; EOP | Some d -&gt; Yield
(GBeg (), append (gen d) (Yield (GEnd (), EOP)))</p></li>
<li><p>Compute lengths of document prefixes, i.e. the position of each
node counting by characters from the beginning of document.</p>
<p>let rec docpos curpos = Await (functionWe input from a
<code>doc_e</code> pipe | TE (, z) -&gt; Yield (TE (curpos, z),and
output <code>doc_e</code> annotated with position. docpos (curpos +
String.length z)) | LE -&gt;Spice and line breaks increase position by
1. Yield (LE curpos, docpos (curpos + 1)) | GBeg -&gt;Groups do not
increase position. Yield (GBeg curpos, docpos curpos) | GEnd -&gt; Yield
(GEnd curpos, docpos curpos))</p>
<p>let docpos = docpos 0The whole document starts at 0.</p></li>
<li><p>Put the end position of the group into the group beginning
marker, so that we can know whether to break it into multiple lines.</p>
<p>let rec grends grstack = Await (function | TE | LE as e -&gt; (match
grstack with | [] -&gt; Yield (e, grends [])We can yield only when |
gr::grs -&gt; grends ((e::gr)::grs))no group is waiting. | GBeg -&gt;
grends ([]::grstack)Wait for end of group. | GEnd endp -&gt; match
grstack withEnd the group on top of stack. | [] -&gt; failwith “grends:
unmatched group end marker” | [gr] -&gt;Top group – we can yield
now.<br />
yieldall (GBeg endp::List.rev (GEnd endp::gr)) (grends [])<br />
| gr::par::grs -&gt;Remember in parent group instead. let par = GEnd
endp::gr @ [GBeg endp] @ par in grends (par::grs))Could use
<em>catenable lists</em> above.</p></li>
<li><p>That’s waiting too long! We can stop waiting when the width of a
group exceeds line limit. GBeg will not store end of group when it is
irrelevant.</p>
<p>let rec grends w grstack = let flush tail =When the stack exceeds
width <code>w</code>, <code>yieldall</code>flush it – yield everything
in it.(revconcatmap <span class="math inline">\sim</span>prep:(GBeg
Toofar) snd grstack) tail inAbove: concatenate in rev. with
<code>prep</code> before each part. Await (function | TE (curp, ) | LE
curp as e -&gt; (match grstack withRemember beginning of groups in the
stack.<br />
| [] -&gt; Yield (e, grends w []) | (begp, ):: when curp-begp &gt; w
-&gt; flush (Yield (e, grends w [])) | (begp, gr)::grs -&gt; grends w
((begp, e::gr)::grs)) | GBeg begp -&gt; grends w ((begp, [])::grstack) |
GEnd endp as e -&gt; match grstack withNo longer fail when the stack is
empty – | [] -&gt; Yield (e, grends w [])could have been flushed. |
(begp, ):: when endp-begp &gt; w -&gt; flush (Yield (e, grends w [])) |
[, gr] -&gt;If width not exceeded, <code>yieldall</code>work as before
optimization.(GBeg (Pos endp)::List.rev (GEnd endp::gr)) (grends w []) |
(, gr)::(parbegp, par)::grs -&gt;<br />
let par = GEnd endp::gr @ [GBeg (Pos endp)] @ par in grends w ((parbegp,
par)::grs))</p></li>
<li><p>Initial stack is empty:</p>
<p>let grends w = grends w []</p></li>
<li><p>Finally we produce the resulting stream of strings.</p></li>
</ul>
<pre><code>(* State: the stack of &quot;group fits in line&quot;; position where end of line would be. *)
let rec format w (inline, endlpos as st) = Await (function
  | TE (_, z) -&gt; Yield (z, format w st)
  | LE p when List.hd inline -&gt;
    Yield (&quot; &quot;, format w st)  (* After return, line has `w` free space. *)
  | LE p -&gt; Yield (&quot;\n&quot;, format w (inline, p+w))
  | GBeg Toofar -&gt;  (* Group with end too far is not inline. *)
    format w (false::inline, endlpos)
  | GBeg (Pos p) -&gt;  (* Group is inline if it ends soon enough. *)
    format w ((p&lt;=endlpos)::inline, endlpos)
  | GEnd _ -&gt; format w (List.tl inline, endlpos))

let format w = format w ([false], w)  (* Break lines outside of groups. *)</code></pre>
<ul>
<li><p>Put the pipes together:</p>
<p>let prettyprint w doc =</p>
<table style="display: inline-table; 
vertical-align: middle">
<tbody>
<tr>
<td style="text-align: center">
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td style="text-align: center">
</td>
</tr>
</tbody>
</table>
<p>-7.32332-0.0176611-6.8788199497288-0.0176610662786083-4.10597-0.0176611-3.64029633549411-0.0176610662786083-0.1477710.003505750.2755655509988090.003505754729461573.76809-0.01766114.233761079507870.003505754729461570cm</p></li>
<li><p>Factorize <code>format</code> so that various line breaking
styles can be plugged in.</p>
<p>let rec breaks w (inline, endlpos as st) = Await (function | TE as e
-&gt; Yield (e, breaks w st) | LE p when List.hd inline -&gt; Yield (TE
(p, ” “), breaks w st) | LE p as e -&gt; Yield (e, breaks w (inline,
p+w)) | GBeg Toofar as e -&gt; Yield (e, breaks w (false::inline,
endlpos)) | GBeg (Pos p) as e -&gt; Yield (e, breaks w
((p&lt;=endlpos)::inline, endlpos)) | GEnd as e -&gt; Yield (e, breaks w
(List.tl inline, endlpos)))let breaks w = breaks w ([false], w)<br />
let rec emit = Await (function | TE (, z) -&gt; Yield (z, emit) | LE
-&gt; Yield (”n”, emit) | GBeg | GEnd -&gt; emit)let prettyprint w doc =
gen doc &gt;-&gt; docpos &gt;-&gt; grends w &gt;-&gt; breaks w &gt;-&gt;
emit &gt;-&gt; iterate printstring</p></li>
<li><p>Tests.</p>
<p>let (++) d1 d2 = Cat (d1, Cat (Line, d2))let (!) s = Text slet
testdoc =<br />
Group (!“Document” ++ Group (!“First part” ++ !“Second part”))let
printedoc prp prep = function | TE (p,z) -&gt; prp p; printendline
(“:”z) | LE p -&gt; prp p; printendline “: endline” | GBeg ep -&gt; prep
ep; printendline “: GBeg” | GEnd p -&gt; prp p; printendline “: GEnd”let
noop () = ()let printpos = function | Pos p -&gt; printint p | Toofar
-&gt; printstring “Too far”let = gen testdoc &gt;-&gt; iterate
(printedoc noop noop)let = gen testdoc &gt;-&gt; docpos &gt;-&gt;
iterate (printedoc printint printint)let = gen testdoc &gt;-&gt; docpos
&gt;-&gt; grends 20 &gt;-&gt; iterate (printedoc printint printpos)let =
gen testdoc &gt;-&gt; docpos &gt;-&gt; grends 30 &gt;-&gt; iterate
(printedoc printint printpos)let = gen testdoc &gt;-&gt; docpos
&gt;-&gt; grends 60 &gt;-&gt; iterate (printedoc printint printpos)let =
prettyprint 20 testdoclet = prettyprint 30 testdoclet = prettyprint 60
testdoc</p></li>
</ul>
<p>Functional Programming</p>
<p>Streams and lazy evaluation</p>
<p><strong>Exercise 1:</strong> My first impulse was to define lazy list
functions as here:</p>
<p><em>let rec wrong_lzip = function | LNil, LNil -&gt; LNil | LCons
(a1, lazy l1), LCons (a2, lazy l2) -&gt; LCons ((a1, a2), lazy
(wrong_lzip (l1, l2))) | -&gt; raise (Invalidargument “lzip”)let rec
wrong_lmap f = function | LNil -&gt; LNil | LCons (a, lazy l) -&gt;
LCons (f a, lazy (wrong_lmap f l))</em></p>
<p><em>What is wrong with these definitions – for which edge cases they
do not work as intended?</em></p>
<p><strong>Exercise 2:</strong> Cyclic lazy lists:</p>
<ol type="1">
<li><p><em>Implement a function</em>
<code>*cycle : 'a list -&gt; 'a llist*</code> <em>that creates a lazy
list with elements from standard list, and the whole list as the tail
after the last element from the input list.</em></p>
<p>*<code>[a1; a2; …; aN]</code><span
class="math inline">\mapsto</span></p>
<table style="display: inline-table;
vertical-align: middle">
<tbody>
<tr>
<td>
</td>
<td style="text-align: center">
</td>
<td>
<p><tt
class="verbatim">…</tt></p>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
</tbody></li>
</ol>
</table>
<p>-1.407730.189096-0.9632226484984790.210262600873131-0.2012170.1890960.2644529699695730.2102626008731310.751290.1890961.068792168276230.1890957798650621.788460.1890962.190633681703930.2102626008731312.19063368170393-0.191906998280196-2.0-0.2-2.0003968778939-0.001405609207567140cm*</p>
<p><em>Your function <code>cycle</code> can either return
<code>LNil</code> or fail for an empty list as argument.</em> 1.
<em>Note that</em> <code>*inv_fact*</code> <em>from the lecture defines
the power series for the</em> <span class="math inline">\exp
(\cdot)</span> <em>function (</em><span class="math inline">\exp (x) =
e^x</span><em>). Using</em> <code>*cycle*</code> <em>and</em>
<code>*inv_fact*</code><em>, define the power series for</em> <span
class="math inline">\sin (\cdot)</span> <em>and</em> <span
class="math inline">\cos
   (\cdot)</span><em>, and draw their graphs using helper functions from
the lecture script</em> <code>*Lec7.ml*</code>.</p>
<p><strong>Exercise 3:</strong> * Modify one of the puzzle solving
programs (either from the previous lecture or from your previous
homework) to work with lazy lists. Implement the necessary higher-order
lazy list functions. Check that indeed displaying only the first
solution when there are multiple solutions in the result takes shorter
than computing solutions by the original program.</p>
<p><strong>Exercise 4:</strong> <em>Hamming’s problem</em>. Generate in
increasing order the numbers of the form <span
class="math inline">2^{a_{1}} 3^{a_{2}} 5^{a_{3}} \ldots
p_{k}^{a_{k}}</span>, that is numbers not divisible by prime numbers
greater than the <span class="math inline">k</span>th prime number.</p>
<ul>
<li><em>In the original Hamming’s problem posed by Dijkstra,</em> <span
class="math inline">k = 3</span>*, which is related</li>
</ul>
<p>to* <em><a
href="http://en.wikipedia.org/wiki/Regular_number">http://en.wikipedia.org/wiki/Regular_number</a></em>.</p>
<p><em>Starter code is available in the middle of the lecture script
<code>Lec7.ml</code>:let rec lfilter f = function | LNil -&gt; LNil |
LCons (n, ll) -&gt; if f n then LCons (n, lazy (lfilter f (Lazy.force
ll))) else lfilter f (Lazy.force ll)let primes = let rec sieve =
function LCons(p,nf) -&gt; LCons(p, lazy (sieve (sift p (Lazy.force
nf)))) | LNil -&gt; failwith “Impossible! Internal error.” and sift p =
lfilter (function n -&gt; n mod p &lt;&gt; 0)in sieve (lfrom 2)let times
ll n = lmap (fun i -&gt; i </em> n) ll;;let rec merge xs ys = match xs,
ys with | LCons (x, lazy xr), LCons (y, lazy yr) -&gt; if x &lt; y then
LCons (x, lazy (merge xr ys)) else if x &gt; y then LCons (y, lazy
(merge xs yr)) else LCons (x, lazy (merge xr yr)) | r, LNil | LNil, r
-&gt; rlet hamming k = let pr = ltake k primes in let rec h = LCons (1,
lazy ( <TODO> )) in h*</p>
<p><strong>Exercise 5:</strong> Modify <code>format</code> and/or
<code>breaks</code> to use just a single number instead of a stack of
booleans to keep track of what groups should be inlined.</p>
<p><strong>Exercise 6:</strong> Add <strong>indentation</strong> to the
pretty-printer for groups: if a group does not fit in a single line, its
consecutive lines are indented by a given amount <code>tab</code> of
spaces deeper than its parent group lines would be. For comparison,
let’s do several implementations.</p>
<ol type="1">
<li><em>Modify the straightforward implementation of</em>
<code>*pretty*</code>.</li>
<li><em>Modify the first pipe-based implementation of</em>
<code>*pretty*</code> <em>by modifying the</em> <code>*format*</code>
<em>function.</em></li>
<li><em>Modify the second pipe-based implementation of</em>
<code>*pretty*</code> <em>by modifying the</em> <code>*breaks*</code>
<em>function. Recover the positions of elements – the number of
characters from the beginning of the document – by keeping track of the
growing offset.</em></li>
<li>** Modify a pipe-based implementation to provide a different style
of indentation: indent the first line of a group, when the group starts
on a new line, at the same level as the consecutive lines (rather than
at the parent level of indentation).*</li>
</ol>
<p><strong>Exercise 7:</strong> Write a pipe that takes document
elements annotated with linear position, and produces document elements
annotated with (line, column) coordinates.</p>
<p><em>Write another pipe that takes so annotated elements and adds a
line number indicator in front of each line. Do not update the column
coordinate. Test the pipes by plugging them before the <code>emit</code>
pipe.</em></p>
<pre><code>1: first line
2: second line, etc.</code></pre>
<p><strong>Exercise 8:</strong> Write a pipe that consumes document
elements <code>doc_e</code> and yields the toplevel subdocuments
<code>doc</code> which would generate the corresponding elements.</p>
<p><em>You can modify the definition of documents to allow annotations,
so that the element annotations are preserved (<code>gen</code> should
ignore annotations to keep things simple):type ’a doc = Text of ’a </em>
string | Line of ’a | Cat of doc * doc | Group of ’a * doc*</p>
<p><strong>Exercise 9:</strong> * Design and implement a way to
duplicate arrows outgoing from a pipe-box, that would memoize the
stream, i.e. not recompute everything “upstream” for the composition of
pipes. Such duplicated arrows would behave nicely with pipes reading
from files.</p>
*
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
Does not recompute <tt
class="verbatim">g</tt> nor <tt
class="verbatim">f</tt>.
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
Reads once and passes all content to <tt
class="verbatim">f</tt> and <tt
class="verbatim">g</tt>.
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>-5.769180.217059-4.245171318957530.217059134806191-3.800670.238226-2.44599153327160.746229660007938-3.821830.259393-2.4459915332716-0.2909445693874851.088870.2170593.988722053181640.7250628389998681.046530.1958923.96755523217357-0.3332782114036250cm*</p>
<p>Lecture 8: Monads</p>
<p>List comprehensions. Basic monads; transformers. Probabilistic
Programming.Lightweight cooperative threads.</p>
<p>Some examples from Tomasz Wierzbicki. Jeff Newbern <em>‘‘All About
Monads’‘<em>.M. Erwig, S. Kollmansberger </em>‘‘Probabilistic Functional
Programming in Haskell’‘<em>.Jerome Vouillon </em>‘‘Lwt: a Cooperative
Thread Library’’</em>.</p>
<p>If you see any error on the slides, let me know!</p>
<h1 id="list-comprehensions">1 List comprehensions</h1>
<ul>
<li><p>Recall the awkward syntax we used in the Countdown Problem
example:</p>
<ul>
<li><p>Brute-force generation:</p>
<p>let combine l r = List.map (fun o-&gt;App (o,l,r)) [Add; Sub; Mul;
Div]let rec exprs = function | [] -&gt; [] | [n] -&gt; [Val n] | ns
-&gt; split ns |-&gt; (fun (ls,rs) -&gt; exprs ls |-&gt; (fun l -&gt;
exprs rs |-&gt; (fun r -&gt; combine l r)))</p></li>
<li><p>Genarate-and-test scheme:</p>
<p>let guard p e = if p e then [e] else []let solutions ns n = choices
ns |-&gt; (fun ns’ -&gt; exprs ns’ |-&gt; guard (fun e -&gt; eval e =
Some n))</p></li>
</ul></li>
<li><p>Recall that we introduced the operator</p>
<p>let ( |-&gt; ) x f = concatmap f x</p></li>
<li><p>We can do better with <em>list comprehensions</em> syntax
extension.</p>
<p>#load “dynlink.cma”;;#load “camlp4o.cma”;;#load
“Camlp4Parsers/Camlp4ListComprehension.cmo”;;</p>
<p>let test = [i * 2 | i &lt;- fromto 2 22; i mod 3 = 0]</p></li>
<li><p>What it means:</p>
<ul>
<li><p>[expr | ] can be translated as [expr]</p></li>
<li><p>[expr | v &lt;- generator; <em>more</em>] can be translated
as</p>
<p><code>generator</code> |-&gt; (fun v -&gt; translation of [expr |
<em>more</em>])</p></li>
<li><p>[expr | <code>condition</code>; <em>more</em>] can be translated
as</p>
<p>if condition then translation of [<code>expr</code> | <em>more</em>]
else []</p></li>
</ul></li>
<li><p>Revisiting the Countdown Problem code snippets:</p>
<ul>
<li><p>Brute-force generation:</p>
<p>let rec exprs = function | [] -&gt; [] | [n] -&gt; [Val n] | ns -&gt;
[App (o,l,r) | (ls,rs) &lt;- split ns; l &lt;- exprs ls; r &lt;- exprs
rs; o &lt;- [Add; Sub; Mul; Div]]</p></li>
<li><p>Genarate-and-test scheme:</p>
<p>let solutions ns n = [e | ns’ &lt;- choices ns; e &lt;- exprs ns’;
eval e = Some n]</p></li>
</ul></li>
<li><p>Subsequences using list comprehensions (with garbage):</p>
<p>let rec subseqs l = match l with | [] -&gt; [[]] | x::xs -&gt; [ys |
px &lt;- subseqs xs; ys &lt;- [px; x::px]]</p></li>
<li><p>Computing permutations using list comprehensions:</p>
<ul>
<li><p>via insertion</p>
<p>let rec insert x = function | [] -&gt; [[x]] | y::ys’ as ys
-&gt;<br />
(x::ys) :: [y::zs | zs &lt;- insert x ys’]let rec insperms = function |
[] -&gt; [[]] | x::xs -&gt; [zs | ys &lt;- insperms xs; zs &lt;- insert
ys]</p></li>
<li><p>via selection</p>
<p>let rec select = function | [x] -&gt; [x,[]] | x::xs -&gt; (x,xs) ::
[ y, x::ys | y,ys &lt;- select xs]let rec selperms = function | [] -&gt;
[[]] | xs -&gt; [x::ys | x,xs’ &lt;- select xs; ys &lt;- selperms
xs’]</p></li>
</ul></li>
</ul>
<h1 id="generalized-comprehensions-aka.-do-notation">2 Generalized
comprehensions aka. <em>do-notation</em></h1>
<ul>
<li><p>We need to install the syntax extension <code>pa_monad</code></p>
<ul>
<li>by copying the <code>pa_monad.cmo or pa_monad400.cmo</code> (for
OCaml 4.0) file from the course page,</li>
<li>or if it does not work, by compiling from sources at <a
href="http://www.cas.mcmaster.ca/~carette/pa_monad/">http://www.cas.mcmaster.ca/~carette/pa_monad/</a>and
installing under a Unix-like shell (Windows: the Cygwin shell).
<ul>
<li>Under Debian/Ubuntu, you may need to install
<code>camlp4-extras</code></li>
</ul></li>
</ul></li>
<li><p>let rec exprs = function | [] -&gt; [] | [n] -&gt; [Val n] | ns
-&gt;<br />
perform with (|-&gt;) in (ls,rs) &lt;– split ns; l &lt;– exprs ls; r
&lt;– exprs rs; o &lt;– [Add; Sub; Mul; Div];<br />
[App (o,l,r)]</p></li>
<li><p>The perform syntax does not seem to support guards…</p>
<p>let solutions ns n = perform with (|-&gt;) in ns’ &lt;– choices
ns;<br />
e &lt;– exprs ns’; eval e = Some n; e</p>
<pre><code>  eval e = Some n;      Error: This expression has type bool but an </code></pre>
<p>expression was expected of type ’a list</p></li>
<li><p>So it wants a list… What can we do?</p></li>
<li><p>We can decide whether to return anything</p>
<p>let solutions ns n = perform with (|-&gt;) in ns’ &lt;– choices
ns;<br />
e &lt;– exprs ns’; if eval e = Some n then [e] else []</p></li>
<li><p>But what if we want to check earlier…</p>
<p>General “guard check” function</p>
<p>let guard p = if p then [()] else []</p></li>
<li><p>let solutions ns n = perform with (|-&gt;) in ns’ &lt;– choices
ns;<br />
e &lt;– exprs ns’; guard (eval e = Some n); [e]</p></li>
</ul>
<h1 id="monads">3 Monads</h1>
<ul>
<li><p>A polymorphic type <code>'a monad</code> (or
<code>'a Monad.t</code>, etc.) that supports at least two
operations:</p>
<ul>
<li><code>bind : 'a monad -&gt; ('a -&gt; 'b monad) -&gt; 'b monad</code></li>
<li><code>return : 'a -&gt; 'a monad</code></li>
<li><blockquote>
<blockquote>
<p>= is infix syntax for <code>bind</code>: let (&gt;&gt;=) a b = bind a
b</p>
</blockquote>
</blockquote></li>
</ul></li>
<li><p>With <code>bind</code> in scope, we do not need the with clause
in perform</p>
<p>let bind a b = concatmap b alet return x = [x] let solutions ns n
=<br />
perform ns’ &lt;– choices ns; e &lt;– exprs ns’; guard (eval e = Some
n); return e</p></li>
<li><p>Why <code>guard</code> looks this way?</p>
<p>let fail = []let guard p = if p then return () else fail</p>
<ul>
<li>Steps in monadic computation are composed with &gt;&gt;=,
e.g. |-&gt;
<ul>
<li>as if ; was replaced by &gt;&gt;=</li>
</ul></li>
<li>[] |-&gt; … does not produce anything – as needed by guarding</li>
<li>[()] |-&gt; … <span class="math inline">\rightsquigarrow</span> (fun
_ -&gt; …) () <span class="math inline">\rightsquigarrow</span> …
i.e. keep without change</li>
</ul></li>
<li><p>Throwing away the binding argument is a common practice, with
infix syntax &gt;&gt; in Haskell, and supported in <em>do-notation</em>
and perform.</p></li>
<li><p>Everything is a monad?</p></li>
<li><p>Different flavors of monads?</p></li>
<li><p>Can <code>guard</code> be defined for any monad?</p></li>
<li><p>perform syntax in depth:</p>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
</td>
<td>
</td>
<td>
<p><tt class="verbatim">exp</tt></p>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
<p>[]</p>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
<p>but uses <tt class="verbatim">b</tt> instead of
<tt class="verbatim">bind</tt></p>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
<p>and <tt class="verbatim">f</tt> instead of
<tt class="verbatim">failwith</tt></p>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
<p>during translation</p>
</td>
</tr>
</tbody>
</table></li>
<li><p>It can be useful to redefine: let failwith = fail
(<em>why?</em>)</p></li>
</ul>
<h2 id="monad-laws">3.1 Monad laws</h2>
<ul>
<li><p>A parametric data type is a monad only if its <code>bind</code>
and <code>return</code> operations meet axioms:</p>
<p><span class="math display"> \begin{matrix}
\operatorname{bind} (\operatorname{return}a) f &amp; \approx &amp; f
a\\\\\\
\operatorname{bind}a (\lambda x.\operatorname{return}x) &amp; \approx
&amp; a \\\\\\
\operatorname{bind} (\operatorname{bind}a (\lambda x.b))  (\lambda y.c)
&amp;
\approx &amp; \operatorname{bind}a (\lambda x.\operatorname{bind}b
(\lambda
y.c)) \end{matrix} </span></p></li>
<li><p>Check that the laws hold for our example monad</p>
<p>let bind a b = concatmap b alet return x = [x]</p></li>
</ul>
<h2 id="monoid-laws-and-monad-plus">3.2 Monoid laws and
<em>monad-plus</em></h2>
<ul>
<li><p>A monoid is a type with, at least, two operations</p>
<ul>
<li><code>mzero : 'a monoid</code></li>
<li><code>mplus : 'a monoid -&gt; 'a monoid -&gt; 'a monoid</code></li>
</ul>
<p>that meet the laws:</p>
<p><span class="math display"> \begin{matrix}
\operatorname{mplus}\operatorname{mzero}a &amp; \approx &amp; a \\\\\\
\operatorname{mplus}a\operatorname{mzero} &amp; \approx &amp; a \\\\\\
\operatorname{mplus}a (\operatorname{mplus}b c) &amp; \approx &amp;
\operatorname{mplus} (\operatorname{mplus}a b) c \end{matrix}
</span></p></li>
<li><p>We will define <code>fail</code> as synonym for
<code>mzero</code> and infix ++ for <code>mplus</code>.</p></li>
<li><p>Fusing monads and monoids gives the most popular general flavor
of monads which we call <em>monad-plus</em> after Haskell.</p></li>
<li><p>Monad-plus requires additional axioms that relate its “addition”
and its “multiplication”.</p>
<p><span class="math display"> \begin{matrix}
\operatorname{bind}\operatorname{mzero}f &amp; \approx &amp;
\operatorname{mzero}\\\\\\
\operatorname{bind}m (\lambda x.\operatorname{mzero}) &amp; \approx
&amp;
\operatorname{mzero} \end{matrix} </span></p></li>
<li><p>Using infix notation with <span class="math inline">\oplus</span>
as <code>mplus</code>, <span class="math inline">\boldsymbol{0}</span>
as <code>mzero</code>, <span
class="math inline">\vartriangleright</span> as <code>bind</code> and
<span class="math inline">\boldsymbol{1}</span> as <code>return</code>,
we get monad-plus axioms</p>
<p><span class="math display"> \begin{matrix}
\boldsymbol{0} \oplus a &amp; \approx &amp; a \\\\\\
a \oplus \boldsymbol{0} &amp; \approx &amp; a \\\\\\
a \oplus (b \oplus c) &amp; \approx &amp; (a \oplus b) \oplus c\\\\\\
\boldsymbol{1}x \vartriangleright f &amp; \approx &amp; f x\\\\\\
a \vartriangleright \lambda x.\boldsymbol{1}x &amp; \approx &amp; a
\\\\\\
(a \vartriangleright \lambda x.b) \vartriangleright \lambda y.c &amp;
\approx &amp;
a \vartriangleright (\lambda x.b \vartriangleright \lambda y.c)\\\\\\
\boldsymbol{0} \vartriangleright f &amp; \approx &amp;
\boldsymbol{0}\\\\\\
a \vartriangleright (\lambda x.\boldsymbol{0}) &amp; \approx &amp;
\boldsymbol{0} \end{matrix} </span></p></li>
<li><p>The list type has a natural monad and monoid structure</p>
<p>let mzero = [] let mplus = (@) let bind a b = concatmap b a let
return a = [a]</p></li>
<li><p>We can define in any monad-plus</p>
<p>let fail = mzero let failwith = fail let (++) = mplus let (&gt;&gt;=)
a b = bind a b let guard p = if p then return () else fail</p></li>
</ul>
<h2 id="backtracking-computation-with-choice">3.3 Backtracking:
computation with choice</h2>
<p>We have seen <code>mzero</code>, i.e. <code>fail</code> in the
countdown problem. What about <code>mplus</code>?</p>
<p>let findtoeat n islandsize numislands emptycells = let honey =
honeycells n emptycells in let rec findboard s = (* Printf.printf
“findboard: %sn” (statestr s); <em>) match visitcell s with | None -&gt;
perform<br />
guard (s.beenislands = numislands); return s.eaten | Some (cell, s)
-&gt; perform s &lt;– findisland cell (freshisland s);<br />
guard (s.beensize = islandsize); findboard s and findisland current s =
let s = keepcell current s in neighbors n emptycells current<br />
|&gt; foldM (fun neighbor s -&gt; if CellSet.mem neighbor s.visited then
return s else let chooseeat =<br />
if s.moretoeat &lt;= 0 then fail else return (eatcell neighbor s) and
choosekeep = if s.beensize &gt;= islandsize then fail else findisland
neighbor s in mplus chooseeat choosekeep) s in let cellstoeat =
List.length honey - islandsize </em> numislands in findboard (initstate
honey cellstoeat)</p>
<h1 id="monad-flavors">4 Monad “flavors”</h1>
<ul>
<li>Monads “wrap around” a type, but some monads need an additional type
parameter.
<ul>
<li>Usually the additional type does not change while within a monad –
we will therefore stick to <code>'a monad</code> rather than
parameterize with an additional type <code>('s, 'a) monad</code>.</li>
</ul></li>
<li>As monad-plus shows, things get interesting when we add more
operations to a basic monad (with <code>bind</code> and
<code>return</code>).
<ul>
<li><p>Monads with access:</p>
<p>access : ’a monad -&gt; ’a</p>
<p>Example: the lazy monad.</p></li>
<li><p>Monad-plus, non-deterministic computation:</p>
<p><code>mzero : 'a monad``mplus : 'a monad -&gt; 'a monad -&gt; 'a monad</code></p></li>
<li><p>Monads with environment or state – parameterized by type
<code>store</code>:</p>
<p>get : store monadput : store -&gt; unit monad</p>
<p>There is a “canonical” state monad. Similar monads: the writer monad
(with <code>get</code> called <code>listen</code> and <code>put</code>
called <code>tell</code>); the reader monad, without <code>put</code>,
but with <code>get</code> (called <code>ask</code>) and
<code>local</code>:</p>
<p>local : (store -&gt; store) -&gt; ’a monad -&gt; ’a monad</p></li>
<li><p>The exception / error monads – parameterized by type
<code>excn</code>:</p>
<p>throw : excn -&gt; ’a monadcatch : ’a monad -&gt; (excn -&gt; ’a
monad) -&gt; ’a monad</p></li>
<li><p>The continuation monad:</p>
<p>callCC : ((’a -&gt; ’b monad) -&gt; ’a monad) -&gt; ’a monad</p>
<p>We will not cover it.</p></li>
<li><p>Probabilistic computation:</p>
<p>choose : float -&gt; ’a monad -&gt; ’a monad -&gt; ’a monad</p>
<p>satisfying the laws with <span class="math inline">a \oplus _{p}
b</span> for <code>choose p a b</code> and <span
class="math inline">pq</span> for <code>p*.q</code>, <span
class="math inline">0 \leqslant p, q \leqslant 1</span>:</p>
<p><span class="math display"> \begin{matrix}
   a \oplus _{0} b &amp; \approx &amp; b \\\\\\
   a \oplus _{p} b &amp; \approx &amp; b \oplus _{1 - p} a\\\\\\
   a \oplus _{p} (b \oplus _{q} c) &amp; \approx &amp; \left( a \oplus
   _{\frac{p}{p + q - pq}} b \right) \oplus _{p + q - pq} c\\\\\\
   a \oplus _{p} a &amp; \approx &amp; a \end{matrix} </span></p></li>
<li><p>Parallel computation as monad with access and parallel bind:</p>
<p>parallel :’a monad-&gt; ’b monad-&gt; (’a -&gt; ’b -&gt; ’c monad)
-&gt; ’c monad</p>
<p>Example: lightweight threads.</p></li>
</ul></li>
</ul>
<h1 id="interlude-the-module-system">5 Interlude: the module system</h1>
<ul>
<li><p>I provide below much more information about the module system
than we need, just for completeness. You can use it as reference.</p>
<ul>
<li>Module system details will <strong>not</strong> be on the exam –
only the structure / signature definitions as discussed in lecture
5.</li>
</ul></li>
<li><p>Modules collect related type definitions and operations
together.</p></li>
<li><p>Module “values” are introduced with struct … end –
structures.</p></li>
<li><p>Module types are introduced with sig … end – signatures.</p>
<ul>
<li>A structure is a package of definitions, a signature is an interface
for packages.</li>
</ul></li>
<li><p>A source file <code>source.ml</code> or <code>Source.ml</code>
defines a module Source.</p>
<p>A source file <code>source.mli</code> or <code>Source.mli</code>
defines its type.</p></li>
<li><p>We can create the initial interface by entering the module in the
interactive toplevel or by command
<code>ocamlc -i source.ml</code></p></li>
<li><p>In the “toplevel” – accurately, module level – modules are
defined with module ModuleName = … or module ModuleName : MODULE_TYPE =
… syntax, and module types with module type MODULETYPE = … syntax.</p>
<ul>
<li>Corresponds to let <code>v_name</code> = … resp. let
<code>v_name</code> : v_type = … syntax for values and type vtype = …
syntax for types.</li>
</ul></li>
<li><p>Locally in expressions, modules are defined with let module M = …
in … syntax.</p>
<ul>
<li>Corresponds to let <code>v_name</code> = … in … syntax for
values.</li>
</ul></li>
<li><p>The content of a module is made visible in the remainder of
another module by open Module</p>
<ul>
<li>Module Pervasives is initially visible, as if each file started with
open Pervasives.</li>
</ul></li>
<li><p>The content of a module is made visible locally in an expression
with let open Module in … syntax.</p></li>
<li><p>Content of a module is included into another module – i.e. made
part of it – by include Module.</p>
<ul>
<li>Just having open Module inside Parent does not affect how Parent
looks from outside.</li>
</ul></li>
<li><p>Module functions – functions from modules to modules – are called
<em>functors</em> (not the Haskell ones!). The type of the parameter has
to be given.</p>
<p>module Funct = functor (Arg : sig … end) -&gt; struct … end</p>
<p>module Funct (Arg : sig … end) = struct … end</p>
<ul>
<li>Functors can return functors, i.e. modules can be parameterized by
multiple modules.</li>
<li>Modules are either structures or functors.</li>
<li>Different kind of thing than Haskell functors.</li>
</ul></li>
<li><p>Functor application always uses parentheses: Funct (struct …
end)</p></li>
<li><p>We can use named module type instead of signature and named
module instead of structure above.</p></li>
<li><p>Argument structures can contain more definitions than
required.</p></li>
<li><p>A signature MODULETYPE with type t_name = … is like MODULETYPE
but with <code>t_name</code> made more specific.</p></li>
<li><p>We can also include signatures into other signatures, by include
MODULETYPE.</p>
<ul>
<li>include MODULETYPE with type tname := … will substitute type
<code>t_name</code> with provided type.</li>
</ul></li>
<li><p>Modules, just as expressions, are <strong>not</strong> recursive
or mutually recursive by default. Syntax for recursive modules:module
rec ModuleName : MODULETYPE = … and …</p></li>
<li><p>We can recover the type – i.e. signature – of a module bymodule
type of Module</p></li>
<li><p>Finally, we can pass around modules in normal functions.</p>
<ul>
<li>(module Module) is an expression</li>
<li>(val modulev) is a module</li>
<li><div class="sourceCode" id="cb57"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">module</span> <span class="kw">type</span> T = <span class="kw">sig</span> <span class="kw">val</span> g : <span class="dt">int</span> -&gt; <span class="dt">int</span> endlet f modv x =  <span class="kw">let</span> <span class="kw">module</span> </span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>M = (<span class="kw">val</span> modv : T) <span class="kw">in</span>  M.g x;;</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : (<span class="kw">module</span> T) -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> test = f (<span class="kw">module</span> <span class="kw">struct</span> <span class="kw">let</span> g i = i*i <span class="kw">end</span> : T);;</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> test : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div></li>
</ul></li>
</ul>
<h1 id="the-two-metaphors">6 The two metaphors</h1>
<ul>
<li>Monads can be seen as <strong>containers</strong>:
<code>'a monad</code> contains stuff of type <code>'a</code></li>
<li>and as <strong>computation</strong>: <code>'a monad</code> is a
special way to compute <code>'a</code>.
<ul>
<li>A monad fixes the sequence of computing steps – unless it is a fancy
monad like parallel computation monad.</li>
</ul></li>
</ul>
<h2 id="monads-as-containers">6.1 Monads as containers</h2>
<ul>
<li>A monad is a <em>quarantine container</em>:
<ul>
<li><p>we can put something into the container with
<code>return</code></p></li>
<li><p>we can operate on it, but the result needs to stay in the
container</p>
<p>let lift f m = perform x &lt;– m; return (f x) val lift : (’a -&gt;
’b) -&gt; ’a monad -&gt; ’b monad</p></li>
<li><p>We can deactivate-unwrap the quarantine container but only when
it is in another container so the quarantine is not broken</p>
<p>let join m = perform x &lt;– m; x val join : (’a monad) monad -&gt;
’a monad</p></li>
</ul></li>
<li>The quarantine container for a <strong>monad-plus</strong> is more
like other containers: it can be empty, or contain multiple
elements.</li>
<li>Monads with access allow us to extract the resulting element from
the container, other monads provide a <code>run</code> operation that
exposes “what really happened behind the quarantine”.</li>
</ul>
<h2 id="monads-as-computation">6.2 Monads as computation</h2>
<ul>
<li><p>To compute the result, perform instructions, naming partial
results.</p></li>
<li><p>Physical metaphor: <strong>assembly line</strong></p>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td style="text-align: right">
</td>
<td>
</td>
<td style="text-align: center">
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>-5.762933.70556.069321338801433.72666688715439-5.72061.990996.217489085857921.990987564492666.069323.726678.926842174890862.7741599417912410.0486836883186-0.1045277153062576.217491.990996.386823653922481.736985712395826.76782643206773-0.08336089429818766.76783-0.0833609-5.29726154253208-0.1045277153062576.72549-1.84021-5.19142743749173-1.819040216959920.6717822.879992.3016271993652.879994046831597.720331.863998.12250297658420.7209783040084676.00582-0.9723674.69347797327689-0.9723673766371212.06879-0.9088670.735282444767826-0.908866913612912-5.762932.87999-4.619923270273852.87999404683159-4.42942-0.930034-5.53009657362085-0.930033734620982-9.763462.68949-8.324116946686072.26615623759757-7.308109538298720.9749801561053052.280462.371993.175100860066451.990988185174813.656303743881470.9749801561053053.88914-1.289873.31763460775235-2.263543458129383.29646778674428-2.83504762534727-4.26009-1.18404-4.64394551581309-1.82001279007382-4.72575737531419-2.72921352030692<code>w</code>-7.42741.25543<code>c</code>3.596731.32033<code>c'</code>3.5293-2.47521<code>c''</code>-4.93743-1.586216.280990.911486.76783-0.0833609-4.408260.91148-3.916971543196911.990989632039070.206112-2.89855-0.600035853371303-1.827196584929880cm</p>
<p>let assemblyLine w = perform c &lt;– makeChopsticks w c’ &lt;–
polishChopsticks c c’’ &lt;– wrapChopsticks c’ return c’’</p></li>
<li><p>Any expression can be spread over a monad, e.g. for <span
class="math inline">\lambda</span>-terms:</p>
<p><span class="math display"> \begin{matrix}
[\![ N ]\!] = &amp; \operatorname{return}N &amp; \text{(constant)}\\\\\\
[\![ x ]\!] = &amp; \operatorname{return}x &amp; \text{(variable)}\\\\\\
[\![ \lambda x.a ]\!] = &amp; \operatorname{return} (\lambda x.
[\![ a ]\!]) &amp; \text{(function)}\\\\\\
[\![ \operatorname{let}x = a\operatorname{in}b ]\!] = &amp;
\operatorname{bind} [\![ a ]\!]  (\lambda x. [\![ b
]\!]) &amp; \text{(local definition)}\\\\\\
[\![ a b ]\!] = &amp; \operatorname{bind} [\![ a ]\!]
(\lambda v_{a} .\operatorname{bind} [\![ b ]\!]  (\lambda
v_{b} .v_{a} v_{b})) &amp; \text{(application)} \end{matrix}
</span></p></li>
<li><p>When an expression is spread over a monad, its computation can be
monitored or affected without modifying the expression.</p></li>
</ul>
<h1 id="monad-classes">7 Monad classes</h1>
<ul>
<li><p>To implement a monad we need to provide the implementation type,
<code>return</code> and <code>bind</code> operations.</p>
<p>module type MONAD = sig type ’a t val return : ’a -&gt; ’a t val bind
: ’a t -&gt; (’a -&gt; ’b t) -&gt; ’b tend</p>
<ul>
<li><p>Alternatively we could start from <code>return</code>,
<code>lift</code> and <code>join</code> operations.</p>
<ul>
<li>For monads that change their additional type parameter we could
define: module type MONAD = sig type (’s, ’a) t val return : ’a -&gt;
(’s, ’a) t val bind : (’s, ’a) t -&gt; (’a -&gt; (’s, ’b) t) -&gt; (’s,
’b) tend</li>
</ul></li>
</ul></li>
<li><p>Based on just these two operations, we can define a whole suite
of general-purpose functions. We look at just a tiny selection.</p>
<p>module type MONADOPS = sig type ’a monad include MONAD with type ’a t
:= ’a monad val ( &gt;&gt;= ) :’a monad -&gt; (’a -&gt; ’b monad) -&gt;
’b monad val foldM : (’a -&gt; ’b -&gt; ’a monad) -&gt; ’a -&gt; ’b list
-&gt; ’a monad val whenM : bool -&gt; unit monad -&gt; unit monad<br />
val lift : (’a -&gt; ’b) -&gt; ’a monad -&gt; <code>'b monad</code> val
(&gt;&gt;|) : ’a monad -&gt; (’a -&gt; ’b) -&gt; ’b monadval join : ’a
monad monad -&gt; ’a monad val ( &gt;=&gt; ) : (’a -&gt;’b monad) -&gt;
(’b -&gt;’c monad) -&gt; ’a -&gt; ’c monadend</p></li>
<li><p>Given a particular implementation, we define these functions.</p>
<p>module MonadOps (M : MONAD) = struct open M type ‘a monad = ’a t let
run x = x let (&gt;&gt;=) a b = bind a b let rec foldM f a = function |
[] -&gt; return a | x::xs -&gt; f a x &gt;&gt;= fun a’ -&gt; foldM f a’
xs let whenM p s = if p then s else return () let lift f m = perform x
&lt;– m; return (f x) let (&gt;&gt;|) a b = lift b a let join m =
perform x &lt;– m; x let (&gt;=&gt;) f g = fun x -&gt; f x &gt;&gt;=
gend</p></li>
<li><p>We make the monad “safe” by keeping its type abstract. But
<code>run</code> exposes “what really happened”.</p>
<p>module Monad (M : MONAD) :sig include MONADOPS val run : ’a monad
-&gt; ’a M.tend = struct include M include MonadOps(M)end</p>
<ul>
<li>Our <code>run</code> function does not do anything at all. Often
more useful functions are called <code>run</code> but then they need to
be defined for each implementation separately. Our <code>access</code>
operation (see section on monad flavors) is often called
<code>run</code>.</li>
</ul></li>
<li><p>The monad-plus class of monads has a lot of implementations. They
need to provide <code>mzero</code> and <code>mplus</code>.</p>
<p>module type MONADPLUS = sig include MONAD val mzero : ’a t val mplus
: ’a t -&gt; ’a t -&gt; ’a tend</p></li>
<li><p>Monad-plus class also has its general-purpose functions:</p>
<p>module type MONADPLUSOPS = sig include MONADOPS val mzero : ’a monad
val mplus : ’a monad -&gt; ’a monad -&gt; ’a monad val fail : ’a monad
val (++) : ’a monad -&gt; ’a monad -&gt; ’a monad val guard : bool -&gt;
unit monad val msummap : (’a -&gt; ’b monad) -&gt; ’a list -&gt; ’b
monadend</p></li>
<li><p>We again separate the “implementation” and the “interface”.</p>
<p>module MonadPlusOps (M : MONADPLUS) = struct open M include
MonadOps(M)<br />
let fail = mzero let (++) a b = mplus a b let guard p = if p then return
() else fail let msummap f l = List.foldright (fun a acc -&gt; mplus
(f</p>
<ol type="a">
<li>acc) l mzeroend</li>
</ol>
<p>module MonadPlus (M : MONADPLUS) :sig include MONADPLUSOPS val run :
’a monad -&gt; ’a M.tend = struct include M include
MonadPlusOps(M)end</p></li>
<li><p>We also need a class for computations with state.</p>
<p>module type STATE = sig type store type ’a t val get : store t val
put : store -&gt; unit tend</p>
<p>The purpose of this signature is inclusion in other
signatures.</p></li>
</ul>
<h1 id="monad-instances">8 Monad instances</h1>
<ul>
<li><p>We do not define a class for monads with access since accessing
means running the monad, not useful while in the monad.</p></li>
<li><p>Notation for laziness heavy? Try a monad! (Monads with
access.)</p>
<p>module LazyM = Monad (struct type ’a t = ’a Lazy.t let bind a b =
lazy (Lazy.force (b (Lazy.force a))) let return a = lazy aend)</p>
<p>let laccess m = Lazy.force (LazyM.run m)</p></li>
<li><p>Our resident list monad. (Monad-plus.)</p>
<p>module ListM = MonadPlus (struct type ’a t = ’a list let bind a b =
concatmap b a let return a = [a] let mzero = [] let mplus =
List.appendend)</p></li>
</ul>
<h2 id="backtracking-parameterized-by-monad-plus">8.1 Backtracking
parameterized by monad-plus</h2>
<p>module Countdown (M : MONADPLUSOPS) = struct open MOpen the module to
make monad operations visible.</p>
<p>let rec insert x = functionAll choice-introducing operations | []
-&gt; return [x]need to happen in the monad. | y::ys as xs -&gt; return
(x::xs) ++ perform xys &lt;– insert x ys; return (y::xys)</p>
<p>let rec choices = function | [] -&gt; return [] | x::xs -&gt; perform
cxs &lt;– choices xs;Choosing which numbers in what order<br />
return cxs ++ <code>insert x cxs</code>and now whether with or without
<code>x</code>.</p>
<p>type op = Add | Sub | Mul | Div</p>
<p>let apply op x y = match op with | Add -&gt; x + y | Sub -&gt; x - y
| Mul -&gt; x * y | Div -&gt; x / y</p>
<p>let valid op x y = match op with | Add -&gt; x &lt;= y | Sub -&gt; x
&gt; y | Mul -&gt; x &lt;= y &amp;&amp; x &lt;&gt; 1 &amp;&amp; y
&lt;&gt; 1 | Div -&gt; x mod y = 0 &amp;&amp; y &lt;&gt; 1</p>
<p>type expr = Val of int | App of op * expr * expr</p>
<p>let op2str = function | Add -&gt; “+” | Sub -&gt; “-” | Mul -&gt; “*”
| Div -&gt; “/” let rec expr2str = functionWe will provide solutions as
strings. | Val n -&gt; stringofint n | App (op,l,r) -&gt;“(”expr2str
lop2str opexpr2str r”)”</p>
<p>let combine (l,x) (r,y) o = performTry out an operator. guard (valid
o x y); return (App (o,l,r), apply o x y)</p>
<p>let split l =Another choice: which numbers go into which argument.
let rec aux lhs = function | [] | [] -&gt; <code>fail</code>Both
arguments need numbers.| [y; z] -&gt; return (List.rev (y::lhs), [z]) |
hd::rhs -&gt;<br />
let lhs = hd::lhs in return (List.rev lhs, rhs) ++ aux lhs rhs in aux []
l</p>
<p>let rec results = functionBuild possible expressions once numbers |
[] -&gt; <code>fail</code>have been picked.| [n] -&gt; perform guard (n
&gt; 0); return (Val n, n) | ns -&gt; perform (ls, rs) &lt;– split ns;
lx &lt;– results ls; ly &lt;– results rs;Collect solutions using each
operator. msummap (combine lx ly) [Add; Sub; Mul; Div]</p>
<p>let solutions ns n = performSolve the problem: ns’ &lt;– choices
ns;pick numbers and their order, (e,m) &lt;– results ns’;build possible
expressions, guard (m=n);check if the expression gives target value,
return (expr2str e)‘‘print’’ the solution.end</p>
<h2 id="understanding-laziness">8.2 Understanding laziness</h2>
<ul>
<li><p>We will measure execution times:</p>
<p>#load “unix.cma”;;let time f = let tbeg = Unix.gettimeofday () in let
res = f () in let tend = Unix.gettimeofday () in tend -. tbeg,
res</p></li>
<li><p>Let’s check our generalized Countdown solver using original
operations.</p>
<p>module ListCountdown = Countdown (ListM)let test1 () = ListM.run
(ListCountdown.solutions [1;3;7;10;25;50] 765)let t1, sol1 = time
test1</p></li>
<li><p>val t1 : float = 2.2856600284576416val sol1 : string list =<br />
[“((25-(3+7))<em>(1+50))”; ”(((25-3)-7)</em>(1+50))”; …</p></li>
<li><p>What if we want only one solution? Laziness to the rescue!</p>
<p>type ’a llist = LNil | LCons of ’a * ’a llist Lazy.tlet rec ltake n =
function | LCons (a, lazy l) when n &gt; 0 -&gt; a::(ltake (n-1) l) |
-&gt; []let rec lappend l1 l2 = match l1 with LNil -&gt; l2 | LCons (hd,
tl) -&gt; LCons (hd, lazy (lappend (Lazy.force tl) l2))let rec
lconcatmap f = function | LNil -&gt; LNil | LCons (a, lazy l)
-&gt;<br />
lappend (f a) (lconcatmap f l)</p></li>
<li><p>That is, another monad-plus.</p>
<p>module LListM = MonadPlus (struct type ’a t = ’a llist let bind a b =
lconcatmap b a let return a = LCons (a, lazy LNil) let mzero = LNil let
mplus = lappendend)</p></li>
<li><p>module LListCountdown = Countdown (LListM)let test2 () =
LListM.run (LListCountdown.solutions [1;3;7;10;25;50] 765)</p></li>
<li><div class="sourceCode" id="cb58"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> t2a, sol2 = time test2;;<span class="kw">val</span> t2a : <span class="dt">float</span> = <span class="fl">2.51197600364685059</span>val </span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>sol2 : <span class="dt">string</span> llist = LCons (<span class="st">&quot;((25-(3+7))*(1+50))&quot;</span>, &lt;<span class="kw">lazy</span>&gt;)</span></code></pre></div>
<p>Not good, almost the same time to even get the lazy list!</p></li>
<li><div class="sourceCode" id="cb59"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> t2b, sol21 = time (<span class="kw">fun</span> () -&gt; ltake <span class="dv">1</span> sol2);;<span class="kw">val</span> t2b : <span class="dt">float</span> </span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>= <span class="fl">2.86102294921875e-06</span>val sol21 : <span class="dt">string</span> <span class="dt">list</span> = [<span class="st">&quot;((25-(3+7))*(1+50))&quot;</span>]# </span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> t2c, sol29 = time (<span class="kw">fun</span> () -&gt; ltake <span class="dv">10</span> sol2);;<span class="kw">val</span> t2c : <span class="dt">float</span> </span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>= <span class="fl">9.059906005859375e-06</span>val sol29 : <span class="dt">string</span> <span class="dt">list</span> =  [<span class="st">&quot;((25-(3+7))*(1+50))&quot;</span>; </span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;(((25-3)-7)*(1+50))&quot;</span>; …# <span class="kw">let</span> t2d, sol239 = time (<span class="kw">fun</span> () -&gt; ltake </span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a><span class="dv">49</span> sol2);;<span class="kw">val</span> t2d : <span class="dt">float</span> = <span class="fl">4.00543212890625e-05</span>val sol239 : <span class="dt">string</span> <span class="dt">list</span> =  </span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>[<span class="st">&quot;((25-(3+7))*(1+50))&quot;</span>; <span class="st">&quot;(((25-3)-7)*(1+50))&quot;</span>; …</span></code></pre></div>
<p>Getting elements from the list shows they are almost already
computed.</p></li>
<li><p>Wait! Perhaps we should not store all candidates when we are only
interested in one.</p>
<p>module OptionM = MonadPlus (struct type ’a t = ’a option let bind a b
=<br />
match a with None -&gt; None | Some x -&gt; b x let return a = Some
a<br />
let mzero = None let mplus a b = match a with None -&gt; b | Some -&gt;
aend)</p></li>
<li><p>module OptCountdown = Countdown (OptionM)let test3 () =
OptionM.run (OptCountdown.solutions [1;3;7;10;25;50] 765)</p></li>
<li><div class="sourceCode" id="cb60"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> t3, sol3 = time test3;;<span class="kw">val</span> t3 : <span class="dt">float</span> = <span class="fl">5.0067901611328125e-06</span>val </span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>sol3 : <span class="dt">string</span> <span class="dt">option</span> = <span class="dt">None</span></span></code></pre></div>
<p>It very quickly computes… nothing. Why?</p>
<ul>
<li>What is the OptionM monad (<code>Maybe</code> monad in Haskell) good
for?</li>
</ul></li>
<li><p>Our lazy list type is not lazy enough.</p>
<ul>
<li>Whenever we “make” a choice: <code>a</code> ++ <code>b</code> or
<code>msum_map</code> …, it computes the first candidate for each choice
path.</li>
<li>When we bind consecutive steps, it computes the second candidate of
the first step even when the first candidate would suffice.</li>
</ul></li>
<li><p>We want the whole monad to be lazy: it’s called <em>even lazy
lists</em>.</p>
<ul>
<li>Our <code>llist</code> are called <em>odd lazy lists</em>.</li>
</ul>
<p>type ’a lazylist = ’a lazylist Lazy.tand ’a lazylist = LazNil |
LazCons of ’a * ’a lazylistlet rec laztake n = function | lazy (LazCons
(a, l)) when n &gt; 0 -&gt; a::(laztake (n-1) l) | -&gt; []let rec
appendaux l1 l2 = match l1 with lazy LazNil -&gt; Lazy.force l2 | lazy
(LazCons (hd, tl)) -&gt; LazCons (hd, lazy (appendaux tl l2))let
lazappend l1 l2 = lazy (appendaux l1 l2)let rec concatmapaux f =
function | lazy LazNil -&gt; LazNil | lazy (LazCons (a, l)) -&gt;
appendaux (f a) (lazy (concatmapaux f l))let lazconcatmap f l = lazy
(concatmapaux f l)</p></li>
<li><p>module LazyListM = MonadPlus (struct type ’a t = ’a lazylist let
bind a b = lazconcatmap b a let return a = lazy (LazCons (a, lazy
LazNil)) let mzero = lazy LazNil let mplus = lazappendend)</p></li>
<li><p>module LazyCountdown = Countdown (LazyListM)let test4 () =
LazyListM.run (LazyCountdown.solutions [1;3;7;10;25;50] 765)</p></li>
<li><div class="sourceCode" id="cb61"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> t4a, sol4 = time test4;;<span class="kw">val</span> t4a : <span class="dt">float</span> = <span class="fl">2.86102294921875e-06</span>val </span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>sol4 : <span class="dt">string</span> lazylist = &lt;<span class="kw">lazy</span>&gt;# <span class="kw">let</span> t4b, sol41 = time (<span class="kw">fun</span> </span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>() -&gt; laztake <span class="dv">1</span> sol4);;<span class="kw">val</span> t4b : <span class="dt">float</span> = <span class="fl">0.367874860763549805</span>val sol41 : </span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a><span class="dt">string</span> <span class="dt">list</span> = [<span class="st">&quot;((25-(3+7))*(1+50))&quot;</span>]# <span class="kw">let</span> t4c, sol49 = time (<span class="kw">fun</span> () -&gt; </span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>laztake <span class="dv">10</span> sol4);;<span class="kw">val</span> t4c : <span class="dt">float</span> = <span class="fl">0.234670877456665039</span>val sol49 : <span class="dt">string</span> </span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a><span class="dt">list</span> =  [<span class="st">&quot;((25-(3+7))*(1+50))&quot;</span>; <span class="st">&quot;(((25-3)-7)*(1+50))&quot;</span>; …# <span class="kw">let</span> t4d, </span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>sol439 = time (<span class="kw">fun</span> () -&gt; laztake <span class="dv">49</span> sol4);;<span class="kw">val</span> t4d : <span class="dt">float</span> </span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>= <span class="fl">4.0594940185546875</span>val sol439 : <span class="dt">string</span> <span class="dt">list</span> =  [<span class="st">&quot;((25-(3+7))*(1+50))&quot;</span>; </span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;(((25-3)-7)*(1+50))&quot;</span>; …</span></code></pre></div>
<ul>
<li>Finally, the first solution in considerably less time than all
solutions.</li>
<li>The next 9 solutions are almost computed once the first one is.</li>
<li>But computing all solutions takes nearly twice as long as without
the overhead of lazy computation.</li>
</ul></li>
</ul>
<h2 id="the-exception-monad">8.3 The exception monad</h2>
<ul>
<li>Built-in non-functional exceptions in OCaml are more efficient (and
more flexible).</li>
<li>Instead of specifying a type of exceptional values, we could use
OCaml open type <code>exn</code>, restoring some flexibility.</li>
<li>Monadic exceptions are safer than standard exceptions in situations
like multi-threading. Monadic lightweight-thread library Lwt has
<code>throw</code> (called <code>fail</code> there) and
<code>catch</code> operations in its monad.</li>
</ul>
<p>module ExceptionM(Excn : sig type t end) : sig type excn = Excn.t
type ’a t = OK of ’a | Bad of excn include MONADOPS val run : ’a monad
-&gt; ’a t<br />
val throw : excn -&gt; ’a monad val catch : ’a monad -&gt; (excn -&gt;
’a monad) -&gt; ’a monadend = struct type excn = Excn.<code>t</code></p>
<p>module M = struct type ’a t = OK of ’a | Bad of excn let return a =
OK a let bind m b = match m with | OK a -&gt; b a | Bad e -&gt; Bad e
end include M include MonadOps(M) let throw e = Bad e let catch m
handler = match m with | OK -&gt; m | Bad e -&gt; handler eend</p>
<h2 id="the-state-monad">8.4 The state monad</h2>
<p>module StateM(Store : sig type t end) : sig type store =
Store.<code>t</code>Pass the current <code>store</code> value to get the
next value.type ‘a t = store -&gt; ’a * store include MONADOPS include
STATE with type ’a t := ’a monad<br />
and type store := store val run : ’a monad -&gt; ’a tend = struct type
store = Store.t module M = struct type ’a t = store -&gt; ’a *
store<br />
let return a = fun s -&gt; a, <code>s</code>Keep the current value
unchanged.let bind m b = fun s -&gt; let a, s’ = m s in b a s’ endTo
bind two steps, pass the value after first step to the second step.
include M include MonadOps(M) let get = fun s -&gt; s,
<code>s</code>Keep the value unchanged but put it in monad.let put s’ =
fun -&gt; (), s’Change the value; a throwaway in monad.end</p>
<ul>
<li><p>The state monad is useful to hide passing-around of a “current”
value.</p></li>
<li><p>We will rename variables in <span
class="math inline">\lambda</span>-terms to get rid of possible name
clashes.</p>
<ul>
<li>This does not make a <span class="math inline">\lambda</span>-term
safe for multiple steps of <span
class="math inline">\beta</span>-reduction. Find a counter-example.</li>
</ul></li>
<li><p>type term =| Var of string| Lam of string * term| App of term *
term</p></li>
<li><p>let (!) x = Var xlet (|-&gt;) x t = Lam (x, t)let (@) t1 t2 = App
(t1, t2)let test = “x” |-&gt; (“x” |-&gt; !“y” @ !“x”) @ !“x”</p></li>
<li><p>module S = StateM(struct type t = int * (string * string) list
end)open S</p>
<p>Without opening the module, we would write S<code>.get</code>,
S<code>.put</code> and perform with S in…</p></li>
<li><p>let rec alphaconv = function | Var x as v -&gt; performFunction
from terms to StateM monad. (_, env) &lt;– get;Seeing a variable does
not change state let v = try Var (List.assoc x env)but we need its new
name.<br />
with Notfound -&gt; v inFree variables don’t change name. return v | Lam
(x, t) -&gt; performWe rename each bound variable. (fresh, env) &lt;–
get;We need a fresh number. let x’ = x stringofint fresh in<br />
put (fresh+1, (x, x’)::env);Remember new name, update number. t’ &lt;–
alphaconv t; (fresh’, ) &lt;– get;We need to restore names, put (fresh’,
env);but keep the number fresh. return (Lam (x’, t’)) | App (t1, t2)
-&gt; perform t1 &lt;– alphaconv t1;Passing around of names<br />
t2 &lt;– alphaconv t2;and the currently fresh number return (App (t1,
t2))is done by the monad.</p></li>
<li><p>val test : term = Lam (“x”, App (Lam (“x”, App (Var “y”, Var
“x”)), Var “x”))# let = StateM.run (alphaconv test) (5, []);;- : term *
(int * (string * string) list) =(Lam (“x5”, App (Lam (“x6”, App (Var
“y”, Var “x6”)), Var “x5”)), (7, []))</p></li>
<li><p>If we separated the reader monad and the state monad, we would
avoid the lines: (fresh’, ) &lt;– get;Restoring the ‘‘reader’’ part
<code>env</code> put (fresh’, env);but preserving the ‘‘state’’ part
<code>fresh</code>.</p></li>
<li><p>The elegant way is to define the monad locally:</p>
<p>let alphaconv t = let module S = StateM (struct type t = int *
(string</p>
<ul>
<li>string) list end) in let open S in let rec aux = function | Var x as
v -&gt; perform (fresh, env) &lt;– get; let v = try Var (List.assoc x
env) with Notfound -&gt; v in return v | Lam (x, t) -&gt; perform
(fresh, env) &lt;– get; let x’ = x<br />
stringofint fresh in put (fresh+1, (x, x’)::env); t’ &lt;– aux t;
(fresh’, ) &lt;– get; put (fresh’, env); return (Lam (x’, t’)) | App
(t1, t2) -&gt; perform t1 &lt;– aux t1; t2 &lt;– aux t2; return (App
(t1, t2)) in run (aux t) (0, [])</li>
</ul></li>
</ul>
<h1 id="monad-transformers">9 Monad transformers</h1>
<ul>
<li><p>Based on: <a
href="http://lambda.jimpryor.net/monad_transformers/">http://lambda.jimpryor.net/monad_transformers/</a></p></li>
<li><p>Sometimes we need merits of multiple monads at the same time,
e.g. monads AM and BM.</p></li>
<li><p>Straightforwad idea is to nest one monad within another:</p>
<ul>
<li>either ’a AM.monad BM.monad</li>
<li>or ’a BM.monad AM.monad.</li>
</ul></li>
<li><p>But we want a monad that has operations of both AM and
BM.</p></li>
<li><p>It turns out that the straightforward approach does not lead to
operations with the meaning we want.</p></li>
<li><p>A <em>monad transformer</em> AT takes a monad BM and turns it
into a monad AT(BM) which actually wraps around BM on both sides. AT(BM)
has operations of both monads.</p></li>
<li><p>We will develop a monad transformer StateT which adds state to a
monad-plus. The resulting monad has all: <code>return</code>,
<code>bind</code>, <code>mzero</code>, <code>mplus</code>,
<code>put</code>, <code>get</code> and their supporting general-purpose
functions.</p>
<ul>
<li>There is no reason for StateT not to provide state to any flavor of
monads. Our restriction to monad-plus is because the type/module system
makes more general solutions harder.</li>
</ul></li>
<li><p>We need monad transformers in OCaml because “monads are
contagious”: although we have built-in state and exceptions, we need to
use monadic state and exceptions when we are inside a monad.</p>
<ul>
<li>The reason <em>Lwt</em> is both a concurrency and an exception
monad.</li>
</ul></li>
<li><p>Things get <em>interesting</em> when we have several monad
transformers, e.g. AT, BT, … We can compose them in various orders:
AT(BT(CM)), BT(AT(CM)), … achieving different results.</p>
<ul>
<li>With a single trasformer, we will not get into issues with
multiple-layer monads…</li>
<li>They are worth exploring – especially if you plan a career around
programming in Haskell.</li>
</ul></li>
<li><p>The state monad, using (fun x -&gt; …) a instead of let x = a in
…</p>
<p>type ’a state = store -&gt; (’a * store)</p>
<p>let <code>return</code> (a : ’a) : ’a state = fun s -&gt; (a, s)</p>
<p>let bind (u : ‘a state) (f : ’a -&gt; ’b state) : ’b state = fun s
-&gt; (fun (a, s’) -&gt; f a s’) (u s)</p></li>
<li><p>Monad M transformed to add state, in pseudo-code:</p>
<p>type ’a stateT(M) = store -&gt; (’a * store) M(* notice this is not
an (’a M) state *)</p>
<p>let <code>return</code> (a : ’a) : ’a stateT(M) = fun s -&gt;
M.<code>return</code> (a, s)Rather than returning, M.return</p>
<p>let bind(u:‘a stateT(M))(f:’a-&gt;’b stateT(M)):’b stateT(M)= fun s
-&gt; M.bind (u s) (fun (a, s’) -&gt; f a s’)Rather than let-binding,
M.bind</p></li>
</ul>
<h2 id="state-transformer">9.1 State transformer</h2>
<p>module StateT (MP : MONADPLUSOPS) (Store : sig type t end) :
sigFunctor takes two modules – the second one type store =
Store.<code>t</code>provides only the storage type.type ‘a t = store
-&gt; (’a * store) MP.monad include MONADPLUSOPSExporting all the
monad-plus operations include STATE with type ’a t :=
<code>'a monad</code>and state operations.and type store := store val
run : ’a monad -&gt; <code>'a t</code>Expose ‘‘what happened’’ –
resulting states.val runT : ’a monad -&gt; store -&gt; ’a MP.monadend =
structRun the state transformer – get the resulting values. type store =
Store.<code>t</code></p>
<p>module M = struct type ‘a t = store -&gt; (’a * store) MP.monad let
return a = fun s -&gt; MP.return (a, s) let bind m b = fun s -&gt;<br />
MP.bind (m s) (fun (a, s’) -&gt; b a s’) let mzero = fun -&gt;
MP.<code>mzero</code><em>Lift</em> the monad-plus operations.let mplus
ma mb = fun s -&gt; MP.mplus (ma s) (mb s) end include M include
MonadPlusOps(M) let get = fun s -&gt; MP.return (s, s)Instead of just
returning, let put s’ = fun -&gt; MP.return ((), s’)MP.return. let runT
m s = MP.lift fst (m s)end</p>
<h2 id="backtracking-with-state">9.2 Backtracking with state</h2>
<p>module HoneyIslands (M : MONADPLUSOPS) = struct type state = {For use
with list monad or lazy list monad. beensize: int; beenislands:
int;<br />
unvisited: cell list; visited: CellSet.t; eaten: cell list;<br />
moretoeat: int; } let initstate unvisited moretoeat = { beensize =
0;<br />
beenislands = 0; unvisited; visited = CellSet.empty; eaten = [];<br />
moretoeat; }</p>
<p>module BacktrackingM = StateT (M) (struct type t = state end) open
BacktrackingM let rec visitcell () = performState update actions. s
&lt;– get; match s.unvisited with | [] -&gt; return None | c::remaining
when CellSet.mem c s.visited -&gt; perform put {s with
unvisited=remaining}; visitcell ()Throwaway argument because of
recursion. See (<em>) | c::remaining (</em> when c not visited *) -&gt;
perform put {s with unvisited=remaining; visited = CellSet.add c
s.visited}; return (Some c)This action returns a value.</p>
<p>let eatcell c = perform s &lt;– get; put {s with eaten = c::s.eaten;
visited = CellSet.add c s.visited; moretoeat = s.moretoeat - 1}; return
()Remaining state update actions just affect the state. let keepcell c =
perform s &lt;– get; put {s with<br />
visited = CellSet.add c s.visited; beensize = s.beensize + 1};<br />
return () let freshisland = perform s &lt;– get; put {s with beensize =
0; beenislands = s.beenislands + 1}; return ()</p>
<p>let findtoeat n islandsize numislands emptycells = let honey =
honeycells n emptycells inOCaml does not realize that
<code>'a monad</code> with state is actually a function – let rec
findboard () = performit’s an abstract type.(*)<br />
cell &lt;– visitcell (); match cell with | None -&gt; perform s &lt;–
get; guard (s.beenislands = numislands); return s.eaten | Some cell
-&gt; perform<br />
freshisland; findisland cell; s &lt;– get;<br />
guard (s.beensize = islandsize); findboard ()</p>
<pre><code>and findisland current = perform        keepcell current;        neighbors </code></pre>
<p>n emptycells current |&gt; <code>foldM</code>The partial answer sits
in the state – throwaway result.(fun () neighbor -&gt; perform s &lt;–
get; whenM (not (CellSet.mem neighbor s.visited))<br />
(let chooseeat = perform guard (s.moretoeat &gt; 0); eatcell
neighbor<br />
and choosekeep = perform guard (s.beensize &lt; islandsize); findisland
neighbor in<br />
chooseeat ++ choosekeep)) () in</p>
<pre><code>let cellstoeat =      List.length honey - islandsize * numislands in    </code></pre>
<p>initstate honey cellstoeat |&gt; runT (findboard ())endmodule HoneyL
= HoneyIslands (ListM)let findtoeat a b c d = ListM.run
(HoneyL.findtoeat a b c d)</p>
<h1 id="probabilistic-programming">10 Probabilistic Programming</h1>
<ul>
<li>Using a random number generator, we can define procedures that
produce various output. This is <strong>not functional</strong> –
mathematical functions have a deterministic result for fixed
arguments.</li>
<li>Similarly to how we can “simulate” (mutable) variables with state
monad and non-determinism (i.e. making choices) with list monad, we can
“simulate” random computation with probability monad.</li>
<li>The probability monad class means much more than having randomized
computation. We can ask questions about probabilities of results. Monad
instances can make tradeoffs of efficiency vs. accuracy (exact vs. 
approximate probabilities).</li>
<li>Probability monad imposes limitations on what approximation
algorithms can be implemented.
<ul>
<li>Efficient <em>probabilistic programming</em> library for OCaml,
based on continuations, memoisation and reified search trees:<a
href="http://okmij.org/ftp/kakuritu/index.html">http://okmij.org/ftp/kakuritu/index.html</a></li>
</ul></li>
</ul>
<h2 id="the-probability-monad">10.1 The probability monad</h2>
<ul>
<li><p>The essential functions for the probability monad class are
<code>choose</code> and <code>distrib</code> – remaining functions could
be defined in terms of these but are provided by each instance for
efficiency.</p></li>
<li><p>Inside-monad operations:</p>
<ul>
<li><p>choose : float -&gt; ’a monad -&gt; ’a monad -&gt; ’a monad</p>
<p><code>choose p a b</code> represents an event or distribution which
is <span class="math inline">a</span> with probability <span
class="math inline">p</span> and is <span class="math inline">b</span>
with probability <span class="math inline">1 - p</span>.</p></li>
<li><p>val pick : (’a * float) list -&gt; ’a t</p>
<p>A result from the provided distribution over values. The argument
must be a probability distribution: positive values summing to
1.</p></li>
<li><p>val uniform : ’a list -&gt; ’a monad</p>
<p>Uniform distribution over given values.</p></li>
<li><p>val flip : float -&gt; bool monad</p>
<p>Equal to
<code>choose 0.5 (return true) (return false)</code>.</p></li>
<li><p>val coin : bool monadEqual to <code>flip 0.5</code>.</p></li>
</ul></li>
<li><p>And some operations for getting out of the monad:</p>
<ul>
<li><p>val prob : (’a -&gt; bool) -&gt; ’a monad -&gt; float</p>
<p>Returns the probability that the predicate holds.</p></li>
<li><p>val distrib : ’a monad -&gt; (’a * float) list</p>
<p>Returns the distribution of probabilities over the resulting
values.</p></li>
<li><p>val access : ’a monad -&gt; ’a</p>
<p>Samples a <em>random</em> result from the distribution –
<strong>non-functional</strong> behavior.</p></li>
</ul></li>
<li><p>We give two instances of the probability monad: exact
distribution monad, and sampling monad, which can approximate
distributions.</p>
<ul>
<li>The sampling monad is entirely non-functional: in Haskell, it lives
in the IO monad.</li>
</ul></li>
<li><p>The monad instances indeed represent probability distributions:
collections of positive numbers that add up to 1 – although often
<code>merge</code> rather than <code>normalize</code> is used. If
<code>pick</code> and <code>choose</code> are used correctly.</p></li>
<li><p>module type PROBABILITY = sigProbability monad class. include
MONADOPS val choose : float -&gt; ’a monad -&gt; ’a monad -&gt; ’a monad
val pick : (’a * float) list -&gt; <code>'a monad</code> val uniform :
’a list -&gt; ’a monadval coin : bool monad val flip : float -&gt; bool
monad val prob : (’a -&gt; bool) -&gt; ’a monad -&gt; float val distrib
: ’a monad -&gt; (’a * float) list val access : ’a monad -&gt;
’aend</p></li>
<li><p>let total dist =Helper functions. List.foldleft (fun a
(,b)-&gt;a+.b) 0. distlet merge dist =Merge repeating elements.
mapreduce (fun x-&gt;x) (+.) 0. distlet normalize dist = Normalize a
measure into a distribution.<br />
let tot = total dist in if tot = 0. then dist else List.map (fun
(e,w)-&gt;e,w/.tot) distlet roulette dist =Roulette wheel from a
distribution/measure. let tot = total dist in let rec aux r = function
[] -&gt; assert false | (e,w):: when w &lt;= r -&gt; e | (,w)::tl -&gt;
aux (r-.w) tl in aux (Random.float tot) dist</p></li>
<li><p>module DistribM : PROBABILITY = struct module M = structExact
probability distribution – naive implementation. type ’a t = (’a *
float) list<br />
let bind a b = <code>merge``x</code> w.p. <span
class="math inline">p</span> and then <code>y</code> w.p. <span
class="math inline">q</span> happens =[y, q*.p | (x,p) &lt;- a; (y,q)
&lt;- b x]<code>y</code> results w.p. <span class="math inline">p
q</span>. let return a = [a, 1.]Certainly <code>a</code>. end include M
include MonadOps (M) let choose p a b = List.map (fun (e,w) -&gt; e,
p<em>.w) a @ List.map (fun (e,w) -&gt; e, (1. -.p)</em>.w) b let pick
dist = <code>dist</code> let uniform elems = normalize (List.map (fun
e-&gt;e,1.) elems)let coin = [true, 0.5; false, 0.5] let flip p = [true,
p; false, 1. -. p]</p>
<p>let prob p m = m |&gt; List.filter (fun (e,) -&gt; p e)All cases
where <code>p</code> holds, |&gt; List.map snd |&gt; List.foldleft (+.)
0.add up.<br />
let distrib m = m let access m = roulette mend</p></li>
<li><p>module SamplingM (S : sig val samples : int end) : PROBABILITY =
structParameterized by how many samples module M = structused to
approximate <code>prob</code> or <code>distrib</code>. type ’a t = unit
-&gt; <code>'a</code>Randomized computation – each call a()let bind a b
() = b (a ()) () is an independent sample. let return a = fun () -&gt;
<code>a</code>Always <code>a</code>.end include M include MonadOps (M)
let choose p a b () = if Random.float 1. &lt;= p then a () else b () let
pick dist = fun () -&gt; <code>roulette dist</code> let uniform elems =
let n = List.length elems in fun () -&gt; List.nth (Random.int n)
elemslet coin = Random.bool let flip p = choose p (return true) (return
false)</p>
<p>let prob p m = let count = ref 0 in for i = 1 to S.samples do<br />
if p (m ()) then incr count done; floatofint !count /. floatofint
S.<code>samples</code>let distrib m = let dist = ref [] in for i = 1 to
S.samples do dist := (m (), 1.) :: !dist done; normalize
(<code>merge</code> !dist) let access m = m ()end</p></li>
</ul>
<h2 id="example-the-monty-hall-problem">10.2 Example: The Monty Hall
problem</h2>
<ul>
<li><p><a
href="http://en.wikipedia.org/wiki/Monty_Hall_problem">http://en.wikipedia.org/wiki/Monty_Hall_problem</a>:
&gt; In search of a new car, the player picks a door, say 1. The game
host &gt; then opens one of the other doors, say 3, to reveal a goat and
offers to &gt; let the player pick door 2 instead of door 1. <embed
src="Monty_open_door.eps" /></p></li>
<li><p>module MontyHall (P : PROBABILITY) = struct open P type door = A
| B | C<br />
let doors = [A; B; C]</p>
<p>let montywin switch = perform prize &lt;– uniform doors;<br />
chosen &lt;– uniform doors; opened &lt;– uniform (listdiff doors [prize;
chosen]); let final = if switch then List.hd<br />
(listdiff doors [opened; chosen]) else chosen in return (final =
prize)end</p></li>
<li><p>module MontyExact = MontyHall (DistribM)module Sampling1000 =
SamplingM (struct let samples = 1000 end)module MontySimul = MontyHall
(Sampling1000)</p></li>
<li><div class="sourceCode" id="cb64"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> t1 = DistribM.distrib (MontyExact.montywin <span class="kw">false</span>);;<span class="kw">val</span> t1 : (<span class="dt">bool</span> * </span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span>) <span class="dt">list</span> =  [(<span class="kw">true</span>, <span class="fl">0.333333333333333315</span>); (<span class="kw">false</span>, <span class="fl">0.66666666666666663</span>)]# </span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> t2 = DistribM.distrib (MontyExact.montywin <span class="kw">true</span>);;<span class="kw">val</span> t2 : (<span class="dt">bool</span> * </span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span>) <span class="dt">list</span> =  [(<span class="kw">true</span>, <span class="fl">0.66666666666666663</span>); (<span class="kw">false</span>, <span class="fl">0.333333333333333315</span>)]# </span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> t3 = Sampling1000.distrib (MontySimul.montywin <span class="kw">false</span>);;<span class="kw">val</span> t3 : (<span class="dt">bool</span> * </span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span>) <span class="dt">list</span> = [(<span class="kw">true</span>, <span class="fl">0.313</span>); (<span class="kw">false</span>, <span class="fl">0.687</span>)]# <span class="kw">let</span> t4 = Sampling1000.distrib </span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>(MontySimul.montywin <span class="kw">true</span>);;<span class="kw">val</span> t4 : (<span class="dt">bool</span> * <span class="dt">float</span>) <span class="dt">list</span> = [(<span class="kw">true</span>, <span class="fl">0.655</span>); </span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>(<span class="kw">false</span>, <span class="fl">0.345</span>)]</span></code></pre></div>
<h2 id="conditional-probabilities">10.3 Conditional
probabilities</h2></li>
<li><p>Wouldn’t it be nice to have a monad-plus rather than a
monad?</p></li>
<li><p>We could use <code>guard</code> – conditional probabilities!</p>
<ul>
<li><span class="math inline">P (A|B)</span>
<ul>
<li>Compute what is needed for both <span class="math inline">A</span>
and <span class="math inline">B</span>.</li>
<li>Guard <span class="math inline">B</span>.</li>
<li>Return <span class="math inline">A</span>.</li>
</ul></li>
</ul></li>
<li><p>For the exact distribution monad it turns out very easy – we just
need to allow intermediate distributions to be unnormalized (sum to less
than 1).</p></li>
<li><p>For the sampling monad we use rejection sampling.</p>
<ul>
<li><code>mplus</code> has no straightforward correct
implementation.</li>
</ul></li>
<li><p>We implemented PROBABILITY separately for educational purposes
only, as COND_PROBAB introduced below supersedes it.</p></li>
<li><p>module type CONDPROBAB = sigClass for conditional probability
monad,<br />
include PROBABILITYwhere <code>guard cond</code> conditions on
<code>cond</code>. include MONADPLUSOPS with type ’a monad := ’a
monadend</p></li>
<li><p>module DistribMP : CONDPROBAB = struct module MP = structThe
measures no longer restricted to type ’a t = (’a * float)
<code>list</code>probability distributions: let bind a b = merge [y,
q*.p | (x,p) &lt;- a; (y,q) &lt;- b x] let return a = [a, 1.] let mzero
= []Measure equal 0 everywhere is OK. let mplus = List.append end
include MP include MonadPlusOps (MP) let choose p a b =It isn’t
<code>a</code> w.p. <span class="math inline">p</span> &amp;
<code>b</code> w.p. <span class="math inline">(1 -
p)</span> since <code>a</code> and <code>b</code> List.map (fun (e,w)
-&gt; e, p<em>.w) a <span class="citation" data-cites="are">@are</span>
not normalized!List.map (fun (e,w) -&gt; e, (1. -.p)</em>.w) b let pick
dist = <code>dist</code></p>
<p>let uniform elems = normalize (List.map (fun e-&gt;e,1.) elems) let
coin = [true, 0.5; false, 0.5] let flip p = [true, p; false, 1. -. p]
let prob p m = <code>normalize m</code>Final normalization step.|&gt;
List.filter (fun (e,) -&gt; p e) |&gt; List.map snd |&gt; List.foldleft
(+.) 0. let distrib m = normalize m let access m = roulette
mend</p></li>
<li><p>We write the rejection sampler in mostly imperative style:</p>
<p>module SamplingMP (S : sig val samples : int end) : CONDPROBAB =
struct<br />
exception RejectedFor rejecting current sample. module MP = structMonad
operations are exactly as for SamplingM type ’a t = unit -&gt; ’a let
bind a b () = b (a ()) () let return a = fun () -&gt; <code>a</code> let
mzero = fun () -&gt; raise Rejectedbut now we can <code>fail</code>. let
mplus a b = fun () -&gt; failwith “SamplingMP.mplus not implemented” end
include MP include MonadPlusOps (MP)</p>
<p>let choose p a b () =Inside-monad operations don’t change. if
Random.float 1. &lt;= p then a () else b () let pick dist = fun () -&gt;
<code>roulette dist</code>let uniform elems = let n = List.length elems
in fun () -&gt; List.nth elems (Random.int n) let coin = Random.bool let
flip p = choose p (return true) (return false)</p>
<p>let prob p m =Getting out of monad: handle rejected samples. let
count = ref 0 and tot = ref 0 in while !tot &lt; S.samples doCount up to
the required trynumber of samples. if p (m ()) then incr count;m() can
fail. <code>incr tot</code>But if we got here it hasn’t.with Rejected
-&gt; ()Rejected, keep sampling. done; floatofint !count /. floatofint
S.<code>samples</code></p>
<p>let distrib m = let dist = ref [] and tot = ref 0 in while !tot &lt;
S.samples do try dist := (m (), 1.) :: !dist; incr tot<br />
with Rejected -&gt; () done; normalize (merge !dist) let rec access m =
try m () with Rejected -&gt; access mend</p></li>
</ul>
<h2 id="burglary-example-encoding-a-bayes-net">10.4 Burglary example:
encoding a Bayes net</h2>
<ul>
<li><p>We’re faced with a problem with the following dependency
structure:</p>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
</td>
<td style="text-align: right">
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td style="text-align: right">
<p>Burglary</p>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
<p>Earthquake</p>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
<p>Alarm</p>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td style="text-align: right">
<p>John calls</p>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td style="text-align: left">
<p>Mary calls</p>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<p>-5.525383.15826-3.04886559068663.17942188120122-3.133532874718882.73491864003175-2.11753-0.376604-0.297178859637518-0.418937690170658-0.318345680645588-0.228436301098029-5.82172-4.9063-2.98536512766239-4.90630374388147-3.64153657891255-6.028145257309170.570661-4.863973.63984984786347-4.906303743881472.85667747056489-6.091645720333380.7399953.158263.682183489879613.094754597168943.512848921815052.50208360894298-3.346952.3791-1.790454363947570.2764614914471450.9764792.39298-0.6819827901385850.319857839429467-1.87545-1.04339-3.6026998120943-3.65669671517365-0.55984-1.063621.16004444583979-3.529329161908520cm</p>
<ul>
<li>Alarm can be due to either a burglary or an earthquake.</li>
<li>I’ve left on vacations.</li>
<li>I’ve asked neighbors John and Mary to call me if the alarm
rings.</li>
<li>Mary only calls when she is really sure about the alarm, but John
has better hearing.</li>
<li>Earthquakes are twice as probable as burglaries.</li>
<li>The alarm has about 30% chance of going off during earthquake.</li>
<li>I can check on the radio if there was an earthquake, but I might
miss the news.</li>
</ul></li>
<li><p>module Burglary (P : CONDPROBAB) = struct open P type
whathappened =<br />
Safe | Burgl | Earthq | Burglnearthq</p>
<p>let check <span class="math inline">\sim</span>johncalled <span
class="math inline">\sim</span>marycalled <span
class="math inline">\sim</span>radio = perform<br />
earthquake &lt;– flip 0.002; guard (radio = None || radio = Some
earthquake); burglary &lt;– flip 0.001; let alarmp = match burglary,
earthquake with | false, false -&gt; 0.001 | false, true -&gt; 0.29 |
true, false -&gt; 0.94 | true, true -&gt; 0.95 in alarm &lt;– flip
alarmp;</p>
<pre><code>let johnp = if alarm then 0.9 else 0.05 in    johncalls &lt;-- flip </code></pre>
<p>johnp; guard (johncalls = johncalled); let maryp = if alarm then 0.7
else 0.01 in marycalls &lt;– flip maryp; guard (marycalls = marycalled);
match burglary, earthquake with | false, false -&gt; return Safe | true,
false -&gt; return Burgl | false, true -&gt; return Earthq | true, true
-&gt; return Burglnearthqend</p></li>
<li><p>module BurglaryExact = Burglary (DistribMP)module Sampling2000 =
SamplingMP (struct let samples = 2000 end)module BurglarySimul =
Burglary (Sampling2000)</p></li>
</ul>
<div class="sourceCode" id="cb66"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> t1 = DistribMP.distrib  (BurglaryExact.check $\sim$johncalled:<span class="kw">true</span> </span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>$\sim$marycalled:<span class="kw">false</span>     $\sim$radio:<span class="dt">None</span>);;    <span class="kw">val</span> t1 : </span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>(BurglaryExact.whathappened * <span class="dt">float</span>) <span class="dt">list</span> =  </span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>[(BurglaryExact.Burglnearthq, <span class="fl">1.03476433660005444e-05</span>);   </span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>(BurglaryExact.Earthq, <span class="fl">0.00452829235738691407</span>);   </span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>(BurglaryExact.Burgl, <span class="fl">0.00511951049003530299</span>);   </span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>(BurglaryExact.Safe, <span class="fl">0.99034184950921178</span>)]# <span class="kw">let</span> t2 = DistribMP.distrib  </span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>(BurglaryExact.check $\sim$johncalled:<span class="kw">true</span> $\sim$marycalled:<span class="kw">true</span>     </span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a>$\sim$radio:<span class="dt">None</span>);;    <span class="kw">val</span> t2 : (BurglaryExact.whathappened * <span class="dt">float</span>) <span class="dt">list</span> =  </span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a>[(BurglaryExact.Burglnearthq, <span class="fl">0.00057437256500405794</span>);   </span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a>(BurglaryExact.Earthq, <span class="fl">0.175492465840075218</span>);   </span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a>(BurglaryExact.Burgl, <span class="fl">0.283597462799388911</span>);   </span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a>(BurglaryExact.Safe, <span class="fl">0.540335698795532</span>)]# <span class="kw">let</span> t3 = DistribMP.distrib  </span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a>(BurglaryExact.check $\sim$johncalled:<span class="kw">true</span> $\sim$marycalled:<span class="kw">true</span>     </span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a>$\sim$radio:(<span class="dt">Some</span> <span class="kw">true</span>));;    <span class="kw">val</span> t3 : (BurglaryExact.whathappened * <span class="dt">float</span>) </span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true" tabindex="-1"></a><span class="dt">list</span> =  [(BurglaryExact.Burglnearthq, <span class="fl">0.0032622416021499262</span>);   </span>
<span id="cb66-17"><a href="#cb66-17" aria-hidden="true" tabindex="-1"></a>(BurglaryExact.Earthq, <span class="fl">0.99673775839785006</span>)]</span>
<span id="cb66-18"><a href="#cb66-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-19"><a href="#cb66-19" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> t4 = Sampling2000.distrib  (BurglarySimul.check $\sim$johncalled:<span class="kw">true</span> </span>
<span id="cb66-20"><a href="#cb66-20" aria-hidden="true" tabindex="-1"></a>$\sim$marycalled:<span class="kw">false</span>     $\sim$radio:<span class="dt">None</span>);;    <span class="kw">val</span> t4 : </span>
<span id="cb66-21"><a href="#cb66-21" aria-hidden="true" tabindex="-1"></a>(BurglarySimul.whathappened * <span class="dt">float</span>) <span class="dt">list</span> =  [(BurglarySimul.Earthq, <span class="fl">0.0035</span>); </span>
<span id="cb66-22"><a href="#cb66-22" aria-hidden="true" tabindex="-1"></a>(BurglarySimul.Burgl, <span class="fl">0.0035</span>);   (BurglarySimul.Safe, <span class="fl">0.993</span>)]# <span class="kw">let</span> t5 = </span>
<span id="cb66-23"><a href="#cb66-23" aria-hidden="true" tabindex="-1"></a>Sampling2000.distrib  (BurglarySimul.check $\sim$johncalled:<span class="kw">true</span> </span>
<span id="cb66-24"><a href="#cb66-24" aria-hidden="true" tabindex="-1"></a>$\sim$marycalled:<span class="kw">true</span>     $\sim$radio:<span class="dt">None</span>);;    <span class="kw">val</span> t5 : </span>
<span id="cb66-25"><a href="#cb66-25" aria-hidden="true" tabindex="-1"></a>(BurglarySimul.whathappened * <span class="dt">float</span>) <span class="dt">list</span> =  </span>
<span id="cb66-26"><a href="#cb66-26" aria-hidden="true" tabindex="-1"></a>[(BurglarySimul.Burglnearthq, <span class="fl">0.0005</span>); (BurglarySimul.Earthq, <span class="fl">0.1715</span>);   </span>
<span id="cb66-27"><a href="#cb66-27" aria-hidden="true" tabindex="-1"></a>(BurglarySimul.Burgl, <span class="fl">0.2875</span>); (BurglarySimul.Safe, <span class="fl">0.5405</span>)]# <span class="kw">let</span> t6 = </span>
<span id="cb66-28"><a href="#cb66-28" aria-hidden="true" tabindex="-1"></a>Sampling2000.distrib  (BurglarySimul.check $\sim$johncalled:<span class="kw">true</span> </span>
<span id="cb66-29"><a href="#cb66-29" aria-hidden="true" tabindex="-1"></a>$\sim$marycalled:<span class="kw">true</span>     $\sim$radio:(<span class="dt">Some</span> <span class="kw">true</span>));;    <span class="kw">val</span> t6 : </span>
<span id="cb66-30"><a href="#cb66-30" aria-hidden="true" tabindex="-1"></a>(BurglarySimul.whathappened * <span class="dt">float</span>) <span class="dt">list</span> =  </span>
<span id="cb66-31"><a href="#cb66-31" aria-hidden="true" tabindex="-1"></a>[(BurglarySimul.Burglnearthq, <span class="fl">0.0015</span>); (BurglarySimul.Earthq, <span class="fl">0.9985</span>)]</span></code></pre></div>
<h1 id="lightweight-cooperative-threads">11 Lightweight cooperative
threads</h1>
<ul>
<li><p><code>bind</code> is inherently sequential: bind a (fun x -&gt;
b) computes <code>a</code>, and resumes computing <code>b</code> only
once the result <code>x</code> is known.</p></li>
<li><p>For concurrency we need to “suppress” this sequentiality. We
introduce</p>
<p>parallel :’a monad-&gt; ’b monad-&gt; (’a -&gt; ’b -&gt; ’c monad)
-&gt; ’c monad</p>
<p>where parallel a b (fun x y -&gt; c) does not wait for <code>a</code>
to be computed before it can start computing <code>b</code>.</p></li>
<li><p>It can be that only accessing the value in the monad triggers the
computation of the value, as we’ve seen in some monads.</p>
<ul>
<li>The state monad does not start computing until you “get out of the
monad” and pass the initial value.</li>
<li>The list monad computes right away – the <code>'a monad</code> value
is the computed results.</li>
</ul>
<p>In former case, a “built-in” <code>parallel</code> is necessary for
concurrency.</p></li>
<li><p>If the monad starts computing right away, as in the <em>Lwt</em>
library,
<code>parallel  \concat{e}{\rsub{a}} \concat{e}{\rsub{b}} c</code> is
equivalent to</p>
<p>perform let a = <span class="math inline">e_{a}</span> in let b =
<span class="math inline">e_{b}</span> in x &lt;– a; y &lt;– b; c x
y</p>
<ul>
<li>We will follow this model, with an imperative implementation.</li>
<li>In any case, do not call <code>run</code> or <code>access</code>
from within a monad.</li>
</ul></li>
<li><p>We still need to decide on when concurrency happens.</p>
<ul>
<li>Under <strong>fine-grained</strong> concurrency, every
<code>bind</code> is suspended and computation moves to other threads.
<ul>
<li>It comes back to complete the <code>bind</code> before running
threads created since the <code>bind</code> was suspended.</li>
<li>We implement this model in our example.</li>
</ul></li>
<li>Under <strong>coarse-grained</strong> concurrency, computation is
only suspended when requested.
<ul>
<li>Operation <code>suspend</code> is often called <code>yield</code>
but the meaning is more similar to <code>Await</code> than
<code>Yield</code> from lecture 7.</li>
<li>Library operations that need to wait for an event or completion of
IO (file operations, etc.) should call <code>suspend</code> or its
equivalent internally.</li>
<li>We leave coarse-grained concurrency as exercise 11.</li>
</ul></li>
</ul></li>
<li><p>The basic operations of a multithreading monad class.</p>
<p>module type THREADS = sig include MONAD val parallel : ’a t -&gt; ’b
t -&gt; (’a -&gt; ’b -&gt; ’c t) -&gt; ’c tend</p></li>
<li><p>Although in our implementation <code>parallel</code> will be
redundant, it is a principled way to make sure subthreads of a thread
are run concurrently.</p></li>
<li><p>All within-monad operations.</p>
<p>module type THREADOPS = sig include MONADOPS include THREADS with
type ’a t := ’a monad val parallelmap : ’a list -&gt; (’a -&gt; ’b
monad) -&gt; ’b list monad val (&gt;||=) : ’a monad -&gt; ’b monad -&gt;
(’a -&gt; ’b -&gt; ’c monad) -&gt; ’c monad val (&gt;||) : ’a monad
-&gt; ’b monad -&gt; (unit -&gt; ’c monad) -&gt; ’c monadend</p></li>
<li><p>Outside-monad operations.</p>
<p>module type THREADSYS = sig include THREADS val access : ’a t -&gt;
’a<br />
val killthreads : unit -&gt; unitend</p></li>
<li><p>Helper functions.</p>
<p>module ThreadOps (M : THREADS) = struct open M include MonadOps (M)
let parallelmap l f = List.foldright (fun a bs -&gt; parallel (f a)
bs<br />
(fun a bs -&gt; return (a::bs))) l (return []) let (&gt;||=) = parallel
let (&gt;||) a b c = parallel a b (fun -&gt; c ())end</p></li>
<li><p>Put an interface around an implementation.</p>
<p>module Threads (M : THREADSYS) :sig include THREADOPS val access : ’a
monad -&gt; ’a val killthreads : unit -&gt; unitend = struct include
M<br />
include ThreadOps(M)end</p></li>
<li><p>Our implementation, following the <em>Lwt</em> paper.</p></li>
</ul>
<p>module Cooperative = Threads(struct type ‘a state = | Return of
<code>'a</code>The thread has returned.| Sleep of (’a -&gt; unit)
<code>list</code>When thread returns, wake up waiters.| Link of
<code>'a t</code>A link to the actual thread.and ’a t = {mutable state :
’a state}State of the thread can change– it can return, or more waiters
can be added.let rec find t = match t.state withUnion-find style link
chasing. | Link t -&gt; find t | -&gt; t let jobs = Queue.create ()Work
queue – will storeunit -&gt; unit procedures. let wakeup m a =Thread
<code>m</code> has actually finished – let m = find m inupdating its
state. match m.state with | Return -&gt; assert false | Sleep waiters
-&gt; m.state &lt;- Return a;Set the state, and only then<br />
List.iter ((|&gt;) a) <code>waiters</code>wake up the waiters. | Link
-&gt; assert false let return a = {state = Return a}let connect t t’
=<code>t</code> was a placeholder for <code>t'</code>. let t’ = find t’
in match t’.state with | Sleep waiters’ -&gt; let t = find t in (match
t.state with | Sleep waiters -&gt;If both sleep, collect their waiters
t.state &lt;- Sleep (waiters’ @ waiters); t’.state &lt;- Link
<code>t</code>and link one to the other.| -&gt; assert false) | Return x
-&gt; <code>wakeup t x</code>If <code>t'</code> returned, wake up the
placeholder.| Link -&gt; assert falselet rec bind a b = let a = find a
in let m = {state = Sleep []} inThe resulting monad.<br />
(match a.state with | Return x -&gt;If <code>a</code> returned, we
suspend further work. let job () = connect m (b x) in(In exercise 11,
this should<br />
Queue.<code>push job jobs</code>only happen after
<code>suspend</code>.)| Sleep waiters -&gt;If <code>a</code> sleeps, we
wait for it to return. let job x = connect m (b x) in<br />
a.state &lt;- Sleep (job::waiters) | Link -&gt; assert false); m<br />
let parallel a b c = performSince in our implementation x &lt;– a;the
threads run as soon as they are created, y &lt;– b;<code>parallel</code>
is redundant. <code>c x y</code>let rec access m =Accessing not only
gets the result of <code>m</code>, let m = find m inbut spins the thread
loop till <code>m</code> terminates. match m.state with | Return x -&gt;
<code>x</code>No further work.| Sleep -&gt; (try Queue.pop jobs
()Perform suspended work. with Queue.Empty -&gt;<br />
failwith “access: result not available”); access m | Link -&gt; assert
false let killthreads () = Queue.clear jobsRemove pending work.end)</p>
<ul>
<li><pre><code>module TTest (T : THREADOPS) = struct
  open T
  let rec loop s n = perform
    return (Printf.printf &quot;-- %s(%d)\n%!&quot; s n);
    (* We cannot use `whenM` because the thread would be
       created regardless of condition. *)
    if n &gt; 0 then loop s (n-1)
    else return ()
end
module TT = TTest (Cooperative)</code></pre></li>
<li>let test = Cooperative.killthreads ();Clean-up after previous tests.
let thread1 = TT.loop “A” 5 in let thread2 = TT.loop “B” 4 in<br />
Cooperative.access thread1;We ensure threads finish computing<br />
Cooperative.access thread2before we proceed.</li>
</ul>
<div class="sourceCode" id="cb68"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> test =    Cooperative.killthreads ();    <span class="kw">let</span> thread1 = TT.loop <span class="st">&quot;A&quot;</span> <span class="dv">5</span> <span class="kw">in</span>    <span class="kw">let</span> thread2 = TT.loop <span class="st">&quot;B&quot;</span> <span class="dv">4</span> <span class="kw">in</span>    Cooperative.access thread1;    Cooperative.access thread2;;-- A(<span class="dv">5</span>)-- B(<span class="dv">4</span>)-- A(<span class="dv">4</span>)-- B(<span class="dv">3</span>)-- A(<span class="dv">3</span>)-- B(<span class="dv">2</span>)-- A(<span class="dv">2</span>)-- B(<span class="dv">1</span>)-- A(<span class="dv">1</span>)-- B(<span class="dv">0</span>)-- A(<span class="dv">0</span>)<span class="kw">val</span> test : <span class="dt">unit</span> = ()</span></code></pre></div>
<p>Exercise 1.</p>
<p>Puzzle via Oleg Kiselyov.</p>
<p>“U2” has a concert that starts in 17 minutes and they must all cross
a bridge to get there. All four men begin on the same side of the
bridge. It is night. There is one flashlight. A maximum of two people
can cross at one time. Any party who crosses, either 1 or 2 people, must
have the flashlight with them. The flashlight must be walked back and
forth, it cannot be thrown, etc.. Each band member walks at a different
speed. A pair must walk together at the rate of the slower man’s
pace:</p>
<ul>
<li>Bono: 1 minute to cross</li>
<li>Edge: 2 minutes to cross</li>
<li>Adam: 5 minutes to cross</li>
<li>Larry: 10 minutes to cross</li>
</ul>
<p>For example: if Bono and Larry walk across first, 10 minutes have
elapsed when they get to the other side of the bridge. If Larry then
returns with the flashlight, a total of 20 minutes have passed and you
have failed the mission.</p>
<p>Find all answers to the puzzle using a list comprehension. The
comprehension will be a bit long but recursion is not needed.</p>
<p>Exercise 2.</p>
<p>Assume <code>concat_map</code> as defined in lecture 6. What will the
following expresions return? Why?</p>
<ol type="1">
<li>perform with (|-&gt;) in return 5; return 7</li>
<li>let guard p = if p then [()] else [];;perform with (|-&gt;) in guard
false; return 7;;</li>
<li>perform with (|-&gt;) in return 5; guard false; return 7;;</li>
</ol>
<p>Exercise 3.</p>
<p>Define <code>bind</code> in terms of <code>lift</code> and
<code>join</code>.</p>
<p>Exercise 4.</p>
<p><span id="TreeM"></span>Define a monad-plus implementation based on
binary trees, with constant-time <code>mzero</code> and
<code>mplus</code>. Starter code:type ’a tree = Empty | Leaf of ’a | T
of ’a t * ’a tmodule TreeM = MonadPlus (struct type ’a t = ’a tree let
bind a b = TODO let return a = TODO let mzero = TODO let mplus a b =
TODOend)</p>
<p>Exercise 5.</p>
<p>Show the monad-plus laws for one of:</p>
<ol type="1">
<li><code>TreeM</code> from your solution of exercise <a
href="#TreeM"></a>;</li>
<li><code>ListM</code> from lecture.</li>
</ol>
<p>Exercise 6.</p>
<p>Why the following monad-plus is not lazy enough?</p>
<ul>
<li>let rec badappend l1 l2 = match l1 with lazy LazNil -&gt; l2 | lazy
(LazCons (hd, tl)) -&gt; lazy (LazCons (hd, badappend tl l2))let rec
badconcatmap f = function | lazy LazNil -&gt; lazy LazNil | lazy
(LazCons (a, l)) -&gt; badappend (f a) (badconcatmap f l)</li>
<li>module BadyListM = MonadPlus (struct type ’a t = ’a lazylist let
bind a b = badconcatmap b a let return a = lazy (LazCons (a, lazy
LazNil)) let mzero = lazy LazNil let mplus = badappendend)</li>
<li>module BadyCountdown = Countdown (BadyListM)let test5 () =
BadyListM.run (BadyCountdown.solutions [1;3;7;10;25;50] 765)</li>
<li><p>let t5a, sol5 = time test5;;val t5a : float =
3.3954310417175293val sol5 :</p>
string lazylist = <lazy># let t5b, sol51 = time (fun () -&gt; laztake 1
sol5);;val t5b : float = 3.0994415283203125e-06val sol51 : string list =
[“((25-(3+7))*(1+50))”]# let t5c, sol59 = time (fun () -&gt; laztake 10
sol5);;val t5c : float = 7.8678131103515625e-06val sol59 : string list =
[“((25-(3+7))*(1+50))”; “(((25-3)-7)*(1+50))”; …# let t5d, sol539 = time
(fun () -&gt; laztake 49 sol5);;val t5d : float =
2.59876251220703125e-05val sol539 : string list =<br />
[“((25-(3+7))*(1+50))”; “(((25-3)-7)*(1+50))”; …</li>
</ul>
<p>Exercise 7.</p>
<p>Convert a “rectangular” list of lists of strings, representing a
matrix with inner lists being rows, into a string, where elements are
column-aligned. (Exercise not related to recent material.)</p>
<p>Exercise 8.</p>
<p>Recall the overly rich way to introduce monads – providing the
freedom of additional parametermodule type MONAD = sig type (’s, ’a) t
val return : ’a -&gt; (’s, ’a) t val bind : (’s, ’a) t -&gt; (’a -&gt;
(’s, ’b) t) -&gt; (’s, ’b) tend</p>
<p>Recall the operations for the exception monad:val throw : excn -&gt;
’a monadval catch : ’a monad -&gt; (excn -&gt; ’a monad) -&gt; ’a
monad</p>
<ol type="1">
<li>Design the signatures for the exception monad operations to use the
enriched monads with (’s, ’a) monad type, so that they provide more
flexibility than our exception monad.</li>
<li>Does the implementation of the exception monad need to change? The
same implementation can work with both sets of signatures, but the
implementation given in lecture needs a very slight change. Can you find
it without implementing? If not, the lecture script provides RMONAD,
RMONAD_OPS, RMonadOps and RMonad, so you can implement and see for
yourself – copy ExceptionM and modify:module ExceptionRM : sig type (’e,
’a) t = KEEP/TODO include RMONADOPS val run : (’e, ’a) monad -&gt; (’e,
’a) t val throw : TODO val catch : TODOend = struct module M =
struct<br />
type (’e, ’a) t = KEEP/TODO let return a = OK a let bind m b = KEEP/TODO
end include M include RMonadOps(M) let throw e = KEEP/TODO<br />
let catch m handler = KEEP/TODOend</li>
</ol>
<p>Exercise 9.</p>
<p>Implement the following constructs for <em>all</em> monads:</p>
<ol type="1">
<li>for…to…</li>
<li>for…downto…</li>
<li>while…do…</li>
<li>do…while…</li>
<li>repeat…until…</li>
</ol>
<p>Explain how, when your implementation is instantiated with the StateM
monad, we get the solution to exercise 2 from lecture 4.</p>
<p>Exercise 10.</p>
<p>A canonical example of a probabilistic model is that of a lawn whose
grass may be wet because it rained, because the sprinkler was on, or for
some other reason. Oleg Kiselyov builds on this example with variables
<code>rain</code>, <code>sprinkler</code>, and <code>wet_grass</code>,
by adding variables <code>cloudy</code> and <code>wet_roof</code>. The
probability tables are:</p>
<p><span class="math display">\begin{eqnarray*}
  P (\operatorname{cloudy}) &amp; = &amp; 0.5 \\\\\\
  P (\operatorname{rain}|\operatorname{cloudy}) &amp; = &amp; 0.8 \\\\\\
  P (\operatorname{rain}|\operatorname{not}\operatorname{cloudy}) &amp;
= &amp; 0.2
  \\\\\\
  P (\operatorname{sprinkler}|\operatorname{cloudy}) &amp; = &amp; 0.1
\\\\\\
  P (\operatorname{sprinkler}|\operatorname{not}\operatorname{cloudy})
&amp; = &amp;
  0.5 \\\\\\
  P (\operatorname{wet\_roof}|\operatorname{not}\operatorname{rain})
  &amp; = &amp; 0 \\\\\\
  P (\operatorname{wet}\operatorname{roof}|\operatorname{rain}) &amp; =
&amp; 0.7
  \\\\\\
  P (\operatorname{wet}\operatorname{grass}|\operatorname{rain} \wedge
  \operatorname{not}\operatorname{sprinkler}) &amp; = &amp; 0.9 \\\\\\
  P (\operatorname{wet}\operatorname{grass}|\operatorname{sprinkler}
\wedge
  \operatorname{not}\operatorname{rain}) &amp; = &amp; 0.9
\end{eqnarray*}</span></p>
<p>We observe whether the grass is wet and whether the roof is wet. What
is the probability that it rained?</p>
<p>Exercise 11.</p>
<p>Implement the coarse-grained concurrency model.</p>
<ul>
<li>Modify <code>bind</code> to compute the resulting monad straight
away if the input monad has returned.</li>
<li>Introduce <code>suspend</code> to do what in the fine-grained model
was the effect of <code>bind (return a) b</code>, i.e. suspend the work
although it could already be started.</li>
<li>One possibility is to introduce <code>suspend</code> of type unit
monad, introduce a “dummy” monadic value <code>Suspend</code> (besides
<code>Return</code> and <code>Sleep</code>), and define
<code>bind suspend b</code> to do what <code>bind (return ()) b</code>
would formerly do.</li>
</ul>
<p>Lecture 9: Compiler</p>
<p>Compilation. Runtime. Optimization. Parsing.</p>
<p>Andrew W. Appel <em>‘‘Modern Compiler Implementation in ML’‘<em>E.
Chailloux, P. Manoury, B. Pagano </em>‘‘Developing Applications with
OCaml’‘<em>Jon D. Harrop </em>‘‘OCaml for Scientists’’</em>Francois
Pottier, Yann Regis-Gianas ‘‘<em>Menhir Reference Manual</em>’’</p>
<p>If you see any error on the slides, let me know!</p>
<h1 id="ocaml-compilers">1 OCaml Compilers</h1>
<ul>
<li><p>OCaml has two primary compilers: the bytecode compiler
<code>ocamlc</code> and the native code compiler
<code>ocamlopt</code>.</p>
<ul>
<li>Natively compiled code runs about 10 times faster than bytecode –
depending on program.</li>
</ul></li>
<li><p>OCaml has an interactive shell called <em>toplevel</em> (in other
languages, <em>repl</em>): <code>ocaml</code> which is based on the
bytecode compiler.</p>
<ul>
<li>There is a toplevel <code>ocamlnat</code> based on the native code
compiler but currently not part of the binary distribution.</li>
</ul></li>
<li><p>There are “third-party” compilers, most notably
<code>js_of_ocaml</code> which translates OCaml bytecode into JavaScript
source.</p>
<ul>
<li>On modern JS virtual machines like V8 the result can be 2-3x faster
than on OCaml virtual machine (but can also be slower).</li>
</ul></li>
<li><p>Stages of compilation:</p>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table></li>
<li><p>Programs:</p>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
<p><tt 
class="verbatim">ocaml</tt></p>
</td>
<td>
<p>toplevel loop</p>
</td>
</tr>
<tr>
<td>
<p><tt 
class="verbatim">ocamlrun</tt></p>
</td>
<td>
<p>bytecode interpreter (VM)</p>
</td>
</tr>
<tr>
<td>
<p><tt 
class="verbatim">camlp4</tt></p>
</td>
<td>
<p>preprocessor (syntax extensions)</p>
</td>
</tr>
<tr>
<td>
<p><tt 
class="verbatim">ocamlc</tt></p>
</td>
<td>
<p>bytecode compiler</p>
</td>
</tr>
<tr>
<td>
<p><tt 
class="verbatim">ocamlopt</tt></p>
</td>
<td>
<p>native code compiler</p>
</td>
</tr>
<tr>
<td>
<p><tt 
class="verbatim">ocamlmktop</tt></p>
</td>
<td>
<p>new toplevel constructor</p>
</td>
</tr>
<tr>
<td>
<p><tt 
class="verbatim">ocamldep</tt></p>
</td>
<td>
<p>dependencies between modules</p>
</td>
</tr>
<tr>
<td>
<p><tt 
class="verbatim">ocamlbuild</tt></p>
</td>
<td>
<p>building projects tool</p>
</td>
</tr>
<tr>
<td>
<p><tt 
class="verbatim">ocamlbrowser</tt></p>
</td>
<td>
<p>graphical browsing of sources</p>
</td>
</tr>
</tbody>
</table></li>
<li><p>File extensions:</p>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
<p><tt class="verbatim">.ml</tt></p>
</td>
<td>
<p>OCaml source file</p>
</td>
</tr>
<tr>
<td>
<p><tt 
class="verbatim">.mli</tt></p>
</td>
<td>
<p>OCaml interface source file</p>
</td>
</tr>
<tr>
<td>
<p><tt 
class="verbatim">.cmi</tt></p>
</td>
<td>
<p>compiled interface</p>
</td>
</tr>
<tr>
<td>
<p><tt 
class="verbatim">.cmo</tt></p>
</td>
<td>
<p>bytecode-compiled file</p>
</td>
</tr>
<tr>
<td>
<p><tt 
class="verbatim">.cmx</tt></p>
</td>
<td>
<p>native-code-compiled file</p>
</td>
</tr>
<tr>
<td>
<p><tt 
class="verbatim">.cma</tt></p>
</td>
<td>
<p>bytecode-compiled library (several source files)</p>
</td>
</tr>
<tr>
<td>
<p><tt 
class="verbatim">.cmxa</tt></p>
</td>
<td>
<p>native-code-compiled library</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">.cmt</tt>/<tt 
class="verbatim">.cmti</tt>/<tt 
class="verbatim">.annot</tt></p>
</td>
<td>
<p>type information for editors</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">.c</tt></p>
</td>
<td>
<p>C source file</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">.o</tt></p>
</td>
<td>
<p>C native-code-compiled file</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">.a</tt></p>
</td>
<td>
<p>C native-code-compiled library</p>
</td>
</tr>
</tbody>
</table></li>
<li><p>Both compilers commands:</p>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
<p><tt class="verbatim">-a</tt></p>
</td>
<td>
<p>construct a runtime library</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">-c</tt></p>
</td>
<td>
<p>compile without linking</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">-o</tt></p>
</td>
<td>
<p>name_of_executable specify the name of the executable</p>
</td>
</tr>
<tr>
<td>
<p><tt 
class="verbatim">-linkall</tt></p>
</td>
<td>
<p>link with all libraries used</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">-i</tt></p>
</td>
<td>
<p>display all compiled global declarations</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">-pp</tt></p>
</td>
<td>
<p>command uses command as preprocessor</p>
</td>
</tr>
<tr>
<td>
<p><tt 
class="verbatim">-unsafe</tt></p>
</td>
<td>
<p>turn off index checking for arrays</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">-v</tt></p>
</td>
<td>
<p>display the version of the compiler</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">-w</tt> list</p>
</td>
<td>
<p>choose among the list the level of warning message</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">-impl</tt> file</p>
</td>
<td>
<p>indicate that file is a Caml source (.ml)</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">-intf</tt> file</p>
</td>
<td>
<p>indicate that file is a Caml interface (.mli)</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">-I</tt> directory</p>
</td>
<td>
<p>add directory in the list of directories; prefix <tt 
class="verbatim">+</tt> for relative</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">-g</tt></p>
</td>
<td>
<p>generate debugging information</p>
</td>
</tr>
</tbody>
</table></li>
<li><p>Warning levels:</p>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
<p><tt class="verbatim">A</tt>/<tt 
class="verbatim">a</tt></p>
</td>
<td>
<p>enable/disable all messages</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">F</tt>/<tt 
class="verbatim">f</tt></p>
</td>
<td>
<p>partial application in a sequence</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">P</tt>/<tt 
class="verbatim">p</tt></p>
</td>
<td>
<p>for incomplete pattern matching</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">U</tt>/<tt 
class="verbatim">u</tt></p>
</td>
<td>
<p>for missing cases in pattern matching</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">X</tt>/<tt 
class="verbatim">x</tt></p>
</td>
<td>
<p>enable/disable all other messages for hidden object</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">M</tt>/<tt 
class="verbatim">m</tt>, <tt 
class="verbatim">V</tt>/<tt 
class="verbatim">v</tt></p>
</td>
<td style="text-align: left">
<p>object-oriented related warnings</p>
</td>
</tr>
</tbody>
</table></li>
<li><p>Native compiler commands:</p>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
<p><tt 
class="verbatim">-compact</tt></p>
</td>
<td>
<p>optimize the produced code for space</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">-S</tt></p>
</td>
<td>
<p>keeps the assembly code in a file</p>
</td>
</tr>
<tr>
<td>
<p><tt 
class="verbatim">-inline</tt></p>
</td>
<td>
<p>level set the aggressiveness of inlining</p>
</td>
</tr>
</tbody>
</table></li>
<li><p>Environment variable <code>OCAMLRUNPARAM</code>:</p>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
<p><tt class="verbatim">b</tt></p>
</td>
<td>
<p>print detailed stack backtrace of runtime exceptions</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">s</tt>/<tt 
class="verbatim">h</tt>/<tt 
class="verbatim">i</tt></p>
</td>
<td>
<p>size of the minor heap/major heap/size increment</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">o</tt>/<tt 
class="verbatim">O</tt></p>
</td>
<td>
<p>major GC speed setting / heap compaction trigger setting</p>
</td>
</tr>
</tbody>
</table>
<p>Typical use, running <code>prog</code>:
<code>export OCAMLRUNPARAM='b'; ./prog</code></p>
<p>To have stack backtraces, compile with option
<code>-g</code>.</p></li>
<li><p>Toplevel loop directives:</p>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td style="text-align: left">
<p><tt 
class="verbatim">#quit;;</tt></p>
</td>
<td>
<p>exit</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">#directory "dir";;</tt></p>
</td>
<td>
<p>add <tt class="verbatim">dir</tt> to the “search path”;
<tt class="verbatim">+</tt> for rel.</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">#cd "dir-name";;</tt></p>
</td>
<td>
<p>change directory</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">#load "file-name";;</tt></p>
</td>
<td>
<p>load a bytecode <tt 
class="verbatim">.cmo</tt>/<tt 
class="verbatim">.cma</tt> file</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">#load_rec "file-name";;</tt></p>
</td>
<td>
<p>load the files <tt 
class="verbatim">file-name</tt> depends on too</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">#use "file-name";;</tt></p>
</td>
<td>
<p>read, compile and execute source phrases</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">#instal_printer pr_nm;;</tt></p>
</td>
<td>
<p>register <tt class="verbatim">pr_nm</tt> to print values of a
type</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">#print_depth num;;</tt></p>
</td>
<td>
<p>how many nestings to print</p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">#print_length num;;</tt></p>
</td>
<td>
<p>how many nodes to print – the rest <tt 
class="verbatim">…</tt></p>
</td>
</tr>
<tr>
<td>
<p><tt class="verbatim">#trace func;;</tt>/<tt 
class="verbatim">#untrace</tt></p>
</td>
<td>
<p>trace calls to <tt 
class="verbatim">func</tt>/stop tracing</p>
</td>
</tr>
</tbody>
</table></li>
</ul>
<h2 id="compiling-multiple-file-projects">1.1 Compiling multiple-file
projects</h2>
<ul>
<li><p>Traditionally the file containing a module would have a lowercase
name, although the module name is always uppercase.</p>
<ul>
<li>Some people think it is more elegant to use uppercase for file
names, to reflect module names, i.e. for MyModule, use
<code>MyModule.ml</code> rather than <code>myModule.ml</code>.</li>
</ul></li>
<li><p>We have a project with main module <code>main.ml</code> and
helper modules <code>sub1.ml</code> and <code>sub2.ml</code> with
corresponding interfaces.</p></li>
<li><p>Native compilation by hand:</p>
<p><code>…:…/Lec9$ ocamlopt sub1.mli…:…/Lec9$ ocamlopt  sub2.mli…:…/Lec9$ ocamlopt -c sub1.ml…:…/Lec9$  ocamlopt -c sub2.ml…:…/Lec9$ ocamlopt -c  main.ml…:…/Lec9$ ocamlopt unix.cmxa sub1.cmx sub2.cmx  main.cmx -o prog…:…/Lec9$ ./prog</code></p></li>
<li><p>Native compilation using <code>make</code>:</p></li>
</ul>
<div class="sourceCode" id="cb69"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>PROG := prog</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>LIBS := unix</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>SOURCES := sub1.ml sub2.ml main.ml</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>INTERFACES := $(wildcard *.mli)</span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>OBJS := $(patsubst %.ml,%.cmx,$(SOURCES))</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>LIBS := $(patsubst %,%.cmxa,$(LIBS))</span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>$(PROG): $(OBJS)</span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>ocamlopt -o $@ $(LIBS) $(OBJS)</span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>clean: rm -rf $(PROG) *.o *.cmx *.cmi *~</span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a>%.cmx: %.ml</span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a>ocamlopt -c $*.ml</span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a>%.cmi: %.mli</span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a>ocamlopt -c $*.mli</span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a>depend: $(SOURCES) $(INTERFACES)</span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a>ocamldep -native $(SOURCES) $(INTERFACES)</span></code></pre></div>
<ul>
<li>First use command:
<code>touch .depend; make depend; make</code></li>
<li>Later just <code>make</code>, after creating new source files
<code>make depend</code></li>
<li>Using <code>ocamlbuild</code>
<ul>
<li><p>files with compiled code are created in <code>_build</code>
directory</p></li>
<li><p>Command: <code>ocamlbuild -libs unix main.native</code></p></li>
<li><p>Resulting program is called <code>main.native</code> (in
directory <code>_build</code>, but with a link in the project
directory)</p></li>
<li><p>More arguments passed after comma, e.g.</p>
<p><code>ocamlbuild -libs nums,unix,graphics main.native</code></p></li>
<li><p>Passing parameters to the compiler with <code>-cflags</code>,
e.g.:</p>
<p><code>ocamlbuild -cflags -I,+lablgtk,-rectypes hello.native</code></p></li>
<li><p>Adding a – at the end (followed with command-line arguments for
the program) will compile and run the program:</p>
<p><code>ocamlbuild -libs unix main.native --</code></p></li>
</ul></li>
</ul>
<h2 id="editors">1.2 Editors</h2>
<ul>
<li>Emacs
<ul>
<li><code>ocaml-mode</code> from the standard distribution</li>
<li>alternative <code>tuareg-mode</code> <a
href="https://forge.ocamlcore.org/projects/tuareg/">https://forge.ocamlcore.org/projects/tuareg/</a>
<ul>
<li>cheat-sheet: <a
href="http://www.ocamlpro.com/files/tuareg-mode.pdf">http://www.ocamlpro.com/files/tuareg-mode.pdf</a></li>
</ul></li>
<li><code>camldebug</code> intergration with debugger</li>
<li>type feedback with <code>C-c C-t</code> key shortcut, needs
<code>.annot</code> files</li>
</ul></li>
<li>Vim
<ul>
<li>OMLet plugin <a
href="http://www.lix.polytechnique.fr/~dbaelde/productions/omlet.html">http://www.lix.polytechnique.fr/~dbaelde/productions/omlet.html</a></li>
<li>For type lookup: either <a
href="https://github.com/avsm/ocaml-annot">https://github.com/avsm/ocaml-annot</a>
<ul>
<li>or <a
href="http://www.vim.org/scripts/script.php?script_id=2025">http://www.vim.org/scripts/script.php?script_id=2025</a></li>
<li>also? <a
href="http://www.vim.org/scripts/script.php?script_id=1197">http://www.vim.org/scripts/script.php?script_id=1197</a></li>
</ul></li>
</ul></li>
<li>Eclipse
<ul>
<li><em>OCaml Development Tools</em> <a
href="http://ocamldt.free.fr/">http://ocamldt.free.fr/</a></li>
<li>an old plugin OcaIDE <a
href="http://www.algo-prog.info/ocaide/">http://www.algo-prog.info/ocaide/</a></li>
</ul></li>
<li>TypeRex <a
href="http://www.typerex.org/">http://www.typerex.org/</a>
<ul>
<li>currently mostly as <code>typerex-mode</code> for Emacs but
integration with other editors will become better</li>
<li>Auto-completion of identifiers (experimental)</li>
<li>Browsing of identifiers: show type and comment, go to
definition</li>
<li>local and whole-program refactoring: renaming identifiers and
compilation units, open elimination</li>
</ul></li>
<li>Indentation tool <code>ocp-ident</code> <a
href="https://github.com/OCamlPro/ocp-indent">https://github.com/OCamlPro/ocp-indent</a>
<ul>
<li>Installation instructions for Emacs and Vim</li>
<li>Can be used with other editors.</li>
</ul></li>
<li>Some dedicated editors
<ul>
<li>OCamlEditor <a
href="http://ocamleditor.forge.ocamlcore.org/">http://ocamleditor.forge.ocamlcore.org/</a></li>
<li><code>ocamlbrowser</code> inspects libraries and programs
<ul>
<li>browsing contents of modules</li>
<li>search by name and by type</li>
<li>basic editing, with syntax highlighting</li>
</ul></li>
<li>Cameleon <a
href="http://home.gna.org/cameleon/">http://home.gna.org/cameleon/</a>
(older)</li>
<li>Camelia <a
href="http://camelia.sourceforge.net/">http://camelia.sourceforge.net/</a>
(even older)</li>
</ul></li>
</ul>
<h1 id="imperative-features-in-ocaml">2 Imperative features in
OCaml</h1>
<p>OCaml is <strong>not</strong> a <em>purely functional</em> language,
it has built-in:</p>
<ul>
<li><p>Mutable arrays.</p>
<p>let a = Array.make 5 0 ina.(3) &lt;- 7; a.(2), a.(3)</p>
<ul>
<li><p>Hashtables in the standard distribution (based on arrays).</p>
<p>let h = Hashtbl.create 11 inTakes initial size of the
array.Hashtbl.add h “Alpha” 5; Hashtbl.find h “Alpha”</p></li>
</ul></li>
<li><p>Mutable strings. (Historical reasons…)</p>
<p>let a = String.make 4 ‘a’ ina.[2] &lt;- ‘b’; a.[2], a.[3]</p>
<ul>
<li>Extensible mutable strings Buffer.t in standard distribution.</li>
</ul></li>
<li><p>Loops:</p>
<ul>
<li>for i = a to/downto b do body done</li>
<li>while condition do body done</li>
</ul></li>
<li><p>Mutable record fields, for example:</p>
<p>type ’a ref = { mutable contents : ’a }Single, mutable field.</p>
<p>A record can have both mutable and immutable fields.</p>
<ul>
<li><p>Modifying the field: record.field &lt;- new_value</p></li>
<li><p>The ref type has operations:</p>
<p>let (:=) r v = r.contents &lt;- vlet (!) r = r.contents</p></li>
</ul></li>
<li><p>Exceptions, defined by exception, raised by raise and caught by
try-with clauses.</p>
<ul>
<li>An exception is a variant of type exception, which is the only open
algebraic datatype – new variants can be added to it.</li>
</ul></li>
<li><p>Input-output functions have no “type safeguards” (no <em>IO
monad</em>).</p></li>
</ul>
<p>Using <strong>global</strong> state e.g. reference cells makes code
<em>non re-entrant</em>: finish one task before starting another – any
form of concurrency is excluded.</p>
<h2 id="parsing-command-line-arguments">2.1 Parsing command-line
arguments</h2>
<p>To go beyond Sys.argv array, see Arg module:<a
href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Arg.html">http://caml.inria.fr/pub/docs/manual-ocaml/libref/Arg.html</a></p>
<p>type config = { Example: configuring a <em>Mine Sweeper</em> game.
nbcols : int ; nbrows : int ; nbmines : int }let defaultconfig = {
nbcols=10; nbrows=10; nbmines=15 }let setnbcols cf n = cf := {!cf with
nbcols = n}let setnbrows cf n = cf := {!cf with nbrows = n}let
setnbmines cf n = cf := {!cf with nbmines = n}let readargs() = let cf =
ref defaultconfig inState of configuration let speclist = will be
updated by given functions. [(“-col”, Arg.Int (setnbcols cf), “number of
columns”); (“-lin”, Arg.Int (setnbrows cf), “number of lines”); (“-min”,
Arg.Int (setnbmines cf), “number of mines”)] in let usagemsg = “usage :
minesweep [-col n] [-lin n] [-min n]” in Arg.parse speclist (fun s -&gt;
()) usagemsg; !cf</p>
<h1 id="ocaml-garbage-collection">3 OCaml Garbage Collection</h1>
<h2 id="representation-of-values">3.1 Representation of values</h2>
<ul>
<li>Pointers always end with <code>00</code> in binary (addresses are in
number of bytes).</li>
<li>Integers are represented by shifting them 1 bit, setting the last
bit to <code>1</code>.</li>
<li>Constant constructors (i.e. variants without parameters) like
<code>None</code>, [] and (), and other integer-like types
(<code>char</code>, <code>bool</code>) are represented in the same way
as integers.</li>
<li>Pointers are always to OCaml <em>blocks</em>. Variants with
parameters, strings and OCaml arrays are stored as blocks.</li>
<li>A block starts with a header, followed by an array of values of size
1 word: either integer-like, or pointers.</li>
<li>The header stores the size of the block, the 2-bit color used for
garbage collection, and 8-bit <em>tag</em> – which variant it is.
<ul>
<li>Therefore there can be at most about 240 variants with parameters in
a variant type (some tag numbers are reserved).</li>
<li><em>Polymorphic variants</em> are a different story.</li>
</ul></li>
</ul>
<h2 id="generational-garbage-collection">3.2 Generational Garbage
Collection</h2>
<ul>
<li>OCaml has two heaps to store blocks: a small, continuous <em>minor
heap</em> and a growing-as-necessary <em>major heap</em>.</li>
<li>Allocation simply moves the minor heap pointer (aka. the <em>young
pointer</em>) and returns the pointed address.
<ul>
<li>Allocation of very large blocks uses the major heap instead.</li>
</ul></li>
<li>When the minor heap runs out of space, it triggers the <em>minor
(garbage) collection</em>, which uses the <em>Stop &amp; Copy</em>
algorithm.</li>
<li>Together with the minor collection, a slice of <em>major (garbage)
collection</em> is performed to cleanup the major heap a bit.
<ul>
<li>The major heap is not cleaned all at once because it might stop the
main program (i.e. our application) for too long.</li>
<li>Major collection uses the <em>Mark &amp; Sweep</em> algorithm.</li>
</ul></li>
<li>Great if most minor heap blocks are already not needed when
collection starts – garbage does <strong>not</strong> slow down
collection.</li>
</ul>
<h2 id="stop-copy-gc">3.3 Stop &amp; Copy GC</h2>
<ul>
<li>Minor collection starts from a set of <em>roots</em> – young blocks
that definitely are not garbage.</li>
<li>Besides the root set, OCaml also maintains the <em>remembered
set</em> of minor heap blocks pointed at from the major heap.
<ul>
<li>Most mutations must check whether they assign a minor heap block to
a major heap block field. This is called <em>write barrier</em>.</li>
<li>Immutable blocks cannot contain pointers from major to minor heap.
<ul>
<li>Unless they are lazy blocks.</li>
</ul></li>
</ul></li>
<li>Collection follows pointers in the root set and remembered set to
find other used blocks.</li>
<li>Every found block is copied to the major heap.</li>
<li>At the end of collection, the young pointer is reset so that the
minor heap is empty again.</li>
</ul>
<h2 id="mark-sweep-gc">3.4 Mark &amp; Sweep GC</h2>
<ul>
<li>Major collection starts from a separate root set – old blocks that
definitely are not garbage.</li>
<li>Major garbage collection consists of a <em>mark</em> phase which
colors blocks that are still in use and a <em>sweep</em> phase that
searches for stretches of unused memory.
<ul>
<li>Slices of the mark phase are performed by-after each minor
collection.</li>
<li>Unused memory is stored in a <em>free list</em>.</li>
</ul></li>
<li>The “proper” major collection is started when a minor collection
consumes the remaining free list. The mark phase is finished and sweep
phase performed.</li>
<li>Colors:
<ul>
<li><strong>gray</strong>: marked cells whose descendents are not yet
marked;</li>
<li><strong>black</strong>: marked cells whose descendents are also
marked;</li>
<li><strong>hatched</strong>: free list element;</li>
<li><strong>white</strong>: elements previously being in use.</li>
</ul></li>
<li><code># let u = let l = ['c'; 'a'; 'm'] in List.tl l ;;``val u : char list =  ['a'; 'm']``# let v = let r = ( ['z'] , u ) in match r with p -&gt; (fst p)  @ (snd p) ;;``val v : char list = ['z'; 'a'; 'm']</code></li>
<li><img src="book-ora034-GC_Marking_phase.gif" /></li>
<li><img src="book-ora035-GC_Sweep_phase.gif" /></li>
</ul>
<h1 id="stack-frames-and-closures">4 Stack Frames and Closures</h1>
<ul>
<li>The nesting of procedure calls is reflected in the <em>stack</em> of
procedure data.</li>
<li>The stretch of stack dedicated to a single function is <em>stack
frame</em> aka. <em>activation record</em>.</li>
<li><em>Stack pointer</em> is where we create new frames, stored in a
special register.</li>
<li><em>Frame pointer</em> allows to refer to function data by offset –
data known early in compilation is close to the frame pointer.</li>
<li>Local variables are stored in the stack frame or in registers – some
registers need to be saved prior to function call (<em>caller-save</em>)
or at entry to a function (<em>callee-save</em>). OCaml avoids
callee-save registers.</li>
<li>Up to 4-6 arguments can be passed in registers, remaining ones on
stack.
<ul>
<li>Note that <em>x86</em> architecture has a small number of
registers.</li>
</ul></li>
<li>Using registers, tail call optimization and function inlining can
eliminate the use of stack entirely. OCaml compiler can also use stack
more efficiently than by creating full stack frames as depicted
below.</li>
<li><table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
</td>
<td>
</td>
</tr>
</tbody>
</table></li>
<li><em>Static links</em> point to stack frames of parent functions, so
we can access stack-based data, e.g. arguments of a main function from
inside <code>aux</code>.</li>
<li>A <strong><em>closure</em></strong> represents a function: it is a
block that contains address of the function: either another closure or a
machine-code pointer, and a way to access non-local variables of the
function.
<ul>
<li>For partially applied functions, it contains the values of arguments
and the address of the original function.</li>
</ul></li>
<li><em>Escaping variables</em> are the variables of a function
<code>f</code> – arguments and local definitions – which are accessed
from a nested function which is part of the returned value of
<code>f</code> (or assigned to a mutable field).
<ul>
<li>Escaping variables must be either part of the closures representing
the nested functions, or of a closure representing the function
<code>f</code> – in the latter case, the nested functions must also be
represented by closures that have a link to the closure of
<code>f</code>.</li>
</ul></li>
</ul>
<h2 id="tail-recursion">4.1 Tail Recursion</h2>
<ul>
<li>A function call <code>f x</code> within the body of another function
<code>g</code> is in <em>tail position</em> if, roughly “calling
<code>f</code> is the last thing that <code>g</code> will do before
returning”.</li>
<li>Call inside try … with clause is not in tail position!
<ul>
<li>For efficient exceptions, OCaml stores <em>traps</em> for try-with
on the stack with topmost trap in a register, after raise unwinding
directly to the trap.</li>
</ul></li>
<li>The steps for a tail call are:
<ol type="1">
<li>Move actual parameters into argument registers (if they aren’t
already there).</li>
<li>Restore callee-save registers (if needed).</li>
<li>Pop the stack frame of the calling function (if it has one).</li>
<li>Jump to the callee.</li>
</ol></li>
<li>Bytecode always throws <code>Stack_overflow</code> exception on too
deep recursion, native code will sometimes cause <em>segmentation
fault</em>!</li>
<li>List<code>.map</code> from the standard distribution is
<strong>not</strong> tail-recursive.</li>
</ul>
<h2 id="generated-assembly">4.2 Generated assembly</h2>
<ul>
<li>Let us look at examples from <a
href="http://ocaml.org/tutorials/performance_and_profiling.html">http://ocaml.org/tutorials/performance_and_profiling.html</a></li>
</ul>
<h1 id="profiling-and-optimization">5 Profiling and Optimization</h1>
<ul>
<li>Steps of optimizing a program:
<ol type="1">
<li>Profile the program to find bottlenecks: where the time is
spent.</li>
<li>If possible, modify the algorithm used by the bottleneck to an
algorithm with better asymptotic complexity.</li>
<li>If possible, modify the bottleneck algorithm to access data less
randomly, to increase <em>cache locality</em>.
<ul>
<li>Additionally, <em>realtime</em> systems may require avoiding use of
huge arrays, traversed by the garbage collector in one go.</li>
</ul></li>
<li>Experiment with various implementations of data structures used
(related to step 3).</li>
<li>Avoid <em>boxing</em> and polymorphic functions. Especially for
numerical processing. (OCaml specific.)</li>
<li><em>Deforestation</em>.</li>
<li><em>Defunctorization</em>.</li>
</ol></li>
</ul>
<h2 id="profiling">5.1 Profiling</h2>
<ul>
<li>We cover native code profiling because it is more useful.
<ul>
<li>It relies on the “Unix” profiling program <code>gprof</code>.</li>
</ul></li>
<li>First we need to compile the sources in profiling mode:
<code>ocamlopt -p</code> …
<ul>
<li><p>or using <code>ocamlbuild</code> when program source is in
<code>prog.ml</code>:</p>
<p><code>ocamlbuild prog.p.native --</code></p></li>
</ul></li>
<li>The execution of program <code>./prog</code> produces a file
<code>gmon.out</code></li>
<li>We call <code>gprof prog &gt; profile.txt</code>
<ul>
<li><p>or when we used <code>ocamlbuild</code> as above:</p>
<p><code>gprof prog.p.native &gt; profile.txt</code></p></li>
<li><p>This redirects profiling analysis to <code>profile.txt</code>
file.</p></li>
</ul></li>
<li>The result <code>profile.txt</code> has three parts:
<ol type="1">
<li>List of functions in the program in descending order of the time
which was spent within the body of the function, excluding time spent in
the bodies of any other functions.</li>
<li>A hierarchical representation of the time taken by each function,
and the total time spent in it, including time spent in functions it
called.</li>
<li>A bibliography of function references.</li>
</ol></li>
<li>It contains C/assembly function names like
<code>camlList__assoc_1169</code>:
<ul>
<li>Prefix <code>caml</code> means function comes from OCaml
source.</li>
<li><code>List__</code> means it belongs to a List module.</li>
<li><code>assoc</code> is the name of the function in source.</li>
<li>Postfix <code>_1169</code> is used to avoid name clashes, as in
OCaml different functions often have the same names.</li>
</ul></li>
<li>Example: computing words histogram for a large file,
<code>Optim0.ml</code>.</li>
</ul>
<p>let readwords file =Imperative programming example. let input =
openin file in let words = ref [] and more = ref true in tryLecture 6
<code>read_lines</code> function would stack-overflow while !more
dobecause of the try-with clause. Scanf.fscanf input
“%[a-zA-Z0-9’]%[a-zA-Z0-9’]” (fun b x -&gt; words := x :: !words; more
:= x &lt;&gt; ““) done; List.rev (List.tl !words) with Endoffile -&gt;
List.rev !wordslet empty () = []let increment h w =Inefficient map
update. try let c = List.assoc w h in (w, c+1) :: List.removeassoc w h
with Notfound -&gt; (w, 1)::hlet iterate f h =<br />
List.iter (fun (k,v)-&gt;f k v) hlet histogram words = List.foldleft
increment (empty ()) wordslet = let words = readwords”./shakespeare.xml”
in let words = List.revmap String.lowercase words in let h = histogram
words in let output = openout “histogram.txt” in iterate (Printf.fprintf
output “%s: %dn”) h; closeout output</p>
<ul>
<li>Now we look at the profiling analysis, first part begins with:</li>
</ul>
<pre><code>  %   cumulative   self              self     total
 time   seconds   seconds    calls   s/call   s/call  name
 37.88      8.54     8.54 306656698    0.00     0.00  compare_val
 19.97     13.04     4.50   273169     0.00     0.00  camlList__assoc_1169
  9.17     15.10     2.07 633527269    0.00     0.00  caml_page_table_lookup
  8.72     17.07     1.97   260756    0.00  0.00 camlList__remove_assoc_1189
  7.10     18.67     1.60 612779467    0.00     0.00  caml_string_length
  4.97     19.79     1.12 306656692     0.00    0.00  caml_compare
  2.84     20.43     0.64                             caml_c_call
  1.53     20.77     0.35    14417     0.00     0.00  caml_page_table_modify
  1.07     21.01     0.24     1115     0.00     0.00  sweep_slice
  0.89     21.21     0.20      484     0.00     0.00  mark_slice</code></pre>
<ul>
<li>List.assoc and List.removeassoc high in the ranking suggests to us
that <code>increment</code> could be the bottleneck.
<ul>
<li>They both use comparison which could explain why
<code>compare_val</code> consumes the most of time.</li>
</ul></li>
<li>Next we look at the interesting pieces of the second part: data
about the <code>increment</code> function.
<ul>
<li>Each block, separated by —— lines, describes the function whose line
starts with an index in brackets.</li>
<li>The functions that called it are above, the functions it calls
below.</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb71"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>index % time    self  children    called     name</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>-----------------------------------------------</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>                <span class="fl">0.00</span>    <span class="fl">6.47</span>  <span class="dv">273169</span>/<span class="dv">273169</span>  camlList__fold_left_1078 [<span class="dv">7</span>]</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>[<span class="dv">8</span>]     <span class="fl">28.7</span>    <span class="fl">0.00</span>    <span class="fl">6.47</span>  <span class="dv">273169</span>         camlOptim0__increment_1038 [<span class="dv">8</span>]</span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>                <span class="fl">4.50</span>    <span class="fl">0.00</span>  <span class="dv">273169</span>/<span class="dv">273169</span>  camlList__assoc_1169 [<span class="dv">9</span>]</span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>               <span class="fl">1.97</span>    <span class="fl">0.00</span>  <span class="dv">260756</span>/<span class="dv">260756</span>  camlList__remove_assoc_1189 [<span class="dv">11</span>]</span></code></pre></div>
<ul>
<li>As expected, <code>increment</code> is only called by
List.fold_left. But it seems to account for only 29% of time. It is
because <code>compare</code> is not analysed correctly, thus not
included in time for <code>increment</code>:</li>
</ul>
<pre><code>-----------------------------------------------
                1.12   12.13 306656692/306656692     caml_c_call [1]
[2]     58.8    1.12   12.13 306656692         caml_compare [2]
                8.54    3.60 306656692/306656698     compare_val [3]</code></pre>
<h2 id="algorithmic-optimizations">5.2 Algorithmic optimizations</h2>
<ul>
<li><p>(All times measured with profiling turned on.)</p></li>
<li><p><code>Optim0.ml</code> asymptotic time complexity: <span
class="math inline">\mathcal{O} (n^2)</span>, time: 22.53s.</p>
<ul>
<li>Garbage collection takes 6% of time.
<ul>
<li>So little because data access wastes a lot of time.</li>
</ul></li>
</ul></li>
<li><p>Optimize the data structure, keep the algorithm.</p>
<p>let empty () = Hashtbl.create 511let increment h w = try let c =
Hashtbl.find h w in Hashtbl.replace h w (c+1); h with Notfound -&gt;
Hashtbl.add h w 1; hlet iterate f h = Hashtbl.iter f h</p>
<p><code>Optim1.ml</code> asymptotic time complexity: <span
class="math inline">\mathcal{O} (n)</span>, time: 0.63s.</p>
<ul>
<li>Garbage collection takes 17% of time.</li>
</ul></li>
<li><p>Optimize the algorithm, keep the data structure.</p>
<p>let histogram words = let words = List.sort String.compare words in
let k,c,h = List.foldleft (fun (k,c,h) w -&gt; if k = w then k, c+1, h
else w, 1, ((k,c)::h)) (““, 0, []) words in (k,c)::h</p>
<p><code>Optim2.ml</code> asymptotic time complexity: <span
class="math inline">\mathcal{O} (n \log n)</span>, time: 1s.</p>
<ul>
<li>Garbage collection takes 40% of time.</li>
</ul></li>
<li><p>Optimizing for cache efficiency is more advanced, we will not
attempt it.</p></li>
<li><p>With algorithmic optimizations we should be concerned with
<strong>asymptotic complexity</strong> in terms of the <span
class="math inline">\mathcal{O} (\cdot)</span> notation, but we will not
pursue complexity analysis in the remainder of the lecture.</p></li>
</ul>
<h2 id="low-level-optimizations">5.3 Low-level optimizations</h2>
<ul>
<li><p>Optimizations below have been made <em>for educational purposes
only</em>.</p></li>
<li><p>Avoid polymorphism in generic comparison function (=).</p>
<p>let rec assoc x = function [] -&gt; raise Notfound | (a,b)::l -&gt;
if String.compare a x = 0 then b else assoc x llet rec removeassoc x =
function | [] -&gt; [] | (a, b as pair) :: l -&gt; if String.compare a x
= 0 then l else pair :: removeassoc x l</p>
<p><code>Optim3.ml</code> (based on <code>Optim0.ml</code>) time:
19s.</p>
<ul>
<li>Despite implementation-wise the code is the same, as String.compare
= Pervasives.compare inside module String, and List.<code>assoc</code>
is like above but uses Pervasives.compare!</li>
<li>We removed polymorphism, no longer <code>caml_compare_val</code>
function.</li>
<li>Usually, adding type annotations would be enough. (Useful especially
for numeric types int, float.)</li>
</ul></li>
<li><p><strong>Deforestation</strong> means removing intermediate data
structures.</p>
<p>let readtohistogram file = let input = openin file in let h = empty
() and more = ref true in try while !more do Scanf.fscanf input
“%[a-zA-Z0-9’]%[a-zA-Z0-9’]” (fun b w -&gt; let w = String.lowercase w
in increment h w; more := w &lt;&gt; ““)<br />
done; h with Endoffile -&gt; h</p>
<p><code>Optim4.ml</code> (based on <code>Optim1.ml</code>) time:
0.51s.</p>
<ul>
<li>Garbage collection takes 8% of time.
<ul>
<li>So little because we have eliminated garbage.</li>
</ul></li>
</ul></li>
<li><p><strong>Defunctorization</strong> means computing functor
applications by hand.</p>
<ul>
<li>There was a tool <code>ocamldefun</code> but it is out of date.</li>
<li>The slight speedup comes from the fact that functor arguments are
implemented as records of functions.</li>
</ul></li>
</ul>
<h2 id="comparison-of-data-structure-implementations">5.4 Comparison of
data structure implementations</h2>
<ul>
<li>We perform a rough comparison of association lists, tree-based maps
and hashtables. Sets would give the same results.</li>
<li>We always create hashtables with initial size 511.</li>
<li><span class="math inline">10^7</span> operations of: adding an
association (creation), finding a key that is in the map, finding a key
out of a small number of keys not in the map.</li>
<li>First row gives sizes of maps. Time in seconds, to two significant
digits.</li>
</ul>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
create:
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
assoc list
</td>
<td>
0.25
</td>
<td>
0.25
</td>
<td>
0.18
</td>
<td>
0.19
</td>
<td>
0.17
</td>
<td>
0.22
</td>
<td>
0.19
</td>
<td>
0.19
</td>
<td>
0.19
</td>
<td>
</td>
</tr>
<tr>
<td>
tree map
</td>
<td>
0.48
</td>
<td>
0.81
</td>
<td>
0.82
</td>
<td>
1.2
</td>
<td>
1.6
</td>
<td>
2.3
</td>
<td>
2.7
</td>
<td>
3.6
</td>
<td>
4.1
</td>
<td>
5.1
</td>
</tr>
<tr>
<td style="text-align: left">
hashtable
</td>
<td>
27
</td>
<td>
9.1
</td>
<td>
5.5
</td>
<td>
4
</td>
<td>
2.9
</td>
<td>
2.4
</td>
<td>
2.1
</td>
<td>
1.9
</td>
<td>
1.8
</td>
<td>
3.7
</td>
</tr>
</tbody>
</table>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
create:
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
tree map
</td>
<td>
6.5
</td>
<td>
8
</td>
<td>
9.8
</td>
<td>
15
</td>
<td>
19
</td>
<td>
26
</td>
<td>
34
</td>
<td>
41
</td>
<td>
51
</td>
<td>
67
</td>
<td>
80
</td>
<td>
130
</td>
</tr>
<tr>
<td style="text-align: left">
hashtable
</td>
<td>
4.8
</td>
<td>
5.6
</td>
<td>
6.4
</td>
<td>
8.4
</td>
<td>
12
</td>
<td>
15
</td>
<td>
19
</td>
<td>
20
</td>
<td>
22
</td>
<td>
24
</td>
<td>
23
</td>
<td>
33
</td>
</tr>
</tbody>
</table>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
found:
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
assoc list
</td>
<td>
1.1
</td>
<td>
1.5
</td>
<td>
2.5
</td>
<td>
4.2
</td>
<td>
8.1
</td>
<td>
17
</td>
<td>
30
</td>
<td>
60
</td>
<td>
120
</td>
<td>
</td>
</tr>
<tr>
<td>
tree map
</td>
<td>
1
</td>
<td>
1.1
</td>
<td>
1.3
</td>
<td>
1.5
</td>
<td>
1.9
</td>
<td>
2.1
</td>
<td>
2.5
</td>
<td>
2.8
</td>
<td>
3.1
</td>
<td>
3.6
</td>
</tr>
<tr>
<td style="text-align: left">
hashtable
</td>
<td>
1.4
</td>
<td>
1.5
</td>
<td>
1.4
</td>
<td>
1.4
</td>
<td>
1.5
</td>
<td>
1.5
</td>
<td>
1.6
</td>
<td>
1.6
</td>
<td>
1.8
</td>
<td>
1.8
</td>
</tr>
</tbody>
</table>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
found:
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
tree map
</td>
<td>
4.3
</td>
<td>
5.2
</td>
<td>
6
</td>
<td>
7.6
</td>
<td>
9.4
</td>
<td>
12
</td>
<td>
15
</td>
<td>
17
</td>
<td>
19
</td>
<td>
24
</td>
<td>
28
</td>
<td>
32
</td>
</tr>
<tr>
<td style="text-align: left">
hashtable
</td>
<td>
1.8
</td>
<td>
2
</td>
<td>
2.5
</td>
<td>
3.1
</td>
<td>
4
</td>
<td>
5.1
</td>
<td>
5.9
</td>
<td>
6.4
</td>
<td>
6.8
</td>
<td>
7.6
</td>
<td>
6.7
</td>
<td>
7.5
</td>
</tr>
</tbody>
</table>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
not found:
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
assoc list
</td>
<td>
1.8
</td>
<td>
2.6
</td>
<td>
4.6
</td>
<td>
8
</td>
<td>
16
</td>
<td>
32
</td>
<td>
60
</td>
<td>
120
</td>
<td>
240
</td>
<td>
</td>
</tr>
<tr>
<td>
tree map
</td>
<td>
1.5
</td>
<td>
1.5
</td>
<td>
1.8
</td>
<td>
2.1
</td>
<td>
2.4
</td>
<td>
2.7
</td>
<td>
3
</td>
<td>
3.2
</td>
<td>
3.5
</td>
<td>
3.8
</td>
</tr>
<tr>
<td style="text-align: left">
hashtable
</td>
<td>
1.4
</td>
<td>
1.4
</td>
<td>
1.5
</td>
<td>
1.5
</td>
<td>
1.6
</td>
<td>
1.5
</td>
<td>
1.7
</td>
<td>
1.9
</td>
<td>
2
</td>
<td>
2.1
</td>
</tr>
</tbody>
</table>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
not found:
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
tree map
</td>
<td>
4.2
</td>
<td>
4.3
</td>
<td>
4.7
</td>
<td>
4.9
</td>
<td>
5.3
</td>
<td>
5.5
</td>
<td>
6.1
</td>
<td>
6.3
</td>
<td>
6.6
</td>
<td>
7.2
</td>
<td>
7.5
</td>
<td>
7.3
</td>
</tr>
<tr>
<td style="text-align: left">
hashtable
</td>
<td>
1.8
</td>
<td>
1.9
</td>
<td>
2
</td>
<td>
1.9
</td>
<td>
1.9
</td>
<td>
1.9
</td>
<td>
2
</td>
<td>
2
</td>
<td>
2.2
</td>
<td>
2
</td>
<td>
2
</td>
<td>
1.9
</td>
</tr>
</tbody>
</table>
<ul>
<li>Using lists makes sense for up to about 15 elements.</li>
<li>Unfortunately OCaml and Haskell do not encourage the use of
efficient maps, the way Scala and Python have built-in syntax for
them.</li>
</ul>
<h1 id="parsing-ocamllex-and-menhir">6 Parsing: ocamllex and Menhir</h1>
<ul>
<li><em>Parsing</em> means transforming text, i.e. a string of
characters, into a data structure that is well fitted for a given task,
or generally makes information in the text more explicit.</li>
<li>Parsing is usually done in stages:
<ol type="1">
<li><em>Lexing</em> or <em>tokenizing</em>, dividing the text into
smallest meaningful pieces called <em>lexemes</em> or
<em>tokens</em>,</li>
<li>composing bigger structures out of lexemes/tokens (and smaller
structures) according to a <em>grammar</em>.
<ul>
<li>Alternatively to building such hierarchical structure, sometimes we
build relational structure over the tokens, e.g. <em>dependency
grammars</em>.</li>
</ul></li>
</ol></li>
<li>We will use <code>ocamllex</code> for lexing, whose rules are like
pattern matching functions, but with patterns being <em>regular
expressions</em>.</li>
<li>We will either consume the results from lexer directly, or use
<em>Menhir</em> for parsing, a successor of <code>ocamlyacc</code>,
belonging to the <em>yacc</em>/<em>bison</em> family of parsers.</li>
</ul>
<h2 id="lexing-with-ocamllex">6.1 Lexing with <em>ocamllex</em></h2>
<ul>
<li><p>The format of lexer definitions is as follows: file with
extension <code>.mll</code></p>
<p>{ header }let ident1 = regexp …rule <code>entrypoint1</code>
[<code>arg1</code>… <code>argN</code>] = parse regexp { action1 }| …|
regexp { actionN }and entrypointN [arg1? argN] = parse …and …{ trailer
}</p>
<ul>
<li>Comments are delimited by (* and *), as in OCaml.</li>
<li>The parse keyword can be replaced by the shortest keyword.</li>
<li>”Header”, “trailer”, “action1”, … “actionN” are arbitrary OCaml
code.</li>
<li>There can be multiple let-clauses and rule-clauses.</li>
</ul></li>
<li><p>Let-clauses are shorthands for regular expressions.</p></li>
<li><p>Each rule-clause <code>entrypoint</code> defines function(s) that
as the last argument (after <code>arg1</code>… <code>argN</code> if
<code>N</code>&gt;0) takes argument <code>lexbuf</code> of type
Lexing.lexbuf.</p>
<ul>
<li><code>lexbuf</code> is also visible in actions, just as a regular
argument.</li>
<li><code>entrypoint1</code>… <code>entrypointN</code> can be mutually
recursive if we need to read more before we can return output.</li>
<li>It seems rule keyword can be used only once.</li>
</ul></li>
<li><p>We can use <code>lexbuf</code> in actions:</p>
<ul>
<li>Lexing.lexeme lexbuf – Return the matched string.</li>
<li>Lexing.lexemechar lexbuf n – Return the nth character in the matched
string. The first character corresponds to n = 0.</li>
<li>Lexing.lexemestart/lexemeend lexbuf – Return the absolute position
in the input text of the beginning/end of the matched string (i.e. the
offset of the first character of the matched string). The first
character read from the input text has offset 0.</li>
</ul></li>
<li><p>The parser will call an <code>entrypoint</code> when it needs
another lexeme/token.</p></li>
<li><p>The syntax of <strong>regular expressions</strong></p>
<ul>
<li>‘c’ – match the character ‘c’</li>
<li><code>_</code> – match a <strong>single</strong> character</li>
<li><code>eof</code> – match end of lexer input</li>
<li>“string” – match the corresponding sequence of characters</li>
<li>[character set] – match the character set, characters ‘c’ and ranges
of characters ‘c’-‘d’ separated by space</li>
<li>[^character set] – match characters outside the character set</li>
<li>[character set 1] # [character set 2] – match the difference,
i.e. only characters in set 1 that are not in set 2</li>
<li>regexp* – (repetition) match the concatenation of zero or more
strings that match regexp</li>
<li>regexp+ – (strict repetition) match the concatenation of one or more
strings that match regexp</li>
<li>regexp? – (option) match the empty string, or a string matching
regexp.</li>
<li>regexp1 | regexp2 – (alternative) match any string that matches
regexp1 or regexp2</li>
<li>regexp1 regexp2 – (concatenation) match the concatenation of two
strings, the first matching regexp1, the second matching regexp2.</li>
<li>( regexp ) – match the same strings as regexp</li>
<li><code>ident</code> – reference the regular expression bound to ident
by an earlier let <code>ident</code> = regexp definition</li>
<li>regexp as <code>ident</code> – bind the substring matched by regexp
to identifier <code>ident</code>.</li>
</ul>
<p>The precedences are: # highest, followed by *, +, ?, concatenation,
|, as.</p></li>
<li><p>The type of as <code>ident</code> variables can be string, char,
string option or char option</p>
<ul>
<li>char means obviously a single character pattern</li>
<li>option means situations like (regexp as <code>ident</code>)? or
regexp1|(regexp2 as <code>ident</code>)</li>
<li>The variables can repeat in the pattern (<strong>unlike</strong> in
normal paterns) – meaning both regexpes match the same substrings.</li>
</ul></li>
<li><p><code>ocamllex Lexer.mll</code> produces the lexer code in
<code>Lexer.ml</code></p>
<ul>
<li><code>ocamlbuild</code> will call <code>ocamllex</code> and
<code>ocamlyacc</code>/<code>menhir</code> if needed</li>
</ul></li>
<li><p>Unfortunately if the lexer patterns are big we get an error:</p>
<p><em>transition table overflow, automaton is too big</em></p></li>
</ul>
<h3 id="example-finding-email-addresses">6.1.1 Example: Finding email
addresses</h3>
<ul>
<li><p>We mine a text file for email addresses, that could have been
obfuscated to hinder our job…</p></li>
<li><p>To compile and run <code>Emails.mll</code>, processing a file
<code>email_corpus.xml</code>:</p>
<p><code>ocamlbuild Emails.native -- email_corpus.xml</code></p></li>
</ul>
<p>{The header with OCaml code. open LexingMake accessing Lexing easier.
let nextline lexbuf =Typical lexer function: move position to next line.
let pos = lexbuf.lexcurrp in lexbuf.lexcurrp &lt;- { pos with poslnum =
pos.poslnum + 1; posbol = pos.poscnum; } type state =Which step of
searching for address we’re at: | SeekSeek: still seeking, Addr (true…):
possibly finished, | Addr of bool * string * string
<code>list</code>Addr (false…): no domain.</p>
<pre><code>(* Report the found address, if any. *)
let report state lexbuf =
  match state with
  | Seek -&gt; ()
  | Addr (false, _, _) -&gt; ()
  | Addr (true, name, addr) -&gt;  (* With line at which it is found. *)
    Printf.printf &quot;%d: %s@%s\n&quot;
      lexbuf.lex_curr_p.pos_lnum
      name (String.concat &quot;.&quot; (List.rev addr))
}
let newline = (&#39;\n&#39; | &quot;\r\n&quot;)  (* Regexp for end of line. *)
let addrchar = [&#39;a&#39;-&#39;z&#39;&#39;A&#39;-&#39;Z&#39;&#39;0&#39;-&#39;9&#39;&#39;-&#39;&#39;_&#39;]
let atwsymb = &quot;where&quot; | &quot;WHERE&quot; | &quot;at&quot; | &quot;At&quot; | &quot;AT&quot;
let atnwsymb = &#39;@&#39; | &quot;&amp;#x40;&quot; | &quot;&amp;#64;&quot;
let opensymb = &#39; &#39;* &#39;(&#39; &#39; &#39;* | &#39; &#39;+  (* Demarcate a possible @ *)
let closesymb = &#39; &#39;* &#39;)&#39; &#39; &#39;* | &#39; &#39;+  (* or . symbol. *)
let atsepsymb = opensymb? atnwsymb closesymb? | opensymb atwsymb closesymb</code></pre>
<p>let dotwsymb = “dot” | “DOT” | “dt” | “DT”let domwsymb = dotwsymb |
“dom” | “DOM”Obfuscation for last dot.let dotsepsymb = opensymb dotwsymb
closesymb |<br />
opensymb? ‘.’ closesymb?let domsepsymb = opensymb domwsymb closesymb
|<br />
opensymb? ‘.’ closesymb?let addrdom =
<code>addrchar addrchar</code>Restricted form of last part| “edu” |
“EDU” | “org” | “ORG” | “com” | “COM”of address.rule
<code>email  state</code> = parse| <code>newline</code>Check state
before moving on.{ report state lexbuf; nextline lexbuf; email Seek
lexbuf }<span class="math inline">\swarrow</span>Detected possible start
of address.| (addrchar+ as name) atsepsymb (addrchar+ as addr) { email
(Addr (false, name, [addr])) lexbuf }</p>
<div class="line-block">domsepsymb (addrdom as dom)Detected possible
finish of address. { let</div>
<p>state = match state with | Seek -&gt; SeekWe weren’t looking at an
address. | Addr (, name, addrs) -&gt;Bingo. Addr (true, name,
dom::addrs) in email state lexbuf }| dotsepsymb (addrchar+ as addr)Next
part of address – { let state =must be continued. match state with |
Seek -&gt; Seek | Addr (, name, addrs) -&gt;<br />
Addr (false, name, addr::addrs) in email state lexbuf }|
<code>eof</code>End of file – end loop.{ report state lexbuf }|Some
boring character – not looking at an address yet.{ report state lexbuf;
email Seek lexbuf }{The trailer with OCaml code. let =Open a file and
start mining for email addresses. let ch = openin Sys.argv.(1) in email
Seek (Lexing.fromchannel ch); closein chClose the file at the end.}</p>
<h2 id="parsing-with-menhir">6.2 Parsing with Menhir</h2>
<ul>
<li><p>The format of parser definitions is as follows: file with
extension <code>.mly</code></p>
<p>%{ header %}OCaml code put in front.%parameter &lt; M : signature
&gt;Parameters make a functor.%token &lt; type1 &gt; Token1
Token2Terminal productions, variants%token &lt; type3 &gt;
Token3returned from lexer.%token NoArgTokenWithout an argument,
e.g. keywords or symbols.%nonassoc Token1This token cannot be stacked
without parentheses.%left Token3Associates to left,%right Token2to
right.%type &lt; type4 &gt; rule1Type of the action of the rule.%start
&lt; type5 &gt; rule2The entry point of the grammar.%%Separate out the
rules part.%inline rule1 (id1, …, inN) :Inlined rules can propagate
priorities.|production1 { action1 }If production matches, perform
action.|production2 |production3Several productions{ action2 }with the
same action.</p>
<p>%public rule2 :Visible in other files of the grammar. | production4 {
action4 }%public rule3 :Override precedence of production5 to that of
productions | production5 { action5 } %prec Token1ending with
Token1%%The separations are needed even if the sections are
empty.trailerOCaml code put at the end of generated source.</p></li>
<li><p>Header, actions and trailer are OCaml code.</p></li>
<li><p>Comments are (* … <em>) in OCaml code, /</em> … */ or // …
outisde</p></li>
<li><p>Rules can optionally be separated by ;</p></li>
<li><p>%parameter turns the <strong>whole</strong> resulting grammar
into a functor, multiple parameters are allowed. The parameters are
visible in %{…%}.</p></li>
<li><p>Terminal symbols Token1 and Token2 are both variants with
argument of type type1, called their <em>semantic value</em>.</p></li>
<li><p><code>rule1</code>… <code>ruleN</code> must be lower-case
identifiers.</p></li>
<li><p>Parameters <code>id1</code>… <code>idN</code> can be lower- or
upper-case.</p></li>
<li><p>Priorities, i.e. precedence, are declared implicitly: %nonassoc,
%left, %right list tokens in increasing priority (Token2 has highest
precedence).</p>
<ul>
<li>Higher precedence = a rule is applied even when tokens so far could
be part of the other rule.</li>
<li>Precedence of a production comes from its rightmost terminal.</li>
<li>%left/%right means left/right associativity: the rule will/won’t be
applied if the “other” rule is the same production.</li>
</ul></li>
<li><p>%start symbols become names of functions exported in the
<code>.mli</code> file to invoke the parser. They are automatically
%public.</p></li>
<li><p>%public rules can even be defined over multiple files, with
productions joined by |.</p></li>
<li><p>The syntax of productions, i.e. patterns, each line shows one
aspect, they can be combined:</p>
<p><code>rule2</code> Token1 <code>rule3</code>Match tokens in sequence
with Token1 in the middle.a=rule2 t=Token3Name semantic values produced
by rules/tokens.rule2; Token3Parts of pattern can be separated by
semicolon.rule1(arg1,…,argN)Use a rule that takes
arguments.<code>rule2</code>?Shorthand for
option(rule2)<code>rule2</code>+Shorthand for
nonemptylist(rule2)rule2*Shorthand for list(rule2)</p></li>
<li><p>Always-visible “standard library” – most of rules copied
below:</p>
<p>%public option(X): /* nothing */ { None }| x = X { Some x }%public
%inline pair(X, Y): x = X; y = Y { (x, y) }</p>
<p>%public %inline separatedpair(X, sep, Y): x = X; sep; y = Y { (x, y)
}%public %inline delimited(opening, X, closing): opening; x = X;
closing<br />
{ x }%public list(X): /* nothing */ { [] }| x = X; xs = list(X) { x ::
xs }%public nonemptylist(X): x = X { [ x ] }| x = X; xs =
nonemptylist(X) { x :: xs }%public %inline separatedlist(separator,
X):<br />
xs = loption(separatednonemptylist(separator, X)) { xs }</p>
<p>%public separatednonemptylist(separator, X): x = X { [ x ] }| x = X;
separator; xs = separatednonemptylist(separator, X) { x :: xs }</p></li>
<li><p>Only <em>left-recursive</em> rules are truly tail-recursive, as
in:</p>
<p>declarations:| { [] }| ds = declarations; option(COMMA); d =
declaration { d :: ds }</p>
<ul>
<li>This is opposite to code expressions (or <em>recursive descent
parsers</em>), i.e. if both OK, first rather than last invocation should
be recursive.</li>
</ul></li>
<li><p>Invocations can be nested in arguments, e.g.:</p>
<p>plist(X):| xs = loption(Like <code>option</code>, but returns a
list.<br />
delimited(LPAREN, separatednonemptylist(COMMA, X),<br />
RPAREN)) { xs }</p></li>
<li><p>Higher-order parameters are allowed.</p>
<p>procedure(list):| PROCEDURE ID list(formal) SEMICOLON block SEMICOLON
{…}</p></li>
<li><p>Example where inlining is required (besides being an
optimization)</p>
<p>%token &lt; int &gt; INT%token PLUS TIMES%left PLUS%left
TIMESMultiplication has higher priority.%%expression:| i = INT { i
}<span class="math inline">\swarrow</span> Without inlining, would not
distinguish priorities.| e = expression; o = op; f = expression { o e f
}%inline op:Inline operator – generate corresponding rules.| PLUS { ( +
) }| TIMES { ( * ) }</p></li>
<li><p>Menhir is an <span class="math inline">\operatorname{LR}
(1)</span> parser generator, i.e. it fails for grammars where looking
one token ahead, together with precedences, is insufficient to determine
whether a rule applies.</p>
<ul>
<li>In particular, only unambiguous grammars.</li>
</ul></li>
<li><p>Although <span class="math inline">\operatorname{LR} (1)</span>
grammars are a small subset of <em>context free grammars</em>, the
semantic actions can depend on context: actions can be functions that
take some form of context as input.</p></li>
<li><p>Positions are available in actions via keywords <span
class="math inline">`startpos`(`x`)
and</span><code>endpos</code>(<code>x</code>) where <code>x</code> is
name given to part of pattern.</p>
<ul>
<li>Do not use the Parsing module from OCaml standard library.</li>
</ul></li>
</ul>
<h3 id="example-parsing-arithmetic-expressions">6.2.1 Example: parsing
arithmetic expressions</h3>
<ul>
<li><p>Example based on a Menhir demo. Due to difficulties with
<code>ocamlbuild</code>, we use option <code>--external-tokens</code> to
provide type token directly rather than having it generated.</p></li>
<li><p>File <code>lexer.mll</code>:</p>
<p>{ type token = | TIMES | RPAREN | PLUS | MINUS | LPAREN<br />
| INT of (int) | EOL | DIV exception Error of string}</p>
<p>rule line = parse| ([‘n’]* ‘n’) as line { line }| eof { exit 0 }and
token = parse| [’ ’ ‘t’] { token lexbuf }| ‘n’ { EOL }| [‘0’-‘9’]+ as i
{ INT (intofstring i) }| ‘+’ { PLUS }| ‘-’ { MINUS }| ’*’ { TIMES }| ‘/’
{ DIV }| ‘(’ { LPAREN }| ‘)’ { RPAREN }| eof { exit 0 }| { raise (Error
(Printf.sprintf “At offset %d: unexpected character.n”
(Lexing.lexemestart lexbuf))) }</p></li>
<li><p>File <code>parser.mly</code>:</p>
<p>%token <int> INTWe still need to define tokens,%token PLUS MINUS
TIMES DIVMenhir does its own checks.%token LPAREN RPAREN%token EOL%left
PLUS MINUS /* lowest precedence <em>/%left TIMES DIV /</em> medium
precedence <em>/%nonassoc UMINUS /</em> highest precedence
<em>/%parameter&lt;Semantics : sig type number val inject: int -&gt;
number val ( + ): number -&gt; number -&gt; number val ( - ): number
-&gt; number -&gt; number val ( </em> ): number -&gt; number -&gt;
number val ( / ): number -&gt; number -&gt; number val ( <span
class="math inline">\sim</span>-): number -&gt; numberend&gt;%start
&lt;Semantics.number&gt; main%{ open Semantics %}</p>
<p>%%main:| e = expr EOL { e }expr:| i = INT { inject i }| LPAREN e =
expr RPAREN { e }| e1 = expr PLUS e2 = expr { e1 + e2 }| e1 = expr MINUS
e2 = expr { e1 - e2 }| e1 = expr TIMES e2 = expr { e1 * e2 }| e1 = expr
DIV e2 = expr { e1 / e2 }| MINUS e = expr %prec UMINUS { - e }</p></li>
<li><p>File <code>calc.ml</code>:</p>
<p>module FloatSemantics = struct type number = float let inject =
floatofint let ( + ) = ( +. ) let ( - ) = ( -. ) let ( * ) = ( *. ) let
( / ) = ( /. ) let (<span class="math inline">\sim</span>- ) = (<span
class="math inline">\sim</span>-. )endmodule FloatParser =
Parser.Make(FloatSemantics)</p>
<p>let () = let stdinbuf = Lexing.fromchannel stdin in while true do let
linebuf = Lexing.fromstring (Lexer.line stdinbuf) in try<br />
Printf.printf “%.1fn%!” (FloatParser.main Lexer.token linebuf)<br />
with | Lexer.Error msg -&gt; Printf.fprintf stderr “%s%!” msg |
FloatParser.Error -&gt; Printf.fprintf stderr “At offset %d: syntax
error.n%!” (Lexing.lexemestart linebuf) done</p></li>
<li><p>Build and run command:</p>
<p><code>ocamlbuild calc.native -use-menhir -menhir "menhir parser.mly --base parser --external-tokens Lexer" --</code></p>
<ul>
<li>Other grammar files can be provided besides
<code>parser.mly</code></li>
<li><code>--base</code> gives the file (without extension) which will
become the module accessed from OCaml</li>
<li><code>--external-tokens</code> provides the OCaml module which
defines the <code>token</code> type</li>
</ul></li>
</ul>
<h3 id="example-a-toy-sentence-grammar">6.2.2 Example: a toy sentence
grammar</h3>
<ul>
<li>Our lexer is a simple limited <em>part-of-speech tagger</em>. Not
re-entrant.</li>
<li>For debugging, we log execution in file <code>log.txt</code>.</li>
<li>File <code>EngLexer.mll</code>:</li>
</ul>
<p>{ type sentence = {Could be in any module visible to EngParser.
subject : string;The actor/actors, i.e. subject noun. action :
string;The action, i.e.  verb. plural : bool;Whether one or multiple
actors. adjs : string list;Characteristics of actor. advs : string
<code>list</code>Characteristics of action. }</p>
<p>type token = | VERB of string | NOUN of string | ADJ of string | ADV
of string | PLURAL | SINGULAR | ADET | THEDET | SOMEDET | THISDET |
THATDET | THESEDET | THOSEDET | COMMACNJ | ANDCNJ | DOTPUNCT let tokstr
= function …Print the token. let adjectives =Recognized adjectives.
[“smart”; “extreme”; “green”; “slow”; “old”; “incredible”; “quiet”;
“diligent”; “mellow”; “new”] let logfile = openout “log.txt”File with
debugging information.let log s = Printf.fprintf logfile “%sn%!” s let
lasttok = ref DOTPUNCTState for better tagging.</p>
<pre><code>(* Token buffer, since single word is sometimes two tokens. *)
let tokbuf = Queue.create ()
let push w =
  log (&quot;lex: &quot; ^ tokstr w);  (* Log lexed token. *)
  lasttok := w;
  Queue.push w tokbuf
exception LexError of string
}
let alphanum = [&#39;0&#39;-&#39;9&#39; &#39;a&#39;-&#39;z&#39; &#39;A&#39;-&#39;Z&#39; &#39;\&#39;&#39; &#39;-&#39;]
rule line = parse  (* For line-based interface. *)
| ([^&#39;\n&#39;]* &#39;\n&#39;) as l { l }
| eof { exit 0 }
and lexword = parse
| [&#39; &#39; &#39;\t&#39;]  (* Skip whitespace. *)
  { lexword lexbuf }
```| &#39;.&#39; { push DOTPUNCT }End of sentence.| &quot;a&quot; 
{ push ADET } | &quot;the&quot; { push THEDET }‘‘Keywords&#39;&#39;.| &quot;some&quot; { push SOMEDET }| 
&quot;this&quot; { push THISDET } | &quot;that&quot; { push THATDET }| &quot;these&quot; { push THESEDET } | 
&quot;those&quot; { push THOSEDET }| &quot;A&quot; { push ADET } | &quot;The&quot; { push THEDET }| &quot;Some&quot; { 
push SOMEDET }| &quot;This&quot; { push THISDET } | &quot;That&quot; { push THATDET }| &quot;These&quot; { 
push THESEDET } | &quot;Those&quot; { push THOSEDET }| &quot;and&quot; { push ANDCNJ }| &#39;,&#39; { push 
COMMACNJ }| (alphanum+ as w) &quot;ly&quot;Adverb is adjective that ends in ‘‘ly&#39;&#39;.{     
 if List.mem w adjectives      then push (ADV w)      else if List.mem (w&quot;le&quot;) 
adjectives      then push (ADV (w&quot;le&quot;))      else (push (NOUN w); push 
SINGULAR)    }

| (alphanum+ as w) &quot;s&quot;Plural noun or singular verb.{      if List.mem w 
adjectives then push (ADJ w)      else match !lasttok with      | THEDET | 
SOMEDET | THESEDET | THOSEDET      | DOTPUNCT | ADJ  -&gt;        push (NOUN 
w); push PLURAL      |  -&gt; push (VERB w); push SINGULAR    }| alphanum+ as 
`w`Noun contexts vs. verb contexts.{      if List.mem w adjectives then push 
(ADJ w)      else match !lasttok with      | ADET | THEDET | SOMEDET | THISDET 
| THATDET      | DOTPUNCT | ADJ  -&gt;        push (NOUN w); push SINGULAR    
  |  -&gt; push (VERB w); push PLURAL    }

|  as w    { raise (LexError (&quot;Unrecognized character &quot;                       
Char.escaped w)) }{  let lexeme lexbuf =The proper interface reads from the 
token buffer.    if Queue.isempty tokbuf then lexword lexbuf;    Queue.pop 
tokbuf}

* File `EngParser.mly`:

%{  open EngLexerSource of the token type and sentence type.%}%token 
&lt;string&gt; VERB NOUN ADJ ADV*Open word classes*.%token PLURAL 
SINGULARNumber marker.%token ADET THEDET SOMEDET THISDET 
THATDET‘‘Keywords&#39;&#39;.%token THESEDET THOSEDET%token COMMACNJ ANDCNJ 
DOTPUNCT%start &lt;EngLexer.sentence&gt; sentenceGrammar entry.%%

%public %inline sep2list(sep1, sep2, X):General purpose.| xs = 
separatednonemptylist(sep1, X) sep2 x=X    { xs @ [x] }We use it for 
‘‘comma-and&#39;&#39; lists:| x=option(X)*smart, quiet **and** diligent.*    { match x 
with None-&gt;[] | Some x-&gt;[x] }singonlydet:How determiners relate to 
number.| ADET | THISDET | THATDET { log &quot;prs: singonlydet&quot; }pluonlydet:| 
THESEDET | THOSEDET { log &quot;prs: pluonlydet&quot; }otherdet:| THEDET | SOMEDET { log 
&quot;prs: otherdet&quot; }np(det):| det adjs=list(ADJ) subject=NOUN    { log &quot;prs: np&quot;; 
adjs, subject }vp(NUM):| advs=separatedlist(ANDCNJ,ADV) action=VERB NUM| 
action=VERB NUM advs=sep2list(COMMACNJ,ANDCNJ,ADV)    { log &quot;prs: vp&quot;; action, 
advs }

sent(det,NUM):Sentence parameterized by number.| adjsub=np(det) NUM 
vbadv=vp(NUM)    { log &quot;prs: sent&quot;;      {subject=snd adjsub; action=fst 
vbadv; plural=false;       adjs=fst adjsub; advs=snd vbadv} 
}vbsent(NUM):Unfortunately, it doesn&#39;t always work…| NUM vbadv=vp(NUM)   
 { log &quot;prs: vbsent&quot;; vbadv }sentence:Sentence, either singular or plural 
number.| s=sent(singonlydet,SINGULAR) DOTPUNCT    { log &quot;prs: sentence1&quot;;      
{s with plural = false} }| s=sent(pluonlydet,PLURAL) DOTPUNCT    { log &quot;prs: 
sentence2&quot;;      {s with plural = true} }

| adjsub=np(otherdet) vbadv=vbsent(SINGULAR) DOTPUNCT    { log &quot;prs: 
sentence3&quot;;Because parser allows only one token look-ahead      {subject=snd 
adjsub; action=fst vbadv; plural=false;       adjs=fst adjsub; advs=snd vbadv} 
}| adjsub=np(otherdet) vbadv=vbsent(PLURAL) DOTPUNCT    { log &quot;prs: 
sentence4&quot;;we need to factor-out the ‘‘common subset&#39;&#39;.      {subject=snd 
adjsub; action=fst vbadv; plural=true;       adjs=fst adjsub; advs=snd vbadv} 
}

* File `Eng.ml` is the same as `calc.ml` from previous example:

```ocaml
open EngLexer
let () =
  let stdinbuf = Lexing.from_channel stdin in
  while true do
    (* Read line by line. *)
    let linebuf = Lexing.from_string (line stdinbuf) in
    try
      (* Run the parser on a single line of input. *)
      let s = EngParser.sentence lexeme linebuf in
      Printf.printf &quot;subject=%s\nplural=%b\nadjs=%s\naction=%s\nadvs=%s\n\n%!&quot;
        s.subject s.plural (String.concat &quot;, &quot; s.adjs)
        s.action (String.concat &quot;, &quot; s.advs)
    with
    | LexError msg -&gt; Printf.fprintf stderr &quot;%s\n%!&quot; msg
    | EngParser.Error -&gt;
      Printf.fprintf stderr &quot;At offset %d: syntax error.\n%!&quot;
        (Lexing.lexeme_start linebuf)
  done</code></pre>
<ul>
<li><p>Build &amp; run command:</p>
<p><code>ocamlbuild Eng.native -use-menhir -menhir "menhir EngParser.mly --base  EngParser --external-tokens EngLexer" --</code></p></li>
</ul>
<h1 id="example-phrase-search">7 Example: Phrase search</h1>
<ul>
<li><p>In lecture 6 we performed keyword search, now we turn to
<em>phrase search</em> i.e. require that given words be consecutive in
the document.</p></li>
<li><p>We start with some English-specific transformations used in
lexer:</p>
<p>let whorpronoun w = w = “where” || w = “what” || w = “who” || w =
“he” || w = “she” || w = “it” || w = “I” || w = “you” || w = “we” || w =
“they”let abridged w1 w2 =Remove shortened forms like <em>I’ll</em> or
<em>press’d</em>. if w2 = “ll” then [w1; “will”] else if w2 = “s” then
if whorpronoun w1 then [w1; “is”] else [“of”; w1] else if w2 = “d” then
[w1”ed”] else if w1 = “o” || w1 = “O” then if w2.[0] = ‘e’ &amp;&amp;
w2.[1] = ‘r’ then [w1”v”w2] else [“of”; w2] else if w2 = “t” then [w1;
“it”] else [w1”’“w2]</p></li>
<li><p>For now we normalize words just by lowercasing, but see exercise
8.</p></li>
<li><p>In lexer we <em>tokenize</em> text: separate words and normalize
them.</p>
<ul>
<li>We also handle simple aspects of <em>XML</em> syntax.</li>
</ul></li>
<li><p>We store the number of each word occurrence, excluding XML
tags.</p></li>
</ul>
<p>{ open IndexParser let word = ref 0 let linebreaks = ref [] let
commentstart = ref Lexing.dummypos let resetasfile lexbuf s =General
purpose lexer function: let pos = lexbuf.Lexing.lexcurrp instart lexing
from a file. lexbuf.Lexing.lexcurrp &lt;- { pos with Lexing.poslnum =
1;<br />
posfname = s; posbol = pos.Lexing.poscnum; }; linebreaks := []; word :=
0 let nextline lexbuf =Old friend. …Besides changing position, remember
a line break. linebreaks := !word :: !<code>linebreaks</code></p>
<p>let parseerrormsg startpos endpos report =General purpose lexer
function:<br />
let clbeg =report a syntax error. startpos.Lexing.poscnum -
startpos.Lexing.posbol in ignore (Format.flushstrformatter ());<br />
Printf.sprintf “File”%s”, lines %d-%d, characters %d-%d: %sn”<br />
startpos.Lexing.posfname startpos.Lexing.poslnum endpos.Lexing.poslnum
clbeg (clbeg+(endpos.Lexing.poscnum - startpos.Lexing.poscnum))<br />
report}let alphanum = [‘0’-‘9’ ‘a’-‘z’ ‘A’-‘Z’]let newline = (‘n’ |
“rn”)let xmlstart = (“<!--" | "<?")let xmlend = ("-->” | “?&gt;”)rule
token = parse | [’ ’ ‘t’] { token lexbuf } | newline { nextline lexbuf;
token lexbuf }</p>
<p>| ‘&lt;’ alphanum+ ‘&gt;’ as <code>w</code>Dedicated token variants
for XML tags.{ OPEN w } | “&lt;/” alphanum+ ‘&gt;’ as w { CLOSE w } |
“’tis” { word := !word+2; WORDS [“it”, !word-1; “is”, !word] } | “‘Tis”
{ word := !word+2; WORDS [“It”, !word-1; “is”, !word] } | “o’clock” {
incr word; WORDS [“o’clock”, !word] } | “O’clock” { incr word; WORDS
[“O’clock”, !word] } | (alphanum+ as w1)’’’ (alphanum+ as w2) { let
words = EngMorph.abridged w1 w2 in let words = List.map (fun w -&gt;
incr word; w, !word) words in WORDS words } | alphanum+ as w { incr
word; WORDS [w, !word] } |”&amp;” { incr word; WORDS [“&amp;”, !word]
}</p>
<p>Dedicated tokens for punctuation:</p>
<pre><code>| [&#39;.&#39; &#39;!&#39; &#39;?&#39;] as p  { SENTENCE (Char.escaped p) }  (* so that it doesn&#39;t break phrases. *)
| &quot;--&quot;      { PUNCT &quot;--&quot; }
| [&#39;,&#39; &#39;:&#39; &#39;\&#39;&#39; &#39;-&#39; &#39;;&#39;] as p      { PUNCT (Char.escaped p) }
| eof { EOF }
| xmlstart
  { commentstart := lexbuf.Lexing.lex_curr_p;
    let s = comment [] lexbuf in
    COMMENT s }
| _
  { let pos = lexbuf.Lexing.lex_curr_p in
    let pos&#39; = {pos with Lexing.pos_cnum = pos.Lexing.pos_cnum + 1} in
    Printf.printf &quot;%s\n%!&quot; (parse_error_msg pos pos&#39; &quot;lexer error&quot;);
    failwith &quot;LEXER ERROR&quot; }

and comment strings = parse
| xmlend      { String.concat &quot;&quot; (List.rev strings) }
| eof
  { let pos = !commentstart in
    let pos&#39; = lexbuf.Lexing.lex_curr_p in
    Printf.printf &quot;%s\n%!&quot; (parse_error_msg pos pos&#39; &quot;lexer error: unclosed comment&quot;);
    failwith &quot;LEXER ERROR&quot; }
| newline
  { nextline lexbuf;
    comment (Lexing.lexeme lexbuf :: strings) lexbuf }
| _
  { comment (Lexing.lexeme lexbuf :: strings) lexbuf }</code></pre>
<ul>
<li>Parsing: the inverted index and the query.</li>
</ul>
<p>type token =| WORDS of (string * int) list| OPEN of string | CLOSE of
string | COMMENT of string| SENTENCE of string | PUNCT of string|
EOF</p>
<p>let invindex update ii lexer lexbuf = let rec aux ii = match lexer
lexbuf with | WORDS ws -&gt; let ws = List.map (fun
(w,p)-&gt;EngMorph.normalize w, p) ws in aux (List.foldleft update ii
ws) | OPEN | CLOSE | SENTENCE | PUNCT | COMMENT -&gt; aux ii<br />
| EOF -&gt; ii in aux ii</p>
<p>let phrase lexer lexbuf = let rec aux words = match lexer lexbuf with
| WORDS ws -&gt; let ws = List.map (fun (w,p)-&gt;EngMorph.normalize w)
ws in aux (List.revappend ws words) | OPEN | CLOSE | SENTENCE | PUNCT |
COMMENT -&gt; aux words | EOF -&gt; List.rev words in aux []</p>
<h3 id="naive-implementation-of-phrase-search">1 Naive implementation of
phrase search</h3>
<ul>
<li>We need <em>postings lists</em> with positions of words rather than
just the document or line of document they belong to.</li>
<li>First approach: association lists and merge postings lists
word-by-word.</li>
</ul>
<p>let update ii (w, p) = try let ps = List.assoc w ii inAdd position to
the postings list of <code>w</code>. (w, p::ps) :: List.removeassoc w ii
with Notfound -&gt; (w, [p])::iilet empty = []let find w ii = List.assoc
w iilet mapv f ii = List.map (fun (k,v)-&gt;k, f v) iilet index file =
let ch = openin file in let lexbuf = Lexing.fromchannel ch in
EngLexer.resetasfile lexbuf file; let ii = IndexParser.invindex update
empty EngLexer.token lexbuf in closein ch;Keep postings lists in
increasing order. mapv List.rev ii, List.rev !EngLexer.linebreakslet
findline linebreaks p =Recover the line in document of a position. let
rec aux line = function | [] -&gt; line<br />
| bp:: when p &lt; bp -&gt; line | ::breaks -&gt; aux (line+1) breaks in
aux 1 linebreakslet search (ii, linebreaks) phrase = let lexbuf =
Lexing.fromstring phrase in EngLexer.resetasfile lexbuf (“search
phrase:”phrase); let phrase = IndexParser.phrase EngLexer.token lexbuf
in let rec aux wpos = functionMerge postings lists for words in query: |
[] -&gt; <code>wpos</code>no more words in query;| <code>w</code>::ws
-&gt;for positions of <code>w</code>, keep those that are next to let
nwpos = find w ii infiltered positions of previous word. aux
(List.filter (fun p-&gt;List.mem (p-1) wpos) nwpos) ws in let wpos =
match phrase with | [] -&gt; []No results for an empty query.<br />
| w::ws -&gt; aux (find w ii) ws in List.map (findline linebreaks)
wposAnswer in terms of document lines.</p>
<p>let shakespeare = index “./shakespeare.xml”let query q = let lines =
search shakespeare q in Printf.printf “%s: lines %sn%!” q (String.concat
“,” (List.map stringofint lines))</p>
<ul>
<li><p>Test: 200 searches of the queries:</p>
<p>[“first witch”; “wherefore art thou”; “captain’s captain”;
“flatter’d”; “of Fulvia”; “that which we call a rose”; “the undiscovered
country”]</p></li>
<li><p>Invocation:
<code>ocamlbuild InvIndex.native -libs unix --</code></p></li>
<li><p>Time: 7.3s</p></li>
</ul>
<h3 id="replace-association-list-with-hash-table">2 Replace association
list with hash table</h3>
<ul>
<li>I recommend using either <em>OCaml Batteries</em> or <em>OCaml
Core</em> – replacement for the standard library. <em>Batteries</em> has
efficient Hashtbl.map (our <code>mapv</code>).</li>
<li>Invocation:
<code>ocamlbuild InvIndex1.native -libs unix --</code></li>
<li>Time: 6.3s</li>
</ul>
<h3 id="replace-naive-merging-with-ordered-merging">3 Replace naive
merging with ordered merging</h3>
<ul>
<li>Postings lists are already ordered.</li>
<li>Invocation:
<code>ocamlbuild InvIndex2.native -libs unix --</code></li>
<li>Time: 2.5s</li>
</ul>
<h3 id="bruteforce-optimization-biword-indexes">4 Bruteforce
optimization: biword indexes</h3>
<ul>
<li><p>Pairs of words are much less frequent than single words so
storing them means less work for postings lists merging.</p></li>
<li><p>Can result in much bigger index size: <span
class="math inline">\min (W^2, N)</span> where <span
class="math inline">W</span> is the number of distinct words and <span
class="math inline">N</span> the total number of words in
documents.</p></li>
<li><p>Invocation that gives us stack backtraces:</p>
<p><code>ocamlbuild InvIndex3.native -cflag -g -libs unix; export OCAMLRUNPARAM="b";  ./InvIndex3.native</code></p></li>
<li><p>Time: 2.4s – disappointing.</p></li>
</ul>
<h2 id="smart-way-information-retrieval-g.v.-cormack-et-al.">7.1 Smart
way: <em>Information Retrieval</em> G.V. Cormack et al.</h2>
<ul>
<li>You should classify your problem and search literature for
state-of-the-art algorithm to solve it.</li>
<li>The algorithm needs a data structure for inverted index that
supports:
<ul>
<li><code>first(w)</code> – first position in documents at which
<code>w</code> appears</li>
<li><code>last(w)</code> – last position of <code>w</code></li>
<li><code>next(w,cp)</code> – first position of <code>w</code> after
position <code>cp</code></li>
<li><code>prev(w,cp)</code> – last position of <code>w</code> before
position <code>cp</code></li>
</ul></li>
<li>We develop <code>next</code> and <code>prev</code> operations in
stages:
<ul>
<li>First, a naive (but FP) approach using the Set module of OCaml.
<ul>
<li>We could use our balanced binary search tree implementation to avoid
the overhead due to limitations of Set API.</li>
</ul></li>
<li>Then, <em>binary search</em> based on arrays.</li>
<li>Imperative linear search.</li>
<li>Imperative <em>galloping search</em> optimization of binary
search.</li>
</ul></li>
</ul>
<h3 id="the-phrase-search-algorithm">7.1.1 The phrase search
algorithm</h3>
<ul>
<li>During search we maintain <em>current position</em> <code>cp</code>
of last found word or phrase.</li>
<li>Algorithm is almost purely functional, we use Not_found exception
instead of option type for convenience.</li>
</ul>
<p>let rec nextphrase ii phrase cp =Return the beginning and end
position let rec aux cp = functionof occurrence of <code>phrase</code>
after position <code>cp</code>. | [] -&gt; raise NotfoundEmpty phrase
counts as not occurring. | [w] -&gt;Single or last word of phrase has
the same let np = next ii w cp in np, <code>np</code>beg. and end
position.| w::ws -&gt;After locating the endp. move back. let np, fp =
aux (next ii w cp) ws in prev ii w np, fp inIf distance is this small,
let np, fp = aux cp phrase inwords are consecutive. if fp - np =
List.length phrase - 1 then np, fp else nextphrase ii phrase fp</p>
<p>let search (ii, linebreaks) phrase = let lexbuf = Lexing.fromstring
phrase in EngLexer.resetasfile lexbuf (“search phrase:”phrase); let
phrase = IndexParser.phrase EngLexer.token lexbuf in let rec aux cp =
tryFind all occurrences of the phrase. let np, fp = nextphrase ii phrase
cp in<br />
np :: aux fp with Notfound -&gt; [] inMoved past last occurrence.<br />
List.map (findline linebreaks) (aux (-1))</p>
<h3 id="naive-but-purely-functional-inverted-index">7.1.2 Naive but
purely functional inverted index</h3>
<p>module S = Set.Make(struct type t=int let compare i j = i-j end)let
update ii (w, p) = (try let ps = Hashtbl.find ii w in Hashtbl.replace ii
w (S.add p ps) with Notfound -&gt; Hashtbl.add ii w (S.singleton p));
iilet first ii w = S.minelt (find w ii)The functions raise Not_foundlet
last ii w = S.maxelt (find w ii)whenever such position would not
exist.let prev ii w cp = let ps = find w ii inSplit the set into
elements let smaller, , = S.split cp ps insmaller and bigger than
<code>cp</code>. S.maxelt smallerlet next ii w cp = let ps = find w ii
in let , , bigger = S.split cp ps in S.minelt bigger</p>
<ul>
<li>Invocation:
<code>ocamlbuild InvIndex4.native -libs unix --</code></li>
<li>Time: 3.3s – would be better without the overhead of S.split.</li>
</ul>
<h3 id="binary-search-based-inverted-index">7.1.3 Binary search based
inverted index</h3>
<p>let prev ii w cp = let ps = find w ii in let rec aux b e =We
implement binary search separately for <code>prev</code> if e-b &lt;= 1
then ps.(b)to make sure here we return less than <code>cp</code> else
let m = (b+e)/2 in if ps.(m) &lt; cp then <code>aux m e</code>else aux b
m in let l = Array.length ps in if l = 0 || ps.(0) &gt;= cp then raise
Notfound else aux 0 (l-1)let next ii w cp = let ps = find w ii in let
rec aux b e = if e-b &lt;= 1 then ps.(e)and here more than
<code>cp</code>. else let m = (b+e)/2 in if ps.(m) &lt;= cp then aux m e
else aux b m in let l = Array.length ps in if l = 0 || ps.(l-1) &lt;= cp
then raise Notfound else aux 0 (l-1)</p>
<ul>
<li>File: <code>InvIndex5.ml</code>. Time: 2.4s</li>
</ul>
<h3 id="imperative-linear-scan">7.1.4 Imperative, linear scan</h3>
<p>let prev ii w cp = let cw,ps = find w ii inFor each word we add a
cell with last visited occurrence. let l = Array.length ps in if l = 0
|| ps.(0) &gt;= cp then raise Notfound else if ps.(l-1) &lt; cp then cw
:= l-1 else (Reset pointer if current position is not ‘‘ahead’’ of it.
if !cw &lt; l-1 &amp;&amp; ps.(!cw+1) &lt; cp then cw := l-1;Otherwise
scan while ps.(!cw) &gt;= cp do decr cw donestarting from last visited.
); ps.(!cw)let next ii w cp = let cw,ps = find w ii in let l =
Array.length ps in if l = 0 || ps.(l-1) &lt;= cp then raise Notfound
else if ps.(0) &gt; cp then cw := 0 else (Reset pointer if current
position is not ahead of it. if !cw &gt; 0 &amp;&amp; ps.(!cw-1) &gt; cp
then cw := 0; while ps.(!cw) &lt;= cp do incr cw done ); ps.(!cw)</p>
<ul>
<li><p>End of <code>index</code>-building function:</p>
<p>mapv (fun ps-&gt;ref 0, Array.oflist (List.rev ps)) ii,…</p></li>
<li><p>File: <code>InvIndex6.ml</code></p></li>
<li><p>Time: 2.8s</p></li>
</ul>
<h3 id="imperative-galloping-search">7.1.5 Imperative, galloping
search</h3>
<p>let next ii w cp = let cw,ps = find w ii in let l = Array.length ps
in if l = 0 || ps.(l-1) &lt;= cp then raise Notfound; let rec jump (b,e
as bounds) j =Locate the interval with <code>cp</code> inside. if e &lt;
l-1 &amp;&amp; ps.(e) &lt;= cp then jump (e,e+j) (2*j) else bounds in
let rec binse b e =Binary search over that interval. if e-b &lt;= 1 then
e else let m = (b+e)/2 in if ps.(m) &lt;= cp then binse m e else binse b
m in if ps.(0) &gt; cp then cw := 0 else ( let b =The invariant is that
ps.(b) &lt;= <code>cp</code>. if !cw &gt; 0 &amp;&amp; ps.(!cw-1) &lt;=
cp then !cw-1 else 0 in let b,e = jump (b,b+1) 2 inLocate interval
starting near !<code>cw</code>. let e = if e &gt; l-1 then l-1 else e in
cw := binse b e ); ps.(!cw)</p>
<ul>
<li><code>prev</code> is symmetric to <code>next</code>.</li>
<li>File: <code>InvIndex7.ml</code></li>
<li>Time: 2.4s – minimal speedup in our simple test case.</li>
</ul>
<p>Exercise 1.</p>
<p>(Exercise 6.1 from <em>“Modern Compiler Implementation in ML”</em> by
Andrew W. Appel.) Using the <code>ocamlopt</code> compiler with
parameter <code>-S</code> and other parameters turning on all possible
compiler optimizations, evaluate the compiled programs by these
criteria:</p>
<ol type="1">
<li>Are local variables kept in registers? Show on an example.</li>
<li>If local variable <code>b</code> is live across more than one
procedure call, is it kept in a callee-save register? Explain how it
would speed up the program:let f a = let b = a+1 in let c = g () in let
d = h c in b+c</li>
<li>If local variable <code>x</code> is never live across a procedure
call, is it properly kept in a caller-save register? Explain how doing
thes would speed up the program:let h y = let x = y+1 in let z = f y in
f z</li>
</ol>
<p>Exercise 2.</p>
<p>As above, verify whether escaping variables of a function are kept in
a closure corresponding to the function, or in closures corresponding to
the local, i.e. nested, functions that are returned from the function
(or assigned to a mutable field).</p>
<p>Exercise 3.</p>
<p>As above, verify that OCaml compiler performs <em>inline
expansion</em> of small functions. Check whether the compiler can
inline, or specialize (produce a local function to help inlining),
recursive functions.</p>
<p>Exercise 4.</p>
<p>Write a “<code>.mll</code> program” that anonymizes, or masks, text.
That is, it replaces identified probable full names (of persons,
companies etc.) with fresh shorthands <em>Mr. A</em>, <em>Ms. B</em>, or
<em>Mr./Ms. C</em> when the gender cannot be easily determined. The same
(full) name should be replaced with the same letter.</p>
<ul>
<li>Do only a very rough job of course, starting with recognizing two or
more capitalized words in a row.</li>
</ul>
<p>Exercise 5.</p>
<p>In the lexer EngLexer we call function <code>abridged</code> from the
module EngMorph. Inline the operation of <code>abridged</code> into the
lexer by adding a new regular expression pattern for each if clause.
Assess the speedup on the <em>Shakespeare</em> corpus and the
readability and either keep the change or revert it.</p>
<p>Exercise 6.</p>
<p>Make the lexer re-entrant for the second Menhir example (toy English
grammar parser).</p>
<p>Exercise 7.</p>
<p>Make the determiner optional in the toy English grammar.</p>
<ol type="1">
<li>* Can you come up with a factorization that would avoid having two
more productions in total?</li>
</ol>
<p>Exercise 8.</p>
<p>Integrate into the <em>Phrase search</em> example, the <em>Porter
Stemmer</em> whose source is in the <code>stemmer.ml</code> file.</p>
<p>Exercise 9.</p>
<p>Revisit the search engine example from lecture 6.</p>
<ol type="1">
<li>Perform optimization of data structure, i.e. replace association
lists with hash tables.</li>
<li>Optimize the algorithm: perform <em>query optimization</em>. Measure
time gains for selected queries.</li>
<li>For bonus points, as time and interest permits, extend the query
language with <em>OR</em> and <em>NOT</em> connectives, in addition to
<em>AND</em>.</li>
<li>* Extend query optimization to the query language with <em>AND</em>,
<em>OR</em> and <em>NOT</em> connectives.</li>
</ol>
<p>Exercise 10.</p>
<p>Write an XML parser tailored to the <code>shakespeare.xml</code>
corpus provided with the phrase search example. Modify the phrase search
engine to provide detailed information for each found location,
e.g. which play and who speaks the phrase.</p>
<p>Lecture 10: FRP</p>
<p>Zippers. Functional Reactive Programming. GUIs.</p>
<p>*‘‘Zipper’‘* in <em>Haskell Wikibook</em> and <em>‘‘The Zipper’’</em>
by Gerard Huet <em>‘‘How <code>froc</code> works’’</em> by Jacob Donham
<em>‘‘The Haskell School of Expression’’</em> by Paul Hudak
‘‘<em>Deprecating the Observer Pattern with
<code>Scala.React</code></em>’’ by Ingo Maier, Martin Odersky</p>
<p>If you see any error on the slides, let me know!</p>
<h1 id="zippers">1 Zippers</h1>
<ul>
<li>We would like to keep track of a position in a data structure:
easily access and modify it at that location, easily move the location
around.</li>
<li>Recall how we have defined <em>context types</em> for datatypes:
types that represent a data structure with one of elements stored in it
missing.</li>
</ul>
<div class="sourceCode" id="cb76"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree = Tip | Node <span class="kw">of</span> <span class="dt">int</span> * btree * btree</span></code></pre></div>
<p><span class="math display"> \begin{matrix}
  T &amp; = &amp; 1 + xT^2\\\\\\
  \frac{\partial T}{\partial x} &amp; = &amp; 0 + T^2 + 2 xT
\frac{\partial
  T}{\partial x} = TT + 2 xT \frac{\partial T}{\partial x}
\end{matrix} </span></p>
<div class="sourceCode" id="cb77"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree_dir = LeftBranch | RightBranch</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree_deriv =</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>  | Here <span class="kw">of</span> btree * btree</span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>  | Below <span class="kw">of</span> btree_dir * <span class="dt">int</span> * btree * btree_deriv</span></code></pre></div>
<ul>
<li><p><strong>Location = context + subtree</strong>! But there’s a
problem above.</p></li>
<li><p>But we cannot easily move the location if Here is at the
bottom.</p>
<p>The part closest to the location should be on top.</p></li>
<li><p>Revisiting equations for trees and lists:</p>
<p><span class="math display"> \begin{matrix}
T &amp; = &amp; 1 + xT^2\\\\\\
\frac{\partial T}{\partial x} &amp; = &amp; 0 + T^2 + 2 xT
\frac{\partial
T}{\partial x}\\\\\\
\frac{\partial T}{\partial x} &amp; = &amp; \frac{T^2}{1 - 2 xT}\\\\\\
L (y) &amp; = &amp; 1 + yL (y)\\\\\\
L (y) &amp; = &amp; \frac{1}{1 - y}\\\\\\
\frac{\partial T}{\partial x} &amp; = &amp; T^2 L (2 xT) \end{matrix}
</span></p>
<p>I.e. the context can be stored as a list with the root as the last
node.</p>
<ul>
<li>Of course it doesn’t matter whether we use built-in lists, or a type
with Above and Root variants.</li>
</ul></li>
<li><p>Contexts of subtrees are more useful than of single elements.</p>
<p>type ’a tree = Tip | Node of ’a tree * ’a * ’a treetype treedir =
Leftbr | Rightbrtype ’a context = (treedir * ’a * ’a tree) listtype ’a
location = {sub: ’a tree; ctx: ’a context}let access {sub} = sublet
change {ctx} sub = {sub; ctx}let modify f {sub; ctx} = {sub=f sub;
ctx}</p></li>
<li><p>We can imagine a location as a rooted tree, which is hanging
pinned at one of its nodes. Let’s look at pictures in<a
href="http://en.wikibooks.org/wiki/Haskell/Zippers">http://en.wikibooks.org/wiki/Haskell/Zippers</a></p></li>
<li><p>Moving around:</p>
<p>let ascend loc = match loc.ctx with | [] -&gt; <code>loc</code>Or
raise exception.| (Leftbr, n, l) :: upctx -&gt; {sub=Node (l, n,
loc.sub); ctx=upctx} | (Rightbr, n, r) :: upctx -&gt; {sub=Node
(loc.sub, n, r); ctx=upctx}let descleft loc = match loc.sub with | Tip
-&gt; <code>loc</code>Or raise exception.| Node (l, n, r) -&gt; {sub=l;
ctx=(Rightbr, n, r)::loc.ctx}let descright loc = match loc.sub with |
Tip -&gt; <code>loc</code>Or raise exception.| Node (l, n, r) -&gt;
{sub=r; ctx=(Leftbr, n, l)::loc.ctx}</p></li>
<li><p>Following <em>The Zipper</em>, let’s look at a tree with
arbitrary number of branches.</p></li>
</ul>
<p>type doc = Text of string | Line | Group of doc listtype context =
(doc list * doc list) listtype location = {sub: doc; ctx: context}</p>
<p>let goup loc = match loc.ctx with | [] -&gt; invalidarg “goup: at
top” | (left, right) :: upctx -&gt;Previous subdocument and its
siblings.<br />
{sub=Group (List.rev left @ loc.sub::right); ctx=upctx}let goleft loc =
match loc.ctx with | [] -&gt; invalidarg “goleft: at top” | (l::left,
right) :: upctx -&gt;Left sibling of previous subdocument. {sub=l;
ctx=(left, loc.sub::right) :: upctx} | ([], ) :: -&gt; invalidarg
“goleft: at first”</p>
<p>let goright loc = match loc.ctx with | [] -&gt; invalidarg “goright:
at top” | (left, r::right) :: upctx -&gt; {sub=r; ctx=(loc.sub::left,
right) :: upctx} | (, []) :: -&gt; invalidarg “goright: at last”let
godown loc =Go to the first (i.e. leftmost) subdocument. match loc.sub
with | Text -&gt; invalidarg “godown: at text” | Line -&gt; invalidarg
“godown: at line” | Group [] -&gt; invalidarg “godown: at empty” | Group
(doc::docs) -&gt; {sub=doc; ctx=([], docs)::loc.ctx}</p>
<h2 id="example-context-rewriting">1.1 Example: Context rewriting</h2>
<ul>
<li>Our friend working on the string theory asked us for help with
simplifying his equations.</li>
<li>The task is to pull out particular subexpressions as far to the left
as we can, but changing the whole expression as little as possible.</li>
<li>We can illustrate our algorithm using mathematical notation. Let:
<ul>
<li><span class="math inline">x</span> be the thing we pull out</li>
<li><span class="math inline">C [e]</span> and <span
class="math inline">D [e]</span> be big expressions with subexpression
<span class="math inline">e</span></li>
<li>operator <span class="math inline">\circ</span> stand for one of:
<span class="math inline">\ast, +</span></li>
</ul>
<span class="math display"> \begin{matrix}
D [(C [x] \circ e_{1}) \circ e_{2}] &amp; \Rightarrow &amp; D [C [x]
\circ (e_{1}
\circ e_{2})]\\\\\\
D [e_{2} \circ (C [x] \circ e_{1})] &amp; \Rightarrow &amp; D [C [x]
\circ (e_{1}
\circ e_{2})]\\\\\\
D [(C [x] + e_{1}) e_{2}] &amp; \Rightarrow &amp; D [C [x] e_{2} + e_{1}
e_{2}]\\\\\\
D [e_{2}  (C [x] + e_{1})] &amp; \Rightarrow &amp; D [C [x] e_{2} +
e_{1}
e_{2}]\\\\\\
D [e \circ C [x]] &amp; \Rightarrow &amp; D [C [x] \circ e] \end{matrix}
</span></li>
<li>First the groundwork:</li>
</ul>
<p>type op = Add | Multype expr = Val of int | Var of string | App of
expr<em>op</em>exprtype exprdir = Leftarg | Rightargtype context =
(exprdir * op * expr) listtype location = {sub: expr; ctx: context}</p>
<ul>
<li>Locate the subexpression described by <code>p</code>.</li>
</ul>
<p>let rec findaux p e = if p e then Some (e, []) else match e with |
Val | Var -&gt; None | App (l, op, r) -&gt; match findaux p l with |
Some (sub, upctx) -&gt; Some (sub, (Rightarg, op, r)::upctx) | None
-&gt; match findaux p r with | Some (sub, upctx) -&gt; Some (sub,
(Leftarg, op, l)::upctx) | None -&gt; None</p>
<p>let find p e = match findaux p e with | None -&gt; None | Some (sub,
ctx) -&gt; Some {sub; ctx=List.rev ctx}</p>
<ul>
<li>Pull-out the located subexpression.</li>
</ul>
<p>let rec pullout loc = match loc.ctx with | [] -&gt;
<code>loc</code>Done.| (Leftarg, op, l) :: upctx -&gt;<span
class="math inline">D [e \circ C [x]] \Rightarrow D [C [x] \circ
e]</span> pullout {loc with ctx=(Rightarg, op, l) :: upctx} | (Rightarg,
op1, e1) :: (, op2, e2) :: upctx when op1 = op2 -&gt;<span
class="math inline">D [(C [x] \circ e_{1}) \circ e_{2}] / D [e_{2} \circ
(C [x] \circ e_{1})] \Rightarrow D [C [x] \circ (e_{1} \circ
e_{2})]</span> pullout {loc with ctx=(Rightarg, op1, App(e1,op1,e2)) ::
upctx} | (Rightarg, Add, e1) :: (, Mul, e2) :: upctx -&gt; pullout {loc
with ctx=<span class="math inline">D [(C [x] + e_{1}) e_{2}] / D
[e_{2}  (C [x] + e_{1})] \Rightarrow D [C [x] e_{2} + e_{1}
e_{2}]</span> (Rightarg, Mul, e2) :: (Rightarg, Add, App(e1,Mul,e2)) ::
upctx} | (Rightarg, op, r)::upctx -&gt;Move up the context. pullout
{sub=App(loc.sub, op, r); ctx=upctx}</p>
<ul>
<li><p>Since operators are commutative, we ignore the direction for the
second piece of context above.</p></li>
<li><p>Test:</p>
<p>let (+) a b = App (a, Add, b)let ( * ) a b = App (a, Mul, b)let (!) a
= Val alet x = Var “x”let y = Var “y”let ex = !5 + y * (!7 + x) * (!3 +
y)let loc = find (fun e-&gt;e=x) exlet sol = match loc with | None -&gt;
raise Notfound | Some loc -&gt; pullout loc# let = expr2str sol;;- :
string = “(((x<em>y)</em>(3+y))+(((7<em>y)</em>(3+y))+5))”</p></li>
<li><p>For best results we can iterate the <code>pull_out</code>
function until fixpoint.</p></li>
</ul>
<h1 id="adaptive-programming-aka.incremental-computing">2 Adaptive
Programming aka.Incremental Computing</h1>
<ul>
<li>Zippers are somewhat unnatural.</li>
<li>Once we change the data-structure, it is difficult to propagate the
changes – need to rewrite all algorithms to work on context
changes.</li>
<li>In <em>Adaptive Programming</em>, aka. <em>incremental
computation</em>, aka. <em>self-adjusting computation</em>, we write
programs in straightforward functional manner, but can later modify any
data causing only minimal amount of work required to update
results.</li>
<li>The functional description of computation is within a monad.</li>
<li>We can change monadic values – e.g. parts of input – from outside
and propagate the changes.
<ul>
<li>In the <em>Froc</em> library, the monadic <em>changeables</em> are
<code>'a Froc_sa.t</code>, and the ability to modify them is exposed by
type <code>'a Froc_sa.u</code> – the <em>writeables</em>.</li>
</ul></li>
</ul>
<h3 id="dependency-graphs-explained-by-jake-dunham">1 Dependency Graphs
(explained by Jake Dunham)</h3>
<ul>
<li><p>The monadic value <code>'a changeable</code> will be the
<em>dependency graph</em> of the computation of the represented value
<code>'a</code>.</p></li>
<li><p>Let’s look at the example in <em>“How froc works”</em>,
representing computation</p>
<p>let u = v / w + x * y + z <img src="how-froc-works-a.png" /></p></li>
<li><p>and its state with partial results memoized</p>
<p><img src="how-froc-works-b.png" /></p>
<p>where <code>n0, n1, n2</code> are interior nodes of
computation.</p></li>
<li><p>Modify inputs <code>v</code> and <code>z</code>
simultaneously</p>
<p><img src="how-froc-works-c.png" /></p></li>
<li><p>We need to update <code>n2</code> before <code>u</code>.</p></li>
<li><p>We use the gray numbers – the order of computation – for the
order of update of <code>n0</code>, <code>n2</code> and
<code>u</code>.</p></li>
<li><p>Similarly to <code>parallel</code> in the concurrency monad, we
provide <code>bind2</code>, <code>bind3</code>, … – and corresponding
<code>lift2</code>, <code>lift3</code>, … – to introduce nodes with
several children.</p>
<p>let n0 = bind2 v w (fun v w -&gt; return (v / w)) let n1 = bind2 x y
(fun x y -&gt; return (x * y)) let n2 = bind2 n0 n1 (fun n0 n1 -&gt;
return (n0 + n1)) let u = bind2 n2 z (fun n2 z -&gt; return (n2 +
z))</p></li>
<li><p>Do-notation is not necessary to have readable expressions.</p>
<p>let (/) = lift2 (/) let ( * ) = lift2 ( * ) let (+) = lift2 (+) let u
= v / w + x * y + z</p></li>
<li><p>As in other monads, we can decrease overhead by using bigger
chunks.</p>
<p>let n0 = blift2 v w (fun v w -&gt; v / w) let n2 = blift3 n0 x y (fun
n0 x y -&gt; n0 + x * y) let u = blift2 n2 z (fun n2 z -&gt; n2 +
z)</p></li>
<li><p>We have a problem if we recompute all nodes by order of
computation.</p>
<p>let b = x &gt;&gt;= fun x -&gt; return (x = 0) let n0 = x &gt;&gt;=
fun x -&gt; return (100 / x) let y = bind2 b n0 (fun b n0-&gt;if b then
return 0 else n0)</p>
<p><img src="how-froc-works-d.png" /></p></li>
<li><p>Rather than a signle “time” stamp, we store intervals: begin and
end of computation</p>
<p><img src="how-froc-works-e.png" /></p></li>
<li><p>When updating the <code>y</code> node, we first detach nodes in
range 4-9 from the graph.</p>
<ul>
<li>Computing the expression will re-attach the nodes as needed.</li>
</ul></li>
<li><p>When value of <code>b</code> does not change, then we skip
updating <code>y</code> and proceed with updating <code>n0</code>.</p>
<ul>
<li>I.e. no children of <code>y</code> with time stamp smaller than
<code>y</code> change.</li>
<li>The value of <code>y</code> is a link to the value of
<code>n0</code> so it will change anyway.</li>
</ul></li>
<li><p>We need memoization to re-attach the same nodes in case they
don’t need updating.</p>
<ul>
<li>Are they up-to-date? Run updating past the node’s timestamp
range.</li>
</ul></li>
</ul>
<h2 id="example-using-froc">2.1 Example using <em>Froc</em></h2>
<ul>
<li><p>Download <em>Froc</em> from <a
href="https://github.com/jaked/froc/downloads">https://github.com/jaked/froc/downloads</a></p></li>
<li><p>Install for example with</p>
<p><code>cd froc-0.2a; ./configure; make all; sudo make install</code></p></li>
<li><p>Frocsa (for <em>self-adjusting</em>) exports the monadic type
<code>t</code> for changeable computation, and a handle type
<code>u</code> for updating the computation.</p></li>
<li><p>open Frocsatype tree =Binary tree with nodes storing their screen
location.| Leaf of int * intWe will grow the tree| Node of int * int *
tree t * tree tby modifying subtrees.</p></li>
<li><p>let rec display px py t =Displaying the tree is changeable
effect: match t withwhenever the tree changes, displaying will be
updated. | Leaf (x,</p>
<ol start="25" type="a">
<li>-&gt;Only new nodes will be drawn after update. return<br />
(Graphics.drawpolyline [|px,py;x,y|];We return Graphics.drawcircle x y
3)a throwaway value. | Node (x, y, l, r) -&gt; return
(Graphics.drawpolyline [|px,py;x,y|]) &gt;&gt;= fun -&gt; l &gt;&gt;=
display x y &gt;&gt;= fun -&gt; r &gt;&gt;= display x y</li>
</ol></li>
<li><p>let growat (x, depth, upd) = let xl = x-f2i
(width<em>.(2.0<strong>(<span class="math inline">\sim</span>-.(i2f
(depth+1))))) in let l, updl = changeable (Leaf (xl, (depth+1)<em>20))
in<br />
let xr = x+f2i (width</em>.(2.0</strong>(<span
class="math inline">\sim</span>-.(i2f (depth+1))))) in let r, updr =
changeable (Leaf (xr, (depth+1)</em>20)) in write upd (Node (x,
depth*20, l, r));Update the old leaf propagate ();and keep handles to
make future updates. [xl, depth+1, updl; xr, depth+1, updr]</p></li>
<li><p>let rec loop t subts steps = if steps &lt;= 0 then () else loop t
(concatmap growat subts) (steps-1)let incremental steps () =<br />
Graphics.opengraph ” 1024x600”; let t, u = changeable (Leaf (512, 20))
in<br />
let d = t &gt;&gt;= display (f2i (width /. 2.)) 0 inDisplay once loop t
[512, 1, u] steps;– new nodes will be drawn automatically.<br />
Graphics.closegraph ();;</p></li>
<li><p>Compare with rebuilding and redrawing the whole tree.
Unfortunately the overhead of incremental computation is quite large.
Byte code run:</p>
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
<p>depth</p>
</td>
<td style="text-align: left">
<p>12</p>
</td>
<td>
<p>13</p>
</td>
<td>
<p>14</p>
</td>
<td>
<p>15</p>
</td>
<td>
<p>16</p>
</td>
<td>
<p>17</p>
</td>
<td>
<p>18</p>
</td>
<td>
<p>19</p>
</td>
<td>
<p>20</p>
</td>
</tr>
<tr>
<td>
<p>incremental</p>
</td>
<td>
<p>0.66s</p>
</td>
<td>
<p>1s</p>
</td>
<td>
<p>2.2s</p>
</td>
<td>
<p>4.4s</p>
</td>
<td>
<p>9.3s</p>
</td>
<td>
<p>21s</p>
</td>
<td>
<p>50s</p>
</td>
<td>
<p>140s</p>
</td>
<td>
<p>255s</p>
</td>
</tr>
<tr>
<td style="text-align: left">
<p>rebuilding</p>
</td>
<td>
<p>0.5s</p>
</td>
<td>
<p>0.63s</p>
</td>
<td>
<p>1.3s</p>
</td>
<td>
<p>3s</p>
</td>
<td>
<p>5.3s</p>
</td>
<td>
<p>13s</p>
</td>
<td>
<p>39s</p>
</td>
<td>
<p>190s</p>
</td>
<td>
</td>
</tr>
</tbody>
</table></li>
</ul>
<h1 id="functional-reactive-programming">3 Functional Reactive
Programming</h1>
<ul>
<li><p>FRP is an attempt to declaratively deal with time.</p></li>
<li><p><em>Behaviors</em> are functions of time.</p>
<ul>
<li>A behavior has a specific value in each instant.</li>
</ul></li>
<li><p><em>Events</em> are sets of (time, value) pairs.</p>
<ul>
<li>I.e. they are organised into streams of actions.</li>
</ul></li>
<li><p>Two problems</p>
<ul>
<li>Behaviors / events are well defined when they don’t depend on
future</li>
<li>Efficiency: minimize overhead</li>
</ul></li>
<li><p>FRP is <em>synchronous</em>: it is possible to set up for events
to happen at the same time, and it is <em>continuous</em>: behaviors can
have details at arbitrary time resolution.</p>
<ul>
<li>Although the results are <em>sampled</em>, there’s no fixed
(minimal) time step for specifying behavior.</li>
<li>Asynchrony refers to various ideas so ask what people mean.</li>
</ul></li>
<li><p>Ideally we would define:</p>
<p>type time = floattype ’a behavior = time -&gt; ’aArbitrary
function.type ’a event = (’a, time) streamIncreasing time
instants.</p></li>
<li><p>Forcing a lazy list (stream) of events would wait till an event
arrives.</p></li>
<li><p>But behaviors need to react to external events:</p>
<p>type useraction =| Key of char * bool| Button of int * int * bool *
bool| MouseMove of int * int| Resize of int * inttype ’a behavior =
useraction event -&gt; time -&gt; ’a</p></li>
<li><p>Scanning through an event list since the beginnig of time till
current time, each time we evaluate a behavior – very wasteful wrt.
time&amp;space.</p>
<p>Producing a stream of behaviors for the stream of time allows to
forget about events already in the past.</p>
<p>type ’a behavior = useraction event -&gt; time stream -&gt; ’a
stream</p></li>
<li><p>Next optimization is to pair user actions with sampling
times.</p>
<p>type ’a behavior = (useraction option * time) stream -&gt; ’a
stream</p>
<p>None action corresponds to sampling time when nothing
happens.</p></li>
<li><p>Turning behaviors and events from functions of time into
input-output streams is similar to optimizing interesction of ordered
lists from <span class="math inline">O (mn)</span> to <span
class="math inline">O (m + n)</span> time.</p></li>
<li><p>Now we can in turn define events in terms of behaviors:</p>
<p>type ’a event = ’a option behavior</p>
<p>although it betrays the discrete character of events (happening at
points in time rather than varying over intervals of time).</p></li>
<li><p>We’ve gotten very close to <em>stream processing</em> as
discussed in lecture 7.</p>
<ul>
<li>Recall the incremental pretty-printing example that can “react” to
more input.</li>
<li>Stream combinators, <em>fork</em> from exercise 9 for lecture 7, and
a corresponding <em>merge</em>, turn stream processing into
<em>synchronous discrete reactive programming</em>.</li>
</ul></li>
<li><p>Behaviors are monadic (but see next point) – in original
specification:</p>
<p>type ’a behavior = time -&gt; ’aval return : ’a -&gt; ’a behaviorlet
return a = fun -&gt; aval bind : ’a behavior -&gt; (’a -&gt; ’b
behavior) -&gt; ’b behaviorlet bind a f = fun t -&gt; f (a t) t</p></li>
<li><p>As we’ve seen with changeables, we mostly use lifting. In Haskell
world we’d call behaviors <em>applicative</em>. To build our own lifters
in any monad:</p>
<p>val ap : (’a -&gt; ’b) monad -&gt; ’a monad -&gt; ’b monadlet ap fm
am = perform f &lt;– fm; a &lt;– am; return (f a)</p>
<ul>
<li>Note that for changeables, the naive implementation above will
introduce unnecessary dependencies. Monadic libraries for
<em>incremental computing</em> or FRP should provide optimized variants
if needed.
<ul>
<li>Compare with <code>parallel</code> for concurrent computing.</li>
</ul></li>
</ul></li>
<li><p>Going from events to behaviors. <code>until</code> and
<code>switch</code> have type</p>
<p>’a behavior -&gt; ’a behavior event -&gt; ’a behavior</p>
<p><code>step</code> has type</p>
<p>’a -&gt; ’a event -&gt; ’a behavior</p>
<ul>
<li><code>until b es</code> behaves as <code>b</code> until the first
event in <code>es</code>, then behaves as the behavior in that
event</li>
<li><code>switch b es</code> behaves as the behavior from the last event
in <code>es</code> prior to current time, if any, otherwise as
<code>b</code></li>
<li><code>step a b</code> starts with behavior returning <code>a</code>
and then switches to returning the value of the last event in
<code>b</code> (prior to current time) – a <em>step function</em>.</li>
</ul></li>
<li><p>We will use “<em>signal</em>” to refer to a behavior or an event.
But often “signal” is used as our behavior (check terminology when
looking at a new FRP library).</p></li>
</ul>
<h1 id="reactivity-by-stream-processing">4 Reactivity by Stream
Processing</h1>
<ul>
<li><p>The stream processing infrastructure should be familiar.</p>
<p>type ’a stream = ’a stream Lazy.tand ’a stream = Cons of ’a * ’a
streamlet rec lmap f l = lazy ( let Cons (x, xs) = Lazy.force l in Cons
(f x, lmap f xs))let rec liter (f : ’a -&gt; unit) (l : ’a stream) :
unit = let Cons (x, xs) = Lazy.force l in f x; liter f xslet rec lmap2 f
xs ys = lazy (<br />
let Cons (x, xs) = Lazy.force xs in let Cons (y, ys) = Lazy.force ys
in<br />
Cons (f x y, lmap2 f xs ys))let rec lmap3 f xs ys zs = lazy ( let Cons
(x, xs) = Lazy.force xs in let Cons (y, ys) = Lazy.force ys in let Cons
(z, zs) = Lazy.force zs in Cons (f x y z, lmap3 f xs ys zs))let rec
lfold acc f (l : ’a stream) = lazy ( let Cons (x, xs) = Lazy.force l
inFold a function over the stream let acc = f acc x inproducing a stream
of partial results.<br />
Cons (acc, lfold acc f xs))</p></li>
<li><p>Since a behavior is a function of user actions and sample times,
we need to ensure that only one stream is created for the actual input
stream.</p>
<p>type (‘a, ’b) memo1 = {memof : ’a -&gt; ’b; mutable memor : (’a * ’b)
option}let memo1 f = {memof = f; memor = None}let memo1app f x = match
f.memor with | Some (y, res) when x == y -&gt; <code>res</code>Physical
equality is OK –| -&gt;external input is ‘‘physically’’ unique. let res
= f.memof x inWhile debugging, we can monitor f.memor &lt;- Some (x,
res);whether f.memor = None before. reslet ($) = memo1apptype ’a
behavior =<br />
((useraction option * time) stream, ’a stream) memo1</p></li>
<li><p>The monadic/applicative functions to build complex behaviors.</p>
<ul>
<li>If you do not provide type annotations in <code>.ml</code> files,
work together with an <code>.mli</code> file to catch problems early.
You can later add more type annotations as needed to find out what’s
wrong.</li>
</ul>
<p>let returnB x : ’a behavior = let rec xs = lazy (Cons (x, xs)) in
memo1 (fun -&gt; xs)let ( !* ) = returnBlet liftB f fb = memo1 (fun uts
-&gt; lmap f (fb $ uts))let liftB2 f fb1 fb2 = memo1 (fun uts -&gt;
lmap2 f (fb1 $ uts) (fb2 $ uts))let liftB3 f fb1 fb2 fb3 = memo1 (fun
uts -&gt; lmap3 f (fb1 $ uts) (fb2 $ uts) (fb3 $ uts))let liftE f (fe :
’a event) : ’b event = memo1 (fun uts -&gt; lmap (function Some e -&gt;
Some (f e) | None -&gt; None) (fe $ uts))let (=&gt;&gt;) fe f = liftE f
felet (-&gt;&gt;) e v = e =&gt;&gt; fun -&gt; v</p></li>
<li><p>Creating events out of behaviors.</p>
<p>let whileB (fb : bool behavior) : unit event = memo1 (fun uts
-&gt;<br />
lmap (function true -&gt; Some () | false -&gt; None) (fb $ uts))let
unique fe : ’a event = memo1 (fun uts -&gt; let xs = fe $ uts in<br />
lmap2 (fun x y -&gt; if x = y then None else y) (lazy (Cons (None, xs)))
xs)let whenB fb = memo1 (fun uts -&gt; unique (whileB fb) $ uts)let
snapshot fe fb : (’a * ’b) event = memo1 (fun uts -&gt; lmap2 (fun
x-&gt;function Some y -&gt; Some (y,x) | None -&gt; None) (fb $ uts) (fe
$ uts))</p></li>
<li><p>Creating behaviors out of events.</p>
<p>let step acc fe =The step function: value of last event. memo1 (fun
uts -&gt; lfold acc (fun acc -&gt; function None -&gt; acc | Some v
-&gt; v) (fe $ uts))let stepaccum acc ff =Transform a value by a series
of functions. memo1 (fun uts -&gt; lfold acc (fun acc -&gt; function |
None -&gt; acc | Some f -&gt; f acc) (ff $ uts))</p></li>
<li><p>To numerically integrate a behavior, we need to access the
sampling times.</p>
<p>let integral fb = let rec loop t0 acc uts bs = let Cons ((,t1), uts)
= Lazy.force uts in let Cons (b, bs) = Lazy.force bs in let acc = acc +.
(t1 -. t0) *. b in<span class="math inline">b =\operatorname{fb}
(t_{1}), \operatorname{acc}
\approx \int_{t \leqslant t_{0}} f</span>. Cons (acc, lazy (loop t1 acc
uts bs)) in memo1 (fun uts -&gt; lazy ( let Cons ((,t), uts’) =
Lazy.force uts in Cons (0., lazy (loop t 0. uts’ (fb $ uts)))))</p>
<ul>
<li>In our <em>paddle game</em> example, we paradoxically express
position and velocity in mutually recursive manner. The trick is the
same as in chapter 7 – integration introduces one step of delay.</li>
</ul></li>
<li><p>User actions:</p>
<p>let lbp : unit event = memo1 (fun uts -&gt; lmap (function
Some(Button(,)), -&gt; Some() | -&gt; None) uts)let mm : (int * int)
event = memo1 (fun uts -&gt; lmap (function Some(MouseMove(x,y)),
-&gt;Some(x,y) | -&gt;None) uts)let screen : (int * int) event = memo1
(fun uts -&gt; lmap (function Some(Resize(x,y)), -&gt;Some(x,y) |
-&gt;None) uts)let mousex : int behavior = step 0 (liftE fst mm)let
mousey : int behavior = step 0 (liftE snd mm)let width : int behavior =
step 640 (liftE fst screen)let height : int behavior = step 512 (liftE
snd screen)</p></li>
</ul>
<h3 id="the-paddle-game-example">1 The Paddle Game example</h3>
<ul>
<li><p>A <em>scene graph</em> is a data structure that represents a
“world” which can be drawn on screen.</p>
<p>type scene =| Rect of int * int * int * intposition, width, height|
Circle of int * int * intposition, radius| Group of scene list| Color of
Graphics.color * <code>scene</code>color of subscene objects|Translate
of float * float * sceneadditional offset of origin</p></li>
<li><p>Drawing a scene explains what we mean above.</p>
<p>let draw sc = let f2i = intoffloat in let open Graphics in let rec
aux tx ty = functionAccumulate translations. | Rect (x, y, w, h)
-&gt;<br />
fillrect (f2i tx+x) (f2i ty+y) w h | Circle (x, y, r) -&gt; fillcircle
(f2i tx+x) (f2i ty+y) r | Group scs -&gt; List.iter (aux tx ty)
<code>scs</code><span class="math inline">\swarrow</span> Set color for
<code>sc</code> objects.| Color (c, sc) -&gt; setcolor c; aux tx ty sc |
Translate (x, y, sc) -&gt; aux (tx+.x) (ty+.y) sc in<br />
cleargraph ();‘‘Fast and clean’’ removing of previous picture. aux 0. 0.
sc; synchronize ()Synchronize the <em>double buffer</em> – avoiding
flickering.</p></li>
<li><p>An animation is a scene behavior. To animate it we need to create
the input stream: the user actions and sampling times stream.</p>
<ul>
<li>We could abstract away drawing from time sampling in
<code>reactimate</code>, asking for (i.e. passing as argument) a
producer of user actions and a consumer of scene graphs (like
<code>draw</code>).</li>
</ul>
<p>let reactimate (anim : scene behavior) = let open Graphics in let
notb = function Some (Button (,)) -&gt; false | -&gt; true in let
current oldm oldscr (oldu, t0) = let rec delay () = let t1 =
Unix.gettimeofday () in let d = 0.01 -. (t1 -. t0) in try if d &gt; 0.
then Thread.delay d; Unix.gettimeofday () with Unix.Unixerror ((<em>
Unix.EAGAIN </em>), , ) -&gt; delay () in let t1 = delay () in let s =
Graphics.waitnextevent [Poll] in let x = s.mousex and y = s.mousey and
scrx = Graphics.sizex () and scry = Graphics.sizey () in let ue = if
s.keypressed then Some (Key s.key) else if (scrx, scry) &lt;&gt; oldscr
then Some (Resize (scrx,scry)) else if s.button &amp;&amp; notb oldu
then Some (Button (x, y)) else if (x, y) &lt;&gt; oldm then Some
(MouseMove (x, y)) else None in (x, y), (scrx, scry), (ue, t1) in
opengraph ““;Open window. displaymode false;Draw using <em>double
buffering</em>. let t0 = Unix.gettimeofday () in let rec utstep mpos scr
ut = lazy ( let mpos, scr, ut = current mpos scr ut in Cons (ut, utstep
mpos scr ut)) in let scr = Graphics.sizex (), Graphics.sizey () in let
ut0 = Some (Resize (fst scr, snd scr)), t0 in liter draw (anim $ lazy
(Cons (ut0, utstep (0,0) scr ut0))); closegraph ()Close window –
unfortunately never happens.</p></li>
<li><p>General-purpose behavior operators.</p>
<p>let (+<em>) = liftB2 (+)let (-</em>) = liftB2 (-)let ( *** ) = liftB2
( * )let (/<em>) = liftB2 (/)let (&amp;&amp;</em>) = liftB2
(&amp;&amp;)let (||<em>) = liftB2 (||)let (&lt;</em>) = liftB2 (&lt;)let
(&gt;*) = liftB2 (&gt;)</p></li>
<li><p>The walls are drawn on left, top and right borders of the
window.</p>
<p>let walls = liftB2 (fun w h -&gt; Color (Graphics.blue, Group [Rect
(0, 0, 20, h-1); Rect (0, h-21, w-1, 20); Rect (w-21, 0, 20,
h-1)]))<br />
width height</p></li>
<li><p>The paddle is tied to the mouse at the bottom border of the
window.</p>
<p>let paddle = liftB (fun mx -&gt; Color (Graphics.black, Rect (mx, 0,
50, 10))) mousex</p></li>
<li><p>The ball has a velocity in pixels per second. It bounces from the
walls, which is hard-coded in terms of distance from window borders.</p>
<ul>
<li>Unfortunately OCaml, being an eager language, does not let us encode
recursive behaviors in elegant way. We need to unpack behaviors and
events as functions of the input stream.</li>
<li>xbounce -&gt;&gt; (<span class="math inline">\sim</span>-.) event is
just the negation function happening at each horizontal bounce.</li>
<li>stepaccum vel (xbounce -&gt;&gt; (<span
class="math inline">\sim</span>-.)) behavior is <code>vel</code> value
changing sign at each horizontal bounce.</li>
<li>liftB intoffloat (integral xvel) +* width /* !*2 – first integrate
velocity, then truncate it to integers and offset to the middle of the
window.</li>
<li>whenB ((xpos &gt;* width -* !<em>27) ||</em> (xpos &lt;* !*27)) –
issue an event the first time the position exceeds the bounds. This
ensures there are no further bouncings until the ball moves out of the
walls.</li>
</ul></li>
</ul>
<p>let pbal vel = let rec xvel uts = stepaccum vel (xbounce -&gt;&gt;
(<span class="math inline">\sim</span>-.)) $ uts and xvel = {memof =
xvel; memor = None} and xpos uts = (liftB intoffloat (integral xvel) +*
width /* !<em>2) $ uts and xpos = {memof = xpos; memor = None} and
xbounce uts = whenB ((xpos &gt;</em> width -* !<em>27) ||</em> (xpos
&lt;* !<em>27)) $ uts and xbounce = {memof = xbounce; memor = None} in
let rec yvel uts = (stepaccum vel (ybounce -&gt;&gt; (<span
class="math inline">\sim</span>-.))) $ uts and yvel = {memof = yvel;
memor = None} and ypos uts = (liftB intoffloat (integral yvel) +</em>
height /* !<em>2) $ uts and ypos = {memof = ypos; memor = None} and
ybounce uts = whenB ( (ypos &gt;</em> height -* !<em>27) ||</em> ((ypos
&lt;* !<em>17) &amp;&amp;</em> (ypos &gt;* !<em>7) &amp;&amp;</em> (xpos
&gt;* mousex) &amp;&amp;* (xpos &lt;* mousex +* !*50))) $ uts and
ybounce = {memof = ybounce; memor = None} in liftB2 (fun x y -&gt; Color
(Graphics.red, Circle (x, y, 6))) xpos ypos</p>
<ul>
<li><p>Invocation:</p>
<p><code>ocamlbuild Lec10b.native -cflags -I,+threads  -libs  graphics,unix,threads/threads --</code></p></li>
<li><p><img src="Lec10b.png" /></p></li>
</ul>
<h1 id="reactivity-by-incremental-computing">5 Reactivity by Incremental
Computing</h1>
<ul>
<li>In <em>Froc</em> behaviors and events are both implemented as
changeables but only behaviors persist, events are “instantaneous”.
<ul>
<li>Behaviors are composed out of constants and prior events, capture
the “changeable” aspect.</li>
<li>Events capture the “writeable” aspect – after their values are
propagated, the values are removed.</li>
</ul>
Events and behaviors are called <em>signals</em>.</li>
<li><em>Froc</em> does not represent time, and provides the function
changes : ’a behavior -&gt; ’a event, which violates the continuous
semantics we introduced before.
<ul>
<li>It breaks the illusion that behaviors vary continuously rather than
at discrete points in time.</li>
<li>But it avoids the need to synchronize global time samples with
events in the system. It is “less continuous but more dense”.</li>
</ul></li>
<li>Sending an event – <code>send</code> – starts an <em>update
cycle</em>. Signals cannot call <code>send</code>, but can
<code>send_deferred</code> which will send an event in next cycle.
<ul>
<li>Things that happen in the same update cycle are
<em>simultaneous</em>.</li>
<li>Events are removed (detached from dependency graph) after an update
cycle.</li>
</ul></li>
<li><em>Froc</em> provides the <code>fix_b</code>, <code>fix_e</code>
functions to define signals recursively. Current value refers to value
from previous update cycle, and defers next recursive step to next
cycle, until convergence.</li>
<li>Update cycles can happen “back-to-back” via
<code>send_deferred</code> and <code>fix_b</code>, <code>fix_e</code>,
or can be invoked from outside <em>Froc</em> by sending events at
arbitrary times.
<ul>
<li>With a <code>time</code> behavior that holds a <code>clock</code>
event value, events from “back-to-back” update cycles can be at the same
clock time although not simultaneous in this sense.</li>
<li>Update cycles prevent <em>glitches</em>, where outdated signal is
used e.g. to issue an event.</li>
</ul></li>
<li>Let’s familiarize ourselves with <em>Froc</em> API:<a
href="http://jaked.github.com/froc/doc/Froc.html">http://jaked.github.com/froc/doc/Froc.html</a></li>
<li>A behavior is written in <em>pure style</em>, when its definition
does not use <code>send</code>, <code>send_deferred</code>,
<code>notify_e</code>, <code>notify_b</code> and <code>sample</code>:
<ul>
<li><code>sample</code>, <code>notify_e</code>, <code>notify_b</code>
are used from outside the behavior (from its “environment”) analogously
to observing result of a function,</li>
<li><code>send</code>, <code>send_deferred</code> are used from outside
analogously to providing input to a function.</li>
</ul></li>
<li>We will develop an example in a pragmatic, <em>impure</em> style,
but since purity is an important aspect of functional programming, I
propose to rewrite it in pure style as an exercise (ex. 5).</li>
<li>When writing in impure style we need to remember to refer from
somewhere to all the pieces of our behavior, otherwise the unreferred
parts will be <strong>garbage collected</strong> breaking the behavior.
<ul>
<li>A value is referred to, when it has a name in the global environment
or is part of a bigger value that is referred to (for example it’s
stored somewhere). Signals can be referred to by being part of the
dependency graph, but also by any of the more general ways.</li>
</ul></li>
</ul>
<h3 id="reimplementing-the-paddle-game-example">1 Reimplementing the
Paddle Game example</h3>
<ul>
<li><p>Rather than following our incremental computing example (a scene
with changeable parts), we follow our FRP example: a scene
behavior.</p></li>
<li><p>First we introduce time:</p>
<p>open Froclet clock, tick = makeevent ()let time = hold
(Unix.gettimeofday ()) clock</p></li>
<li><p>Next we define integration:</p>
<p>let integral fb = let aux (sum, t0) t1 = sum +. (t1 -. t0) *. sample
fb, t1 in collectb aux (0., sample time) clock</p>
<p>For convenience, the integral remembers the current upper limit of
integration. It will be useful to get the integer part:</p>
<p>let integres fb = lift (fun (v,) -&gt; intoffloat v) (integral
fb)</p></li>
<li><p>We can also define integration in pure style:</p>
<p>let pair fa fb = lift2 (fun x y -&gt; x, y) fa fblet integralnice fb
= let samples = changes (pair fb time) in let aux (sum, t0) (fv, t1) =
sum +. (t1 -. t0) *. fv, t1 in collectb aux (0., sample time)
samples</p>
<p>The initial value (0., sample time) is not “inside” the behavior so
<code>sample</code> here does not spoil the pure style.</p></li>
<li><p>The <code>scene</code> datatype and how we <code>draw</code> a
scene does not change.</p></li>
<li><p>Signals which will be sent to behaviors:</p>
<p>let mousemovex, movemousex = makeevent ()let mousemovey, movemousey =
makeevent ()let mousex = hold 0 mousemovexlet mousey = hold 0
mousemovexlet widthresized, resizewidth = makeevent ()let heightresized,
resizeheight = makeevent ()let width = hold 640 widthresizedlet height =
hold 512 heightresizedlet mbuttonpressed, pressmbutton = makeevent ()let
keypressed, presskey = makeevent ()</p></li>
<li><p>The user interface main loop, emiting signals and observing
behaviors:</p>
<p>let reactimate (anim : scene behavior) = let open Graphics in let rec
loop omx omy osx osy omb t0 = let rec delay () = let t1 =
Unix.gettimeofday () in let d = 0.01 -. (t1 -. t0) in try if d &gt; 0.
then Thread.delay d; Unix.gettimeofday () with Unix.Unixerror ((*
Unix.EAGAIN *), , ) -&gt; delay () in let t1 = delay () in let s =
Graphics.waitnextevent [Poll] in let x = s.mousex and y = s.mousey and
scrx = Graphics.sizex () and scry = Graphics.sizey () in if s.keypressed
then send presskey s.key;We can send signals if scrx &lt;&gt; osx then
send resizewidth scrx;one by one. if scry &lt;&gt; osy then send
resizeheight scry; if s.button &amp;&amp; not omb then send pressmbutton
(); if x &lt;&gt; omx then send movemousex x; if y &lt;&gt; omy then
send movemousey y; send tick t1; draw (sample anim);After all signals
are updated, observe behavior. loop x y scrx scry s.button t1 in
opengraph ““; displaymode false; loop 0 0 640 512 false
(Unix.gettimeofday ()); closegraph ()</p></li>
<li><p>The simple behaviors as in <code>Lec10b.ml</code>. Pragmatic
(impure) bouncing:</p>
<div class="sourceCode" id="cb78"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pbal vel =  <span class="kw">let</span> xbounce, bouncex = makeevent () <span class="kw">in</span>  <span class="kw">let</span> ybounce, bouncey </span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>=</span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>makeevent () <span class="kw">in</span>  <span class="kw">let</span> xvel = collectb (<span class="kw">fun</span> v  -&gt; $\sim$-.v) vel xbounce</span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span>  <span class="kw">let</span> yvel = collectb (<span class="kw">fun</span> v  -&gt; $\sim$-.v) vel ybounce <span class="kw">in</span>  <span class="kw">let</span> xpos =</span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>integres xvel +* width /* !*<span class="dv">2</span> <span class="kw">in</span>  <span class="kw">let</span> ypos = integres yvel +* height /*</span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a>!*<span class="dv">2</span> <span class="kw">in</span>  <span class="kw">let</span> xbounce = whentrue    ((xpos &gt;* width -* !*<span class="dv">27</span>) ||*</span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a>(xpos &lt;* !*<span class="dv">27</span>)) <span class="kw">in</span>  notifye xbounce (send bouncex);  <span class="kw">let</span> ybounce =</span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a>whentrue (    (ypos &gt;* height -* !*<span class="dv">27</span>) ||*      ((ypos &lt;*</span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true" tabindex="-1"></a>!*<span class="dv">17</span>) &amp;&amp;* (ypos &gt;* !*<span class="dv">7</span>) &amp;&amp;*          (xpos &gt;* mousex) &amp;&amp;*</span>
<span id="cb78-10"><a href="#cb78-10" aria-hidden="true" tabindex="-1"></a>(xpos &lt;* mousex +* !*<span class="dv">50</span>))) <span class="kw">in</span>  notifye ybounce (send bouncey);</span>
<span id="cb78-11"><a href="#cb78-11" aria-hidden="true" tabindex="-1"></a>lift4 (<span class="kw">fun</span> x y   -&gt; Color (Graphics.red, Circle (x, y, <span class="dv">6</span>)))    xpos ypos</span>
<span id="cb78-12"><a href="#cb78-12" aria-hidden="true" tabindex="-1"></a>(hold () xbounce) (hold () ybounce)</span></code></pre></div></li>
<li><p>We hold on to xbounce and ybounce above to prevent garbage
collecting them. We could instead remember them in the “toplevel”:</p>
<p>let pbal vel = … xbounce, ybounce, lift2 (fun x y -&gt; Color
(Graphics.red, Circle (x, y, 6))) xpos yposlet xb, yb, ball = pbal
100.let game = lift3 (fun walls paddle ball -&gt; Group [walls; paddle;
ball]) walls paddle ball</p></li>
<li><p>We can easily monitor signals while debugging, e.g.:</p>
<pre><code>notifye xbounce (fun () -&gt; Printf.printf &quot;xbounce\n%!&quot;);
notifye ybounce (fun () -&gt; Printf.printf &quot;ybounce\n%!&quot;);</code></pre></li>
<li><p>Invocation:<code>ocamlbuild Lec10c.native -cflags -I,+froc,-I,+threads -libs  froc/froc,unix,graphics,threads/threads --</code></p></li>
</ul>
<h1 id="direct-control">6 Direct Control</h1>
<ul>
<li><p>Real-world behaviors often are <em>state machines</em>, going
through several stages. We don’t have declarative means for it yet.</p>
<ul>
<li>Example: baking recipes. <em>1. Preheat the oven. 2. Put flour,
sugar, eggs into a bowl. 3. Spoon the mixture.</em> etc.</li>
</ul></li>
<li><p>We want a <em>flow</em> to be able to proceed through events:
when the first event arrives we remember its result and wait for the
next event, disregarding any further arrivals of the first event!</p>
<ul>
<li>Therefore <em>Froc</em> constructs like mapping an event:
<code>map</code>, or attaching a notification to a behavior change:
<code>bind b1 (fun v1 -&gt; notify_b  ~now:false b2 (fun v2 -&gt;</code>
…)), will not work.</li>
</ul></li>
<li><p>We also want to be able to repeat or loop a flow, but starting
from the notification of the first event that happens after the
notification of the last event.</p></li>
<li><p><code>next e</code> is an event propagating only the first
occurrence of <code>e</code>. This will be the basis of our
<code>await</code> function.</p></li>
<li><p>The whole flow should be cancellable from outside at any
time.</p></li>
<li><p>A flow is a kind of a <em>lightweight thread</em> as in end of
lecture 8, we’ll make it a monad. It only “stores” a non-unit value when
it <code>await</code>s an event. But it has a primitive to
<code>emit</code> values.</p>
<ul>
<li>We actually implement <em>coarse-grained</em> threads (lecture 8
exercise 11), with <code>await</code> in the role of
<code>suspend</code>.</li>
</ul></li>
<li><p>We build a module Flow with monadic type (’a, ’b) flow “storing”
<code>'b</code> and emitting <code>'a</code>.</p>
<p>type (’a, ’b) flowtype cancellableA handle to cancel a flow (stop
further computation).val noopflow : (’a, unit) flowSame as
<code>return</code> ().val return : ’b -&gt; (’a, ’b) flowCompleted
flow.val await : ’b Froc.event -&gt; (’a, ’b) flowWait and store
event:val bind :the principled way to input. (’a, ’b) flow -&gt; (’b
-&gt; (’a, ’c) flow) -&gt; (’a, ’c) flowval emit : ’a -&gt; (’a, unit)
flowThe principled way to output.val cancel : cancellable -&gt; unitval
repeat :Loop the given flow and store the stop event. ?until:’a
Froc.event -&gt; (’b, unit) flow -&gt; (’b, ’a) flowval eventflow : (’a,
unit) flow -&gt; ’a Froc.event * cancellableval behaviorflow :The
initial value of a behavior and a flow to update it.<br />
’a -&gt; (’a, unit) flow -&gt; ’a Froc.behavior * cancellableval
iscancelled : cancellable -&gt; bool</p></li>
<li><p>We follow our (or <em>Lwt</em>) implementation of lightweight
threads, adapting it to the need of cancelling flows.</p>
<p>module F = Froctype ’a result =| Return of <code>'a</code><span
class="math inline">\downarrow</span>Notifications to cancel when
cancelled.| Sleep of (’a -&gt; unit) list * F.cancel ref list|
Cancelled| Link of ’a stateand ’a state = {mutable state : ’a
result}type cancellable = unit state</p></li>
<li><p>Functions <code>find</code>, <code>wakeup</code>,
<code>connect</code> are as in lecture 8 (but connecting to cancelled
thread cancels the other thread).</p></li>
<li><p>Our monad is actually a reader monad over the result state. The
reader supplies the <code>emit</code> function. (See exercise 10.)</p>
<p>type (’a, ’b) flow = (’a -&gt; unit) -&gt; ’b state</p></li>
<li><p>The <code>return</code> and <code>bind</code> functions are as in
our lightweight threads, but we need to handle cancelled flows: for
<code>m = bind a b</code>, if <code>a</code> is cancelled then
<code>m</code> is cancelled, and if <code>m</code> is cancelled then
don’t wake up <code>b</code>:</p>
<pre><code>  let waiter x =        if not (iscancelled m)        then connect m (b </code></pre>
<p>x emit) in …</p></li>
<li><p><code>await</code> is implemented like <code>next</code>, but it
wakes up a flow:</p>
<p>let await t = fun emit -&gt; let c = ref F.nocancel in let m =
{state=Sleep ([], [c])} in c := F.notifyecancel t begin fun r
-&gt;<br />
F.cancel !c; c := F.nocancel; wakeup m r end; m</p></li>
<li><p><code>repeat</code> attaches the whole loop as a waiter for the
loop body.</p>
<p>let repeat ?(until=F.never) fa = fun emit -&gt; let c = ref
F.nocancel in let out = {state=Sleep ([], [c])} in let cancelbody = ref
{state=Cancelled} in c := F.notifyecancel until begin fun tv -&gt;<br />
F.cancel !c; c := F.nocancel; Exiting the loop consists of cancelling
the loop body cancel !cancelbody; <code>wakeup out tv</code>and waking
up loop waiters.end; let rec loop () = let a = find (fa emit) in
cancelbody := a; (match a.state with | Cancelled -&gt; cancel out;
F.cancel !c | Return x -&gt; failwith “loopuntil: not implemented for
unsuspended flows” | Sleep (xwaiters, xcancels) -&gt; a.state &lt;-
Sleep (loop::xwaiters, xcancels)<br />
| Link -&gt; assert false) in loop (); out</p></li>
<li><p>Example: drawing shapes.
Invocation:<code>ocamlbuild Lec10d.native -pp "camlp4o  monad/pa_monad.cmo" -libs froc/froc,graphics -cflags -I,+froc --</code></p></li>
<li><p>The event handlers and drawing/event dispatch loop
<code>reactimate</code> is similar to the paddle game example (we
removed unnecessary events).</p></li>
<li><p>The scene is a list of shapes, the first shape is open.</p>
<p>type scene = (int * int) list listlet draw sc = let open Graphics
in<br />
cleargraph (); (match sc with | [] -&gt; () | opn::cld -&gt;<br />
drawpolyline (Array.oflist opn); List.iter (fillpoly -| Array.oflist)
cld); synchronize ()</p></li>
<li><p>We build a flow and turn it into a behavior to animate.</p>
<p>let painter = let cld = ref [] inGlobal state of painter. repeat
(perform<br />
await mbuttonpressed;Start when button down. let opn = ref [] in<br />
repeat (perform mpos &lt;– await mousemove;<span
class="math inline">\swarrow</span>Add next position to line. emit (opn
:= mpos :: !opn; !opn :: !cld))<br />
<span class="math inline">\sim</span>until:mbuttonreleased;<span
class="math inline">\swarrow</span>Start new shape. emit (cld := !opn ::
!cld; opn := []; [] :: !cld))let painter, cancelpainter = behaviorflow
[] painterlet () = reactimate painter</p></li>
<li><p><img src="Lec10d.png" /></p></li>
</ul>
<h3 id="flows-and-state">1 Flows and state</h3>
<p>Global state and thread-local state can be used with lightweight
threads, but pay attention to semantics – which computations are inside
the monad and which while building the initial monadic value.</p>
<ul>
<li>Side effects hidden in <code>return</code> and <code>emit</code>
arguments are not inside the monad. E.g. if in the “first line” of a
loop effects are executed only at the start of the loop – but if after
bind (“below first line” of a loop), at each step of the loop.</li>
</ul>
<pre><code>let f = repeat (perform
  emit (Printf.printf &quot;[0]\n%!&quot;; &#39;0&#39;);
  () &lt;-- await aas;
  emit (Printf.printf &quot;[1]\n%!&quot;; &#39;1&#39;);
  () &lt;-- await bs;
  emit (Printf.printf &quot;[2]\n%!&quot;; &#39;2&#39;);
  () &lt;-- await cs;
  emit (Printf.printf &quot;[3]\n%!&quot;; &#39;3&#39;);
  () &lt;-- await ds;
  emit (Printf.printf &quot;[4]\n%!&quot;; &#39;4&#39;))
let e, cancele = eventflow f
let () =
  F.notifye e (fun c -&gt; Printf.printf &quot;flow: %c\n%!&quot; c);
  Printf.printf &quot;notification installed\n%!&quot;
let () =
  F.send a (); F.send b (); F.send c (); F.send d ();
  F.send a (); F.send b (); F.send c (); F.send d ()</code></pre>
<p>[0]Only printed once – when building the
loop.<code>notification installed</code>Only installed
<strong>after</strong> the first flow event sent.event: aEvent
notification (see source <code>Lec10e.ml</code>).[1]Second
<code>emit</code> computed after first <code>await</code> returns.flow:
1Emitted signal.event: bNext event…[2]flow: 2event: c[3]flow: 3event:
d[4]flow: 4Last signal emitted from first turn of the loop –flow: 0and
first signal of the second turn (but <code>[0]</code> not
printed).event: a[1]flow: 1event: b[2]flow: 2event: c[3]flow: 3event:
d[4]flow: 4flow: 0Program ends while flow in third turn of the loop.</p>
<h1 id="graphical-user-interfaces">7 Graphical User Interfaces</h1>
<ul>
<li>In-depth discussion of GUIs is beyond the scope of this course. We
only cover what’s needed for an example reactive program with direct
control.</li>
<li>Demo of libraries <em>LablTk</em> based on optional labelled
arguments discussed in lecture 2 exercise 2, and polymorphic variants,
and <em>LablGtk</em> additionally based on objects. We will learn more
about objects and polymorphic variants in next lecture.</li>
</ul>
<h2 id="calculator-flow">7.1 Calculator Flow</h2>
<p>let digits, digit = F.makeevent ()We represent the mechanicslet ops,
op = F.makeevent ()of the calculator directly as a flow.let dots, dot =
F.makeevent ()let calc =We need two state variables for two arguments of
calculation let f = ref (fun x -&gt; x) and now = ref 0.0 inbut we
repeat (performremember the older argument in partial application. op
&lt;– repeat<br />
(performEnter the digits of a number (on later turns d &lt;– await
digits;starting from the second digit) emit (now := 10. *. !now +. d;
!now)) <span class="math inline">\sim</span>until:ops;until operator
button is pressed.<br />
emit (now := !f !now; f := op !now; !now); d &lt;–
<code>repeat</code><span class="math inline">\nwarrow</span>Compute the
result and ‘‘store away’’ the operator.(perform op &lt;– await ops;
return (f := op !now)) <span
class="math inline">\sim</span>until:digits;The user can pick a
different operator. emit (now := d; !now))Reset the state to a new
number.let calce, cancelcalc = eventflow calcNotifies display
update.</p>
<h2 id="tk-labltk">7.2 <em>Tk</em>: <em>LablTk</em></h2>
<ul>
<li><p>Widget toolkit <strong><em>Tk</em></strong> known from the
<em>Tcl</em> language.</p></li>
<li><p>Invocation:<code>ocamlbuild Lec10tk.byte -cflags -I,+froc -libs froc/froc  -pkg  labltk -pp "camlp4o monad/pa_monad.cmo" --</code></p>
<ul>
<li>For unknown reason I had build problems with <code>ocamlopt</code>
(native).</li>
</ul></li>
<li><p>Layout of the calculator – common across GUIs.</p>
<p>let layout = [|[|“7”,‘Di 7.; “8”,‘Di 8.; “9”,‘Di 9.; “+”,‘O
(+.)|];<br />
[|“4”,‘Di 4.; “5”,‘Di 5.; “6”,‘Di 6.; “-”,‘O (-.)|]; [|“1”,‘Di 1.;
“2”,‘Di 2.; “3”,‘Di 3.; “<em>“,‘O ( </em>.)|]; [|“0”,‘Di 0.; “.”,‘Dot;
“=”, ‘O sk; “/”,‘O (/.)|]|]</p></li>
<li><p>Every <em>widget</em> (window gadget) has a parent in which it is
located.</p></li>
<li><p><em>Buttons</em> have action associated with pressing them,
<em>labels</em> just provide information, <em>entries</em> (aka.
<em>edit</em> fields) are for entering info from keyboard.</p>
<ul>
<li>Actions are <em>callback</em> functions passed as the <span
class="math inline">\sim</span><code>command</code> argument.</li>
</ul></li>
<li><p><em>Frames</em> in <em>Tk</em> group widgets.</p></li>
<li><p>The parent is sent as last argument, after optional labelled
arguments.</p>
<p>let top = Tk.openTk ()let btnframe = Frame.create <span
class="math inline">\sim</span>relief:‘Groove <span
class="math inline">\sim</span>borderwidth:2 toplet buttons = Array.map
(Array.map (function | text, ‘Dot -&gt; Button.create <span
class="math inline">\sim</span>text <span
class="math inline">\sim</span>command:(fun () -&gt; F.send dot ())
btnframe | text, ‘Di d -&gt; Button.create <span
class="math inline">\sim</span>text <span
class="math inline">\sim</span>command:(fun () -&gt; F.send digit d)
btnframe | text, ‘O f -&gt; Button.create <span
class="math inline">\sim</span>text <span
class="math inline">\sim</span>command:(fun () -&gt; F.send op f)
btnframe)) layoutlet result = Label.create <span
class="math inline">\sim</span>text:“0” <span
class="math inline">\sim</span>relief:‘Sunken top</p></li>
<li><p>GUI toolkits have layout algorithms, so we only need to tell
which widgets hang together and whether they should fill all available
space etc. – via <code>pack</code>, or <code>grid</code> for
“rectangular” organization.</p></li>
<li><p><span class="math inline">\sim</span>fill: the allocated space in
<code>‘X</code>, <code>‘Y</code>, <code>‘Both</code> or
<code>‘None</code> axes;<span class="math inline">\sim</span>expand:
maximally how much space is allocated or only as needed.</p></li>
<li><p><span class="math inline">\sim</span>anchor: allows to glue a
widget in particular direction (<code>‘Center</code>, <code>‘E</code>,
<code>‘Ne</code> etc.)</p></li>
<li><p>The <code>grid</code> packing flexibility: <span
class="math inline">\sim</span>columnspan and <span
class="math inline">\sim</span>rowspan.</p></li>
<li><p><code>configure</code> functions accept the same arguments as
<code>create</code> but change existing widgets.</p></li>
<li><p>let () = Wm.titleset top “Calculator”; Tk.pack [result] <span
class="math inline">\sim</span>side:‘Top <span
class="math inline">\sim</span>fill:‘X; Tk.pack [btnframe] <span
class="math inline">\sim</span>side:‘Bottom <span
class="math inline">\sim</span>expand:true;<br />
Array.iteri (fun column -&gt;Array.iteri (fun row button -&gt; Tk.grid
<span class="math inline">\sim</span>column <span
class="math inline">\sim</span>row [button])) buttons; Wm.geometryset
top “200x200”;<br />
F.notifye calce (fun now -&gt; Label.configure <span
class="math inline">\sim</span>text:(stringoffloat now) result);
Tk.mainLoop ()</p></li>
<li><p><img src="Lec10-Calc_Tk.png" /></p></li>
</ul>
<h2 id="gtk-lablgtk">7.3 <em>GTk+</em>: <em>LablGTk</em></h2>
<ul>
<li><p><strong><em>LablGTk</em></strong> is build as an object-oriented
layer over a low-level layer of functions interfacing with the
<em>GTk+</em> library, which is written in <em>C</em>.</p></li>
<li><p>In OCaml, object fields are only visible to object methods, and
methods are called with # syntax, e.g. window#show ()</p></li>
<li><p>The interaction with the application is reactive:</p>
<ul>
<li>Our events are called signals in <em>GTk+</em>.</li>
<li>Registering a notification is called connecting a signal handler,
e.g.button#connect#clicked <span
class="math inline">\sim</span>callback:hello which takes <span
class="math inline">\sim
{\nobreak}</span>callback:(unit -&gt; unit) and returns GtkSignal.id.
<ul>
<li>As with <em>Froc</em> notifications, multiple handlers can be
attached.</li>
</ul></li>
<li><em>GTk+</em> events are a subclass of signals related to more
specific window events, e.g.window#event#connect#delete <span
class="math inline">\sim</span>callback:deleteevent</li>
<li><em>GTk+</em> event callbacks take more info: <span
class="math inline">\sim</span>callback:(event -&gt; unit) for some type
<code>event</code>.</li>
</ul></li>
<li><p>Automatic layout (aka. packing) seems less sophisticated than in
<em>Tk</em>:</p>
<ul>
<li>only horizontal and vertical boxes,</li>
<li>therefore <span class="math inline">\sim</span>fill is binary and
<span class="math inline">\sim</span>anchor is replaced by <span
class="math inline">\sim</span>from <code>‘START</code> or
<code>‘END</code>.</li>
</ul></li>
<li><p>Automatic grid layout is called <code>table</code>.</p>
<ul>
<li><span class="math inline">\sim</span>fill and <span
class="math inline">\sim</span>expand take <code>‘X</code>,
<code>‘Y</code>, <code>‘BOTH</code>, <code>‘NONE</code>.</li>
</ul></li>
<li><p>The <code>coerce</code> method casts the type of the object (in
<em>Tk</em> there is <code>coe</code> function).</p></li>
<li><p>Labels don’t have a dedicated module – see definition of
<code>result</code> widget.</p></li>
<li><p>Widgets have setter methods <code>widget#set_X</code> (instead of
a single <code>configure</code> function in <em>Tk</em>).</p></li>
<li><p>Invocation:<code>ocamlbuild Lec10gtk.native -cflags -I,+froc -libs froc/froc   -pkg lablgtk2 -pp "camlp4o monad/pa_monad.cmo" --</code></p></li>
<li><p>The model part of application doesn’t change.</p></li>
<li><p>Setup:</p>
<p>let = GtkMain.Main.init ()let window = GWindow.window <span
class="math inline">\sim</span>width:200 <span
class="math inline">\sim</span>height:200 <span
class="math inline">\sim</span>title:“Calculator” ()let top = GPack.vbox
<span class="math inline">\sim</span>packing:window#add ()let result =
GMisc.label <span class="math inline">\sim</span>text:“0” <span
class="math inline">\sim</span>packing:top#add ()let btnframe =
GPack.table <span class="math inline">\sim</span>rows:(Array.length
layout) <span class="math inline">\sim</span>columns:(Array.length
layout.(0)) <span class="math inline">\sim</span>packing:top#add
()</p></li>
<li><p>Button actions:</p>
<p>let buttons = Array.map (Array.map (function | label, ‘Dot -&gt; let
b = GButton.button <span class="math inline">\sim</span>label () in let
= b#connect#clicked<br />
<span class="math inline">\sim</span>callback:(fun () -&gt; F.send dot
()) in b | label, ‘Di d -&gt;<br />
let b = GButton.button <span class="math inline">\sim</span>label () in
let = b#connect#clicked<br />
<span class="math inline">\sim</span>callback:(fun () -&gt; F.send digit
d) in b | label, ‘O f -&gt;<br />
let b = GButton.button <span class="math inline">\sim</span>label () in
let = b#connect#clicked<br />
<span class="math inline">\sim</span>callback:(fun () -&gt; F.send op f)
in b)) layout</p></li>
<li><p>Button layout, result notification, start application:</p>
<p>let deleteevent = GMain.Main.quit (); falselet () = let =
window#event#connect#delete <span
class="math inline">\sim</span>callback:deleteevent in Array.iteri (fun
column-&gt;Array.iteri (fun row button -&gt; btnframe#attach <span
class="math inline">\sim</span>left:column <span
class="math inline">\sim</span>top:row <span
class="math inline">\sim</span>fill:‘BOTH <span
class="math inline">\sim</span>expand:‘BOTH (button#coerce)) ) buttons;
F.notifye calce (fun now -&gt; result#setlabel (stringoffloat now));
window#show (); GMain.Main.main ()</p></li>
<li><p><img src="Lec10calc_gtk.png" /></p></li>
</ul>
<p>Functional Programming</p>
<p>Zippers, Reactivity, GUIs</p>
<p><strong>Exercise 1:</strong> Introduce operators <span
class="math inline">-, /</span> into the context rewriting “pull out
subexpression” example. Remember that they are not commutative.</p>
<p><strong>Exercise 2:</strong> Add to the <em>paddle game</em>
example:</p>
<ol type="1">
<li><em>game restart,</em></li>
<li><em>score keeping,</em></li>
<li><em>game quitting (in more-or-less elegant way).</em></li>
</ol>
<p><strong>Exercise 3:</strong> Our numerical integration function
roughly corresponds to the rectangle rule. Modify the rule and write a
test for the accuracy of:</p>
<ol type="1">
<li><em>the trapezoidal rule;</em></li>
<li>*the Simpson’s</li>
</ol>
<p>rule.* <em><a
href="http://en.wikipedia.org/wiki/Simpson%27s_rule">http://en.wikipedia.org/wiki/Simpson%27s_rule</a></em></p>
<p><strong>Exercise 4:</strong> Explain the recursive behavior of
integration:</p>
<ol type="1">
<li><em>In</em> <em>paddle game</em> <em>implemented by stream
processing –</em> <code>*Lec10b.ml*</code><em>, do we look at past
velocity to determine current position, at past position to determine
current velocity, both, or neither?</em></li>
<li><em>What is the difference between</em> <code>*integral*</code>
<em>and</em> <code>*integral_nice*</code> <em>in</em>
<code>*Lec10c.ml*</code><em>, what happens when we replace the former
with the latter in the</em> <code>*pbal*</code> <em>function? How about
after rewriting</em> <code>*pbal*</code> <em>into pure style as in the
following exercise?</em></li>
</ol>
<p><strong>Exercise 5:</strong> Reimplement the <em>Froc</em> based
paddle ball example in a pure style: rewrite the <code>pbal</code>
function to not use <code>notify_e</code>.</p>
<p><strong>Exercise 6:</strong> * Our implementation of flows is a bit
heavy. One alternative approach is to use continuations, as in
<code>Scala.React</code>. OCaml has a continuations library
<em>Delimcc</em>; for how it can cooperate with <em>Froc</em>, see<a
href="http://ambassadortothecomputers.blogspot.com/2010/08/mixing-monadic-and-direct-style-code.html">http://ambassadortothecomputers.blogspot.com/2010/08/mixing-monadic-and-direct-style-code.html</a></p>
<p><strong>Exercise 7:</strong> Implement <code>parallel</code> for
flows, retaining coarse-grained implementation and using the event queue
from <em>Froc</em> somehow (instead of introducing a new job queue).</p>
<p><strong>Exercise 8:</strong> Add quitting, e.g. via a
<code>'q'</code> key press, to the <em>painter</em> example. Use the
<code>is_cancelled</code> function.</p>
<p><strong>Exercise 9:</strong> Our calculator example is not finished.
Implement entering decimal fractions: add handling of the
<code>dots</code> event.</p>
<p><strong>Exercise 10:</strong> The Flow module has reader monad
functions that have not been discussed on slides:let local f m = fun
emit -&gt; m (fun x -&gt; emit (f x))let localopt f m = fun emit -&gt; m
(fun x -&gt; match f x with None -&gt; () | Some y -&gt; emit y)val
local : (’a -&gt; ’b) -&gt; (’a, ’c) flow -&gt; (’b, ’c) flowval
localopt : (’a -&gt; ’b option) -&gt; (’a, ’c) flow -&gt; (’b, ’c)
flow</p>
<p><em>Implement an example that uses this compositionality-increasing
capability.</em></p>
<p>The Expression Problem</p>
<p>The Expression Problem</p>
<p>Code organization, extensibility and reuse</p>
<ul>
<li><p>Ralf Lämmel lectures on MSDN’s Channel 9:<a
href="http://channel9.msdn.com/Shows/Going+Deep/C9-Lectures-Dr-Ralf-Laemmel-Advanced-Functional-Programming-The-Expression-Problem">The
Expression Problem</a>, <a
href="http://channel9.msdn.com/Shows/Going+Deep/C9-Lectures-Dr-Ralf-Lmmel-Advanced-Functional-Programming-Type-Classes">Haskell’s
Type Classes</a></p></li>
<li><p>The old book <em>Developing Applications with Objective
Caml</em>:<a
href="http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora153.html">Comparison
of Modules and Objects</a>, <a
href="http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora154.html">Extending
Components</a></p></li>
<li><p>The new book <em>Real World OCaml</em>: <a
href="https://realworldocaml.org/v1/en/html/objects.html">Chapter 11:
Objects</a>, <a
href="https://realworldocaml.org/v1/en/html/classes.html">Chapter 12:
Classes</a></p></li>
<li><p>Jacques Garrigue’s <a
href="http://www.math.nagoya-u.ac.jp/~garrigue/papers/variant-reuse.ps.gz">Code
reuse through polymorphic variants</a>,and <a
href="http://www.math.nagoya-u.ac.jp/~garrigue/papers/nakata-icfp2006.pdf">Recursive
Modules for Programming</a> with Keiko Nakata</p></li>
<li><p><a
href="http://caml.inria.fr/pub/docs/manual-ocaml/extn.html#sec246">Extensible
variant types</a></p></li>
<li><p>Graham Hutton’s and Erik Meijer’s <a
href="https://www.cs.nott.ac.uk/~gmh/monparsing.pdf">Monadic Parser
Combinators</a>The Expression Problem: Definition</p></li>
<li><p>The <em>Expression Problem</em>: design an implementation for
expressions, where:</p>
<ul>
<li>new variants of expressions can be added (<em>datatype
extensibility</em>),</li>
<li>new operations on the expressions can be added (<em>functional
extensibility</em>).</li>
</ul></li>
<li><p>By <em>extensibility</em> we mean three conditions:</p>
<ul>
<li>code-level modularization: the new datatype variants, and new
operations, are in separate files,</li>
<li>separate compilation: the files can be compiled and distributed
separately,</li>
<li>static type safety: we do not lose the type checking help and
guarantees.</li>
</ul></li>
<li><p>The name comes from an example: extend a language of expressions
with new constructs:</p>
<ul>
<li>lambda calculus: variables <code>Var</code>, <span
class="math inline">\lambda</span>-abstractions <code>Abs</code>,
function applications <code>App</code>;</li>
<li>arithmetics: variables <code>Var</code>, constants <code>Num</code>,
addition <code>Add</code>, multiplication <code>Mult</code>; …</li>
</ul>
<p>and new oparations:</p>
<ul>
<li>evaluation <code>eval</code>;</li>
<li>pretty-printing to strings <code>string_of</code>;</li>
<li>free variables <code>free_vars</code>; …Functional Programming
Non-solution: ordinary Algebraic Datatypes</li>
</ul></li>
<li><p>Pattern matching makes functional extensibility easy in
functional programming.</p></li>
<li><p>Ensuring datatype extensibility is complicated when using
standard variant types.</p></li>
<li><p>For brevity, we will place examples in a single file, but the
component type and function definitions are not mutually recursive so
can be put in separate modules.</p></li>
<li><p>Non-solution penalty points:</p>
<ul>
<li>Functions implemented for a broader language
(e.g. <code>lexpr_t</code>) cannot be used with a value from a narrower
langugage (e.g. <code>expr_t</code>).</li>
<li>Significant memory (and some time) overhead due to so called
<em>tagging</em>: work of the <code>wrap</code> and <code>unwrap</code>
functions, adding tags e.g. <code>Lambda</code> and
<code>Expr</code>.</li>
<li>Some code bloat due to tagging. For example, deep pattern matching
needs to be manually unrolled and interspersed with calls to
<code>unwrap</code>.</li>
</ul>
<p>Verdict: non-solution, but better than extensible variant types-based
approach (next) and direct OOP approach (later).</p></li>
</ul>
<p>type0.5emvar0.5em=0.5emstringVariables constitute a sub-language of
its own.We treat this sub-language slightly differently – no need for a
dedicated
variant.let0.5emevalvar0.5emwrap0.5emsub0.5em(s0.5em:0.5emvar)0.5em=0.5em0.5emtry0.5emList.assoc0.5ems0.5emsub0.5emwith0.5emNotfound0.5em-&gt;0.5emwrap0.5emstype0.5em’a0.5emlambda0.5em=Here
we define the sub-language of <span
class="math inline">\lambda</span>-expressions.0.5em0.5emVarL0.5emof0.5emvar0.5em|0.5emAbs0.5emof0.5emstring0.5em<em>0.5em’a0.5em|0.5emApp0.5emof0.5em’a0.5em</em>0.5em’aDuring
evaluation, we need to freshen variables to avoid
capturelet0.5emgensym0.5em=0.5emlet0.5emn0.5em=0.5emref0.5em00.5emin0.5emfun0.5em()0.5em-&gt;0.5emincr0.5emn;0.5em”“0.5emˆ0.5emstringofint0.5em!n(mistaking
distinct variables with the same
name).let0.5emevallambda0.5emevalrec0.5emwrap0.5emunwrap0.5emsubst0.5eme0.5em=0.5em0.5emmatch0.5emunwrap0.5eme0.5emwithAlternatively,
unwrapping could use an
exception,0.5em0.5em|0.5emSome0.5em(VarL0.5emv)0.5em-&gt;0.5emevalvar0.5em(fun0.5emv0.5em-&gt;0.5emwrap0.5em(VarL0.5emv))0.5emsubst0.5emv0.5em0.5em|0.5emSome0.5em(App0.5em(l1,0.5eml2))0.5em-&gt;but
we use the option type as it is
safer0.5em0.5em0.5em0.5emlet0.5eml1’0.5em=0.5em<code>evalrec0.5emsubst0.5eml1</code>and
more flexible in this
context.0.5em0.5em0.5em0.5emand0.5eml2’0.5em=0.5emevalrec0.5emsubst0.5eml20.5eminRecursive
processing function returns
expression0.5em0.5em0.5em0.5em(match0.5emunwrap0.5eml1’0.5emwithof the
completed language, we
need0.5em0.5em0.5em0.5em|0.5emSome0.5em(Abs0.5em(s,0.5embody))0.5em-&gt;to
unwrap it into the current
sub-language.0.5em0.5em0.5em0.5em0.5em0.5emevalrec0.5em[s,0.5eml2’]0.5em<code>body</code>The
recursive call is already
wrapped.<code>0.5em0.5em0.5em0.5em</code>|0.5em0.5em _
-&gt;0.5emwrap0.5em(App0.5em(l1’,0.5eml2’)))Wrap into the completed
language.0.5em0.5em0.5emSome0.5em(Abs0.5em(s,0.5eml1))0.5em-&gt;0.5em0.5em0.5em0.5emlet0.5ems’0.5em=0.5emgensym0.5em()0.5eminRename
variable to avoid capture (<span
class="math inline">\alpha</span>-equivalence).0.5em0.5em0.5em0.5emwrap0.5em(Abs0.5em(s’,0.5emevalrec0.5em((s,0.5emwrap0.5em(VarL0.5ems’))::subst)0.5eml1))0.5em0.5em0.5emNone0.5em-&gt;0.5emeFalling-through
when not in the current
sub-language.type0.5emlambdat0.5em=0.5emLambdat0.5emof0.5emlambdat0.5emlambdaDefining
<span class="math inline">\lambda</span>-expressionsas the completed
language,let0.5emrec0.5emeval10.5emsubst0.5em=and the corresponding
<code>eval</code>
function.0.5em0.5emevallambda0.5emeval10.5em0.5em0.5em0.5em(fun0.5eme0.5em-&gt;0.5emLambdat0.5eme)0.5em(fun0.5em(Lambdat0.5eme)0.5em-&gt;0.5emSome0.5eme)0.5emsubsttype0.5em’a0.5emexpr0.5em=The
sub-language of arithmetic
expressions.0.5em0.5emVarE0.5emof0.5emvar0.5em0.5emNum0.5emof0.5emint0.5em0.5emAdd0.5emof0.5em’a0.5em<em>0.5em’a0.5em0.5emMult0.5emof0.5em’a0.5em</em>0.5em’alet0.5emevalexpr0.5emevalrec0.5emwrap0.5emunwrap0.5emsubst0.5eme0.5em=0.5em0.5emmatch0.5emunwrap0.5eme0.5emwith0.5em0.5em0.5emSome0.5em(Num0.5em)0.5em-&gt;0.5eme0.5em0.5em0.5emSome0.5em(VarE0.5emv)0.5em-&gt;0.5em0.5em0.5em0.5emevalvar0.5em(fun0.5emx0.5em-&gt;0.5emwrap0.5em(VarE0.5emx))0.5emsubst0.5emv0.5em0.5em0.5emSome0.5em(Add0.5em(m,0.5emn))0.5em-&gt;0.5em0.5em0.5em0.5emlet0.5emm’0.5em=0.5emevalrec0.5emsubst0.5emm0.5em0.5em0.5em0.5emand0.5emn’0.5em=0.5emevalrec0.5emsubst0.5emn0.5emin0.5em0.5em0.5em0.5em(match0.5emunwrap0.5emm’,0.5emunwrap0.5emn’0.5emwithUnwrapping
to check if the
subexpressions0.5em0.5em0.5em0.5em0.5emSome0.5em(Num0.5emm’),0.5emSome0.5em(Num0.5emn’)0.5em-&gt;got
computed to
values.0.5em0.5em0.5em0.5em0.5em0.5emwrap0.5em(Num0.5em(m’0.5em+0.5emn’))0.5em0.5em0.5em0.5em-&gt;0.5emwrap0.5em(Add0.5em(m’,0.5emn’)))Here
<code>m'</code> and <code>n'</code> are
wrapped.0.5em0.5em0.5emSome0.5em(Mult0.5em(m,0.5emn))0.5em-&gt;0.5em0.5em0.5em0.5emlet0.5emm’0.5em=0.5emevalrec0.5emsubst0.5emm0.5em0.5em0.5em0.5emand0.5emn’0.5em=0.5emevalrec0.5emsubst0.5emn0.5emin0.5em0.5em0.5em0.5em(match0.5emunwrap0.5emm’,0.5emunwrap0.5emn’0.5emwith0.5em0.5em0.5em0.5em0.5emSome0.5em(Num0.5emm’),0.5emSome0.5em(Num0.5emn’)0.5em-&gt;0.5em0.5em0.5em0.5em0.5em0.5emwrap0.5em(Num0.5em(m’0.5em*0.5emn’))0.5em0.5em0.5em0.5em-&gt;0.5emwrap0.5em(Mult0.5em(m’,0.5emn’)))0.5em0.5em0.5emNone0.5em-&gt;0.5emetype0.5emexprt0.5em=0.5emExprt0.5emof0.5emexprt0.5emexprDefining
arithmetic expressionsas the completed
language,let0.5emrec0.5emeval20.5emsubst0.5em=aka. ‘‘tying the recursive
knot’‘.0.5em0.5emevalexpr0.5emeval20.5em0.5em0.5em0.5em(fun0.5eme0.5em-&gt;0.5emExprt0.5eme)0.5em(fun0.5em(Exprt0.5eme)0.5em-&gt;0.5emSome0.5eme)0.5emsubsttype0.5em’a0.5emlexpr0.5em=The
language merging <span class="math inline">\lambda</span>-expressions
and arithmetic
expressions,0.5em0.5emLambda0.5emof0.5em’a0.5emlambda0.5em0.5emExpr0.5emof0.5em’a0.5emexprcan
also be used asa sub-language for further
extensions.let0.5emevallexpr0.5emevalrec0.5emwrap0.5emunwrap0.5emsubst0.5eme0.5em=0.5em0.5emevallambda0.5emevalrec0.5em0.5em0.5em0.5em(fun0.5eme0.5em-&gt;0.5emwrap0.5em(Lambda0.5eme))0.5em0.5em0.5em0.5em(fun0.5eme0.5em-&gt;0.5em0.5em0.5em0.5em0.5em0.5emmatch0.5emunwrap0.5eme0.5emwith0.5em0.5em0.5em0.5em0.5em0.5em0.5emSome0.5em(Lambda0.5eme)0.5em-&gt;0.5emSome0.5eme0.5em0.5em0.5em0.5em0.5em0.5em-&gt;0.5emNone)0.5em0.5em0.5em0.5emsubst0.5em0.5em0.5em0.5em(<code>evalexpr0.5emevalrec</code>We
use the ‘‘fall-through’’ property of
<code>eval_expr``0.5em0.5em0.5em0.5em0.5em0.5em0.5em</code>(fun0.5eme0.5em-&gt;0.5emwrap0.5em(Expr0.5eme))to
combine the
evaluators.0.5em0.5em0.5em0.5em0.5em0.5em0.5em(fun0.5eme0.5em-&gt;0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5emmatch0.5emunwrap0.5eme0.5emwith0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5emSome0.5em(Expr0.5eme)0.5em-&gt;0.5emSome0.5eme0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em-&gt;0.5emNone)0.5em0.5em0.5em0.5em0.5em0.5em0.5emsubst0.5eme)type0.5emlexprt0.5em=0.5emLExprt0.5emof0.5emlexprt0.5emlexprTying
the recursive knot one last
time.let0.5emrec0.5emeval30.5emsubst0.5em=0.5em0.5emevallexpr0.5emeval30.5em0.5em0.5em0.5em(fun0.5eme0.5em-&gt;0.5emLExprt0.5eme)0.5em0.5em0.5em0.5em(fun0.5em(LExprt0.5eme)0.5em-&gt;0.5emSome0.5eme)0.5emsubstLightweight
FP non-solution: Extensible Variant Types</p>
<ul>
<li>Exceptions have always formed an extensible variant type in OCaml,
whose pattern matching is done using the try<span
class="math inline">\ldots</span>with syntax. Since recently, new
extensible variant types can be defined. This augments the normal
function extensibility of FP with straightforward data
extensibility.</li>
<li>Non-solution penalty points:
<ul>
<li>Giving up exhaustivity checking, which is an important aspect of
static type safety.</li>
<li>More natural with “single inheritance” extension chains, although
merging is possible, and demonstrated in our example.</li>
<li>Requires “tying the recursive knot” for functions.</li>
</ul>
Verdict: pleasant-looking, but the worst approach because of possible
bugginess. Unless bug-proneness is not a concern, then the best
approach.</li>
</ul>
<p>type0.5emexpr0.5em=0.5em..This is how extensible variant types are
defined.type0.5emvarname0.5em=0.5emstringtype0.5emexpr0.5em+=0.5emVar0.5emof0.5emstringWe
add a variant
case.let0.5emevalvar0.5emsub0.5em=0.5emfunction0.5em0.5em0.5emVar0.5ems0.5emas0.5emv0.5em-&gt;0.5em(try0.5emList.assoc0.5ems0.5emsub0.5emwith0.5emNotfound0.5em-&gt;0.5emv)0.5em0.5em0.5eme0.5em-&gt;0.5emelet0.5emgensym0.5em=0.5emlet0.5emn0.5em=0.5emref0.5em00.5emin0.5emfun0.5em()0.5em-&gt;0.5emincr0.5emn;0.5em”“0.5em0.5emstringofint0.5em!ntype0.5emexpr0.5em+=0.5emAbs0.5emof0.5emstring0.5em<em>0.5emexpr0.5em0.5emApp0.5emof0.5emexpr0.5em</em>0.5emexprThe
sub-languagesare not differentiated by types, a shortcoming of this
non-solution.let0.5emevallambda0.5emevalrec0.5emsubst0.5em=0.5emfunction0.5em0.5em0.5emVar0.5em0.5emas0.5emv0.5em-&gt;0.5emevalvar0.5emsubst0.5emv0.5em0.5em0.5emApp0.5em(l1,0.5eml2)0.5em-&gt;0.5em0.5em0.5em0.5emlet0.5eml2’0.5em=0.5emevalrec0.5emsubst0.5eml20.5emin0.5em0.5em0.5em0.5em(match0.5emevalrec0.5emsubst0.5eml10.5emwith0.5em0.5em0.5em0.5em0.5emAbs0.5em(s,0.5embody)0.5em-&gt;0.5em0.5em0.5em0.5em0.5em0.5emevalrec0.5em[s,0.5eml2’]0.5embody0.5em0.5em0.5em0.5em0.5eml1’0.5em-&gt;0.5emApp0.5em(l1’,0.5eml2’))0.5em0.5em0.5emAbs0.5em(s,0.5eml1)0.5em-&gt;0.5em0.5em0.5em0.5emlet0.5ems’0.5em=0.5emgensym0.5em()0.5emin0.5em0.5em0.5em0.5emAbs0.5em(s’,0.5emevalrec0.5em((s,0.5emVar0.5ems’)::subst)0.5eml1)0.5em0.5em0.5eme0.5em-&gt;0.5emelet0.5emfreevarslambda0.5emfreevarsrec0.5em=0.5emfunction0.5em0.5em0.5emVar0.5emv0.5em-&gt;0.5em[v]0.5em0.5em0.5emApp0.5em(l1,0.5eml2)0.5em-&gt;0.5emfreevarsrec0.5eml10.5em@0.5emfreevarsrec0.5eml20.5em0.5em0.5emAbs0.5em(s,0.5eml1)0.5em-&gt;0.5em0.5em0.5em0.5emList.filter0.5em(fun0.5emv0.5em-&gt;0.5emv0.5em&lt;&gt;0.5ems)0.5em(freevarsrec0.5eml1)0.5em0.5em-&gt;0.5em[]let0.5emrec0.5emeval10.5emsubst0.5eme0.5em=0.5emevallambda0.5emeval10.5emsubst0.5emelet0.5emrec0.5emfreevars10.5eme0.5em=0.5emfreevarslambda0.5emfreevars10.5emelet0.5emtest10.5em=0.5emApp0.5em(Abs0.5em(”x”,0.5emVar0.5em”x”),0.5emVar0.5em”y”)let0.5emetest0.5em=0.5emeval10.5em[]0.5emtest1let0.5emfvtest0.5em=0.5emfreevars10.5emtest1type0.5emexpr0.5em+=0.5emNum0.5emof0.5emint0.5em0.5emAdd0.5emof0.5emexpr0.5em<em>0.5emexpr0.5em0.5emMult0.5emof0.5emexpr0.5em</em>0.5emexprlet0.5emmapexpr0.5emf0.5em=0.5emfunction0.5em0.5em0.5emAdd0.5em(e1,0.5eme2)0.5em-&gt;0.5emAdd0.5em(f0.5eme1,0.5emf0.5eme2)0.5em0.5em0.5emMult0.5em(e1,0.5eme2)0.5em-&gt;0.5emMult0.5em(f0.5eme1,0.5emf0.5eme2)0.5em0.5em0.5eme0.5em-&gt;0.5emelet0.5emevalexpr0.5emevalrec0.5emsubst0.5eme0.5em=0.5em0.5emmatch0.5emmapexpr0.5em(evalrec0.5emsubst)0.5eme0.5emwith0.5em0.5em0.5emAdd0.5em(Num0.5emm,0.5emNum0.5emn)0.5em-&gt;0.5emNum0.5em(m0.5em+0.5emn)0.5em0.5em0.5emMult0.5em(Num0.5emm,0.5emNum0.5emn)0.5em-&gt;0.5emNum0.5em(m0.5em*0.5emn)0.5em0.5em0.5em(Num0.5em0.5em0.5emAdd0.5em0.5em0.5emMult0.5em)0.5emas0.5eme0.5em-&gt;0.5eme0.5em0.5em0.5eme0.5em-&gt;0.5emelet0.5emfreevarsexpr0.5emfreevarsrec0.5em=0.5emfunction0.5em0.5em0.5emNum0.5em0.5em-&gt;0.5em[]0.5em0.5em0.5emAdd0.5em(e1,0.5eme2)0.5em0.5emMult0.5em(e1,0.5eme2)0.5em-&gt;0.5emfreevarsrec0.5eme10.5em@0.5emfreevarsrec0.5eme20.5em0.5em-&gt;0.5em[]let0.5emrec0.5emeval20.5emsubst0.5eme0.5em=0.5emevalexpr0.5emeval20.5emsubst0.5emelet0.5emrec0.5emfreevars20.5eme0.5em=0.5emfreevarsexpr0.5emfreevars20.5emelet0.5emtest20.5em=0.5emAdd0.5em(Mult0.5em(Num0.5em3,0.5emVar0.5em”x”),0.5emNum0.5em1)let0.5emetest20.5em=0.5emeval20.5em[]0.5emtest2let0.5emfvtest20.5em=0.5emfreevars20.5emtest2let0.5emevallexpr0.5emevalrec0.5emsubst0.5eme0.5em=0.5em0.5emevalexpr0.5emevalrec0.5emsubst0.5em(evallambda0.5emevalrec0.5emsubst0.5eme)let0.5emfreevarslexpr0.5emfreevarsrec0.5eme0.5em=0.5em0.5emfreevarslambda0.5emfreevarsrec0.5eme0.5em@0.5emfreevarsexpr0.5emfreevarsrec0.5emelet0.5emrec0.5emeval30.5emsubst0.5eme0.5em=0.5emevallexpr0.5emeval30.5emsubst0.5emelet0.5emrec0.5emfreevars30.5eme0.5em=0.5emfreevarslexpr0.5emfreevars30.5emelet0.5emtest30.5em=0.5em0.5emApp0.5em(Abs0.5em(“x”,0.5emAdd0.5em(Mult0.5em(Num0.5em3,0.5emVar0.5em”x”),0.5emNum0.5em1)),0.5em0.5em0.5em0.5em0.5em0.5em0.5emNum0.5em2)let0.5emetest30.5em=0.5emeval30.5em[]0.5emtest3let0.5emfvtest30.5em=0.5emfreevars30.5emtest3Object
Oriented Programming: Subtyping</p>
<ul>
<li>OCaml’s <em>objects</em> are values, somewhat similar to
records.</li>
<li>Viewed from the outside, an OCaml object has only <em>methods</em>,
identifying the code with which to respond to messages, i.e. method
invocations.</li>
<li>All methods are <em>late-bound</em>, the object determines what code
is run (i.e. <em>virtual</em> in C++ parlance).</li>
<li><em>Subtyping</em> determines if an object can be used in some
context. OCaml has <em>structural subtyping</em>: the content of the
types concerned decides if an object can be used.</li>
<li>Parametric polymorphism can be used to infer if an object has the
required methods.</li>
</ul>
<p>let0.5emf0.5emx0.5em=0.5emx#mMethod invocation:
object#method.val0.5emf0.5em:0.5em&lt;0.5emm0.5em:0.5em’a;0.5em..0.5em&gt;0.5em-&gt;0.5em’aType
poymorphic in two ways: <code>'a</code> is the method type,.. means that
objects with more methods will be accepted.</p>
<ul>
<li><p>Methods are computed when they are invoked, even if they do not
take arguments.</p></li>
<li><p>We define objects inside object…end (compare: records {…}) using
keywords method for methods, val for constant fields and val mutable for
mutable fields. Constructor arguments can often be used instead of
constant fields:</p>
<p>let0.5emsquare0.5emw0.5em=0.5emobject0.5em0.5emmethod0.5emarea0.5em=0.5emfloatofint0.5em(w0.5em*0.5emw)0.5emmethod0.5emwidth0.5em=0.5emw0.5emend</p></li>
<li><p>Subtyping often needs to be explicit: we write (object :&gt;
supertype) or in more complex cases (object : type :&gt; supertype).</p>
<ul>
<li>Technically speaking, subtyping in OCaml always is explicit, and
<em>open types</em>, containing .., use <em>row polymorphism</em> rather
than subtyping.</li>
</ul></li>
</ul>
<p>let0.5ema0.5em=0.5emobject0.5emmethod0.5emm0.5em=0.5em70.5em0.5emmethod0.5emx0.5em=0.5em”a”0.5emendToy
example: object
typeslet0.5emb0.5em=0.5emobject0.5emmethod0.5emm0.5em=0.5em420.5emmethod0.5emy0.5em=0.5em”b”0.5emendshare
some but not all methods.let0.5eml0.5em=0.5em[a;0.5emb]The exact types
of the objects do not
agree.Error:0.5emThis0.5emexpression0.5emhas0.5emtype0.5em&lt;0.5emm0.5em:0.5emint;0.5emy0.5em:0.5emstring0.5em&gt;0.5em0.5em0.5em0.5em0.5em0.5em0.5embut0.5eman0.5emexpression0.5emwas0.5emexpected0.5emof0.5emtype0.5em&lt;0.5emm0.5em:0.5emint;0.5emx0.5em:0.5emstring0.5em&gt;0.5em0.5em0.5em0.5em0.5em0.5em0.5emThe0.5emsecond0.5emobject0.5emtype0.5emhas0.5emno0.5emmethod0.5emylet0.5eml0.5em=0.5em[(a0.5em:&gt;0.5em&lt;m0.5em:0.5em’a&gt;);0.5em(b0.5em:&gt;0.5em&lt;m0.5em:0.5em’a&gt;)]But
the types share a
supertype.val0.5eml0.5em:0.5em&lt;0.5emm0.5em:0.5emint0.5em&gt;0.5emlist</p>
<ul>
<li><em>Variance</em> determines how type parameters behave wrt.
subtyping:
<ul>
<li><p><em>Invariant parameters</em> cannot be subtyped:</p>
<p>let0.5emf0.5emx0.5em=0.5em(x0.5em:0.5em&lt;m0.5em:0.5emint;0.5emn0.5em:0.5emfloat&gt;0.5emarray0.5em:&gt;0.5em&lt;m0.5em:0.5emint&gt;0.5emarray)Error:0.5emType0.5em&lt;0.5emm0.5em:0.5emint;0.5emn0.5em:0.5emfloat0.5em&gt;0.5emarray0.5emis0.5emnot0.5ema0.5emsubtype0.5emof0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em&lt;0.5emm0.5em:0.5emint0.5em&gt;0.5emarray0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5emThe0.5emsecond0.5emobject0.5emtype0.5emhas0.5emno0.5emmethod0.5emn</p></li>
<li><p><em>Covariant parameters</em> are subtyped in the same direction
as the type:</p>
<p>let0.5emf0.5emx0.5em=0.5em(x0.5em:0.5em&lt;m0.5em:0.5emint;0.5emn0.5em:0.5emfloat&gt;0.5emlist0.5em:&gt;0.5em&lt;m0.5em:0.5emint&gt;0.5emlist)val0.5emf0.5em:0.5em&lt;0.5emm0.5em:0.5emint;0.5emn0.5em:0.5emfloat0.5em&gt;0.5emlist0.5em-&gt;0.5em&lt;0.5emm0.5em:0.5emint0.5em&gt;0.5emlist</p></li>
<li><p><em>Contravariant parameters</em> are subtyped in the opposite
direction:</p>
<p>let0.5emf0.5emx0.5em=0.5em(x0.5em:0.5em&lt;m0.5em:0.5emint;0.5emn0.5em:0.5emfloat&gt;0.5em-&gt;0.5emfloat0.5em:&gt;0.5em&lt;m0.5em:0.5emint&gt;0.5em-&gt;0.5emfloat)Error:0.5emType0.5em&lt;0.5emm0.5em:0.5emint;0.5emn0.5em:0.5emfloat0.5em&gt;0.5em-&gt;0.5emfloat0.5emis0.5emnot0.5ema0.5emsubtype0.5emof0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em&lt;0.5emm0.5em:0.5emint0.5em&gt;0.5em-&gt;0.5emfloat0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5emType0.5em&lt;0.5emm0.5em:0.5emint0.5em&gt;0.5emis0.5emnot0.5ema0.5emsubtype0.5emof0.5em&lt;0.5emm0.5em:0.5emint;0.5emn0.5em:0.5emfloat0.5em&gt;0.5emlet0.5emf0.5emx0.5em=0.5em(x0.5em:0.5em&lt;m0.5em:0.5emint&gt;0.5em-&gt;0.5emfloat0.5em:&gt;0.5em&lt;m0.5em:0.5emint;0.5emn0.5em:0.5emfloat&gt;0.5em-&gt;0.5emfloat)val0.5emf0.5em:0.5em(&lt;0.5emm0.5em:0.5emint0.5em&gt;0.5em-&gt;0.5emfloat)0.5em-&gt;0.5em&lt;0.5emm0.5em:0.5emint;0.5emn0.5em:0.5emfloat0.5em&gt;0.5em-&gt;0.5emfloatObject
Oriented Programming: Inheritance</p></li>
</ul></li>
<li>The system of object classes in OCaml is similar to the module
system.
<ul>
<li>Object classes are not types. Classes are a way to build object
<em>constructors</em> – functions that return objects.</li>
<li>Classes have their types (compare: modules and signatures).</li>
</ul></li>
<li>In OCaml parlance:
<ul>
<li>late binding is not called anything – all methods are late-bound (in
C++ called virtual)</li>
<li>a method or field declared to be defined in sub-classes is
<em>virtual</em> (in C++ called abstract); classes that use virtual
methods or fields are also called virtual</li>
<li>a method that is only visible in sub-classes is <em>private</em> (in
C++ called protected)</li>
<li>a method not visible outside the class is not called anything (in
C++ called private) – provide the type for the class, and omit the
method in the class type (compare: module signatures and
<code>.mli</code> files)</li>
</ul></li>
<li>OCaml allows multiple inheritance, which can be used to implement
<em>mixins</em> as virtual / abstract classes.</li>
<li>Inheritance works somewhat similarly to textual inclusion.</li>
<li>See the excellent examples in <a
href="https://realworldocaml.org/v1/en/html/classes.html">https://realworldocaml.org/v1/en/html/classes.html</a></li>
<li>You can perform <code>ocamlc -i Objects.ml</code> etc. to see
inferred object and class types.</li>
</ul>
<p>OOP Non-solution: direct approach</p>
<ul>
<li>It turns out that although object oriented programming was designed
with data extensibility in mind, it is a bad fit for recursive types,
like in the expression problem. Below is my attempt at solving our
problem using classes – can you do better?</li>
<li>Non-solution penalty points:
<ul>
<li>Functions implemented for a broader language (e.g. corresponding to
<code>lexpr_t</code> on other slides) cannot handle values from a
narrower one (e.g.  corresponding to <code>expr_t</code>).</li>
<li>Writing a new function requires extending the language.</li>
<li>No deep pattern matching.</li>
</ul>
Verdict: non-solution, better only than the extensible variant
types-based approach.</li>
</ul>
<p>type0.5emvarname0.5em=0.5emstringlet0.5emgensym0.5em=0.5emlet0.5emn0.5em=0.5emref0.5em00.5emin0.5emfun0.5em()0.5em-&gt;0.5emincr0.5emn;0.5em”“0.5em0.5emstringofint0.5em!nclass0.5emvirtual0.5em[’lang]0.5emevaluable0.5em=The
abstract class for objects supporting the <code>eval</code>
method.object0.5emFor <span class="math inline">\lambda</span>-calculus,
we need helper
functions:0.5em0.5emmethod0.5emvirtual0.5emeval0.5em:0.5em(varname0.5em<em>0.5em’lang)0.5emlist0.5em-&gt;0.5em’lang0.5em0.5emmethod0.5emvirtual0.5emrename0.5em:0.5emvarname0.5em-&gt;0.5emvarname0.5em-&gt;0.5em<code>'lang</code>renaming
of free
variables,0.5em0.5emmethod0.5emapply0.5em(arg0.5em:0.5em’lang)<span
class="math inline">\beta</span>-reduction if possible (fallback
otherwise).0.5em0.5em0.5em0.5em(fallback0.5em:0.5emunit0.5em-&gt;0.5em’lang)0.5em(subst0.5em:0.5em(varname0.5em</em>0.5em’lang)0.5emlist)0.5em=0.5em0.5em0.5em0.5emfallback0.5em()endclass0.5em[’lang]0.5emvar0.5em(v0.5em:0.5emvarname)0.5em=object0.5em(self)We
name the current object
<code>self</code>.0.5em0.5eminherit0.5em[’lang]0.5emevaluable0.5em0.5emval0.5emv0.5em=0.5emv0.5em0.5emmethod0.5emeval0.5emsubst0.5em=0.5em0.5em0.5em0.5emtry0.5emList.assoc0.5emv0.5emsubst0.5emwith0.5emNotfound0.5em-&gt;0.5emself0.5em0.5emmethod0.5emrename0.5emv10.5emv20.5em=Renaming
a
variable:0.5em0.5em0.5em0.5emif0.5emv0.5em=0.5emv10.5emthen0.5em{&lt;0.5emv0.5em=0.5emv20.5em&gt;}0.5emelse0.5emselfwe
clone the current object putting the new
name.endclass0.5em[’lang]0.5emabs0.5em(v0.5em:0.5emvarname)0.5em(body0.5em:0.5em’lang)0.5em=object0.5em(self)0.5em0.5eminherit0.5em[’lang]0.5emevaluable0.5em0.5emval0.5emv0.5em=0.5emv0.5em0.5emval0.5embody0.5em=0.5embody0.5em0.5emmethod0.5emeval0.5emsubst0.5em=We
do <span class="math inline">\alpha</span>-conversion prior to
evaluation.0.5em0.5em0.5em0.5emlet0.5emv’0.5em=0.5emgensym0.5em()0.5eminAlternatively,
we could evaluate
with0.5em0.5em0.5em0.5em{&lt;0.5emv0.5em=0.5emv’;0.5embody0.5em=0.5em(body#rename0.5emv0.5emv’)#eval0.5emsubst0.5em&gt;}substitution
of <code>v</code>0.5em0.5emmethod0.5emrename0.5emv10.5emv20.5em=by
<code>v_inst v' : 'lang</code> similar to <code>num_inst</code>
below.0.5em0.5em0.5em0.5emif0.5emv0.5em=0.5emv10.5emthen0.5em<code>self</code>Renaming
the free variable <code>v1</code>, so no work if
<code>v=v1</code>.0.5em0.5em0.5em0.5emelse0.5em{&lt;0.5embody0.5em=0.5embody#rename0.5emv10.5emv20.5em&gt;}0.5em0.5emmethod0.5emapply0.5emargsubst0.5em=0.5em0.5em0.5em0.5embody#eval0.5em((v,0.5emarg)::subst)endclass0.5em[’lang]0.5emapp0.5em(f0.5em:0.5em’lang)0.5em(arg0.5em:0.5em’lang)0.5em=object0.5em(self)0.5em0.5eminherit0.5em[’lang]0.5emevaluable0.5em0.5emval0.5emf0.5em=0.5emf0.5em0.5emval0.5emarg0.5em=0.5emarg0.5em0.5emmethod0.5emeval0.5emsubst0.5em=We
use <code>apply</code> to differentiate between
<code>f = abs</code>0.5em0.5em0.5em0.5emlet0.5emarg’0.5em=0.5emarg#eval0.5emsubst0.5emin
(<span class="math inline">\beta</span>-redexes) and
<code>f ≠ abs</code>.0.5em0.5em0.5em0.5emf#apply0.5emarg’0.5em(fun0.5em()0.5em-&gt;0.5em{&lt;0.5emf0.5em=0.5emf#eval0.5emsubst;0.5emarg0.5em=0.5emarg’0.5em&gt;})0.5emsubst0.5em0.5emmethod0.5emrename0.5emv10.5emv20.5em=Cloning
the object ensures that it will be a subtype of
<code>'lang</code>0.5em0.5em0.5em0.5em{&lt;0.5emf0.5em=0.5emf#rename0.5emv10.5emv2;0.5emarg0.5em=0.5emarg#rename0.5emv10.5emv20.5em&gt;}rather
than just
<code>'lang app</code>.endtype0.5emevaluablet0.5em=0.5emevaluablet0.5emevaluableThese
definitions only add nice-looking
types.let0.5emnewvar10.5emv0.5em:0.5emevaluablet0.5em=0.5emnew0.5emvar0.5emvlet0.5emnewabs10.5emv0.5em(body0.5em:0.5emevaluablet)0.5em:0.5emevaluablet0.5em=0.5emnew0.5emabs0.5emv0.5embodyclass0.5emvirtual0.5emcomputemixin0.5em=0.5emobjectFor
evaluating arithmetic expressions we
need0.5em0.5emmethod0.5emcompute0.5em:0.5emint0.5emoption0.5em=0.5emNone0.5em0.5ema
heper method
<code>compute</code>.endclass0.5em[’lang]0.5emvarc0.5emv0.5em=0.5emobjectTo
use <span class="math inline">\lambda</span>-expressions together with
arithmetic
expressions0.5em0.5eminherit0.5em[’lang]0.5em<code>var0.5emv</code>we
need to upgrade them with the helper
method.0.5em0.5eminherit0.5emcomputemixinendclass0.5em[’lang]0.5emabsc0.5emv0.5embody0.5em=0.5emobject0.5em0.5eminherit0.5em[’lang]0.5emabs0.5emv0.5embody0.5em0.5eminherit0.5emcomputemixinendclass0.5em[’lang]0.5emappc0.5emf0.5emarg0.5em=0.5emobject0.5em0.5eminherit0.5em[’lang]0.5emapp0.5emf0.5emarg0.5em0.5eminherit0.5emcomputemixinendclass0.5em[’lang]0.5emnum0.5em(i0.5em:0.5emint)0.5em=A
numerical
constant.object0.5em(self)0.5em0.5eminherit0.5em[’lang]0.5emevaluable0.5em0.5emval0.5emi0.5em=0.5emi0.5em0.5emmethod0.5emeval0.5emsubst0.5em=0.5emself0.5em0.5emmethod0.5emrename0.5em=0.5emself0.5em0.5emmethod0.5emcompute0.5em=0.5emSome0.5emiendclass0.5emvirtual0.5em[’lang]0.5em<code>operation</code>Abstract
class for evaluating arithmetic
operations.0.5em0.5em0.5em0.5em(numinst0.5em:0.5emint0.5em-&gt;0.5em’lang)0.5em(n10.5em:0.5em’lang)0.5em(n20.5em:0.5em’lang)0.5em=object0.5em(self)0.5em0.5eminherit0.5em[’lang]0.5emevaluable0.5em0.5emval0.5emn10.5em=0.5emn10.5em0.5emval0.5emn20.5em=0.5emn20.5em0.5emmethod0.5emeval0.5emsubst0.5em=0.5em0.5em0.5em0.5emlet0.5emself’0.5em=0.5em{&lt;0.5emn10.5em=0.5emn1#eval0.5emsubst;0.5emn20.5em=0.5emn2#eval0.5emsubst0.5em&gt;}0.5emin0.5em0.5em0.5em0.5emmatch0.5emself’#compute0.5emwith0.5em0.5em0.5em0.5em0.5emSome0.5emi0.5em-&gt;0.5em<code>numinst0.5emi</code>We
need to inject the integer as a constant that
is0.5em0.5em0.5em0.5em-&gt;0.5em<code>self'</code>a subtype of
<code>'lang</code>.0.5em0.5emmethod0.5emrename0.5emv10.5emv20.5em=0.5em{&lt;0.5emn10.5em=0.5emn1#rename0.5emv10.5emv2;0.5emn20.5em=0.5emn2#rename0.5emv10.5emv20.5em&gt;}endclass0.5em[’lang]0.5emadd0.5emnuminst0.5emn10.5emn20.5em=object0.5em(self)0.5em0.5eminherit0.5em[’lang]0.5emoperation0.5emnuminst0.5emn10.5emn20.5em0.5emmethod0.5emcompute0.5em=If
<code>compute</code> is called by <code>eval</code>, as
intended,0.5em0.5em0.5em0.5emmatch0.5emn1#compute,0.5emn2#compute0.5emwiththen
<code>n1</code> and <code>n2</code> are already
computed.0.5em0.5em0.5em0.5em0.5emSome0.5emi1,0.5emSome0.5emi20.5em-&gt;0.5emSome0.5em(i10.5em+0.5emi2)0.5em0.5em0.5em0.5em-&gt;0.5emNoneendclass0.5em[’lang]0.5emmult0.5emnuminst0.5emn10.5emn20.5em=object0.5em(self)0.5em0.5eminherit0.5em[’lang]0.5emoperation0.5emnuminst0.5emn10.5emn20.5em0.5emmethod0.5emcompute0.5em=0.5em0.5em0.5em0.5emmatch0.5emn1#compute,0.5emn2#compute0.5emwith0.5em0.5em0.5em0.5em0.5emSome0.5emi1,0.5emSome0.5emi20.5em-&gt;0.5emSome0.5em(i10.5em*0.5emi2)0.5em0.5em0.5em0.5em-&gt;0.5emNoneendclass0.5emvirtual0.5em[’lang]0.5emcomputable0.5em=This
class is defined merely to provide an object type,objectwe could also
define this object type ‘‘by
hand’’.0.5em0.5eminherit0.5em[’lang]0.5emevaluable0.5em0.5eminherit0.5emcomputemixinendtype0.5emcomputablet0.5em=0.5emcomputablet0.5emcomputableNice
types for all the
constructors.let0.5emnewvar20.5emv0.5em:0.5emcomputablet0.5em=0.5emnew0.5emvarc0.5emvlet0.5emnewabs20.5emv0.5em(body0.5em:0.5emcomputablet)0.5em:0.5emcomputablet0.5em=0.5emnew0.5emabsc0.5emv0.5embodylet0.5emnewapp20.5emv0.5em(body0.5em:0.5emcomputablet)0.5em:0.5emcomputablet0.5em=0.5emnew0.5emappc0.5emv0.5embodylet0.5emnewnum20.5emi0.5em:0.5emcomputablet0.5em=0.5emnew0.5emnum0.5emilet0.5emnewadd20.5em(n10.5em:0.5emcomputablet)0.5em(n20.5em:0.5emcomputablet)0.5em:0.5emcomputablet0.5em=0.5em0.5emnew0.5emadd0.5emnewnum20.5emn10.5emn2let0.5emnewmult20.5em(n10.5em:0.5emcomputablet)0.5em(n20.5em:0.5emcomputablet)0.5em:0.5emcomputablet0.5em=0.5em0.5emnew0.5emmult0.5emnewnum20.5emn10.5emn2OOP:
The Visitor Pattern</p>
<ul>
<li>The <em>Visitor Pattern</em> is an object-oriented programming
pattern for turning objects into variants with shallow pattern-matching
(i.e. dispatch based on which variant a value is). It replaces data
extensibility by operation extensibility.</li>
<li>I needed to use imperative features (mutable fields), can you do
better?</li>
<li>Penalty points:
<ul>
<li>Heavy code bloat.</li>
<li>Side-effects appear to be required.</li>
<li>No deep pattern matching.</li>
</ul>
Verdict: poor solution, better than approaches we considered so far, and
worse than approaches we consider next.</li>
</ul>
<p>type0.5em’visitor0.5emvisitable0.5em=0.5em&lt;0.5emaccept0.5em:0.5em’visitor0.5em-&gt;0.5emunit0.5em&gt;The
variants need be visitable.We store the computation as side effect
because of the difficultytype0.5emvarname0.5em=0.5emstringto keep the
visitor polymorphic but have the result typedepend on the
visitor.class0.5em[’visitor]0.5emvar0.5em(v0.5em:0.5emvarname)0.5em=The
<code>'visitor</code> will determine the
(sub)languageobject0.5em(self)to which a given <code>var</code> variant
belongs.0.5em0.5emmethod0.5emv0.5em=0.5emv0.5em0.5emmethod0.5emaccept0.5em:0.5em’visitor0.5em-&gt;0.5emunit0.5em=The
visitor pattern inverts the
way0.5em0.5em0.5em0.5emfun0.5emvisitor0.5em-&gt;0.5emvisitor#visitVar0.5emselfpattern
matching proceeds: the variantendselects the pattern matching
branch.let0.5emnewvar0.5emv0.5em=0.5em(new0.5emvar0.5emv0.5em:&gt;0.5em’a0.5emvisitable)Visitors
need to see the stored data,but distinct constructors need to belong to
the same
type.class0.5em[’visitor]0.5emabs0.5em(v0.5em:0.5emvarname)0.5em(body0.5em:0.5em’visitor0.5emvisitable)0.5em=object0.5em(self)0.5em0.5emmethod0.5emv0.5em=0.5emv0.5em0.5emmethod0.5embody0.5em=0.5embody0.5em0.5emmethod0.5emaccept0.5em:0.5em’visitor0.5em-&gt;0.5emunit0.5em=0.5em0.5em0.5em0.5emfun0.5emvisitor0.5em-&gt;0.5emvisitor#visitAbs0.5emselfendlet0.5emnewabs0.5emv0.5embody0.5em=0.5em(new0.5emabs0.5emv0.5embody0.5em:&gt;0.5em’a0.5emvisitable)class0.5em[’visitor]0.5emapp0.5em(f0.5em:0.5em’visitor0.5emvisitable)0.5em(arg0.5em:0.5em’visitor0.5emvisitable)0.5em=object0.5em(self)0.5em0.5emmethod0.5emf0.5em=0.5emf0.5em0.5emmethod0.5emarg0.5em=0.5emarg0.5em0.5emmethod0.5emaccept0.5em:0.5em’visitor0.5em-&gt;0.5emunit0.5em=0.5em0.5em0.5em0.5emfun0.5emvisitor0.5em-&gt;0.5emvisitor#visitApp0.5emselfendlet0.5emnewapp0.5emf0.5emarg0.5em=0.5em(new0.5emapp0.5emf0.5emarg0.5em:&gt;0.5em’a0.5emvisitable)class0.5emvirtual0.5em[’visitor]0.5emlambdavisit0.5em=This
abstract class has two uses:objectit defines the visitors for the
sub-langauge of <span
class="math inline">\lambda</span>-expressions,0.5em0.5emmethod0.5emvirtual0.5emvisitVar0.5em:0.5em’visitor0.5emvar0.5em-&gt;0.5emunitand
it will provide an early
check0.5em0.5emmethod0.5emvirtual0.5emvisitAbs0.5em:0.5em’visitor0.5emabs0.5em-&gt;0.5emunitthat
the visitor
classes0.5em0.5emmethod0.5emvirtual0.5emvisitApp0.5em:0.5em’visitor0.5emapp0.5em-&gt;0.5emunitimplement
all the
methods.endlet0.5emgensym0.5em=0.5emlet0.5emn0.5em=0.5emref0.5em00.5emin0.5emfun0.5em()0.5em-&gt;0.5emincr0.5emn;0.5em”“0.5em0.5emstringofint0.5em!nclass0.5em[’visitor]0.5em<code>evallambda</code>0.5em0.5em(subst0.5em:0.5em(varname0.5em<em>0.5em’visitor0.5emvisitable)0.5emlist)0.5em0.5em(result0.5em:0.5em’visitor0.5emvisitable0.5emref)0.5em=An
output argument, but also used internallyobject0.5em(self)to store
intermediate
results.0.5em0.5eminherit0.5em[’visitor]0.5emlambdavisit0.5em0.5emval0.5emmutable0.5emsubst0.5em=0.5em<code>subst</code>We
avoid threading the argument through the visit
methods.0.5em0.5emval0.5emmutable0.5embetaredex0.5em:0.5em(varname0.5em</em>0.5em’visitor0.5emvisitable)0.5emoption0.5em=0.5emNoneWe
work around0.5em0.5emmethod0.5emvisitVar0.5emvar0.5em=the need to
differentiate between <code>abs</code> and non-<code>abs</code>
values0.5em0.5em0.5em0.5embetaredex0.5em&lt;-0.5emNone;of app#f inside
<code>visitApp</code>.0.5em0.5em0.5em0.5emtry0.5emresult0.5em:=0.5emList.assoc0.5emvar#v0.5emsubst0.5em0.5em0.5em0.5emwith0.5emNotfound0.5em-&gt;0.5emresult0.5em:=0.5em(var0.5em:&gt;0.5em’visitor0.5emvisitable)0.5em0.5emmethod0.5emvisitAbs0.5emabs0.5em=0.5em0.5em0.5em0.5emlet0.5emv’0.5em=0.5emgensym0.5em()0.5emin0.5em0.5em0.5em0.5emlet0.5emorigsubst0.5em=0.5emsubst0.5emin0.5em0.5em0.5em0.5emsubst0.5em&lt;-0.5em(abs#v,0.5emnew_var0.5emv’)::subst;‘‘Pass’’
the updated
substitution0.5em0.5em0.5em0.5em(abs#body)#accept0.5emself;to the
recursive
call0.5em0.5em0.5em0.5emlet0.5embody’0.5em=0.5em!result0.5eminand
collect the result of the recursive
call.0.5em0.5em0.5em0.5emsubst0.5em&lt;-0.5emorigsubst;0.5em0.5em0.5em0.5embetaredex0.5em&lt;-0.5emSome0.5em(v’,0.5embody’);Indicate
that an <code>abs</code> has just been
visited.0.5em0.5em0.5em0.5emresult0.5em:=0.5emnewabs0.5emv’0.5embody’0.5em0.5emmethod0.5emvisitApp0.5emapp0.5em=0.5em0.5em0.5em0.5emapp#arg#accept0.5emself;0.5em0.5em0.5em0.5emlet0.5emarg’0.5em=0.5em!result0.5emin0.5em0.5em0.5em0.5emapp#f#accept0.5emself;0.5em0.5em0.5em0.5emlet0.5emf’0.5em=0.5em!result0.5emin0.5em0.5em0.5em0.5emmatch0.5embetaredex0.5emwithPattern-match
on
app#f.0.5em0.5em0.5em0.5em0.5emSome0.5em(v’,0.5embody’)0.5em-&gt;0.5em0.5em0.5em0.5em0.5em0.5embetaredex0.5em&lt;-0.5emNone;0.5em0.5em0.5em0.5em0.5em0.5emlet0.5emorigsubst0.5em=0.5emsubst0.5emin0.5em0.5em0.5em0.5em0.5em0.5emsubst0.5em&lt;-0.5em(v’,0.5emarg’)::subst;0.5em0.5em0.5em0.5em0.5em0.5embody’#accept0.5emself;0.5em0.5em0.5em0.5em0.5em0.5emsubst0.5em&lt;-0.5emorigsubst0.5em0.5em0.5em0.5em0.5emNone0.5em-&gt;0.5emresult0.5em:=0.5emnewapp0.5emf’0.5emarg’endclass0.5em[’visitor]0.5emfreevarslambda0.5em(result0.5em:0.5emvarname0.5emlist0.5emref)0.5em=object0.5em(self)We
use <code>result</code> as an
accumulator.0.5em0.5eminherit0.5em[’visitor]0.5emlambdavisit0.5em0.5emmethod0.5emvisitVar0.5emvar0.5em=0.5em0.5em0.5em0.5emresult0.5em:=0.5emvar#v0.5em::0.5em!result0.5em0.5emmethod0.5emvisitAbs0.5emabs0.5em=0.5em0.5em0.5em0.5em(abs#body)#accept0.5emself;0.5em0.5em0.5em0.5emresult0.5em:=0.5emList.filter0.5em(fun0.5emv’0.5em-&gt;0.5emv’0.5em&lt;&gt;0.5emabs#v)0.5em!result0.5em0.5emmethod0.5emvisitApp0.5emapp0.5em=0.5em0.5em0.5em0.5emapp#arg#accept0.5emself;0.5emapp#f#accept0.5emselfendtype0.5emlambdavisitt0.5em=0.5emlambdavisitt0.5emlambdavisitVisitor
for the language of <span
class="math inline">\lambda</span>-expressions.type0.5emlambdat0.5em=0.5emlambdavisitt0.5emvisitablelet0.5emeval10.5em(e0.5em:0.5emlambdat)0.5emsubst0.5em:0.5emlambdat0.5em=0.5em0.5emlet0.5emresult0.5em=0.5emref0.5em(newvar0.5em”“)0.5eminThis
initial value will be
ignored.0.5em0.5eme#accept0.5em(new0.5emevallambda0.5emsubst0.5emresult0.5em:&gt;0.5emlambdavisitt);0.5em0.5em!resultlet0.5emfreevars10.5em(e0.5em:0.5emlambdat)0.5em=0.5em0.5emlet0.5emresult0.5em=0.5emref0.5em[]0.5eminInitial
value of the
accumulator.0.5em0.5eme#accept0.5em(new0.5emfreevarslambda0.5emresult);0.5em0.5em!resultlet0.5emtest10.5em=0.5em0.5em(newapp0.5em(newabs0.5em”x”0.5em(newvar0.5em”x”))0.5em(newvar0.5em”y”)0.5em:&gt;0.5emlambdat)let0.5emetest0.5em=0.5emeval10.5emtest10.5em[]let0.5emfvtest0.5em=0.5emfreevars10.5emtest1class0.5em[’visitor]0.5emnum0.5em(i0.5em:0.5emint)0.5em=object0.5em(self)0.5em0.5emmethod0.5emi0.5em=0.5emi0.5em0.5emmethod0.5emaccept0.5em:0.5em’visitor0.5em-&gt;0.5emunit0.5em=0.5em0.5em0.5em0.5emfun0.5emvisitor0.5em-&gt;0.5emvisitor#visitNum0.5emselfendlet0.5emnewnum0.5emi0.5em=0.5em(new0.5emnum0.5emi0.5em:&gt;0.5em’a0.5emvisitable)class0.5emvirtual0.5em[’visitor]0.5emoperation0.5em0.5em(arg10.5em:0.5em’visitor0.5emvisitable)0.5em(arg20.5em:0.5em’visitor0.5emvisitable)0.5em=object0.5em(self)Shared
accessor
methods.0.5em0.5emmethod0.5emarg10.5em=0.5emarg10.5em0.5emmethod0.5emarg20.5em=0.5emarg2endclass0.5em[’visitor]0.5emadd0.5emarg10.5emarg20.5em=object0.5em(self)0.5em0.5eminherit0.5em[’visitor]0.5emoperation0.5emarg10.5emarg20.5em0.5emmethod0.5emaccept0.5em:0.5em’visitor0.5em-&gt;0.5emunit0.5em=0.5em0.5em0.5em0.5emfun0.5emvisitor0.5em-&gt;0.5emvisitor#visitAdd0.5emselfendlet0.5emnewadd0.5emarg10.5emarg20.5em=0.5em(new0.5emadd0.5emarg10.5emarg20.5em:&gt;0.5em’a0.5emvisitable)class0.5em[’visitor]0.5emmult0.5emarg10.5emarg20.5em=object0.5em(self)0.5em0.5eminherit0.5em[’visitor]0.5emoperation0.5emarg10.5emarg20.5em0.5emmethod0.5emaccept0.5em:0.5em’visitor0.5em-&gt;0.5emunit0.5em=0.5em0.5em0.5em0.5emfun0.5emvisitor0.5em-&gt;0.5emvisitor#visitMult0.5emselfendlet0.5emnewmult0.5emarg10.5emarg20.5em=0.5em(new0.5emmult0.5emarg10.5emarg20.5em:&gt;0.5em’a0.5emvisitable)class0.5emvirtual0.5em[’visitor]0.5emexprvisit0.5em=The
sub-language of arithmetic
expressions.object0.5em0.5emmethod0.5emvirtual0.5emvisitNum0.5em:0.5em’visitor0.5emnum0.5em-&gt;0.5emunit0.5em0.5emmethod0.5emvirtual0.5emvisitAdd0.5em:0.5em’visitor0.5emadd0.5em-&gt;0.5emunit0.5em0.5emmethod0.5emvirtual0.5emvisitMult0.5em:0.5em’visitor0.5emmult0.5em-&gt;0.5emunitendclass0.5em[’visitor]0.5emevalexpr0.5em0.5em(result0.5em:0.5em’visitor0.5emvisitable0.5emref)0.5em=object0.5em(self)0.5em0.5eminherit0.5em[’visitor]0.5emexprvisit0.5em0.5emval0.5emmutable0.5emnumredex0.5em:0.5emint0.5emoption0.5em=0.5emNoneThe
numeric result, if
any.0.5em0.5emmethod0.5emvisitNum0.5emnum0.5em=0.5em0.5em0.5em0.5emnumredex0.5em&lt;-0.5emSome0.5emnum#i;0.5em0.5em0.5em0.5emresult0.5em:=0.5em(num0.5em:&gt;0.5em’visitor0.5emvisitable)0.5em0.5emmethod0.5emprivate0.5emvisitOperation0.5emnewe0.5emop0.5eme0.5em=0.5em0.5em0.5em0.5em(e#arg1)#accept0.5emself;0.5em0.5em0.5em0.5emlet0.5emarg1’0.5em=0.5em!result0.5emand0.5emi10.5em=0.5emnumredex0.5emin0.5em0.5em0.5em0.5em(e#arg2)#accept0.5emself;0.5em0.5em0.5em0.5emlet0.5emarg2’0.5em=0.5em!result0.5emand0.5emi20.5em=0.5emnumredex0.5emin0.5em0.5em0.5em0.5emmatch0.5emi1,0.5emi20.5emwith0.5em0.5em0.5em0.5em0.5emSome0.5emi1,0.5emSome0.5emi20.5em-&gt;0.5em0.5em0.5em0.5em0.5em0.5emlet0.5emres0.5em=0.5emop0.5emi10.5emi20.5emin0.5em0.5em0.5em0.5em0.5em0.5emnumredex0.5em&lt;-0.5emSome0.5emres;0.5emresult0.5em:=0.5emnewnum0.5emres0.5em0.5em0.5em0.5em-&gt;0.5em0.5em0.5em0.5em0.5em0.5emnumredex0.5em&lt;-0.5emNone;0.5em0.5em0.5em0.5em0.5em0.5emresult0.5em:=0.5emnewe0.5emarg1’0.5emarg2’0.5em0.5emmethod0.5emvisitAdd0.5emadd0.5em=0.5emself#visitOperation0.5emnewadd0.5em(0.5em+0.5em)0.5emadd0.5em0.5emmethod0.5emvisitMult0.5emmult0.5em=0.5emself#visitOperation0.5emnewmult0.5em(0.5em*0.5em)0.5emmultendclass0.5em[’visitor]0.5emfreevarsexpr0.5em(result0.5em:0.5emvarname0.5emlist0.5emref)0.5em=Flow-through
classobject0.5em(self)for computing free
variables.0.5em0.5eminherit0.5em[’visitor]0.5emexprvisit0.5em0.5emmethod0.5emvisitNum=0.5em()0.5em0.5emmethod0.5emvisitAdd0.5emadd0.5em=0.5em0.5em0.5em0.5emadd#arg1#accept0.5emself;0.5emadd#arg2#accept0.5emself0.5em0.5emmethod0.5emvisitMult0.5emmult0.5em=0.5em0.5em0.5em0.5emmult#arg1#accept0.5emself;0.5emmult#arg2#accept0.5emselfendtype0.5emexprvisitt0.5em=0.5emexprvisitt0.5emexprvisitThe
language of arithmetic
expressionstype0.5emexprt0.5em=0.5emexprvisitt0.5emvisitable– in this
example without
variables.let0.5emeval20.5em(e0.5em:0.5emexprt)0.5em:0.5emexprt0.5em=0.5em0.5emlet0.5emresult0.5em=0.5emref0.5em(newnum0.5em0)0.5eminThis
initial value will be
ignored.0.5em0.5eme#accept0.5em(new0.5emevalexpr0.5emresult);0.5em0.5em!resultlet0.5emtest20.5em=0.5em0.5em(newadd0.5em(newmult0.5em(newnum0.5em3)0.5em(newnum0.5em3))0.5em(newnum0.5em1)0.5em:&gt;0.5emexprt)let0.5emetest0.5em=0.5emeval20.5emtest2class0.5emvirtual0.5em[’visitor]0.5emlexprvisit0.5em=Combining
the variants /
constructors.object0.5em0.5eminherit0.5em[’visitor]0.5emlambdavisit0.5em0.5eminherit0.5em[’visitor]0.5emexprvisitendclass0.5em[’visitor]0.5emevallexpr0.5emsubst0.5emresult0.5em=Combining
the ‘‘pattern-matching
branches’’.object0.5em0.5eminherit0.5em[’visitor]0.5emevalexpr0.5emresult0.5em0.5eminherit0.5em[’visitor]0.5emevallambda0.5emsubst0.5emresultendclass0.5em[’visitor]0.5emfreevarslexpr0.5emresult0.5em=object0.5em0.5eminherit0.5em[’visitor]0.5emfreevarsexpr0.5emresult0.5em0.5eminherit0.5em[’visitor]0.5emfreevarslambda0.5emresultendtype0.5emlexprvisitt0.5em=0.5emlexprvisitt0.5emlexprvisitThe
language
combiningtype0.5emlexprt0.5em=0.5emlexprvisitt0.5emvisitable<span
class="math inline">\lambda</span>-expressions and arithmetic
expressions.let0.5emeval30.5em(e0.5em:0.5emlexprt)0.5emsubst0.5em:0.5emlexprt0.5em=0.5em0.5emlet0.5emresult0.5em=0.5emref0.5em(newnum0.5em0)0.5emin0.5em0.5eme#accept0.5em(new0.5emevallexpr0.5emsubst0.5emresult);0.5em0.5em!resultlet0.5emfreevars30.5em(e0.5em:0.5emlexprt)0.5em=0.5em0.5emlet0.5emresult0.5em=0.5emref0.5em[]0.5emin0.5em0.5eme#accept0.5em(new0.5emfreevarslexpr0.5emresult);0.5em0.5em!resultlet0.5emtest30.5em=0.5em0.5em(newadd0.5em(newmult0.5em(newnum0.5em3)0.5em(newvar0.5em”x”))0.5em(newnum0.5em1)0.5em:&gt;0.5emlexprt)let0.5emetest0.5em=0.5emeval30.5emtest30.5em[]let0.5emfvtest0.5em=0.5emfreevars30.5emtest3let0.5emoldetest0.5em=0.5emeval30.5em(test20.5em:&gt;0.5emlexprt)0.5em[]let0.5emoldfvtest0.5em=0.5emeval30.5em(test20.5em:&gt;0.5emlexprt)0.5em[]Polymorphic
Variant Types: Subtyping</p>
<ul>
<li><p>Polymorphic variants are to ordinary variants as objects are to
records: both enable <em>open types</em> and subtyping, both allow
different types to share the same components.</p>
<ul>
<li>They are <em>dual</em> concepts in that if we replace “product” of
records / objects by “sum” (see lecture 2), we get variants /
polymorphic variants.Duality implies many behaviors are opposite.</li>
</ul></li>
<li><p>While object subtypes have more methods, polymorphic variant
subtypes have less tags.</p></li>
<li><p>The &gt; sign means “these tags or more”:</p>
<p>let0.5eml0.5em=0.5em[‘Int0.5em3;0.5em‘Float0.5em4.];;val0.5eml0.5em:0.5em[&gt;0.5em‘Float0.5emof0.5emfloat0.5em0.5em‘Int0.5emof0.5emint0.5em]0.5emlist0.5em=0.5em[‘Int0.5em3;0.5em‘Float0.5em4.]</p></li>
<li><p>The &lt; sign means “these tags or less”:</p>
<p>let0.5emispositive0.5em=0.5emfunction0.5em0.5em0.5em0.5em0.5em0.5em‘Int0.5em0.5em0.5emx0.5em-&gt;0.5emSome0.5em(x0.5em&gt;0.5em0)0.5em0.5em0.5em0.5em0.5em0.5em‘Float0.5emx0.5em-&gt;0.5emSome0.5em(x0.5em&gt;0.5em0.)0.5em0.5em0.5em0.5em0.5em0.5em‘Notanumber0.5em-&gt;0.5emNone;;val0.5emispositive0.5em:0.5em0.5em[&lt;0.5em‘Float0.5emof0.5emfloat0.5em0.5em‘Int0.5emof0.5emint0.5em0.5em‘Notanumber0.5em]0.5em-&gt;0.5em
bool0.5emoption0.5em=0.5em<fun></p></li>
<li><p>No sign means a closed type (similar to an object type without
the ..)</p></li>
<li><p>Both an upper and a lower bound are sometimes inferred,see <a
href="https://realworldocaml.org/v1/en/html/variants.html">https://realworldocaml.org/v1/en/html/variants.html</a></p>
<p>List.filter0.5em0.5em(fun0.5emx0.5em-&gt;0.5emmatch0.5emispositive0.5emx0.5emwith0.5emNone0.5em-&gt;0.5emfalse0.5em0.5emSome0.5emb0.5em-&gt;0.5emb)0.5eml;;-0.5em:0.5em[&lt;0.5em‘Float0.5emof0.5emfloat0.5em0.5em‘Int0.5emof0.5emint0.5em0.5em‘Notanumber0.5em&gt;0.5em‘Float0.5em‘Int0.5em]0.5em
list0.5em=[‘Int0.5em3;0.5em‘Float0.5em4.]Polymorphic Variant Types: The
Expression Problem</p></li>
<li><p>Because distinct polymorphic variant types can share the same
tags, the solution to the Expression Problem is
straightforward.</p></li>
<li><p>Penalty points:</p>
<ul>
<li>The need to “tie the recursive knot” separately both at the type
level and the function level. At the function level, an <span
class="math inline">\eta</span>-expansion is required due to <em>value
recursion</em> problem. At the type level, the type variable can be
confusing.</li>
<li>There can be a slight time cost compared to the visitor
pattern-based approach: additional dispatch at each level of type
aggregation (i.e.  merging sub-languages).</li>
</ul>
<p>Verdict: a flexible and concise solution, second-best place.</p></li>
</ul>
<p>type0.5emvar0.5em=0.5em[‘Var0.5emof0.5emstring]let0.5emevalvar0.5emsub0.5em(‘Var0.5ems0.5emas0.5emv0.5em:0.5emvar)0.5em=0.5em0.5emtry0.5emList.assoc0.5ems0.5emsub0.5emwith0.5emNotfound0.5em-&gt;0.5emvtype0.5em’a0.5emlambda0.5em=0.5em0.5em[‘Var0.5emof0.5emstring0.5em0.5em‘Abs0.5emof0.5emstring0.5em<em>0.5em’a0.5em0.5em‘App0.5emof0.5em’a0.5em</em>0.5em’a]let0.5emgensym0.5em=0.5emlet0.5emn0.5em=0.5emref0.5em00.5emin0.5emfun0.5em()0.5em-&gt;0.5emincr0.5emn;0.5em”“0.5em0.5emstringofint0.5em!nlet0.5emevallambda0.5emevalrec0.5emsubst0.5em:0.5em’a0.5emlambda0.5em-&gt;0.5em’a0.5em=0.5emfunction0.5em0.5em0.5em#var0.5emas0.5emv0.5em-&gt;0.5em<code>evalvar0.5emsubst0.5emv</code>We
could also leave the type
open0.5em0.5em0.5em‘App0.5em(l1,0.5eml2)0.5em-&gt;rather than closing it
to
<code>lambda</code>.0.5em0.5em0.5em0.5emlet0.5eml2’0.5em=0.5emevalrec0.5emsubst0.5eml20.5emin0.5em0.5em0.5em0.5em(match0.5emevalrec0.5emsubst0.5eml10.5emwith0.5em0.5em0.5em0.5em0.5em‘Abs0.5em(s,0.5embody)0.5em-&gt;0.5em0.5em0.5em0.5em0.5em0.5emevalrec0.5em[s,0.5eml2’]0.5embody0.5em0.5em0.5em0.5em0.5eml1’0.5em-&gt;0.5em‘App0.5em(l1’,0.5eml2’))0.5em0.5em0.5em‘Abs0.5em(s,0.5eml1)0.5em-&gt;0.5em0.5em0.5em0.5emlet0.5ems’0.5em=0.5emgensym0.5em()0.5emin0.5em0.5em0.5em0.5em‘Abs0.5em(s’,0.5emevalrec0.5em((s,0.5em‘Var0.5ems’)::subst)0.5eml1)let0.5emfreevarslambda0.5emfreevarsrec0.5em:0.5em’a0.5emlambda0.5em-&gt;0.5em’b0.5em=0.5emfunction0.5em0.5em0.5em‘Var0.5emv0.5em-&gt;0.5em[v]0.5em0.5em0.5em‘App0.5em(l1,0.5eml2)0.5em-&gt;0.5emfreevarsrec0.5eml10.5em@0.5emfreevarsrec0.5eml20.5em0.5em0.5em‘Abs0.5em(s,0.5eml1)0.5em-&gt;0.5em0.5em0.5em0.5emList.filter0.5em(fun0.5emv0.5em-&gt;0.5emv0.5em&lt;&gt;0.5ems)0.5em(freevarsrec0.5eml1)type0.5emlambdat0.5em=0.5emlambdat0.5emlambdalet0.5emrec0.5emeval10.5emsubst0.5eme0.5em:0.5emlambdat0.5em=0.5emevallambda0.5emeval10.5emsubst0.5emelet0.5emrec0.5emfreevars10.5em(e0.5em:0.5emlambdat)0.5em=0.5emfreevarslambda0.5emfreevars10.5emelet0.5emtest10.5em=0.5em(‘App0.5em(‘Abs0.5em(”x”,0.5em‘Var0.5em”x”),0.5em‘Var0.5em”y”)0.5em:&gt;0.5emlambdat)let0.5emetest0.5em=0.5emeval10.5em[]0.5emtest1let0.5emfvtest0.5em=0.5emfreevars10.5emtest1type0.5em’a0.5emexpr0.5em=0.5em0.5em[‘Var0.5emof0.5emstring0.5em0.5em‘Num0.5emof0.5emint0.5em0.5em‘Add0.5emof0.5em’a0.5em<em>0.5em’a0.5em0.5em‘Mult0.5emof0.5em’a0.5em</em>0.5em’a]let0.5emmapexpr0.5em(f0.5em:0.5em0.5em-&gt;0.5em’a)0.5em:0.5em’a0.5emexpr0.5em-&gt;0.5em’a0.5em=0.5emfunction0.5em0.5em0.5em#var0.5emas0.5emv0.5em-&gt;0.5emv0.5em0.5em0.5em‘Num0.5em0.5emas0.5emn0.5em-&gt;0.5emn0.5em0.5em0.5em‘Add0.5em(e1,0.5eme2)0.5em-&gt;0.5em‘Add0.5em(f0.5eme1,0.5emf0.5eme2)0.5em0.5em0.5em‘Mult0.5em(e1,0.5eme2)0.5em-&gt;0.5em‘Mult0.5em(f0.5eme1,0.5emf0.5eme2)let0.5emevalexpr0.5emevalrec0.5emsubst0.5em(e0.5em:0.5em’a0.5emexpr)0.5em:0.5em’a0.5em=0.5em0.5emmatch0.5emmapexpr0.5em(evalrec0.5emsubst)0.5eme0.5emwith0.5em0.5em0.5em#var0.5emas0.5emv0.5em-&gt;0.5em<code>evalvar0.5emsubst0.5emv</code>Here
and elsewhere, we could also
factor-out0.5em0.5em<code>0.5em‘</code>Add0.5em(‘Num0.5emm,0.5em‘Num0.5emn)0.5em-&gt;0.5em‘Num0.5em(m0.5em+0.5emn)the
sub-language of
variables.0.5em0.5em0.5em‘Mult0.5em(‘Num0.5emm,0.5em‘Num0.5emn)0.5em-&gt;0.5em‘Num0.5em(m0.5em*0.5emn)0.5em0.5em0.5eme0.5em-&gt;0.5emelet0.5emfreevarsexpr0.5emfreevarsrec0.5em:0.5em’a0.5emexpr0.5em-&gt;0.5em’b0.5em=0.5emfunction0.5em0.5em0.5em‘Var0.5emv0.5em-&gt;0.5em[v]0.5em0.5em0.5em‘Num0.5em0.5em-&gt;0.5em[]0.5em0.5em0.5em‘Add0.5em(e1,0.5eme2)0.5em0.5em‘Mult0.5em(e1,0.5eme2)0.5em-&gt;0.5emfreevarsrec0.5eme10.5em@0.5emfreevarsrec0.5eme2type0.5emexprt0.5em=0.5emexprt0.5emexprlet0.5emrec0.5emeval20.5emsubst0.5eme0.5em:0.5emexprt0.5em=0.5emevalexpr0.5emeval20.5emsubst0.5emelet0.5emrec0.5emfreevars20.5em(e0.5em:0.5emexprt)0.5em=0.5emfreevarsexpr0.5emfreevars20.5emelet0.5emtest20.5em=0.5em(‘Add0.5em(‘Mult0.5em(‘Num0.5em3,0.5em‘Var0.5em”x”),0.5em‘Num0.5em1)0.5em:0.5emexprt)let0.5emetest20.5em=0.5emeval20.5em[“x”,0.5em‘Num0.5em2]0.5emtest2let0.5emfvtest20.5em=0.5emfreevars20.5emtest2type0.5em’a0.5emlexpr0.5em=0.5em[’a0.5emlambda0.5em0.5em’a0.5emexpr]let0.5emevallexpr0.5emevalrec0.5emsubst0.5em:0.5em’a0.5emlexpr0.5em-&gt;0.5em’a0.5em=0.5emfunction0.5em0.5em0.5em#lambda0.5emas0.5emx0.5em-&gt;0.5emevallambda0.5emevalrec0.5emsubst0.5emx0.5em0.5em0.5em#expr0.5emas0.5emx0.5em-&gt;0.5emevalexpr0.5emevalrec0.5emsubst0.5emxlet0.5emfreevarslexpr0.5emfreevarsrec0.5em:0.5em’a0.5emlexpr0.5em-&gt;0.5em’b0.5em=0.5emfunction0.5em0.5em0.5em#lambda0.5emas0.5emx0.5em-&gt;0.5emfreevarslambda0.5emfreevarsrec0.5emx0.5em0.5em0.5em#expr0.5emas0.5emx0.5em-&gt;0.5emfreevarsexpr0.5emfreevarsrec0.5emxtype0.5emlexprt0.5em=0.5emlexprt0.5emlexprlet0.5emrec0.5emeval30.5emsubst0.5eme0.5em:0.5emlexprt0.5em=0.5emevallexpr0.5emeval30.5emsubst0.5emelet0.5emrec0.5emfreevars30.5em(e0.5em:0.5emlexprt)0.5em=0.5emfreevarslexpr0.5emfreevars30.5emelet0.5emtest30.5em=0.5em0.5em(‘App0.5em(‘Abs0.5em(“x”,0.5em‘Add0.5em(‘Mult0.5em(‘Num0.5em3,0.5em‘Var0.5em”x”),0.5em‘Num0.5em1)),0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em‘Num0.5em2)0.5em:0.5emlexprt)let0.5emetest30.5em=0.5emeval30.5em[]0.5emtest3let0.5emfvtest30.5em=0.5emfreevars30.5emtest3let0.5emeoldtest0.5em=0.5emeval30.5em[]0.5em(test20.5em:&gt;0.5emlexprt)let0.5emfvoldtest0.5em=0.5emfreevars30.5em(test20.5em:&gt;0.5emlexprt)Polymorphic
Variants and Recursive Modules</p>
<ul>
<li>Using recursive modules, we can clean-up the confusing or cluttering
aspects of tying the recursive knots: type variables, recursive call
arguments.</li>
<li>We need <em>private types</em>, which for objects and polymorphic
variants means <em>private rows</em>.
<ul>
<li><p>We can conceive of open row types, e.g. [&gt;
‘Int0.5emof0.5emint0.5em0.5em‘String0.5emof0.5emstring] as using a
<em>row variable</em>, e.g. <code>'a</code>:</p>
<p>[‘Int0.5emof0.5emint0.5em0.5em‘String0.5emof0.5emstring0.5em0.5em’a]</p>
<p>and then of private row types as abstracting the row variable:</p>
<p>type0.5emtrowtype0.5emt0.5em=0.5em[‘Int0.5emof0.5emint0.5em0.5em‘String0.5emof0.5emstring0.5em0.5emtrow]</p>
<p>But the actual formalization of private row types is more
complex.</p></li>
</ul></li>
<li>Penalty points:
<ul>
<li>We still need to tie the recursive knots for types, for example
private0.5em[&gt;0.5em’a0.5emlambda]0.5emas0.5em’a.</li>
<li>There can be slight time costs due to the use of functors and
dispatch on merging of sub-languages.</li>
</ul></li>
<li>Verdict: a clean solution, best place.</li>
</ul>
<p>type0.5emvar0.5em=0.5em[‘Var0.5emof0.5emstring]let0.5emevalvar0.5emsubst0.5em(‘Var0.5ems0.5emas0.5emv0.5em:0.5emvar)0.5em=0.5em0.5emtry0.5emList.assoc0.5ems0.5emsubst0.5emwith0.5emNotfound0.5em-&gt;0.5emvtype0.5em’a0.5emlambda0.5em=0.5em0.5em[‘Var0.5emof0.5emstring0.5em0.5em‘Abs0.5emof0.5emstring0.5em<em>0.5em’a0.5em0.5em‘App0.5emof0.5em’a0.5em</em>0.5em’a]module0.5emtype0.5emEval0.5em=sig0.5emtype0.5emexp0.5emval0.5emeval0.5em:0.5em(string0.5em*0.5emexp)0.5emlist0.5em-&gt;0.5emexp0.5em-&gt;0.5emexp0.5emendmodule0.5emLF(X0.5em:0.5emEval0.5emwith0.5emtype0.5emexp0.5em=0.5emprivate0.5em[&gt;0.5em’a0.5emlambda]0.5emas0.5em’a)0.5em=struct0.5em0.5emtype0.5emexp0.5em=0.5emX.exp0.5emlambda0.5em0.5emlet0.5emgensym0.5em=0.5em</p>
<p>let0.5emn0.5em=0.5emref0.5em00.5emin0.5emfun0.5em()0.5em-&gt;0.5emincr0.5emn;0.5em”“0.5em0.5emstringofint0.5em!n0.5em0.5emlet0.5emeval0.5emsubst0.5em:0.5emexp0.5em-&gt;0.5emX.exp0.5em=0.5emfunction0.5em0.5em0.5em0.5em0.5em#var0.5emas0.5emv0.5em-&gt;0.5emevalvar0.5emsubst0.5emv0.5em0.5em0.5em0.5em0.5em‘App0.5em(l1,0.5eml2)0.5em-&gt;0.5em0.5em0.5em0.5em0.5em0.5emlet0.5eml2’0.5em=0.5emX.eval0.5emsubst0.5eml20.5emin0.5em0.5em0.5em0.5em0.5em0.5em(match0.5emX.eval0.5emsubst0.5eml10.5emwith0.5em0.5em0.5em0.5em0.5em0.5em0.5em‘Abs0.5em(s,0.5embody)0.5em-&gt;0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5emX.eval0.5em[s,0.5eml2’]0.5embody0.5em0.5em0.5em0.5em0.5em0.5em0.5eml1’0.5em-&gt;0.5em‘App0.5em(l1’,0.5eml2’))0.5em0.5em0.5em0.5em0.5em‘Abs0.5em(s,0.5eml1)0.5em-&gt;0.5em0.5em0.5em0.5em0.5em0.5emlet0.5ems’0.5em=0.5emgensym0.5em()0.5emin0.5em0.5em0.5em0.5em0.5em0.5em‘Abs0.5em(s’,0.5emX.eval0.5em((s,0.5em‘Var0.5ems’)::subst)0.5eml1)endmodule0.5emrec0.5emLambda0.5em:0.5em(Eval0.5emwith0.5emtype0.5emexp0.5em=0.5emLambda.exp0.5emlambda)0.5em=0.5em0.5emLF(Lambda)module0.5emtype0.5emFreeVars0.5em=sig0.5emtype0.5emexp0.5emval0.5emfreevars0.5em:0.5emexp0.5em-&gt;0.5emstring0.5emlist0.5emendmodule0.5emLFVF(X0.5em:0.5emFreeVars0.5emwith0.5emtype0.5emexp0.5em=0.5emprivate0.5em[&gt;0.5em’a0.5emlambda]0.5emas0.5em’a)0.5em=struct0.5em0.5emtype0.5emexp0.5em=0.5emX.exp0.5emlambda0.5em0.5emlet0.5emfreevars0.5em:0.5emexp0.5em-&gt;0.5em’b0.5em=0.5emfunction0.5em0.5em0.5em0.5em0.5em‘Var0.5emv0.5em-&gt;0.5em[v]0.5em0.5em0.5em0.5em0.5em‘App0.5em(l1,0.5eml2)0.5em-&gt;0.5emX.freevars0.5eml10.5em@0.5emX.freevars0.5eml20.5em0.5em0.5em0.5em0.5em‘Abs0.5em(s,0.5eml1)0.5em-&gt;0.5em0.5em0.5em0.5em0.5em0.5emList.filter0.5em(fun0.5emv0.5em-&gt;0.5emv0.5em&lt;&gt;0.5ems)0.5em(X.freevars0.5eml1)endmodule0.5emrec0.5emLambdaFV0.5em:0.5em(FreeVars0.5emwith0.5emtype0.5emexp0.5em=0.5emLambdaFV.exp0.5emlambda)0.5em=0.5em0.5emLFVF(LambdaFV)let0.5emtest10.5em=0.5em(‘App0.5em(‘Abs0.5em(”x”,0.5em‘Var0.5em”x”),0.5em‘Var0.5em”y”)0.5em:0.5emLambda.exp)let0.5emetest0.5em=0.5emLambda.eval0.5em[]0.5emtest1let0.5emfvtest0.5em=0.5emLambdaFV.freevars0.5emtest1type0.5em’a0.5emexpr0.5em=0.5em0.5em[‘Var0.5emof0.5emstring0.5em0.5em‘Num0.5emof0.5emint0.5em0.5em‘Add0.5emof0.5em’a0.5em<em>0.5em’a0.5em0.5em‘Mult0.5emof0.5em’a0.5em</em>0.5em’a]module0.5emtype0.5emOperations0.5em=sig0.5eminclude0.5emEval0.5eminclude0.5emFreeVars0.5emwith0.5emtype0.5emexp0.5em:=0.5emexp0.5emendmodule0.5emEF(X0.5em:0.5emOperations0.5emwith0.5emtype0.5emexp0.5em=0.5emprivate0.5em[&gt;0.5em’a0.5emexpr]0.5emas0.5em’a)0.5em=struct0.5em0.5emtype0.5emexp0.5em=0.5emX.exp0.5emexpr0.5em0.5emlet0.5emmapexpr0.5emf0.5em=0.5emfunction0.5em0.5em0.5em0.5em0.5em#var0.5emas0.5emv0.5em-&gt;0.5emv0.5em0.5em0.5em0.5em0.5em‘Num0.5em0.5emas0.5emn0.5em-&gt;0.5emn0.5em0.5em0.5em0.5em0.5em‘Add0.5em(e1,0.5eme2)0.5em-&gt;0.5em‘Add0.5em(f0.5eme1,0.5emf0.5eme2)0.5em0.5em0.5em0.5em0.5em‘Mult0.5em(e1,0.5eme2)0.5em-&gt;0.5em‘Mult0.5em(f0.5eme1,0.5emf0.5eme2)0.5em0.5emlet0.5emeval0.5emsubst0.5em(e0.5em:0.5emexp)0.5em:0.5emX.exp0.5em=0.5em0.5em0.5em0.5emmatch0.5emmapexpr0.5em(X.eval0.5emsubst)0.5eme0.5emwith0.5em0.5em0.5em0.5em0.5em#var0.5emas0.5emv0.5em-&gt;0.5emevalvar0.5emsubst0.5emv0.5em0.5em0.5em0.5em0.5em‘Add0.5em(‘Num0.5emm,0.5em‘Num0.5emn)0.5em-&gt;0.5em‘Num0.5em(m0.5em+0.5emn)0.5em0.5em0.5em0.5em0.5em‘Mult0.5em(‘Num0.5emm,0.5em‘Num0.5emn)0.5em-&gt;0.5em‘Num0.5em(m0.5em*0.5emn)0.5em0.5em0.5em0.5em0.5eme0.5em-&gt;0.5eme0.5em0.5emlet0.5emfreevars0.5em:0.5emexp0.5em-&gt;0.5em’b0.5em=0.5emfunction0.5em0.5em0.5em0.5em0.5em‘Var0.5emv0.5em-&gt;0.5em[v]0.5em0.5em0.5em0.5em0.5em‘Num0.5em0.5em-&gt;0.5em[]0.5em0.5em0.5em0.5em0.5em‘Add0.5em(e1,0.5eme2)0.5em0.5em‘Mult0.5em(e1,0.5eme2)0.5em-&gt;0.5emX.freevars0.5eme10.5em@0.5emX.freevars0.5eme2endmodule0.5emrec0.5emExpr0.5em:0.5em(Operations0.5emwith0.5emtype0.5emexp0.5em=0.5emExpr.exp0.5emexpr)0.5em=0.5em0.5emEF(Expr)let0.5emtest20.5em=0.5em(‘Add0.5em(‘Mult0.5em(‘Num0.5em3,0.5em‘Var0.5em”x”),0.5em‘Num0.5em1)0.5em:0.5emExpr.exp)let0.5emetest20.5em=0.5emExpr.eval0.5em[“x”,0.5em‘Num0.5em2]0.5emtest2let0.5emfvstest20.5em=0.5emExpr.freevars0.5emtest2type0.5em’a0.5emlexpr0.5em=0.5em[’a0.5emlambda0.5em0.5em’a0.5emexpr]module0.5emLEF(X0.5em:0.5emOperations0.5emwith0.5emtype0.5emexp0.5em=0.5emprivate0.5em[&gt;0.5em’a0.5emlexpr]0.5emas0.5em’a)0.5em=struct0.5em0.5emtype0.5emexp0.5em=0.5emX.exp0.5emlexpr0.5em0.5emmodule0.5emLambdaX0.5em=0.5emLF(X)0.5em0.5emmodule0.5emLambdaFVX0.5em=0.5emLFVF(X)0.5em0.5emmodule0.5emExprX0.5em=0.5emEF(X)0.5em0.5emlet0.5emeval0.5emsubst0.5em:0.5emexp0.5em-&gt;0.5emX.exp0.5em=0.5emfunction0.5em0.5em0.5em0.5em0.5em#LambdaX.exp0.5emas0.5emx0.5em-&gt;0.5emLambdaX.eval0.5emsubst0.5emx0.5em0.5em0.5em0.5em0.5em#ExprX.exp0.5emas0.5emx0.5em-&gt;0.5emExprX.eval0.5emsubst0.5emx0.5em0.5emlet0.5emfreevars0.5em:0.5emexp0.5em-&gt;0.5em’b0.5em=0.5emfunction0.5em0.5em0.5em0.5em0.5em#lambda0.5emas0.5emx0.5em-&gt;0.5emLambdaFVX.freevars0.5emxEither
of #lambda or #LambdaX.exp is
fine.<code>0.5em0.5em0.5em0.5em</code>0.5em#expr0.5emas0.5emx0.5em-&gt;0.5emExprX.freevars0.5emxEither
of #expr or #ExprX.exp is
fine.endmodule0.5emrec0.5emLExpr0.5em:0.5em(Operations0.5emwith0.5emtype0.5emexp0.5em=0.5emLExpr.exp0.5emlexpr)0.5em=0.5em0.5emLEF(LExpr)let0.5emtest30.5em=0.5em0.5em(‘App0.5em(‘Abs0.5em(“x”,0.5em‘Add0.5em(‘Mult0.5em(‘Num0.5em3,0.5em‘Var0.5em”x”),0.5em‘Num0.5em1)),0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em‘Num0.5em2)0.5em:0.5emLExpr.exp)let0.5emetest30.5em=0.5emLExpr.eval0.5em[]0.5emtest3let0.5emfvtest30.5em=0.5emLExpr.freevars0.5emtest3let0.5emeoldtest0.5em=0.5emLExpr.eval0.5em[]0.5em(test20.5em:&gt;0.5emLExpr.exp)let0.5emfvoldtest0.5em=0.5emLExpr.freevars0.5em(test20.5em:&gt;0.5emLExpr.exp)Digression:
Parser Combinators</p>
<ul>
<li><p>We have done parsing using external languages OCamlLex and
Menhir, now we will look at parsers written directly in OCaml.</p></li>
<li><p>Language <em>combinators</em> are ways defining languages by
composing definitions of smaller languages. For example, the combinators
of the <em>Extended Backus-Naur Form</em> notation are:</p>
<ul>
<li>concatenation: <span class="math inline">S = A, B</span> stands for
<span class="math inline">S = \lbrace a b|a \in A, b \in b
\rbrace</span>,</li>
<li>alternation: <span class="math inline">S = A|B</span> stands for
<span class="math inline">S = \lbrace a|a \in A \vee a \in B
\rbrace</span>,</li>
<li>option: <span class="math inline">S = [A]</span> stands for <span
class="math inline">S = \lbrace \epsilon \rbrace \cup A</span>, where
<span class="math inline">\epsilon</span> is an empty string,</li>
<li>repetition: <span class="math inline">S = \lbrace A \rbrace</span>
stands for <span class="math inline">S = \lbrace \epsilon
\rbrace \cup \lbrace a s|a \in A, s \in S \rbrace</span>,</li>
<li>terminal string: <span class="math inline">S =&#39;&#39;
a&#39;&#39;</span> stands for <span class="math inline">S = \lbrace a
\rbrace</span>.</li>
</ul></li>
<li><p>Parsers implemented directly in a functional programming paradigm
are functions from character streams to the parsed values.
Algorithmically they are <em>recursive descent parsers</em>.</p></li>
<li><p><em>Parser combinators</em> approach builds parsers as <em>monad
plus</em> values:</p>
<ul>
<li><p>Bind:
<code>val (&gt;&gt;=) : 'a parser -&gt; ('a -&gt; 'b parser) -&gt;  'b parser</code></p>
<ul>
<li><code>p &gt;&gt;= f</code> is a parser that first parses
<code>p</code>, and makes the result available for parsing
<code>f</code>.</li>
</ul></li>
<li><p>Return: <code>val return : 'a -&gt; 'a parser</code></p>
<ul>
<li><code>return x</code> parses an empty string, symbolically <span
class="math inline">S = \lbrace \epsilon
\rbrace</span>, and returns <code>x</code>.</li>
</ul></li>
<li><p>MZero: <code>val fail : 'a parser</code></p>
<ul>
<li><code>fail</code> fails to parse anything, symbolically <span
class="math inline">S = \varnothing = \lbrace
\rbrace</span>.</li>
</ul></li>
<li><p>MPlus: either
<code>val &lt;|&gt; : 'a parser -&gt; 'a parser -&gt; 'a  parser</code>,</p>
<p>or
<code>val &lt;|&gt; : 'a parser -&gt; 'b parser -&gt; ('a, 'b) choice  parser</code></p>
<ul>
<li><code>p &lt;|&gt; q</code> tries <code>p</code>, and if
<code>p</code> succeeds, its result is returned, otherwise the parser
<code>q</code> is used.</li>
</ul></li>
</ul>
<p>The only non-monad-plus operation that has to be built into the monad
is some way to consume a single character from the input stream, for
example:</p>
<ul>
<li><code>val satisfy : (char -&gt; bool) -&gt; char parser</code>
<ul>
<li><code>satisfy (fun c -&gt; c = 'a')</code> consumes the character
“a” from the input stream and returns it; if the input stream starts
with a different character, this parser fails.</li>
</ul></li>
</ul></li>
<li><p>Ordinary monadic recursive descent parsers <strong>do not
allow</strong> <em>left-recursion</em>: if a cycle of calls not
consuming any character can be entered when a parse failure should
occur, the cycle will keep repeating.</p>
<ul>
<li>For example, if we define numbers <span class="math inline">N := D |
N D</span>, where <span class="math inline">D</span> stands for digits,
then a stack of uses of the rule <span class="math inline">N \rightarrow
N D</span> will build up when the next character is not a digit.</li>
<li>On the other hand, rules can share common prefixes.Parser
Combinators: Implementation</li>
</ul></li>
<li><p>The parser monad is actually a composition of two monads:</p>
<ul>
<li>the state monad for storing the stream of characters that remain to
be parsed,</li>
<li>the backtracking monad for handling parse failures and
ambiguities.</li>
</ul>
<p>Alternatively, one can split the state monad into a reader monad with
the parsed string, and a state monad with the parsing position.</p></li>
<li><p>Recall Lecture 8, especially slides 54-63.</p></li>
<li><p>On my new OPAM installation of OCaml, I run the parsing example
with:</p>
<p><code>ocamlbuild Plugin1.cmxs -pp "camlp4o  /home/lukstafi/.opam/4.02.1/lib/monad-custom/pa_monad.cmo"</code></p>
<p><code>ocamlbuild Plugin2.cmxs -pp "camlp4o  /home/lukstafi/.opam/4.02.1/lib/monad-custom/pa_monad.cmo"</code></p>
<p><code>ocamlbuild PluginRun.native -lib dynlink -pp "camlp4o  ~/.opam/4.02.1/lib/monad-custom/pa_monad.cmo" -- "(3*(6+1))"  _build/Plugin1.cmxs _build/Plugin2.cmxs</code></p></li>
<li><p>We experiment with a different approach to <em>monad-plus</em>.
The merits of this approach (or lack thereof) is left as an exercise.
<em>lazy-monad-plus</em>:</p>
<p>val0.5emmplus0.5em:0.5em’a0.5emmonad
-&gt;0.5em’a0.5emmonad0.5emLazy.t0.5em-&gt;0.5em’a0.5emmonad</p></li>
</ul>
<p>Parser Combinators: Implementation of lazy-monad-plus</p>
<ul>
<li>Excerpts from <code>Monad.ml</code>. First an operation from
MonadPlusOps.</li>
</ul>
<p>0.5em0.5emlet0.5emmsummap0.5emf0.5eml0.5em=0.5em0.5em0.5em0.5emList.<code>foldleft</code>Folding
left reversers the apparent order of
composition,<code>0.5em0.5em0.5em0.5em0.5em0.5em</code>(fun0.5emacc0.5ema0.5em-&gt;0.5emmplus0.5emacc0.5em(lazy0.5em(f0.5ema)))0.5emmzero0.5emlorder
from <code>l</code> is preserved.</p>
<ul>
<li>The implementation of the lazy-monad-plus.</li>
</ul>
<p>type0.5em’a0.5emllist0.5em=0.5emLNil0.5em0.5emLCons0.5emof0.5em’a0.5em<em>0.5em’a0.5emllist0.5emLazy.tlet0.5emrec0.5emltake0.5emn0.5em=0.5emfunction0.5em0.5emLCons0.5em(a,0.5eml)0.5emwhen0.5emn0.5em&gt;0.5em10.5em-&gt;0.5ema::(ltake0.5em(n-1)0.5em(Lazy.force0.5eml))0.5em0.5emLCons0.5em(a,0.5eml)0.5emwhen0.5emn0.5em=0.5em10.5em-&gt;0.5em[a]Avoid
forcing the tail if not
needed.0.5em-&gt;0.5em[]let0.5emrec0.5emlappend0.5eml10.5eml20.5em=0.5em0.5emmatch0.5eml10.5emwith0.5emLNil0.5em-&gt;0.5emLazy.<code>force0.5eml2</code>0.5em0.5em0.5emLCons0.5em(hd,0.5emtl)0.5em-&gt;
LCons0.5em(hd,0.5emlazy0.5em(lappend0.5em(Lazy.force0.5emtl)0.5eml2))let0.5emrec0.5emlconcatmap0.5emf0.5em=0.5emfunction0.5em0.5em0.5emLNil0.5em-&gt;0.5emLNil0.5em0.5em0.5emLCons0.5em(a,0.5eml)0.5em-&gt;0.5emlappend0.5em(f0.5ema)0.5em(lazy0.5em(lconcatmap0.5emf0.5em(Lazy.force0.5eml)))module0.5emLListM0.5em=0.5emMonadPlus0.5em(struct0.5em0.5emtype0.5em’a0.5emt0.5em=0.5em’a0.5emllist0.5em0.5emlet0.5embind0.5ema0.5emb0.5em=0.5emlconcatmap0.5emb0.5ema0.5em0.5emlet0.5emreturn0.5ema0.5em=0.5emLCons0.5em(a,0.5emlazy0.5emLNil)0.5em0.5emlet0.5emmzero0.5em=0.5emLNil0.5em0.5emlet0.5emmplus0.5em=0.5emlappendend)Parser
Combinators: the </em>Parsec* Monad</p>
<ul>
<li>File <code>Parsec.ml</code>:</li>
</ul>
<p>open0.5emMonadmodule0.5emtype0.5emPARSE0.5em=0.5emsig0.5em0.5emtype0.5em<code>'a0.5embacktrackingmonad</code>Name
for the underlying
monad-plus.0.5em0.5emtype0.5em’a0.5emparsingstate0.5em=0.5emint0.5em-&gt;0.5em(‘a0.5em<em>0.5emint)0.5em<code>backtrackingmonad</code>Processing
state –
position.0.5em0.5emtype0.5em’a0.5emt0.5em=0.5emstring0.5em-&gt;0.5em<code>'a0.5emparsingstate</code>Reader
for the parsed
text.0.5em0.5eminclude0.5emMONADPLUSOPS0.5em0.5emval0.5em(&lt;&gt;)0.5em:0.5em’a0.5emmonad0.5em-&gt;0.5em’a0.5emmonad0.5emLazy.t0.5em-&gt;0.5em<code>'a0.5emmonad</code>A
synonym for
<code>mplus</code>.0.5em0.5emval0.5emrun0.5em:0.5em’a0.5emmonad0.5em-&gt;0.5em’a0.5emt0.5em0.5emval0.5emrunT0.5em:0.5em’a0.5emmonad0.5em-&gt;0.5emstring0.5em-&gt;0.5emint0.5em-&gt;0.5em’a0.5embacktrackingmonad0.5em0.5emval0.5emsatisfy0.5em:0.5em(char0.5em-&gt;0.5embool)0.5em-&gt;0.5em<code>char0.5emmonad</code>Consume
a character of the specified
class.0.5em0.5emval0.5emendoftext0.5em:0.5emunit0.5emmonadCheck for end
of the processed
text.endmodule0.5emParseT0.5em(MP0.5em:0.5emMONADPLUSOPS)0.5em:0.5em0.5emPARSE0.5emwith0.5emtype0.5em’a0.5embacktrackingmonad0.5em:=0.5em’a0.5emMP.monad0.5em=struct0.5em0.5emtype0.5em’a0.5embacktrackingmonad0.5em=0.5em’a0.5emMP.monad0.5em0.5emtype0.5em’a0.5emparsingstate0.5em=0.5emint0.5em-&gt;0.5em(’a0.5em</em>0.5emint)0.5emMP.monad0.5em0.5emmodule0.5emM0.5em=0.5emstruct0.5em0.5em0.5em0.5emtype0.5em’a0.5emt0.5em=0.5emstring0.5em-&gt;0.5em’a0.5emparsingstate0.5em0.5em0.5em0.5em0.5emlet0.5emreturn0.5ema0.5em=0.5emfun0.5ems0.5emp0.5em-&gt;0.5emMP.return0.5em(a,0.5emp)0.5em0.5em0.5em0.5emlet0.5embind0.5emm0.5emb0.5em=0.5emfun0.5ems0.5emp0.5em-&gt;0.5em0.5em0.5em0.5em0.5em0.5emMP.bind0.5em(m0.5ems0.5emp)0.5em(fun0.5em(a,0.5emp’)0.5em-&gt;0.5emb0.5ema0.5ems0.5emp’)0.5em0.5em0.5em0.5emlet0.5emmzero0.5em=0.5emfun0.5em0.5em_0.5em-&gt;0.5emMP.mzero0.5em0.5em0.5em0.5emlet0.5emmplus0.5emma0.5emmb0.5em=0.5emfun0.5ems0.5emp0.5em-&gt;0.5em0.5em0.5em0.5em0.5em0.5emMP.mplus0.5em(ma0.5ems0.5emp)0.5em(lazy0.5em(Lazy.force0.5emmb0.5ems0.5emp))0.5em0.5emend0.5em0.5eminclude0.5emM0.5em0.5eminclude0.5emMonadPlusOps(M)0.5em0.5emlet0.5em(&lt;&gt;)0.5emma0.5emmb0.5em=0.5emmplus0.5emma0.5emmb0.5em0.5emlet0.5emrunT0.5emm0.5ems0.5emp0.5em=0.5emMP.lift0.5emfst0.5em(m0.5ems0.5emp)0.5em0.5emlet0.5emsatisfy0.5emf0.5ems0.5emp0.5em=0.5em0.5em0.5em0.5emif0.5emp0.5em&lt;0.5emString.length0.5ems0.5em&amp;&amp;0.5emf0.5ems.[p]Consuming
a character means accessing
it0.5em0.5em0.5em0.5emthen0.5emMP.return0.5em(s.[p],0.5emp0.5em+0.5em1)0.5emelse0.5emMP.<code>mzero</code>and
advancing the parsing
position.0.5em0.5emlet0.5emendoftext0.5ems0.5emp0.5em=0.5em0.5em0.5em0.5emif0.5emp0.5em&gt;=0.5emString.length0.5ems0.5emthen0.5emMP.return0.5em((),0.5emp)0.5emelse0.5emMP.mzeroendmodule0.5emtype0.5emPARSEOPS0.5em=0.5emsig0.5em0.5eminclude0.5emPARSE0.5em0.5emval0.5emmany0.5em:0.5em’a0.5emmonad0.5em-&gt;0.5em’a0.5emlist0.5emmonad0.5em0.5emval0.5emopt0.5em:0.5em’a0.5emmonad0.5em-&gt;0.5em’a0.5emoption0.5emmonad0.5em0.5emval0.5em(?)0.5em:0.5em’a0.5emmonad0.5em-&gt;0.5em’a0.5emoption0.5emmonad0.5em0.5emval0.5emseq0.5em:0.5em’a0.5emmonad0.5em-&gt;0.5em’b0.5emmonad0.5emLazy.t0.5em-&gt;0.5em(‘a0.5em<em>0.5em’b)0.5em<code>monad</code>Exercise:
why laziness
here?0.5em0.5emval0.5em(&lt;</em>&gt;)0.5em:0.5em’a0.5emmonad0.5em-&gt;0.5em’b0.5emmonad0.5emLazy.t0.5em-&gt;0.5em(’a0.5em<em>0.5em’b)0.5em<code>monad</code>Synonym
for
<code>seq</code>.0.5em0.5emval0.5emlowercase0.5em:0.5emchar0.5emmonad0.5em0.5emval0.5emuppercase0.5em:0.5emchar0.5emmonad0.5em0.5emval0.5emdigit0.5em:0.5emchar0.5emmonad0.5em0.5emval0.5emalpha0.5em:0.5emchar0.5emmonad0.5em0.5emval0.5emalphanum0.5em:0.5emchar0.5emmonad0.5em0.5emval0.5emliteral0.5em:0.5emstring0.5em-&gt;0.5emunit0.5em<code>monad</code>Consume
characters of the given
string.0.5em0.5emval0.5em(&lt;&lt;&gt;)0.5em:0.5emstring0.5em-&gt;0.5em’a0.5emmonad0.5em-&gt;0.5em<code>'a0.5emmonad</code>Prefix
and postfix
keywords.0.5em0.5emval0.5em(&lt;&gt;&gt;)0.5em:0.5em’a0.5emmonad0.5em-&gt;0.5emstring0.5em-&gt;0.5em’a0.5emmonadendmodule0.5emParseOps0.5em(R0.5em:0.5emMONADPLUSOPS)0.5em0.5em(P0.5em:0.5emPARSE0.5emwith0.5emtype0.5em’a0.5embacktrackingmonad0.5em:=0.5em’a0.5emR.monad)0.5em:0.5em0.5emPARSEOPS0.5emwith0.5emtype0.5em’a0.5embacktrackingmonad0.5em:=0.5em’a0.5emR.monad0.5em=struct0.5em0.5eminclude0.5emP0.5em0.5emlet0.5emrec0.5emmany0.5emp0.5em=0.5em0.5em0.5em0.5em(perform0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5emr0.5em&lt;–0.5emp;0.5emrs0.5em&lt;–0.5emmany0.5emp;0.5emreturn0.5em(r::rs))0.5em0.5em0.5em0.5em++0.5emlazy0.5em(return0.5em[])0.5em0.5emlet0.5emopt0.5emp0.5em=0.5em(p0.5em&gt;&gt;=0.5em(fun0.5emx0.5em-&gt;0.5emreturn0.5em(Some0.5emx)))0.5em++0.5emlazy0.5em(return0.5emNone)0.5em0.5emlet0.5em(?)0.5emp0.5em=0.5emopt0.5emp0.5em0.5emlet0.5emseq0.5emp0.5emq0.5em=0.5emperform0.5em0.5em0.5em0.5em0.5em0.5emx0.5em&lt;–0.5emp;0.5emy0.5em&lt;–0.5emLazy.force0.5emq;0.5emreturn0.5em(x,0.5emy)0.5em0.5emlet0.5em(&lt;</em>&gt;)0.5emp0.5emq0.5em=0.5emseq0.5emp0.5emq0.5em0.5emlet0.5emlowercase0.5em=0.5emsatisfy0.5em(fun0.5emc0.5em-&gt;0.5emc0.5em&gt;=0.5em’a’0.5em&amp;&amp;0.5emc0.5em&lt;=0.5em’z’)0.5em0.5emlet0.5emuppercase0.5em=0.5emsatisfy0.5em(fun0.5emc0.5em-&gt;0.5emc0.5em&gt;=0.5em’A’0.5em&amp;&amp;0.5emc0.5em&lt;=0.5em’Z’)0.5em0.5emlet0.5emdigit0.5em=0.5emsatisfy0.5em(fun0.5emc0.5em-&gt;0.5emc0.5em&gt;=0.5em’0’0.5em&amp;&amp;0.5emc0.5em&lt;=0.5em’9’)0.5em0.5emlet0.5emalpha0.5em=0.5emlowercase0.5em++0.5emlazy0.5emuppercase0.5em0.5emlet0.5emalphanum0.5em=0.5emalpha0.5em++0.5emlazy0.5emdigit0.5em0.5emlet0.5emliteral0.5eml0.5em=0.5em0.5em0.5em0.5emlet0.5emrec0.5emloop0.5empos0.5em=0.5em0.5em0.5em0.5em0.5em0.5emif0.5empos0.5em=0.5emString.length0.5eml0.5emthen0.5emreturn0.5em()0.5em0.5em0.5em0.5em0.5em0.5emelse0.5emsatisfy0.5em(fun0.5emc0.5em-&gt;0.5emc0.5em=0.5eml.[pos])0.5em&gt;&gt;-0.5emloop0.5em(pos0.5em+0.5em1)0.5emin0.5em0.5em0.5em0.5emloop0.5em00.5em0.5emlet0.5em(&lt;&lt;&gt;)0.5embra0.5emp0.5em=0.5emliteral0.5embra0.5em&gt;&gt;-0.5emp0.5em0.5emlet0.5em(&lt;&gt;&gt;)0.5emp0.5emket0.5em=0.5emp0.5em&gt;&gt;=0.5em(fun0.5emx0.5em-&gt;0.5emliteral0.5emket0.5em&gt;&gt;-0.5emreturn0.5emx)endParser
Combinators: Tying the Recursive Knot</p>
<ul>
<li>File <code>PluginBase.ml</code>:</li>
</ul>
<p>module0.5emParseM0.5em=0.5em0.5emParsec.ParseOps0.5em(Monad.LListM)0.5em(Parsec.ParseT0.5em(Monad.LListM))open0.5emParseMlet0.5emgrammarrules0.5em:0.5em(int0.5emmonad0.5em-&gt;0.5emint0.5emmonad)0.5emlist0.5emref0.5em=0.5emref0.5em[]let0.5emgetlanguage0.5em()0.5em:0.5emint0.5emmonad0.5em=0.5em0.5emlet0.5emrec0.5emresult0.5em=0.5em0.5em0.5em0.5emlazy0.5em0.5em0.5em0.5em0.5em0.5em(List.foldleft0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em(fun0.5emacc0.5emlang0.5em-&gt;0.5emacc0.5em&lt;&gt;0.5emlazy0.5em(lang0.5em(Lazy.force0.5emresult)))0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5emmzero0.5em!grammarrules)0.5eminEnsure
we parse the whole
text.0.5em0.5emperform0.5emr0.5em&lt;–0.5emLazy.force0.5emresult;0.5emendoftext;0.5emreturn0.5emrParser
Combinators: Dynamic Code Loading</p>
<ul>
<li>File <code>PluginRun.ml</code>:</li>
</ul>
<p>let0.5emloadplug0.5emfname0.5em:0.5emunit0.5em=0.5em0.5emlet0.5emfname0.5em=0.5emDynlink.adaptfilename0.5emfname0.5emin0.5em0.5emif0.5emSys.fileexists0.5emfname0.5emthen0.5em0.5em0.5em0.5emtry0.5emDynlink.loadfile0.5emfname0.5em0.5em0.5em0.5emwith0.5em0.5em0.5em0.5em0.5em0.5em(Dynlink.Error0.5emerr)0.5emas0.5eme0.5em-&gt;0.5em0.5em0.5em0.5em0.5em0.5emPrintf.printf0.5em”0.5emloading0.5emplugin:0.5em%s%!“0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em(Dynlink.errormessage0.5emerr);0.5em0.5em0.5em0.5em0.5em0.5emraise0.5eme0.5em0.5em0.5em0.5em0.5eme0.5em-&gt;0.5emPrintf.printf0.5em”0.5emerror0.5emwhile0.5emloading0.5emplugin%!“0.5em0.5emelse0.5em(0.5em0.5em0.5em0.5emPrintf.printf0.5em”0.5emfile0.5em%s0.5emdoes0.5emnot0.5emexist%!“0.5emfname;0.5em0.5em0.5em0.5emexit0.5em(-1))let0.5em()0.5em=0.5em0.5emfor0.5emi0.5em=0.5em20.5emto0.5emArray.length0.5emSys.argv0.5em-0.5em10.5emdo0.5em0.5em0.5em0.5emloadplug0.5emSys.argv.(i)0.5emdone;0.5em0.5emlet0.5emlang0.5em=0.5emPluginBase.getlanguage0.5em()0.5emin0.5em0.5emlet0.5emresult0.5em=0.5em0.5em0.5em0.5emMonad.LListM.run0.5em0.5em0.5em0.5em0.5em0.5em(PluginBase.ParseM.runT0.5emlang0.5emSys.argv.(1)0.5em0)0.5emin0.5em0.5emmatch0.5emMonad.ltake0.5em10.5emresult0.5emwith0.5em0.5em0.5em[]0.5em-&gt;0.5emPrintf.printf0.5em”0.5emerror%!“0.5em0.5em0.5emr::0.5em-&gt;0.5emPrintf.printf0.5em”:0.5em%d%!“0.5emrParser
Combinators: Toy Example</p>
<ul>
<li>File <code>Plugin1.ml</code>:</li>
</ul>
<p>open0.5emPluginBase.ParseMlet0.5emdigitofchar0.5emd0.5em=0.5emintofchar0.5emd0.5em-0.5emintofchar0.5em’0’let0.5emnumber=0.5em0.5emlet0.5emrec0.5emnum0.5em=Numbers:
<span class="math inline">N := D N | D</span> where <span
class="math inline">D</span> is
digits.0.5em0.5em0.5em0.5emlazy0.5em(0.5em0.5em(perform0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5emd0.5em&lt;–0.5emdigit;0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em(n,0.5emb)0.5em&lt;–0.5emLazy.force0.5emnum;0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5em0.5emreturn0.5em(digitofchar0.5emd0.5em<em>0.5emb0.5em+0.5emn,0.5emb0.5em</em>0.5em10))0.5em0.5em0.5em0.5em0.5em0.5em&lt;&gt;0.5emlazy0.5em(digit0.5em&gt;&gt;=0.5em(fun0.5emd0.5em-&gt;0.5emreturn0.5em(digitofchar0.5emd,0.5em10))))0.5emin0.5em0.5emLazy.force0.5emnum0.5em&gt;&gt;0.5emfstlet0.5emaddition0.5emlang0.5em=Addition
rule: <span class="math inline">S \rightarrow (S +
S)</span>.0.5em0.5emperformRequiring a parenthesis ( turns the rule into
non-left-recursive.0.5em0.5em0.5em0.5emliteral0.5em”(“;0.5emn10.5em&lt;–0.5emlang;0.5emliteral0.5em”+“;0.5emn20.5em&lt;–0.5emlang;0.5emliteral0.5em”)“;0.5em0.5em0.5em0.5emreturn0.5em(n10.5em+0.5emn2)let0.5em()0.5em=
PluginBase.(grammarrules0.5em:=0.5emnumber0.5em::0.5emaddition0.5em::0.5em!grammarrules)</p>
<ul>
<li>File <code>Plugin2.ml</code>:</li>
</ul>
<p>open0.5emPluginBase.ParseMlet0.5emmultiplication0.5emlang0.5em=0.5em0.5emperformMultiplication
rule: <span class="math inline">S \rightarrow (S \ast
S)</span>.0.5em0.5em0.5em0.5emliteral0.5em”(“;0.5emn10.5em&lt;–0.5emlang;0.5emliteral0.5em”<em>“;0.5emn20.5em&lt;–0.5emlang;0.5emliteral0.5em”)“;0.5em0.5em0.5em0.5emreturn0.5em(n10.5em</em>0.5emn2)let0.5em()0.5em=
PluginBase.(grammarrules0.5em:=0.5emmultiplication0.5em::0.5em!grammarrules)</p>
<h1 id="the-expression-problem-exercises">The Expression Problem –
Exercises</h1>
<p><strong>Exercise 1:</strong> <span id="ExStringOf"></span>Implement
the <code>string_of_</code> functions or methods, covering all data
cases, corresponding to the <code>eval_</code> functions in at least two
examples from the lecture, including both an object-based example and a
variant-based example (either standard, or polymorphic, or extensible
variants).</p>
<p><strong>Exercise 2:</strong> <span id="ExSplitFiles"></span>Split at
least one of the examples from the previous exercise into multiple files
and demonstrate separate compilation.</p>
<p><strong>Exercise 3:</strong> Can we drop the tags
<code>Lambda_t</code>, <code>Expr_t</code> and <code>LExpr_t</code> used
in the examples based on standard variants (file
<code>FP_ADT.ml</code>)? When using polymorphic variants, such tags are
not needed.</p>
<p><strong>Exercise 4:</strong> Factor-out the sub-language consisting
only of variables, thus eliminating the duplication of tags
<code>VarL</code>, <code>VarE</code> in the examples based on standard
variants (file <code>FP_ADT.ml</code>).</p>
<p><strong>Exercise 5:</strong> Come up with a scenario where the
extensible variant types-based solution leads to a non-obvious or hard
to locate bug.</p>
<p><strong>Exercise 6:</strong> * Re-implement the direct object-based
solution to the expression problem (file <code>Objects.ml</code>) to
make it more satisfying. For example, eliminate the need for some of the
<code>rename</code>, <code>apply</code>, <code>compute</code>
methods.</p>
<p><strong>Exercise 7:</strong> Re-implement the visitor pattern-based
solution to the expression problem (file <code>Visitor.ml</code>) in a
functional way, i.e. replace the mutable fields <code>subst</code> and
<code>beta_redex</code> in the <code>eval_lambda</code> class with a
different solution to the problem of treating <code>abs</code> and
non-<code>abs</code> expressions differently.</p>
<p>** See if you can replace the reference cells <code>result</code> in
<code>evalN</code> and <code>freevarsN</code> functions (for
<code>N=1,2,3</code>) with a different solution to the problem of
polymorphism wrt. the type of the computed values.*</p>
<p><strong>Exercise 8:</strong> Extend the sub-language
<code>expr_visit</code> with variables, and add to arguments of the
evaluation constructor <code>eval_expr</code> the substitution. Handle
the problem of potentially duplicate fields <code>subst</code>. (One
approach might be to use ideas from exercise 6.)</p>
<p><strong>Exercise 9:</strong> Impement the following modifications to
the example from the file <code>PolyV.ml</code>:</p>
<ol type="1">
<li><em>Factor-out the sub-language of variables, around the already
present</em> <code>*var*</code> <em>type.</em></li>
<li><em>Open the types of functions</em>
<code>*eval3*</code>,<code>*freevars3*</code> <em>and other functions as
required, so that explicit subtyping, e.g. in</em>
<em>eval30.5em<strong>[]0.5em(</strong>test20.5em<strong>:&gt;0.5em</strong>lexprt</em>)<em>,
is not necessary.</em></li>
<li><em>Remove the double-dispatch currently in</em>
<code>*eval_lexpr*</code> <em>and</em>
<code>*freevars_lexpr*</code><em>, by implementing a cascading design
rather than a “divide-and-conquer” design.</em></li>
</ol>
<p><strong>Exercise 10:</strong> Streamline the solution
<code>PolyRecM.ml</code> by extending the language of <span
class="math inline">\lambda</span>-expressions with arithmetic
expressions, rather than defining the sub-languages separately and then
merging them. See slide on page 15 of Jacques Garrigue <em>Structural
Types, Recursive Modules, and the Expression Problem</em>.</p>
<p><strong>Exercise 11:</strong> Transform a parser monad, or rewrite
the parser monad transformer, by adding state for the line and column
numbers.</p>
<p>** How to implement a monad transformer transformer in OCaml?*</p>
<p><strong>Exercise 12:</strong> Implement <code>_of_string</code>
functions as parser combinators on top of the example
<code>PolyRecM.ml</code>. Sections 4.3 and 6.2 of <em>Monadic Parser
Combinators</em> by Graham Hutton and Erik Meijer might be helpful.
Split the result into multiple files as in Exercise <a
href="#ExSplitFiles">2</a> and demonstrate dynamic loading of code.</p>
<p><strong>Exercise 13:</strong> What are the benefits and drawbacks of
our lazy-monad-plus (built on top of <em>odd lazy lists</em>) approach,
as compared to regular monad-plus built on top of <em>even lazy
lists</em>? To additionally illustrate your answer:</p>
<ol type="1">
<li><em>Rewrite the parser combinators example to use regular monad-plus
and even lazy lists.</em></li>
<li><em>Select one example from Lecture 8 and rewrite it using
lazy-monad-plus and odd lazy lists.</em></li>
</ol>
<p>Exam: Exercises for review</p>
<h1 id="exam-set-0">Exam set 0</h1>
<p>Exercise 1.</p>
<p>Give types of the following expressions, either by guessing or
inferring them by hand:</p>
<ol type="1">
<li>let double f y = f (f y) in fun g x -&gt; double (g x)</li>
<li>let rec tails l = match l with [] -&gt; [] | x::xs -&gt; xs::tails
xs infun l -&gt; List.combine l (tails l)</li>
</ol>
<p>Exercise 2.</p>
<p>Assume that the corresponding expression from previous exercise is
bound to name <code>foo</code>. What are the values computed for the
expressions (compute in your head or derive on paper):</p>
<ol type="1">
<li>foo (+) 2 3, foo ( * ) 2 3, foo ( * ) 3 2</li>
<li>foo [1; 2; 3]</li>
</ol>
<p>Exercise 3.</p>
<p>Give example expressions that have the following types (without using
type constraints):</p>
<ol type="1">
<li><code>(int -&gt; int) -&gt; bool</code></li>
<li><code>'a option -&gt; 'a list</code></li>
</ol>
<p>Exercise 4.</p>
<p>Write function that returns the list of all lists containing elements
from the input list, preserving order from the input list, but without
two elements.</p>
<p>Exercise 5.</p>
<p>Write a breadth-first-search function that returns an element from a
binary tree for which a predicate holds, or <code>None</code> if no such
element exists. The function should have signature:</p>
<p><code>val bfs : ('a -&gt; bool) -&gt; 'a btree -&gt; 'a option</code></p>
<p>Exercise 6.</p>
<p>Solve the n-queens problem using backtracking based on lists.</p>
<p>Available functions: <code>from_to</code>, <code>concat_map</code>,
<code>concat_foldl</code>, <code>unique</code>.</p>
<p>Hint functions (asking for hint each loses one point):
<code>valid_queens</code>, <code>add_queen</code>,
<code>find_queen</code>, <code>find_queens</code>. Final function
<code>solve</code> takes <span class="math inline">n</span> as an
argument. Each function, other than <code>valid_queens</code> that takes
3 lines, fits on one line.</p>
<p>Exercise 7.</p>
<p>Provide an algebraic specification and an implementation for
first-in-first-out queues (lecture 5 exercise 9).</p>
<h1 id="exam-set-1">Exam set 1</h1>
<p>Functional ProgrammingFebruary 5th 2013</p>
<p>Exam set 1</p>
<p><strong>Exercise 1:</strong> (Blue.) What is the type of the
subexpression <code>y</code> as part of the expression below assuming
that the whole expression has the type given?</p>
*(fun double g x -&gt; double (g x)) (fun f y -&gt; f (f
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
y
</td>
</tr>
</tbody>
</table>
<p>))*</p>
<p><em>: (’a -&gt; ’b -&gt; ’b) -&gt; ’a -&gt; ’b -&gt; ’b</em></p>
<p><strong>Exercise 2:</strong> (Blue.) Write an example function with
type:</p>
<p><code>*((int -&gt; int) -&gt; bool) -&gt; int*</code></p>
<p><em>Tell “in your words” what it does.</em></p>
<p><strong>Exercise 3:</strong> (Green.) Write a function
<code>last : 'a list -&gt; 'a option</code> that returns the last
element of a list.</p>
<p><strong>Exercise 4:</strong> (Green.) Duplicate the elements of a
list.</p>
<p><strong>Exercise 5:</strong> (Yellow.) Drop every N’th element from a
list.</p>
<p><strong>Exercise 6:</strong> (Yellow.) Construct completely balanced
binary trees of given depth.</p>
<p><em>In a completely balanced binary tree, the following property
holds for every node: The number of nodes in its left subtree and the
number of nodes in its right subtree are almost equal, which means their
difference is not greater than one.</em></p>
<p><em>Write a function <code>cbal_tree</code> to construct completely
balanced binary trees for a given number of nodes. The function should
generate the list of all solutions (e.g. via backtracking). Put the
letter <code>'x'</code> as information into all nodes of the
tree.</em></p>
<p><strong>Exercise 7:</strong> (White.) Due to Yaron Minsky.</p>
<p><em>Consider a datatype to store internet connection information. The
time <code>when_initiated</code> marks the start of connecting and is
not needed after the connection is established (it is only used to
decide whether to give up trying to connect). The ping information is
available for established connection but not straight away.</em></p>
<p><em>type connectionstate = | Connecting | Connected |
Disconnectedtype connectioninfo = { state : connectionstate; server :
Inetaddr.t; lastpingtime : Time.t option; lastpingid : int option;
sessionid : string option; wheninitiated : Time.t option;
whendisconnected : Time.t option;}</em></p>
<p><em>(The types Time.t and Inetaddr.t come from the library </em>Core*
used where Yaron Minsky works. You can replace them with
<code>float</code> and Unix.inet_addr. Load the Unix library in the
interactive toplevel by <code>#load "unix.cma";;</code>.) Rewrite the
type definitions so that the datatype will contain only reasonable
combinations of information.*</p>
<p><strong>Exercise 8:</strong> (White.) Design an algebraic
specification and write a signature for first-in-first-out queues.
Provide two implementations: one straightforward using a list, and
another one using two lists: one for freshly added elements providing
efficient queueing of new elements, and “reversed” one for efficient
popping of old elements.</p>
<p><strong>Exercise 9:</strong> (Orange.) Implement
<code>while_do</code> in terms of <code>repeat_until</code>.</p>
<p><strong>Exercise 10:</strong> (Orange.) Implement a map from keys to
values (a dictionary) using only functions (without data structures like
lists or trees).</p>
<p><strong>Exercise 11:</strong> (Purple.) One way to express
constraints on a polymorphic function is to write its type in the form:
<span class="math inline">\forall \alpha _{1} \ldots \alpha
_{n} [C] . \tau</span>, where <span class="math inline">\tau</span> is
the type of the function, <span class="math inline">\alpha _{1}
\ldots \alpha _{n}</span> are the polymorphic type variables, and <span
class="math inline">C</span> are additional constraints that the
variables <span class="math inline">\alpha _{1} \ldots \alpha
_{n}</span> have to meet. Let’s say we allow “local variables” in <span
class="math inline">C</span>: for example <span class="math inline">C =
\exists \beta . \alpha _{1} \dot{=} \operatorname{list} (\beta)</span>.
Why the general form <span class="math inline">\forall \beta [C] .
\beta</span> is enough to express all types of the general form <span
class="math inline">\forall \alpha _{1} \ldots \alpha _{n} [C] .
\tau</span>?</p>
<p><strong>Exercise 12:</strong> (Purple.) Define a type that
corresponds to a set with a googleplex of elements (i.e. <span
class="math inline">10^{10^{100}}</span> elements).</p>
<p><strong>Exercise 13:</strong> (Red.) In a height-balanced binary
tree, the following property holds for every node: The height of its
left subtree and the height of its right subtree are almost equal, which
means their difference is not greater than one. Consider a
height-balanced binary tree of height <span
class="math inline">h</span>. What is the maximum number of nodes it can
contain? Clearly, <span class="math inline">\operatorname{maxN}=
2 h - 1</span>. However, finding the minimum number <span
class="math inline">\operatorname{minN}</span> is more difficult.</p>
<p><em>Construct all the height-balanced binary trees with a given nuber
of nodes. <code>hbal_tree_nodes n</code> returns a list of all
height-balanced binary tree with <code>n</code> nodes.</em></p>
<p><em>Find out how many height-balanced trees exist for <code>n</code>
= 15.</em></p>
<p><strong>Exercise 14:</strong> (Crimson.) To construct a Huffman code
for symbols with probability/frequency, we can start by building a
binary tree as follows. The algorithm uses a priority queue where the
node with lowest probability is given highest priority:</p>
<ol type="1">
<li><em>Create a leaf node for each symbol and add it to the priority
queue.</em></li>
<li><em>While there is more than one node in the queue:</em>
<ol type="1">
<li><em>Remove the two nodes of highest priority (lowest probability)
from the queue.</em></li>
<li><em>Create a new internal node with these two nodes as children and
with probability equal to the sum of the two nodes’
probabilities.</em></li>
<li><em>Add the new node to the queue.</em></li>
</ol></li>
<li><em>The remaining node is the root node and the tree is
complete.</em></li>
</ol>
<p><em>Label each left edge by <code>0</code> and right edge by
<code>1</code>. The final binary code assigns the string of bits on the
path from root to the symbol as its code.</em></p>
<p><em>We suppose a set of symbols with their frequencies, given as a
list of Fr(S,F) terms. Example:
<code>fs = [Fr(a,45); Fr(b,13); Fr(c,12); Fr(d,16); Fr(e,9); Fr(f,5)]</code>.
Our objective is to construct a list <code>Hc(S,C)</code> terms, where
<code>C</code> is the Huffman code word for the symbol <code>S</code>.
In our example, the result could be
<code>hs = [Hc(a,'0'); Hc(b,'101'); Hc(c,'100'); Hc(d,'111'); Hc(e,'1101'); Hc(f,'1100')]</code>
[<code>Hc(a,'01')</code>,…etc.]. The task shall be performed by the
function huffman defined as follows: <code>huffman(fs)</code> returns
the Huffman code table for the frequency table <code>fs</code>.</em></p>
<p><strong>Exercise 15:</strong> (Black.) Implement the Gaussian
Elimination algorithm for solving linear equations and inverting square
invertible matrices.</p>
<h1 id="exam-set-2">Exam set 2</h1>
<p>Functional ProgrammingFebruary 5th 2013</p>
<p>Exam set 2</p>
<p><strong>Exercise 1:</strong> (Blue.) What is the type of the
subexpression <code>f</code> as part of the expression below assuming
that the whole expression has the type given?</p>
*(fun double g x -&gt; double (g x)) (fun f y -&gt;
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
</td>
</tr>
</tbody>
</table>
<p>(f y))*</p>
<p><em>: (’a -&gt; ’b -&gt; ’b) -&gt; ’a -&gt; ’b -&gt; ’b</em></p>
<p><strong>Exercise 2:</strong> (Blue.) Write an example function with
type:</p>
<p><code>*(int -&gt; int list) -&gt; bool*</code></p>
<p><em>Tell “in your words” what it does.</em></p>
<p><strong>Exercise 3:</strong> (Green.) Find the number of elements of
a list.</p>
<p><strong>Exercise 4:</strong> (Green.) Split a list into two parts;
the length of the first part is given.</p>
<p><strong>Exercise 5:</strong> (Yellow.) Rotate a list N places to the
left.</p>
<p><strong>Exercise 6:</strong> (Yellow.) Let us call a binary tree
symmetric if you can draw a vertical line through the root node and then
the right subtree is the mirror image of the left subtree. Write a
function <code>is_symmetric</code> to check whether a given binary tree
is symmetric.</p>
<p><strong>Exercise 7:</strong> (White.) By “traverse a tree” we mean:
write a function that takes a tree and returns a list of values in the
nodes of the tree. Traverse a tree in breadth-first order – first values
in more shallow nodes.</p>
<p><strong>Exercise 8:</strong> (White.) Generate all combinations of K
distinct elements chosen from the N elements of a list.</p>
<p><strong>Exercise 9:</strong> (Orange.) Implement a topological sort
of a graph: write a function that either returns a list of graph nodes
in topological order or informs (via exception or option type) that the
graph has a cycle.</p>
<p><strong>Exercise 10:</strong> (Orange.) Express
<code>fold_left</code> in terms of <code>fold_right</code>. Hint:
continuation passing style.</p>
<p><strong>Exercise 11:</strong> (Purple.) Show why for a monomorphic
specification, if datastructures <span class="math inline">d_{1}</span>
and <span class="math inline">d_{2}</span> have the same behavior under
all operations, then they have the same representation <span
class="math inline">d_{1} = d_{2}</span> in all implementations.</p>
<p><strong>Exercise 12:</strong> (Purple.) <code>append</code> for lazy
lists returns in constant time. Where has its linear-time complexity
gone? Explain how you would account for this in a time complexity
analysis.</p>
<p><strong>Exercise 13:</strong> (Red.) Write a function
<code>ms_tree graph</code> to construct the <em>minimal spanning
tree</em> of a given weighted graph. A weighted graph will be
represented as follows:</p>
<p><code>*type 'a weighted_graph = {nodes : 'a list; edges : ('a * 'a * int) list}*</code></p>
<p><em>The labels identify the nodes <code>'a</code> uniquely and there
is at most one edge between a pair of nodes. A triple
<code>(a,b,w)</code> inside <code>edges</code> corresponds to edge
between <code>a</code> and <code>b</code> with weight <code>w</code>.
The minimal spanning tree is a subset of <code>edges</code> that forms
an undirected tree, covers all nodes of the graph, and has the minimal
sum of weights.</em></p>
<p><strong>Exercise 14:</strong> (Crimson.) Von Koch’s conjecture. Given
a tree with N nodes (and hence N-1 edges). Find a way to enumerate the
nodes from 1 to N and, accordingly, the edges from 1 to N-1 in such a
way, that for each edge K the difference of its node numbers equals to
K. The conjecture is that this is always possible.</p>
<p><em>For small trees the problem is easy to solve by hand. However,
for larger trees, and 14 is already very large, it is extremely
difficult to find a solution. And remember, we don’t know for sure
whether there is always a solution!</em></p>
<p><em>Write a function that calculates a numbering scheme for a given
tree. What is the solution for the larger tree pictured above?</em></p>
<p><strong>Exercise 15:</strong> (Black.) Based on our search engine
implementation, write a function that for a list of keywords returns
three best “next keyword” suggestions (in some sense of “best”,
e.g. occurring in most of documents containing the given words).</p>
<h1 id="exam-set-3">Exam set 3</h1>
<p>Functional ProgrammingFebruary 5th 2013</p>
<p>Exam set 3</p>
<p><strong>Exercise 1:</strong> (Blue.) What is the type of the
subexpression <code>f y</code> as part of the expression below assuming
that the whole expression has the type given?</p>
*(fun double g x -&gt; double (g x)) (fun f y -&gt; f (
<table style="display: inline-table; vertical-align: middle">
<tbody>
<tr>
<td>
</td>
</tr>
</tbody>
</table>
<p>))*</p>
<p><em>: (’a -&gt; ’b -&gt; ’b) -&gt; ’a -&gt; ’b -&gt; ’b</em></p>
<p><strong>Exercise 2:</strong> (Blue.) Write an example function with
type:</p>
<p><code>*(int -&gt; int -&gt; bool option) -&gt; bool list*</code></p>
<p><em>Tell “in your words” what it does.</em></p>
<p><strong>Exercise 3:</strong> (Green.) Find the k’th element of a
list.</p>
<p><strong>Exercise 4:</strong> (Green.) Insert an element at a given
position into a list.</p>
<p><strong>Exercise 5:</strong> (Yellow.) Group the elements of a set
into disjoint subsets. Represent sets as lists, preserve the order of
elements. The required sizes of subsets are given as a list of
numbers.</p>
<p><strong>Exercise 6:</strong> (Yellow.) A complete binary tree with
height <span class="math inline">H</span> is defined as follows: The
levels <span class="math inline">1, 2, 3, \ldots, H - 1</span> contain
the maximum number of nodes (i.e <span class="math inline">2^{i -
1}</span> at the level <span class="math inline">i</span>, note that we
start counting the levels from <span class="math inline">1</span> at the
root). In level <span class="math inline">H</span>, which may contain
less than the maximum possible number of nodes, all the nodes are
“left-adjusted”. This means that in a levelorder tree traversal all
internal nodes come first, the leaves come second, and empty successors
(the nil’s which are not really nodes!) come last.</p>
<p><em>We can assign an address number to each node in a complete binary
tree by enumerating the nodes in levelorder, starting at the root with
number 1. In doing so, we realize that for every node X with address A
the following property holds: The address of X’s left and right
successors are 2</em>A and 2<em>A+1, respectively, supposed the
successors do exist. This fact can be used to elegantly construct a
complete binary tree structure. Write a function
<code>is_complete_binary_tree</code> with the following specification:
<code>is_complete_binary_tree n t</code> returns true iff <code>t</code>
is a complete binary tree with <code>n</code> nodes.</em></p>
<p><strong>Exercise 7:</strong> (White.) Write two sorting algorithms,
working on lists: merge sort and quicksort.</p>
<ol type="1">
<li><em>Merge sort splits the list roughly in half, sorts the parts, and
merges the sorted parts into the sorted result.</em></li>
<li><em>Quicksort splits the list into elements smaller/greater than the
first element, sorts the parts, and puts them together.</em></li>
</ol>
<p><strong>Exercise 8:</strong> (White.) Express in terms of
<code>fold_left</code> or <code>fold_right</code>, i.e.  with all
recursion contained in the call to one of these functions, run-length
encoding of a list (exercise 10 from <em>99 Problems</em>).</p>
<ul>
<li><code>*encode [‘a;‘a;‘a;‘a;‘b;‘c;‘c;‘a;‘a;‘d] = [4,‘a; 1,‘b; 2,‘c; 2,‘a; 1,‘d]*</code></li>
</ul>
<p><strong>Exercise 9:</strong> (Orange.) Implement Priority Queue
module that is an abstract data type for polymorphic queues
parameterized by comparison function: the empty queue creation has
signature</p>
<p><em><code>val make_empty : leq:('a -&gt; 'a -&gt; bool) -&gt; 'a prio_queue</code></em></p>
<p><em>Provide only functions: <code>make_empty</code>,
<code>add</code>, <code>min</code>, <code>delete_min</code>. Is this
data structure “safe”?</em></p>
<p><em>Implement the heap as a </em>heap-ordered tree<em>, i.e. in which
the element at each node is no larger than the elements at its children.
Unbalanced binary trees are OK.</em></p>
<p><strong>Exercise 10:</strong> (Orange.) Write a function that
transposes a rectangular matrix represented as a list of lists.</p>
<p><strong>Exercise 11:</strong> (Purple.) Find the bijective functions
between the types corresponding to <span class="math inline">a (a^b +
c)</span> and <span class="math inline">a^{b + 1} + ac</span> (in
OCaml).</p>
<p><strong>Exercise 12:</strong> (Purple.) Show the monad-plus laws for
<code>OptionM</code> monad.</p>
<p><strong>Exercise 13:</strong> (Red.) As a preparation for drawing the
tree, a layout algorithm is required to determine the position of each
node in a rectangular grid. Several layout methods are conceivable, one
of them is shown in the illustration below.</p>
<p><em><img src="Layout_bin_tree-p64.png" /></em></p>
<p><em>In this layout strategy, the position of a node v is obtained by
the following two rules:</em></p>
<ul>
<li><em>x(v) is equal to the position of the node v in the inorder
sequence;</em></li>
<li><em>y(v) is equal to the depth of the node v in the tree.</em></li>
</ul>
<p><em>In order to store the position of the nodes, we redefine the
OCaml type representing a node (and its successors) as follows:</em></p>
<pre><code>type &#39;a pos_binary_tree =
    | E (* represents the empty tree *)
    | N of &#39;a * int * int * &#39;a pos_binary_tree * &#39;a pos_binary_tree</code></pre>
<p><em><code>N(w,x,y,l,r)</code> represents a (non-empty) binary tree
with root w “positioned” at <code>(x,y)</code>, and subtrees
<code>l</code> and <code>r</code>. Write a function
<code>layout_binary_tree</code> with the following specification:
<code>layout_binary_tree t</code> returns the “positioned” binary tree
obtained from the binary tree <code>t</code>.</em></p>
<p><em>An alternative layout method is depicted in the
illustration:</em></p>
<p><em><img src="Layout_bin_tree-p65.png" /></em></p>
<p><em>Find out the rules and write the corresponding function.</em></p>
<p><em>Hint: On a given level, the horizontal distance between
neighboring nodes is constant.</em></p>
<p><strong>Exercise 14:</strong> (Crimson.) Nonograms. Each row and
column of a rectangular bitmap is annotated with the respective lengths
of its distinct strings of occupied cells. The person who solves the
puzzle must complete the bitmap given only these lengths.</p>
<pre><code>          Problem statement:          Solution:

          |_|_|_|_|_|_|_|_| 3         |_|X|X|X|_|_|_|_| 3
          |_|_|_|_|_|_|_|_| 2 1       |X|X|_|X|_|_|_|_| 2 1
          |_|_|_|_|_|_|_|_| 3 2       |_|X|X|X|_|_|X|X| 3 2
          |_|_|_|_|_|_|_|_| 2 2       |_|_|X|X|_|_|X|X| 2 2
          |_|_|_|_|_|_|_|_| 6         |_|_|X|X|X|X|X|X| 6
          |_|_|_|_|_|_|_|_| 1 5       |X|_|X|X|X|X|X|_| 1 5
          |_|_|_|_|_|_|_|_| 6         |X|X|X|X|X|X|_|_| 6
          |_|_|_|_|_|_|_|_| 1         |_|_|_|_|X|_|_|_| 1
          |_|_|_|_|_|_|_|_| 2         |_|_|_|X|X|_|_|_| 2
           1 3 1 7 5 3 4 3             1 3 1 7 5 3 4 3
           2 1 5 1                     2 1 5 1</code></pre>
<p><em>For the example above, the problem can be stated as the two lists
<code>[[3];[2;1];[3;2];[2;2];[6];[1;5];[6];[1];[2]]</code> and
<code>[[1;2];[3;1];[1;5];[7;1];[5];[3];[4];[3]]</code> which give the
“solid” lengths of the rows and columns, top-to-bottom and
left-to-right, respectively. Published puzzles are larger than this
example, e.g. 25</em>20, and apparently always have unique
solutions.*</p>
<p><strong>Exercise 15:</strong> (Black.) Leftist heaps are heap-ordered
binary trees that satisfy the <em>leftist property</em>: the rank of any
left child is at least as large as the rank of its right sibling. The
rank of a node is defined to be the length of its <em>right spine</em>,
i.e. the rightmost path from the node in question to an empty node.
Implement <span class="math inline">O (\log n)</span> worst case time
complexity Priority Queues based on leftist heaps. Each node of the tree
should contain its rank.</p>
<p><em>Note that the elements along any path through a heap-ordered tree
are stored in sorted order. The key insight behind leftist heaps is that
two heaps can be merged by merging their right spines as you would merge
two sorted lists, and then swapping the children of nodes along this
path as necessary to restore the leftist property.</em></p>
</body>
</html>
