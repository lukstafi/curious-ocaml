<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Lukasz Stafiniak" />
  <title>Curious OCaml</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Curious OCaml</h1>
<p class="author">Lukasz Stafiniak</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#curious-ocaml" id="toc-curious-ocaml">Curious OCaml</a>
<ul>
<li><a href="#chapter-1-logic" id="toc-chapter-1-logic">Chapter 1:
Logic</a>
<ul>
<li><a href="#in-the-beginning-there-was-logos"
id="toc-in-the-beginning-there-was-logos">1.1 In the Beginning there was
Logos</a></li>
<li><a href="#rules-for-logical-connectives"
id="toc-rules-for-logical-connectives">1.2 Rules for Logical
Connectives</a></li>
<li><a href="#logos-was-programmed-in-ocaml"
id="toc-logos-was-programmed-in-ocaml">1.3 Logos was Programmed in
OCaml</a></li>
<li><a href="#exercises" id="toc-exercises">1.4 Exercises</a></li>
</ul></li>
<li><a href="#chapter-2-algebra" id="toc-chapter-2-algebra">Chapter 2:
Algebra</a>
<ul>
<li><a href="#a-glimpse-at-type-inference"
id="toc-a-glimpse-at-type-inference">2.1 A Glimpse at Type
Inference</a></li>
<li><a href="#algebraic-data-types" id="toc-algebraic-data-types">2.2
Algebraic Data Types</a></li>
<li><a href="#syntactic-conventions" id="toc-syntactic-conventions">2.3
Syntactic Conventions</a></li>
<li><a href="#pattern-matching" id="toc-pattern-matching">2.4 Pattern
Matching</a></li>
<li><a href="#interpreting-algebraic-data-types-as-polynomials"
id="toc-interpreting-algebraic-data-types-as-polynomials">2.5
Interpreting Algebraic Data Types as Polynomials</a></li>
<li><a href="#differentiating-algebraic-data-types"
id="toc-differentiating-algebraic-data-types">2.6 Differentiating
Algebraic Data Types</a></li>
<li><a href="#exercises-1" id="toc-exercises-1">2.7 Exercises</a></li>
</ul></li>
<li><a href="#chapter-3-computation"
id="toc-chapter-3-computation">Chapter 3: Computation</a>
<ul>
<li><a href="#function-composition" id="toc-function-composition">3.1
Function Composition</a></li>
<li><a href="#evaluation-rules-reduction-semantics"
id="toc-evaluation-rules-reduction-semantics">3.2 Evaluation Rules
(Reduction Semantics)</a></li>
<li><a href="#symbolic-derivation-example"
id="toc-symbolic-derivation-example">3.3 Symbolic Derivation
Example</a></li>
<li><a href="#tail-calls-and-tail-recursion"
id="toc-tail-calls-and-tail-recursion">3.4 Tail Calls and Tail
Recursion</a></li>
<li><a href="#first-encounter-of-continuation-passing-style"
id="toc-first-encounter-of-continuation-passing-style">3.5 First
Encounter of Continuation Passing Style</a></li>
<li><a href="#exercises-2" id="toc-exercises-2">3.6 Exercises</a></li>
</ul></li>
<li><a href="#chapter-4-functions" id="toc-chapter-4-functions">Chapter
4: Functions</a>
<ul>
<li><a href="#review-computation-by-hand"
id="toc-review-computation-by-hand">4.1 Review: Computation by
Hand</a></li>
<li><a href="#language-and-rules-of-the-untyped-lambda-calculus"
id="toc-language-and-rules-of-the-untyped-lambda-calculus">4.2 Language
and Rules of the Untyped Lambda-Calculus</a></li>
<li><a href="#booleans" id="toc-booleans">4.3 Booleans</a></li>
<li><a href="#if-then-else-and-pairs"
id="toc-if-then-else-and-pairs">4.4 If-then-else and Pairs</a></li>
<li><a href="#pair-encoded-natural-numbers"
id="toc-pair-encoded-natural-numbers">4.5 Pair-Encoded Natural
Numbers</a></li>
<li><a href="#church-numerals" id="toc-church-numerals">4.6 Church
Numerals</a></li>
<li><a href="#recursion-fixpoint-combinators"
id="toc-recursion-fixpoint-combinators">4.7 Recursion: Fixpoint
Combinators</a></li>
<li><a href="#encoding-lists-and-trees"
id="toc-encoding-lists-and-trees">4.8 Encoding Lists and Trees</a></li>
<li><a href="#looping-recursion" id="toc-looping-recursion">4.9 Looping
Recursion</a></li>
<li><a href="#exercises-3" id="toc-exercises-3">4.10 Exercises</a></li>
</ul></li>
<li><a href="#chapter-5-polymorphism-and-abstract-data-types"
id="toc-chapter-5-polymorphism-and-abstract-data-types">Chapter 5:
Polymorphism and Abstract Data Types</a>
<ul>
<li><a href="#type-inference" id="toc-type-inference">5.1 Type
Inference</a></li>
<li><a href="#parametric-types" id="toc-parametric-types">5.2 Parametric
Types</a></li>
<li><a href="#type-inference-formally"
id="toc-type-inference-formally">5.3 Type Inference, Formally</a></li>
<li><a href="#algebraic-specification"
id="toc-algebraic-specification">5.4 Algebraic Specification</a></li>
<li><a href="#homomorphisms" id="toc-homomorphisms">5.5
Homomorphisms</a></li>
<li><a href="#example-maps" id="toc-example-maps">5.6 Example:
Maps</a></li>
<li><a href="#modules-and-interfaces-signatures-syntax"
id="toc-modules-and-interfaces-signatures-syntax">5.7 Modules and
Interfaces (Signatures): Syntax</a></li>
<li><a href="#implementing-maps-association-lists"
id="toc-implementing-maps-association-lists">5.8 Implementing Maps:
Association Lists</a></li>
<li><a href="#implementing-maps-binary-search-trees"
id="toc-implementing-maps-binary-search-trees">5.9 Implementing Maps:
Binary Search Trees</a></li>
<li><a href="#implementing-maps-red-black-trees"
id="toc-implementing-maps-red-black-trees">5.10 Implementing Maps:
Red-Black Trees</a></li>
<li><a href="#exercises-4" id="toc-exercises-4">Exercises</a></li>
</ul></li>
<li><a href="#chapter-6-folding-and-backtracking"
id="toc-chapter-6-folding-and-backtracking">Chapter 6: Folding and
Backtracking</a>
<ul>
<li><a href="#basic-generic-list-operations"
id="toc-basic-generic-list-operations">6.1 Basic Generic List
Operations</a></li>
<li><a href="#making-fold-tail-recursive"
id="toc-making-fold-tail-recursive">6.2 Making Fold
Tail-Recursive</a></li>
<li><a href="#map-and-fold-for-trees-and-other-structures"
id="toc-map-and-fold-for-trees-and-other-structures">6.3 Map and Fold
for Trees and Other Structures</a></li>
<li><a href="#point-free-programming"
id="toc-point-free-programming">6.4 Point-Free Programming</a></li>
<li><a href="#reductions-and-more-higher-order-functions"
id="toc-reductions-and-more-higher-order-functions">6.5 Reductions and
More Higher-Order Functions</a></li>
<li><a href="#grouping-and-map-reduce"
id="toc-grouping-and-map-reduce">6.6 Grouping and Map-Reduce</a></li>
<li><a href="#higher-order-functions-for-the-option-type"
id="toc-higher-order-functions-for-the-option-type">6.7 Higher-Order
Functions for the Option Type</a></li>
<li><a href="#the-countdown-problem-puzzle"
id="toc-the-countdown-problem-puzzle">6.8 The Countdown Problem
Puzzle</a></li>
<li><a href="#the-honey-islands-puzzle"
id="toc-the-honey-islands-puzzle">6.9 The Honey Islands Puzzle</a></li>
<li><a href="#constraint-based-puzzles"
id="toc-constraint-based-puzzles">6.10 Constraint-Based Puzzles</a></li>
<li><a href="#exercises-5" id="toc-exercises-5">6.11 Exercises</a></li>
</ul></li>
<li><a href="#chapter-7-laziness" id="toc-chapter-7-laziness">Chapter 7:
Laziness</a>
<ul>
<li><a href="#evaluation-strategies-and-parameter-passing"
id="toc-evaluation-strategies-and-parameter-passing">7.1 Evaluation
Strategies and Parameter Passing</a></li>
<li><a href="#call-by-name-streams" id="toc-call-by-name-streams">7.2
Call-by-name: Streams</a></li>
<li><a href="#lazy-values" id="toc-lazy-values">7.3 Lazy Values</a></li>
<li><a href="#power-series-and-differential-equations"
id="toc-power-series-and-differential-equations">7.4 Power Series and
Differential Equations</a></li>
<li><a href="#arbitrary-precision-computation"
id="toc-arbitrary-precision-computation">7.5 Arbitrary Precision
Computation</a></li>
<li><a href="#circular-data-structures-double-linked-lists"
id="toc-circular-data-structures-double-linked-lists">7.6 Circular Data
Structures: Double-Linked Lists</a></li>
<li><a href="#input-output-streams" id="toc-input-output-streams">7.7
Input-Output Streams</a></li>
<li><a href="#pipes" id="toc-pipes">7.8 Pipes</a></li>
<li><a href="#example-pretty-printing"
id="toc-example-pretty-printing">7.9 Example: Pretty-Printing</a></li>
<li><a href="#exercises-6" id="toc-exercises-6">7.10 Exercises</a></li>
</ul></li>
<li><a href="#chapter-8-monads" id="toc-chapter-8-monads">Chapter 8:
Monads</a>
<ul>
<li><a href="#list-comprehensions" id="toc-list-comprehensions">8.1 List
Comprehensions</a></li>
<li><a href="#generalized-comprehensions-do-notation"
id="toc-generalized-comprehensions-do-notation">8.2 Generalized
Comprehensions: Do-Notation</a></li>
<li><a href="#monads" id="toc-monads">8.3 Monads</a></li>
<li><a href="#monad-laws" id="toc-monad-laws">8.4 Monad Laws</a></li>
<li><a href="#monoid-laws-and-monad-plus"
id="toc-monoid-laws-and-monad-plus">8.5 Monoid Laws and
Monad-Plus</a></li>
<li><a href="#backtracking-computation-with-choice"
id="toc-backtracking-computation-with-choice">8.6 Backtracking:
Computation with Choice</a></li>
<li><a href="#monad-flavors" id="toc-monad-flavors">8.7 Monad
Flavors</a></li>
<li><a href="#interlude-the-module-system"
id="toc-interlude-the-module-system">8.8 Interlude: The Module
System</a></li>
<li><a href="#the-two-metaphors" id="toc-the-two-metaphors">8.9 The Two
Metaphors</a></li>
<li><a href="#monad-classes-and-instances"
id="toc-monad-classes-and-instances">8.10 Monad Classes and
Instances</a></li>
<li><a href="#monad-instances" id="toc-monad-instances">8.11 Monad
Instances</a></li>
<li><a href="#monad-transformers" id="toc-monad-transformers">8.12 Monad
Transformers</a></li>
<li><a href="#probabilistic-programming"
id="toc-probabilistic-programming">8.13 Probabilistic
Programming</a></li>
<li><a href="#lightweight-cooperative-threads"
id="toc-lightweight-cooperative-threads">8.14 Lightweight Cooperative
Threads</a></li>
<li><a href="#exercises-7" id="toc-exercises-7">8.15 Exercises</a></li>
</ul></li>
<li><a href="#chapter-9-compiler" id="toc-chapter-9-compiler">Chapter 9:
Compiler</a>
<ul>
<li><a href="#compilation-runtime-optimization-and-parsing"
id="toc-compilation-runtime-optimization-and-parsing">Compilation,
Runtime, Optimization, and Parsing</a></li>
<li><a href="#ocaml-compilers" id="toc-ocaml-compilers">9.1 OCaml
Compilers</a></li>
<li><a href="#imperative-features-in-ocaml"
id="toc-imperative-features-in-ocaml">9.2 Imperative Features in
OCaml</a></li>
<li><a href="#ocaml-garbage-collection"
id="toc-ocaml-garbage-collection">9.3 OCaml Garbage Collection</a></li>
<li><a href="#stack-frames-and-closures"
id="toc-stack-frames-and-closures">9.4 Stack Frames and
Closures</a></li>
<li><a href="#profiling-and-optimization"
id="toc-profiling-and-optimization">9.5 Profiling and
Optimization</a></li>
<li><a href="#parsing-ocamllex-and-menhir"
id="toc-parsing-ocamllex-and-menhir">9.6 Parsing: ocamllex and
Menhir</a></li>
<li><a href="#example-phrase-search" id="toc-example-phrase-search">9.7
Example: Phrase Search</a></li>
<li><a href="#exercises-8" id="toc-exercises-8">9.8 Exercises</a></li>
</ul></li>
<li><a href="#chapter-10-functional-reactive-programming"
id="toc-chapter-10-functional-reactive-programming">Chapter 10:
Functional Reactive Programming</a>
<ul>
<li><a href="#zippers" id="toc-zippers">10.1 Zippers</a></li>
<li><a href="#example-context-rewriting"
id="toc-example-context-rewriting">10.2 Example: Context
Rewriting</a></li>
<li><a href="#adaptive-programming-incremental-computing"
id="toc-adaptive-programming-incremental-computing">10.3 Adaptive
Programming (Incremental Computing)</a></li>
<li><a href="#functional-reactive-programming"
id="toc-functional-reactive-programming">10.4 Functional Reactive
Programming</a></li>
<li><a href="#reactivity-by-stream-processing"
id="toc-reactivity-by-stream-processing">10.5 Reactivity by Stream
Processing</a></li>
<li><a href="#reactivity-by-incremental-computing"
id="toc-reactivity-by-incremental-computing">10.6 Reactivity by
Incremental Computing</a></li>
<li><a href="#direct-control" id="toc-direct-control">10.7 Direct
Control</a></li>
<li><a href="#graphical-user-interfaces"
id="toc-graphical-user-interfaces">10.8 Graphical User
Interfaces</a></li>
<li><a href="#exercises-9" id="toc-exercises-9">10.9 Exercises</a></li>
</ul></li>
<li><a href="#chapter-11-the-expression-problem"
id="toc-chapter-11-the-expression-problem">Chapter 11: The Expression
Problem</a>
<ul>
<li><a href="#the-expression-problem-definition"
id="toc-the-expression-problem-definition">11.1 The Expression Problem:
Definition</a></li>
<li><a
href="#functional-programming-non-solution-ordinary-algebraic-datatypes"
id="toc-functional-programming-non-solution-ordinary-algebraic-datatypes">11.2
Functional Programming Non-Solution: Ordinary Algebraic
Datatypes</a></li>
<li><a href="#lightweight-fp-non-solution-extensible-variant-types"
id="toc-lightweight-fp-non-solution-extensible-variant-types">11.3
Lightweight FP Non-Solution: Extensible Variant Types</a></li>
<li><a href="#object-oriented-programming-subtyping"
id="toc-object-oriented-programming-subtyping">11.4 Object-Oriented
Programming: Subtyping</a></li>
<li><a href="#direct-object-oriented-non-solution"
id="toc-direct-object-oriented-non-solution">11.5 Direct Object-Oriented
Non-Solution</a></li>
<li><a href="#oop-non-solution-the-visitor-pattern"
id="toc-oop-non-solution-the-visitor-pattern">11.6 OOP Non-Solution: The
Visitor Pattern</a></li>
<li><a href="#polymorphic-variants" id="toc-polymorphic-variants">11.7
Polymorphic Variants</a></li>
<li><a href="#polymorphic-variants-with-recursive-modules"
id="toc-polymorphic-variants-with-recursive-modules">11.8 Polymorphic
Variants with Recursive Modules</a></li>
<li><a href="#parser-combinators" id="toc-parser-combinators">11.9
Parser Combinators</a></li>
<li><a href="#parser-combinators-implementation"
id="toc-parser-combinators-implementation">11.10 Parser Combinators:
Implementation</a></li>
<li><a href="#parser-combinators-tying-the-recursive-knot"
id="toc-parser-combinators-tying-the-recursive-knot">11.11 Parser
Combinators: Tying the Recursive Knot</a></li>
<li><a href="#parser-combinators-dynamic-code-loading"
id="toc-parser-combinators-dynamic-code-loading">11.12 Parser
Combinators: Dynamic Code Loading</a></li>
<li><a href="#parser-combinators-toy-example"
id="toc-parser-combinators-toy-example">11.13 Parser Combinators: Toy
Example</a></li>
<li><a href="#exercises-10" id="toc-exercises-10">11.14
Exercises</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<!-- Do NOT modify this file, it is automatically generated -->
<h1 id="curious-ocaml">Curious OCaml</h1>
<h2 id="chapter-1-logic">Chapter 1: Logic</h2>
<p><em>From logic rules to programming constructs</em></p>
<h3 id="in-the-beginning-there-was-logos">1.1 In the Beginning there was
Logos</h3>
<p>What logical connectives do you know?</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th><span class="math inline">\top</span></th>
<th><span class="math inline">\bot</span></th>
<th><span class="math inline">\wedge</span></th>
<th><span class="math inline">\vee</span></th>
<th><span class="math inline">\rightarrow</span></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td><span class="math inline">a \wedge b</span></td>
<td><span class="math inline">a \vee b</span></td>
<td><span class="math inline">a \rightarrow b</span></td>
</tr>
<tr>
<td>truth</td>
<td>falsehood</td>
<td>conjunction</td>
<td>disjunction</td>
<td>implication</td>
</tr>
<tr>
<td>“trivial”</td>
<td>“impossible”</td>
<td><span class="math inline">a</span> and <span
class="math inline">b</span></td>
<td><span class="math inline">a</span> or <span
class="math inline">b</span></td>
<td><span class="math inline">a</span> gives <span
class="math inline">b</span></td>
</tr>
<tr>
<td></td>
<td>shouldn’t get</td>
<td>got both</td>
<td>got at least one</td>
<td>given <span class="math inline">a</span>, we get <span
class="math inline">b</span></td>
</tr>
</tbody>
</table>
<p>How can we define them? Think in terms of <em>derivation
trees</em>:</p>
<p><span class="math display">
\frac{
\frac{\frac{\,}{\text{a premise}} \; \frac{\,}{\text{another
premise}}}{\text{some fact}} \;
\frac{\frac{\,}{\text{this we have by default}}}{\text{another fact}}}
{\text{final conclusion}}
</span></p>
<p>We define connectives by providing rules for using them. For example,
a rule <span class="math inline">\frac{a \; b}{c}</span> matches parts
of the tree that have two premises, represented by variables <span
class="math inline">a</span> and <span class="math inline">b</span>, and
have any conclusion, represented by variable <span
class="math inline">c</span>.</p>
<p><strong>Design principle:</strong> Try to use only the connective you
define in its definition.</p>
<h3 id="rules-for-logical-connectives">1.2 Rules for Logical
Connectives</h3>
<p><strong>Introduction rules</strong> say how to <em>produce</em> a
connective.</p>
<p><strong>Elimination rules</strong> say how to <em>use</em> it.</p>
<p>Text in parentheses is comments. Letters are variables that can stand
for anything.</p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 38%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr>
<th>Connective</th>
<th>Introduction Rules</th>
<th>Elimination Rules</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\top</span></td>
<td><span class="math inline">\frac{}{\top}</span></td>
<td>doesn’t have</td>
</tr>
<tr>
<td><span class="math inline">\bot</span></td>
<td>doesn’t have</td>
<td><span class="math inline">\frac{\bot}{a}</span> (i.e.,
anything)</td>
</tr>
<tr>
<td><span class="math inline">\wedge</span></td>
<td><span class="math inline">\frac{a \quad b}{a \wedge b}</span></td>
<td><span class="math inline">\frac{a \wedge b}{a}</span> (take first)  
<span class="math inline">\frac{a \wedge b}{b}</span> (take second)</td>
</tr>
<tr>
<td><span class="math inline">\vee</span></td>
<td><span class="math inline">\frac{a}{a \vee b}</span> (put first)  
<span class="math inline">\frac{b}{a \vee b}</span> (put second)</td>
<td><span class="math inline">\frac{a \vee b \quad
\genfrac{}{}{0pt}{}{[a]^x}{\vdots \; c} \quad
\genfrac{}{}{0pt}{}{[b]^y}{\vdots \; c}}{c}</span> using <span
class="math inline">x, y</span></td>
</tr>
<tr>
<td><span class="math inline">\rightarrow</span></td>
<td><span class="math inline">\frac{\genfrac{}{}{0pt}{}{[a]^x}{\vdots \;
b}}{a \rightarrow b}</span> using <span
class="math inline">x</span></td>
<td><span class="math inline">\frac{a \rightarrow b \quad
a}{b}</span></td>
</tr>
</tbody>
</table>
<h4 id="notation-for-hypothetical-derivations">Notation for Hypothetical
Derivations</h4>
<p>The notation <span
class="math inline">\genfrac{}{}{0pt}{}{[a]^x}{\vdots \; b}</span>
(sometimes written as a tree) matches any subtree that derives <span
class="math inline">b</span> and can use <span
class="math inline">a</span> as an assumption (marked with label <span
class="math inline">x</span>), even though <span
class="math inline">a</span> might not otherwise be warranted.</p>
<p>For example, we can derive “sunny <span
class="math inline">\rightarrow</span> happy” by showing that
<em>assuming</em> it’s sunny, we can derive happiness:</p>
<p><span class="math display">
\frac{\frac{\frac{\frac{\frac{\,}{\text{sunny}}^x}{\text{go
outdoor}}}{\text{playing}}}{\text{happy}}}{\text{sunny} \rightarrow
\text{happy}} \text{ using } x
</span></p>
<p>Such assumptions can only be used in the matched subtree! But they
can be used several times. For example, if someone’s mood is more
difficult to influence:</p>
<p><span class="math display">
\frac{\frac{
  \frac{\frac{\frac{\,}{\text{sunny}}^x}{\text{go
outdoor}}}{\text{playing}} \quad
  \frac{\frac{\,}{\text{sunny}}^x \quad
\frac{\frac{\,}{\text{sunny}}^x}{\text{go outdoor}}}{\text{nice view}}
}{\text{happy}}}{\text{sunny} \rightarrow \text{happy}} \text{ using } x
</span></p>
<h4 id="reasoning-by-cases">Reasoning by Cases</h4>
<p>The elimination rule for disjunction represents <strong>reasoning by
cases</strong>.</p>
<p>How can we use the fact that it is sunny <span
class="math inline">\vee</span> cloudy (but not rainy)?</p>
<p><span class="math display">
\frac{
  \frac{\,}{\text{sunny} \vee \text{cloudy}}^{\text{forecast}} \quad
  \frac{\frac{\,}{\text{sunny}}^x}{\text{no-umbrella}} \quad
  \frac{\frac{\,}{\text{cloudy}}^y}{\text{no-umbrella}}
}{\text{no-umbrella}} \text{ using } x, y
</span></p>
<p>We know that it will be sunny or cloudy (by watching the weather
forecast). If it will be sunny, we won’t need an umbrella. If it will be
cloudy, we won’t need an umbrella. Therefore, we won’t need an
umbrella.</p>
<h4 id="reasoning-by-induction">Reasoning by Induction</h4>
<p>We need one more kind of rule to do serious math: <strong>reasoning
by induction</strong> (somewhat similar to reasoning by cases). Example
rule for induction on natural numbers:</p>
<p><span class="math display">
\frac{p(0) \quad \genfrac{}{}{0pt}{}{[p(x)]^x}{\vdots \; p(x+1)}}{p(n)}
\text{ by induction, using } x
</span></p>
<p>We get property <span class="math inline">p</span> for any natural
number <span class="math inline">n</span>, provided we can: 1. Establish
<span class="math inline">p(0)</span> (the base case) 2. Show that
assuming <span class="math inline">p(x)</span> holds, we can derive
<span class="math inline">p(x+1)</span> (the inductive step)</p>
<p>Here <span class="math inline">x</span> is a unique variable—we
cannot substitute a particular number for it because we write “using
<span class="math inline">x</span>” on the side.</p>
<h3 id="logos-was-programmed-in-ocaml">1.3 Logos was Programmed in
OCaml</h3>
<p>There is a deep correspondence between logic and programming, known
as the <strong>Curry-Howard correspondence</strong> (or “propositions as
types”). The following table shows how logical connectives correspond to
programming constructs:</p>
<table>
<thead>
<tr>
<th>Logic</th>
<th>Type</th>
<th>Expression</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\top</span></td>
<td><code>unit</code></td>
<td><code>()</code></td>
</tr>
<tr>
<td><span class="math inline">\bot</span></td>
<td><code>'a</code></td>
<td><code>raise</code></td>
</tr>
<tr>
<td><span class="math inline">\wedge</span></td>
<td><code>*</code></td>
<td><code>(,)</code></td>
</tr>
<tr>
<td><span class="math inline">\vee</span></td>
<td><code>|</code></td>
<td><code>match</code></td>
</tr>
<tr>
<td><span class="math inline">\rightarrow</span></td>
<td><code>-&gt;</code></td>
<td><code>fun</code></td>
</tr>
<tr>
<td>induction</td>
<td>—</td>
<td><code>rec</code></td>
</tr>
</tbody>
</table>
<p><strong>Typing rules for OCaml constructs:</strong></p>
<ul>
<li><p><strong>Unit (truth):</strong> <span
class="math inline">\frac{}{\texttt{()} : \texttt{unit}}</span></p></li>
<li><p><strong>Exception (falsehood):</strong> <span
class="math inline">\frac{\text{oops!}}{\texttt{raise exn} : c}</span> —
can produce any type</p></li>
<li><p><strong>Pair (conjunction):</strong></p>
<ul>
<li>Introduction: <span class="math inline">\frac{s : a \quad t : b}{(s,
t) : a * b}</span></li>
<li>Elimination: <span class="math inline">\frac{p : a *
b}{\texttt{fst}~p : a}</span> and <span class="math inline">\frac{p : a
* b}{\texttt{snd}~p : b}</span></li>
</ul></li>
<li><p><strong>Variant (disjunction):</strong></p>
<ul>
<li>Introduction: <span class="math inline">\frac{s : a}{\texttt{A}(s) :
\texttt{A of}~a~|~\texttt{B of}~b}</span></li>
<li>Elimination (match): given <span class="math inline">t</span> of
variant type and branches for each case, produce result <span
class="math inline">c</span></li>
</ul></li>
<li><p><strong>Function (implication):</strong></p>
<ul>
<li>Introduction: <span class="math inline">\frac{\genfrac{}{}{0pt}{}{[x
: a]}{e : b}}{\texttt{fun}~x \to e : a \to b}</span></li>
<li>Elimination (application): <span class="math inline">\frac{f : a \to
b \quad t : a}{f~t : b}</span></li>
</ul></li>
<li><p><strong>Recursion (induction):</strong> <span
class="math inline">\frac{\genfrac{}{}{0pt}{}{[x : a]}{e :
a}}{\texttt{rec}~x = e : a}</span></p></li>
</ul>
<h4 id="definitions">1.3.1 Definitions</h4>
<p>Writing out expressions and types repetitively is tedious: we need
definitions.</p>
<p><strong>Type definitions</strong> are written: <code>type ty =</code>
some type.</p>
<ul>
<li><p>Writing <code>A(s) : A of a | B of b</code> in the table was
cheating. Usually we have to define the type and then use it. For
example, using <code>int</code> for <span class="math inline">a</span>
and <code>string</code> for <span class="math inline">b</span>:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> int_string_choice = A <span class="kw">of</span> <span class="dt">int</span> | B <span class="kw">of</span> <span class="dt">string</span></span></code></pre></div>
<p>This allows us to write
<code>A(s) : int_string_choice</code>.</p></li>
<li><p>Without the type definition, it is difficult to know what other
variants there are when one <em>infers</em> (i.e., “guesses”, computes)
the type!</p></li>
<li><p>In OCaml we can write <code>`A(s) : [`A of a | `B of b]</code>.
With “<code>`</code>” variants (polymorphic variants), OCaml does guess
what other variants there are. These types are interesting, but we will
not focus on them in this book.</p></li>
<li><p>Tuple elements don’t need labels because we always know at which
position a tuple element stands. But having labels makes code more
clear, so we can define a <em>record type</em>:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> int_string_record = {a: <span class="dt">int</span>; b: <span class="dt">string</span>}</span></code></pre></div>
<p>and create its values: <code>{a = 7; b = "Mary"}</code>.</p></li>
<li><p>We access the <em>fields</em> of records using the dot notation:
<code>{a=7; b="Mary"}.b = "Mary"</code>.</p></li>
</ul>
<h4 id="expression-definitions">1.3.2 Expression Definitions</h4>
<p>The recursive expression <code>rec x = e</code> in the table was
cheating: <code>rec</code> (usually called <code>fix</code> in theory)
cannot appear alone in OCaml! It must be part of a definition.</p>
<p><strong>Definitions for expressions</strong> are introduced by rules
a bit more complex:</p>
<p><span class="math display">
\frac{e_1 : a \quad \frac{[x : a]}{e_2 : b}}{\texttt{let } x = e_1
\texttt{ in } e_2 : b}
</span></p>
<p>(Note that this rule is the same as introducing and eliminating <span
class="math inline">\rightarrow</span>.)</p>
<p>For recursive definitions:</p>
<p><span class="math display">
\frac{\frac{[x : a]}{e_1 : a} \quad \frac{[x : a]}{e_2 : b}}{\texttt{let
rec } x = e_1 \texttt{ in } e_2 : b}
</span></p>
<p>We will cover what is missing in the above rules when we discuss
<strong>polymorphism</strong>.</p>
<h4 id="scoping-rules">1.3.3 Scoping Rules</h4>
<ul>
<li><p><strong>Type definitions</strong> we have seen above are
<em>global</em>: they need to be at the top-level (not nested in
expressions), and they extend from the point they occur till the end of
the source file or interactive session.</p></li>
<li><p><strong><code>let</code>-<code>in</code> definitions</strong> for
expressions: <code>let x = e1 in e2</code> are <em>local</em>—<span
class="math inline">x</span> is only visible in <span
class="math inline">e_2</span>. But <strong><code>let</code>
definitions</strong> without <code>in</code> are global: placing
<code>let x = e1</code> at the top-level makes <span
class="math inline">x</span> visible from after <span
class="math inline">e_1</span> till the end of the source file or
interactive session.</p></li>
<li><p>In the interactive session (toplevel/REPL), we mark the end of a
top-level “sentence” with <code>;;</code>—this is unnecessary in source
files.</p></li>
</ul>
<h4 id="operators">1.3.4 Operators</h4>
<p>Operators like <code>+</code>, <code>*</code>, <code>&lt;</code>,
<code>=</code> are names of functions. Just like other names, you can
use operator names for your own functions:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (+:) a b = <span class="dt">String</span>.concat <span class="st">&quot;&quot;</span> [a; b]  <span class="co">(* Special way of defining *)</span></span></code></pre></div>
<div class="sourceCode" id="cb4"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;Alpha&quot;</span> +: <span class="st">&quot;Beta&quot;</span>  <span class="co">(* but normal way of using operators *)</span></span></code></pre></div>
<p>Operators in OCaml are <strong>not overloaded</strong>. This means
that every type needs its own set of operators: - <code>+</code>,
<code>*</code>, <code>/</code> work for integers - <code>+.</code>,
<code>*.</code>, <code>/.</code> work for floating point numbers</p>
<p><strong>Exception:</strong> Comparisons <code>&lt;</code>,
<code>=</code>, etc. work for all values other than functions.</p>
<h3 id="exercises">1.4 Exercises</h3>
<p>Exercises from <em>Think OCaml: How to Think Like a Computer
Scientist</em> by Nicholas Monje and Allen Downey.</p>
<ol type="1">
<li><p>Assume that we execute the following assignment statements:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> width = <span class="dv">17</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> height = <span class="fl">12.0</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> delimiter = <span class="ch">&#39;.&#39;</span></span></code></pre></div>
<p>For each of the following expressions, write the value of the
expression and the type (of the value of the expression), or the
resulting type error.</p>
<ol type="1">
<li><code>width/2</code></li>
<li><code>width/.2.0</code></li>
<li><code>height/3</code></li>
<li><code>1 + 2 * 5</code></li>
<li><code>delimiter * 5</code></li>
</ol></li>
<li><p>Practice using the OCaml interpreter as a calculator:</p>
<ol type="1">
<li>The volume of a sphere with radius <span
class="math inline">r</span> is <span class="math inline">\frac{4}{3}
\pi r^3</span>. What is the volume of a sphere with radius 5?
(<em>Hint:</em> 392.6 is wrong!)</li>
<li>Suppose the cover price of a book is $24.95, but bookstores get a
40% discount. Shipping costs $3 for the first copy and 75 cents for each
additional copy. What is the total wholesale cost for 60 copies?</li>
<li>If I leave my house at 6:52 am and run 1 mile at an easy pace (8:15
per mile), then 3 miles at tempo (7:12 per mile) and 1 mile at easy pace
again, what time do I get home for breakfast?</li>
</ol></li>
<li><p>You’ve probably heard of the Fibonacci numbers before, but in
case you haven’t, they’re defined by the following recursive
relationship: <span class="math display">
\begin{cases}
f(0) = 0 \\
f(1) = 1 \\
f(n+1) = f(n) + f(n-1) &amp; \text{for } n = 2, 3, \ldots
\end{cases}
</span> Write a recursive function to calculate these numbers.</p></li>
<li><p>A palindrome is a word that is spelled the same backward and
forward, like “noon” and “redivider”. Recursively, a word is a
palindrome if the first and last letters are the same and the middle is
a palindrome.</p>
<p>The following are functions that take a string argument and return
the first, last, and middle letters:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> first_char word = word.[<span class="dv">0</span>]</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> last_char word =</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> len = <span class="dt">String</span>.length word - <span class="dv">1</span> <span class="kw">in</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  word.[len]</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> middle word =</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> len = <span class="dt">String</span>.length word - <span class="dv">2</span> <span class="kw">in</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">String</span>.sub word <span class="dv">1</span> len</span></code></pre></div>
<ol type="1">
<li>Enter these functions into the toplevel and test them out. What
happens if you call <code>middle</code> with a string with two letters?
One letter? What about the empty string <code>""</code>?</li>
<li>Write a function called <code>is_palindrome</code> that takes a
string argument and returns <code>true</code> if it is a palindrome and
<code>false</code> otherwise.</li>
</ol></li>
<li><p>The greatest common divisor (GCD) of <span
class="math inline">a</span> and <span class="math inline">b</span> is
the largest number that divides both of them with no remainder.</p>
<p>One way to find the GCD of two numbers is Euclid’s algorithm, which
is based on the observation that if <span class="math inline">r</span>
is the remainder when <span class="math inline">a</span> is divided by
<span class="math inline">b</span>, then <span
class="math inline">\gcd(a, b) = \gcd(b, r)</span>. As a base case, we
can consider <span class="math inline">\gcd(a, 0) = a</span>.</p>
<p>Write a function called <code>gcd</code> that takes parameters
<code>a</code> and <code>b</code> and returns their greatest common
divisor.</p>
<p>If you need help, see <a
href="http://en.wikipedia.org/wiki/Euclidean_algorithm">http://en.wikipedia.org/wiki/Euclidean_algorithm</a>.</p></li>
</ol>
<h2 id="chapter-2-algebra">Chapter 2: Algebra</h2>
<p><em>Algebraic Data Types and some curious analogies</em></p>
<h3 id="a-glimpse-at-type-inference">2.1 A Glimpse at Type
Inference</h3>
<p>For a refresher, let us apply the type inference rules introduced in
Chapter 1 to some simple examples. We will start with the identity
function <code>fun x -&gt; x</code>. In the derivations below, <span
class="math inline">[?]</span> means “type unknown yet.”</p>
<p>We begin with an incomplete derivation:</p>
<p><span class="math display">
\frac{[?]}{\texttt{fun x -&gt; x} : [?]}
</span></p>
<p>Using the <span class="math inline">\rightarrow</span> introduction
rule, we need to derive the body <code>x</code> assuming <code>x</code>
has some type <span class="math inline">a</span>:</p>
<p><span class="math display">
\frac{\frac{\,}{\texttt{x} : a}^x}{\texttt{fun x -&gt; x} : [?]
\rightarrow [?]}
</span></p>
<p>The premise <span class="math inline">\frac{\,}{\texttt{x} :
a}^x</span> matches the pattern for hypothetical derivations since <span
class="math inline">e = \texttt{x}</span>. Since the body <code>x</code>
has type <span class="math inline">a</span> (from our assumption), and
the parameter <code>x</code> also has type <span
class="math inline">a</span>, we conclude:</p>
<p><span class="math display">
\frac{\frac{\,}{\texttt{x} : a}^x}{\texttt{fun x -&gt; x} : a
\rightarrow a}
</span></p>
<p>Because <span class="math inline">a</span> is arbitrary (we made no
assumptions constraining it), OCaml introduces a <em>type variable</em>
<code>'a</code> to represent it:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">fun</span> x -&gt; x;;</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>- : &#39;a -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
<h4 id="a-more-complex-example">A More Complex Example</h4>
<p>Let us try <code>fun x -&gt; x+1</code>, which is the same as
<code>fun x -&gt; ((+) x) 1</code> (try it in OCaml!). We will use the
notation <span class="math inline">[?\alpha]</span> to mean “type
unknown yet, but the same as in other places marked <span
class="math inline">[?\alpha]</span>.”</p>
<p>Starting the derivation and applying <span
class="math inline">\rightarrow</span> introduction:</p>
<p><span class="math display">
\frac{\frac{[?]}{\texttt{((+) x) 1} : [?\alpha]}}{\texttt{fun x -&gt;
((+) x) 1} : [?] \rightarrow [?\alpha]}
</span></p>
<p>Applying <span class="math inline">\rightarrow</span> elimination
(function application) to <code>((+) x) 1</code>:</p>
<p><span class="math display">
\frac{\frac{\frac{[?]}{\texttt{(+) x} : [?\beta] \rightarrow [?\alpha]}
\quad \frac{[?]}{\texttt{1} : [?\beta]}}{\texttt{((+) x) 1} :
[?\alpha]}}{\texttt{fun x -&gt; ((+) x) 1} : [?] \rightarrow [?\alpha]}
</span></p>
<p>We know that <code>1 : int</code>, so <span
class="math inline">[?\beta] = \texttt{int}</span>:</p>
<p><span class="math display">
\frac{\frac{\frac{[?]}{\texttt{(+) x} : \texttt{int} \rightarrow
[?\alpha]} \quad \frac{\,}{\texttt{1} :
\texttt{int}}^{\text{(constant)}}}{\texttt{((+) x) 1} :
[?\alpha]}}{\texttt{fun x -&gt; ((+) x) 1} : [?] \rightarrow [?\alpha]}
</span></p>
<p>Applying function application again to <code>(+) x</code>:</p>
<p><span class="math display">
\frac{\frac{\frac{\frac{[?]}{\texttt{(+)} : [?\gamma] \rightarrow
\texttt{int} \rightarrow [?\alpha]} \quad \frac{[?]}{\texttt{x} :
[?\gamma]}}{\texttt{(+) x} : \texttt{int} \rightarrow [?\alpha]} \quad
\frac{\,}{\texttt{1} : \texttt{int}}^{\text{(constant)}}}{\texttt{((+)
x) 1} : [?\alpha]}}{\texttt{fun x -&gt; ((+) x) 1} : [?\gamma]
\rightarrow [?\alpha]}
</span></p>
<p>Since <code>(+) : int -&gt; int -&gt; int</code>, we have <span
class="math inline">[?\gamma] = \texttt{int}</span> and <span
class="math inline">[?\alpha] = \texttt{int}</span>:</p>
<p><span class="math display">
\frac{\frac{\frac{\frac{\,}{\texttt{(+)} : \texttt{int} \rightarrow
\texttt{int} \rightarrow \texttt{int}}^{\text{(constant)}} \quad
\frac{\,}{\texttt{x} : \texttt{int}}^x}{\texttt{(+) x} : \texttt{int}
\rightarrow \texttt{int}} \quad \frac{\,}{\texttt{1} :
\texttt{int}}^{\text{(constant)}}}{\texttt{((+) x) 1} :
\texttt{int}}}{\texttt{fun x -&gt; ((+) x) 1} : \texttt{int} \rightarrow
\texttt{int}}
</span></p>
<h4 id="curried-form">2.1.1 Curried Form</h4>
<p>When there are several arrows “on the same depth” in a function type,
it means that the function returns a function. For example,
<code>(+) : int -&gt; int -&gt; int</code> is just a shorthand for
<code>(+) : int -&gt; (int -&gt; int)</code>. This is very different
from:</p>
<p><span class="math display">
\texttt{fun f -&gt; (f 1) + 1} : (\texttt{int} \rightarrow \texttt{int})
\rightarrow \texttt{int}
</span></p>
<p>In the first case, <code>(+)</code> is a function that takes an
integer and returns a function from integers to integers. In the second
case, we have a function that takes a function as an argument.</p>
<p>For addition, instead of <code>(fun x -&gt; x+1)</code> we can write
<code>((+) 1)</code>. What expanded form does <code>((+) 1)</code>
correspond to exactly (computationally)? It corresponds to
<code>fun y -&gt; 1 + y</code>.</p>
<p>We will become more familiar with functions returning functions when
we study the <em>lambda calculus</em> in a later chapter.</p>
<h3 id="algebraic-data-types">2.2 Algebraic Data Types</h3>
<p>In Chapter 1, we learned about the <code>unit</code> type and variant
types like:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> int_string_choice = A <span class="kw">of</span> <span class="dt">int</span> | B <span class="kw">of</span> <span class="dt">string</span></span></code></pre></div>
<p>We also covered tuple types, record types, and type definitions. Let
us now explore these concepts more deeply.</p>
<h4 id="variants-without-arguments">Variants Without Arguments</h4>
<p>Variants do not have to carry arguments. Instead of writing
<code>A of unit</code>, we can simply use <code>A</code>. This is more
convenient and idiomatic:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> color = Red | Green | Blue</span></code></pre></div>
<p><strong>A subtle point about OCaml:</strong> In OCaml, variants take
multiple arguments rather than taking tuples as arguments. This means
<code>A of int * string</code> is different from
<code>A of (int * string)</code>. The first takes two separate
arguments, while the second takes a single tuple argument. This
distinction is usually not important unless you encounter situations
where it matters.</p>
<h4 id="recursive-type-definitions">Recursive Type Definitions</h4>
<p>Type definitions can be recursive! This allows us to define data
structures of arbitrary size:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> int_list = Empty | Cons <span class="kw">of</span> <span class="dt">int</span> * int_list</span></code></pre></div>
<p>Let us see what values inhabit <code>int_list</code>: -
<code>Empty</code> represents the empty list -
<code>Cons (5, Empty)</code> is a list containing just 5 -
<code>Cons (5, Cons (7, Cons (13, Empty)))</code> is a list containing
5, 7, and 13</p>
<p>The built-in type <code>bool</code> can be viewed as if it were
defined as <code>type bool = true | false</code>. Similarly,
<code>int</code> can be thought of as a very large variant:
<code>type int = 0 | -1 | 1 | -2 | 2 | ...</code></p>
<h4 id="parametric-type-definitions">Parametric Type Definitions</h4>
<p>Type definitions can be <em>parametric</em> with respect to the types
of their components. This allows us to define generic data structures
that work with any element type. For example, a list of elements of
arbitrary type:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;elem <span class="dt">list</span> = Empty | Cons <span class="kw">of</span> &#39;elem * &#39;elem <span class="dt">list</span></span></code></pre></div>
<p>Several conventions and syntax rules apply to parametric types:</p>
<ul>
<li><p>Type variables must start with <code>'</code>, but since OCaml
will not remember the names we give, it is customary to use the names
OCaml uses: <code>'a</code>, <code>'b</code>, <code>'c</code>,
<code>'d</code>, etc.</p></li>
<li><p>The OCaml syntax places the type parameter before the type name,
mimicking English word order. A silly example:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;white_color dog = Dog <span class="kw">of</span> &#39;white_color</span></code></pre></div></li>
<li><p>With multiple parameters, OCaml uses parentheses:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (&#39;a, &#39;b) choice = Left <span class="kw">of</span> &#39;a | Right <span class="kw">of</span> &#39;b</span></code></pre></div>
<p>Compare this to F# syntax:
<code>type choice&lt;'a,'b&gt; = Left of 'a | Right of 'b</code></p>
<p>And Haskell syntax:
<code>data Choice a b = Left a | Right b</code></p></li>
</ul>
<h3 id="syntactic-conventions">2.3 Syntactic Conventions</h3>
<h4 id="constructor-naming">Constructor Naming</h4>
<p>Names of variants, called <em>constructors</em>, must start with a
capital letter. If we wanted to define our own booleans, we would
write:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> my_bool = True | False</span></code></pre></div>
<p>Only constructors and module names can start with capital letters in
OCaml. <em>Modules</em> are organizational units (like “shelves”)
containing related values. For example, the <code>List</code> module
provides operations on lists, including <code>List.map</code> and
<code>List.filter</code>.</p>
<h4 id="accessing-record-fields">Accessing Record Fields</h4>
<p>We can use dot notation to access record fields:
<code>record.field</code>. For example, if we have
<code>let person = {name="Alice"; age=30}</code>, we can write
<code>person.name</code> to get <code>"Alice"</code>.</p>
<h4 id="function-definition-shortcuts">Function Definition
Shortcuts</h4>
<p>Several syntactic shortcuts make function definitions more
concise:</p>
<ul>
<li><p><code>fun x y -&gt; e</code> stands for
<code>fun x -&gt; fun y -&gt; e</code>. Note that
<code>fun x -&gt; fun y -&gt; e</code> parses as
<code>fun x -&gt; (fun y -&gt; e)</code>.</p></li>
<li><p><code>function A x -&gt; e1 | B y -&gt; e2</code> stands for
<code>fun p -&gt; match p with A x -&gt; e1 | B y -&gt; e2</code>. The
general form is: <code>function PATTERN-MATCHING</code> stands for
<code>fun v -&gt; match v with PATTERN-MATCHING</code>.</p></li>
<li><p><code>let f ARGS = e</code> is a shorthand for
<code>let f = fun ARGS -&gt; e</code>.</p></li>
</ul>
<h3 id="pattern-matching">2.4 Pattern Matching</h3>
<p>Recall that we introduced <code>fst</code> and <code>snd</code> as
means to access elements of a pair. But what about larger tuples? The
fundamental way to access any tuple uses the <code>match</code>
construct. In fact, <code>fst</code> and <code>snd</code> can easily be
defined using pattern matching:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">fst</span> = <span class="kw">fun</span> p -&gt; <span class="kw">match</span> p <span class="kw">with</span> (a, b) -&gt; a</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">snd</span> = <span class="kw">fun</span> p -&gt; <span class="kw">match</span> p <span class="kw">with</span> (a, b) -&gt; b</span></code></pre></div>
<h4 id="matching-on-records">Matching on Records</h4>
<p>Pattern matching also works with records:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> person = {name: <span class="dt">string</span>; surname: <span class="dt">string</span>; age: <span class="dt">int</span>}</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> greet_person () =</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> {name=<span class="st">&quot;Walker&quot;</span>; surname=<span class="st">&quot;Johnnie&quot;</span>; age=<span class="dv">207</span>}</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">with</span> {name=n; surname=sn; age=a} -&gt; <span class="st">&quot;Hi &quot;</span> ^ sn ^ <span class="st">&quot;!&quot;</span></span></code></pre></div>
<h4 id="understanding-patterns">Understanding Patterns</h4>
<p>The left-hand sides of <code>-&gt;</code> in <code>match</code>
expressions are called <strong>patterns</strong>. Patterns describe the
structure of values we want to match against.</p>
<p>Patterns can be nested, allowing us to match complex structures:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> <span class="dt">Some</span> (<span class="dv">5</span>, <span class="dv">7</span>) <span class="kw">with</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>| <span class="dt">None</span> -&gt; <span class="st">&quot;sum: nothing&quot;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>| <span class="dt">Some</span> (x, y) -&gt; <span class="st">&quot;sum: &quot;</span> ^ <span class="dt">string_of_int</span> (x+y)</span></code></pre></div>
<h4 id="simple-patterns-and-wildcards">Simple Patterns and
Wildcards</h4>
<p>A pattern can simply bind the entire value without destructuring.
Writing <code>match f x with v -&gt; ...</code> is the same as
<code>let v = f x in ...</code>.</p>
<p>When we do not need a value in a pattern, it is good practice to use
the underscore <code>_</code>, which is a wildcard (not a variable):</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">fst</span> (a, _) = a</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">snd</span> (_, b) = b</span></code></pre></div>
<h4 id="pattern-linearity">Pattern Linearity</h4>
<p>A variable can only appear once in a pattern. This property is called
<em>linearity</em>. However, we can add conditions to patterns using
<code>when</code>, so linearity is not a limitation:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> describe_point p =</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> p <span class="kw">with</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  | (x, y) <span class="kw">when</span> x = y -&gt; <span class="st">&quot;diag&quot;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; <span class="st">&quot;off-diag&quot;</span></span></code></pre></div>
<p>Here is a more elaborate example:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">compare</span> a b = <span class="kw">match</span> a, b <span class="kw">with</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  | (x, y) <span class="kw">when</span> x &lt; y -&gt; <span class="dv">-1</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  | (x, y) <span class="kw">when</span> x = y -&gt; <span class="dv">0</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; <span class="dv">1</span></span></code></pre></div>
<h4 id="partial-record-patterns">Partial Record Patterns</h4>
<p>We can skip unused fields of a record in a pattern. Only the fields
we care about need to be mentioned.</p>
<h4 id="or-patterns">Or-Patterns</h4>
<p>We can compress patterns by using <code>|</code> inside a single
pattern to match multiple alternatives:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> month =</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  | Jan | Feb | Mar | Apr | May | Jun</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  | Jul | Aug | Sep | Oct | Nov | Dec</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> weekday = Mon | Tue | Wed | Thu | Fri | Sat | Sun</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date =</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>  {year: <span class="dt">int</span>; month: month; day: <span class="dt">int</span>; weekday: weekday}</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> day =</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>  {year = <span class="dv">2012</span>; month = Feb; day = <span class="dv">14</span>; weekday = Wed};;</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> day <span class="kw">with</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>  | {weekday = Sat | Sun} -&gt; <span class="st">&quot;Weekend!&quot;</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; <span class="st">&quot;Work day&quot;</span></span></code></pre></div>
<h4 id="named-patterns-with-as">Named Patterns with <code>as</code></h4>
<p>We use <code>(pattern as v)</code> to name a nested pattern, binding
the matched value to <code>v</code>:</p>
<pre><code>match day with
  | {weekday = (Mon | Tue | Wed | Thu | Fri as wday)}
      when not (day.month = Dec &amp;&amp; day.day = 24) -&gt;
    Some (work (get_plan wday))
  | _ -&gt; None</code></pre>
<p>This example shows the <code>as</code> keyword binding the matched
weekday to <code>wday</code> for use in the expression on the right side
of the arrow.</p>
<h3 id="interpreting-algebraic-data-types-as-polynomials">2.5
Interpreting Algebraic Data Types as Polynomials</h3>
<p>Let us explore a curious analogy between algebraic data types and
polynomials. We translate data types to mathematical expressions by:</p>
<ul>
<li>Replacing <code>|</code> (variant choice) with <span
class="math inline">+</span></li>
<li>Replacing <code>*</code> (tuple product) with <span
class="math inline">\times</span></li>
<li>Treating record types as tuple types (erasing field names and
translating <code>;</code> as <span
class="math inline">\times</span>)</li>
</ul>
<p>We also need translations for some special types:</p>
<ul>
<li><p>The <strong>void type</strong> (a type with no constructors,
hence no values):</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> void</span></code></pre></div>
<p>(Yes, this is its complete definition, with no
<code>= something</code> part.) Translate it as <span
class="math inline">0</span>.</p></li>
<li><p>The <strong>unit type</strong> translates as <span
class="math inline">1</span>. Since variants without arguments behave
like variants <code>of unit</code>, translate them as <span
class="math inline">1</span> as well.</p></li>
<li><p>The <strong>bool type</strong> translates as <span
class="math inline">2</span>.</p></li>
<li><p>Types like <code>int</code>, <code>string</code>,
<code>float</code>, and type parameters translate as variables.</p></li>
<li><p>Defined types translate according to their definitions
(substituting variables as necessary).</p></li>
</ul>
<p>Give a name to the type being defined (representing a function of the
introduced variables). Now interpret the result as an ordinary numeric
polynomial! (Or a “rational function” if recursively defined.)</p>
<p>Let us have some fun with this translation.</p>
<h4 id="example-date-type">Example: Date Type</h4>
<div class="sourceCode" id="cb24"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = {year: <span class="dt">int</span>; month: <span class="dt">int</span>; day: <span class="dt">int</span>}</span></code></pre></div>
<p>Translating to a polynomial (using <span class="math inline">x</span>
for <code>int</code>):</p>
<p><span class="math display">D = x \times x \times x = x^3</span></p>
<h4 id="example-option-type">Example: Option Type</h4>
<p>The built-in option type is defined as:</p>
<pre><code>type &#39;a option = None | Some of &#39;a</code></pre>
<p>Translating:</p>
<p><span class="math display">O = 1 + x</span></p>
<h4 id="example-list-type">Example: List Type</h4>
<div class="sourceCode" id="cb26"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a my_list = Empty | Cons <span class="kw">of</span> &#39;a * &#39;a my_list</span></code></pre></div>
<p>Translating (where <span class="math inline">L</span> represents the
list type):</p>
<p><span class="math display">L = 1 + x \cdot L</span></p>
<h4 id="example-binary-tree-type">Example: Binary Tree Type</h4>
<div class="sourceCode" id="cb27"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree = Tip | Node <span class="kw">of</span> <span class="dt">int</span> * btree * btree</span></code></pre></div>
<p>Translating:</p>
<p><span class="math display">T = 1 + x \cdot T \cdot T = 1 + x \cdot
T^2</span></p>
<h4 id="type-isomorphisms">Type Isomorphisms</h4>
<p>When translations of two types are equal according to the laws of
high-school algebra, the types are <em>isomorphic</em>. This means there
exist bijective (one-to-one and onto) functions between them.</p>
<p>Let us manipulate the binary tree polynomial:</p>
<p><span class="math display">
\begin{aligned}
T &amp;= 1 + x \cdot T^2 \\
  &amp;= 1 + x \cdot T + x^2 \cdot T^3 \\
  &amp;= 1 + x + x^2 \cdot T^2 + x^2 \cdot T^3 \\
  &amp;= 1 + x + x^2 \cdot T^2 \cdot (1 + T) \\
  &amp;= 1 + x \cdot (1 + x \cdot T^2 \cdot (1 + T))
\end{aligned}
</span></p>
<p>Now let us translate the resulting expression back to a type:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> repr =</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">int</span> * (<span class="dt">int</span> * btree * btree * btree <span class="dt">option</span>) <span class="dt">option</span>) <span class="dt">option</span></span></code></pre></div>
<p>The challenge is to find isomorphism functions with signatures:</p>
<pre><code>val iso1 : btree -&gt; repr
val iso2 : repr -&gt; btree</code></pre>
<p>These functions should satisfy: for all trees <code>t</code>,
<code>iso2 (iso1 t) = t</code>, and for all representations
<code>r</code>, <code>iso1 (iso2 r) = r</code>.</p>
<h4 id="a-first-attempt">A First Attempt</h4>
<p>Here is a first (failed) attempt:</p>
<pre><code># let iso1 (t : btree) : repr =
  match t with
    | Tip -&gt; None
    | Node (x, Tip, Tip) -&gt; Some (x, None)
    | Node (x, Node (y, t1, t2), Tip) -&gt;
      Some (x, Some (y, t1, t2, None))
    | Node (x, Node (y, t1, t2), t3) -&gt;
      Some (x, Some (y, t1, t2, Some t3));;

Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Node (_, Tip, Node (_, _, _))</code></pre>
<p>We forgot about one case! It seems difficult to guess the solution
directly.</p>
<h4 id="breaking-down-the-problem">Breaking Down the Problem</h4>
<p>Let us divide the task into smaller steps corresponding to
intermediate points in the polynomial transformation:</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (&#39;a, &#39;b) choice = Left <span class="kw">of</span> &#39;a | Right <span class="kw">of</span> &#39;b</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> interm1 =</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>  ((<span class="dt">int</span> * btree, <span class="dt">int</span> * <span class="dt">int</span> * btree * btree * btree) choice)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">option</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> interm2 =</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>  ((<span class="dt">int</span>, <span class="dt">int</span> * <span class="dt">int</span> * btree * btree * btree <span class="dt">option</span>) choice)</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">option</span></span></code></pre></div>
<p>Now we can define each step:</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> step1r (t : btree) : interm1 =</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> t <span class="kw">with</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    | Tip -&gt; <span class="dt">None</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    | Node (x, t1, Tip) -&gt; <span class="dt">Some</span> (Left (x, t1))</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    | Node (x, t1, Node (y, t2, t3)) -&gt;</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Some</span> (Right (x, y, t1, t2, t3))</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> step2r (r : interm1) : interm2 =</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> r <span class="kw">with</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">None</span> -&gt; <span class="dt">None</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (Left (x, Tip)) -&gt; <span class="dt">Some</span> (Left x)</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (Left (x, Node (y, t1, t2))) -&gt;</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Some</span> (Right (x, y, t1, t2, <span class="dt">None</span>))</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (Right (x, y, t1, t2, t3)) -&gt;</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Some</span> (Right (x, y, t1, t2, <span class="dt">Some</span> t3))</span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> step3r (r : interm2) : repr =</span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> r <span class="kw">with</span></span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">None</span> -&gt; <span class="dt">None</span></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (Left x) -&gt; <span class="dt">Some</span> (x, <span class="dt">None</span>)</span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (Right (x, y, t1, t2, t3opt)) -&gt;</span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Some</span> (x, <span class="dt">Some</span> (y, t1, t2, t3opt))</span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> iso1 (t : btree) : repr =</span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a>  step3r (step2r (step1r t))</span></code></pre></div>
<p>Defining <code>step1l</code>, <code>step2l</code>,
<code>step3l</code>, and <code>iso2</code> is now straightforward—each
step is the inverse of its corresponding forward step.</p>
<h4 id="take-home-lessons">Take-Home Lessons</h4>
<ol type="1">
<li><p><strong>Design for validity:</strong> Try to define data
structures so that only meaningful information can be represented—as
long as it does not overcomplicate the data structures. Avoid catch-all
clauses when defining functions. The compiler will then tell you if you
have forgotten about a case.</p></li>
<li><p><strong>Divide and conquer:</strong> Break solutions into small
steps so that each step can be easily understood and verified.</p></li>
</ol>
<h3 id="differentiating-algebraic-data-types">2.6 Differentiating
Algebraic Data Types</h3>
<p>The title might seem strange—we will differentiate the translated
polynomials, not the types themselves. But what sense does this
make?</p>
<p>It turns out that taking the partial derivative of a polynomial
(translated from a data type), when translated back, gives a type
representing how to change one occurrence of a value corresponding to
the variable with respect to which we differentiated. In other words,
the derivative represents a “context” or “hole” in the data
structure.</p>
<h4 id="example-differentiating-the-date-type">Example: Differentiating
the Date Type</h4>
<div class="sourceCode" id="cb33"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = {year: <span class="dt">int</span>; month: <span class="dt">int</span>; day: <span class="dt">int</span>}</span></code></pre></div>
<p>The translation:</p>
<p><span class="math display">
\begin{aligned}
D &amp;= x \cdot x \cdot x = x^3 \\
\frac{\partial D}{\partial x} &amp;= 3x^2 = x \cdot x + x \cdot x + x
\cdot x
\end{aligned}
</span></p>
<p>We could have left it as <span class="math inline">3 \cdot x \cdot
x</span>, but expanding shows the structure more clearly. Translating
back to a type:</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date_deriv =</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>  Year <span class="kw">of</span> <span class="dt">int</span> * <span class="dt">int</span> | Month <span class="kw">of</span> <span class="dt">int</span> * <span class="dt">int</span> | Day <span class="kw">of</span> <span class="dt">int</span> * <span class="dt">int</span></span></code></pre></div>
<p>Each variant represents a “hole” at a different position:
<code>Year</code> means the year field is missing (and we have the month
and day), and so on.</p>
<p>Now we can define functions to introduce and eliminate this
derivative type:</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> date_deriv {year=y; month=m; day=d} =</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  [Year (m, d); Month (y, d); Day (y, m)]</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> date_integr n = <span class="kw">function</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>  | Year (m, d) -&gt; {year=n; month=m; day=d}</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>  | Month (y, d) -&gt; {year=y; month=n; day=d}</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>  | Day (y, m) -&gt; {year=y; month=m; day=n}</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>;;</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.map (date_integr <span class="dv">7</span>)</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>  (date_deriv {year=<span class="dv">2012</span>; month=<span class="dv">2</span>; day=<span class="dv">14</span>})</span></code></pre></div>
<p>The <code>date_deriv</code> function produces all contexts (one for
each field), and <code>date_integr</code> fills in a hole with a new
value.</p>
<h4 id="example-differentiating-binary-trees">Example: Differentiating
Binary Trees</h4>
<p>Let us tackle the more challenging case of binary trees:</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree = Tip | Node <span class="kw">of</span> <span class="dt">int</span> * btree * btree</span></code></pre></div>
<p>The translation and differentiation:</p>
<p><span class="math display">
\begin{aligned}
T &amp;= 1 + x \cdot T^2 \\
\frac{\partial T}{\partial x} &amp;= 0 + T^2 + 2 \cdot x \cdot T \cdot
\frac{\partial T}{\partial x} = T \cdot T + 2 \cdot x \cdot T \cdot
\frac{\partial T}{\partial x}
\end{aligned}
</span></p>
<p>The derivative is recursive! This makes sense: a context in a tree is
either at the current node (<span class="math inline">T \cdot T</span>,
the two subtrees) or somewhere below (<span class="math inline">2 \cdot
x \cdot T \cdot \frac{\partial T}{\partial x}</span>, choosing left or
right, with the node value, the other subtree, and a deeper
context).</p>
<p>Instead of translating <span class="math inline">2</span> as
<code>bool</code>, we introduce a more descriptive type:</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree_dir = LeftBranch | RightBranch</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree_deriv =</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>  | Here <span class="kw">of</span> btree * btree</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>  | Below <span class="kw">of</span> btree_dir * <span class="dt">int</span> * btree * btree_deriv</span></code></pre></div>
<p>(You might someday hear about <em>zippers</em>—they are “inverted”
relative to our type, with the hole coming first.)</p>
<p>The integration function fills the hole with a value:</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> btree_integr n = <span class="kw">function</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>  | Here (ltree, rtree) -&gt; Node (n, ltree, rtree)</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>  | Below (LeftBranch, m, rtree, deriv) -&gt;</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    Node (m, btree_integr n deriv, rtree)</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>  | Below (RightBranch, m, ltree, deriv) -&gt;</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>    Node (m, ltree, btree_integr n deriv)</span></code></pre></div>
<h3 id="exercises-1">2.7 Exercises</h3>
<h4 id="exercise-1">Exercise 1</h4>
<p><em>Due to Yaron Minsky.</em></p>
<p>Consider a datatype to store internet connection information. The
time <code>when_initiated</code> marks the start of connecting and is
not needed after the connection is established (it is only used to
decide whether to give up trying to connect). The ping information is
available for established connections but not straight away.</p>
<pre><code>type connectionstate = Connecting | Connected | Disconnected

type connectioninfo = {
  state : connectionstate;
  server : Inetaddr.t;
  lastpingtime : Time.t option;
  lastpingid : int option;
  sessionid : string option;
  wheninitiated : Time.t option;
  whendisconnected : Time.t option;
}</code></pre>
<p>(The types <code>Time.t</code> and <code>Inetaddr.t</code> come from
the <em>Core</em> library. You can replace them with <code>float</code>
and <code>Unix.inet_addr</code>. Load the Unix library in the
interactive toplevel with <code>#load "unix.cma";;</code>.)</p>
<p>Rewrite the type definitions so that the datatype will contain only
reasonable combinations of information.</p>
<h4 id="exercise-2">Exercise 2</h4>
<p>In OCaml, functions can have labeled arguments and optional arguments
(parameters with default values that can be omitted). Labels can differ
from the names of argument values:</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f ~meaningfulname:n = n + <span class="dv">1</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> _ = f ~meaningfulname:<span class="dv">5</span>  <span class="co">(* We do not need the result so we ignore it. *)</span></span></code></pre></div>
<p>When the label and value names are the same, the syntax is
shorter:</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> g ~pos ~len =</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">StringLabels</span>.sub <span class="st">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span> ~pos ~len</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () =  <span class="co">(* A nicer way to mark computations that return unit. *)</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> pos = <span class="dt">Random</span>.<span class="dt">int</span> <span class="dv">26</span> <span class="kw">in</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> len = <span class="dt">Random</span>.<span class="dt">int</span> <span class="dv">10</span> <span class="kw">in</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">print_string</span> (g ~pos ~len)</span></code></pre></div>
<p>When some function arguments are optional, the function must take
non-optional arguments after the last optional argument. Optional
parameters with default values:</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> h ?(len=<span class="dv">1</span>) pos = g ~pos ~len</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () = <span class="dt">print_string</span> (h <span class="dv">10</span>)</span></code></pre></div>
<p>Optional arguments are implemented as parameters of an option type.
This allows checking whether the argument was provided:</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo ?bar n =</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> bar <span class="kw">with</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">None</span> -&gt; <span class="st">&quot;Argument = &quot;</span> ^ <span class="dt">string_of_int</span> n</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> m -&gt; <span class="st">&quot;Sum = &quot;</span> ^ <span class="dt">string_of_int</span> (m + n)</span></code></pre></div>
<p>We can use it in various ways:</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> _ = foo <span class="dv">5</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> _ = foo ~bar:<span class="dv">5</span> <span class="dv">7</span></span></code></pre></div>
<p>We can also provide the option value directly:</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> test_foo () =</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> bar = <span class="kw">if</span> <span class="dt">Random</span>.<span class="dt">int</span> <span class="dv">10</span> &lt; <span class="dv">5</span> <span class="kw">then</span> <span class="dt">None</span> <span class="kw">else</span> <span class="dt">Some</span> <span class="dv">7</span> <span class="kw">in</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>  foo ?bar <span class="dv">7</span></span></code></pre></div>
<ol type="1">
<li><p>Observe the types that functions with labeled and optional
arguments have. Come up with coding style guidelines for when to use
labeled arguments.</p></li>
<li><p>Write a rectangle-drawing procedure that takes three optional
arguments: left-upper corner, right-lower corner, and a width-height
pair. It should draw a correct rectangle whenever two arguments are
given, and raise an exception otherwise. Load the graphics library with
<code>#load "graphics.cma";;</code>. Use <code>invalid_arg</code>,
<code>Graphics.open_graph</code>, and
<code>Graphics.draw_rect</code>.</p></li>
<li><p>Write a function that takes an optional argument of arbitrary
type and a function argument, and passes the optional argument to the
function without inspecting it.</p></li>
</ol>
<h4 id="exercise-3">Exercise 3</h4>
<p><em>From a past exam.</em></p>
<ol type="1">
<li>Give the (most general) types of the following expressions, either
by guessing or by inferring by hand:
<ol type="1">
<li><code>let double f y = f (f y) in fun g x -&gt; double (g x)</code></li>
<li><code>let rec tails l = match l with [] -&gt; [] | x::xs -&gt; xs::tails xs in fun l -&gt; List.combine l (tails l)</code></li>
</ol></li>
<li>Give example expressions that have the following types (without
using type constraints):
<ol type="1">
<li><code>(int -&gt; int) -&gt; bool</code></li>
<li><code>'a option -&gt; 'a list</code></li>
</ol></li>
</ol>
<h4 id="exercise-4">Exercise 4</h4>
<p>We have seen that algebraic data types can be related to analytic
functions (the subset definable from polynomials via recursion)—by
literally interpreting sum types (variant types) as sums and product
types (tuple and record types) as products. We can extend this
interpretation to function types by interpreting <span
class="math inline">a \rightarrow b</span> as <span
class="math inline">b^a</span> (i.e., <span class="math inline">b</span>
to the power of <span class="math inline">a</span>). Note that the <span
class="math inline">b^a</span> notation is actually used to denote
functions in set theory.</p>
<ol type="1">
<li><p>Translate <span class="math inline">a^{b + cd}</span> and <span
class="math inline">a^b \cdot (a^c)^d</span> into OCaml types, using any
distinct types for <span class="math inline">a, b, c, d</span>, and
using <code>type ('a,'b) choice = Left of 'a | Right of 'b</code> for
<span class="math inline">+</span>. Write the bijection function in both
directions.</p></li>
<li><p>Come up with a type <code>'t exp</code> that shares with the
exponential function the following property: <span
class="math inline">\frac{\partial \exp(t)}{\partial t} =
\exp(t)</span>, where we translate a derivative of a type as a context
(i.e., the type with a “hole”), as in this chapter. Explain why your
answer is correct. <em>Hint:</em> in computer science, our logarithms
are mostly base 2.</p></li>
</ol>
<p><em>Further reading:</em> <a
href="http://bababadalgharaghtakamminarronnkonnbro.blogspot.com/2012/10/algebraic-type-systems-combinatorial.html">Algebraic
Type Systems - Combinatorial Species</a></p>
<h4 id="exercise-5-homework">Exercise 5 (Homework)</h4>
<p>Write a function <code>btree_deriv_at</code> that takes a predicate
over integers (i.e., a function <code>f: int -&gt; bool</code>) and a
<code>btree</code>, and builds a <code>btree_deriv</code> whose “hole”
is in the first position for which the predicate returns true. It should
return a <code>btree_deriv option</code>, with <code>None</code> if the
predicate does not hold for any node.</p>
<h2 id="chapter-3-computation">Chapter 3: Computation</h2>
<p><em>Reduction semantics and operational reasoning</em></p>
<p><strong>References:</strong></p>
<ul>
<li>“Using, Understanding and Unraveling the OCaml Language” by Didier
Remy, Chapter 1</li>
<li>“The OCaml system” manual, the tutorial part, Chapter 1</li>
</ul>
<h3 id="function-composition">3.1 Function Composition</h3>
<p>The usual way function composition is defined in mathematics is
“backward”—the notation follows the convention of mathematical function
application:</p>
<p><span class="math display">
(f \circ g)(x) = f(g(x))
</span></p>
<p>This means that when we write <span class="math inline">f \circ
g</span>, we first apply <span class="math inline">g</span> and then
apply <span class="math inline">f</span> to the result. Here is how this
is expressed in different functional programming languages:</p>
<table>
<thead>
<tr>
<th>Language</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td>Math</td>
<td><span class="math inline">(f \circ g)(x) = f(g(x))</span></td>
</tr>
<tr>
<td>OCaml</td>
<td><code>let (-|) f g x = f (g x)</code></td>
</tr>
<tr>
<td>F#</td>
<td><code>let (&lt;&lt;) f g x = f (g x)</code></td>
</tr>
<tr>
<td>Haskell</td>
<td><code>(.) f g = \x -&gt; f (g x)</code></td>
</tr>
</tbody>
</table>
<p>This backward composition looks like function application but needs
fewer parentheses. Recall the functions <code>iso1</code> and
<code>iso2</code> from the previous chapter on type isomorphisms. Using
backward composition, we could write:</p>
<pre><code>let iso2 = step1l -| step2l -| step3l</code></pre>
<p>A more natural definition of function composition is “forward”
composition, which follows the order in which computation actually
proceeds:</p>
<table>
<thead>
<tr>
<th>Language</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td>OCaml</td>
<td><code>let (\|-) f g x = g (f x)</code></td>
</tr>
<tr>
<td>F#</td>
<td><code>let (&gt;&gt;) f g x = g (f x)</code></td>
</tr>
</tbody>
</table>
<p>With forward composition, data flows from left to right, matching how
we typically read code:</p>
<pre><code>let iso1 = step1r |- step2r |- step3r</code></pre>
<h4 id="partial-application">Partial Application</h4>
<p>Both composition examples above use <strong>partial
application</strong>. Recall from the previous chapter that
<code>((+) 1)</code> is a function that adds 1 to its argument. Partial
application occurs when we do not pass all the arguments a function
needs; the result is a function that requires the remaining
arguments.</p>
<p>In the composition <code>step1r |- step2r |- step3r</code>, each
<code>stepNr</code> function is partially applied. The composition
operator <code>(|-)</code> takes two functions <code>f</code> and
<code>g</code> and returns a new function that first applies
<code>f</code>, then applies <code>g</code> to the result.</p>
<h4 id="power-function">Power Function</h4>
<p>Now we define iterated function composition:</p>
<p><span class="math display">
f^n(x) := \underbrace{(f \circ \cdots \circ f)}_{n \text{ times}}(x)
</span></p>
<p>In OCaml, we first define the backward composition operator, then use
it in <code>power</code>:</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (-|) f g x = f (g x)</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> power f n =</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> (<span class="kw">fun</span> x -&gt; x) <span class="kw">else</span> f -| power f (n<span class="dv">-1</span>)</span></code></pre></div>
<p>When <code>n &lt;= 0</code>, we return the identity function.
Otherwise, we compose <code>f</code> with <code>power f (n-1)</code>,
which gives us one more application of <code>f</code>.</p>
<h4 id="numerical-derivative">Numerical Derivative</h4>
<p>Using <code>power</code>, we can define a numerical approximation of
the derivative:</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> derivative dx f = <span class="kw">fun</span> x -&gt; (f(x +. dx) -. f(x)) /. dx</span></code></pre></div>
<p>This definition emphasizes that <code>derivative dx f</code> is
itself a function of <code>x</code>. We can write it more concisely
as:</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> derivative dx f x = (f(x +. dx) -. f(x)) /. dx</span></code></pre></div>
<p>Note that OCaml uses different operators for floating-point
arithmetic. We have <code>(+): int -&gt; int -&gt; int</code> for
integers, so we cannot use <code>+</code> with floating-point numbers.
Instead, operators followed by a dot work on <code>float</code> values:
<code>+.</code>, <code>-.</code>, <code>*.</code>, <code>/.</code>.</p>
<h4 id="computing-higher-order-derivatives">Computing Higher-Order
Derivatives</h4>
<p>With <code>power</code> and <code>derivative</code>, we can easily
compute higher-order derivatives:</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pi = <span class="fl">4.0</span> *. <span class="dt">atan</span> <span class="fl">1.0</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> sin&#39;&#39;&#39; = (power (derivative <span class="fl">1e-5</span>) <span class="dv">3</span>) <span class="dt">sin</span>;;</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>sin&#39;&#39;&#39; pi</span></code></pre></div>
<p>Here <code>sin'''</code> is the third derivative of sine. The result
should be approximately <span class="math inline">-\cos(\pi) = 1</span>
(with some numerical error due to the finite difference
approximation).</p>
<h3 id="evaluation-rules-reduction-semantics">3.2 Evaluation Rules
(Reduction Semantics)</h3>
<p>To understand how OCaml programs compute their results, we need to
formalize the evaluation process. This section presents
<strong>reduction semantics</strong>, which describes computation as a
series of rewriting steps.</p>
<h4 id="expressions">Expressions</h4>
<p>Programs consist of <strong>expressions</strong>. Here is the grammar
of expressions for a simplified version of OCaml:</p>
<p><span class="math display">
\begin{array}{lcll}
a &amp; := &amp; x &amp; \text{variables} \\
  &amp; |  &amp; \texttt{fun } x \texttt{ -&gt; } a &amp;
\text{(defined) functions} \\
  &amp; |  &amp; a \; a &amp; \text{applications} \\
  &amp; |  &amp; C^0 &amp; \text{value constructors of arity } 0 \\
  &amp; |  &amp; C^n(a, \ldots, a) &amp; \text{value constructors of
arity } n \\
  &amp; |  &amp; f^n &amp; \text{built-in values (primitives) of arity }
n \\
  &amp; |  &amp; \texttt{let } x = a \texttt{ in } a &amp; \text{name
bindings (local definitions)} \\
  &amp; |  &amp; \texttt{match } a \texttt{ with} &amp; \\
  &amp;    &amp; \quad p \texttt{ -&gt; } a \texttt{ | } \cdots \texttt{
| } p \texttt{ -&gt; } a &amp; \text{pattern matching} \\[1em]
p &amp; := &amp; x &amp; \text{pattern variables} \\
  &amp; |  &amp; (p, \ldots, p) &amp; \text{tuple patterns} \\
  &amp; |  &amp; C^0 &amp; \text{variant patterns of arity } 0 \\
  &amp; |  &amp; C^n(p, \ldots, p) &amp; \text{variant patterns of arity
} n
\end{array}
</span></p>
<p><strong>Arity</strong> means how many arguments something requires
(and for tuples, the length of the tuple).</p>
<h4 id="the-fix-primitive">The <code>fix</code> Primitive</h4>
<p>To simplify our presentation of recursion, we use a primitive
<code>fix</code> to define a limited form of <code>let rec</code>:</p>
<p><span class="math display">
\texttt{let rec } f \; x = e_1 \texttt{ in } e_2 \equiv \texttt{let } f
= \texttt{fix (fun } f \; x \texttt{ -&gt; } e_1 \texttt{) in } e_2
</span></p>
<p>The <code>fix</code> primitive captures the essence of recursion: it
takes a function that expects to receive itself as an argument and
produces a fixed point—a function that, when called, behaves as if it
had access to itself.</p>
<h4 id="values">Values</h4>
<p>Expressions evaluate (i.e., compute) to <strong>values</strong>.
Values are expressions that cannot be reduced further:</p>
<p><span class="math display">
\begin{array}{lcll}
v &amp; := &amp; \texttt{fun } x \texttt{ -&gt; } a &amp;
\text{(defined) functions} \\
  &amp; |  &amp; C^n(v_1, \ldots, v_n) &amp; \text{constructed values}
\\
  &amp; |  &amp; f^n \; v_1 \; \cdots \; v_k &amp; k &lt; n \text{
(partially applied primitives)}
\end{array}
</span></p>
<p>Note that functions are values: <code>fun x -&gt; x + 1</code> is
already fully evaluated. Partially applied primitives like
<code>(+) 3</code> are also values—they are waiting for more
arguments.</p>
<h4 id="substitution">Substitution</h4>
<p>To <strong>substitute</strong> a value <span
class="math inline">v</span> for a variable <span
class="math inline">x</span> in expression <span
class="math inline">a</span>, we write <span class="math inline">a[x :=
v]</span>. This notation means that every occurrence of <span
class="math inline">x</span> in <span class="math inline">a</span> is
replaced by <span class="math inline">v</span>.</p>
<p>In the actual implementation, the value <span
class="math inline">v</span> is not duplicated in memory. Instead, OCaml
uses references or closures to share the value efficiently.</p>
<h4 id="reduction-rules-redexes">Reduction Rules (Redexes)</h4>
<p>Reduction (i.e., computation) proceeds by finding reducible
expressions called <strong>redexes</strong> and applying reduction
rules. Here are the fundamental redexes:</p>
<p><strong>Function application (beta reduction):</strong> <span
class="math display">
(\texttt{fun } x \texttt{ -&gt; } a) \; v \rightsquigarrow a[x := v]
</span></p>
<p>When we apply a function to a value, we substitute the value for the
parameter in the function body.</p>
<p><strong>Let binding:</strong> <span class="math display">
\texttt{let } x = v \texttt{ in } a \rightsquigarrow a[x := v]
</span></p>
<p>A let binding with a value substitutes that value into the body.</p>
<p><strong>Primitive application:</strong> <span class="math display">
f^n \; v_1 \; \cdots \; v_n \rightsquigarrow f(v_1, \ldots, v_n)
</span></p>
<p>When a primitive receives all its arguments, it computes the result.
Here <span class="math inline">f(v_1, \ldots, v_n)</span> denotes the
actual result of the primitive operation.</p>
<p><strong>Pattern matching with a variable pattern:</strong> <span
class="math display">
\texttt{match } v \texttt{ with } x \texttt{ -&gt; } a \texttt{ | }
\cdots \rightsquigarrow a[x := v]
</span></p>
<p><strong>Pattern matching with a non-matching constructor:</strong>
<span class="math display">
\frac{C_1 \neq C_2}{\texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{
with } C_2^k(p_1, \ldots, p_k) \texttt{ -&gt; } a \texttt{ | } pm
\rightsquigarrow \texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{ with }
pm}
</span></p>
<p>If the constructor does not match, we try the next pattern.</p>
<p><strong>Pattern matching with a matching constructor:</strong> <span
class="math display">
\texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{ with } C_1^n(x_1,
\ldots, x_n) \texttt{ -&gt; } a \texttt{ | } \cdots \rightsquigarrow
a[x_1 := v_1; \ldots; x_n := v_n]
</span></p>
<p>If the constructor matches, we substitute all the bound values.</p>
<p>If <span class="math inline">n = 0</span>, then <span
class="math inline">C_1^n(v_1, \ldots, v_n)</span> stands for simply
<span class="math inline">C_1^0</span>, a constructor with no arguments.
We omit the more complex cases of nested pattern matching.</p>
<h4 id="rule-variables">Rule Variables</h4>
<p>In these rules, the metavariables have specific meanings: - <span
class="math inline">x</span> matches any expression or pattern variable
- <span class="math inline">a, a_1, \ldots, a_n</span> match any
expression - <span class="math inline">v, v_1, \ldots, v_n</span> match
any value</p>
<p>To apply a rule, find substitutions for these metavariables that make
the left-hand side match your expression. The right-hand side (with the
same substitutions) is the reduced expression.</p>
<h4 id="evaluation-context-rules">Evaluation Context Rules</h4>
<p>The rules above only apply when the arguments are already values. We
also need rules that allow evaluation of subexpressions. If <span
class="math inline">a_i \rightsquigarrow a_i&#39;</span>, then:</p>
<p><span class="math display">
\begin{array}{lcl}
a_1 \; a_2 &amp; \rightsquigarrow &amp; a_1&#39; \; a_2 \\
a_1 \; a_2 &amp; \rightsquigarrow &amp; a_1 \; a_2&#39; \\
C^n(a_1, \ldots, a_i, \ldots, a_n) &amp; \rightsquigarrow &amp; C^n(a_1,
\ldots, a_i&#39;, \ldots, a_n) \\
\texttt{let } x = a_1 \texttt{ in } a_2 &amp; \rightsquigarrow &amp;
\texttt{let } x = a_1&#39; \texttt{ in } a_2 \\
\texttt{match } a_1 \texttt{ with } pm &amp; \rightsquigarrow &amp;
\texttt{match } a_1&#39; \texttt{ with } pm
\end{array}
</span></p>
<p>These rules say that: - In an application, either the function or the
argument can be evaluated (in arbitrary order) - In a constructor, any
argument can be evaluated - In a let binding, the bound expression is
evaluated before the body - In a match, the scrutinee is evaluated
before matching</p>
<h4 id="the-fix-rule">The <code>fix</code> Rule</h4>
<p>Finally, the rule for the <code>fix</code> primitive, which enables
recursion:</p>
<p><span class="math display">
\texttt{fix}^2 \; v_1 \; v_2 \rightsquigarrow v_1 \; (\texttt{fix}^2 \;
v_1) \; v_2
</span></p>
<p>Because <code>fix</code> is a binary primitive (arity 2), the
expression <span class="math inline">(\texttt{fix}^2 \; v_1)</span> is
already a value (a partially applied primitive). This means it will not
be further evaluated until it is applied inside <span
class="math inline">v_1</span>. This delayed evaluation is what makes
recursion work without infinite loops.</p>
<h4 id="practice">Practice</h4>
<p><strong>Exercise:</strong> Compute some simple programs by hand using
these rules. For example, trace the evaluation of:</p>
<div class="sourceCode" id="cb52"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> double x = x + x <span class="kw">in</span> double <span class="dv">3</span></span></code></pre></div>
<h3 id="symbolic-derivation-example">3.3 Symbolic Derivation
Example</h3>
<p>Let us see the reduction rules in action with a more complex example.
Consider the symbolic expression evaluator from
<code>Lec3.ml</code>:</p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> expression =</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>  | Const <span class="kw">of</span> <span class="dt">float</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>  | Var <span class="kw">of</span> <span class="dt">string</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>  | Sum <span class="kw">of</span> expression * expression    <span class="co">(* e1 + e2 *)</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>  | Diff <span class="kw">of</span> expression * expression   <span class="co">(* e1 - e2 *)</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>  | Prod <span class="kw">of</span> expression * expression   <span class="co">(* e1 * e2 *)</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>  | Quot <span class="kw">of</span> expression * expression   <span class="co">(* e1 / e2 *)</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a><span class="kw">exception</span> Unbound_variable <span class="kw">of</span> <span class="dt">string</span></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> eval env <span class="dt">exp</span> =</span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> <span class="dt">exp</span> <span class="kw">with</span></span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>  | Const c -&gt; c</span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>  | Var v -&gt;</span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">try</span> <span class="dt">List</span>.assoc v env <span class="kw">with</span> <span class="dt">Not_found</span> -&gt; <span class="dt">raise</span> (Unbound_variable v))</span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a>  | Sum(f, g) -&gt; eval env f +. eval env g</span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a>  | Diff(f, g) -&gt; eval env f -. eval env g</span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true" tabindex="-1"></a>  | Prod(f, g) -&gt; eval env f *. eval env g</span>
<span id="cb53-19"><a href="#cb53-19" aria-hidden="true" tabindex="-1"></a>  | Quot(f, g) -&gt; eval env f /. eval env g</span></code></pre></div>
<p>We can also define symbolic differentiation:</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> deriv <span class="dt">exp</span> dv =</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> <span class="dt">exp</span> <span class="kw">with</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>  | Const c -&gt; Const <span class="fl">0.0</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>  | Var v -&gt; <span class="kw">if</span> v = dv <span class="kw">then</span> Const <span class="fl">1.0</span> <span class="kw">else</span> Const <span class="fl">0.0</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>  | Sum(f, g) -&gt; Sum(deriv f dv, deriv g dv)</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>  | Diff(f, g) -&gt; Diff(deriv f dv, deriv g dv)</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>  | Prod(f, g) -&gt; Sum(Prod(f, deriv g dv), Prod(deriv f dv, g))</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>  | Quot(f, g) -&gt; Quot(Diff(Prod(deriv f dv, g), Prod(f, deriv g dv)),</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>                       Prod(g, g))</span></code></pre></div>
<p>For convenience, let us define some operators and variables:</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = Var <span class="st">&quot;x&quot;</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> y = Var <span class="st">&quot;y&quot;</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (+:) f g = Sum (f, g)</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (-:) f g = Diff (f, g)</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ( *: ) f g = Prod (f, g)</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (/:) f g = Quot (f, g)</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (!:) i = Const i</span></code></pre></div>
<p>Now consider evaluating the expression <code>3x + 2y + x^2 y</code>
at <span class="math inline">x = 1, y = 2</span>:</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> example = !:<span class="fl">3.0</span> *: x +: !:<span class="fl">2.0</span> *: y +: x *: x *: y</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> env = [<span class="st">&quot;x&quot;</span>, <span class="fl">1.0</span>; <span class="st">&quot;y&quot;</span>, <span class="fl">2.0</span>]</span></code></pre></div>
<p>When we trace the evaluation, we can see the recursive structure of
the computation:</p>
<pre><code>eval_1_2 &lt;-- 3.00 * x + 2.00 * y + x * x * y
  eval_1_2 &lt;-- x * x * y
    eval_1_2 &lt;-- y
    eval_1_2 --&gt; 2.
    eval_1_2 &lt;-- x * x
      eval_1_2 &lt;-- x
      eval_1_2 --&gt; 1.
      eval_1_2 &lt;-- x
      eval_1_2 --&gt; 1.
    eval_1_2 --&gt; 1.
  eval_1_2 --&gt; 2.
  eval_1_2 &lt;-- 3.00 * x + 2.00 * y
    eval_1_2 &lt;-- 2.00 * y
      eval_1_2 &lt;-- y
      eval_1_2 --&gt; 2.
      eval_1_2 &lt;-- 2.00
      eval_1_2 --&gt; 2.
    eval_1_2 --&gt; 4.
    eval_1_2 &lt;-- 3.00 * x
      eval_1_2 &lt;-- x
      eval_1_2 --&gt; 1.
      eval_1_2 &lt;-- 3.00
      eval_1_2 --&gt; 3.
    eval_1_2 --&gt; 3.
  eval_1_2 --&gt; 7.
eval_1_2 --&gt; 9.
- : float = 9.</code></pre>
<p>The indentation levels in this trace correspond to <strong>stack
frames</strong>—the runtime structures that store the state of each
function call. This brings us to an important optimization
technique.</p>
<h3 id="tail-calls-and-tail-recursion">3.4 Tail Calls and Tail
Recursion</h3>
<p>Computers normally evaluate programs by creating <strong>stack
frames</strong> on the call stack for each function call. The trace
above illustrates this: each level of indentation represents a new stack
frame.</p>
<h4 id="what-is-a-tail-call">What is a Tail Call?</h4>
<p>A <strong>tail call</strong> is a function call that is performed
last when computing a function—there is nothing more to do after the
call returns. For example, in:</p>
<pre><code>let f x = g (x + 1)</code></pre>
<p>The call to <code>g</code> is a tail call because after
<code>g</code> returns, <code>f</code> immediately returns that
value.</p>
<p>In contrast, in:</p>
<pre><code>let f x = 1 + g x</code></pre>
<p>The call to <code>g</code> is <em>not</em> a tail call because after
<code>g</code> returns, we still need to add 1 to the result.</p>
<h4 id="tail-call-optimization">Tail Call Optimization</h4>
<p>Functional language compilers (including OCaml’s) recognize tail
calls and optimize them. Instead of creating a new stack frame, they
reuse the current frame by performing a “jump” to the called function.
This means tail calls use constant stack space.</p>
<h4 id="tail-recursive-functions">Tail Recursive Functions</h4>
<p>A function is <strong>tail recursive</strong> if it calls itself (and
any mutually recursive functions it depends on) only using tail
calls.</p>
<p>Tail recursive functions often use special
<strong>accumulator</strong> arguments that store intermediate
computation results. In a non-tail-recursive function, these
intermediate results would be values of subexpressions stored on the
stack.</p>
<p>The key insight is that the accumulated result is computed in
“reverse order”—while climbing up the recursion (making calls) rather
than while descending (returning from calls).</p>
<h4 id="example-counting">Example: Counting</h4>
<p>Compare these two counting functions:</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> count n =</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> <span class="dv">1</span> + (count (n<span class="dv">-1</span>))</span></code></pre></div>
<p>This is <em>not</em> tail recursive because after the recursive call
returns, we still need to add 1.</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> count_tcall acc n =</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> acc <span class="kw">else</span> count_tcall (acc+<span class="dv">1</span>) (n<span class="dv">-1</span>)</span></code></pre></div>
<p>This <em>is</em> tail recursive: the recursive call is the last thing
the function does.</p>
<h4 id="example-building-lists">Example: Building Lists</h4>
<p>Let us see a more dramatic example:</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> unfold n = <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> [] <span class="kw">else</span> n :: unfold (n<span class="dv">-1</span>)</span></code></pre></div>
<p>This function builds a list counting down from <code>n</code>. It is
not tail recursive because after the recursive call, we must cons
<code>n</code> onto the result.</p>
<pre><code># unfold 100000;;
- : int list = [100000; 99999; 99998; 99997; ...]

# unfold 1000000;;
Stack overflow during evaluation (looping recursion?).</code></pre>
<p>With a million elements, we run out of stack space! Now consider the
tail-recursive version:</p>
<div class="sourceCode" id="cb64"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> unfold_tcall acc n =</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> acc <span class="kw">else</span> unfold_tcall (n::acc) (n<span class="dv">-1</span>)</span></code></pre></div>
<p>The accumulator <code>acc</code> collects the list as we go. Note
that the list is built in reverse order:</p>
<pre><code># unfold_tcall [] 100000;;
- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; ...]

# unfold_tcall [] 1000000;;
- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; ...]</code></pre>
<p>The tail-recursive version handles a million elements with no
problem.</p>
<h4 id="a-challenge-tree-depth">A Challenge: Tree Depth</h4>
<p>Is it possible to find the depth of a tree using a tail-recursive
function?</p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree = Tip | Node <span class="kw">of</span> <span class="dt">int</span> * btree * btree</span></code></pre></div>
<p>The naive approach:</p>
<div class="sourceCode" id="cb67"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> depth tree = <span class="kw">match</span> tree <span class="kw">with</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>  | Tip -&gt; <span class="dv">0</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>  | Node(_, left, right) -&gt; <span class="dv">1</span> + <span class="dt">max</span> (depth left) (depth right)</span></code></pre></div>
<p>This is not tail recursive: after both recursive calls, we still need
to compute <code>1 + max ...</code>. The challenge is that we have
<em>two</em> recursive calls, and we cannot simply use an
accumulator.</p>
<h4 id="note-on-lazy-languages">Note on Lazy Languages</h4>
<p>The issue of tail recursion is more complex for <strong>lazy</strong>
programming languages like Haskell. In a lazy language, the cons
operation <code>(:)</code> does not immediately evaluate its arguments,
so building a list with <code>n :: unfold (n-1)</code> does not consume
stack space in the same way.</p>
<h3 id="first-encounter-of-continuation-passing-style">3.5 First
Encounter of Continuation Passing Style</h3>
<p>We can solve the tree depth problem using <strong>Continuation
Passing Style (CPS)</strong>. The key idea is to postpone doing actual
work until the very last moment by passing around a “continuation”—a
function that represents “what to do next.”</p>
<div class="sourceCode" id="cb68"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> depth_cps tree k = <span class="kw">match</span> tree <span class="kw">with</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>  | Tip -&gt; k <span class="dv">0</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>  | Node(_, left, right) -&gt;</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>    depth_cps left (<span class="kw">fun</span> dleft -&gt;</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>      depth_cps right (<span class="kw">fun</span> dright -&gt;</span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>        k (<span class="dv">1</span> + (<span class="dt">max</span> dleft dright))))</span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> depth tree = depth_cps tree (<span class="kw">fun</span> d -&gt; d)</span></code></pre></div>
<p>Let us understand how this works:</p>
<ol type="1">
<li><p>The function takes an extra parameter <code>k</code>, called the
<strong>continuation</strong>. It represents what to do with the final
result.</p></li>
<li><p>In the <code>Tip</code> case, we call the continuation with the
depth 0.</p></li>
<li><p>In the <code>Node</code> case, we recursively compute the depth
of the left subtree, passing a continuation that:</p>
<ul>
<li>Receives the left depth <code>dleft</code></li>
<li>Then recursively computes the depth of the right subtree, passing a
continuation that:
<ul>
<li>Receives the right depth <code>dright</code></li>
<li>Finally calls the original continuation with
<code>1 + max dleft dright</code></li>
</ul></li>
</ul></li>
<li><p>The wrapper function passes the identity function
<code>fun d -&gt; d</code> as the initial continuation.</p></li>
</ol>
<p>The magic is that each recursive call is now a tail call! The “work”
of computing <code>1 + max dleft dright</code> is captured in the
continuation closures, which are allocated on the heap rather than the
stack.</p>
<p>However, this does not completely solve the stack overflow problem—we
are trading stack space for heap space (storing the continuation
closures). For very deep trees, we might still run out of memory. True
solutions involve trampolining or iterative approaches with explicit
stacks.</p>
<p>CPS is a powerful technique that appears throughout functional
programming. We will encounter it again when studying monads and
advanced control flow.</p>
<h3 id="exercises-2">3.6 Exercises</h3>
<p><strong>Exercise 1:</strong> By “traverse a tree” below we mean:
write a function that takes a tree and returns a list of values in the
nodes of the tree.</p>
<ol type="1">
<li><p>Write a function (of type <code>btree -&gt; int list</code>) that
traverses a binary tree in <strong>prefix order</strong>—first the value
stored in a node, then values in all nodes to the left, then values in
all nodes to the right.</p></li>
<li><p>Write a traversal in <strong>infix order</strong>—first values in
all nodes to the left, then the value stored in the node, then values in
all nodes to the right (so it is “left-to-right” order).</p></li>
<li><p>Write a traversal in <strong>breadth-first order</strong>—first
values in shallower nodes before deeper nodes.</p></li>
</ol>
<p><strong>Exercise 2:</strong> Turn the function from Exercise 1
(prefix or infix traversal) into continuation passing style.</p>
<p><strong>Exercise 3:</strong> Do the homework from the end of Chapter
2: write <code>btree_deriv_at</code> that takes a predicate over
integers and a <code>btree</code>, and builds a <code>btree_deriv</code>
whose “hole” is in the first position for which the predicate returns
true.</p>
<p><strong>Exercise 4:</strong> Write a function
<code>simplify: expression -&gt; expression</code> that simplifies
symbolic expressions, so that for example the result of
<code>simplify (deriv exp dv)</code> looks more like what a human would
get computing the derivative of <code>exp</code> with respect to
<code>dv</code>.</p>
<ul>
<li>Write a <code>simplify_once</code> function that performs a single
step of simplification.</li>
<li>Wrap it using a general <code>fixpoint</code> function that performs
an operation until a <strong>fixed point</strong> is reached: given
<span class="math inline">f</span> and <span
class="math inline">x</span>, it computes <span
class="math inline">f^n(x)</span> such that <span
class="math inline">f^n(x) = f^{n+1}(x)</span>.</li>
</ul>
<p><strong>Exercise 5:</strong> Write two sorting algorithms working on
lists: merge sort and quicksort.</p>
<ol type="1">
<li><p><strong>Merge sort</strong> splits the list roughly in half,
sorts the parts recursively, and merges the sorted parts into the sorted
result.</p></li>
<li><p><strong>Quicksort</strong> splits the list into elements smaller
than and greater than (or equal to) the first element, sorts the parts
recursively, and concatenates them.</p></li>
</ol>
<h2 id="chapter-4-functions">Chapter 4: Functions</h2>
<p><em>Programming in untyped lambda-calculus</em></p>
<p>This chapter explores the theoretical foundations of functional
programming through the untyped lambda-calculus. We begin with a review
of computation by hand using our reduction semantics, then introduce the
lambda-calculus notation and show how to encode fundamental data
types—booleans, pairs, and natural numbers—using only functions. The
chapter concludes with an examination of recursion through fixpoint
combinators and practical considerations for avoiding infinite loops in
eager evaluation.</p>
<p><strong>References:</strong> - “Introduction to Lambda Calculus” by
Henk Barendregt and Erik Barendsen - “Lecture Notes on the Lambda
Calculus” by Peter Selinger</p>
<h3 id="review-computation-by-hand">4.1 Review: Computation by Hand</h3>
<p>Before diving into the lambda-calculus, let us work through a
complete example of evaluation using the reduction rules from Chapter 3.
This exercise reinforces our understanding of how computation proceeds
and prepares us for the more abstract setting of lambda-calculus.</p>
<p>Recall that we use <code>fix</code> instead of <code>let rec</code>
to simplify rules for recursion. Also remember our syntactic
conventions: <code>fun x y -&gt; e</code> stands for
<code>fun x -&gt; (fun y -&gt; e)</code>, and so forth.</p>
<p>Consider the following recursive <code>length</code> function applied
to a two-element list:</p>
<pre><code>let rec fix f x = f (fix f) x

type int_list = Nil | Cons of int * int_list

let length =
  fix (fun f l -&gt;
    match l with
      | Nil -&gt; 0
      | Cons (x, xs) -&gt; 1 + f xs) in
length (Cons (1, (Cons (2, Nil))))</code></pre>
<p>Let us trace through this computation step by step. First, we
eliminate the <code>let</code> binding:</p>
<p><span class="math display">\texttt{let } x = v \texttt{ in } a
\Downarrow a[x := v]</span></p>
<p>This gives us:</p>
<pre><code>fix (fun f l -&gt;
    match l with
      | Nil -&gt; 0
      | Cons (x, xs) -&gt; 1 + f xs) (Cons (1, (Cons (2, Nil))))</code></pre>
<p>Next, we apply the <code>fix</code> rule:</p>
<p><span class="math display">\texttt{fix}^2 \; v_1 \; v_2 \Downarrow
v_1 \; (\texttt{fix}^2 \; v_1) \; v_2</span></p>
<p>This unfolds to:</p>
<pre><code>(fun f l -&gt;
    match l with
      | Nil -&gt; 0
      | Cons (x, xs) -&gt; 1 + f xs)
    (fix (fun f l -&gt;
      match l with
        | Nil -&gt; 0
        | Cons (x, xs) -&gt; 1 + f xs))
    (Cons (1, (Cons (2, Nil))))</code></pre>
<p>Function application reduces according to:</p>
<p><span class="math display">(\texttt{fun } x \texttt{ -&gt; } a) \; v
\rightsquigarrow a[x := v]</span></p>
<p>After substituting both <code>f</code> and <code>l</code>, we
get:</p>
<pre><code>(match Cons (1, (Cons (2, Nil))) with
    | Nil -&gt; 0
    | Cons (x, xs) -&gt; 1 + (fix (fun f l -&gt;
      match l with
        | Nil -&gt; 0
        | Cons (x, xs) -&gt; 1 + f xs)) xs)</code></pre>
<p>Pattern matching against a non-matching constructor moves to the next
branch:</p>
<p><span class="math display">
\begin{aligned}
&amp; \texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{ with} \\
&amp; C_2^n(p_1, \ldots, p_k) \texttt{ -&gt; } a \texttt{ | } pm
\Downarrow \texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{ with } pm
\end{aligned}
</span></p>
<p>Pattern matching against a matching constructor performs
substitution:</p>
<p><span class="math display">
\begin{aligned}
&amp; \texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{ with} \\
&amp; C_1^n(x_1, \ldots, x_n) \texttt{ -&gt; } a \texttt{ | } \ldots
\Downarrow a[x_1 := v_1; \ldots; x_n := v_n]
\end{aligned}
</span></p>
<p>After matching and substitution:</p>
<pre><code>1 + (fix (fun f l -&gt;
      match l with
        | Nil -&gt; 0
        | Cons (x, xs) -&gt; 1 + f xs)) (Cons (2, Nil))</code></pre>
<p>Continuing the evaluation, we apply <code>fix</code> again and work
through the pattern match for <code>Cons (2, Nil)</code>, eventually
reaching:</p>
<pre><code>1 + (1 + (fix (fun f l -&gt;
             match l with
               | Nil -&gt; 0
               | Cons (x, xs) -&gt; 1 + f xs)) Nil)</code></pre>
<p>One more unfolding and pattern match against <code>Nil</code>
gives:</p>
<pre><code>1 + (1 + 0)</code></pre>
<p>Finally, applying the built-in addition:</p>
<p><span class="math display">f^n \; v_1 \; \ldots \; v_n \Downarrow
f(v_1, \ldots, v_n)</span></p>
<p>We obtain the result: <code>2</code>.</p>
<h3 id="language-and-rules-of-the-untyped-lambda-calculus">4.2 Language
and Rules of the Untyped Lambda-Calculus</h3>
<p>The lambda-calculus, introduced by Alonzo Church in the 1930s, is a
minimal formal system for expressing computation. To work with it, we
first simplify our language:</p>
<ol type="1">
<li><p><strong>Forget about types.</strong> In pure lambda-calculus,
there is no type system constraining which terms can be
combined.</p></li>
<li><p><strong>Introduce notation.</strong> We write <span
class="math inline">\lambda x.a</span> for <code>fun x -&gt; a</code>,
and <span class="math inline">\lambda xy.a</span> for
<code>fun x y -&gt; a</code>, and so forth.</p></li>
<li><p><strong>Reduce to essentials.</strong> We keep only functions
(lambda abstractions) and variables—no constructors, no built-in
primitives.</p></li>
</ol>
<p>The core reduction rule of lambda-calculus is called <strong><span
class="math inline">\beta</span>-reduction</strong>:</p>
<p><span class="math display">(\texttt{fun } x \texttt{ -&gt; } a_1) \;
a_2 \rightsquigarrow a_1[x := a_2]</span></p>
<p>Note that this rule is more general than the one we use for OCaml
evaluation. In our OCaml semantics, we require the argument to be a
value: <span class="math inline">(\texttt{fun } x \texttt{ -&gt; } a) \;
v \rightsquigarrow a[x := v]</span>. The general <span
class="math inline">\beta</span>-reduction rule allows substituting any
expression, not just values.</p>
<p>Lambda-calculus also uses <strong><span
class="math inline">\alpha</span>-conversion</strong> (bound variable
renaming), or equivalent techniques, to avoid <strong>variable
capture</strong>—the unintended binding of free variables during
substitution. We will explore <span
class="math inline">\beta</span>-reduction further in the chapter on
laziness.</p>
<p>Why is <span class="math inline">\beta</span>-reduction more general
than our evaluation rule? Consider the expression <span
class="math inline">(\lambda x. x) \; ((\lambda y. y) \; z)</span>. With
<span class="math inline">\beta</span>-reduction, we could reduce the
outer application first, obtaining <span class="math inline">((\lambda
y. y) \; z)</span>. Our evaluation rule would require first reducing the
argument to a value.</p>
<h3 id="booleans">4.3 Booleans</h3>
<p>Alonzo Church introduced lambda-calculus to encode logic. There are
multiple ways to encode various sorts of data in lambda-calculus, though
not all of them work well in a typed setting—the straightforward
encode/decode functions may not type-check.</p>
<p>The <strong>Church encoding</strong> of booleans represents truth
values as selector functions:</p>
<ul>
<li><strong>True</strong> selects the first argument:
<code>c_true</code> <span class="math inline">= \lambda xy.x</span></li>
<li><strong>False</strong> selects the second argument:
<code>c_false</code> <span class="math inline">= \lambda
xy.y</span></li>
</ul>
<p>In OCaml syntax:</p>
<div class="sourceCode" id="cb76"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c_true = <span class="kw">fun</span> x y -&gt; x   <span class="co">(* &quot;True&quot; is projection on the first argument *)</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c_false = <span class="kw">fun</span> x y -&gt; y  <span class="co">(* And &quot;false&quot; on the second argument *)</span></span></code></pre></div>
<p>Logical conjunction can be defined as:</p>
<p><span class="math display">\texttt{c\_and} = \lambda xy. x \; y \;
\texttt{c\_false}</span></p>
<p>The logic is: if <code>x</code> is true, return <code>y</code> (so
the result is true only if both are true); if <code>x</code> is false,
return false immediately.</p>
<div class="sourceCode" id="cb77"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c_and = <span class="kw">fun</span> x y -&gt; x y c_false  <span class="co">(* If one is false, then return false *)</span></span></code></pre></div>
<p>Let us verify this works. For <code>c_and c_true c_true</code>:</p>
<p><span class="math display">(\lambda xy. x \; y \; \texttt{c\_false})
\; (\lambda xy.x) \; (\lambda xy.x)</span></p>
<p>reduces to:</p>
<p><span class="math display">(\lambda xy.x) \; (\lambda xy.x) \;
\texttt{c\_false}</span></p>
<p>which gives us <span class="math inline">\lambda xy.x</span> =
<code>c_true</code>. For any other combination involving
<code>c_false</code>, the result is <code>c_false</code>.</p>
<p>To verify our encodings in OCaml, we need encode and decode
functions:</p>
<div class="sourceCode" id="cb78"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> encode_bool b = <span class="kw">if</span> b <span class="kw">then</span> c_true <span class="kw">else</span> c_false</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> decode_bool c = c <span class="kw">true</span> <span class="kw">false</span>  <span class="co">(* Test the functions in the toplevel *)</span></span></code></pre></div>
<p><strong>Exercise:</strong> Define <code>c_or</code> and
<code>c_not</code> yourself!</p>
<h3 id="if-then-else-and-pairs">4.4 If-then-else and Pairs</h3>
<p>From now on, we will use OCaml syntax for our lambda-calculus
programs. An important observation is that our encoded booleans already
implement conditional selection:</p>
<div class="sourceCode" id="cb79"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> if_then_else = <span class="kw">fun</span> b -&gt; b  <span class="co">(* Booleans select the argument! *)</span></span></code></pre></div>
<p>Since <code>c_true</code> returns its first argument and
<code>c_false</code> returns its second,
<code>if_then_else b then_branch else_branch</code> simply applies
<code>b</code> to the two branches. Remember to play with these
functions in the toplevel to build intuition.</p>
<h4 id="pairs">Pairs</h4>
<p>Pairs (ordered tuples of two elements) can be encoded similarly:</p>
<div class="sourceCode" id="cb80"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c_pair m n = <span class="kw">fun</span> x -&gt; x m n  <span class="co">(* We couple things *)</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c_first = <span class="kw">fun</span> p -&gt; p c_true  <span class="co">(* by passing them together *)</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c_second = <span class="kw">fun</span> p -&gt; p c_false  <span class="co">(* Check that it works! *)</span></span></code></pre></div>
<p>A pair is a function that, when given a selector, applies that
selector to both components. To extract the first component, we pass
<code>c_true</code> (which selects the first argument); to extract the
second, we pass <code>c_false</code>.</p>
<p>For verification:</p>
<div class="sourceCode" id="cb81"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> encode_pair enc_fst enc_snd (a, b) =</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>  c_pair (enc_fst a) (enc_snd b)</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> decode_pair de_fst de_snd c = c (<span class="kw">fun</span> x y -&gt; de_fst x, de_snd y)</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> decode_bool_pair c = decode_pair decode_bool decode_bool c</span></code></pre></div>
<p>We can define larger tuples in the same manner:</p>
<div class="sourceCode" id="cb82"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c_triple l m n = <span class="kw">fun</span> x -&gt; x l m n</span></code></pre></div>
<h3 id="pair-encoded-natural-numbers">4.5 Pair-Encoded Natural
Numbers</h3>
<p>Our first encoding of natural numbers uses nested pairs. The
representation is based on the depth of nested pairs whose rightmost
leaf is the identity function <span class="math inline">\lambda
x.x</span> and whose left elements are <code>c_false</code>.</p>
<div class="sourceCode" id="cb83"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pn0 = <span class="kw">fun</span> x -&gt; x           <span class="co">(* Start with the identity function *)</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pn_succ n = c_pair c_false n  <span class="co">(* Stack another pair *)</span></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pn_pred = <span class="kw">fun</span> x -&gt; x c_false  <span class="co">(* Extract the nested number *)</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pn_is_zero = <span class="kw">fun</span> x -&gt; x c_true  <span class="co">(* Check if it&#39;s the base case *)</span></span></code></pre></div>
<p>The number 0 is represented as the identity function. The number 1 is
<code>c_pair c_false pn0</code>, the number 2 is
<code>c_pair c_false (c_pair c_false pn0)</code>, and so on. The
<code>pn_is_zero</code> function works because: - For <code>pn0</code>,
applying it to <code>c_true</code> gives <code>c_true</code> (since
<code>pn0</code> is the identity). - For any successor, applying
<code>c_pair c_false n</code> to <code>c_true</code> applies the pair to
<code>c_true</code>, which selects <code>c_false</code>.</p>
<p>We program in untyped lambda-calculus as an exercise, and we need
encoding/decoding to verify our exercises. Using <code>Obj.magic</code>
to bypass the type system for encoding/decoding is “fair game”:</p>
<div class="sourceCode" id="cb84"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> encode_pnat n =                <span class="co">(* We use Obj.magic to forget types *)</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> <span class="dt">Obj</span>.magic pn0</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> pn_succ (<span class="dt">Obj</span>.magic (encode_pnat (n<span class="dv">-1</span>)))  <span class="co">(* Disregarding types, *)</span></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> decode_pnat pn =               <span class="co">(* these functions are straightforward! *)</span></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> decode_bool (pn_is_zero pn) <span class="kw">then</span> <span class="dv">0</span></span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> <span class="dv">1</span> + decode_pnat (pn_pred (<span class="dt">Obj</span>.magic pn))</span></code></pre></div>
<h3 id="church-numerals">4.6 Church Numerals</h3>
<p>Do you remember our function <code>power f n</code> from Chapter 3?
We will use a similar idea for a different representation of numbers.
<strong>Church numerals</strong> represent a natural number <span
class="math inline">n</span> as a function that applies its first
argument <span class="math inline">n</span> times to its second
argument:</p>
<div class="sourceCode" id="cb85"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn0 = <span class="kw">fun</span> f x -&gt; x        <span class="co">(* The same as c_false *)</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn1 = <span class="kw">fun</span> f x -&gt; f x      <span class="co">(* Behaves like identity when f = id *)</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn2 = <span class="kw">fun</span> f x -&gt; f (f x)</span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn3 = <span class="kw">fun</span> f x -&gt; f (f (f x))</span></code></pre></div>
<p>This is the original Alonzo Church encoding. The number <span
class="math inline">n</span> is represented as <span
class="math inline">\lambda fx. f^n(x)</span>, where <span
class="math inline">f^n</span> denotes <span
class="math inline">n</span>-fold composition.</p>
<p>The successor function adds one more application of
<code>f</code>:</p>
<div class="sourceCode" id="cb86"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn_succ = <span class="kw">fun</span> n f x -&gt; f (n f x)</span></code></pre></div>
<p><strong>Exercise:</strong> Define addition, multiplication, comparing
to zero, and the predecessor function “-1” for Church numerals.</p>
<p>It turns out even Alonzo Church could not define predecessor right
away! His student Stephen Kleene eventually found it. Try to make some
progress before looking at the solution below.</p>
<div class="sourceCode" id="cb87"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (-|) f g x = f (g x)  <span class="co">(* Backward composition operator *)</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> encode_cnat n f =</span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> (<span class="kw">fun</span> x -&gt; x) <span class="kw">else</span> f -| encode_cnat (n<span class="dv">-1</span>) f</span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> decode_cnat n = n ((+) <span class="dv">1</span>) <span class="dv">0</span></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn7 f x = encode_cnat <span class="dv">7</span> f x   <span class="co">(* We need to eta-expand these definitions *)</span></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn13 f x = encode_cnat <span class="dv">13</span> f x  <span class="co">(* for type-system reasons *)</span></span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a>                                   <span class="co">(* (because OCaml allows side-effects) *)</span></span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn_add = <span class="kw">fun</span> n m f x -&gt; n f (m f x)  <span class="co">(* Put n of f in front *)</span></span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn_mult = <span class="kw">fun</span> n m f -&gt; n (m f)       <span class="co">(* Repeat n times *)</span></span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a>                                          <span class="co">(* putting m of f in front *)</span></span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn_prev n =</span>
<span id="cb87-13"><a href="#cb87-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fun</span> f x -&gt;                  <span class="co">(* This is the &quot;Church numeral signature&quot; *)</span></span>
<span id="cb87-14"><a href="#cb87-14" aria-hidden="true" tabindex="-1"></a>    n                         <span class="co">(* The only thing we have is an n-step loop *)</span></span>
<span id="cb87-15"><a href="#cb87-15" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">fun</span> g v -&gt; v (g f))    <span class="co">(* We need sth that operates on f *)</span></span>
<span id="cb87-16"><a href="#cb87-16" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">fun</span> z -&gt; x)            <span class="co">(* We need to ignore the innermost step *)</span></span>
<span id="cb87-17"><a href="#cb87-17" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">fun</span> z -&gt; z)            <span class="co">(* We&#39;ve built a &quot;machine&quot; not results -- start the machine *)</span></span></code></pre></div>
<p>The predecessor function is ingenious. It builds up a chain of
functions that, when “started” with the identity, yields <span
class="math inline">n-1</span> applications of <code>f</code>. The key
insight is to delay the actual application of <code>f</code> and skip
the first one.</p>
<p><code>cn_is_zero</code> is left as an exercise.</p>
<h4 id="tracing-cn_prev-cn3">Tracing <code>cn_prev cn3</code></h4>
<p>Let us trace through <code>decode_cnat (cn_prev cn3)</code>:</p>
<p><span class="math display">\Downarrow</span></p>
<pre><code>(cn_prev cn3) ((+) 1) 0</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>(fun f x -&gt;
    cn3
      (fun g v -&gt; v (g f))
      (fun z -&gt; x)
      (fun z -&gt; z)) ((+) 1) 0</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>((fun f x -&gt; f (f (f x)))
      (fun g v -&gt; v (g ((+) 1)))
      (fun z -&gt; 0)
      (fun z -&gt; z))</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>((fun g v -&gt; v (g ((+) 1)))
  ((fun g v -&gt; v (g ((+) 1)))
    ((fun g v -&gt; v (g ((+) 1)))
      (fun z -&gt; 0))))
  (fun z -&gt; z))</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>((fun z -&gt; z)
  (((fun g v -&gt; v (g ((+) 1)))
    ((fun g v -&gt; v (g ((+) 1)))
      (fun z -&gt; 0)))) ((+) 1)))</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>(fun g v -&gt; v (g ((+) 1)))
  ((fun g v -&gt; v (g ((+) 1)))
    (fun z -&gt; 0)) ((+) 1)</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>((+) 1) ((fun g v -&gt; v (g ((+) 1)))
          (fun z -&gt; 0) ((+) 1))</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>((+) 1) (((+) 1) ((fun z -&gt; 0) ((+) 1)))</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>((+) 1) (((+) 1) (0))</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>((+) 1) 1</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>2</code></pre>
<h3 id="recursion-fixpoint-combinators">4.7 Recursion: Fixpoint
Combinators</h3>
<p>In lambda-calculus, recursion is achieved through <strong>fixpoint
combinators</strong>—lambda terms that compute fixed points of
functions.</p>
<h4 id="turings-fixpoint-combinator">Turing’s Fixpoint Combinator</h4>
<p><span class="math display">\Theta = (\lambda xy. y \; (x \; x \; y))
\; (\lambda xy. y \; (x \; x \; y))</span></p>
<p>Let us verify it computes fixed points. Define <span
class="math inline">N = \Theta F</span>:</p>
<p><span class="math display">
\begin{aligned}
N &amp;= \Theta F \\
&amp;= (\lambda xy. y \; (x \; x \; y)) \; (\lambda xy. y \; (x \; x \;
y)) \; F \\
&amp;=_{\rightarrow\rightarrow} F \; ((\lambda xy. y \; (x \; x \; y))
\; (\lambda xy. y \; (x \; x \; y)) \; F) \\
&amp;= F \; (\Theta F) = F \; N
\end{aligned}
</span></p>
<p>So <span class="math inline">N = F \; N</span>, meaning <span
class="math inline">N</span> is a fixed point of <span
class="math inline">F</span>.</p>
<h4 id="currys-fixpoint-combinator-y-combinator">Curry’s Fixpoint
Combinator (Y Combinator)</h4>
<p><span class="math display">\mathbf{Y} = \lambda f. (\lambda x. f \;
(x \; x)) \; (\lambda x. f \; (x \; x))</span></p>
<p><span class="math display">
\begin{aligned}
N &amp;= \mathbf{Y} F \\
&amp;= (\lambda f. (\lambda x. f \; (x \; x)) \; (\lambda x. f \; (x \;
x))) \; F \\
&amp;=_{\rightarrow} (\lambda x. F \; (x \; x)) \; (\lambda x. F \; (x
\; x)) \\
&amp;=_{\rightarrow} F \; ((\lambda x. F \; (x \; x)) \; (\lambda x. F
\; (x \; x))) \\
&amp;=_{\leftarrow} F \; ((\lambda f. (\lambda x. f \; (x \; x)) \;
(\lambda x. f \; (x \; x))) \; F) \\
&amp;= F \; (\mathbf{Y} F) = F \; N
\end{aligned}
</span></p>
<h4 id="call-by-value-fixpoint-combinator">Call-by-Value Fixpoint
Combinator</h4>
<p><span class="math display">\texttt{fix} = \lambda f&#39;. (\lambda
fx. f&#39; \; (f \; f) \; x) \; (\lambda fx. f&#39; \; (f \; f) \;
x)</span></p>
<p><span class="math display">
\begin{aligned}
N &amp;= \texttt{fix} \; F \\
&amp;= (\lambda f&#39;. (\lambda fx. f&#39; \; (f \; f) \; x) \;
(\lambda fx. f&#39; \; (f \; f) \; x)) \; F \\
&amp;=_{\rightarrow} (\lambda fx. F \; (f \; f) \; x) \; (\lambda fx. F
\; (f \; f) \; x) \\
&amp;=_{\rightarrow} \lambda x. F \; ((\lambda fx. F \; (f \; f) \; x)
\; (\lambda fx. F \; (f \; f) \; x)) \; x \\
&amp;=_{\leftarrow} \lambda x. F \; ((\lambda f&#39;. (\lambda fx.
f&#39; \; (f \; f) \; x) \; (\lambda fx. f&#39; \; (f \; f) \; x)) \; F)
\; x \\
&amp;= \lambda x. F \; (\texttt{fix} \; F) \; x = \lambda x. F \; N \; x
\\
&amp;=_{\eta} F \; N
\end{aligned}
</span></p>
<h4 id="the-problem-with-the-first-two-combinators">The Problem with the
First Two Combinators</h4>
<p>What is the problem with Turing’s and Curry’s combinators? Consider
what happens when we try to evaluate <span class="math inline">\Theta
F</span>:</p>
<p><span class="math display">
\begin{aligned}
\Theta F &amp;\rightsquigarrow\rightsquigarrow F \; ((\lambda xy. y \;
(x \; x \; y)) \; (\lambda xy. y \; (x \; x \; y)) \; F) \\
&amp;\rightsquigarrow\rightsquigarrow F \; (F \; ((\lambda xy. y \; (x
\; x \; y)) \; (\lambda xy. y \; (x \; x \; y)) \; F)) \\
&amp;\rightsquigarrow\rightsquigarrow F \; (F \; (F \; ((\lambda xy. y
\; (x \; x \; y)) \; (\lambda xy. y \; (x \; x \; y)) \; F))) \\
&amp;\rightsquigarrow\rightsquigarrow \ldots
\end{aligned}
</span></p>
<p>Recall the distinction between <em>expressions</em> and
<em>values</em> from Chapter 3 on Computation. The reduction rule for
lambda-calculus is meant to determine which expressions are considered
“equal”—it is highly <em>non-deterministic</em>, while on a computer,
computation needs to go one way or another.</p>
<p>Using the general reduction rule of lambda-calculus, for a recursive
definition, it is always possible to find an infinite reduction
sequence. This means a naive lambda-calculus compiler could legitimately
generate infinite loops for all recursive definitions!</p>
<p>Therefore, we need more specific rules. Most languages use
<strong>call-by-value</strong> (also called <strong>eager</strong>
evaluation):</p>
<p><span class="math display">(\texttt{fun } x \texttt{ -&gt; } a) \; v
\rightsquigarrow a[x := v]</span></p>
<p>The program <em>eagerly</em> computes arguments before starting to
compute the function body. This is exactly the rule we introduced in the
Computation chapter.</p>
<h4 id="call-by-value-fixpoint-combinator-in-action">Call-by-Value
Fixpoint Combinator in Action</h4>
<p>What happens with the call-by-value fixpoint combinator?</p>
<p><span class="math display">
\begin{aligned}
\texttt{fix} \; F &amp;\rightsquigarrow (\lambda fx. F \; (f \; f) \; x)
\; (\lambda fx. F \; (f \; f) \; x) \\
&amp;\rightsquigarrow \lambda x. F \; ((\lambda fx. F \; (f \; f) \; x)
\; (\lambda fx. F \; (f \; f) \; x)) \; x
\end{aligned}
</span></p>
<p>The computation stops because we use the rule <span
class="math inline">(\texttt{fun } x \texttt{ -&gt; } a) \; v
\rightsquigarrow a[x := v]</span> rather than <span
class="math inline">(\texttt{fun } x \texttt{ -&gt; } a_1) \; a_2
\rightsquigarrow a_1[x := a_2]</span>. The expression inside the lambda
is not evaluated until the function is applied.</p>
<p>Let us compute the function on some input:</p>
<p><span class="math display">
\begin{aligned}
\texttt{fix} \; F \; v &amp;\rightsquigarrow (\lambda fx. F \; (f \; f)
\; x) \; (\lambda fx. F \; (f \; f) \; x) \; v \\
&amp;\rightsquigarrow (\lambda x. F \; ((\lambda fx. F \; (f \; f) \; x)
\; (\lambda fx. F \; (f \; f) \; x)) \; x) \; v \\
&amp;\rightsquigarrow F \; ((\lambda fx. F \; (f \; f) \; x) \; (\lambda
fx. F \; (f \; f) \; x)) \; v \\
&amp;\rightsquigarrow F \; (\lambda x. F \; ((\lambda fx. F \; (f \; f)
\; x) \; (\lambda fx. F \; (f \; f) \; x)) \; x) \; v \\
&amp;\rightsquigarrow \text{depends on } F
\end{aligned}
</span></p>
<h4 id="why-fixpoint">Why “Fixpoint”?</h4>
<p>If you examine our derivations, you will see they establish <span
class="math inline">x = f(x)</span>. Such values <span
class="math inline">x</span> are called <strong>fixpoints</strong> of
<span class="math inline">f</span>. An arithmetic function can have
several fixpoints—for example, <span class="math inline">f(x) =
x^2</span> has fixpoints 0 and 1—or no fixpoints, such as <span
class="math inline">f(x) = x + 1</span>.</p>
<p>When you define a function (or another object) by recursion, it has
similar meaning: the name appears on both sides of the equality. In
lambda-calculus, functions like <span class="math inline">\Theta</span>
and <span class="math inline">\mathbf{Y}</span> take <em>any</em>
function as an argument and return its fixpoint.</p>
<p>We turn a specification of a recursive object into a definition by
solving it with respect to the recurring name: deriving <span
class="math inline">x = f(x)</span> where <span
class="math inline">x</span> is the recurring name. We then have <span
class="math inline">x = \texttt{fix}(f)</span>.</p>
<h4 id="deriving-factorial">Deriving Factorial</h4>
<p>Let us walk through this for the factorial function. We omit the
prefix <code>cn_</code> (could be <code>pn_</code> if using pair-encoded
numbers) and shorten <code>if_then_else</code> to
<code>if_t_e</code>:</p>
<p><span class="math display">
\begin{aligned}
\texttt{fact} \; n &amp;= \texttt{if\_t\_e} \; (\texttt{is\_zero} \; n)
\; \texttt{cn1} \; (\texttt{mult} \; n \; (\texttt{fact} \;
(\texttt{pred} \; n))) \\
\texttt{fact} &amp;= \lambda n. \texttt{if\_t\_e} \; (\texttt{is\_zero}
\; n) \; \texttt{cn1} \; (\texttt{mult} \; n \; (\texttt{fact} \;
(\texttt{pred} \; n))) \\
\texttt{fact} &amp;= (\lambda fn. \texttt{if\_t\_e} \;
(\texttt{is\_zero} \; n) \; \texttt{cn1} \; (\texttt{mult} \; n \; (f \;
(\texttt{pred} \; n)))) \; \texttt{fact} \\
\texttt{fact} &amp;= \texttt{fix} \; (\lambda fn. \texttt{if\_t\_e} \;
(\texttt{is\_zero} \; n) \; \texttt{cn1} \; (\texttt{mult} \; n \; (f \;
(\texttt{pred} \; n))))
\end{aligned}
</span></p>
<p>The last line is a valid definition: we simply give a name to a
<em>ground</em> (also called <em>closed</em>) expression—one with no
free variables.</p>
<p><strong>Exercise:</strong> Compute <code>fact cn2</code>.</p>
<p><strong>Exercise:</strong> What does
<code>fix (fun x -&gt; cn_succ x)</code> mean?</p>
<h3 id="encoding-lists-and-trees">4.8 Encoding Lists and Trees</h3>
<p>A <strong>list</strong> is either empty (often called
<code>Empty</code> or <code>Nil</code>) or consists of an element
followed by another list (the “tail”), called <code>Cons</code>.</p>
<p>Define: - <code>nil</code> <span class="math inline">= \lambda
xy.y</span> - <code>cons</code> <span class="math inline">H \; T =
\lambda xy. x \; H \; T</span></p>
<p>To add numbers stored inside a list:</p>
<p><span class="math display">\texttt{addlist} \; l = l \; (\lambda ht.
\texttt{cn\_add} \; h \; (\texttt{addlist} \; t)) \;
\texttt{cn0}</span></p>
<p>To make a proper definition, we apply <span
class="math inline">\texttt{fix}</span> to the solution of the above
equation:</p>
<p><span class="math display">\texttt{addlist} = \texttt{fix} \;
(\lambda fl. l \; (\lambda ht. \texttt{cn\_add} \; h \; (f \; t)) \;
\texttt{cn0})</span></p>
<p>For <strong>trees</strong>, let us use a different form of binary
trees: instead of keeping elements in inner nodes, we keep elements in
leaves.</p>
<p>Define: - <code>leaf</code> <span class="math inline">n = \lambda xy.
x \; n</span> - <code>node</code> <span class="math inline">L \; R =
\lambda xy. y \; L \; R</span></p>
<p>To add numbers stored inside a tree:</p>
<p><span class="math display">\texttt{addtree} \; t = t \; (\lambda n.n)
\; (\lambda lr. \texttt{cn\_add} \; (\texttt{addtree} \; l) \;
(\texttt{addtree} \; r))</span></p>
<p>And in solved form:</p>
<p><span class="math display">\texttt{addtree} = \texttt{fix} \;
(\lambda ft. t \; (\lambda n.n) \; (\lambda lr. \texttt{cn\_add} \; (f
\; l) \; (f \; r)))</span></p>
<pre><code>let rec fix f x = f (fix f) x
let nil = fun x y -&gt; y
let cons h t = fun x y -&gt; x h t
let addlist l =
  fix (fun f l -&gt; l (fun h t -&gt; cn_add h (f t)) cn0) l
;;
decode_cnat
  (addlist (cons cn1 (cons cn2 (cons cn7 nil))));;
let leaf n = fun x y -&gt; x n
let node l r = fun x y -&gt; y l r
let addtree t =
  fix (fun f t -&gt;
    t (fun n -&gt; n) (fun l r -&gt; cn_add (f l) (f r))
  ) t
;;
decode_cnat
  (addtree (node (node (leaf cn3) (leaf cn7))
              (leaf cn1)));;</code></pre>
<h4 id="the-general-pattern">The General Pattern</h4>
<p>Observe a regularity: when we encode a variant type with <span
class="math inline">n</span> variants, for each variant we define a
function that takes <span class="math inline">n</span> arguments.</p>
<p>If the <span class="math inline">k</span>th variant <span
class="math inline">C_k</span> has <span class="math inline">m_k</span>
parameters, then the function <span class="math inline">c_k</span> that
encodes it has the form:</p>
<p><span class="math display">C_k(v_1, \ldots, v_{m_k}) \sim c_k \; v_1
\; \ldots \; v_{m_k} = \lambda x_1 \ldots x_n. x_k \; v_1 \; \ldots \;
v_{m_k}</span></p>
<p>The encoded variants serve as shallow pattern matching with
guaranteed exhaustiveness: the <span class="math inline">k</span>th
argument corresponds to the <span class="math inline">k</span>th branch
of pattern matching.</p>
<h3 id="looping-recursion">4.9 Looping Recursion</h3>
<p>Let us return to pair-encoded numbers and define addition:</p>
<pre><code>let pn_add m n =
  fix (fun f m n -&gt;
    if_then_else (pn_is_zero m)
      n (pn_succ (f (pn_pred m) n))
  ) m n;;
decode_pnat (pn_add pn3 pn3);;</code></pre>
<p>Oops… OCaml says:
<code>Stack overflow during evaluation (looping recursion?).</code></p>
<p>What went wrong? Nothing as far as lambda-calculus is concerned. But
OCaml (and F#) always compute arguments before calling a function. By
definition of <code>fix</code>, <code>f</code> corresponds to
recursively calling <code>pn_add</code>. Therefore,
<code>(pn_succ (f (pn_pred m) n))</code> will be evaluated regardless of
what <code>(pn_is_zero m)</code> returns!</p>
<p>Why do <code>addlist</code> and <code>addtree</code> work? Because
their recursive calls are “guarded” by corresponding <code>fun</code>.
What is inside of <code>fun</code> is not computed immediately—only when
the function is applied to argument(s).</p>
<p>To avoid looping recursion, you need to guard all recursive calls.
Besides putting them inside <code>fun</code>, in OCaml or F# you can
also put them in branches of a <code>match</code> clause, as long as one
of the branches does not have unguarded recursive calls.</p>
<p>The trick for functions like <code>if_then_else</code> is to guard
their arguments with <code>fun x -&gt;</code>, where <code>x</code> is
not used, and apply the <em>result</em> of <code>if_then_else</code> to
some dummy value:</p>
<pre><code>let id x = x
let rec fix f x = f (fix f) x
let pn1 x = pn_succ pn0 x
let pn2 x = pn_succ pn1 x
let pn3 x = pn_succ pn2 x
let pn7 x = encode_pnat 7 x
let pn_add m n =
  fix (fun f m n -&gt;
    (if_then_else (pn_is_zero m)
       (fun x -&gt; n) (fun x -&gt; pn_succ (f (pn_pred m) n)))
      id
  ) m n;;
decode_pnat (pn_add pn3 pn3);;
decode_pnat (pn_add pn3 pn7);;</code></pre>
<p>In OCaml or F# we would typically guard by <code>fun () -&gt;</code>
and then apply to <code>()</code>, but we do not have datatypes like
<code>unit</code> in pure lambda-calculus.</p>
<h3 id="exercises-3">4.10 Exercises</h3>
<p><strong>Exercise 1:</strong> Define (implement) and test on a couple
of examples functions corresponding to or computing:</p>
<ol type="1">
<li><code>c_or</code> and <code>c_not</code>;</li>
<li>exponentiation for Church numerals;</li>
<li>is-zero predicate for Church numerals;</li>
<li>even-number predicate for Church numerals;</li>
<li>multiplication for pair-encoded natural numbers;</li>
<li>factorial <span class="math inline">n!</span> for pair-encoded
natural numbers;</li>
<li>the length of a list (in Church numerals);</li>
<li><code>cn_max</code> – maximum of two Church numerals;</li>
<li>the depth of a tree (in Church numerals).</li>
</ol>
<p><strong>Exercise 2:</strong> Construct lambda-terms <span
class="math inline">m_0, m_1, \ldots</span> such that for all <span
class="math inline">n</span> one has:</p>
<p><span class="math display">
\begin{aligned}
m_0 &amp;= x \\
m_{n+1} &amp;= m_{n+2} \; m_n
\end{aligned}
</span></p>
<p>(where equality is after performing <span
class="math inline">\beta</span>-reductions).</p>
<p><strong>Exercise 3:</strong> Representing side-effects as an
explicitly “passed around” state value, write (higher-order) functions
that represent the imperative constructs:</p>
<ol type="1">
<li><code>for</code>…<code>to</code>…</li>
<li><code>for</code>…<code>downto</code>…</li>
<li><code>while</code>…<code>do</code>…</li>
<li><code>do</code>…<code>while</code>…</li>
<li><code>repeat</code>…<code>until</code>…</li>
</ol>
<p>Rather than writing a lambda-term using the encodings that we have
learnt, just implement the functions in OCaml / F#, using built-in
<code>int</code> and <code>bool</code> types. You can use
<code>let rec</code> instead of <code>fix</code>.</p>
<ul>
<li>For example, in exercise (a), write a function
<code>let rec for_to f beg_i end_i s = ...</code> where <code>f</code>
takes arguments <code>i</code> ranging from <code>beg_i</code> to
<code>end_i</code>, state <code>s</code> at given step, and returns
state <code>s</code> at next step; the <code>for_to</code> function
returns the state after the last step.</li>
<li>And in exercise (c), write a function
<code>let rec while_do p f s = ...</code> where both <code>p</code> and
<code>f</code> take state <code>s</code> at given step, and if
<code>p s</code> returns true, then <code>f s</code> is computed to
obtain state at next step; the <code>while_do</code> function returns
the state after the last step.</li>
</ul>
<p>Do not use the imperative features of OCaml and F#!</p>
<p>Although we will not cover imperative features in this course, it is
instructive to see the implementation using them, to better understand
what is actually required of a solution to Exercise 3:</p>
<div class="sourceCode" id="cb102"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* (a) *)</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> for_to f beg_i end_i s =</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s = <span class="dt">ref</span> s <span class="kw">in</span></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">for</span> i = beg_i <span class="kw">to</span> end_i <span class="kw">do</span></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a>    s := f i !s</span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span>;</span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true" tabindex="-1"></a>  !s</span>
<span id="cb102-8"><a href="#cb102-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-9"><a href="#cb102-9" aria-hidden="true" tabindex="-1"></a><span class="co">(* (b) *)</span></span>
<span id="cb102-10"><a href="#cb102-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> for_downto f beg_i end_i s =</span>
<span id="cb102-11"><a href="#cb102-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s = <span class="dt">ref</span> s <span class="kw">in</span></span>
<span id="cb102-12"><a href="#cb102-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">for</span> i = beg_i <span class="kw">downto</span> end_i <span class="kw">do</span></span>
<span id="cb102-13"><a href="#cb102-13" aria-hidden="true" tabindex="-1"></a>    s := f i !s</span>
<span id="cb102-14"><a href="#cb102-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span>;</span>
<span id="cb102-15"><a href="#cb102-15" aria-hidden="true" tabindex="-1"></a>  !s</span>
<span id="cb102-16"><a href="#cb102-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-17"><a href="#cb102-17" aria-hidden="true" tabindex="-1"></a><span class="co">(* (c) *)</span></span>
<span id="cb102-18"><a href="#cb102-18" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> while_do p f s =</span>
<span id="cb102-19"><a href="#cb102-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s = <span class="dt">ref</span> s <span class="kw">in</span></span>
<span id="cb102-20"><a href="#cb102-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">while</span> p !s <span class="kw">do</span></span>
<span id="cb102-21"><a href="#cb102-21" aria-hidden="true" tabindex="-1"></a>    s := f !s</span>
<span id="cb102-22"><a href="#cb102-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span>;</span>
<span id="cb102-23"><a href="#cb102-23" aria-hidden="true" tabindex="-1"></a>  !s</span>
<span id="cb102-24"><a href="#cb102-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-25"><a href="#cb102-25" aria-hidden="true" tabindex="-1"></a><span class="co">(* (d) *)</span></span>
<span id="cb102-26"><a href="#cb102-26" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> do_while p f s =</span>
<span id="cb102-27"><a href="#cb102-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s = <span class="dt">ref</span> (f s) <span class="kw">in</span></span>
<span id="cb102-28"><a href="#cb102-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">while</span> p !s <span class="kw">do</span></span>
<span id="cb102-29"><a href="#cb102-29" aria-hidden="true" tabindex="-1"></a>    s := f !s</span>
<span id="cb102-30"><a href="#cb102-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span>;</span>
<span id="cb102-31"><a href="#cb102-31" aria-hidden="true" tabindex="-1"></a>  !s</span>
<span id="cb102-32"><a href="#cb102-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-33"><a href="#cb102-33" aria-hidden="true" tabindex="-1"></a><span class="co">(* (e) *)</span></span>
<span id="cb102-34"><a href="#cb102-34" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> repeat_until p f s =</span>
<span id="cb102-35"><a href="#cb102-35" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s = <span class="dt">ref</span> (f s) <span class="kw">in</span></span>
<span id="cb102-36"><a href="#cb102-36" aria-hidden="true" tabindex="-1"></a>  <span class="kw">while</span> <span class="dt">not</span> (p !s) <span class="kw">do</span></span>
<span id="cb102-37"><a href="#cb102-37" aria-hidden="true" tabindex="-1"></a>    s := f !s</span>
<span id="cb102-38"><a href="#cb102-38" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span>;</span>
<span id="cb102-39"><a href="#cb102-39" aria-hidden="true" tabindex="-1"></a>  !s</span></code></pre></div>
<h2 id="chapter-5-polymorphism-and-abstract-data-types">Chapter 5:
Polymorphism and Abstract Data Types</h2>
<p>This chapter explores how OCaml’s type system supports generic
programming through parametric polymorphism, and how abstract data types
provide clean interfaces for data structures. We examine the formal
mechanics of type inference and then apply these concepts to build
progressively more sophisticated implementations of the map (dictionary)
data structure, culminating in red-black trees.</p>
<h3 id="type-inference">5.1 Type Inference</h3>
<p>We have seen the rules that govern the assignment of types to
expressions, but how does OCaml guess what types to use, and when no
correct types exist? The answer is that it solves equations.</p>
<h4 id="variables-unknowns-and-parameters">5.1.1 Variables: Unknowns and
Parameters</h4>
<p>Variables in type inference play two distinct roles: they can be
<em>unknowns</em> (standing for a specific but not-yet-determined type)
or <em>parameters</em> (standing for any type whatsoever).</p>
<p>Consider the following example:</p>
<div class="sourceCode" id="cb103"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> f = <span class="dt">List</span>.hd;;</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : &#39;a <span class="dt">list</span> -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
<p>Here <code>'a</code> is a parameter: it can become any type.
Mathematically we write: <span class="math inline">f : \forall \alpha .
\alpha \ \text{list} \rightarrow \alpha</span> – the quantified type is
called a <em>type scheme</em>.</p>
<p>In contrast:</p>
<div class="sourceCode" id="cb104"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> x = <span class="dt">ref</span> [];;</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> x : &#39;_weak1 <span class="dt">list</span> <span class="dt">ref</span> = {contents = []}</span></code></pre></div>
<p>Here <code>'_a</code> is an unknown. It stands for a particular type
like <code>float</code> or <code>int -&gt; int</code>, but OCaml just
does not yet know which type. OCaml only reports unknowns like
<code>'_a</code> in inferred types for reasons related to mutable state
(the “value restriction”), which are not central to functional
programming.</p>
<p>When unknowns appear in inferred types against our expectations,
<em><span class="math inline">\eta</span>-expansion</em> may help:
writing <code>let f x = expr x</code> instead of
<code>let f = expr</code>. For example:</p>
<div class="sourceCode" id="cb105"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> f = <span class="dt">List</span>.append [];;</span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : &#39;_weak2 <span class="dt">list</span> -&gt; &#39;_weak2 <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> f l = <span class="dt">List</span>.append [] l;;</span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
<p>In the second definition, the eta-expanded form allows full
generalization.</p>
<h4 id="type-environments">5.1.2 Type Environments</h4>
<p>A <em>type environment</em> specifies what names (corresponding to
parameters and definitions) are available for an expression because they
were introduced above it, and it specifies their types.</p>
<h4 id="solving-type-equations">5.1.3 Solving Type Equations</h4>
<p>Type inference solves equations over unknowns. The central question
is: “What has to hold so that <span class="math inline">e : \tau</span>
in type environment <span class="math inline">\Gamma</span>?”</p>
<p>The process works as follows:</p>
<ul>
<li><p>If, for example, <span class="math inline">f : \forall \alpha .
\alpha \ \text{list} \rightarrow \alpha \in \Gamma</span>, then for
<span class="math inline">f : \tau</span> we introduce <span
class="math inline">\gamma \ \text{list} \rightarrow \gamma =
\tau</span> for some fresh unknown <span
class="math inline">\gamma</span>.</p></li>
<li><p>For function application <span class="math inline">e_1 \ e_2 :
\tau</span>, we introduce <span class="math inline">\beta = \tau</span>
and ask for <span class="math inline">e_1 : \gamma \rightarrow
\beta</span> and <span class="math inline">e_2 : \gamma</span>, for some
fresh unknowns <span class="math inline">\beta, \gamma</span>.</p></li>
<li><p>For a function <span class="math inline">\text{fun} \ x
\rightarrow e : \tau</span>, we introduce <span
class="math inline">\beta \rightarrow \gamma = \tau</span> and ask for
<span class="math inline">e : \gamma</span> in environment <span
class="math inline">\{x : \beta\} \cup \Gamma</span>, for some fresh
unknowns <span class="math inline">\beta, \gamma</span>.</p></li>
<li><p>The case <span class="math inline">\text{let} \ x = e_1 \
\text{in} \ e_2 : \tau</span> is different. One approach is to
<em>first</em> solve the equations that we get by asking for <span
class="math inline">e_1 : \beta</span>, for some fresh unknown <span
class="math inline">\beta</span>. Let us say a solution <span
class="math inline">\beta = \tau_\beta</span> has been found, <span
class="math inline">\alpha_1 \ldots \alpha_n \beta_1 \ldots
\beta_m</span> are the remaining unknowns in <span
class="math inline">\tau_\beta</span>, and <span
class="math inline">\alpha_1 \ldots \alpha_n</span> are all that do not
appear in <span class="math inline">\Gamma</span>. Then we ask for <span
class="math inline">e_2 : \tau</span> in environment <span
class="math inline">\{x : \forall \alpha_1 \ldots \alpha_n .
\tau_\beta\} \cup \Gamma</span>.</p></li>
<li><p>Remember that whenever we establish a solution <span
class="math inline">\beta = \tau_\beta</span> to an unknown <span
class="math inline">\beta</span>, it takes effect everywhere!</p></li>
<li><p>To find a type for <span class="math inline">e</span> (in
environment <span class="math inline">\Gamma</span>), we pick a fresh
unknown <span class="math inline">\beta</span> and ask for <span
class="math inline">e : \beta</span> (in <span
class="math inline">\Gamma</span>).</p></li>
</ul>
<h4 id="polymorphism">5.1.4 Polymorphism</h4>
<p>The “top-level” definitions for which the system infers types with
variables are called <em>polymorphic</em>, which informally means
“working with different shapes of data”. This kind of polymorphism is
called <em>parametric polymorphism</em>, since the types have
parameters. A different kind of polymorphism is provided by
object-oriented programming languages (sometimes called <em>subtype
polymorphism</em> or <em>ad-hoc polymorphism</em>).</p>
<h3 id="parametric-types">5.2 Parametric Types</h3>
<p>Polymorphic functions shine when used with polymorphic data types.
Consider:</p>
<div class="sourceCode" id="cb106"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a my_list = Empty | Cons <span class="kw">of</span> &#39;a * &#39;a my_list</span></code></pre></div>
<p>We define lists that can store elements of any type <code>'a</code>.
Now:</p>
<div class="sourceCode" id="cb107"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> tail l =</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="dt">invalid_arg</span> <span class="st">&quot;tail&quot;</span></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a>    | Cons (_, tl) -&gt; tl;;</span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> tail : &#39;a my_list -&gt; &#39;a my_list = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
<p>This is a polymorphic function: it works for lists with elements of
any type.</p>
<p>A <em>parametric type</em> like <code>'a my_list</code> <em>is
not</em> itself a data type but a family of data types:
<code>bool my_list</code>, <code>int my_list</code>, etc. <em>are</em>
different types. We say that the type <code>int my_list</code>
<em>instantiates</em> the parametric type <code>'a my_list</code>.</p>
<h4 id="multiple-type-parameters">5.2.1 Multiple Type Parameters</h4>
<p>In OCaml, the syntax is a bit confusing: type parameters precede the
type name. For example:</p>
<div class="sourceCode" id="cb108"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (&#39;a, &#39;b) choice = Left <span class="kw">of</span> &#39;a | Right <span class="kw">of</span> &#39;b</span></code></pre></div>
<p>This type has two parameters. Mathematically we would write <span
class="math inline">\text{choice}(\alpha, \beta)</span>.</p>
<p>Functions do not have to be polymorphic:</p>
<div class="sourceCode" id="cb109"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> get_int c =</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> c <span class="kw">with</span></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a>    | Left i -&gt; i</span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a>    | Right b -&gt; <span class="kw">if</span> b <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>;;</span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> get_int : (<span class="dt">int</span>, <span class="dt">bool</span>) choice -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
<h4 id="syntax-in-other-languages">5.2.2 Syntax in Other Languages</h4>
<p>In F#, we provide parameters (when more than one) after the type
name:</p>
<div class="sourceCode" id="cb110"><pre
class="sourceCode fsharp"><code class="sourceCode fsharp"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> choice&lt;&#39;a,&#39;b&gt; = Left <span class="kw">of</span> &#39;a | Right <span class="kw">of</span> &#39;b</span></code></pre></div>
<p>In Haskell, we provide type parameters similarly to function
arguments:</p>
<div class="sourceCode" id="cb111"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Choice</span> a b <span class="ot">=</span> <span class="dt">Left</span> a <span class="op">|</span> <span class="dt">Right</span> b</span></code></pre></div>
<h3 id="type-inference-formally">5.3 Type Inference, Formally</h3>
<p>A statement that an expression has a type in an environment is called
a <em>type judgement</em>. For environment <span
class="math inline">\Gamma = \{x : \forall \alpha_1 \ldots \alpha_n .
\tau_x ; \ldots\}</span>, expression <span class="math inline">e</span>
and type <span class="math inline">\tau</span> we write:</p>
<p><span class="math display">\Gamma \vdash e : \tau</span></p>
<p>We will derive the equations in one go using <span
class="math inline">[\![ \cdot ]\!]</span>, to be solved later. Besides
equations we will need to manage introduced variables, using existential
quantification.</p>
<p>For local definitions we require remembering what constraints should
hold when the definition is used. Therefore we extend <em>type
schemes</em> in the environment to: <span class="math inline">\Gamma =
\{x : \forall \beta_1 \ldots \beta_m [\exists \alpha_1 \ldots \alpha_n .
D] . \tau_x ; \ldots\}</span> where <span class="math inline">D</span>
are equations – keeping the variables <span class="math inline">\alpha_1
\ldots \alpha_n</span> introduced while deriving <span
class="math inline">D</span> in front. A simpler form would be enough:
<span class="math inline">\Gamma = \{x : \forall \beta [\exists \alpha_1
\ldots \alpha_n . D] . \beta ; \ldots\}</span></p>
<p>The formal constraint generation rules are:</p>
<p><span class="math display">[\![ \Gamma \vdash x : \tau ]\!] = \exists
\overline{\beta&#39;} \overline{\alpha&#39;} . (D[\overline{\beta}
\overline{\alpha} := \overline{\beta&#39;} \overline{\alpha&#39;}]
\wedge \tau_x[\overline{\beta} \overline{\alpha} :=
\overline{\beta&#39;} \overline{\alpha&#39;}] \doteq \tau)</span></p>
<p>where <span class="math inline">\Gamma(x) = \forall \overline{\beta}
[\exists \overline{\alpha} . D] . \tau_x</span>, <span
class="math inline">\overline{\beta&#39;} \overline{\alpha&#39;} \#
\text{FV}(\Gamma, \tau)</span></p>
<p><span class="math display">[\![ \Gamma \vdash \mathbf{fun} \ x
\texttt{-&gt;} e : \tau ]\!] = \exists \alpha_1 \alpha_2 . ([\![ \Gamma
\{x : \alpha_1\} \vdash e : \alpha_2 ]\!] \wedge \alpha_1 \rightarrow
\alpha_2 \doteq \tau)</span></p>
<p>where <span class="math inline">\alpha_1 \alpha_2 \#
\text{FV}(\Gamma, \tau)</span></p>
<p><span class="math display">[\![ \Gamma \vdash e_1 \ e_2 : \tau ]\!] =
\exists \alpha . ([\![ \Gamma \vdash e_1 : \alpha \rightarrow \tau ]\!]
\wedge [\![ \Gamma \vdash e_2 : \alpha ]\!]), \alpha \#
\text{FV}(\Gamma, \tau)</span></p>
<p><span class="math display">[\![ \Gamma \vdash K \ e_1 \ldots e_n :
\tau ]\!] = \exists \overline{\alpha&#39;} . (\bigwedge_i [\![ \Gamma
\vdash e_i : \tau_i[\overline{\alpha} := \overline{\alpha&#39;}] ]\!]
\wedge \varepsilon(\overline{\alpha&#39;}) \doteq \tau)</span></p>
<p>where <span class="math inline">K : \forall \overline{\alpha} .
\tau_1 \times \ldots \times \tau_n \rightarrow
\varepsilon(\overline{\alpha})</span>, <span
class="math inline">\overline{\alpha&#39;} \# \text{FV}(\Gamma,
\tau)</span></p>
<p>For let-expressions:</p>
<p><span class="math display">[\![ \Gamma \vdash \mathbf{let} \ x = e_1
\ \mathbf{in} \ e_2 : \tau ]\!] = (\exists \beta . C) \wedge [\![ \Gamma
\{x : \forall \beta [C] . \beta\} \vdash e_2 : \tau ]\!]</span></p>
<p>where <span class="math inline">C = [\![ \Gamma \vdash e_1 : \beta
]\!]</span></p>
<p>For recursive let-expressions:</p>
<p><span class="math display">[\![ \Gamma \vdash \mathbf{letrec} \ x =
e_1 \ \mathbf{in} \ e_2 : \tau ]\!] = (\exists \beta . C) \wedge [\![
\Gamma \{x : \forall \beta [C] . \beta\} \vdash e_2 : \tau
]\!]</span></p>
<p>where <span class="math inline">C = [\![ \Gamma \{x : \beta\} \vdash
e_1 : \beta ]\!]</span></p>
<p>For match expressions:</p>
<p><span class="math display">[\![ \Gamma \vdash \mathbf{match} \ e_v \
\mathbf{with} \ \overline{c} : \tau ]\!] = \exists \alpha_v . [\![
\Gamma \vdash e_v : \alpha_v ]\!] \bigwedge_i [\![ \Gamma \vdash p_i .
e_i : \alpha_v \rightarrow \tau ]\!]</span></p>
<p>where <span class="math inline">\overline{c} = p_1 . e_1 | \ldots |
p_n . e_n</span>, <span class="math inline">\alpha_v \#
\text{FV}(\Gamma, \tau)</span></p>
<p>For pattern clauses:</p>
<p><span class="math display">[\![ \Gamma, \Sigma \vdash p.e : \tau_1
\rightarrow \tau_2 ]\!] = [\![ \Sigma \vdash p \downarrow \tau_1 ]\!]
\wedge \exists \overline{\beta} . [\![ \Gamma \Gamma&#39; \vdash e :
\tau_2 ]\!]</span></p>
<p>where <span class="math inline">\exists \overline{\beta}
\Gamma&#39;</span> is <span class="math inline">[\![ \Sigma \vdash p
\uparrow \tau_1 ]\!]</span>, <span class="math inline">\overline{\beta}
\# \text{FV}(\Gamma, \tau_2)</span></p>
<p>The notation <span class="math inline">[\![ \Sigma \vdash p
\downarrow \tau_1 ]\!]</span> derives constraints on the type of the
matched value, while <span class="math inline">[\![ \Sigma \vdash p
\uparrow \tau_1 ]\!]</span> derives the environment for pattern
variables.</p>
<p>By <span class="math inline">\overline{\alpha}</span> or <span
class="math inline">\overline{\alpha_i}</span> we denote a sequence of
some length: <span class="math inline">\alpha_1 \ldots \alpha_n</span>.
By <span class="math inline">\bigwedge_i \varphi_i</span> we denote a
conjunction of <span class="math inline">\overline{\varphi_i}</span>:
<span class="math inline">\varphi_1 \wedge \ldots \wedge
\varphi_n</span>.</p>
<h4 id="polymorphic-recursion">5.3.1 Polymorphic Recursion</h4>
<p>Note the limited polymorphism of <code>let rec f = ...</code> – we
cannot use <code>f</code> polymorphically in its definition. In modern
OCaml we can bypass the problem if we provide the type of <code>f</code>
upfront:</p>
<pre><code>let rec f : &#39;a. &#39;a -&gt; &#39;a list = ...</code></pre>
<p>where <code>'a. 'a -&gt; 'a list</code> stands for <span
class="math inline">\forall \alpha . \alpha \rightarrow \alpha \
\text{list}</span>.</p>
<p>Using the recursively defined function with different types in its
definition is called <em>polymorphic recursion</em>. It is most useful
together with <em>irregular recursive datatypes</em> where the recursive
use has different type arguments than the actual parameters.</p>
<h5
id="example-a-list-alternating-between-two-types-of-elements">Example: A
List Alternating Between Two Types of Elements</h5>
<div class="sourceCode" id="cb113"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (&#39;x, &#39;o) alterning =</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>  | Stop</span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>  | One <span class="kw">of</span> &#39;x * (&#39;o, &#39;x) alterning</span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> to_list :</span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a>    &#39;x &#39;o &#39;a. (&#39;x -&gt; &#39;a) -&gt; (&#39;o -&gt; &#39;a) -&gt;</span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a>              (&#39;x, &#39;o) alterning -&gt; &#39;a <span class="dt">list</span> =</span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fun</span> x2a o2a -&gt;</span>
<span id="cb113-9"><a href="#cb113-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">function</span></span>
<span id="cb113-10"><a href="#cb113-10" aria-hidden="true" tabindex="-1"></a>    | Stop -&gt; []</span>
<span id="cb113-11"><a href="#cb113-11" aria-hidden="true" tabindex="-1"></a>    | One (x, rest) -&gt; x2a x :: to_list o2a x2a rest</span>
<span id="cb113-12"><a href="#cb113-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-13"><a href="#cb113-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> to_choice_list alt =</span>
<span id="cb113-14"><a href="#cb113-14" aria-hidden="true" tabindex="-1"></a>  to_list (<span class="kw">fun</span> x -&gt; Left x) (<span class="kw">fun</span> o -&gt; Right o) alt</span>
<span id="cb113-15"><a href="#cb113-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-16"><a href="#cb113-16" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> it = to_choice_list</span>
<span id="cb113-17"><a href="#cb113-17" aria-hidden="true" tabindex="-1"></a>  (One (<span class="dv">1</span>, One (<span class="st">&quot;o&quot;</span>, One (<span class="dv">2</span>, One (<span class="st">&quot;oo&quot;</span>, Stop)))))</span></code></pre></div>
<p>Notice how the recursive call to <code>to_list</code> swaps
<code>o2a</code> and <code>x2a</code> – this is necessary because the
alternating structure swaps the type parameters at each level.</p>
<h5 id="example-data-structural-bootstrapping">Example: Data-Structural
Bootstrapping</h5>
<div class="sourceCode" id="cb114"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a seq =</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>  | Nil</span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>  | Zero <span class="kw">of</span> (&#39;a * &#39;a) seq</span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>  | One <span class="kw">of</span> &#39;a * (&#39;a * &#39;a) seq</span></code></pre></div>
<p>We store a list of elements in exponentially increasing chunks:</p>
<div class="sourceCode" id="cb115"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> example =</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>  One (<span class="dv">0</span>, One ((<span class="dv">1</span>,<span class="dv">2</span>), Zero (One ((((<span class="dv">3</span>,<span class="dv">4</span>),(<span class="dv">5</span>,<span class="dv">6</span>)), ((<span class="dv">7</span>,<span class="dv">8</span>),(<span class="dv">9</span>,<span class="dv">10</span>))), Nil))))</span></code></pre></div>
<div class="sourceCode" id="cb116"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> cons : &#39;a. &#39;a -&gt; &#39;a seq -&gt; &#39;a seq =  <span class="co">(* Appending an element to the *)</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fun</span> x -&gt; <span class="kw">function</span>                           <span class="co">(* datastructure is like *)</span></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>  | Nil -&gt; One (x, Nil)                       <span class="co">(* adding one to a binary number: 1+0=1 *)</span></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a>  | Zero ps -&gt; One (x, ps)                    <span class="co">(* 1+...0=...1 *)</span></span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a>  | One (y, ps) -&gt; Zero (cons (x,y) ps)       <span class="co">(* 1+...1=[...+1]0 *)</span></span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> lookup : &#39;a. <span class="dt">int</span> -&gt; &#39;a seq -&gt; &#39;a =</span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fun</span> i s -&gt; <span class="kw">match</span> i, s <span class="kw">with</span></span>
<span id="cb116-9"><a href="#cb116-9" aria-hidden="true" tabindex="-1"></a>  | _, Nil -&gt; <span class="dt">raise</span> <span class="dt">Not_found</span>                 <span class="co">(* Rather than returning None : &#39;a option *)</span></span>
<span id="cb116-10"><a href="#cb116-10" aria-hidden="true" tabindex="-1"></a>  | <span class="dv">0</span>, One (x, _) -&gt; x                        <span class="co">(* we raise exception, for convenience. *)</span></span>
<span id="cb116-11"><a href="#cb116-11" aria-hidden="true" tabindex="-1"></a>  | i, One (_, ps) -&gt; lookup (i<span class="dv">-1</span>) (Zero ps)</span>
<span id="cb116-12"><a href="#cb116-12" aria-hidden="true" tabindex="-1"></a>  | i, Zero ps -&gt;                             <span class="co">(* Random-Access lookup works *)</span></span>
<span id="cb116-13"><a href="#cb116-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> x, y = lookup (i / <span class="dv">2</span>) ps <span class="kw">in</span>         <span class="co">(* in logarithmic time -- much faster than *)</span></span>
<span id="cb116-14"><a href="#cb116-14" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> i <span class="kw">mod</span> <span class="dv">2</span> = <span class="dv">0</span> <span class="kw">then</span> x <span class="kw">else</span> y            <span class="co">(* in standard lists. *)</span></span></code></pre></div>
<h3 id="algebraic-specification">5.4 Algebraic Specification</h3>
<p>The way we introduce a data structure, like complex numbers or
strings, in mathematics is by specifying an <em>algebraic
structure</em>.</p>
<p>Algebraic structures consist of a set (or several sets, for so-called
<em>multisorted</em> algebras) and a bunch of functions (also known as
operations) over this set (or sets).</p>
<p>A <em>signature</em> is a rough description of an algebraic
structure: it provides <em>sorts</em> – names for the sets (in the
multisorted case) – and names of the functions-operations together with
their arity (and what sorts of arguments they take).</p>
<p>We select a class of algebraic structures by providing axioms that
have to hold. We will call such classes <em>algebraic
specifications</em>. In mathematics, a rusty name for some algebraic
specifications is a <em>variety</em>; a more modern name is
<em>algebraic category</em>.</p>
<p>Algebraic structures correspond to “implementations” and signatures
to “interfaces” in programming languages. We will say that an algebraic
structure <em>implements</em> an algebraic specification when all axioms
of the specification hold in the structure. All algebraic specifications
are implemented by multiple structures!</p>
<p>We say that an algebraic structure does not have <em>junk</em> when
all its elements (i.e., elements in the sets corresponding to sorts) can
be built using operations in its signature.</p>
<p>We allow parametric types as sorts. In that case, strictly speaking,
we define a family of algebraic specifications (a different
specification for each instantiation of the parametric type).</p>
<h4 id="algebraic-specifications-examples">5.4.1 Algebraic
Specifications: Examples</h4>
<p>An algebraic specification can also use an earlier specification. In
“impure” languages like OCaml and F# we allow that the result of any
operation be an <span class="math inline">\text{error}</span>. In
Haskell we could use <code>Maybe</code>.</p>
<p><strong>Specification <span class="math inline">\text{nat}_p</span>
(bounded natural numbers):</strong></p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr>
<th><span class="math inline">\text{nat}_p</span></th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">0 : \text{nat}_p</span></td>
</tr>
<tr>
<td><span class="math inline">\text{succ} : \text{nat}_p \rightarrow
\text{nat}_p</span></td>
</tr>
<tr>
<td><span class="math inline">+ : \text{nat}_p \rightarrow \text{nat}_p
\rightarrow \text{nat}_p</span></td>
</tr>
<tr>
<td><span class="math inline">* : \text{nat}_p \rightarrow \text{nat}_p
\rightarrow \text{nat}_p</span></td>
</tr>
<tr>
<td>Variables: <span class="math inline">n, m : \text{nat}_p</span></td>
</tr>
<tr>
<td>Axioms:</td>
</tr>
<tr>
<td><span class="math inline">0 + n = n</span>, <span
class="math inline">n + 0 = n</span></td>
</tr>
<tr>
<td><span class="math inline">m + \text{succ}(n) = \text{succ}(m +
n)</span></td>
</tr>
<tr>
<td><span class="math inline">0 * n = 0</span>, <span
class="math inline">n * 0 = 0</span></td>
</tr>
<tr>
<td><span class="math inline">m * \text{succ}(n) = m + (m *
n)</span></td>
</tr>
<tr>
<td><span
class="math inline">\underbrace{\text{succ}(\ldots\text{succ}(0))}_{\text{less
than } p \text{ times}} \neq 0</span></td>
</tr>
<tr>
<td><span
class="math inline">\underbrace{\text{succ}(\ldots\text{succ}(0))}_{p
\text{ times}} = 0</span></td>
</tr>
</tbody>
</table>
<p><strong>Specification <span
class="math inline">\text{string}_p</span> (bounded
strings):</strong></p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr>
<th><span class="math inline">\text{string}_p</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>uses <span class="math inline">\text{char}</span>, <span
class="math inline">\text{nat}_p</span></td>
</tr>
<tr>
<td><code>""</code> <span class="math inline">:
\text{string}_p</span></td>
</tr>
<tr>
<td><code>"c"</code> <span class="math inline">: \text{char} \rightarrow
\text{string}_p</span></td>
</tr>
<tr>
<td><span class="math inline">\hat{\ } : \text{string}_p \rightarrow
\text{string}_p \rightarrow \text{string}_p</span></td>
</tr>
<tr>
<td><span class="math inline">\cdot[\cdot] : \text{string}_p \rightarrow
\text{nat}_p \rightarrow \text{char}</span></td>
</tr>
<tr>
<td>Variables: <span class="math inline">s : \text{string}_p</span>,
<span class="math inline">c, c_1, \ldots, c_p : \text{char}</span>,
<span class="math inline">n : \text{nat}_p</span></td>
</tr>
<tr>
<td>Axioms:</td>
</tr>
<tr>
<td><code>""</code> <span class="math inline">\hat{\ } s = s</span>,
<span class="math inline">s \hat{\ }</span> <code>""</code> <span
class="math inline">= s</span></td>
</tr>
<tr>
<td><span class="math inline">\underbrace{\text{``}c_1\text{&#39;&#39;}
\hat{\ } (\ldots \hat{\ } \text{``}c_p\text{&#39;&#39;})}_{p \text{
times}} = \text{error}</span></td>
</tr>
<tr>
<td><span class="math inline">r \hat{\ } (s \hat{\ } t) = (r \hat{\ } s)
\hat{\ } t</span></td>
</tr>
<tr>
<td><span class="math inline">(\text{``}c\text{&#39;&#39;} \hat{\ }
s)[0] = c</span></td>
</tr>
<tr>
<td><span class="math inline">(\text{``}c\text{&#39;&#39;} \hat{\ }
s)[\text{succ}(n)] = s[n]</span></td>
</tr>
<tr>
<td><code>""</code><span class="math inline">[n] =
\text{error}</span></td>
</tr>
</tbody>
</table>
<h3 id="homomorphisms">5.5 Homomorphisms</h3>
<p>Homomorphisms are mappings between algebraic structures with the same
signature that preserve operations.</p>
<p>A <em>homomorphism</em> from algebraic structure <span
class="math inline">(A, \{f^A, g^A, \ldots\})</span> to <span
class="math inline">(B, \{f^B, g^B, \ldots\})</span> is a function <span
class="math inline">h : A \rightarrow B</span> such that: - <span
class="math inline">h(f^A(a_1, \ldots, a_{n_f})) = f^B(h(a_1), \ldots,
h(a_{n_f}))</span> for all <span class="math inline">(a_1, \ldots,
a_{n_f})</span> - <span class="math inline">h(g^A(a_1, \ldots, a_{n_g}))
= g^B(h(a_1), \ldots, h(a_{n_g}))</span> for all <span
class="math inline">(a_1, \ldots, a_{n_g})</span> - and so on for all
operations.</p>
<p>Two algebraic structures are <em>isomorphic</em> if there are
homomorphisms <span class="math inline">h_1 : A \rightarrow B</span>,
<span class="math inline">h_2 : B \rightarrow A</span> from one to the
other and back, that when composed in any order form identity: <span
class="math inline">\forall (b \in B) \ h_1(h_2(b)) = b</span> and <span
class="math inline">\forall (a \in A) \ h_2(h_1(a)) = a</span>.</p>
<p>An algebraic specification whose all implementations without junk are
isomorphic is called “<em>monomorphic</em>”. We usually only add axioms
that really matter to us to the specification, so that the
implementations have room for optimization. For this reason, the
resulting specifications will often not be monomorphic in the above
sense.</p>
<h3 id="example-maps">5.6 Example: Maps</h3>
<p>A <em>map</em> (also called dictionary or associative array)
associates keys with values. Here is an algebraic specification:</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr>
<th><span class="math inline">(\alpha, \beta) \ \text{map}</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>uses <span class="math inline">\text{bool}</span>, type parameters
<span class="math inline">\alpha, \beta</span></td>
</tr>
<tr>
<td><span class="math inline">\text{empty} : (\alpha, \beta) \
\text{map}</span></td>
</tr>
<tr>
<td><span class="math inline">\text{member} : \alpha \rightarrow
(\alpha, \beta) \ \text{map} \rightarrow \text{bool}</span></td>
</tr>
<tr>
<td><span class="math inline">\text{add} : \alpha \rightarrow \beta
\rightarrow (\alpha, \beta) \ \text{map} \rightarrow (\alpha, \beta) \
\text{map}</span></td>
</tr>
<tr>
<td><span class="math inline">\text{remove} : \alpha \rightarrow
(\alpha, \beta) \ \text{map} \rightarrow (\alpha, \beta) \
\text{map}</span></td>
</tr>
<tr>
<td><span class="math inline">\text{find} : \alpha \rightarrow (\alpha,
\beta) \ \text{map} \rightarrow \beta</span></td>
</tr>
<tr>
<td>Variables: <span class="math inline">k, k_2 : \alpha</span>, <span
class="math inline">v, v_2 : \beta</span>, <span class="math inline">m :
(\alpha, \beta) \ \text{map}</span></td>
</tr>
<tr>
<td>Axioms:</td>
</tr>
<tr>
<td><span class="math inline">\text{member}(k, \text{add}(k, v, m)) =
\text{true}</span></td>
</tr>
<tr>
<td><span class="math inline">\text{member}(k, \text{remove}(k, m)) =
\text{false}</span></td>
</tr>
<tr>
<td><span class="math inline">\text{member}(k, \text{add}(k_2, v, m)) =
\text{true} \wedge k \neq k_2 \Leftrightarrow \text{member}(k, m) =
\text{true} \wedge k \neq k_2</span></td>
</tr>
<tr>
<td><span class="math inline">\text{member}(k, \text{remove}(k_2, m)) =
\text{true} \wedge k \neq k_2 \Leftrightarrow \text{member}(k, m) =
\text{true} \wedge k \neq k_2</span></td>
</tr>
<tr>
<td><span class="math inline">\text{find}(k, \text{add}(k, v, m)) =
v</span></td>
</tr>
<tr>
<td><span class="math inline">\text{find}(k, \text{remove}(k, m)) =
\text{error}</span>, <span class="math inline">\text{find}(k,
\text{empty}) = \text{error}</span></td>
</tr>
<tr>
<td><span class="math inline">\text{find}(k, \text{add}(k_2, v_2, m)) =
v \wedge k \neq k_2 \Leftrightarrow \text{find}(k, m) = v \wedge k \neq
k_2</span></td>
</tr>
<tr>
<td><span class="math inline">\text{find}(k, \text{remove}(k_2, m)) = v
\wedge k \neq k_2 \Leftrightarrow \text{find}(k, m) = v \wedge k \neq
k_2</span></td>
</tr>
<tr>
<td><span class="math inline">\text{remove}(k, \text{empty}) =
\text{empty}</span></td>
</tr>
</tbody>
</table>
<h3 id="modules-and-interfaces-signatures-syntax">5.7 Modules and
Interfaces (Signatures): Syntax</h3>
<p>In the ML family of languages, structures are given names by
<strong>module</strong> bindings, and signatures are types of modules.
From outside of a structure or signature, we refer to the values or
types it provides with a dot notation: <code>Module.value</code>.</p>
<p>Module (and module type) names have to start with a capital letter
(in ML languages). Since modules and module types have names, there is a
tradition to name the central type of a signature (the one that is
“specified” by the signature), for brevity, <code>t</code>. Module types
are often named with “all-caps” (all letters upper case).</p>
<div class="sourceCode" id="cb117"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">type</span> MAP = <span class="kw">sig</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> (&#39;a, &#39;b) t</span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> empty : (&#39;a, &#39;b) t</span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> member : &#39;a -&gt; (&#39;a, &#39;b) t -&gt; <span class="dt">bool</span></span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> add : &#39;a -&gt; &#39;b -&gt; (&#39;a, &#39;b) t -&gt; (&#39;a, &#39;b) t</span>
<span id="cb117-6"><a href="#cb117-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> remove : &#39;a -&gt; (&#39;a, &#39;b) t -&gt; (&#39;a, &#39;b) t</span>
<span id="cb117-7"><a href="#cb117-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> find : &#39;a -&gt; (&#39;a, &#39;b) t -&gt; &#39;b</span>
<span id="cb117-8"><a href="#cb117-8" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb117-9"><a href="#cb117-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-10"><a href="#cb117-10" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> ListMap : MAP = <span class="kw">struct</span></span>
<span id="cb117-11"><a href="#cb117-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> (&#39;a, &#39;b) t = (&#39;a * &#39;b) <span class="dt">list</span></span>
<span id="cb117-12"><a href="#cb117-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> empty = []</span>
<span id="cb117-13"><a href="#cb117-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> member = <span class="dt">List</span>.mem_assoc</span>
<span id="cb117-14"><a href="#cb117-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> add k v m = (k, v)::m</span>
<span id="cb117-15"><a href="#cb117-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> remove = <span class="dt">List</span>.remove_assoc</span>
<span id="cb117-16"><a href="#cb117-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> find = <span class="dt">List</span>.assoc</span>
<span id="cb117-17"><a href="#cb117-17" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<h3 id="implementing-maps-association-lists">5.8 Implementing Maps:
Association Lists</h3>
<p>Let us now build an implementation of maps from the ground up. The
most straightforward implementation… might not be what you expected:</p>
<div class="sourceCode" id="cb118"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> TrivialMap : MAP = <span class="kw">struct</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> (&#39;a, &#39;b) t =</span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>    | Empty</span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a>    | Add <span class="kw">of</span> &#39;a * &#39;b * (&#39;a, &#39;b) t</span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a>    | Remove <span class="kw">of</span> &#39;a * (&#39;a, &#39;b) t</span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> empty = Empty</span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-9"><a href="#cb118-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> member k m =</span>
<span id="cb118-10"><a href="#cb118-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb118-11"><a href="#cb118-11" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="kw">false</span></span>
<span id="cb118-12"><a href="#cb118-12" aria-hidden="true" tabindex="-1"></a>    | Add (k2, _, _) <span class="kw">when</span> k = k2 -&gt; <span class="kw">true</span></span>
<span id="cb118-13"><a href="#cb118-13" aria-hidden="true" tabindex="-1"></a>    | Remove (k2, _) <span class="kw">when</span> k = k2 -&gt; <span class="kw">false</span></span>
<span id="cb118-14"><a href="#cb118-14" aria-hidden="true" tabindex="-1"></a>    | Add (_, _, m2) -&gt; member k m2</span>
<span id="cb118-15"><a href="#cb118-15" aria-hidden="true" tabindex="-1"></a>    | Remove (_, m2) -&gt; member k m2</span>
<span id="cb118-16"><a href="#cb118-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-17"><a href="#cb118-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> add k v m = Add (k, v, m)</span>
<span id="cb118-18"><a href="#cb118-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> remove k m = Remove (k, m)</span>
<span id="cb118-19"><a href="#cb118-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-20"><a href="#cb118-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> find k m =</span>
<span id="cb118-21"><a href="#cb118-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb118-22"><a href="#cb118-22" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="dt">raise</span> <span class="dt">Not_found</span></span>
<span id="cb118-23"><a href="#cb118-23" aria-hidden="true" tabindex="-1"></a>    | Add (k2, v, _) <span class="kw">when</span> k = k2 -&gt; v</span>
<span id="cb118-24"><a href="#cb118-24" aria-hidden="true" tabindex="-1"></a>    | Remove (k2, _) <span class="kw">when</span> k = k2 -&gt; <span class="dt">raise</span> <span class="dt">Not_found</span></span>
<span id="cb118-25"><a href="#cb118-25" aria-hidden="true" tabindex="-1"></a>    | Add (_, _, m2) -&gt; find k m2</span>
<span id="cb118-26"><a href="#cb118-26" aria-hidden="true" tabindex="-1"></a>    | Remove (_, m2) -&gt; find k m2</span>
<span id="cb118-27"><a href="#cb118-27" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>This “trivial” implementation simply records all operations as a log.
The <code>add</code> and <code>remove</code> operations are <span
class="math inline">O(1)</span>, but <code>member</code> and
<code>find</code> must traverse the entire history.</p>
<p>Here is an implementation based on association lists, i.e., on lists
of key-value pairs:</p>
<div class="sourceCode" id="cb119"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> MyListMap : MAP = <span class="kw">struct</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> (&#39;a, &#39;b) t = Empty | Add <span class="kw">of</span> &#39;a * &#39;b * (&#39;a, &#39;b) t</span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> empty = Empty</span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> member k m =</span>
<span id="cb119-7"><a href="#cb119-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb119-8"><a href="#cb119-8" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="kw">false</span></span>
<span id="cb119-9"><a href="#cb119-9" aria-hidden="true" tabindex="-1"></a>    | Add (k2, _, _) <span class="kw">when</span> k = k2 -&gt; <span class="kw">true</span></span>
<span id="cb119-10"><a href="#cb119-10" aria-hidden="true" tabindex="-1"></a>    | Add (_, _, m2) -&gt; member k m2</span>
<span id="cb119-11"><a href="#cb119-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-12"><a href="#cb119-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> add k v m =</span>
<span id="cb119-13"><a href="#cb119-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb119-14"><a href="#cb119-14" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; Add (k, v, Empty)</span>
<span id="cb119-15"><a href="#cb119-15" aria-hidden="true" tabindex="-1"></a>    | Add (k2, _, m) <span class="kw">when</span> k = k2 -&gt; Add (k, v, m)</span>
<span id="cb119-16"><a href="#cb119-16" aria-hidden="true" tabindex="-1"></a>    | Add (k2, v2, m) -&gt; Add (k2, v2, add k v m)</span>
<span id="cb119-17"><a href="#cb119-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-18"><a href="#cb119-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> remove k m =</span>
<span id="cb119-19"><a href="#cb119-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb119-20"><a href="#cb119-20" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; Empty</span>
<span id="cb119-21"><a href="#cb119-21" aria-hidden="true" tabindex="-1"></a>    | Add (k2, _, m) <span class="kw">when</span> k = k2 -&gt; m</span>
<span id="cb119-22"><a href="#cb119-22" aria-hidden="true" tabindex="-1"></a>    | Add (k2, v, m) -&gt; Add (k2, v, remove k m)</span>
<span id="cb119-23"><a href="#cb119-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-24"><a href="#cb119-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> find k m =</span>
<span id="cb119-25"><a href="#cb119-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb119-26"><a href="#cb119-26" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="dt">raise</span> <span class="dt">Not_found</span></span>
<span id="cb119-27"><a href="#cb119-27" aria-hidden="true" tabindex="-1"></a>    | Add (k2, v, _) <span class="kw">when</span> k = k2 -&gt; v</span>
<span id="cb119-28"><a href="#cb119-28" aria-hidden="true" tabindex="-1"></a>    | Add (_, _, m2) -&gt; find k m2</span>
<span id="cb119-29"><a href="#cb119-29" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<h3 id="implementing-maps-binary-search-trees">5.9 Implementing Maps:
Binary Search Trees</h3>
<p>Binary search trees are binary trees with elements stored at the
interior nodes, such that elements to the left of a node are smaller
than, and elements to the right bigger than, elements within a node.</p>
<p>For maps, we store key-value pairs as elements in binary search
trees, and compare the elements by keys alone.</p>
<p>On average, binary search trees are fast because they use
“divide-and-conquer” to search for the value associated with a key
(<span class="math inline">O(\log n)</span> complexity). In the worst
case, however, they reduce to association lists.</p>
<p>The simple polymorphic signature for maps is only possible with
implementations based on some total order of keys because OCaml has
polymorphic comparison (and equality) operators. These operators work on
elements of most types, but not on functions. They may not work in a way
you would want though! Our signature for polymorphic maps is not the
standard approach because of the problem of needing the order of keys;
it is just to keep things simple.</p>
<div class="sourceCode" id="cb120"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> BTreeMap : MAP = <span class="kw">struct</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> (&#39;a, &#39;b) t = Empty | T <span class="kw">of</span> (&#39;a, &#39;b) t * &#39;a * &#39;b * (&#39;a, &#39;b) t</span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> empty = Empty</span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> member k m =                           <span class="co">(* &quot;Divide and conquer&quot; search through the tree. *)</span></span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="kw">false</span></span>
<span id="cb120-9"><a href="#cb120-9" aria-hidden="true" tabindex="-1"></a>    | T (_, k2, _, _) <span class="kw">when</span> k = k2 -&gt; <span class="kw">true</span></span>
<span id="cb120-10"><a href="#cb120-10" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, _, _) <span class="kw">when</span> k &lt; k2 -&gt; member k m1</span>
<span id="cb120-11"><a href="#cb120-11" aria-hidden="true" tabindex="-1"></a>    | T (_, _, _, m2) -&gt; member k m2</span>
<span id="cb120-12"><a href="#cb120-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-13"><a href="#cb120-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> add k v m =                            <span class="co">(* Searches the tree in the same way as member *)</span></span>
<span id="cb120-14"><a href="#cb120-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span>                                 <span class="co">(* but copies every node along the way. *)</span></span>
<span id="cb120-15"><a href="#cb120-15" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; T (Empty, k, v, Empty)</span>
<span id="cb120-16"><a href="#cb120-16" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, _, m2) <span class="kw">when</span> k = k2 -&gt; T (m1, k, v, m2)</span>
<span id="cb120-17"><a href="#cb120-17" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, v2, m2) <span class="kw">when</span> k &lt; k2 -&gt; T (add k v m1, k2, v2, m2)</span>
<span id="cb120-18"><a href="#cb120-18" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, v2, m2) -&gt; T (m1, k2, v2, add k v m2)</span>
<span id="cb120-19"><a href="#cb120-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-20"><a href="#cb120-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> split_rightmost m =                    <span class="co">(* A helper function, it does not belong *)</span></span>
<span id="cb120-21"><a href="#cb120-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span>                                 <span class="co">(* to the &quot;exported&quot; signature. *)</span></span>
<span id="cb120-22"><a href="#cb120-22" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="dt">raise</span> <span class="dt">Not_found</span></span>
<span id="cb120-23"><a href="#cb120-23" aria-hidden="true" tabindex="-1"></a>    | T (Empty, k, v, Empty) -&gt; k, v, Empty      <span class="co">(* We remove one element, *)</span></span>
<span id="cb120-24"><a href="#cb120-24" aria-hidden="true" tabindex="-1"></a>    | T (m1, k, v, m2) -&gt;                        <span class="co">(* the one that is on the bottom right. *)</span></span>
<span id="cb120-25"><a href="#cb120-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> rk, rv, rm = split_rightmost m2 <span class="kw">in</span></span>
<span id="cb120-26"><a href="#cb120-26" aria-hidden="true" tabindex="-1"></a>        rk, rv, T (m1, k, v, rm)</span>
<span id="cb120-27"><a href="#cb120-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-28"><a href="#cb120-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> remove k m =</span>
<span id="cb120-29"><a href="#cb120-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb120-30"><a href="#cb120-30" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; Empty</span>
<span id="cb120-31"><a href="#cb120-31" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, _, Empty) <span class="kw">when</span> k = k2 -&gt; m1</span>
<span id="cb120-32"><a href="#cb120-32" aria-hidden="true" tabindex="-1"></a>    | T (Empty, k2, _, m2) <span class="kw">when</span> k = k2 -&gt; m2</span>
<span id="cb120-33"><a href="#cb120-33" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, _, m2) <span class="kw">when</span> k = k2 -&gt;</span>
<span id="cb120-34"><a href="#cb120-34" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> rk, rv, rm = split_rightmost m1 <span class="kw">in</span></span>
<span id="cb120-35"><a href="#cb120-35" aria-hidden="true" tabindex="-1"></a>        T (rm, rk, rv, m2)</span>
<span id="cb120-36"><a href="#cb120-36" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, v, m2) <span class="kw">when</span> k &lt; k2 -&gt; T (remove k m1, k2, v, m2)</span>
<span id="cb120-37"><a href="#cb120-37" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, v, m2) -&gt; T (m1, k2, v, remove k m2)</span>
<span id="cb120-38"><a href="#cb120-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-39"><a href="#cb120-39" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> find k m =</span>
<span id="cb120-40"><a href="#cb120-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb120-41"><a href="#cb120-41" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="dt">raise</span> <span class="dt">Not_found</span></span>
<span id="cb120-42"><a href="#cb120-42" aria-hidden="true" tabindex="-1"></a>    | T (_, k2, v, _) <span class="kw">when</span> k = k2 -&gt; v</span>
<span id="cb120-43"><a href="#cb120-43" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, _, _) <span class="kw">when</span> k &lt; k2 -&gt; find k m1</span>
<span id="cb120-44"><a href="#cb120-44" aria-hidden="true" tabindex="-1"></a>    | T (_, _, _, m2) -&gt; find k m2</span>
<span id="cb120-45"><a href="#cb120-45" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<h3 id="implementing-maps-red-black-trees">5.10 Implementing Maps:
Red-Black Trees</h3>
<p>This section is based on Wikipedia’s <a
href="http://en.wikipedia.org/wiki/Red-black_tree">Red-black tree
article</a>, Chris Okasaki’s “Purely Functional Data Structures” and
Matt Might’s excellent blog post on <a
href="http://matt.might.net/articles/red-black-delete/">red-black tree
deletion</a>.</p>
<p>Binary search trees are good when we encounter keys in random order,
because the cost of operations is limited by the depth of the tree which
is small relative to the number of nodes… unless the tree grows
unbalanced achieving large depth (which means there are sibling subtrees
of vastly different sizes on some path).</p>
<p>To remedy this, we <em>rebalance</em> the tree while building it –
i.e., while adding elements.</p>
<p>In <em>red-black trees</em> we achieve balance by: 1. Remembering one
of two colors with each node 2. Keeping the same length of each
root-to-leaf path if only black nodes are counted 3. Not allowing a red
node to have a red child</p>
<p>This way the depth is at most twice the depth of a perfectly balanced
tree with the same number of nodes.</p>
<h4 id="b-trees-of-order-4-2-3-4-trees">5.10.1 B-trees of Order 4 (2-3-4
Trees)</h4>
<p>How can we have perfectly balanced trees without worrying about
having <span class="math inline">2^k - 1</span> elements? <strong>2-3-4
trees</strong> can store from 1 to 3 elements in each node and have 2 to
4 subtrees correspondingly. Lots of freedom!</p>
<p>A 2-node contains one element and has two children. A 3-node contains
two elements and has three children. A 4-node contains three elements
and has four children.</p>
<p>To insert “25” into a 2-3-4 tree, we descend right, but if we
encounter a full node (4-node), we move the middle element up and split
the remaining elements. This maintains balance at all times.</p>
<p>To represent a 2-3-4 tree as a binary tree with one element per node,
we color the middle element of a 4-node, or the first element of a
2-/3-node, black and make it the parent of its neighbor elements, and
make them parents of the original subtrees. This correspondence provides
the intuition behind red-black trees.</p>
<h4 id="red-black-trees-without-deletion">5.10.2 Red-Black Trees,
Without Deletion</h4>
<p>Red-black trees maintain two invariants:</p>
<p><strong>Invariant 1.</strong> No red node has a red child.</p>
<p><strong>Invariant 2.</strong> Every path from the root to an empty
node contains the same number of black nodes.</p>
<p>First we implement red-black tree based sets without deletion. The
implementation proceeds almost exactly like for unbalanced binary search
trees; we only need to restore invariants.</p>
<p>By keeping balance at each step of constructing a node, it is enough
to check locally (around the root of the subtree). For an understandable
implementation of deletion, we need to introduce more colors – see Matt
Might’s post.</p>
<div class="sourceCode" id="cb121"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> color = R | B</span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a t = E | T <span class="kw">of</span> color * &#39;a t * &#39;a * &#39;a t</span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> empty = E</span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> member x m =                           <span class="co">(* Like in unbalanced binary search tree. *)</span></span>
<span id="cb121-7"><a href="#cb121-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb121-8"><a href="#cb121-8" aria-hidden="true" tabindex="-1"></a>  | E -&gt; <span class="kw">false</span></span>
<span id="cb121-9"><a href="#cb121-9" aria-hidden="true" tabindex="-1"></a>  | T (_, _, y, _) <span class="kw">when</span> x = y -&gt; <span class="kw">true</span></span>
<span id="cb121-10"><a href="#cb121-10" aria-hidden="true" tabindex="-1"></a>  | T (_, a, y, _) <span class="kw">when</span> x &lt; y -&gt; member x a</span>
<span id="cb121-11"><a href="#cb121-11" aria-hidden="true" tabindex="-1"></a>  | T (_, _, _, b) -&gt; member x b</span>
<span id="cb121-12"><a href="#cb121-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-13"><a href="#cb121-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> balance = <span class="kw">function</span>                         <span class="co">(* Restoring the invariants. *)</span></span>
<span id="cb121-14"><a href="#cb121-14" aria-hidden="true" tabindex="-1"></a>  | B, T (R, T (R,a,x,b), y, c), z, d          <span class="co">(* On next figure: left, *)</span></span>
<span id="cb121-15"><a href="#cb121-15" aria-hidden="true" tabindex="-1"></a>  | B, T (R, a, x, T (R,b,y,c)), z, d          <span class="co">(* top, *)</span></span>
<span id="cb121-16"><a href="#cb121-16" aria-hidden="true" tabindex="-1"></a>  | B, a, x, T (R, T (R,b,y,c), z, d)          <span class="co">(* bottom, *)</span></span>
<span id="cb121-17"><a href="#cb121-17" aria-hidden="true" tabindex="-1"></a>  | B, a, x, T (R, b, y, T (R,c,z,d))          <span class="co">(* right, *)</span></span>
<span id="cb121-18"><a href="#cb121-18" aria-hidden="true" tabindex="-1"></a>      -&gt; T (R, T (B,a,x,b), y, T (B,c,z,d))    <span class="co">(* center tree. *)</span></span>
<span id="cb121-19"><a href="#cb121-19" aria-hidden="true" tabindex="-1"></a>  | color, a, x, b -&gt; T (color, a, x, b)       <span class="co">(* We allow red-red violation for now. *)</span></span>
<span id="cb121-20"><a href="#cb121-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-21"><a href="#cb121-21" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> insert x s =</span>
<span id="cb121-22"><a href="#cb121-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> ins = <span class="kw">function</span>                       <span class="co">(* Like in unbalanced binary search tree, *)</span></span>
<span id="cb121-23"><a href="#cb121-23" aria-hidden="true" tabindex="-1"></a>    | E -&gt; T (R, E, x, E)                      <span class="co">(* but fix violation above created node. *)</span></span>
<span id="cb121-24"><a href="#cb121-24" aria-hidden="true" tabindex="-1"></a>    | T (color, a, y, b) <span class="kw">as</span> s -&gt;</span>
<span id="cb121-25"><a href="#cb121-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> x &lt; y <span class="kw">then</span> balance (color, ins a, y, b)</span>
<span id="cb121-26"><a href="#cb121-26" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="kw">if</span> x &gt; y <span class="kw">then</span> balance (color, a, y, ins b)</span>
<span id="cb121-27"><a href="#cb121-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> s</span>
<span id="cb121-28"><a href="#cb121-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb121-29"><a href="#cb121-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> ins s <span class="kw">with</span>                             <span class="co">(* We could still have red-red violation at root, *)</span></span>
<span id="cb121-30"><a href="#cb121-30" aria-hidden="true" tabindex="-1"></a>  | T (_, a, y, b) -&gt; T (B, a, y, b)           <span class="co">(* fixed by coloring it black. *)</span></span>
<span id="cb121-31"><a href="#cb121-31" aria-hidden="true" tabindex="-1"></a>  | E -&gt; <span class="dt">failwith</span> <span class="st">&quot;insert: impossible&quot;</span></span></code></pre></div>
<p>The <code>balance</code> function handles four cases where a red-red
violation occurs (a red node with a red child). In each case, we
restructure the tree to eliminate the violation while maintaining the
binary search tree property. All four cases produce the same balanced
result: a red root with two black children.</p>
<h3 id="exercises-4">Exercises</h3>
<p><strong>Exercise 1.</strong> Derive the equations and solve them to
find the type for:</p>
<div class="sourceCode" id="cb122"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cadr l = <span class="dt">List</span>.hd (<span class="dt">List</span>.tl l) <span class="kw">in</span> cadr (<span class="dv">1</span>::<span class="dv">2</span>::[]), cadr (<span class="kw">true</span>::<span class="kw">false</span>::[])</span></code></pre></div>
<p>in environment <span class="math inline">\Gamma = \{ \text{List.hd} :
\forall \alpha . \alpha \ \text{list} \rightarrow \alpha ;
\text{List.tl} : \forall \alpha . \alpha \ \text{list} \rightarrow
\alpha \ \text{list} \}</span>. You can take “shortcuts” if it is too
many equations to write down.</p>
<p><strong>Exercise 2.</strong> <em>Terms</em> <span
class="math inline">t_1, t_2, \ldots \in T(\Sigma, X)</span> are built
out of variables <span class="math inline">x, y, \ldots \in X</span> and
function symbols <span class="math inline">f, g, \ldots \in
\Sigma</span> the way you build values out of functions:</p>
<ul>
<li><span class="math inline">X \subset T(\Sigma, X)</span> – variables
are terms; usually an infinite set,</li>
<li>for terms <span class="math inline">t_1, \ldots, t_n \in T(\Sigma,
X)</span> and a function symbol <span class="math inline">f \in
\Sigma_n</span> of arity <span class="math inline">n</span>, <span
class="math inline">f(t_1, \ldots, t_n) \in T(\Sigma, X)</span> – bigger
terms arise from applying function symbols to smaller terms; <span
class="math inline">\Sigma = \dot{\cup}_n \Sigma_n</span> is called a
signature.</li>
</ul>
<p>In OCaml, we can define terms as:
<code>type term = V of string | T of string * term list</code>, where
for example <code>V("x")</code> is a variable <span
class="math inline">x</span> and <code>T("f", [V("x"); V("y")])</code>
is the term <span class="math inline">f(x, y)</span>.</p>
<p>By <em>substitutions</em> <span class="math inline">\sigma, \rho,
\ldots</span> we mean finite sets of variable-term pairs which we can
write as <span class="math inline">\{x_1 \mapsto t_1, \ldots, x_k
\mapsto t_k\}</span> or <span class="math inline">[x_1 := t_1; \ldots;
x_k := t_k]</span>, but also functions from terms to terms <span
class="math inline">\sigma : T(\Sigma, X) \rightarrow T(\Sigma,
X)</span> related to the pairs as follows: if <span
class="math inline">\sigma = \{x_1 \mapsto t_1, \ldots, x_k \mapsto
t_k\}</span>, then</p>
<ul>
<li><span class="math inline">\sigma(x_i) = t_i</span> for <span
class="math inline">x_i \in \{x_1, \ldots, x_k\}</span>,</li>
<li><span class="math inline">\sigma(x) = x</span> for <span
class="math inline">x \in X \setminus \{x_1, \ldots, x_k\}</span>,</li>
<li><span class="math inline">\sigma(f(t_1, \ldots, t_n)) =
f(\sigma(t_1), \ldots, \sigma(t_n))</span>.</li>
</ul>
<p>In OCaml, we can define substitutions <span
class="math inline">\sigma</span> as:
<code>type subst = (string * term) list</code>, together with a function
<code>apply : subst -&gt; term -&gt; term</code> which computes <span
class="math inline">\sigma(\cdot)</span>.</p>
<p>We say that a substitution <span class="math inline">\sigma</span> is
<em>more general</em> than all substitutions <span
class="math inline">\rho \circ \sigma</span>, where <span
class="math inline">(\rho \circ \sigma)(x) = \rho(\sigma(x))</span>. In
type inference, we are interested in most general solutions.</p>
<p>A <em>unification problem</em> is a finite set of equations <span
class="math inline">S = \{s_1 =^? t_1, \ldots, s_n =^? t_n\}</span>. A
solution, or <em>unifier</em> of <span class="math inline">S</span>, is
a substitution <span class="math inline">\sigma</span> such that <span
class="math inline">\sigma(s_i) = \sigma(t_i)</span> for <span
class="math inline">i = 1, \ldots, n</span>. A <em>most general
unifier</em>, or <em>MGU</em>, is a most general such substitution.</p>
<ol type="1">
<li><p>Implement an algorithm that, given a set of equations represented
as a list of pairs of terms, computes an idempotent most general unifier
of the equations.</p></li>
<li><p>(Ex. 4.22 in Franz Baader and Tobias Nipkow “Term Rewriting and
All That”, p. 82.) Modify the implementation of unification to achieve
linear space complexity by working with what could be called iterated
substitutions.</p></li>
</ol>
<p><strong>Exercise 3.</strong></p>
<ol type="1">
<li>What does it mean that an implementation has junk (as an algebraic
structure for a given signature)? Is it bad?</li>
<li>Define a monomorphic algebraic specification (other than, but
similar to, <span class="math inline">\text{nat}_p</span> or <span
class="math inline">\text{string}_p</span>, some useful data type).</li>
<li>Discuss an example of a (monomorphic) algebraic specification where
it would be useful to drop some axioms (giving up monomorphicity) to
allow more efficient implementations.</li>
</ol>
<p><strong>Exercise 4.</strong></p>
<ol type="1">
<li><p>Does the example <code>ListMap</code> meet the requirements of
the algebraic specification for maps? Hint: here is the definition of
<code>List.remove_assoc</code>; <code>compare a x</code> equals
<code>0</code> if and only if <code>a = x</code>.</p>
<div class="sourceCode" id="cb123"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> remove_assoc x = <span class="kw">function</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; []</span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>  | (a, b <span class="kw">as</span> pair) :: l -&gt;</span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> <span class="dt">compare</span> a x = <span class="dv">0</span> <span class="kw">then</span> l <span class="kw">else</span> pair :: remove_assoc x l</span></code></pre></div></li>
<li><p>Trick question: what is the computational complexity of
<code>ListMap</code> or <code>TrivialMap</code>?</p></li>
<li><p>(*) The implementation <code>MyListMap</code> is inefficient: it
performs a lot of copying and is not tail-recursive. Optimize it
(without changing the type definition).</p></li>
<li><p>Add (and specify) <span class="math inline">\text{isEmpty} :
(\alpha, \beta) \ \text{map} \rightarrow \text{bool}</span> to the
example algebraic specification of maps without increasing the burden on
its implementations. Hint: equational reasoning might be not enough;
consider an equivalence relation <span
class="math inline">\approx</span> meaning “have the same
keys”.</p></li>
</ol>
<p><strong>Exercise 5.</strong> Design an algebraic specification and
write a signature for first-in-first-out queues. Provide two
implementations: one straightforward using a list, and another one using
two lists: one for freshly added elements providing efficient queueing
of new elements, and “reversed” one for efficient popping of old
elements.</p>
<p><strong>Exercise 6.</strong> Design an algebraic specification and
write a signature for sets. Provide two implementations: one
straightforward using a list, and another one using a map into the unit
type.</p>
<p><strong>Exercise 7.</strong></p>
<ol type="1">
<li><p>(Ex. 2.2 in Chris Okasaki “Purely Functional Data Structures”) In
the worst case, <code>member</code> performs approximately <span
class="math inline">2d</span> comparisons, where <span
class="math inline">d</span> is the depth of the tree. Rewrite
<code>member</code> to take no more than <span class="math inline">d +
1</span> comparisons by keeping track of a candidate element that
<em>might</em> be equal to the query element (say, the last element for
which <span class="math inline">&lt;</span> returned false) and checking
for equality only when you hit the bottom of the tree.</p></li>
<li><p>(Ex. 3.10 in Chris Okasaki “Purely Functional Data Structures”)
The <code>balance</code> function currently performs several unnecessary
tests: when e.g. <code>ins</code> recurses on the left child, there are
no violations on the right child.</p>
<ul>
<li>Split <code>balance</code> into <code>lbalance</code> and
<code>rbalance</code> that test for violations of left resp. right child
only. Replace calls to <code>balance</code> appropriately.</li>
<li>One of the remaining tests on grandchildren is also unnecessary.
Rewrite <code>ins</code> so that it never tests the color of nodes not
on the search path.</li>
</ul></li>
</ol>
<p><strong>Exercise 8.</strong> (*) Implement maps (i.e. write a module
for the map signature) based on AVL trees. See
<code>http://en.wikipedia.org/wiki/AVL_tree</code>.</p>
<h2 id="chapter-6-folding-and-backtracking">Chapter 6: Folding and
Backtracking</h2>
<p>This chapter explores two fundamental programming paradigms in
functional programming: <strong>folding</strong> (also known as
reduction) and <strong>backtracking</strong>. We begin with the classic
<code>map</code> and <code>fold</code> higher-order functions, examine
how they generalize to trees and other data structures, then move on to
solving puzzles using backtracking with lists.</p>
<h3 id="basic-generic-list-operations">6.1 Basic Generic List
Operations</h3>
<p>Functional programming emphasizes identifying common patterns and
abstracting them into reusable higher-order functions. Let us see how
this works in practice.</p>
<h4 id="the-map-function">The <code>map</code> Function</h4>
<p>Consider the problem of printing a comma-separated list of integers.
The <code>String</code> module provides:</p>
<pre><code>val concat : string -&gt; string list -&gt; string</code></pre>
<p>First, we need to convert numbers into strings:</p>
<pre><code>let rec strings_of_ints = function
  | [] -&gt; []
  | hd::tl -&gt; string_of_int hd :: strings_of_ints tl

let comma_sep_ints = String.concat &quot;, &quot; -| strings_of_ints</code></pre>
<p>Similarly, to sort strings from shortest to longest, we first compute
lengths:</p>
<pre><code>let rec strings_lengths = function
  | [] -&gt; []
  | hd::tl -&gt; (String.length hd, hd) :: strings_lengths tl

let by_size = List.sort compare -| strings_lengths</code></pre>
<p>Notice the common structure in <code>strings_of_ints</code> and
<code>strings_lengths</code>: both transform each element of a list
independently. We can extract this pattern into a generic function
called <code>map</code>:</p>
<pre><code>let rec list_map f = function
  | [] -&gt; []
  | hd::tl -&gt; f hd :: list_map f tl</code></pre>
<p>Now we can rewrite our functions more concisely:</p>
<pre><code>let comma_sep_ints =
  String.concat &quot;, &quot; -| list_map string_of_int

let by_size =
  List.sort compare -| list_map (fun s -&gt; String.length s, s)</code></pre>
<h4 id="the-fold-function">The <code>fold</code> Function</h4>
<p>Consider summing elements of a list:</p>
<pre><code>let rec balance = function
  | [] -&gt; 0
  | hd::tl -&gt; hd + balance tl</code></pre>
<p>Or multiplying elements:</p>
<pre><code>let rec total_ratio = function
  | [] -&gt; 1.
  | hd::tl -&gt; hd *. total_ratio tl</code></pre>
<p>The pattern is the same: we combine each element with the result of
processing the rest of the list. This is the <strong>fold</strong>
operation:</p>
<pre><code>let rec list_fold f base = function
  | [] -&gt; base
  | hd::tl -&gt; f hd (list_fold f base tl)</code></pre>
<p><strong>Important:</strong> Note that <code>list_fold f base l</code>
equals <code>List.fold_right f l base</code>. The OCaml standard library
uses a different argument order.</p>
<p>The key insight is that <code>map</code> alters the <em>contents</em>
of data without changing its structure, while <code>fold</code> computes
a value using the structure as scaffolding. Visually:</p>
<ul>
<li><code>map</code> transforms: <code>[a; b; c; d]</code> becomes
<code>[f a; f b; f c; f d]</code></li>
<li><code>fold</code> collapses: <code>[a; b; c; d]</code> becomes
<code>f a (f b (f c (f d accu)))</code></li>
</ul>
<h3 id="making-fold-tail-recursive">6.2 Making Fold Tail-Recursive</h3>
<p>Let us investigate tail-recursive functions. Consider reversing a
list:</p>
<pre><code>let rec list_rev acc = function
  | [] -&gt; acc
  | hd::tl -&gt; list_rev (hd::acc) tl</code></pre>
<p>Or computing an average:</p>
<pre><code>let rec average (sum, tot) = function
  | [] when tot = 0. -&gt; 0.
  | [] -&gt; sum /. tot
  | hd::tl -&gt; average (hd +. sum, 1. +. tot) tl</code></pre>
<p>The pattern here is different from <code>fold_right</code>. We
process elements from left to right, accumulating a result:</p>
<pre><code>let rec fold_left f accu = function
  | [] -&gt; accu
  | a::l -&gt; fold_left f (f accu a) l</code></pre>
<p>With <code>fold_left</code>, hiding the accumulator is
straightforward:</p>
<pre><code>let list_rev l =
  fold_left (fun t h -&gt; h::t) [] l

let average =
  fold_left (fun (sum, tot) e -&gt; sum +. e, 1. +. tot) (0., 0.)</code></pre>
<p>The naming convention for <code>fold_right</code> and
<code>fold_left</code> reflects associativity:</p>
<ul>
<li><p><code>fold_right f</code> makes <code>f</code> <strong>right
associative</strong>, like the list constructor <code>::</code>:
<code>List.fold_right f [a1; ...; an] b</code> is
<code>f a1 (f a2 (... (f an b) ...))</code></p></li>
<li><p><code>fold_left f</code> makes <code>f</code> <strong>left
associative</strong>, like function application:
<code>List.fold_left f a [b1; ...; bn]</code> is
<code>f (... (f (f a b1) b2) ...) bn</code></p></li>
</ul>
<p>The “backward” structure of <code>fold_left</code>: - Input:
<code>[a; b; c; d]</code> - Result:
<code>f (f (f (f accu a) b) c) d</code></p>
<h4 id="useful-derived-functions">Useful Derived Functions</h4>
<p>List filtering is naturally expressed using
<code>fold_right</code>:</p>
<pre><code>let list_filter p l =
  List.fold_right (fun h t -&gt; if p h then h::t else t) l []</code></pre>
<p>A tail-recursive map that returns elements in reverse order:</p>
<pre><code>let list_rev_map f l =
  List.fold_left (fun t h -&gt; f h :: t) [] l</code></pre>
<h3 id="map-and-fold-for-trees-and-other-structures">6.3 Map and Fold
for Trees and Other Structures</h3>
<h4 id="binary-trees">Binary Trees</h4>
<p>Mapping binary trees is straightforward:</p>
<pre><code>type &#39;a btree = Empty | Node of &#39;a * &#39;a btree * &#39;a btree

let rec bt_map f = function
  | Empty -&gt; Empty
  | Node (e, l, r) -&gt; Node (f e, bt_map f l, bt_map f r)

let test = Node
  (3, Node (5, Empty, Empty), Node (7, Empty, Empty))
let _ = bt_map ((+) 1) test</code></pre>
<p>The <code>map</code> and <code>fold</code> functions we consider here
preserve/respect the structure of data. They do <strong>not</strong>
correspond to <code>map</code> and <code>fold</code> of abstract data
type containers (which are like <code>List.rev_map</code> and
<code>List.fold_left</code> over container elements in arbitrary order).
Here we generalize <code>List.map</code> and
<code>List.fold_right</code> to other structures.</p>
<p>The most general form of <code>fold</code> for binary trees processes
each element together with partial results from subtrees:</p>
<pre><code>let rec bt_fold f base = function
  | Empty -&gt; base
  | Node (e, l, r) -&gt;
    f e (bt_fold f base l) (bt_fold f base r)</code></pre>
<p>Examples:</p>
<pre><code>let sum_els = bt_fold (fun i l r -&gt; i + l + r) 0
let depth t = bt_fold (fun _ l r -&gt; 1 + max l r) 1 t</code></pre>
<h4 id="more-complex-structures-expressions">More Complex Structures:
Expressions</h4>
<p>To demonstrate map and fold for more complex structures, we recall
the expression type from Chapter 3:</p>
<pre><code>type expression =
    Const of float
  | Var of string
  | Sum of expression * expression    (* e1 + e2 *)
  | Diff of expression * expression   (* e1 - e2 *)
  | Prod of expression * expression   (* e1 * e2 *)
  | Quot of expression * expression   (* e1 / e2 *)</code></pre>
<p>The multitude of cases makes the datatype harder to work with.
Fortunately, <em>or-patterns</em> help:</p>
<pre><code>let rec vars = function
  | Const _ -&gt; []
  | Var x -&gt; [x]
  | Sum (a,b) | Diff (a,b) | Prod (a,b) | Quot (a,b) -&gt;
    vars a @ vars b</code></pre>
<p>Mapping and folding must be specialized for each case. We pack
behaviors into records:</p>
<pre><code>type expression_map = {
  map_const : float -&gt; expression;
  map_var : string -&gt; expression;
  map_sum : expression -&gt; expression -&gt; expression;
  map_diff : expression -&gt; expression -&gt; expression;
  map_prod : expression -&gt; expression -&gt; expression;
  map_quot : expression -&gt; expression -&gt; expression;
}

(* Note: &#39;a replaces expression because fold produces values of arbitrary type *)
type &#39;a expression_fold = {
  fold_const : float -&gt; &#39;a;
  fold_var : string -&gt; &#39;a;
  fold_sum : &#39;a -&gt; &#39;a -&gt; &#39;a;
  fold_diff : &#39;a -&gt; &#39;a -&gt; &#39;a;
  fold_prod : &#39;a -&gt; &#39;a -&gt; &#39;a;
  fold_quot : &#39;a -&gt; &#39;a -&gt; &#39;a;
}</code></pre>
<p>We define standard behaviors that can be tailored for specific
uses:</p>
<pre><code>let identity_map = {
  map_const = (fun c -&gt; Const c);
  map_var = (fun x -&gt; Var x);
  map_sum = (fun a b -&gt; Sum (a, b));
  map_diff = (fun a b -&gt; Diff (a, b));
  map_prod = (fun a b -&gt; Prod (a, b));
  map_quot = (fun a b -&gt; Quot (a, b));
}

let make_fold op base = {
  fold_const = (fun _ -&gt; base);
  fold_var = (fun _ -&gt; base);
  fold_sum = op; fold_diff = op;
  fold_prod = op; fold_quot = op;
}</code></pre>
<p>The actual <code>map</code> and <code>fold</code> functions:</p>
<pre><code>let rec expr_map emap = function
  | Const c -&gt; emap.map_const c
  | Var x -&gt; emap.map_var x
  | Sum (a,b) -&gt; emap.map_sum (expr_map emap a) (expr_map emap b)
  | Diff (a,b) -&gt; emap.map_diff (expr_map emap a) (expr_map emap b)
  | Prod (a,b) -&gt; emap.map_prod (expr_map emap a) (expr_map emap b)
  | Quot (a,b) -&gt; emap.map_quot (expr_map emap a) (expr_map emap b)

let rec expr_fold efold = function
  | Const c -&gt; efold.fold_const c
  | Var x -&gt; efold.fold_var x
  | Sum (a,b) -&gt; efold.fold_sum (expr_fold efold a) (expr_fold efold b)
  | Diff (a,b) -&gt; efold.fold_diff (expr_fold efold a) (expr_fold efold b)
  | Prod (a,b) -&gt; efold.fold_prod (expr_fold efold a) (expr_fold efold b)
  | Quot (a,b) -&gt; efold.fold_quot (expr_fold efold a) (expr_fold efold b)</code></pre>
<p>Using the <code>{record with field = value}</code> syntax to
customize behaviors:</p>
<pre><code>let prime_vars = expr_map
  {identity_map with map_var = fun x -&gt; Var (x ^ &quot;&#39;&quot;)}

let subst s =
  let apply x = try List.assoc x s with Not_found -&gt; Var x in
  expr_map {identity_map with map_var = apply}

let vars =
  expr_fold {(make_fold (@) []) with fold_var = fun x -&gt; [x]}

let size = expr_fold (make_fold (fun a b -&gt; 1 + a + b) 1)

let eval env = expr_fold {
  fold_const = id;
  fold_var = (fun x -&gt; List.assoc x env);
  fold_sum = (+.); fold_diff = (-.);
  fold_prod = ( *.); fold_quot = (/.);
}</code></pre>
<h3 id="point-free-programming">6.4 Point-Free Programming</h3>
<p>In 1977/78, John Backus designed <strong>FP</strong>, the first
<em>function-level programming</em> language. Over the next decade it
evolved into the <strong>FL</strong> language.</p>
<blockquote>
<p>“Clarity is achieved when programs are written at the function
level–that is, by putting together existing programs to form new ones,
rather than by manipulating objects and then abstracting from those
objects to produce programs.” – <em>The FL Project: The Design of a
Functional Language</em></p>
</blockquote>
<p>For function-level programming, we need combinators like these from
<em>OCaml Batteries</em>:</p>
<pre><code>let const x _ = x
let ( |- ) f g x = g (f x)          (* forward composition *)
let ( -| ) f g x = f (g x)          (* backward composition *)
let flip f x y = f y x
let ( *** ) f g = fun (x,y) -&gt; (f x, g y)
let ( &amp;&amp;&amp; ) f g = fun x -&gt; (f x, g x)
let first f x = fst (f x)
let second f x = snd (f x)
let curry f x y = f (x,y)
let uncurry f (x,y) = f x y</code></pre>
<p>The flow of computation can be viewed as a circuit where results of
nodes (functions) connect to further nodes as inputs. We represent
cross-sections of the circuit as tuples of intermediate values.</p>
<pre><code>let print2 c i =
  let a = Char.escaped c in
  let b = string_of_int i in
  a ^ b</code></pre>
<p>In point-free style:</p>
<pre><code>let print2 = curry
  ((Char.escaped *** string_of_int) |- uncurry (^))</code></pre>
<p>Since we usually pass arguments one at a time rather than in tuples,
we need <code>uncurry</code> to access multi-argument functions.
Converting a C/Pascal-like function to one that takes arguments one at a
time is called <em>currying</em>, after logician Haskell Brooks
Curry.</p>
<p>Another approach uses function composition, <code>flip</code>, and
the <strong>S</strong> combinator:</p>
<pre><code>let s x y z = x z (y z)</code></pre>
<p>Example: transforming a filter-map function step by step:</p>
<pre><code>let func2 f g l = List.filter f (List.map g l)
(* Using composition: *)
let func2 f g = (-|) (List.filter f) (List.map g)
let func2 f = (-|) (List.filter f) -| List.map
(* Eliminating f: *)
let func2 f = (-|) ((-|) (List.filter f)) List.map
let func2 f = flip (-|) List.map ((-|) (List.filter f))
let func2 f = (((|-) List.map) -| ((-|) -| List.filter)) f
let func2 = (|-) List.map -| ((-|) -| List.filter)</code></pre>
<h3 id="reductions-and-more-higher-order-functions">6.5 Reductions and
More Higher-Order Functions</h3>
<p>Mathematics has notation for sums over intervals: <span
class="math inline">\sum_{n=a}^{b} f(n)</span>.</p>
<p>In OCaml, we do not have a universal addition operator:</p>
<pre><code>let rec i_sum_from_to f a b =
  if a &gt; b then 0
  else f a + i_sum_from_to f (a+1) b

let rec f_sum_from_to f a b =
  if a &gt; b then 0.
  else f a +. f_sum_from_to f (a+1) b

let pi2_over6 =
  f_sum_from_to (fun i -&gt; 1. /. float_of_int (i*i)) 1 5000</code></pre>
<p>The natural generalization:</p>
<pre><code>let rec op_from_to op base f a b =
  if a &gt; b then base
  else op (f a) (op_from_to op base f (a+1) b)</code></pre>
<h4 id="collecting-results-concat_map">Collecting Results:
concat_map</h4>
<p>Let us collect results of a multifunction (set-valued function) for a
set of arguments. In mathematical notation:</p>
<p><span class="math display">f(A) = \bigcup_{p \in A} f(p)</span></p>
<p>This translates to a useful list operation with union as append:</p>
<pre><code>let rec concat_map f = function
  | [] -&gt; []
  | a::l -&gt; f a @ concat_map f l</code></pre>
<p>More efficiently (tail-recursive):</p>
<pre><code>let concat_map f l =
  let rec cmap_f accu = function
    | [] -&gt; accu
    | a::l -&gt; cmap_f (List.rev_append (f a) accu) l in
  List.rev (cmap_f [] l)</code></pre>
<h4 id="all-subsequences-of-a-list">All Subsequences of a List</h4>
<pre><code>let rec subseqs l =
  match l with
    | [] -&gt; [[]]
    | x::xs -&gt;
      let pxs = subseqs xs in
      List.map (fun px -&gt; x::px) pxs @ pxs</code></pre>
<p>Tail-recursively:</p>
<pre><code>let rec rmap_append f accu = function
  | [] -&gt; accu
  | a::l -&gt; rmap_append f (f a :: accu) l

let rec subseqs l =
  match l with
    | [] -&gt; [[]]
    | x::xs -&gt;
      let pxs = subseqs xs in
      rmap_append (fun px -&gt; x::px) pxs pxs</code></pre>
<h3 id="grouping-and-map-reduce">6.6 Grouping and Map-Reduce</h3>
<p>It is often useful to organize values by some property.</p>
<h4 id="collecting-by-key">Collecting by Key</h4>
<p>First, we collect elements from an association list by key:</p>
<pre><code>let collect l =
  match List.sort (fun x y -&gt; compare (fst x) (fst y)) l with
  | [] -&gt; []                                (* Start with associations sorted by key *)
  | (k0, v0)::tl -&gt;
    let k0, vs, l = List.fold_left
      (fun (k0, vs, l) (kn, vn) -&gt;           (* Collect values for current key *)
        if k0 = kn then k0, vn::vs, l        (* and when the key changes, *)
        else kn, [vn], (k0, List.rev vs)::l) (* stack the collected values *)
      (k0, [v0], []) tl in                   (* Why reverse? To preserve order *)
    List.rev ((k0, List.rev vs)::l)</code></pre>
<p>Now we can group by an arbitrary property:</p>
<pre><code>let group_by p l = collect (List.map (fun e -&gt; p e, e) l)</code></pre>
<h4 id="reduction-aggregation">Reduction (Aggregation)</h4>
<p>To process results like SQL aggregate operations, we add
<strong>reduction</strong>:</p>
<pre><code>let aggregate_by p red base l =
  let ags = group_by p l in
  List.map (fun (k, vs) -&gt; k, List.fold_right red vs base) ags</code></pre>
<p>Using the <strong>feed-forward</strong> (pipe) operator
<code>let ( |&gt; ) x f = f x</code>:</p>
<pre><code>let aggregate_by p redf base l =
  group_by p l
  |&gt; List.map (fun (k, vs) -&gt; k, List.fold_right redf vs base)</code></pre>
<p>Often it is easier to extract the property upfront. Since we first
map elements into key-value pairs, we call this
<code>map_reduce</code>:</p>
<pre><code>let map_reduce mapf redf base l =
  List.map mapf l
  |&gt; collect
  |&gt; List.map (fun (k, vs) -&gt; k, List.fold_right redf vs base)</code></pre>
<h4 id="map-reduce-examples">Map-Reduce Examples</h4>
<p>Sometimes we have multiple sources of information:</p>
<pre><code>let concat_reduce mapf redf base l =
  concat_map mapf l
  |&gt; collect
  |&gt; List.map (fun (k, vs) -&gt; k, List.fold_right redf vs base)</code></pre>
<p>Computing a merged histogram of documents:</p>
<pre><code>let histogram documents =
  let mapf doc =
    Str.split (Str.regexp &quot;[ \t.,;]+&quot;) doc
    |&gt; List.map (fun word -&gt; word, 1) in
  concat_reduce mapf (+) 0 documents</code></pre>
<p>Computing an inverted index:</p>
<pre><code>let cons hd tl = hd::tl

let inverted_index documents =
  let mapf (addr, doc) =
    Str.split (Str.regexp &quot;[ \t.,;]+&quot;) doc
    |&gt; List.map (fun word -&gt; word, addr) in
  concat_reduce mapf cons [] documents</code></pre>
<p>A simple “search engine”:</p>
<pre><code>let search index words =
  match List.map (flip List.assoc index) words with
  | [] -&gt; []
  | idx::idcs -&gt; List.fold_left intersect idx idcs</code></pre>
<p>where <code>intersect</code> computes intersection of sets
represented as sorted lists:</p>
<pre><code>let intersect xs ys =                       (* Sets as sorted lists *)
  let rec aux acc = function
    | [], _ | _, [] -&gt; acc
    | (x::xs&#39; as xs), (y::ys&#39; as ys) -&gt;
      let c = compare x y in
      if c = 0 then aux (x::acc) (xs&#39;, ys&#39;)
      else if c &lt; 0 then aux acc (xs&#39;, ys)
      else aux acc (xs, ys&#39;) in
  List.rev (aux [] (xs, ys))</code></pre>
<h3 id="higher-order-functions-for-the-option-type">6.7 Higher-Order
Functions for the Option Type</h3>
<p>Operating on optional values:</p>
<pre><code>let map_option f = function
  | None -&gt; None
  | Some e -&gt; f e</code></pre>
<p>Mapping over a list and filtering out failures:</p>
<pre><code>let rec map_some f = function
  | [] -&gt; []
  | e::l -&gt; match f e with
    | None -&gt; map_some f l
    | Some r -&gt; r :: map_some f l</code></pre>
<p>Tail-recursively:</p>
<pre><code>let map_some f l =
  let rec maps_f accu = function
    | [] -&gt; accu
    | a::l -&gt; maps_f (match f a with None -&gt; accu
      | Some r -&gt; r::accu) l in
  List.rev (maps_f [] l)</code></pre>
<h3 id="the-countdown-problem-puzzle">6.8 The Countdown Problem
Puzzle</h3>
<p>The Countdown Problem is a classic puzzle:</p>
<ul>
<li>Using a given set of numbers and arithmetic operators +, -, *, /,
construct an expression with a given value.</li>
<li>All numbers, including intermediate results, must be positive
integers.</li>
<li>Each source number can be used at most once.</li>
</ul>
<p><strong>Example:</strong> - Numbers: 1, 3, 7, 10, 25, 50 - Target:
765 - Possible solution: (25-10) * (50+1)</p>
<p>There are 780 solutions for this example. Changing the target to 831
gives an example with no solutions.</p>
<h4 id="data-types">Data Types</h4>
<pre><code>type op = Add | Sub | Mul | Div

let apply op x y =
  match op with
  | Add -&gt; x + y
  | Sub -&gt; x - y
  | Mul -&gt; x * y
  | Div -&gt; x / y

let valid op x y =
  match op with
  | Add -&gt; true
  | Sub -&gt; x &gt; y
  | Mul -&gt; true
  | Div -&gt; x mod y = 0

type expr = Val of int | App of op * expr * expr

let rec eval = function
  | Val n -&gt; if n &gt; 0 then Some n else None
  | App (o, l, r) -&gt;
    eval l |&gt; map_option (fun x -&gt;
      eval r |&gt; map_option (fun y -&gt;
      if valid o x y then Some (apply o x y)
      else None))

let rec values = function
  | Val n -&gt; [n]
  | App (_, l, r) -&gt; values l @ values r

let solution e ns n =
  list_diff (values e) ns = [] &amp;&amp; is_unique (values e) &amp;&amp;
  eval e = Some n</code></pre>
<h4 id="brute-force-solution">Brute Force Solution</h4>
<p>Splitting a list into two non-empty parts:</p>
<pre><code>let split l =
  let rec aux lhs acc = function
    | [] | [_] -&gt; []
    | [y; z] -&gt; (List.rev (y::lhs), [z])::acc
    | hd::rhs -&gt;
      let lhs = hd::lhs in
      aux lhs ((List.rev lhs, rhs)::acc) rhs in
  aux [] [] l</code></pre>
<p>We introduce an operator for working with multiple data sources:</p>
<pre><code>let ( |-&gt; ) x f = concat_map f x</code></pre>
<p>Generating all expressions from a list of numbers:</p>
<pre><code>let combine l r =                           (* Combine two expressions using each operator *)
  List.map (fun o -&gt; App (o, l, r)) [Add; Sub; Mul; Div]

let rec exprs = function
  | [] -&gt; []
  | [n] -&gt; [Val n]
  | ns -&gt;
    split ns |-&gt; (fun (ls, rs) -&gt;           (* For each split ls,rs of numbers *)
      exprs ls |-&gt; (fun l -&gt;                (* for each expression l over ls *)
        exprs rs |-&gt; (fun r -&gt;              (* and expression r over rs *)
          combine l r)))                    (* produce all l ? r expressions *)</code></pre>
<p>Finding solutions:</p>
<pre><code>let guard n =
  List.filter (fun e -&gt; eval e = Some n)

let solutions ns n =
  choices ns |-&gt; (fun ns&#39; -&gt;
    exprs ns&#39; |&gt; guard n)</code></pre>
<h4 id="optimization-fuse-generation-with-testing">Optimization: Fuse
Generation with Testing</h4>
<p>We memorize values with expressions as pairs
<code>(e, eval e)</code>, so only valid subexpressions are
generated:</p>
<pre><code>let combine&#39; (l, x) (r, y) =
  [Add; Sub; Mul; Div]
  |&gt; List.filter (fun o -&gt; valid o x y)
  |&gt; List.map (fun o -&gt; App (o, l, r), apply o x y)

let rec results = function
  | [] -&gt; []
  | [n] -&gt; if n &gt; 0 then [Val n, n] else []
  | ns -&gt;
    split ns |-&gt; (fun (ls, rs) -&gt;
      results ls |-&gt; (fun lx -&gt;
        results rs |-&gt; (fun ry -&gt;
          combine&#39; lx ry)))

let solutions&#39; ns n =
  choices ns |-&gt; (fun ns&#39; -&gt;
    results ns&#39;
    |&gt; List.filter (fun (e, m) -&gt; m = n)
    |&gt; List.map fst)                        (* Discard memorized values *)</code></pre>
<h4 id="eliminating-symmetric-cases">Eliminating Symmetric Cases</h4>
<p>Strengthening the validity predicate to account for commutativity and
identity:</p>
<pre><code>let valid op x y =
  match op with
  | Add -&gt; x &lt;= y
  | Sub -&gt; x &gt; y
  | Mul -&gt; x &lt;= y &amp;&amp; x &lt;&gt; 1 &amp;&amp; y &lt;&gt; 1
  | Div -&gt; x mod y = 0 &amp;&amp; y &lt;&gt; 1</code></pre>
<p>This eliminates repeating symmetrical solutions on the semantic level
(values) rather than syntactic level (expressions)–both easier and more
effective.</p>
<h3 id="the-honey-islands-puzzle">6.9 The Honey Islands Puzzle</h3>
<p>The Honey Islands puzzle: Find cells to eat honey from so that the
least amount of honey becomes sour (assuming sourness spreads through
contact).</p>
<p>Given a honeycomb with some cells initially marked black, mark
additional cells so that unmarked cells form <code>num_islands</code>
disconnected components, each with <code>island_size</code> cells.</p>
<h4 id="representing-the-honeycomb">Representing the Honeycomb</h4>
<pre><code>type cell = int * int                       (* Cartesian coordinates *)

module CellSet =                            (* Store cells in sets *)
  Set.Make (struct type t = cell let compare = compare end)

type task = {                               (* For board size N, coordinates *)
  board_size : int;                         (* range from (-2N, -N) to (2N, N) *)
  num_islands : int;                        (* Required number of islands *)
  island_size : int;                        (* Required cells per island *)
  empty_cells : CellSet.t;                  (* Initially empty cells *)
}

let cellset_of_list l =                     (* List to set, inverse of CellSet.elements *)
  List.fold_right CellSet.add l CellSet.empty</code></pre>
<p><strong>Neighborhood:</strong> Each cell (x, y) has up to 6
neighbors:</p>
<pre><code>let neighbors n eaten (x, y) =
  List.filter
    (inside_board n eaten)
    [x-1,y-1; x+1,y-1; x+2,y;
     x+1,y+1; x-1,y+1; x-2,y]</code></pre>
<p><strong>Building the honeycomb:</strong></p>
<pre><code>let even x = x mod 2 = 0

let inside_board n eaten (x, y) =
  even x = even y &amp;&amp; abs y &lt;= n &amp;&amp;
  abs x + abs y &lt;= 2*n &amp;&amp;
  not (CellSet.mem (x, y) eaten)

let honey_cells n eaten =
  from_to (-2*n) (2*n) |-&gt; (fun x -&gt;
    from_to (-n) n |-&gt; (fun y -&gt;
     guard (inside_board n eaten)
        (x, y)))</code></pre>
<h4 id="testing-correctness">Testing Correctness</h4>
<p>We walk through each island counting cells depth-first:</p>
<pre><code>let check_correct n island_size num_islands empty_cells =
  let honey = honey_cells n empty_cells in

  let rec check_board been_islands unvisited visited =
    match unvisited with
    | [] -&gt; been_islands = num_islands
    | cell::remaining when CellSet.mem cell visited -&gt;
        check_board been_islands remaining visited    (* Keep looking *)
    | cell::remaining (* when not visited *) -&gt;
        let (been_size, unvisited, visited) =
          check_island cell                           (* Visit another island *)
            (1, remaining, CellSet.add cell visited) in
        been_size = island_size
        &amp;&amp; check_board (been_islands+1) unvisited visited

  and check_island current state =
    neighbors n empty_cells current
    |&gt; List.fold_left                                 (* Walk into each direction *)
      (fun (been_size, unvisited, visited as state)
        neighbor -&gt;
        if CellSet.mem neighbor visited then state
        else
          let unvisited = remove neighbor unvisited in
          let visited = CellSet.add neighbor visited in
          let been_size = been_size + 1 in
          check_island neighbor
            (been_size, unvisited, visited))
      state in                                        (* Initial been_size is 1 *)

  check_board 0 honey empty_cells</code></pre>
<h4 id="multiple-results-per-step-concat_fold">Multiple Results per
Step: concat_fold</h4>
<p>When processing lists with potentially multiple results per step, we
need <code>concat_fold</code>:</p>
<pre><code>let rec concat_fold f a = function
  | [] -&gt; [a]
  | x::xs -&gt;
    f x a |-&gt; (fun a&#39; -&gt; concat_fold f a&#39; xs)</code></pre>
<h4 id="generating-solutions">Generating Solutions</h4>
<p>We transform the testing code into generation code by: - Passing
around the current solution <code>eaten</code> - Returning results in a
list (empty list = no solutions) - At each neighbor, trying both eating
and keeping</p>
<pre><code>let find_to_eat n island_size num_islands empty_cells =
  let honey = honey_cells n empty_cells in

  let rec find_board been_islands unvisited visited eaten =
    match unvisited with
    | [] -&gt;
      if been_islands = num_islands then [eaten] else []
    | cell::remaining when CellSet.mem cell visited -&gt;
      find_board been_islands remaining visited eaten
    | cell::remaining (* when not visited *) -&gt;
      find_island cell
        (1, remaining, CellSet.add cell visited, eaten)
      |-&gt;                                             (* Concatenate solutions *)
      (fun (been_size, unvisited, visited, eaten) -&gt;
        if been_size = island_size
        then find_board (been_islands+1)
               unvisited visited eaten
        else [])

  and find_island current state =
    neighbors n empty_cells current
    |&gt; concat_fold                                    (* Multiple results *)
        (fun neighbor
          (been_size, unvisited, visited, eaten as state) -&gt;
          if CellSet.mem neighbor visited then [state]
          else
            let unvisited = remove neighbor unvisited in
            let visited = CellSet.add neighbor visited in
            (been_size, unvisited, visited,
             neighbor::eaten)::
              (* solutions where neighbor is honey *)
            find_island neighbor
              (been_size+1, unvisited, visited, eaten))
        state in

  find_board 0 honey empty_cells []</code></pre>
<h4 id="optimizations">Optimizations</h4>
<p>The main rule: <strong>fail (drop solution candidates) as early as
possible</strong>.</p>
<p>We guard both choices (eating and keeping) and track how much honey
needs to be eaten:</p>
<pre><code>type state = {
  been_size: int;                           (* Honey cells in current island *)
  been_islands: int;                        (* Islands visited so far *)
  unvisited: cell list;                     (* Cells to visit *)
  visited: CellSet.t;                       (* Already visited *)
  eaten: cell list;                         (* Current solution candidate *)
  more_to_eat: int;                         (* Remaining cells to eat *)
}

let rec visit_cell s =
  match s.unvisited with
  | [] -&gt; None
  | c::remaining when CellSet.mem c s.visited -&gt;
    visit_cell {s with unvisited=remaining}
  | c::remaining (* when c not visited *) -&gt;
    Some (c, {s with
      unvisited=remaining;
      visited = CellSet.add c s.visited})

let eat_cell c s =
  {s with eaten = c::s.eaten;
    visited = CellSet.add c s.visited;
    more_to_eat = s.more_to_eat - 1}

let keep_cell c s =                         (* c is actually unused *)
  {s with been_size = s.been_size + 1;
    visited = CellSet.add c s.visited}

let fresh_island s =                        (* Increment been_size at start of find_island *)
  {s with been_size = 0;
    been_islands = s.been_islands + 1}

let init_state unvisited more_to_eat = {
  been_size = 0; been_islands = 0;
  unvisited; visited = CellSet.empty;
  eaten = []; more_to_eat;
}</code></pre>
<p>The optimized island loop only tries actions that make sense:</p>
<pre><code>  and find_island current s =
    let s = keep_cell current s in
    neighbors n empty_cells current
    |&gt; concat_fold
        (fun neighbor s -&gt;
          if CellSet.mem neighbor s.visited then [s]
          else
            let choose_eat =                (* Guard against failed actions *)
              if s.more_to_eat = 0 then []
              else [eat_cell neighbor s]
            and choose_keep =
              if s.been_size &gt;= island_size then []
              else find_island neighbor s in
            choose_eat @ choose_keep)
        s in</code></pre>
<p>Finally, compute the required eaten cells and start searching:</p>
<pre><code>  let cells_to_eat =
    List.length honey - island_size * num_islands in
  find_board (init_state honey cells_to_eat)</code></pre>
<h3 id="constraint-based-puzzles">6.10 Constraint-Based Puzzles</h3>
<p>Puzzles can be presented by providing: 1. The general form of
solutions 2. Additional requirements (constraints) that solutions must
meet</p>
<p>For many puzzles, solutions decompose into a fixed number of
<strong>variables</strong>: - A <strong>domain</strong> is the set of
possible values a variable can have - In Honey Islands, variables are
cells with domain {Honey, Empty} - <strong>Constraints</strong> specify
relationships: cells that must be empty, number and size of connected
components, neighborhood graph</p>
<h4 id="finite-domain-constraint-programming">Finite Domain Constraint
Programming</h4>
<p>A general and often efficient scheme:</p>
<ol type="1">
<li><p>With each variable, associate a set of values (initially the full
domain). The singleton containing this association is the initial set of
partial solutions.</p></li>
<li><p>While there is a solution with more than one value for some
variable:</p>
<ul>
<li><ol type="a">
<li>If some value for a variable fails for all possible assignments to
other variables, remove it</li>
</ol></li>
<li><ol start="2" type="a">
<li>If a variable has an empty set of possible values, remove that
solution</li>
</ol></li>
<li><ol start="3" type="a">
<li>Select the variable with the smallest non-singleton set. Split into
similarly-sized parts. Replace the solution with two solutions for each
part.</li>
</ol></li>
</ul></li>
<li><p>Build final solutions by assigning each variable its single
remaining value.</p></li>
</ol>
<p>Simplifications: In step (2c), instead of equal-sized splits, we can
partition into singleton and remainder, or partition completely into
singletons.</p>
<h3 id="exercises-5">6.11 Exercises</h3>
<ol type="1">
<li><p>Recall how we generated all subsequences of a list. Find
(generate) all:</p>
<ul>
<li>permutations of a list</li>
<li>ways of choosing without repetition from a list</li>
<li>combinations of K distinct objects chosen from N elements of a
list</li>
</ul></li>
<li><p>Using folding for the <code>expression</code> data type, compute
the degree of the corresponding polynomial.</p></li>
<li><p>Implement simplification of expressions using mapping for the
<code>expression</code> data type.</p></li>
<li><p>Express in terms of <code>fold_left</code> or
<code>fold_right</code>:</p>
<ul>
<li><code>indexed : 'a list -&gt; (int * 'a) list</code>, which pairs
elements with their indices</li>
<li><code>concat_fold</code> as used in Honey Islands</li>
<li>Run-length encoding of a list:
<code>encode ['a;'a;'a;'a;'b;'c;'c;'a;'a;'d] = [4,'a; 1,'b; 2,'c; 2,'a; 1,'d]</code></li>
</ul></li>
<li><p>Write more efficient variants:</p>
<ul>
<li><code>list_diff</code> computing difference of sets represented as
sorted lists</li>
<li><code>is_unique</code> in constant stack space</li>
</ul></li>
<li><p>Write functions <code>compose</code> and <code>perform</code>
that take a list of functions and return their composition:</p>
<ul>
<li><code>compose [f1; ...; fn] = x -&gt; f1 (... (fn x)...)</code></li>
<li><code>perform [f1; ...; fn] = x -&gt; fn (... (f1 x)...)</code></li>
</ul></li>
<li><p>Write a solver for the <em>Tents Puzzle</em>.</p></li>
<li><p><strong>Robot Squad</strong> (harder): Given a map with walls and
lidar readings (8 directions: E, NE, N, NW, W, SW, S, SE) for multiple
robots, determine possible robot positions.</p></li>
<li><p>Write a solver for the <em>Plinx Puzzle</em> (does not need to
solve all levels, but should handle initial ones).</p></li>
</ol>
<h2 id="chapter-7-laziness">Chapter 7: Laziness</h2>
<p>This chapter explores lazy evaluation and stream processing in OCaml.
We examine different evaluation strategies, implement streams and lazy
lists, apply them to power series computation and differential
equations, build circular data structures, and develop a sophisticated
pipe-based pretty-printer.</p>
<h3 id="evaluation-strategies-and-parameter-passing">7.1 Evaluation
Strategies and Parameter Passing</h3>
<p><strong>Evaluation strategy</strong> is the order in which
expressions are computed – primarily, when arguments are computed.
Recall our problems with using <em>flow control</em> expressions like
<code>if_then_else</code> in examples from the lambda-calculus lecture.
There are many technical terms describing various evaluation
strategies:</p>
<p><strong>Strict evaluation</strong>: Arguments are always evaluated
completely before the function is applied.</p>
<p><strong>Non-strict evaluation</strong>: Arguments are not evaluated
unless they are actually used in the evaluation of the function
body.</p>
<p><strong>Eager evaluation</strong>: An expression is evaluated as soon
as it gets bound to a variable.</p>
<p><strong>Lazy evaluation</strong>: Non-strict evaluation which avoids
repeating computation.</p>
<p><strong>Call-by-value</strong>: The argument expression is evaluated,
and the resulting value is bound to the corresponding variable in the
function (frequently by copying the value into a new memory region).</p>
<p><strong>Call-by-reference</strong>: A function receives an implicit
reference to a variable used as argument, rather than a copy of its
value. In purely functional languages there is no difference between the
two strategies, so they are typically described as call-by-value even
though implementations use call-by-reference internally for efficiency.
Call-by-value languages like C and OCaml support explicit references
(objects that refer to other objects), and these can be used to simulate
call-by-reference.</p>
<p><strong>Normal order</strong>: Start computing function bodies before
evaluating their arguments. Do not even wait for arguments if they are
not needed.</p>
<p><strong>Call-by-name</strong>: Arguments are substituted directly
into the function body and then left to be evaluated whenever they
appear in the function.</p>
<p><strong>Call-by-need</strong>: If the function argument is evaluated,
that value is stored for subsequent uses.</p>
<p>Almost all languages do not compute inside the body of an un-applied
function, but with curried functions you can pre-compute data before all
arguments are provided (recall the <code>search_bible</code> example
from earlier lectures).</p>
<p>In eager / call-by-value languages we can simulate call-by-name by
taking a function to compute the value as an argument instead of the
value directly. “Our” languages have a <code>unit</code> type with a
single value <code>()</code> specifically for use as throw-away
arguments. Scala has built-in support for call-by-name (i.e. direct,
without the need to build argument functions).</p>
<p>ML languages have built-in support for lazy evaluation, while Haskell
has built-in support for eager evaluation (to override the default
laziness).</p>
<h3 id="call-by-name-streams">7.2 Call-by-name: Streams</h3>
<p>Call-by-name is useful not only for implementing flow control:</p>
<pre><code>let if_then_else cond e1 e2 =
  match cond with
  | true -&gt; e1 ()
  | false -&gt; e2 ()</code></pre>
<p>but also for arguments of value constructors, i.e. for data
structures.</p>
<p><strong>Streams</strong> are lists with call-by-name tails:</p>
<pre><code>type &#39;a stream = SNil | SCons of &#39;a * (unit -&gt; &#39;a stream)</code></pre>
<p>Reading from a stream into a list:</p>
<pre><code>let rec stake n = function
  | SCons (a, s) when n &gt; 0 -&gt; a :: (stake (n-1) (s ()))
  | _ -&gt; []</code></pre>
<p>Streams can easily be infinite:</p>
<pre><code>let rec s_ones = SCons (1, fun () -&gt; s_ones)

let rec s_from n =
  SCons (n, fun () -&gt; s_from (n+1))</code></pre>
<h4 id="stream-operations">7.2.1 Stream Operations</h4>
<p>Streams admit list-like operations:</p>
<pre><code>let rec smap f = function
  | SNil -&gt; SNil
  | SCons (a, s) -&gt; SCons (f a, fun () -&gt; smap f (s ()))

let rec szip = function
  | SNil, SNil -&gt; SNil
  | SCons (a1, s1), SCons (a2, s2) -&gt;
      SCons ((a1, a2), fun () -&gt; szip (s1 (), s2 ()))
  | _ -&gt; raise (Invalid_argument &quot;szip&quot;)</code></pre>
<p>Streams can provide scaffolding for recursive algorithms. Consider
the Fibonacci sequence:</p>
<pre><code>let rec sfib =
  SCons (1, fun () -&gt; smap (fun (a,b) -&gt; a+b)
    (szip (sfib, SCons (1, fun () -&gt; sfib))))</code></pre>
<p>This definition creates a stream where each element is computed by
adding pairs from the current stream and itself shifted by one
position:</p>
<table>
<thead>
<tr>
<th>sfib</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>5</th>
<th>8</th>
<th>13</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr>
<td>sfib</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>8</td>
<td>13</td>
<td>…</td>
</tr>
<tr>
<td>shifted</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>8</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>The <code>+</code> operation between corresponding elements produces
the next values.</p>
<h4 id="streams-and-input-output">7.2.2 Streams and Input-Output</h4>
<p>Streams are less functional than could be expected in the context of
input-output effects:</p>
<pre><code>let file_stream name =
  let ch = open_in name in
  let rec ch_read_line () =
    try SCons (input_line ch, ch_read_line)
    with End_of_file -&gt; SNil in
  ch_read_line ()</code></pre>
<p><em>OCaml Batteries</em> uses a stream type <code>enum</code> for
interfacing between various sequence-like data types. The safest way to
use streams is in a <em>linear</em> / <em>ephemeral</em> manner: every
value used only once. Streams minimize space consumption at the expense
of time for recomputation.</p>
<h3 id="lazy-values">7.3 Lazy Values</h3>
<p>Lazy evaluation is more general than call-by-need as any value can be
lazy, not only a function parameter.</p>
<p>A <em>lazy value</em> is a value that “holds” an expression until its
result is needed, and from then on it “holds” the result. It is also
called a <em>suspension</em>. If it holds the expression (not yet
evaluated), it is called a <em>thunk</em>.</p>
<p>In OCaml, we build lazy values explicitly. In Haskell, all values are
lazy but functions can have call-by-value parameters which “need” the
argument.</p>
<p>To create a lazy value: <code>lazy expr</code> – where
<code>expr</code> is the suspended computation.</p>
<p>Two ways to use a lazy value (be careful when the result is
computed!): - In expressions: <code>Lazy.force l_expr</code> - In
patterns: <code>match l_expr with lazy v -&gt; ...</code> -
Syntactically <code>lazy</code> behaves like a data constructor.</p>
<h4 id="lazy-lists">7.3.1 Lazy Lists</h4>
<p>Lazy lists are defined as:</p>
<pre><code>type &#39;a llist = LNil | LCons of &#39;a * &#39;a llist Lazy.t</code></pre>
<p>Reading from a lazy list into a list:</p>
<pre><code>let rec ltake n = function
  | LCons (a, lazy l) when n &gt; 0 -&gt; a :: (ltake (n-1) l)
  | _ -&gt; []</code></pre>
<p>Lazy lists can easily be infinite:</p>
<pre><code>let rec l_ones = LCons (1, lazy l_ones)

let rec l_from n = LCons (n, lazy (l_from (n+1)))</code></pre>
<p>Read once, access multiple times (unlike streams):</p>
<pre><code>let file_llist name =
  let ch = open_in name in
  let rec ch_read_line () =
    try LCons (input_line ch, lazy (ch_read_line ()))
    with End_of_file -&gt; LNil in
  ch_read_line ()</code></pre>
<h4 id="lazy-list-operations">7.3.2 Lazy List Operations</h4>
<pre><code>let rec lzip = function
  | LNil, LNil -&gt; LNil
  | LCons (a1, ll1), LCons (a2, ll2) -&gt;
      LCons ((a1, a2), lazy (
        lzip (Lazy.force ll1, Lazy.force ll2)))
  | _ -&gt; raise (Invalid_argument &quot;lzip&quot;)

let rec lmap f = function
  | LNil -&gt; LNil
  | LCons (a, ll) -&gt;
    LCons (f a, lazy (lmap f (Lazy.force ll)))</code></pre>
<p>Using these operations, we can define the factorial sequence
elegantly:</p>
<pre><code>let posnums = l_from 1

let rec lfact =
  LCons (1, lazy (lmap (fun (a,b) -&gt; a*b)
                    (lzip (lfact, posnums))))</code></pre>
<p>This produces: 1, 1, 2, 6, 24, 120, … where each element is the
product of the previous factorial and the corresponding positive
integer:</p>
<table>
<thead>
<tr>
<th>lfact</th>
<th>1</th>
<th>1</th>
<th>2</th>
<th>6</th>
<th>24</th>
<th>120</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr>
<td>lfact</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>6</td>
<td>24</td>
<td>120</td>
<td>…</td>
</tr>
<tr>
<td>posnums</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>The <code>*</code> operation between corresponding elements produces
the next values.</p>
<h3 id="power-series-and-differential-equations">7.4 Power Series and
Differential Equations</h3>
<p>This section presents an application of lazy lists to power series
computation and solving differential equations through power series. The
differential equations idea is due to Henning Thielemann.</p>
<p>The expression <span class="math inline">P(x) = \sum_{i=0}^{n} a_i
x^i</span> defines a polynomial for <span class="math inline">n &lt;
\infty</span> and a power series for <span class="math inline">n =
\infty</span>.</p>
<p>If we define:</p>
<pre><code>let rec lfold_right f l base =
  match l with
    | LNil -&gt; base
    | LCons (a, lazy l) -&gt; f a (lfold_right f l base)</code></pre>
<p>then we can compute polynomials using Horner’s method:</p>
<pre><code>let horner x l =
  lfold_right (fun c sum -&gt; c +. x *. sum) l 0.</code></pre>
<p>But this will not work for infinite power series! Does it make sense
to compute the value at <span class="math inline">x</span> of a power
series? Does it make sense to fold an infinite list?</p>
<p>If the power series converges for <span class="math inline">x &gt;
1</span>, then when the elements <span class="math inline">a_n</span>
get small, the remaining sum <span
class="math inline">\sum_{i=n}^{\infty} a_i x^i</span> is also
small.</p>
<p><code>lfold_right</code> falls into an infinite loop on infinite
lists. We need call-by-name / call-by-need semantics for the argument
function <code>f</code>:</p>
<pre><code>let rec lazy_foldr f l base =
  match l with
    | LNil -&gt; base
    | LCons (a, ll) -&gt;
      f a (lazy (lazy_foldr f (Lazy.force ll) base))</code></pre>
<p>We need a stopping condition in the Horner algorithm step:</p>
<pre><code>let lhorner x l =                         (* This is a bit of a hack, *)
  let upd c sum =                         (* we hope to &quot;hit&quot; the interval (0, epsilon]. *)
    if c = 0. || abs_float c &gt; epsilon_float
    then c +. x *. Lazy.force sum
    else 0. in
  lazy_foldr upd l 0.

let inv_fact = lmap (fun n -&gt; 1. /. float_of_int n) lfact
let e = lhorner 1. inv_fact</code></pre>
<h4 id="power-series-polynomial-operations">7.4.1 Power Series /
Polynomial Operations</h4>
<pre><code>let rec add xs ys =
  match xs, ys with
    | LNil, _ -&gt; ys
    | _, LNil -&gt; xs
    | LCons (x,xs), LCons (y,ys) -&gt;
      LCons (x +. y, lazy (add (Lazy.force xs) (Lazy.force ys)))

let rec sub xs ys =
  match xs, ys with
    | LNil, _ -&gt; lmap (fun x -&gt; -.x) ys
    | _, LNil -&gt; xs
    | LCons (x,xs), LCons (y,ys) -&gt;
      LCons (x -. y, lazy (add (Lazy.force xs) (Lazy.force ys)))

let scale s = lmap (fun x -&gt; s *. x)

let rec shift n xs =
  if n = 0 then xs
  else if n &gt; 0 then LCons (0., lazy (shift (n-1) xs))
  else match xs with
    | LNil -&gt; LNil
    | LCons (0., lazy xs) -&gt; shift (n+1) xs
    | _ -&gt; failwith &quot;shift: fractional division&quot;

let rec mul xs = function
  | LNil -&gt; LNil
  | LCons (y, ys) -&gt;
    add (scale y xs) (LCons (0., lazy (mul xs (Lazy.force ys))))

let rec div xs ys =
  match xs, ys with
  | LNil, _ -&gt; LNil
  | LCons (0., xs&#39;), LCons (0., ys&#39;) -&gt;
    div (Lazy.force xs&#39;) (Lazy.force ys&#39;)
  | LCons (x, xs&#39;), LCons (y, ys&#39;) -&gt;
    let q = x /. y in
    LCons (q, lazy (div (sub (Lazy.force xs&#39;)
                                 (scale q (Lazy.force ys&#39;))) ys))
  | LCons _, LNil -&gt; failwith &quot;div: division by zero&quot;

let integrate c xs =
  LCons (c, lazy (lmap (uncurry (/.)) (lzip (xs, posnums))))

let ltail = function
  | LNil -&gt; invalid_arg &quot;ltail&quot;
  | LCons (_, lazy tl) -&gt; tl

let differentiate xs =
  lmap (uncurry ( *.)) (lzip (ltail xs, posnums))</code></pre>
<h4 id="differential-equations">7.4.2 Differential Equations</h4>
<p>Consider the differential equations for sine and cosine:</p>
<p><span class="math display">\frac{d \sin x}{dx} = \cos x, \quad
\frac{d \cos x}{dx} = -\sin x, \quad \sin 0 = 0, \quad \cos 0 =
1</span></p>
<p>We will solve the corresponding integral equations. We cannot define
the integral by direct recursion like this:</p>
<pre><code>let (~-:) = lmap (fun x -&gt; -.x)  (* Unary negation for series *)

let rec sin = integrate (of_int 0) cos
and cos = integrate (of_int 1) (~-:sin)</code></pre>
<p>Unfortunately this fails with:
<code>Error: This kind of expression is not allowed as right-hand side of 'let rec'</code></p>
<p>Even changing the second argument of <code>integrate</code> to
call-by-need does not help, because OCaml cannot represent the values
that <code>sin</code> and <code>cos</code> refer to at the point of
their definition.</p>
<p>We need to inline a bit of <code>integrate</code> so that OCaml knows
how to start building the recursive structure:</p>
<pre><code>let integ xs = lmap (uncurry (/.)) (lzip (xs, posnums))

let rec sin = LCons (of_int 0, lazy (integ cos))
and cos = LCons (of_int 1, lazy (integ (~-:sin)))</code></pre>
<p>The complete example would look much more elegant in Haskell, where
all values are lazy by default.</p>
<p>Although this approach is not limited to linear equations, equations
like Lotka-Volterra or Lorentz are not “solvable” this way – computed
coefficients quickly grow instead of quickly falling.</p>
<p>Drawing functions work like in the previous lecture, but with open
curves:</p>
<pre><code>let plot_1D f ~w ~scale ~t_beg ~t_end =
  let dt = (t_end -. t_beg) /. of_int w in
  Array.init w (fun i -&gt;
    let y = lhorner (dt *. of_int i) f in
    i, to_int (scale *. y))</code></pre>
<h3 id="arbitrary-precision-computation">7.5 Arbitrary Precision
Computation</h3>
<p>Putting together the power series computation with floating-point
numbers reveals drastic numerical errors for large <span
class="math inline">x</span>. Floating-point numbers have limited
precision, and we break out of Horner method computations too
quickly.</p>
<p>For infinite precision on rational numbers we use the
<code>nums</code> library – but it does not help by itself.</p>
<p>We need to generate a sequence of approximations to the power series
limit at <span class="math inline">x</span>:</p>
<pre><code>let infhorner x l =
  let upd c sum =
    LCons (c, lazy (lmap (fun apx -&gt; c +. x *. apx)
                      (Lazy.force sum))) in
  lazy_foldr upd l (LCons (of_int 0, lazy LNil))</code></pre>
<p>Find where the series converges – as far as a given test is
concerned:</p>
<pre><code>let rec exact f = function           (* We arbitrarily decide that convergence is *)
  | LNil -&gt; assert false             (* when three consecutive results are the same. *)
  | LCons (x0, lazy (LCons (x1, lazy (LCons (x2, _)))))
      when f x0 = f x1 &amp;&amp; f x0 = f x2 -&gt; f x0
  | LCons (_, lazy tl) -&gt; exact f tl</code></pre>
<p>Draw the pixels of the graph at exact coordinates:</p>
<pre><code>let plot_1D f ~w ~h0 ~scale ~t_beg ~t_end =
  let dt = (t_end -. t_beg) /. of_int w in
  let eval = exact (fun y -&gt; to_int (scale *. y)) in
  Array.init w (fun i -&gt;
    let y = infhorner (t_beg +. dt *. of_int i) f in
    i, h0 + eval y)</code></pre>
<p>If a power series had every third term contributing we would have to
check three terms in the function <code>exact</code>. We could also test
for <code>f x0 = f x1 &amp;&amp; not (x0 =. x1)</code> like in
<code>lhorner</code>.</p>
<h4 id="example-nuclear-chain-reaction">7.5.1 Example: Nuclear Chain
Reaction</h4>
<p>Consider a nuclear chain reaction where substance A decays into B,
which decays into C. The differential equations are:</p>
<p><span class="math display">\frac{dN_A}{dt} = -\lambda_A N_A, \quad
\frac{dN_B}{dt} = \lambda_A N_A - \lambda_B N_B</span></p>
<pre><code>let n_chain ~nA0 ~nB0 ~lA ~lB =
  let rec nA =
    LCons (nA0, lazy (integ (~-.lA *:. nA)))
  and nB =
    LCons (nB0, lazy (integ (~-.lB *:. nB +: lA *:. nA))) in
  nA, nB</code></pre>
<p>(See <a
href="http://en.wikipedia.org/wiki/Radioactive_decay#Chain-decay_processes">Radioactive
decay chain processes</a> for more information.)</p>
<h3 id="circular-data-structures-double-linked-lists">7.6 Circular Data
Structures: Double-Linked Lists</h3>
<p>Without delayed computation, the ability to define data structures
with referential cycles is very limited.</p>
<p>Double-linked lists contain such cycles between any two nodes even if
they are not cyclic when following only <em>forward</em> or
<em>backward</em> links:</p>
<pre><code>+--------+     +--------+     +--------+     +--------+     +--------+
| DLNil  | &lt;-&gt; |   a1   | &lt;-&gt; |   a2   | &lt;-&gt; |   a3   | &lt;-&gt; | DLNil  |
+--------+     +--------+     +--------+     +--------+     +--------+</code></pre>
<p>We need to “break” the cycles by making some links lazy:</p>
<pre><code>type &#39;a dllist =
  DLNil | DLCons of &#39;a dllist Lazy.t * &#39;a * &#39;a dllist</code></pre>
<pre><code>let rec dldrop n l =
  match l with
    | DLCons (_, x, xs) when n &gt; 0 -&gt;
       dldrop (n-1) xs
    | _ -&gt; l</code></pre>
<p>Creating a double-linked list from a regular list:</p>
<pre><code>let dllist_of_list l =
  let rec dllist prev l =
    match l with
      | [] -&gt; DLNil
      | x::xs -&gt;
        let rec cell =
          lazy (DLCons (prev, x, dllist cell xs)) in
        Lazy.force cell in
  dllist (lazy DLNil) l</code></pre>
<p>Taking elements going forward:</p>
<pre><code>let rec dltake n l =
  match l with
    | DLCons (_, x, xs) when n &gt; 0 -&gt;
       x :: dltake (n-1) xs
    | _ -&gt; []</code></pre>
<p>Taking elements going backward:</p>
<pre><code>let rec dlbackwards n l =
  match l with
    | DLCons (lazy xs, x, _) when n &gt; 0 -&gt;
      x :: dlbackwards (n-1) xs
    | _ -&gt; []</code></pre>
<h3 id="input-output-streams">7.7 Input-Output Streams</h3>
<p>The stream type used a throwaway argument to make a suspension:</p>
<pre><code>type &#39;a stream = SNil | SCons of &#39;a * (unit -&gt; &#39;a stream)</code></pre>
<p>What if we take a real argument?</p>
<pre><code>type (&#39;a, &#39;b) iostream =
  EOS | More of &#39;b * (&#39;a -&gt; (&#39;a, &#39;b) iostream)</code></pre>
<p>This is a stream that for a single input value produces an output
value.</p>
<pre><code>type &#39;a istream = (unit, &#39;a) iostream  (* Input stream produces output when &quot;asked&quot;. *)
type &#39;a ostream = (&#39;a, unit) iostream  (* Output stream consumes provided input. *)</code></pre>
<p>(The confusion arises from adapting the <em>input file / output
file</em> terminology, also used for streams.)</p>
<p>We can compose streams: directing output of one to input of
another.</p>
<pre><code>let rec compose sf sg =
  match sg with
  | EOS -&gt; EOS                              (* No more output. *)
  | More (z, g) -&gt;
    match sf with
    | EOS -&gt; More (z, fun _ -&gt; EOS)         (* No more input &quot;processing power&quot;. *)
    | More (y, f) -&gt;
      let update x = compose (f x) (g y) in
      More (z, update)</code></pre>
<p>Every box has one incoming and one outgoing wire. Notice how the
output stream is ahead of the input stream.</p>
<h3 id="pipes">7.8 Pipes</h3>
<p>We need a more flexible input-output stream definition: - Consume
several inputs to produce a single output. - Produce several outputs
after a single input (or even without input). - No need for a dummy when
producing output requires input.</p>
<p>After Haskell, we call the data structure <code>pipe</code>:</p>
<pre><code>type (&#39;a, &#39;b) pipe =
  EOP                                       (* End of pipe *)
| Yield of &#39;b * (&#39;a, &#39;b) pipe               (* For incremental streams change to lazy. *)
| Await of (&#39;a -&gt; (&#39;a, &#39;b) pipe)</code></pre>
<p>Again, we can have producing output only <em>input pipes</em> and
consuming input only <em>output pipes</em>:</p>
<pre><code>type &#39;a ipipe = (unit, &#39;a) pipe
type void
type &#39;a opipe = (&#39;a, void) pipe</code></pre>
<p>Why <code>void</code> rather than <code>unit</code>, and why only for
<code>opipe</code>? Because an output pipe never yields values – if it
used <code>unit</code> as the output type, it could still yield
<code>()</code> values, but with the abstract <code>void</code> type, it
cannot yield anything.</p>
<h4 id="pipe-composition">7.8.1 Pipe Composition</h4>
<p>Composition of pipes is like “concatenating them in space” or
connecting boxes:</p>
<pre><code>let rec compose pf pg =
  match pg with
  | EOP -&gt; EOP                              (* Done producing results. *)
  | Yield (z, pg&#39;) -&gt; Yield (z, compose pf pg&#39;)   (* Ready result. *)
  | Await g -&gt;
    match pf with
    | EOP -&gt; EOP                            (* End of input. *)
    | Yield (y, pf&#39;) -&gt; compose pf&#39; (g y)   (* Compute next result. *)
    | Await f -&gt;
      let update x = compose (f x) pg in
      Await update                          (* Wait for more input. *)

let (&gt;-&gt;) pf pg = compose pf pg</code></pre>
<p>Appending pipes means “concatenating them in time” or adding more
fuel to a box:</p>
<pre><code>let rec append pf pg =
  match pf with
  | EOP -&gt; pg                               (* When pf runs out, use pg. *)
  | Yield (z, pf&#39;) -&gt; Yield (z, append pf&#39; pg)
  | Await f -&gt;                              (* If pf awaits input, continue when it comes. *)
    let update x = append (f x) pg in
    Await update</code></pre>
<p>Append a list of ready results in front of a pipe:</p>
<pre><code>let rec yield_all l tail =
  match l with
  | [] -&gt; tail
  | x::xs -&gt; Yield (x, yield_all xs tail)</code></pre>
<p>Iterate a pipe (<strong>not functional</strong> – performs side
effects):</p>
<pre><code>let rec iterate f : &#39;a opipe =
  Await (fun x -&gt; let () = f x in iterate f)</code></pre>
<h3 id="example-pretty-printing">7.9 Example: Pretty-Printing</h3>
<p>Print a hierarchically organized document with a limited line
width.</p>
<pre><code>type doc =
  Text of string | Line | Cat of doc * doc | Group of doc</code></pre>
<pre><code>let (++) d1 d2 = Cat (d1, Cat (Line, d2))
let (!) s = Text s

let test_doc =
  Group (!&quot;Document&quot; ++
            Group (!&quot;First part&quot; ++ !&quot;Second part&quot;))</code></pre>
<p>Example output with different widths:</p>
<pre><code># let () = print_endline (pretty 30 test_doc);;
Document
First part Second part

# let () = print_endline (pretty 20 test_doc);;
Document
First part
Second part

# let () = print_endline (pretty 60 test_doc);;
Document First part Second part</code></pre>
<h4 id="straightforward-solution">7.9.1 Straightforward Solution</h4>
<pre><code>let pretty w d =                            (* Allowed width of line w. *)
  let rec width = function                  (* Total length of subdocument. *)
    | Text z -&gt; String.length z
    | Line -&gt; 1
    | Cat (d1, d2) -&gt; width d1 + width d2
    | Group d -&gt; width d in
  let rec format f r = function             (* Remaining space r. *)
    | Text z -&gt; z, r - String.length z
    | Line when f -&gt; &quot; &quot;, r-1               (* If not f then line breaks. *)
    | Line -&gt; &quot;\n&quot;, w
    | Cat (d1, d2) -&gt;
      let s1, r = format f r d1 in
      let s2, r = format f r d2 in
      s1 ^ s2, r                            (* If following group fits, then without line breaks. *)
    | Group d -&gt; format (f || width d &lt;= r) r d in
  fst (format false w d)</code></pre>
<h4 id="stream-based-solution">7.9.2 Stream-Based Solution</h4>
<p>Working with a stream of nodes:</p>
<pre><code>type (&#39;a, &#39;b) doc_e =                       (* Annotated nodes, special for group beginning. *)
  TE of &#39;a * string | LE of &#39;a | GBeg of &#39;b | GEnd of &#39;a</code></pre>
<p>Normalize a subdocument – remove empty groups:</p>
<pre><code>let rec norm = function
  | Group d -&gt; norm d
  | Text &quot;&quot; -&gt; None
  | Cat (Text &quot;&quot;, d) -&gt; norm d
  | d -&gt; Some d</code></pre>
<p>Generate the stream by infix traversal:</p>
<pre><code>let rec gen = function
  | Text z -&gt; Yield (TE ((),z), EOP)
  | Line -&gt; Yield (LE (), EOP)
  | Cat (d1, d2) -&gt; append (gen d1) (gen d2)
  | Group d -&gt;
    match norm d with
    | None -&gt; EOP
    | Some d -&gt;
      Yield (GBeg (),
             append (gen d) (Yield (GEnd (), EOP)))</code></pre>
<p>Compute lengths of document prefixes, i.e. the position of each node
counting by characters from the beginning of document:</p>
<pre><code>let rec docpos curpos =
  Await (function                           (* We input from a doc_e pipe *)
  | TE (_, z) -&gt;
    Yield (TE (curpos, z),                  (* and output doc_e annotated with position. *)
           docpos (curpos + String.length z))
  | LE _ -&gt;                                 (* Space and line breaks increase position by 1. *)
    Yield (LE curpos, docpos (curpos + 1))
  | GBeg _ -&gt;                               (* Groups do not increase position. *)
    Yield (GBeg curpos, docpos curpos)
  | GEnd _ -&gt;
    Yield (GEnd curpos, docpos curpos))

let docpos = docpos 0                       (* The whole document starts at 0. *)</code></pre>
<p>Put the end position of the group into the group beginning marker, so
that we can know whether to break it into multiple lines:</p>
<pre><code>let rec grends grstack =
  Await (function
  | TE _ | LE _ as e -&gt;
    (match grstack with
    | [] -&gt; Yield (e, grends [])            (* We can yield only when *)
    | gr::grs -&gt; grends ((e::gr)::grs))     (* no group is waiting. *)
  | GBeg _ -&gt; grends ([]::grstack)          (* Wait for end of group. *)
  | GEnd endp -&gt;
    match grstack with                      (* End the group on top of stack. *)
    | [] -&gt; failwith &quot;grends: unmatched group end marker&quot;
    | [gr] -&gt;                               (* Top group -- we can yield now. *)
      yield_all
        (GBeg endp::List.rev (GEnd endp::gr))
        (grends [])
    | gr::par::grs -&gt;                       (* Remember in parent group instead. *)
      let par = GEnd endp::gr @ [GBeg endp] @ par in
      grends (par::grs))                    (* Could use catenable lists above. *)</code></pre>
<p>That’s waiting too long! We can stop waiting when the width of a
group exceeds the line limit. <code>GBeg</code> will not store end of
group when it is irrelevant:</p>
<pre><code>type grp_pos = Pos of int | Too_far

let rec grends w grstack =
  let flush tail =                          (* When the stack exceeds width w, *)
    yield_all                               (* flush it -- yield everything in it. *)
      (rev_concat_map ~prep:(GBeg Too_far) snd grstack)
      tail in                               (* Above: concatenate in rev. with prep before each part. *)
  Await (function
  | TE (curp, _) | LE curp as e -&gt;
    (match grstack with                     (* Remember beginning of groups in the stack. *)
    | [] -&gt; Yield (e, grends w [])
    | (begp, _)::_ when curp-begp &gt; w -&gt;
      flush (Yield (e, grends w []))
    | (begp, gr)::grs -&gt; grends w ((begp, e::gr)::grs))
  | GBeg begp -&gt; grends w ((begp, [])::grstack)
  | GEnd endp as e -&gt;
    match grstack with                      (* No longer fail when the stack is empty -- *)
    | [] -&gt; Yield (e, grends w [])          (* could have been flushed. *)
    | (begp, _)::_ when endp-begp &gt; w -&gt;
      flush (Yield (e, grends w []))
    | [_, gr] -&gt;                            (* If width not exceeded, *)
      yield_all                             (* work as before optimization. *)
        (GBeg (Pos endp)::List.rev (GEnd endp::gr))
        (grends w [])
    | (_, gr)::(par_begp, par)::grs -&gt;
      let par =
        GEnd endp::gr @ [GBeg (Pos endp)] @ par in
      grends w ((par_begp, par)::grs))

let grends w = grends w []                  (* Initial stack is empty. *)</code></pre>
<p>Finally we produce the resulting stream of strings:</p>
<pre><code>let rec format w (inline, endlpos as st) =  (* State: the stack of *)
  Await (function                           (* &quot;group fits in line&quot;; position where end of line would be. *)
  | TE (_, z) -&gt; Yield (z, format w st)
  | LE p when List.hd inline -&gt;
    Yield (&quot; &quot;, format w st)                (* After return, line has w free space. *)
  | LE p -&gt; Yield (&quot;\n&quot;, format w (inline, p+w))
  | GBeg Too_far -&gt;                         (* Group with end too far is not inline. *)
    format w (false::inline, endlpos)
  | GBeg (Pos p) -&gt;                         (* Group is inline if it ends soon enough. *)
    format w ((p&lt;=endlpos)::inline, endlpos)
  | GEnd _ -&gt; format w (List.tl inline, endlpos))

let format w = format w ([false], w)        (* Break lines outside of groups. *)</code></pre>
<p>Put the pipes together:</p>
<pre><code>+--------+     +-------+     +---------+     +--------+     +----------------+
| gen doc| --&gt; |docpos | --&gt; |grends w | --&gt; |format w| --&gt; |iterate print_s |
+--------+     +-------+     +---------+     +--------+     +----------------+</code></pre>
<h4 id="factored-solution">7.9.3 Factored Solution</h4>
<p>Factorize <code>format</code> so that various line breaking styles
can be plugged in:</p>
<pre><code>let rec breaks w (inline, endlpos as st) =
  Await (function
  | TE _ as e -&gt; Yield (e, breaks w st)
  | LE p when List.hd inline -&gt;
    Yield (TE (p, &quot; &quot;), breaks w st)
  | LE p as e -&gt; Yield (e, breaks w (inline, p+w))
  | GBeg Too_far as e -&gt;
    Yield (e, breaks w (false::inline, endlpos))
  | GBeg (Pos p) as e -&gt;
    Yield (e, breaks w ((p&lt;=endlpos)::inline, endlpos))
  | GEnd _ as e -&gt;
    Yield (e, breaks w (List.tl inline, endlpos)))

let breaks w = breaks w ([false], w)

let rec emit =
  Await (function
  | TE (_, z) -&gt; Yield (z, emit)
  | LE _ -&gt; Yield (&quot;\n&quot;, emit)
  | GBeg _ | GEnd _ -&gt; emit)

let pretty_print w doc =
  gen doc &gt;-&gt; docpos &gt;-&gt; grends w &gt;-&gt; breaks w &gt;-&gt;
  emit &gt;-&gt; iterate print_string</code></pre>
<h3 id="exercises-6">7.10 Exercises</h3>
<p><strong>Exercise 1:</strong> My first impulse was to define lazy list
functions as follows:</p>
<pre><code>let rec wrong_lzip = function
  | LNil, LNil -&gt; LNil
  | LCons (a1, lazy l1), LCons (a2, lazy l2) -&gt;
      LCons ((a1, a2), lazy (wrong_lzip (l1, l2)))
  | _ -&gt; raise (Invalid_argument &quot;lzip&quot;)

let rec wrong_lmap f = function
  | LNil -&gt; LNil
  | LCons (a, lazy l) -&gt; LCons (f a, lazy (wrong_lmap f l))</code></pre>
<p>What is wrong with these definitions – for which edge cases do they
not work as intended?</p>
<p><strong>Exercise 2:</strong> Cyclic lazy lists.</p>
<ol type="1">
<li><p>Implement a function <code>cycle : 'a list -&gt; 'a llist</code>
that creates a lazy list with elements from a standard list, and the
whole list as the tail after the last element from the input list:
<code>[a1; a2; ...; aN]</code> maps to a cyclic structure where
<code>aN</code> points back to <code>a1</code>. Your function
<code>cycle</code> can either return <code>LNil</code> or fail for an
empty list as argument.</p></li>
<li><p>Note that <code>inv_fact</code> from the lecture defines the
power series for the <span class="math inline">\exp(\cdot)</span>
function (<span class="math inline">\exp(x) = e^x</span>). Using
<code>cycle</code> and <code>inv_fact</code>, define the power series
for <span class="math inline">\sin(\cdot)</span> and <span
class="math inline">\cos(\cdot)</span>, and draw their graphs using
helper functions from the lecture script <code>Lec7.ml</code>.</p></li>
</ol>
<p><strong>Exercise 3:</strong> Modify one of the puzzle solving
programs (either from the previous lecture or from your previous
homework) to work with lazy lists. Implement the necessary higher-order
lazy list functions. Check that indeed displaying only the first
solution when there are multiple solutions in the result takes shorter
than computing solutions by the original program.</p>
<p><strong>Exercise 4:</strong> <em>Hamming’s problem</em>. Generate in
increasing order the numbers of the form <span
class="math inline">2^{a_1} 3^{a_2} 5^{a_3} \ldots p_k^{a_k}</span>,
that is numbers not divisible by prime numbers greater than the <span
class="math inline">k</span>th prime number.</p>
<p>In the original Hamming’s problem posed by Dijkstra, <span
class="math inline">k = 3</span>, which is related to <a
href="http://en.wikipedia.org/wiki/Regular_number">regular
numbers</a>.</p>
<p>Starter code is available in the lecture script
<code>Lec7.ml</code>:</p>
<pre><code>let rec lfilter f = function
  | LNil -&gt; LNil
  | LCons (n, ll) -&gt;
      if f n then LCons (n, lazy (lfilter f (Lazy.force ll)))
      else lfilter f (Lazy.force ll)

let primes =
  let rec sieve = function
    | LCons(p, nf) -&gt;
        LCons(p, lazy (sieve (sift p (Lazy.force nf))))
    | LNil -&gt; failwith &quot;Impossible! Internal error.&quot;
  and sift p = lfilter (fun n -&gt; n mod p &lt;&gt; 0)
  in sieve (l_from 2)

let times ll n = lmap (fun i -&gt; i * n) ll

let rec merge xs ys =
  match xs, ys with
  | LCons (x, lazy xr), LCons (y, lazy yr) -&gt;
      if x &lt; y then LCons (x, lazy (merge xr ys))
      else if x &gt; y then LCons (y, lazy (merge xs yr))
      else LCons (x, lazy (merge xr yr))
  | r, LNil | LNil, r -&gt; r

let hamming k =
  let pr = ltake k primes in
  let rec h = LCons (1, lazy (
     (* TODO *)
  )) in h</code></pre>
<p><strong>Exercise 5:</strong> Modify <code>format</code> and/or
<code>breaks</code> to use just a single number instead of a stack of
booleans to keep track of what groups should be inlined.</p>
<p><strong>Exercise 6:</strong> Add <strong>indentation</strong> to the
pretty-printer for groups: if a group does not fit in a single line, its
consecutive lines are indented by a given amount <code>tab</code> of
spaces deeper than its parent group lines would be. For comparison,
let’s do several implementations.</p>
<ol type="1">
<li>Modify the straightforward implementation of
<code>pretty</code>.</li>
<li>Modify the first pipe-based implementation of <code>pretty</code> by
modifying the <code>format</code> function.</li>
<li>Modify the second pipe-based implementation of <code>pretty</code>
by modifying the <code>breaks</code> function. Recover the positions of
elements – the number of characters from the beginning of the document –
by keeping track of the growing offset.</li>
<li>(Harder) Modify a pipe-based implementation to provide a different
style of indentation: indent the first line of a group, when the group
starts on a new line, at the same level as the consecutive lines (rather
than at the parent level of indentation).</li>
</ol>
<p><strong>Exercise 7:</strong> Write a pipe that takes document
elements annotated with linear position, and produces document elements
annotated with (line, column) coordinates.</p>
<p>Write another pipe that takes so annotated elements and adds a line
number indicator in front of each line. Do not update the column
coordinate. Test the pipes by plugging them before the <code>emit</code>
pipe.</p>
<pre><code>1: first line
2: second line, etc.</code></pre>
<p><strong>Exercise 8:</strong> Write a pipe that consumes document
elements <code>doc_e</code> and yields the toplevel subdocuments
<code>doc</code> which would generate the corresponding elements.</p>
<p>You can modify the definition of documents to allow annotations, so
that the element annotations are preserved (<code>gen</code> should
ignore annotations to keep things simple):</p>
<pre><code>type &#39;a doc =
  Text of &#39;a * string | Line of &#39;a | Cat of doc * doc | Group of &#39;a * doc</code></pre>
<p><strong>Exercise 9:</strong> (Harder) Design and implement a way to
duplicate arrows outgoing from a pipe-box, that would memoize the
stream, i.e. not recompute everything “upstream” for the composition of
pipes. Such duplicated arrows would behave nicely with pipes reading
from files.</p>
<h2 id="chapter-8-monads">Chapter 8: Monads</h2>
<p>This chapter explores one of functional programming’s most powerful
abstractions: monads. We begin with list comprehensions, introduce
monadic concepts, examine monad laws and the monad-plus extension, then
work through various monad instances including state, exception, and
probability monads. We conclude with monad transformers and cooperative
lightweight threads.</p>
<h3 id="list-comprehensions">8.1 List Comprehensions</h3>
<p>Recall the somewhat awkward syntax we used in the Countdown Problem
example from earlier chapters. The brute-force generation of expressions
looked like this:</p>
<pre><code>let combine l r =
  List.map (fun o -&gt; App (o, l, r)) [Add; Sub; Mul; Div]

let rec exprs = function
  | [] -&gt; []
  | [n] -&gt; [Val n]
  | ns -&gt;
      split ns |-&gt; (fun (ls, rs) -&gt;
      exprs ls |-&gt; (fun l -&gt;
      exprs rs |-&gt; (fun r -&gt;
      combine l r)))</code></pre>
<p>And the generate-and-test scheme used:</p>
<pre><code>let guard p e = if p e then [e] else []

let solutions ns n =
  choices ns |-&gt; (fun ns&#39; -&gt;
  exprs ns&#39; |-&gt;
    guard (fun e -&gt; eval e = Some n))</code></pre>
<p>We introduced the operator <code>|-&gt;</code> defined as:</p>
<pre><code>let ( |-&gt; ) x f = concat_map f x</code></pre>
<p>We can do much better with list comprehensions syntax extension. In
older versions of OCaml with Camlp4, this was loaded via:</p>
<pre><code>#load &quot;dynlink.cma&quot;;;
#load &quot;camlp4o.cma&quot;;;
#load &quot;Camlp4Parsers/Camlp4ListComprehension.cmo&quot;;;</code></pre>
<p>With list comprehensions, we can write:</p>
<pre><code>let test = [i * 2 | i &lt;- from_to 2 22; i mod 3 = 0]</code></pre>
<p>The translation rules for list comprehensions are:</p>
<ul>
<li><code>[expr | ]</code> translates to <code>[expr]</code></li>
<li><code>[expr | v &lt;- generator; more]</code> translates to
<code>generator |-&gt; (fun v -&gt; [expr | more])</code></li>
<li><code>[expr | condition; more]</code> translates to
<code>if condition then [expr | more] else []</code></li>
</ul>
<h4 id="revisiting-countdown-with-list-comprehensions">Revisiting
Countdown with List Comprehensions</h4>
<p>The brute-force generation becomes cleaner:</p>
<pre><code>let rec exprs = function
  | [] -&gt; []
  | [n] -&gt; [Val n]
  | ns -&gt;
      [App (o, l, r) | (ls, rs) &lt;- split ns;
       l &lt;- exprs ls; r &lt;- exprs rs;
       o &lt;- [Add; Sub; Mul; Div]]</code></pre>
<p>And the generate-and-test scheme simplifies to:</p>
<pre><code>let solutions ns n =
  [e | ns&#39; &lt;- choices ns;
   e &lt;- exprs ns&#39;; eval e = Some n]</code></pre>
<h4 id="more-list-comprehension-examples">More List Comprehension
Examples</h4>
<p>Computing subsequences using list comprehensions (with some garbage
generation):</p>
<pre><code>let rec subseqs l =
  match l with
  | [] -&gt; [[]]
  | x::xs -&gt; [ys | px &lt;- subseqs xs; ys &lt;- [px; x::px]]</code></pre>
<p>Computing permutations via insertion:</p>
<pre><code>let rec insert x = function
  | [] -&gt; [[x]]
  | y::ys&#39; as ys -&gt;
      (x::ys) :: [y::zs | zs &lt;- insert x ys&#39;]

let rec ins_perms = function
  | [] -&gt; [[]]
  | x::xs -&gt; [zs | ys &lt;- ins_perms xs; zs &lt;- insert x ys]</code></pre>
<p>And via selection:</p>
<pre><code>let rec select = function
  | [x] -&gt; [x, []]
  | x::xs -&gt; (x, xs) :: [y, x::ys | y, ys &lt;- select xs]

let rec sel_perms = function
  | [] -&gt; [[]]
  | xs -&gt; [x::ys | x, xs&#39; &lt;- select xs; ys &lt;- sel_perms xs&#39;]</code></pre>
<h3 id="generalized-comprehensions-do-notation">8.2 Generalized
Comprehensions: Do-Notation</h3>
<p>To use a more general syntax extension, we need
<code>pa_monad</code>. With it, the expression generation code
becomes:</p>
<pre><code>let rec exprs = function
  | [] -&gt; []
  | [n] -&gt; [Val n]
  | ns -&gt;
      perform with (|-&gt;) in
        (ls, rs) &lt;-- split ns;
        l &lt;-- exprs ls; r &lt;-- exprs rs;
        o &lt;-- [Add; Sub; Mul; Div];
        [App (o, l, r)]</code></pre>
<p>The <code>perform</code> syntax does not directly support guards. If
we try to write:</p>
<pre><code>let solutions ns n =
  perform with (|-&gt;) in
    ns&#39; &lt;-- choices ns;
    e &lt;-- exprs ns&#39;;
    eval e = Some n;  (* Error! *)
    e</code></pre>
<p>We get an error because it expects a list, not a boolean. We can work
around this by deciding whether to return anything:</p>
<pre><code>let solutions ns n =
  perform with (|-&gt;) in
    ns&#39; &lt;-- choices ns;
    e &lt;-- exprs ns&#39;;
    if eval e = Some n then [e] else []</code></pre>
<p>For a general guard check function, we define:</p>
<pre><code>let guard p = if p then [()] else []</code></pre>
<p>And then:</p>
<pre><code>let solutions ns n =
  perform with (|-&gt;) in
    ns&#39; &lt;-- choices ns;
    e &lt;-- exprs ns&#39;;
    guard (eval e = Some n);
    [e]</code></pre>
<h3 id="monads">8.3 Monads</h3>
<p>A monad is a polymorphic type <code>'a monad</code> (or
<code>'a Monad.t</code>) that supports at least two operations:</p>
<ul>
<li><code>bind : 'a monad -&gt; ('a -&gt; 'b monad) -&gt; 'b monad</code></li>
<li><code>return : 'a -&gt; 'a monad</code></li>
<li>The infix <code>&gt;&gt;=</code> is commonly used for
<code>bind</code>: <code>let (&gt;&gt;=) a b = bind a b</code></li>
</ul>
<p>With <code>bind</code> in scope, we do not need the <code>with</code>
clause in <code>perform</code>:</p>
<pre><code>let bind a b = concat_map b a
let return x = [x]

let solutions ns n =
  perform
    ns&#39; &lt;-- choices ns;
    e &lt;-- exprs ns&#39;;
    guard (eval e = Some n);
    return e</code></pre>
<p>Why does <code>guard</code> look this way? Let us examine:</p>
<pre><code>let fail = []
let guard p = if p then return () else fail</code></pre>
<p>Steps in monadic computation are composed with <code>&gt;&gt;=</code>
(like <code>|-&gt;</code> for lists). The key insight is:</p>
<ul>
<li><code>[] |-&gt; ...</code> does not produce anything – as needed by
guarding</li>
<li><code>[()] |-&gt; ...</code> becomes
<code>(fun _ -&gt; ...) ()</code> which simply continues the computation
unchanged</li>
</ul>
<p>Throwing away the binding argument is common, with infix syntax
<code>&gt;&gt;</code> in Haskell:</p>
<pre><code>let (&gt;&gt;) m f = m &gt;&gt;= (fun _ -&gt; f)</code></pre>
<h4 id="the-perform-syntax-in-depth">The Perform Syntax in Depth</h4>
<p>The <code>perform</code> syntax translates as follows:</p>
<table>
<colgroup>
<col style="width: 38%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr>
<th>Source</th>
<th>Translation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>perform exp</code></td>
<td><code>exp</code></td>
</tr>
<tr>
<td><code>perform pat &lt;-- exp; rest</code></td>
<td><code>bind exp (fun pat -&gt; perform rest)</code></td>
</tr>
<tr>
<td><code>perform exp; rest</code></td>
<td><code>bind exp (fun _ -&gt; perform rest)</code></td>
</tr>
<tr>
<td><code>perform let ... in rest</code></td>
<td><code>let ... in perform rest</code></td>
</tr>
<tr>
<td><code>perform rpt &lt;-- exp; rest</code></td>
<td><code>bind exp (function \| rpt -&gt; perform rest \| _ -&gt; failwith "pattern match")</code></td>
</tr>
<tr>
<td><code>perform with b [and f] in body</code></td>
<td>Uses <code>b</code> instead of <code>bind</code> and <code>f</code>
instead of <code>failwith</code></td>
</tr>
</tbody>
</table>
<p>It can be useful to redefine <code>let failwith _ = fail</code> so
that pattern match failures behave like guard failures.</p>
<h3 id="monad-laws">8.4 Monad Laws</h3>
<p>A parametric data type is a monad only if its <code>bind</code> and
<code>return</code> operations meet these axioms:</p>
<p><span class="math display">
\begin{aligned}
\text{bind}\ (\text{return}\ a)\ f &amp;\approx f\ a &amp; \text{(left
identity)} \\
\text{bind}\ a\ (\lambda x.\text{return}\ x) &amp;\approx a &amp;
\text{(right identity)} \\
\text{bind}\ (\text{bind}\ a\ (\lambda x.b))\ (\lambda y.c) &amp;\approx
\text{bind}\ a\ (\lambda x.\text{bind}\ b\ (\lambda y.c)) &amp;
\text{(associativity)}
\end{aligned}
</span></p>
<p>You should verify that these laws hold for our list monad:</p>
<pre><code>let bind a b = concat_map b a
let return x = [x]</code></pre>
<h3 id="monoid-laws-and-monad-plus">8.5 Monoid Laws and Monad-Plus</h3>
<p>A monoid is a type with at least two operations:</p>
<ul>
<li><code>mzero : 'a monoid</code></li>
<li><code>mplus : 'a monoid -&gt; 'a monoid -&gt; 'a monoid</code></li>
</ul>
<p>that meet these laws:</p>
<p><span class="math display">
\begin{aligned}
\text{mplus}\ \text{mzero}\ a &amp;\approx a &amp; \text{(left
identity)} \\
\text{mplus}\ a\ \text{mzero} &amp;\approx a &amp; \text{(right
identity)} \\
\text{mplus}\ a\ (\text{mplus}\ b\ c) &amp;\approx \text{mplus}\
(\text{mplus}\ a\ b)\ c &amp; \text{(associativity)}
\end{aligned}
</span></p>
<p>We define <code>fail</code> as a synonym for <code>mzero</code> and
infix <code>++</code> for <code>mplus</code>.</p>
<p>Fusing monads and monoids gives the most popular general flavor of
monads, which we call <strong>monad-plus</strong> after Haskell.
Monad-plus requires additional axioms relating its “addition” and
“multiplication”:</p>
<p><span class="math display">
\begin{aligned}
\text{bind}\ \text{mzero}\ f &amp;\approx \text{mzero} \\
\text{bind}\ m\ (\lambda x.\text{mzero}) &amp;\approx \text{mzero}
\end{aligned}
</span></p>
<p>Using infix notation with <span class="math inline">\oplus</span> for
<code>mplus</code>, <span class="math inline">\mathbf{0}</span> for
<code>mzero</code>, <span class="math inline">\triangleright</span> for
<code>bind</code>, and <span class="math inline">\mathbf{1}</span> for
<code>return</code>, the complete monad-plus axioms are:</p>
<p><span class="math display">
\begin{aligned}
\mathbf{0} \oplus a &amp;\approx a \\
a \oplus \mathbf{0} &amp;\approx a \\
a \oplus (b \oplus c) &amp;\approx (a \oplus b) \oplus c \\
\mathbf{1}\ x \triangleright f &amp;\approx f\ x \\
a \triangleright \lambda x.\mathbf{1}\ x &amp;\approx a \\
(a \triangleright \lambda x.b) \triangleright \lambda y.c &amp;\approx a
\triangleright (\lambda x.b \triangleright \lambda y.c) \\
\mathbf{0} \triangleright f &amp;\approx \mathbf{0} \\
a \triangleright (\lambda x.\mathbf{0}) &amp;\approx \mathbf{0}
\end{aligned}
</span></p>
<p>The list type has a natural monad and monoid structure:</p>
<pre><code>let mzero = []
let mplus = (@)
let bind a b = concat_map b a
let return a = [a]</code></pre>
<p>We can define in any monad-plus:</p>
<pre><code>let fail = mzero
let failwith _ = fail
let (++) = mplus
let (&gt;&gt;=) a b = bind a b
let guard p = if p then return () else fail</code></pre>
<h3 id="backtracking-computation-with-choice">8.6 Backtracking:
Computation with Choice</h3>
<p>We have seen <code>mzero</code> (i.e., <code>fail</code>) in the
countdown problem. What about <code>mplus</code>? Here is an example
from a puzzle solver:</p>
<pre><code>let find_to_eat n island_size num_islands empty_cells =
  let honey = honey_cells n empty_cells in

  let rec find_board s =
    match visit_cell s with
    | None -&gt;
        perform
          guard (s.been_islands = num_islands);
          return s.eaten
    | Some (cell, s) -&gt;
        perform
          s &lt;-- find_island cell (fresh_island s);
          guard (s.been_size = island_size);
          find_board s

  and find_island current s =
    let s = keep_cell current s in
    neighbors n empty_cells current
    |&gt; foldM
         (fun neighbor s -&gt;
           if CellSet.mem neighbor s.visited then return s
           else
             let choose_eat =
               if s.more_to_eat &lt;= 0 then fail
               else return (eat_cell neighbor s)
             and choose_keep =
               if s.been_size &gt;= island_size then fail
               else find_island neighbor s in
             mplus choose_eat choose_keep)  (* Choice point! *)
         s in

  let cells_to_eat =
    List.length honey - island_size * num_islands in
  find_board (init_state honey cells_to_eat)</code></pre>
<p>The <code>mplus choose_eat choose_keep</code> creates a choice point:
either eat the cell or keep it as part of the island. The monad-plus
structure handles backtracking automatically.</p>
<h3 id="monad-flavors">8.7 Monad Flavors</h3>
<p>Monads “wrap around” a type, but some monads need an additional type
parameter. Usually the additional type does not change while within a
monad, so we stick to <code>'a monad</code> rather than
<code>('s, 'a) monad</code>.</p>
<p>As monad-plus shows, things get interesting when we add more
operations to a basic monad. Here are some common monad flavors:</p>
<p><strong>Monads with access:</strong></p>
<pre><code>access : &#39;a monad -&gt; &#39;a</code></pre>
<p>Example: the lazy monad.</p>
<p><strong>Monad-plus (non-deterministic computation):</strong></p>
<pre><code>mzero : &#39;a monad
mplus : &#39;a monad -&gt; &#39;a monad -&gt; &#39;a monad</code></pre>
<p><strong>Monads with state (parameterized by type
<code>store</code>):</strong></p>
<pre><code>get : store monad
put : store -&gt; unit monad</code></pre>
<p>There is a “canonical” state monad. Similar monads include the writer
monad (with <code>get</code> called <code>listen</code> and
<code>put</code> called <code>tell</code>) and the reader monad, without
<code>put</code>, but with <code>get</code> (called <code>ask</code>)
and:</p>
<pre><code>local : (store -&gt; store) -&gt; &#39;a monad -&gt; &#39;a monad</code></pre>
<p><strong>Exception/error monads (parameterized by type
<code>excn</code>):</strong></p>
<pre><code>throw : excn -&gt; &#39;a monad
catch : &#39;a monad -&gt; (excn -&gt; &#39;a monad) -&gt; &#39;a monad</code></pre>
<p><strong>Continuation monad:</strong></p>
<pre><code>callCC : ((&#39;a -&gt; &#39;b monad) -&gt; &#39;a monad) -&gt; &#39;a monad</code></pre>
<p>We will not cover continuations in detail here.</p>
<p><strong>Probabilistic computation:</strong></p>
<pre><code>choose : float -&gt; &#39;a monad -&gt; &#39;a monad -&gt; &#39;a monad</code></pre>
<p>satisfying the laws with <span class="math inline">a \oplus_p
b</span> for <code>choose p a b</code> and <span class="math inline">p
\cdot q</span> for <code>p *. q</code>, where <span
class="math inline">0 \leq p, q \leq 1</span>:</p>
<p><span class="math display">
\begin{aligned}
a \oplus_0 b &amp;\approx b \\
a \oplus_p b &amp;\approx b \oplus_{1-p} a \\
a \oplus_p (b \oplus_q c) &amp;\approx (a \oplus_{\frac{p}{p+q-pq}} b)
\oplus_{p+q-pq} c \\
a \oplus_p a &amp;\approx a
\end{aligned}
</span></p>
<p><strong>Parallel computation (monad with access and parallel
bind):</strong></p>
<pre><code>parallel : &#39;a monad -&gt; &#39;b monad -&gt; (&#39;a -&gt; &#39;b -&gt; &#39;c monad) -&gt; &#39;c monad</code></pre>
<p>Example: lightweight threads.</p>
<h3 id="interlude-the-module-system">8.8 Interlude: The Module
System</h3>
<p>OCaml’s module system provides the infrastructure for defining monads
in a reusable way. Here is a brief overview of the key concepts.</p>
<p>Modules collect related type definitions and operations together.
Module values are introduced with <code>struct ... end</code>
(structures), and module types with <code>sig ... end</code>
(signatures). A structure is a package of definitions; a signature is an
interface for packages.</p>
<p>A source file <code>source.ml</code> defines a module
<code>Source</code>. A file <code>source.mli</code> defines its
type.</p>
<p>In the module level, modules are defined with
<code>module ModuleName = ...</code> or
<code>module ModuleName : MODULE_TYPE = ...</code>, and module types
with <code>module type MODULE_TYPE = ...</code>.</p>
<p>Locally in expressions, modules are defined with
<code>let module M = ... in ...</code>.</p>
<p>The content of a module is made visible with
<code>open Module</code>. Module <code>Pervasives</code> (now
<code>Stdlib</code>) is initially visible.</p>
<p>Content of a module is included into another module with
<code>include Module</code>.</p>
<p><strong>Functors</strong> are module functions – functions from
modules to modules:</p>
<pre><code>module Funct = functor (Arg : sig ... end) -&gt; struct ... end
(* Or equivalently: *)
module Funct (Arg : sig ... end) = struct ... end</code></pre>
<p>Functors can return functors, and modules can be parameterized by
multiple modules. Functor application always uses parentheses:
<code>Funct (struct ... end)</code>.</p>
<p>A signature <code>MODULE_TYPE with type t_name = ...</code> is like
<code>MODULE_TYPE</code> but with <code>t_name</code> made more
specific. We can also include signatures with
<code>include MODULE_TYPE</code>.</p>
<p>Finally, we can pass around modules in normal functions using
first-class modules:</p>
<pre><code>module type T = sig val g : int -&gt; int end

let f mod_v x =
  let module M = (val mod_v : T) in
  M.g x
(* val f : (module T) -&gt; int -&gt; int = &lt;fun&gt; *)

let test = f (module struct let g i = i*i end : T)
(* val test : int -&gt; int = &lt;fun&gt; *)</code></pre>
<h3 id="the-two-metaphors">8.9 The Two Metaphors</h3>
<p>Monads can be understood through two complementary metaphors.</p>
<h4 id="monads-as-containers">Monads as Containers</h4>
<p>A monad is a <strong>quarantine container</strong>:</p>
<ul>
<li>We can put something into the container with
<code>return</code></li>
<li>We can operate on it, but the result needs to stay in the
container</li>
</ul>
<pre><code>let lift f m = perform x &lt;-- m; return (f x)
(* val lift : (&#39;a -&gt; &#39;b) -&gt; &#39;a monad -&gt; &#39;b monad *)</code></pre>
<ul>
<li>We can deactivate-unwrap the quarantine container but only when it
is in another container so the quarantine is not broken</li>
</ul>
<pre><code>let join m = perform x &lt;-- m; x
(* val join : (&#39;a monad) monad -&gt; &#39;a monad *)</code></pre>
<p>The quarantine container for a <strong>monad-plus</strong> is more
like other containers: it can be empty, or contain multiple
elements.</p>
<p>Monads with access allow us to extract the resulting element from the
container; other monads provide a <code>run</code> operation that
exposes “what really happened behind the quarantine.”</p>
<h4 id="monads-as-computation">Monads as Computation</h4>
<p>To compute the result, <code>perform</code> instructions, naming
partial results. The physical metaphor is an <strong>assembly
line</strong>:</p>
<pre><code>let assemblyLine w =
  perform
    c &lt;-- makeChopsticks w;   (* Worker makes chopsticks *)
    c&#39; &lt;-- polishChopsticks c; (* Worker polishes them *)
    c&#39;&#39; &lt;-- wrapChopsticks c&#39;; (* Worker wraps them *)
    return c&#39;&#39;                 (* Loader returns the result *)</code></pre>
<p>Any expression can be spread over a monad. For lambda-terms:</p>
<p><span class="math display">
\begin{aligned}
[\![ N ]\!] &amp;= \text{return}\ N &amp; \text{(constant)} \\
[\![ x ]\!] &amp;= \text{return}\ x &amp; \text{(variable)} \\
[\![ \lambda x.a ]\!] &amp;= \text{return}\ (\lambda x.[\![ a ]\!])
&amp; \text{(function)} \\
[\![ \text{let}\ x = a\ \text{in}\ b ]\!] &amp;= \text{bind}\ [\![ a
]\!]\ (\lambda x.[\![ b ]\!]) &amp; \text{(local definition)} \\
[\![ a\ b ]\!] &amp;= \text{bind}\ [\![ a ]\!]\ (\lambda
v_a.\text{bind}\ [\![ b ]\!]\ (\lambda v_b.v_a\ v_b)) &amp;
\text{(application)}
\end{aligned}
</span></p>
<p>When an expression is spread over a monad, its computation can be
monitored or affected without modifying the expression.</p>
<h3 id="monad-classes-and-instances">8.10 Monad Classes and
Instances</h3>
<p>To implement a monad, we need to provide the implementation type,
<code>return</code>, and <code>bind</code> operations.</p>
<pre><code>module type MONAD = sig
  type &#39;a t
  val return : &#39;a -&gt; &#39;a t
  val bind : &#39;a t -&gt; (&#39;a -&gt; &#39;b t) -&gt; &#39;b t
end</code></pre>
<p>Alternatively, we could start from <code>return</code>,
<code>lift</code>, and <code>join</code> operations.</p>
<p>Based on just these two operations, we can define a suite of
general-purpose functions:</p>
<pre><code>module type MONAD_OPS = sig
  type &#39;a monad
  include MONAD with type &#39;a t := &#39;a monad
  val ( &gt;&gt;= ) : &#39;a monad -&gt; (&#39;a -&gt; &#39;b monad) -&gt; &#39;b monad
  val foldM : (&#39;a -&gt; &#39;b -&gt; &#39;a monad) -&gt; &#39;a -&gt; &#39;b list -&gt; &#39;a monad
  val whenM : bool -&gt; unit monad -&gt; unit monad
  val lift : (&#39;a -&gt; &#39;b) -&gt; &#39;a monad -&gt; &#39;b monad
  val (&gt;&gt;|) : &#39;a monad -&gt; (&#39;a -&gt; &#39;b) -&gt; &#39;b monad
  val join : &#39;a monad monad -&gt; &#39;a monad
  val ( &gt;=&gt;) : (&#39;a -&gt; &#39;b monad) -&gt; (&#39;b -&gt; &#39;c monad) -&gt; &#39;a -&gt; &#39;c monad
end

module MonadOps (M : MONAD) = struct
  open M
  type &#39;a monad = &#39;a t
  let run x = x
  let (&gt;&gt;=) a b = bind a b
  let rec foldM f a = function
    | [] -&gt; return a
    | x::xs -&gt; f a x &gt;&gt;= fun a&#39; -&gt; foldM f a&#39; xs
  let whenM p s = if p then s else return ()
  let lift f m = perform x &lt;-- m; return (f x)
  let (&gt;&gt;|) a b = lift b a
  let join m = perform x &lt;-- m; x
  let (&gt;=&gt;) f g = fun x -&gt; f x &gt;&gt;= g
end</code></pre>
<p>We make the monad “safe” by keeping its type abstract, but
<code>run</code> exposes “what really happened”:</p>
<pre><code>module Monad (M : MONAD) : sig
  include MONAD_OPS
  val run : &#39;a monad -&gt; &#39;a M.t
end = struct
  include M
  include MonadOps(M)
end</code></pre>
<h4 id="monad-plus-classes">Monad-Plus Classes</h4>
<p>The monad-plus class has many implementations. They need to provide
<code>mzero</code> and <code>mplus</code>:</p>
<pre><code>module type MONAD_PLUS = sig
  include MONAD
  val mzero : &#39;a t
  val mplus : &#39;a t -&gt; &#39;a t -&gt; &#39;a t
end

module type MONAD_PLUS_OPS = sig
  include MONAD_OPS
  val mzero : &#39;a monad
  val mplus : &#39;a monad -&gt; &#39;a monad -&gt; &#39;a monad
  val fail : &#39;a monad
  val (++) : &#39;a monad -&gt; &#39;a monad -&gt; &#39;a monad
  val guard : bool -&gt; unit monad
  val msum_map : (&#39;a -&gt; &#39;b monad) -&gt; &#39;a list -&gt; &#39;b monad
end

module MonadPlusOps (M : MONAD_PLUS) = struct
  open M
  include MonadOps(M)
  let fail = mzero
  let (++) a b = mplus a b
  let guard p = if p then return () else fail
  let msum_map f l = List.fold_right
    (fun a acc -&gt; mplus (f a) acc) l mzero
end

module MonadPlus (M : MONAD_PLUS) : sig
  include MONAD_PLUS_OPS
  val run : &#39;a monad -&gt; &#39;a M.t
end = struct
  include M
  include MonadPlusOps(M)
end</code></pre>
<p>We also need a class for computations with state:</p>
<pre><code>module type STATE = sig
  type store
  type &#39;a t
  val get : store t
  val put : store -&gt; unit t
end</code></pre>
<h3 id="monad-instances">8.11 Monad Instances</h3>
<h4 id="the-lazy-monad">The Lazy Monad</h4>
<p>Heavy laziness notation? Try a monad (with access):</p>
<pre><code>module LazyM = Monad (struct
  type &#39;a t = &#39;a Lazy.t
  let bind a b = lazy (Lazy.force (b (Lazy.force a)))
  let return a = lazy a
end)

let laccess m = Lazy.force (LazyM.run m)</code></pre>
<h4 id="the-list-monad">The List Monad</h4>
<p>Our resident list monad (monad-plus):</p>
<pre><code>module ListM = MonadPlus (struct
  type &#39;a t = &#39;a list
  let bind a b = concat_map b a
  let return a = [a]
  let mzero = []
  let mplus = List.append
end)</code></pre>
<h4 id="backtracking-parameterized-by-monad-plus">Backtracking
Parameterized by Monad-Plus</h4>
<p>The Countdown module can be parameterized by any monad-plus:</p>
<pre><code>module Countdown (M : MONAD_PLUS_OPS) = struct
  open M  (* Open the module to make monad operations visible *)

  let rec insert x = function  (* All choice-introducing operations *)
    | [] -&gt; return [x]          (* need to happen in the monad *)
    | y::ys as xs -&gt;
        return (x::xs) ++
          perform xys &lt;-- insert x ys; return (y::xys)

  let rec choices = function
    | [] -&gt; return []
    | x::xs -&gt; perform
        cxs &lt;-- choices xs;           (* Choosing which numbers in what order *)
        return cxs ++ insert x cxs    (* and now whether with or without x *)

  type op = Add | Sub | Mul | Div

  let apply op x y =
    match op with
    | Add -&gt; x + y
    | Sub -&gt; x - y
    | Mul -&gt; x * y
    | Div -&gt; x / y

  let valid op x y =
    match op with
    | Add -&gt; x &lt;= y
    | Sub -&gt; x &gt; y
    | Mul -&gt; x &lt;= y &amp;&amp; x &lt;&gt; 1 &amp;&amp; y &lt;&gt; 1
    | Div -&gt; x mod y = 0 &amp;&amp; y &lt;&gt; 1

  type expr = Val of int | App of op * expr * expr

  let op2str = function
    | Add -&gt; &quot;+&quot; | Sub -&gt; &quot;-&quot; | Mul -&gt; &quot;*&quot; | Div -&gt; &quot;/&quot;

  let rec expr2str = function  (* We will provide solutions as strings *)
    | Val n -&gt; string_of_int n
    | App (op, l, r) -&gt; &quot;(&quot; ^ expr2str l ^ op2str op ^ expr2str r ^ &quot;)&quot;

  let combine (l, x) (r, y) o = perform  (* Try out an operator *)
    guard (valid o x y);
    return (App (o, l, r), apply o x y)

  let split l =  (* Another choice: which numbers go into which argument *)
    let rec aux lhs = function
      | [] | [_] -&gt; fail                    (* Both arguments need numbers *)
      | [y; z] -&gt; return (List.rev (y::lhs), [z])
      | hd::rhs -&gt;
          let lhs = hd::lhs in
          return (List.rev lhs, rhs)
            ++ aux lhs rhs in
    aux [] l

  let rec results = function  (* Build possible expressions once numbers *)
    | [] -&gt; fail                (* have been picked *)
    | [n] -&gt; perform
        guard (n &gt; 0); return (Val n, n)
    | ns -&gt; perform
        (ls, rs) &lt;-- split ns;
        lx &lt;-- results ls;
        ly &lt;-- results rs;  (* Collect solutions using each operator *)
        msum_map (combine lx ly) [Add; Sub; Mul; Div]

  let solutions ns n = perform  (* Solve the problem: *)
      ns&#39; &lt;-- choices ns;         (* pick numbers and their order, *)
      (e, m) &lt;-- results ns&#39;;     (* build possible expressions, *)
      guard (m = n);              (* check if the expression gives target value, *)
      return (expr2str e)         (* &quot;print&quot; the solution *)
end</code></pre>
<h4 id="understanding-laziness">Understanding Laziness</h4>
<p>Let us measure execution times:</p>
<pre><code>let time f =
  let tbeg = Unix.gettimeofday () in
  let res = f () in
  let tend = Unix.gettimeofday () in
  tend -. tbeg, res</code></pre>
<p>With the list monad:</p>
<pre><code>module ListCountdown = Countdown (ListM)
let test1 () = ListM.run (ListCountdown.solutions [1;3;7;10;25;50] 765)
let t1, sol1 = time test1
(* val t1 : float = 2.28... *)
(* val sol1 : string list = [&quot;((25-(3+7))*(1+50))&quot;; &quot;(((25-3)-7)*(1+50))&quot;; ...] *)</code></pre>
<p>What if we want only one solution? Laziness to the rescue! We define
an “odd lazy list”:</p>
<pre><code>type &#39;a llist = LNil | LCons of &#39;a * &#39;a llist Lazy.t

let rec ltake n = function
  | LCons (a, lazy l) when n &gt; 0 -&gt; a::(ltake (n-1) l)
  | _ -&gt; []

let rec lappend l1 l2 =
  match l1 with
  | LNil -&gt; l2
  | LCons (hd, tl) -&gt;
      LCons (hd, lazy (lappend (Lazy.force tl) l2))

let rec lconcat_map f = function
  | LNil -&gt; LNil
  | LCons (a, lazy l) -&gt;
      lappend (f a) (lconcat_map f l)

module LListM = MonadPlus (struct
  type &#39;a t = &#39;a llist
  let bind a b = lconcat_map b a
  let return a = LCons (a, lazy LNil)
  let mzero = LNil
  let mplus = lappend
end)</code></pre>
<p>Testing shows that the odd lazy list still takes about the same time
to even get the lazy list started! The elements are almost already
computed once the first one is.</p>
<p>The <strong>option monad</strong> does not help either:</p>
<pre><code>module OptionM = MonadPlus (struct
  type &#39;a t = &#39;a option
  let bind a b =
    match a with None -&gt; None | Some x -&gt; b x
  let return a = Some a
  let mzero = None
  let mplus a b = match a with None -&gt; b | Some _ -&gt; a
end)</code></pre>
<p>This very quickly computes… nothing. The <code>OptionM</code> monad
(Haskell’s <code>Maybe</code> monad) is good for computations that might
fail, but not for search with multiple solutions.</p>
<p>Our lazy list type is not lazy enough. Whenever we “make” a choice
with <code>a ++ b</code> or <code>msum_map</code>, it computes the first
candidate for each choice path immediately.</p>
<p>We need <strong>even lazy lists</strong> (our <code>llist</code>
above are called “odd lazy lists”):</p>
<pre><code>type &#39;a lazy_list = &#39;a lazy_list_ Lazy.t
and &#39;a lazy_list_ = LazNil | LazCons of &#39;a * &#39;a lazy_list

let rec laztake n = function
  | lazy (LazCons (a, l)) when n &gt; 0 -&gt; a::(laztake (n-1) l)
  | _ -&gt; []

let rec append_aux l1 l2 =
  match l1 with
  | lazy LazNil -&gt; Lazy.force l2
  | lazy (LazCons (hd, tl)) -&gt;
      LazCons (hd, lazy (append_aux tl l2))

let lazappend l1 l2 = lazy (append_aux l1 l2)

let rec concat_map_aux f = function
  | lazy LazNil -&gt; LazNil
  | lazy (LazCons (a, l)) -&gt;
      append_aux (f a) (lazy (concat_map_aux f l))

let lazconcat_map f l = lazy (concat_map_aux f l)

module LazyListM = MonadPlus (struct
  type &#39;a t = &#39;a lazy_list
  let bind a b = lazconcat_map b a
  let return a = lazy (LazCons (a, lazy LazNil))
  let mzero = lazy LazNil
  let mplus = lazappend
end)</code></pre>
<p>Now the first solution takes considerably less time than all
solutions. The next 9 solutions are almost computed once the first one
is. But computing all solutions takes nearly twice as long as without
the overhead of lazy computation – the price of laziness.</p>
<h4 id="the-exception-monad">The Exception Monad</h4>
<p>Built-in non-functional exceptions in OCaml are more efficient and
more flexible. However, monadic exceptions are safer than standard
exceptions in situations like multi-threading. The monadic
lightweight-thread library Lwt has <code>throw</code> (called
<code>fail</code> there) and <code>catch</code> operations in its
monad.</p>
<pre><code>module ExceptionM (Excn : sig type t end) : sig
  type excn = Excn.t
  type &#39;a t = OK of &#39;a | Bad of excn
  include MONAD_OPS
  val run : &#39;a monad -&gt; &#39;a t
  val throw : excn -&gt; &#39;a monad
  val catch : &#39;a monad -&gt; (excn -&gt; &#39;a monad) -&gt; &#39;a monad
end = struct
  type excn = Excn.t
  module M = struct
    type &#39;a t = OK of &#39;a | Bad of excn
    let return a = OK a
    let bind m b = match m with
      | OK a -&gt; b a
      | Bad e -&gt; Bad e
  end
  include M
  include MonadOps(M)
  let throw e = Bad e
  let catch m handler = match m with
    | OK _ -&gt; m
    | Bad e -&gt; handler e
end</code></pre>
<h4 id="the-state-monad">The State Monad</h4>
<pre><code>module StateM (Store : sig type t end) : sig
  type store = Store.t
  type &#39;a t = store -&gt; &#39;a * store  (* Pass the current store value to get the next value *)
  include MONAD_OPS
  include STATE with type &#39;a t := &#39;a monad
                 and type store := store
  val run : &#39;a monad -&gt; &#39;a t
end = struct
  type store = Store.t
  module M = struct
    type &#39;a t = store -&gt; &#39;a * store
    let return a = fun s -&gt; a, s     (* Keep the current value unchanged *)
    let bind m b = fun s -&gt; let a, s&#39; = m s in b a s&#39;
  end                                (* To bind two steps, pass the value after first step to the second step *)
  include M
  include MonadOps(M)
  let get = fun s -&gt; s, s            (* Keep the value unchanged but put it in monad *)
  let put s&#39; = fun _ -&gt; (), s&#39;       (* Change the value; a throwaway in monad *)
end</code></pre>
<p>The state monad is useful to hide passing-around of a “current”
value. Here is an example that renames variables in lambda-terms to
eliminate potential name clashes:</p>
<pre><code>type term =
  | Var of string
  | Lam of string * term
  | App of term * term

let (!) x = Var x
let (|-&gt;) x t = Lam (x, t)
let (@) t1 t2 = App (t1, t2)
let test = &quot;x&quot; |-&gt; (&quot;x&quot; |-&gt; !&quot;y&quot; @ !&quot;x&quot;) @ !&quot;x&quot;

module S = StateM (struct type t = int * (string * string) list end)
open S

let rec alpha_conv = function
  | Var x as v -&gt; perform              (* Function from terms to StateM monad *)
      (_, env) &lt;-- get;                (* Seeing a variable does not change state *)
      let v = try Var (List.assoc x env)  (* but we need its new name *)
        with Not_found -&gt; v in         (* Free variables don&#39;t change name *)
      return v
  | Lam (x, t) -&gt; perform              (* We rename each bound variable *)
      (fresh, env) &lt;-- get;            (* We need a fresh number *)
      let x&#39; = x ^ string_of_int fresh in
      put (fresh+1, (x, x&#39;)::env);     (* Remember new name, update number *)
      t&#39; &lt;-- alpha_conv t;
      (fresh&#39;, _) &lt;-- get;             (* We need to restore names, *)
      put (fresh&#39;, env);               (* but keep the number fresh *)
      return (Lam (x&#39;, t&#39;))
  | App (t1, t2) -&gt; perform
      t1 &lt;-- alpha_conv t1;            (* Passing around of names *)
      t2 &lt;-- alpha_conv t2;            (* and the currently fresh number *)
      return (App (t1, t2))            (* is done by the monad *)

(* val test : term = Lam (&quot;x&quot;, App (Lam (&quot;x&quot;, App (Var &quot;y&quot;, Var &quot;x&quot;)), Var &quot;x&quot;)) *)
(* # StateM.run (alpha_conv test) (5, []);;
   - : term * (int * (string * string) list) =
   (Lam (&quot;x5&quot;, App (Lam (&quot;x6&quot;, App (Var &quot;y&quot;, Var &quot;x6&quot;)), Var &quot;x5&quot;)), (7, [])) *)</code></pre>
<p>Note: This does not make a lambda-term safe for multiple steps of
beta-reduction. Can you find a counter-example?</p>
<h3 id="monad-transformers">8.12 Monad Transformers</h3>
<p>Sometimes we need merits of multiple monads at the same time, e.g.,
monads <code>AM</code> and <code>BM</code>. The straightforward idea is
to nest one monad within another: either
<code>'a AM.monad BM.monad</code> or <code>'a BM.monad AM.monad</code>.
But we want a monad that has operations of both <code>AM</code> and
<code>BM</code>.</p>
<p>It turns out that the straightforward approach does not lead to
operations with the meaning we want. A <strong>monad
transformer</strong> <code>AT</code> takes a monad <code>BM</code> and
turns it into a monad <code>AT(BM)</code> which actually wraps around
<code>BM</code> on both sides. <code>AT(BM)</code> has operations of
both monads.</p>
<p>We will develop a monad transformer <code>StateT</code> which adds
state to a monad-plus. The resulting monad has all: <code>return</code>,
<code>bind</code>, <code>mzero</code>, <code>mplus</code>,
<code>put</code>, <code>get</code>, and their supporting general-purpose
functions.</p>
<p>We need monad transformers in OCaml because “monads are contagious”:
although we have built-in state and exceptions, we need to use monadic
state and exceptions when we are inside a monad. This is the reason Lwt
is both a concurrency and an exception monad.</p>
<p>The state monad uses <code>let x = a in ...</code> for binding. The
transformed monad uses <code>M.bind</code> instead:</p>
<pre><code>type &#39;a state = store -&gt; (&#39;a * store)

let return (a : &#39;a) : &#39;a state =
  fun s -&gt; (a, s)

let bind (u : &#39;a state) (f : &#39;a -&gt; &#39;b state) : &#39;b state =
  fun s -&gt; (fun (a, s&#39;) -&gt; f a s&#39;) (u s)

(* Monad M transformed to add state, in pseudo-code: *)
type &#39;a stateT(M) = store -&gt; (&#39;a * store) M
(* notice this is not an (&#39;a M) state *)

let return (a : &#39;a) : &#39;a stateT(M) =
  fun s -&gt; M.return (a, s)           (* Rather than returning, M.return *)

let bind (u : &#39;a stateT(M)) (f : &#39;a -&gt; &#39;b stateT(M)) : &#39;b stateT(M) =
  fun s -&gt; M.bind (u s) (fun (a, s&#39;) -&gt; f a s&#39;)  (* Rather than let-binding, M.bind *)</code></pre>
<h4 id="state-transformer-implementation">State Transformer
Implementation</h4>
<pre><code>module StateT (MP : MONAD_PLUS_OPS) (Store : sig type t end) : sig
  type store = Store.t
  type &#39;a t = store -&gt; (&#39;a * store) MP.monad
  include MONAD_PLUS_OPS         (* Exporting all monad-plus operations *)
  include STATE with type &#39;a t := &#39;a monad
                 and type store := store  (* and state operations *)
  val run : &#39;a monad -&gt; &#39;a t     (* Expose &quot;what happened&quot; -- resulting states *)
  val runT : &#39;a monad -&gt; store -&gt; &#39;a MP.monad
end = struct                     (* Run the state transformer -- get resulting values *)
  type store = Store.t
  module M = struct
    type &#39;a t = store -&gt; (&#39;a * store) MP.monad
    let return a = fun s -&gt; MP.return (a, s)
    let bind m b = fun s -&gt;
      MP.bind (m s) (fun (a, s&#39;) -&gt; b a s&#39;)
    let mzero = fun _ -&gt; MP.mzero            (* Lift the monad-plus operations *)
    let mplus ma mb = fun s -&gt; MP.mplus (ma s) (mb s)
  end
  include M
  include MonadPlusOps(M)
  let get = fun s -&gt; MP.return (s, s)        (* Instead of just returning, *)
  let put s&#39; = fun _ -&gt; MP.return ((), s&#39;)   (* MP.return *)
  let runT m s = MP.lift fst (m s)
end</code></pre>
<h4 id="backtracking-with-state">Backtracking with State</h4>
<p>Using the state transformer with our puzzle solver:</p>
<pre><code>module HoneyIslands (M : MONAD_PLUS_OPS) = struct
  type state = {
    been_size : int;
    been_islands : int;
    unvisited : cell list;
    visited : CellSet.t;
    eaten : cell list;
    more_to_eat : int;
  }

  let init_state unvisited more_to_eat = {
    been_size = 0;
    been_islands = 0;
    unvisited;
    visited = CellSet.empty;
    eaten = [];
    more_to_eat;
  }

  module BacktrackingM = StateT (M) (struct type t = state end)
  open BacktrackingM

  let rec visit_cell () = perform    (* State update actions *)
    s &lt;-- get;
    match s.unvisited with
    | [] -&gt; return None
    | c::remaining when CellSet.mem c s.visited -&gt; perform
        put {s with unvisited=remaining};
        visit_cell ()                 (* Throwaway argument because of recursion *)
    | c::remaining -&gt; perform
        put {s with
          unvisited=remaining;
          visited = CellSet.add c s.visited};
        return (Some c)               (* This action returns a value *)

  let eat_cell c = perform
    s &lt;-- get;
    put {s with eaten = c::s.eaten;
         visited = CellSet.add c s.visited;
         more_to_eat = s.more_to_eat - 1};
    return ()                         (* Remaining state update actions just affect the state *)

  let keep_cell c = perform
    s &lt;-- get;
    put {s with
      visited = CellSet.add c s.visited;
      been_size = s.been_size + 1};
    return ()

  let fresh_island = perform
    s &lt;-- get;
    put {s with been_size = 0;
         been_islands = s.been_islands + 1};
    return ()

  let find_to_eat n island_size num_islands empty_cells =
    let honey = honey_cells n empty_cells in
    let rec find_board () = perform
      cell &lt;-- visit_cell ();
      match cell with
      | None -&gt; perform
          s &lt;-- get;
          guard (s.been_islands = num_islands);
          return s.eaten
      | Some cell -&gt; perform
          fresh_island;
          find_island cell;
          s &lt;-- get;
          guard (s.been_size = island_size);
          find_board ()

    and find_island current = perform
      keep_cell current;
      neighbors n empty_cells current
      |&gt; foldM
           (fun () neighbor -&gt; perform
              s &lt;-- get;
              whenM (not (CellSet.mem neighbor s.visited))
                (let choose_eat = perform
                   guard (s.more_to_eat &gt; 0);
                   eat_cell neighbor
                 and choose_keep = perform
                   guard (s.been_size &lt; island_size);
                   find_island neighbor in
                 choose_eat ++ choose_keep)) () in

    let cells_to_eat =
      List.length honey - island_size * num_islands in
    init_state honey cells_to_eat
    |&gt; runT (find_board ())
end

module HoneyL = HoneyIslands (ListM)
let find_to_eat a b c d =
  ListM.run (HoneyL.find_to_eat a b c d)</code></pre>
<h3 id="probabilistic-programming">8.13 Probabilistic Programming</h3>
<p>Using a random number generator, we can define procedures that
produce various output. This is <strong>not functional</strong> –
mathematical functions have a deterministic result for fixed
arguments.</p>
<p>Similarly to how we can “simulate” (mutable) variables with state
monad and non-determinism with list monad, we can “simulate” random
computation with a probability monad.</p>
<p>The probability monad class means much more than having randomized
computation. We can ask questions about probabilities of results. Monad
instances can make tradeoffs of efficiency vs. accuracy (exact
vs. approximate probabilities).</p>
<h4 id="the-probability-monad">The Probability Monad</h4>
<p>The essential functions for the probability monad class are
<code>choose</code> and <code>distrib</code>. Remaining functions could
be defined in terms of these but are provided by each instance for
efficiency.</p>
<p>Inside-monad operations:</p>
<ul>
<li><code>choose : float -&gt; 'a monad -&gt; 'a monad -&gt; 'a monad</code>:
<code>choose p a b</code> represents an event or distribution which is
<code>a</code> with probability <span class="math inline">p</span> and
is <code>b</code> with probability <span
class="math inline">1-p</span>.</li>
<li><code>pick : ('a * float) list -&gt; 'a monad</code>: A result from
the provided distribution over values. The argument must be a
probability distribution: positive values summing to 1.</li>
<li><code>uniform : 'a list -&gt; 'a monad</code>: Uniform distribution
over given values.</li>
<li><code>flip : float -&gt; bool monad</code>: Equal to
<code>choose p (return true) (return false)</code>.</li>
<li><code>coin : bool monad</code>: Equal to <code>flip 0.5</code>.</li>
</ul>
<p>Outside-monad operations:</p>
<ul>
<li><code>prob : ('a -&gt; bool) -&gt; 'a monad -&gt; float</code>:
Returns the probability that the predicate holds.</li>
<li><code>distrib : 'a monad -&gt; ('a * float) list</code>: Returns the
distribution of probabilities over the resulting values.</li>
<li><code>access : 'a monad -&gt; 'a</code>: Samples a random result
from the distribution – <strong>non-functional</strong> behavior.</li>
</ul>
<pre><code>module type PROBABILITY = sig
  include MONAD_OPS
  val choose : float -&gt; &#39;a monad -&gt; &#39;a monad -&gt; &#39;a monad
  val pick : (&#39;a * float) list -&gt; &#39;a monad
  val uniform : &#39;a list -&gt; &#39;a monad
  val coin : bool monad
  val flip : float -&gt; bool monad
  val prob : (&#39;a -&gt; bool) -&gt; &#39;a monad -&gt; float
  val distrib : &#39;a monad -&gt; (&#39;a * float) list
  val access : &#39;a monad -&gt; &#39;a
end</code></pre>
<p>Helper functions:</p>
<pre><code>let total dist =
  List.fold_left (fun a (_,b) -&gt; a +. b) 0. dist

let merge dist = map_reduce (fun x -&gt; x) (+.) 0. dist  (* Merge repeating elements *)

let normalize dist =                     (* Normalize a measure into a distribution *)
  let tot = total dist in
  if tot = 0. then dist
  else List.map (fun (e,w) -&gt; e, w /. tot) dist

let roulette dist =                      (* Roulette wheel from a distribution/measure *)
  let tot = total dist in
  let rec aux r = function
    | [] -&gt; assert false
    | (e, w)::_ when w &lt;= r -&gt; e
    | (_, w)::tl -&gt; aux (r -. w) tl in
  aux (Random.float tot) dist</code></pre>
<h4 id="exact-distribution-monad">Exact Distribution Monad</h4>
<pre><code>module DistribM : PROBABILITY = struct
  module M = struct                      (* Exact probability distribution -- naive implementation *)
    type &#39;a t = (&#39;a * float) list
    let bind a b = merge              (* x w.p. p and then y w.p. q happens = *)
      [y, q *. p | (x, p) &lt;- a; (y, q) &lt;- b x]  (* y results w.p. p*q *)
    let return a = [a, 1.]               (* Certainly a *)
  end
  include M
  include MonadOps (M)
  let choose p a b =
    List.map (fun (e,w) -&gt; e, p *. w) a @
      List.map (fun (e,w) -&gt; e, (1. -. p) *. w) b
  let pick dist = dist
  let uniform elems = normalize
    (List.map (fun e -&gt; e, 1.) elems)
  let coin = [true, 0.5; false, 0.5]
  let flip p = [true, p; false, 1. -. p]
  let prob p m = m
    |&gt; List.filter (fun (e,_) -&gt; p e)    (* All cases where p holds, *)
    |&gt; List.map snd |&gt; List.fold_left (+.) 0.  (* add up *)
  let distrib m = m
  let access m = roulette m
end</code></pre>
<h4 id="sampling-monad">Sampling Monad</h4>
<pre><code>module SamplingM (S : sig val samples : int end) : PROBABILITY = struct
  module M = struct                      (* Parameterized by how many samples *)
    type &#39;a t = unit -&gt; &#39;a               (* used to approximate prob or distrib *)
    let bind a b () = b (a ()) ()        (* Randomized computation -- each call a() *)
    let return a = fun () -&gt; a           (* is an independent sample. Always a. *)
  end
  include M
  include MonadOps (M)
  let choose p a b () =
    if Random.float 1. &lt;= p then a () else b ()
  let pick dist = fun () -&gt; roulette dist
  let uniform elems =
    let n = List.length elems in
    fun () -&gt; List.nth elems (Random.int n)
  let coin = Random.bool
  let flip p = choose p (return true) (return false)
  let prob p m =
    let count = ref 0 in
    for i = 1 to S.samples do
      if p (m ()) then incr count
    done;
    float_of_int !count /. float_of_int S.samples
  let distrib m =
    let dist = ref [] in
    for i = 1 to S.samples do
      dist := (m (), 1.) :: !dist done;
    normalize (merge !dist)
  let access m = m ()
end</code></pre>
<h4 id="example-the-monty-hall-problem">Example: The Monty Hall
Problem</h4>
<p>In search of a new car, the player picks a door, say 1. The game host
then opens one of the other doors, say 3, to reveal a goat and offers to
let the player pick door 2 instead of door 1.</p>
<pre><code>module MontyHall (P : PROBABILITY) = struct
  open P
  type door = A | B | C
  let doors = [A; B; C]

  let monty_win switch = perform
    prize &lt;-- uniform doors;
    chosen &lt;-- uniform doors;
    opened &lt;-- uniform
      (list_diff doors [prize; chosen]);
    let final =
      if switch then List.hd
        (list_diff doors [opened; chosen])
      else chosen in
    return (final = prize)
end

module MontyExact = MontyHall (DistribM)
module Sampling1000 =
  SamplingM (struct let samples = 1000 end)
module MontySimul = MontyHall (Sampling1000)

(* DistribM.distrib (MontyExact.monty_win false);;
   - : (bool * float) list = [(true, 0.333...); (false, 0.666...)]

   DistribM.distrib (MontyExact.monty_win true);;
   - : (bool * float) list = [(true, 0.666...); (false, 0.333...)] *)</code></pre>
<p>The famous result: switching doubles your chances of winning!</p>
<h4 id="conditional-probabilities">Conditional Probabilities</h4>
<p>Wouldn’t it be nice to have a monad-plus rather than just a monad? We
could use <code>guard</code> for conditional probabilities!</p>
<p>To compute <span class="math inline">P(A|B)</span>: 1. Compute what
is needed for both <span class="math inline">A</span> and <span
class="math inline">B</span> 2. Guard <span class="math inline">B</span>
3. Return <span class="math inline">A</span></p>
<p>For the exact distribution monad, we just need to allow intermediate
distributions to be unnormalized (sum to less than 1). For the sampling
monad, we use rejection sampling (though <code>mplus</code> has no
straightforward correct implementation).</p>
<pre><code>module type COND_PROBAB = sig
  include PROBABILITY
  include MONAD_PLUS_OPS with type &#39;a monad := &#39;a monad
end

module DistribMP : COND_PROBAB = struct
  module MP = struct
    type &#39;a t = (&#39;a * float) list      (* Measures no longer restricted to *)
    let bind a b = merge               (* probability distributions *)
      [y, q *. p | (x, p) &lt;- a; (y, q) &lt;- b x]
    let return a = [a, 1.]
    let mzero = []                     (* Measure equal 0 everywhere is OK *)
    let mplus = List.append
  end
  include MP
  include MonadPlusOps (MP)
  let choose p a b =                   (* It isn&#39;t a w.p. p &amp; b w.p. (1-p) since a and b *)
    List.map (fun (e,w) -&gt; e, p *. w) a @  (* are not normalized! *)
      List.map (fun (e,w) -&gt; e, (1. -. p) *. w) b
  let pick dist = dist
  let uniform elems = normalize
    (List.map (fun e -&gt; e, 1.) elems)
  let coin = [true, 0.5; false, 0.5]
  let flip p = [true, p; false, 1. -. p]
  let prob p m = normalize m           (* Final normalization step *)
    |&gt; List.filter (fun (e,_) -&gt; p e)
    |&gt; List.map snd |&gt; List.fold_left (+.) 0.
  let distrib m = normalize m
  let access m = roulette m
end

module SamplingMP (S : sig val samples : int end) : COND_PROBAB = struct
  exception Rejected                   (* For rejecting current sample *)
  module MP = struct                   (* Monad operations are exactly as for SamplingM *)
    type &#39;a t = unit -&gt; &#39;a
    let bind a b () = b (a ()) ()
    let return a = fun () -&gt; a
    let mzero = fun () -&gt; raise Rejected  (* but now we can fail *)
    let mplus a b = fun () -&gt;
      failwith &quot;SamplingMP.mplus not implemented&quot;
  end
  include MP
  include MonadPlusOps (MP)
  let choose p a b () =                (* Inside-monad operations don&#39;t change *)
    if Random.float 1. &lt;= p then a () else b ()
  let pick dist = fun () -&gt; roulette dist
  let uniform elems =
    let n = List.length elems in
    fun () -&gt; List.nth elems (Random.int n)
  let coin = Random.bool
  let flip p = choose p (return true) (return false)
  let prob p m =                       (* Getting out of monad: handle rejected samples *)
    let count = ref 0 and tot = ref 0 in
    while !tot &lt; S.samples do          (* Count up to the required *)
      try                              (* number of samples *)
        if p (m ()) then incr count;   (* m() can fail *)
        incr tot                       (* But if we got here it hasn&#39;t *)
      with Rejected -&gt; ()              (* Rejected, keep sampling *)
    done;
    float_of_int !count /. float_of_int S.samples
  let distrib m =
    let dist = ref [] and tot = ref 0 in
    while !tot &lt; S.samples do
      try
        dist := (m (), 1.) :: !dist;
        incr tot
      with Rejected -&gt; ()
    done;
    normalize (merge !dist)
  let rec access m =
    try m () with Rejected -&gt; access m
end</code></pre>
<h4 id="burglary-example-encoding-a-bayes-net">Burglary Example:
Encoding a Bayes Net</h4>
<p>Consider a problem with this dependency structure:</p>
<ul>
<li>An alarm can be due to either a burglary or an earthquake</li>
<li>You are on vacation and have asked neighbors John and Mary to call
if the alarm rings</li>
<li>Mary only calls when she is really sure about the alarm, but John
has better hearing</li>
<li>Earthquakes are twice as probable as burglaries</li>
<li>The alarm has about 30% chance of going off during an
earthquake</li>
<li>You can check on the radio if there was an earthquake, but you might
miss the news</li>
</ul>
<p>Probability tables: - <span class="math inline">P(\text{Burglary}) =
0.001</span> - <span class="math inline">P(\text{Earthquake}) =
0.002</span> - <span class="math inline">P(\text{Alarm}|\text{B},
\text{E})</span> varies (0.001 for FF, 0.29 for FT, 0.94 for TF, 0.95
for TT) - <span class="math inline">P(\text{John
calls}|\text{Alarm})</span> is 0.9 if alarm, 0.05 otherwise - <span
class="math inline">P(\text{Mary calls}|\text{Alarm})</span> is 0.7 if
alarm, 0.01 otherwise</p>
<pre><code>module Burglary (P : COND_PROBAB) = struct
  open P
  type what_happened =
    | Safe | Burgl | Earthq | Burgl_n_earthq

  let check ~john_called ~mary_called ~radio = perform
    earthquake &lt;-- flip 0.002;
    guard (radio = None || radio = Some earthquake);
    burglary &lt;-- flip 0.001;
    let alarm_p =
      match burglary, earthquake with
      | false, false -&gt; 0.001
      | false, true -&gt; 0.29
      | true, false -&gt; 0.94
      | true, true -&gt; 0.95 in
    alarm &lt;-- flip alarm_p;
    let john_p = if alarm then 0.9 else 0.05 in
    john_calls &lt;-- flip john_p;
    guard (john_calls = john_called);
    let mary_p = if alarm then 0.7 else 0.01 in
    mary_calls &lt;-- flip mary_p;
    guard (mary_calls = mary_called);
    match burglary, earthquake with
    | false, false -&gt; return Safe
    | true, false -&gt; return Burgl
    | false, true -&gt; return Earthq
    | true, true -&gt; return Burgl_n_earthq
end

module BurglaryExact = Burglary (DistribMP)
module Sampling2000 =
  SamplingMP (struct let samples = 2000 end)
module BurglarySimul = Burglary (Sampling2000)

(* DistribMP.distrib
     (BurglaryExact.check ~john_called:true ~mary_called:true ~radio:None);;
   - : (BurglaryExact.what_happened * float) list =
   [(Burgl_n_earthq, 0.000574...); (Earthq, 0.175...);
    (Burgl, 0.283...); (Safe, 0.540...)] *)</code></pre>
<h3 id="lightweight-cooperative-threads">8.14 Lightweight Cooperative
Threads</h3>
<p>The <code>bind</code> operation is inherently sequential:
<code>bind a (fun x -&gt; b)</code> computes <code>a</code>, and resumes
computing <code>b</code> only once the result <code>x</code> is
known.</p>
<p>For concurrency, we need to “suppress” this sequentiality. We
introduce:</p>
<pre><code>parallel : &#39;a monad -&gt; &#39;b monad -&gt; (&#39;a -&gt; &#39;b -&gt; &#39;c monad) -&gt; &#39;c monad</code></pre>
<p>where <code>parallel a b (fun x y -&gt; c)</code> does not wait for
<code>a</code> to be computed before it can start computing
<code>b</code>.</p>
<p>If the monad starts computing right away (as in the Lwt library),
<code>parallel ea eb c</code> is equivalent to:</p>
<pre><code>perform
  let a = ea in
  let b = eb in
  x &lt;-- a;
  y &lt;-- b;
  c x y</code></pre>
<h4 id="fine-grained-vs.-coarse-grained-concurrency">Fine-Grained
vs. Coarse-Grained Concurrency</h4>
<p>Under <strong>fine-grained</strong> concurrency, every
<code>bind</code> is suspended and computation moves to other threads.
It comes back to complete the <code>bind</code> before running threads
created since the <code>bind</code> was suspended.</p>
<p>Under <strong>coarse-grained</strong> concurrency, computation is
only suspended when requested via a <code>suspend</code> (often called
<code>yield</code>) operation. Library operations that need to wait for
an event or completion of I/O should call <code>suspend</code>
internally.</p>
<h4 id="thread-monad-signatures">Thread Monad Signatures</h4>
<pre><code>module type THREADS = sig
  include MONAD
  val parallel :
    &#39;a t -&gt; &#39;b t -&gt; (&#39;a -&gt; &#39;b -&gt; &#39;c t) -&gt; &#39;c t
end

module type THREAD_OPS = sig
  include MONAD_OPS
  include THREADS with type &#39;a t := &#39;a monad
  val parallel_map :
    &#39;a list -&gt; (&#39;a -&gt; &#39;b monad) -&gt; &#39;b list monad
  val (&gt;||=) :
    &#39;a monad -&gt; &#39;b monad -&gt; (&#39;a -&gt; &#39;b -&gt; &#39;c monad) -&gt; &#39;c monad
  val (&gt;||) :
    &#39;a monad -&gt; &#39;b monad -&gt; (unit -&gt; &#39;c monad) -&gt; &#39;c monad
end

module type THREADSYS = sig
  include THREADS
  val access : &#39;a t -&gt; &#39;a
  val kill_threads : unit -&gt; unit
end

module ThreadOps (M : THREADS) = struct
  open M
  include MonadOps (M)
  let parallel_map l f =
    List.fold_right (fun a bs -&gt;
      parallel (f a) bs
        (fun a bs -&gt; return (a::bs))) l (return [])
  let (&gt;||=) = parallel
  let (&gt;||) a b c = parallel a b (fun _ _ -&gt; c ())
end

module Threads (M : THREADSYS) : sig
  include THREAD_OPS
  val access : &#39;a monad -&gt; &#39;a
  val kill_threads : unit -&gt; unit
end = struct
  include M
  include ThreadOps(M)
end</code></pre>
<h4 id="cooperative-thread-implementation">Cooperative Thread
Implementation</h4>
<pre><code>module Cooperative = Threads(struct
  type &#39;a state =
    | Return of &#39;a                     (* The thread has returned *)
    | Sleep of (&#39;a -&gt; unit) list       (* When thread returns, wake up waiters *)
    | Link of &#39;a t                     (* A link to the actual thread *)
  and &#39;a t = {mutable state : &#39;a state}  (* State of the thread can change *)
                                       (* -- it can return, or more waiters can be added *)
  let rec find t =                     (* Union-find style link chasing *)
    match t.state with
    | Link t -&gt; find t
    | _ -&gt; t

  let jobs = Queue.create ()           (* Work queue -- will store unit -&gt; unit procedures *)

  let wakeup m a =                     (* Thread m has actually finished -- *)
    let m = find m in                  (* updating its state *)
    match m.state with
    | Return _ -&gt; assert false
    | Sleep waiters -&gt;
        m.state &lt;- Return a;           (* Set the state, and only then *)
        List.iter ((|&gt;) a) waiters     (* wake up the waiters *)
    | Link _ -&gt; assert false

  let return a = {state = Return a}

  let connect t t&#39; =                   (* t was a placeholder for t&#39; *)
    let t&#39; = find t&#39; in
    match t&#39;.state with
    | Sleep waiters&#39; -&gt;
        let t = find t in
        (match t.state with
        | Sleep waiters -&gt;             (* If both sleep, collect their waiters *)
            t.state &lt;- Sleep (waiters&#39; @ waiters);
            t&#39;.state &lt;- Link t         (* and link one to the other *)
        | _ -&gt; assert false)
    | Return x -&gt; wakeup t x           (* If t&#39; returned, wake up the placeholder *)
    | Link _ -&gt; assert false

  let rec bind a b =
    let a = find a in
    let m = {state = Sleep []} in      (* The resulting monad *)
    (match a.state with
    | Return x -&gt;                      (* If a returned, we suspend further work *)
        let job () = connect m (b x) in  (* (In exercise 11, this should *)
        Queue.push job jobs            (* only happen after suspend) *)
    | Sleep waiters -&gt;                 (* If a sleeps, we wait for it to return *)
        let job x = connect m (b x) in
        a.state &lt;- Sleep (job::waiters)
    | Link _ -&gt; assert false);
    m

  let parallel a b c = perform         (* Since in our implementation *)
    x &lt;-- a;                           (* the threads run as soon as they are created, *)
    y &lt;-- b;                           (* parallel is redundant *)
    c x y

  let rec access m =                   (* Accessing not only gets the result of m, *)
    let m = find m in                  (* but spins the thread loop till m terminates *)
    match m.state with
    | Return x -&gt; x                    (* No further work *)
    | Sleep _ -&gt;
        (try Queue.pop jobs ()         (* Perform suspended work *)
         with Queue.Empty -&gt;
           failwith &quot;access: result not available&quot;);
        access m
    | Link _ -&gt; assert false

  let kill_threads () = Queue.clear jobs  (* Remove pending work *)
end)</code></pre>
<h4 id="testing-the-thread-implementation">Testing the Thread
Implementation</h4>
<pre><code>module TTest (T : THREAD_OPS) = struct
  open T
  let rec loop s n = perform
    return (Printf.printf &quot;-- %s(%d)\n%!&quot; s n);
    if n &gt; 0 then loop s (n-1)         (* We cannot use whenM because *)
    else return ()                     (* the thread would be created regardless of condition *)
end

module TT = TTest (Cooperative)

let test =
  Cooperative.kill_threads ();         (* Clean-up after previous tests *)
  let thread1 = TT.loop &quot;A&quot; 5 in
  let thread2 = TT.loop &quot;B&quot; 4 in
  Cooperative.access thread1;          (* We ensure threads finish computing *)
  Cooperative.access thread2           (* before we proceed *)

(* Output:
   -- A(5)
   -- B(4)
   -- A(4)
   -- B(3)
   -- A(3)
   -- B(2)
   -- A(2)
   -- B(1)
   -- A(1)
   -- B(0)
   -- A(0)
   val test : unit = () *)</code></pre>
<p>The output shows that the threads interleave their execution, with
each <code>bind</code> causing a context switch.</p>
<h3 id="exercises-7">8.15 Exercises</h3>
<p><strong>Exercise 1.</strong> (Puzzle via Oleg Kiselyov)</p>
<p>“U2” has a concert that starts in 17 minutes and they must all cross
a bridge to get there. All four men begin on the same side of the
bridge. It is night. There is one flashlight. A maximum of two people
can cross at one time. Any party who crosses, either 1 or 2 people, must
have the flashlight with them. The flashlight must be walked back and
forth, it cannot be thrown, etc. Each band member walks at a different
speed. A pair must walk together at the rate of the slower man’s
pace:</p>
<ul>
<li>Bono: 1 minute to cross</li>
<li>Edge: 2 minutes to cross</li>
<li>Adam: 5 minutes to cross</li>
<li>Larry: 10 minutes to cross</li>
</ul>
<p>For example: if Bono and Larry walk across first, 10 minutes have
elapsed when they get to the other side of the bridge. If Larry then
returns with the flashlight, a total of 20 minutes have passed and you
have failed the mission.</p>
<p>Find all answers to the puzzle using a list comprehension. The
comprehension will be a bit long but recursion is not needed.</p>
<p><strong>Exercise 2.</strong> Assume <code>concat_map</code> as
defined in lecture 6. What will the following expressions return?
Why?</p>
<ol type="1">
<li><code>perform with (|-&gt;) in return 5; return 7</code></li>
<li><code>let guard p = if p then [()] else [];; perform with (|-&gt;) in guard false; return 7;;</code></li>
<li><code>perform with (|-&gt;) in return 5; guard false; return 7;;</code></li>
</ol>
<p><strong>Exercise 3.</strong> Define <code>bind</code> in terms of
<code>lift</code> and <code>join</code>.</p>
<p><strong>Exercise 4.</strong> Define a monad-plus implementation based
on binary trees, with constant-time <code>mzero</code> and
<code>mplus</code>. Starter code:</p>
<pre><code>type &#39;a tree = Empty | Leaf of &#39;a | T of &#39;a tree * &#39;a tree

module TreeM = MonadPlus (struct
  type &#39;a t = &#39;a tree
  let bind a b = (* TODO *)
  let return a = (* TODO *)
  let mzero = (* TODO *)
  let mplus a b = (* TODO *)
end)</code></pre>
<p><strong>Exercise 5.</strong> Show the monad-plus laws for one of: 1.
<code>TreeM</code> from your solution of exercise 4 2.
<code>ListM</code> from lecture</p>
<p><strong>Exercise 6.</strong> Why is the following monad-plus not lazy
enough?</p>
<pre><code>let rec badappend l1 l2 =
  match l1 with lazy LazNil -&gt; l2
  | lazy (LazCons (hd, tl)) -&gt;
      lazy (LazCons (hd, badappend tl l2))

let rec badconcatmap f = function
  | lazy LazNil -&gt; lazy LazNil
  | lazy (LazCons (a, l)) -&gt;
      badappend (f a) (badconcatmap f l)

module BadyListM = MonadPlus (struct
  type &#39;a t = &#39;a lazylist
  let bind a b = badconcatmap b a
  let return a = lazy (LazCons (a, lazy LazNil))
  let mzero = lazy LazNil
  let mplus = badappend
end)</code></pre>
<p><strong>Exercise 7.</strong> Convert a “rectangular” list of lists of
strings, representing a matrix with inner lists being rows, into a
string, where elements are column-aligned. (Exercise not related to
monads.)</p>
<p><strong>Exercise 8.</strong> Recall the enriched monad signature with
<code>('s, 'a) t</code> type. Design the signatures for the exception
monad operations to provide more flexibility than our exception monad.
Does the implementation need to change?</p>
<p><strong>Exercise 9.</strong> Implement the following constructs for
<em>all</em> monads:</p>
<ol type="1">
<li><code>for...to...</code></li>
<li><code>for...downto...</code></li>
<li><code>while...do...</code></li>
<li><code>do...while...</code></li>
<li><code>repeat...until...</code></li>
</ol>
<p>Explain how, when your implementation is instantiated with the StateM
monad, we get the solution to exercise 2 from lecture 4.</p>
<p><strong>Exercise 10.</strong> A canonical example of a probabilistic
model is that of a lawn whose grass may be wet because it rained,
because the sprinkler was on, or for some other reason. The probability
tables are:</p>
<p><span class="math display">
\begin{aligned}
P(\text{cloudy}) &amp;= 0.5 \\
P(\text{rain}|\text{cloudy}) &amp;= 0.8 \\
P(\text{rain}|\neg\text{cloudy}) &amp;= 0.2 \\
P(\text{sprinkler}|\text{cloudy}) &amp;= 0.1 \\
P(\text{sprinkler}|\neg\text{cloudy}) &amp;= 0.5 \\
P(\text{wet\_roof}|\neg\text{rain}) &amp;= 0 \\
P(\text{wet\_roof}|\text{rain}) &amp;= 0.7 \\
P(\text{wet\_grass}|\text{rain} \land \neg\text{sprinkler}) &amp;= 0.9
\\
P(\text{wet\_grass}|\text{sprinkler} \land \neg\text{rain}) &amp;= 0.9
\end{aligned}
</span></p>
<p>We observe whether the grass is wet and whether the roof is wet. What
is the probability that it rained?</p>
<p><strong>Exercise 11.</strong> Implement the coarse-grained
concurrency model:</p>
<ul>
<li>Modify <code>bind</code> to compute the resulting monad straight
away if the input monad has returned.</li>
<li>Introduce <code>suspend</code> to do what in the fine-grained model
was the effect of <code>bind (return a) b</code>, i.e., suspend the work
although it could already be started.</li>
<li>One possibility is to introduce <code>suspend</code> of type
<code>unit monad</code>, introduce a “dummy” monadic value
<code>Suspend</code> (besides <code>Return</code> and
<code>Sleep</code>), and define <code>bind suspend b</code> to do what
<code>bind (return ()) b</code> would formerly do.</li>
</ul>
<h2 id="chapter-9-compiler">Chapter 9: Compiler</h2>
<h3 id="compilation-runtime-optimization-and-parsing">Compilation,
Runtime, Optimization, and Parsing</h3>
<p>This chapter explores the practical aspects of OCaml development,
from compilation and runtime systems to performance optimization and
parsing techniques. We cover the OCaml toolchain, garbage collection,
stack frames and closures, profiling strategies, and both lexing with
<code>ocamllex</code> and parsing with Menhir.</p>
<p><strong>References:</strong> - Andrew W. Appel, <em>Modern Compiler
Implementation in ML</em> - E. Chailloux, P. Manoury, B. Pagano,
<em>Developing Applications with OCaml</em> - Jon D. Harrop, <em>OCaml
for Scientists</em> - Francois Pottier, Yann Regis-Gianas, <em>Menhir
Reference Manual</em></p>
<h3 id="ocaml-compilers">9.1 OCaml Compilers</h3>
<p>OCaml provides two primary compilers: the bytecode compiler
<code>ocamlc</code> and the native code compiler <code>ocamlopt</code>.
Natively compiled code typically runs about 10 times faster than
bytecode, though this varies by program.</p>
<p>OCaml also includes an interactive shell called the <em>toplevel</em>
(or <em>REPL</em> in other languages): <code>ocaml</code>, which is
based on the bytecode compiler. There is also a native-code-based
toplevel <code>ocamlnat</code>, though it is not currently part of the
binary distribution.</p>
<p>Third-party compilers extend OCaml’s reach to other platforms. Most
notably, <code>js_of_ocaml</code> translates OCaml bytecode into
JavaScript source. On modern JS virtual machines like V8, the resulting
code can be 2-3 times faster than code running on the OCaml virtual
machine (though it can also be slower in some cases).</p>
<h4 id="compilation-stages">Compilation Stages</h4>
<p>The compilation process proceeds through several stages:</p>
<table>
<thead>
<tr>
<th>Stage</th>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>Preprocessing</td>
<td>Source program</td>
<td>Transformed source or AST</td>
</tr>
<tr>
<td>Compiling</td>
<td>Source/AST</td>
<td>Assembly program</td>
</tr>
<tr>
<td>Assembling</td>
<td>Assembly program</td>
<td>Machine instructions</td>
</tr>
<tr>
<td>Linking</td>
<td>Machine instructions</td>
<td>Executable code</td>
</tr>
</tbody>
</table>
<h4 id="ocaml-programs-and-tools">OCaml Programs and Tools</h4>
<table>
<thead>
<tr>
<th>Program</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ocaml</code></td>
<td>Toplevel loop (REPL)</td>
</tr>
<tr>
<td><code>ocamlrun</code></td>
<td>Bytecode interpreter (VM)</td>
</tr>
<tr>
<td><code>camlp4</code></td>
<td>Preprocessor (syntax extensions)</td>
</tr>
<tr>
<td><code>ocamlc</code></td>
<td>Bytecode compiler</td>
</tr>
<tr>
<td><code>ocamlopt</code></td>
<td>Native code compiler</td>
</tr>
<tr>
<td><code>ocamlmktop</code></td>
<td>New toplevel constructor</td>
</tr>
<tr>
<td><code>ocamldep</code></td>
<td>Dependencies between modules</td>
</tr>
<tr>
<td><code>ocamlbuild</code></td>
<td>Building projects tool</td>
</tr>
<tr>
<td><code>ocamlbrowser</code></td>
<td>Graphical browsing of sources</td>
</tr>
</tbody>
</table>
<h4 id="file-extensions">File Extensions</h4>
<table>
<thead>
<tr>
<th>Extension</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.ml</code></td>
<td>OCaml source file</td>
</tr>
<tr>
<td><code>.mli</code></td>
<td>OCaml interface source file</td>
</tr>
<tr>
<td><code>.cmi</code></td>
<td>Compiled interface</td>
</tr>
<tr>
<td><code>.cmo</code></td>
<td>Bytecode-compiled file</td>
</tr>
<tr>
<td><code>.cmx</code></td>
<td>Native-code-compiled file</td>
</tr>
<tr>
<td><code>.cma</code></td>
<td>Bytecode-compiled library (several source files)</td>
</tr>
<tr>
<td><code>.cmxa</code></td>
<td>Native-code-compiled library</td>
</tr>
<tr>
<td><code>.cmt</code>/<code>.cmti</code>/<code>.annot</code></td>
<td>Type information for editors</td>
</tr>
<tr>
<td><code>.c</code></td>
<td>C source file</td>
</tr>
<tr>
<td><code>.o</code></td>
<td>C native-code-compiled file</td>
</tr>
<tr>
<td><code>.a</code></td>
<td>C native-code-compiled library</td>
</tr>
</tbody>
</table>
<h4 id="compiler-options">Compiler Options</h4>
<p>Both compilers share common command-line options:</p>
<table>
<colgroup>
<col style="width: 38%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-a</code></td>
<td>Construct a runtime library</td>
</tr>
<tr>
<td><code>-c</code></td>
<td>Compile without linking</td>
</tr>
<tr>
<td><code>-o name</code></td>
<td>Specify the name of the executable</td>
</tr>
<tr>
<td><code>-linkall</code></td>
<td>Link with all libraries used</td>
</tr>
<tr>
<td><code>-i</code></td>
<td>Display all compiled global declarations</td>
</tr>
<tr>
<td><code>-pp command</code></td>
<td>Use command as preprocessor</td>
</tr>
<tr>
<td><code>-unsafe</code></td>
<td>Turn off index checking for arrays</td>
</tr>
<tr>
<td><code>-v</code></td>
<td>Display the version of the compiler</td>
</tr>
<tr>
<td><code>-w list</code></td>
<td>Choose warning levels</td>
</tr>
<tr>
<td><code>-impl file</code></td>
<td>Indicate that file is a Caml source (.ml)</td>
</tr>
<tr>
<td><code>-intf file</code></td>
<td>Indicate that file is a Caml interface (.mli)</td>
</tr>
<tr>
<td><code>-I directory</code></td>
<td>Add directory to the search path; prefix <code>+</code> for
relative</td>
</tr>
<tr>
<td><code>-g</code></td>
<td>Generate debugging information</td>
</tr>
</tbody>
</table>
<p>Warning levels control which messages the compiler produces:</p>
<table>
<thead>
<tr>
<th>Level</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>A</code>/<code>a</code></td>
<td>Enable/disable all messages</td>
</tr>
<tr>
<td><code>F</code>/<code>f</code></td>
<td>Partial application in a sequence</td>
</tr>
<tr>
<td><code>P</code>/<code>p</code></td>
<td>Incomplete pattern matching</td>
</tr>
<tr>
<td><code>U</code>/<code>u</code></td>
<td>Missing cases in pattern matching</td>
</tr>
<tr>
<td><code>X</code>/<code>x</code></td>
<td>Enable/disable messages for hidden objects</td>
</tr>
<tr>
<td><code>M</code>/<code>m</code>, <code>V</code>/<code>v</code></td>
<td>Object-oriented related warnings</td>
</tr>
</tbody>
</table>
<p>The native compiler has additional options:</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-compact</code></td>
<td>Optimize the produced code for space</td>
</tr>
<tr>
<td><code>-S</code></td>
<td>Keep the assembly code in a file</td>
</tr>
<tr>
<td><code>-inline level</code></td>
<td>Set the aggressiveness of inlining</td>
</tr>
</tbody>
</table>
<h4 id="runtime-configuration">Runtime Configuration</h4>
<p>The <code>OCAMLRUNPARAM</code> environment variable controls runtime
behavior:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>b</code></td>
<td>Print detailed stack backtrace of runtime exceptions</td>
</tr>
<tr>
<td><code>s</code>/<code>h</code>/<code>i</code></td>
<td>Size of the minor heap/major heap/size increment</td>
</tr>
<tr>
<td><code>o</code>/<code>O</code></td>
<td>Major GC speed setting / heap compaction trigger setting</td>
</tr>
</tbody>
</table>
<p>Typical usage for running a program <code>prog</code> with
backtraces:</p>
<pre><code>export OCAMLRUNPARAM=&#39;b&#39;; ./prog</code></pre>
<p>To have stack backtraces, compile with the <code>-g</code>
option.</p>
<h4 id="toplevel-loop-directives">Toplevel Loop Directives</h4>
<p>The interactive toplevel supports several directives:</p>
<table>
<colgroup>
<col style="width: 45%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr>
<th>Directive</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>#quit;;</code></td>
<td>Exit the toplevel</td>
</tr>
<tr>
<td><code>#directory "dir";;</code></td>
<td>Add <code>dir</code> to the search path; <code>+</code> for
relative</td>
</tr>
<tr>
<td><code>#cd "dir-name";;</code></td>
<td>Change directory</td>
</tr>
<tr>
<td><code>#load "file-name";;</code></td>
<td>Load a bytecode <code>.cmo</code>/<code>.cma</code> file</td>
</tr>
<tr>
<td><code>#load_rec "file-name";;</code></td>
<td>Load the files <code>file-name</code> depends on too</td>
</tr>
<tr>
<td><code>#use "file-name";;</code></td>
<td>Read, compile and execute source phrases</td>
</tr>
<tr>
<td><code>#install_printer pr_nm;;</code></td>
<td>Register <code>pr_nm</code> to print values of a type</td>
</tr>
<tr>
<td><code>#print_depth num;;</code></td>
<td>How many nestings to print</td>
</tr>
<tr>
<td><code>#print_length num;;</code></td>
<td>How many nodes to print (the rest shows as <code>...</code>)</td>
</tr>
<tr>
<td><code>#trace func;;</code>/<code>#untrace</code></td>
<td>Trace calls to <code>func</code> / stop tracing</td>
</tr>
</tbody>
</table>
<h4 id="compiling-multiple-file-projects">9.1.1 Compiling Multiple-File
Projects</h4>
<p>Traditionally, the file containing a module has a lowercase name,
although the module name is always uppercase. Some developers prefer
uppercase file names to reflect module names (e.g.,
<code>MyModule.ml</code> rather than <code>myModule.ml</code> for a
module <code>MyModule</code>).</p>
<p>Consider a project with a main module <code>main.ml</code> and helper
modules <code>sub1.ml</code> and <code>sub2.ml</code> with corresponding
interfaces.</p>
<p><strong>Native compilation by hand:</strong></p>
<pre><code>$ ocamlopt sub1.mli
$ ocamlopt sub2.mli
$ ocamlopt -c sub1.ml
$ ocamlopt -c sub2.ml
$ ocamlopt -c main.ml
$ ocamlopt unix.cmxa sub1.cmx sub2.cmx main.cmx -o prog
$ ./prog</code></pre>
<p><strong>Native compilation using <code>make</code>:</strong></p>
<div class="sourceCode" id="cb315"><pre
class="sourceCode makefile"><code class="sourceCode makefile"><span id="cb315-1"><a href="#cb315-1" aria-hidden="true" tabindex="-1"></a><span class="dt">PROG</span> <span class="ch">:=</span><span class="st"> prog</span></span>
<span id="cb315-2"><a href="#cb315-2" aria-hidden="true" tabindex="-1"></a><span class="dt">LIBS</span> <span class="ch">:=</span><span class="st"> unix</span></span>
<span id="cb315-3"><a href="#cb315-3" aria-hidden="true" tabindex="-1"></a><span class="dt">SOURCES</span> <span class="ch">:=</span><span class="st"> sub1.ml sub2.ml main.ml</span></span>
<span id="cb315-4"><a href="#cb315-4" aria-hidden="true" tabindex="-1"></a><span class="dt">INTERFACES</span> <span class="ch">:=</span><span class="st"> </span><span class="ch">$(</span><span class="kw">wildcard</span><span class="st"> *.mli</span><span class="ch">)</span></span>
<span id="cb315-5"><a href="#cb315-5" aria-hidden="true" tabindex="-1"></a><span class="dt">OBJS</span> <span class="ch">:=</span><span class="st"> </span><span class="ch">$(</span><span class="kw">patsubst</span><span class="st"> %.ml</span><span class="kw">,</span><span class="st">%.cmx</span><span class="kw">,</span><span class="ch">$(</span><span class="dt">SOURCES</span><span class="ch">))</span></span>
<span id="cb315-6"><a href="#cb315-6" aria-hidden="true" tabindex="-1"></a><span class="dt">LIBS</span> <span class="ch">:=</span><span class="st"> </span><span class="ch">$(</span><span class="kw">patsubst</span><span class="st"> %</span><span class="kw">,</span><span class="st">%.cmxa</span><span class="kw">,</span><span class="ch">$(</span><span class="dt">LIBS</span><span class="ch">))</span></span>
<span id="cb315-7"><a href="#cb315-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb315-8"><a href="#cb315-8" aria-hidden="true" tabindex="-1"></a><span class="dv">$(PROG):</span><span class="dt"> </span><span class="ch">$(</span><span class="dt">OBJS</span><span class="ch">)</span></span>
<span id="cb315-9"><a href="#cb315-9" aria-hidden="true" tabindex="-1"></a><span class="er">    </span>ocamlopt -o <span class="ch">$@</span> <span class="ch">$(</span><span class="dt">LIBS</span><span class="ch">)</span> <span class="ch">$(</span><span class="dt">OBJS</span><span class="ch">)</span></span>
<span id="cb315-10"><a href="#cb315-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb315-11"><a href="#cb315-11" aria-hidden="true" tabindex="-1"></a><span class="dv">clean:</span></span>
<span id="cb315-12"><a href="#cb315-12" aria-hidden="true" tabindex="-1"></a><span class="er">    </span>rm -rf <span class="ch">$(</span><span class="dt">PROG</span><span class="ch">)</span> *.o *.cmx *.cmi *~</span>
<span id="cb315-13"><a href="#cb315-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb315-14"><a href="#cb315-14" aria-hidden="true" tabindex="-1"></a><span class="dv">%.cmx:</span><span class="dt"> %.ml</span></span>
<span id="cb315-15"><a href="#cb315-15" aria-hidden="true" tabindex="-1"></a><span class="er">    </span>ocamlopt -c <span class="ch">$*</span>.ml</span>
<span id="cb315-16"><a href="#cb315-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb315-17"><a href="#cb315-17" aria-hidden="true" tabindex="-1"></a><span class="dv">%.cmi:</span><span class="dt"> %.mli</span></span>
<span id="cb315-18"><a href="#cb315-18" aria-hidden="true" tabindex="-1"></a><span class="er">    </span>ocamlopt -c <span class="ch">$*</span>.mli</span>
<span id="cb315-19"><a href="#cb315-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb315-20"><a href="#cb315-20" aria-hidden="true" tabindex="-1"></a><span class="dv">depend:</span><span class="dt"> </span><span class="ch">$(</span><span class="dt">SOURCES</span><span class="ch">)</span><span class="dt"> </span><span class="ch">$(</span><span class="dt">INTERFACES</span><span class="ch">)</span></span>
<span id="cb315-21"><a href="#cb315-21" aria-hidden="true" tabindex="-1"></a><span class="er">    </span>ocamldep -native <span class="ch">$(</span><span class="dt">SOURCES</span><span class="ch">)</span> <span class="ch">$(</span><span class="dt">INTERFACES</span><span class="ch">)</span></span></code></pre></div>
<p>First use: <code>touch .depend; make depend; make</code>. Later, just
<code>make</code>, and run <code>make depend</code> after creating new
source files.</p>
<p><strong>Using <code>ocamlbuild</code>:</strong> - Files with compiled
code are created in the <code>_build</code> directory - Command:
<code>ocamlbuild -libs unix main.native</code> - The resulting program
is called <code>main.native</code> (in directory <code>_build</code>,
with a link in the project directory) - Multiple libraries:
<code>ocamlbuild -libs nums,unix,graphics main.native</code> - Passing
compiler parameters:
<code>ocamlbuild -cflags -I,+lablgtk,-rectypes hello.native</code> -
Adding <code>--</code> at the end compiles and runs the program:
<code>ocamlbuild -libs unix main.native --</code></p>
<h4 id="editors-and-ides">9.1.2 Editors and IDEs</h4>
<p>Several editors provide OCaml support:</p>
<p><strong>Emacs:</strong> - <code>ocaml-mode</code> from the standard
distribution - Alternative: <code>tuareg-mode</code>
(https://forge.ocamlcore.org/projects/tuareg/) - <code>camldebug</code>
integration with debugger - Type feedback with <code>C-c C-t</code> key
shortcut (needs <code>.annot</code> files)</p>
<p><strong>Vim:</strong> - OMLet plugin - Type lookup with
<code>ocaml-annot</code> or other plugins</p>
<p><strong>Eclipse:</strong> - <em>OCaml Development Tools</em>
(http://ocamldt.free.fr/)</p>
<p><strong>TypeRex</strong> (http://www.typerex.org/): - Auto-completion
of identifiers (experimental) - Browsing of identifiers: show type and
comment, go to definition - Local and whole-program refactoring:
renaming identifiers and compilation units, <code>open</code>
elimination</p>
<p><strong>Indentation tool <code>ocp-indent</code></strong>
(https://github.com/OCamlPro/ocp-indent): - Installation instructions
for Emacs and Vim - Can be used with other editors</p>
<p><strong>Dedicated editors:</strong> - OCamlEditor -
<code>ocamlbrowser</code> inspects libraries and programs (browsing
contents of modules, search by name and by type, basic editing with
syntax highlighting)</p>
<h3 id="imperative-features-in-ocaml">9.2 Imperative Features in
OCaml</h3>
<p>OCaml is <strong>not</strong> a <em>purely functional</em> language.
It has built-in imperative features:</p>
<p><strong>Mutable arrays:</strong></p>
<div class="sourceCode" id="cb316"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb316-1"><a href="#cb316-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> a = <span class="dt">Array</span>.make <span class="dv">5</span> <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb316-2"><a href="#cb316-2" aria-hidden="true" tabindex="-1"></a>a.(<span class="dv">3</span>) &lt;- <span class="dv">7</span>; a.(<span class="dv">2</span>), a.(<span class="dv">3</span>)</span></code></pre></div>
<p>Hashtables in the standard distribution are based on arrays:</p>
<div class="sourceCode" id="cb317"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb317-1"><a href="#cb317-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> h = <span class="dt">Hashtbl</span>.create <span class="dv">11</span> <span class="kw">in</span>  <span class="co">(* Takes initial size of the array *)</span></span>
<span id="cb317-2"><a href="#cb317-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Hashtbl</span>.add h <span class="st">&quot;Alpha&quot;</span> <span class="dv">5</span>; <span class="dt">Hashtbl</span>.find h <span class="st">&quot;Alpha&quot;</span></span></code></pre></div>
<p><strong>Mutable strings</strong> (for historical reasons):</p>
<div class="sourceCode" id="cb318"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb318-1"><a href="#cb318-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> a = <span class="dt">Bytes</span>.make <span class="dv">4</span> <span class="ch">&#39;a&#39;</span> <span class="kw">in</span></span>
<span id="cb318-2"><a href="#cb318-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Bytes</span>.set a <span class="dv">2</span> <span class="ch">&#39;b&#39;</span>; <span class="dt">Bytes</span>.get a <span class="dv">2</span>, <span class="dt">Bytes</span>.get a <span class="dv">3</span></span></code></pre></div>
<p>Extensible mutable strings are provided by <code>Buffer.t</code> in
the standard distribution.</p>
<p><strong>Loops:</strong> -
<code>for i = a to/downto b do body done</code> -
<code>while condition do body done</code></p>
<p><strong>Mutable record fields:</strong></p>
<div class="sourceCode" id="cb319"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb319-1"><a href="#cb319-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a <span class="dt">ref</span> = { <span class="kw">mutable</span> contents : &#39;a }  <span class="co">(* Single, mutable field *)</span></span></code></pre></div>
<p>A record can have both mutable and immutable fields.</p>
<ul>
<li>Modifying the field: <code>record.field &lt;- new_value</code></li>
<li>The <code>ref</code> type has operations:</li>
</ul>
<div class="sourceCode" id="cb320"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb320-1"><a href="#cb320-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (:=) r v = r.contents &lt;- v</span>
<span id="cb320-2"><a href="#cb320-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (!) r = r.contents</span></code></pre></div>
<p><strong>Exceptions</strong> are defined by <code>exception</code>,
raised by <code>raise</code>, and caught by
<code>try</code>-<code>with</code> clauses. An exception is a variant of
type <code>exception</code>, which is the only open algebraic datatype –
new variants can be added to it.</p>
<p><strong>Input-output functions</strong> have no “type safeguards” (no
<em>IO monad</em>).</p>
<p>Using <strong>global</strong> state (e.g., reference cells) makes
code <em>non re-entrant</em>: you must finish one task before starting
another – any form of concurrency is excluded.</p>
<h4 id="parsing-command-line-arguments">9.2.1 Parsing Command-Line
Arguments</h4>
<p>To go beyond the <code>Sys.argv</code> array, see the
<code>Arg</code> module
(http://caml.inria.fr/pub/docs/manual-ocaml/libref/Arg.html).</p>
<p>Example: configuring a Mine Sweeper game:</p>
<pre><code>type config = {
   nbcols  : int; nbrows : int; nbmines : int
}

let default_config = { nbcols=10; nbrows=10; nbmines=15 }

let set_nbcols cf n = cf := {!cf with nbcols = n}
let set_nbrows cf n = cf := {!cf with nbrows = n}
let set_nbmines cf n = cf := {!cf with nbmines = n}

let read_args() =
  let cf = ref default_config in  (* State of configuration *)
  let speclist =                  (* will be updated by given functions *)
   [(&quot;-col&quot;, Arg.Int (set_nbcols cf), &quot;number of columns&quot;);
    (&quot;-lin&quot;, Arg.Int (set_nbrows cf), &quot;number of lines&quot;);
    (&quot;-min&quot;, Arg.Int (set_nbmines cf), &quot;number of mines&quot;)] in
  let usage_msg =
    &quot;usage : minesweep [-col n] [-lin n] [-min n]&quot; in
   Arg.parse speclist (fun s -&gt; ()) usage_msg; !cf</code></pre>
<h3 id="ocaml-garbage-collection">9.3 OCaml Garbage Collection</h3>
<h4 id="representation-of-values">9.3.1 Representation of Values</h4>
<p>OCaml uses a uniform value representation to support garbage
collection:</p>
<ul>
<li><strong>Pointers</strong> always end with <code>00</code> in binary
(addresses are in number of bytes)</li>
<li><strong>Integers</strong> are represented by shifting them 1 bit,
setting the last bit to <code>1</code></li>
<li><strong>Constant constructors</strong> (variants without parameters)
like <code>None</code>, <code>[]</code>, and <code>()</code>, and other
integer-like types (<code>char</code>, <code>bool</code>) are
represented the same way as integers</li>
<li><strong>Pointers</strong> are always to OCaml <em>blocks</em>.
Variants with parameters, strings, and OCaml arrays are stored as
blocks</li>
<li>A <strong>block</strong> starts with a header, followed by an array
of values of size 1 word (either integer-like, or pointers)</li>
<li>The <strong>header</strong> stores the size of the block, the 2-bit
color used for garbage collection, and an 8-bit <em>tag</em> (which
variant it is)
<ul>
<li>Therefore there can be at most about 240 variants with parameters in
a variant type (some tag numbers are reserved)</li>
<li><em>Polymorphic variants</em> are a different story</li>
</ul></li>
</ul>
<h4 id="generational-garbage-collection">9.3.2 Generational Garbage
Collection</h4>
<p>OCaml has two heaps to store blocks: a small, continuous <em>minor
heap</em> and a growing-as-necessary <em>major heap</em>.</p>
<p>Allocation simply moves the minor heap pointer (aka. the <em>young
pointer</em>) and returns the pointed address. Allocation of very large
blocks uses the major heap instead.</p>
<p>When the minor heap runs out of space, it triggers the <em>minor
(garbage) collection</em>, which uses the <em>Stop and Copy</em>
algorithm. Together with the minor collection, a slice of <em>major
(garbage) collection</em> is performed to clean up the major heap a
bit.</p>
<p>The major heap is not cleaned all at once because it might stop the
main program for too long. Major collection uses the <em>Mark and
Sweep</em> algorithm.</p>
<p>This generational approach works well when most minor heap blocks are
already not needed when collection starts – garbage does
<strong>not</strong> slow down collection.</p>
<h4 id="stop-and-copy-gc">9.3.3 Stop and Copy GC</h4>
<p>Minor collection starts from a set of <em>roots</em> – young blocks
that definitely are not garbage.</p>
<p>Besides the root set, OCaml also maintains the <em>remembered
set</em> of minor heap blocks pointed at from the major heap. Most
mutations must check whether they assign a minor heap block to a major
heap block field. This is called the <em>write barrier</em>.</p>
<p>Immutable blocks cannot contain pointers from major to minor heap
(unless they are <code>lazy</code> blocks).</p>
<p>Collection follows pointers in the root set and remembered set to
find other used blocks. Every found block is copied to the major heap.
At the end of collection, the young pointer is reset so that the minor
heap is empty again.</p>
<h4 id="mark-and-sweep-gc">9.3.4 Mark and Sweep GC</h4>
<p>Major collection starts from a separate root set – old blocks that
definitely are not garbage.</p>
<p>Major garbage collection consists of a <em>mark</em> phase which
colors blocks that are still in use and a <em>sweep</em> phase that
searches for stretches of unused memory. Slices of the mark phase are
performed by/after each minor collection. Unused memory is stored in a
<em>free list</em>.</p>
<p>The “proper” major collection is started when a minor collection
consumes the remaining free list. The mark phase is finished and sweep
phase performed.</p>
<p>The colors used are: - <strong>gray</strong>: marked cells whose
descendants are not yet marked - <strong>black</strong>: marked cells
whose descendants are also marked - <strong>hatched</strong>: free list
element - <strong>white</strong>: elements previously being in use</p>
<p>Example of garbage collection in action:</p>
<div class="sourceCode" id="cb322"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb322-1"><a href="#cb322-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> u = <span class="kw">let</span> l = [<span class="ch">&#39;c&#39;</span>; <span class="ch">&#39;a&#39;</span>; <span class="ch">&#39;m&#39;</span>] <span class="kw">in</span> <span class="dt">List</span>.tl l;;</span>
<span id="cb322-2"><a href="#cb322-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> u : <span class="dt">char</span> <span class="dt">list</span> = [<span class="ch">&#39;a&#39;</span>; <span class="ch">&#39;m&#39;</span>]</span>
<span id="cb322-3"><a href="#cb322-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb322-4"><a href="#cb322-4" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> v = <span class="kw">let</span> r = ( [<span class="ch">&#39;z&#39;</span>] , u ) <span class="kw">in</span> <span class="kw">match</span> r <span class="kw">with</span> p -&gt; (<span class="dt">fst</span> p) @ (<span class="dt">snd</span> p);;</span>
<span id="cb322-5"><a href="#cb322-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> v : <span class="dt">char</span> <span class="dt">list</span> = [<span class="ch">&#39;z&#39;</span>; <span class="ch">&#39;a&#39;</span>; <span class="ch">&#39;m&#39;</span>]</span></code></pre></div>
<p>During the marking phase, reachable cells are colored gray, then
black as their descendants are processed. During the sweep phase, white
(unreachable) cells are added to the free list.</p>
<h3 id="stack-frames-and-closures">9.4 Stack Frames and Closures</h3>
<p>The nesting of procedure calls is reflected in the <em>stack</em> of
procedure data. The stretch of stack dedicated to a single function is a
<em>stack frame</em> (aka. <em>activation record</em>).</p>
<p>The <em>stack pointer</em> is where we create new frames, stored in a
special register. The <em>frame pointer</em> allows referring to
function data by offset – data known early in compilation is close to
the frame pointer.</p>
<p><strong>Local variables</strong> are stored in the stack frame or in
registers. Some registers need to be saved prior to function call
(<em>caller-save</em>) or at entry to a function (<em>callee-save</em>).
OCaml avoids callee-save registers.</p>
<p>Up to 4-6 arguments can be passed in registers, with remaining ones
on the stack. Note that the <em>x86</em> architecture has a small number
of registers.</p>
<p>Using registers, tail call optimization, and function inlining can
eliminate the use of stack entirely. The OCaml compiler can also use
stack more efficiently than by creating full stack frames.</p>
<p>A typical stack frame contains (from higher to lower addresses): -
Incoming arguments (argument n … argument 1, static link) - Local
variables - Return address - Temporaries - Saved registers - Outgoing
arguments (argument m … argument 1, static link)</p>
<p><em>Static links</em> point to stack frames of parent functions, so
we can access stack-based data (e.g., arguments of a main function from
inside an <code>aux</code> helper function).</p>
<p>A <strong><em>closure</em></strong> represents a function: it is a
block that contains the address of the function (either another closure
or a machine-code pointer) and a way to access non-local variables of
the function. For partially applied functions, it contains the values of
arguments and the address of the original function.</p>
<p><em>Escaping variables</em> are the variables of a function
<code>f</code> (arguments and local definitions) which are accessed from
a nested function that is part of the returned value of <code>f</code>
(or assigned to a mutable field). Escaping variables must be either part
of the closures representing the nested functions, or of a closure
representing the function <code>f</code> – in the latter case, the
nested functions must also be represented by closures that have a link
to the closure of <code>f</code>.</p>
<h4 id="tail-recursion">9.4.1 Tail Recursion</h4>
<p>A function call <code>f x</code> within the body of another function
<code>g</code> is in <em>tail position</em> if, roughly, “calling
<code>f</code> is the last thing that <code>g</code> will do before
returning.”</p>
<p><strong>Important:</strong> A call inside a <code>try ... with</code>
clause is <strong>not</strong> in tail position! For efficient
exceptions, OCaml stores <em>traps</em> for
<code>try</code>-<code>with</code> on the stack with the topmost trap in
a register; after <code>raise</code>, it unwinds directly to the
trap.</p>
<p>The steps for a tail call are: 1. Move actual parameters into
argument registers (if they aren’t already there) 2. Restore callee-save
registers (if needed) 3. Pop the stack frame of the calling function (if
it has one) 4. Jump to the callee</p>
<p>Bytecode always throws a <code>Stack_overflow</code> exception on too
deep recursion; native code will sometimes cause a <em>segmentation
fault</em>!</p>
<p><strong>Note:</strong> <code>List.map</code> from the standard
distribution is <strong>not</strong> tail-recursive.</p>
<h4 id="generated-assembly">9.4.2 Generated Assembly</h4>
<p>For examples of generated assembly code and performance analysis, see
http://ocaml.org/tutorials/performance_and_profiling.html</p>
<h3 id="profiling-and-optimization">9.5 Profiling and Optimization</h3>
<p>Steps for optimizing a program:</p>
<ol type="1">
<li><strong>Profile</strong> the program to find bottlenecks: where the
time is spent</li>
<li>If possible, modify the algorithm used by the bottleneck to an
algorithm with better asymptotic complexity</li>
<li>If possible, modify the bottleneck algorithm to access data less
randomly, to increase <em>cache locality</em>
<ul>
<li>Additionally, <em>realtime</em> systems may require avoiding use of
huge arrays, traversed by the garbage collector in one go</li>
</ul></li>
<li>Experiment with various implementations of data structures used
(related to step 3)</li>
<li>Avoid <em>boxing</em> and polymorphic functions, especially for
numerical processing (OCaml specific)</li>
<li><em>Deforestation</em></li>
<li><em>Defunctorization</em></li>
</ol>
<h4 id="profiling">9.5.1 Profiling</h4>
<p>We cover native code profiling because it is more useful. It relies
on the Unix profiling program <code>gprof</code>.</p>
<p>First, compile the sources in profiling mode:
<code>ocamlopt -p ...</code></p>
<p>Or using <code>ocamlbuild</code> when the program source is in
<code>prog.ml</code>:</p>
<pre><code>ocamlbuild prog.p.native --</code></pre>
<p>The execution of program <code>./prog</code> produces a file
<code>gmon.out</code>.</p>
<p>We call <code>gprof prog &gt; profile.txt</code> (or
<code>gprof prog.p.native &gt; profile.txt</code> when using
<code>ocamlbuild</code>). This redirects profiling analysis to
<code>profile.txt</code>.</p>
<p>The result <code>profile.txt</code> has three parts: 1. List of
functions in the program in descending order of time spent within the
body of the function, excluding time spent in other functions 2. A
hierarchical representation of the time taken by each function, and the
total time spent in it, including time spent in functions it called 3. A
bibliography of function references</p>
<p>It contains C/assembly function names like
<code>camlList__assoc_1169</code>: - Prefix <code>caml</code> means the
function comes from OCaml source - <code>List__</code> means it belongs
to a <code>List</code> module - <code>assoc</code> is the name of the
function in source - Postfix <code>_1169</code> is used to avoid name
clashes, as in OCaml different functions often have the same names</p>
<p><strong>Example: computing a words histogram for a large file
(<code>Optim0.ml</code>):</strong></p>
<pre><code>let read_words file =                      (* Imperative programming example *)
  let input = open_in file in
  let words = ref [] and more = ref true in
  try                 (* Lecture 6 read_lines function would stack-overflow *)
    while !more do                         (* because of the try-with clause *)
      Scanf.fscanf input &quot;%[^a-zA-Z0-9&#39;]%[a-zA-Z0-9&#39;]&quot;
        (fun _ x -&gt; words := x :: !words; more := x &lt;&gt; &quot;&quot;)
    done;
    List.rev (List.tl !words)
  with End_of_file -&gt; List.rev !words

let empty () = []

let increment h w =                                  (* Inefficient map update *)
  try
    let c = List.assoc w h in
    (w, c+1) :: List.remove_assoc w h
  with Not_found -&gt; (w, 1)::h

let iterate f h =
  List.iter (fun (k,v)-&gt;f k v) h

let histogram words =
  List.fold_left increment (empty ()) words</code></pre>
<p>The profiling analysis first part begins with:</p>
<pre><code>  %   cumulative   self              self     total
 time   seconds   seconds    calls   s/call   s/call  name
 37.88      8.54     8.54 306656698    0.00     0.00  compare_val
 19.97     13.04     4.50   273169     0.00     0.00  camlList__assoc_1169
  9.17     15.10     2.07 633527269    0.00     0.00  caml_page_table_lookup
  8.72     17.07     1.97   260756    0.00  0.00 camlList__remove_assoc_1189
  7.10     18.67     1.60 612779467    0.00     0.00  caml_string_length
  4.97     19.79     1.12 306656692     0.00    0.00  caml_compare
  2.84     20.43     0.64                             caml_c_call
  1.53     20.77     0.35    14417     0.00     0.00  caml_page_table_modify
  1.07     21.01     0.24     1115     0.00     0.00  sweep_slice
  0.89     21.21     0.20      484     0.00     0.00  mark_slice</code></pre>
<p><code>List.assoc</code> and <code>List.remove_assoc</code> high in
the ranking suggests that <code>increment</code> could be the
bottleneck. They both use comparison, which could explain why
<code>compare_val</code> consumes the most time.</p>
<p>The second part shows data about the <code>increment</code> function.
Each block describes the function whose line starts with an index in
brackets, with callers above and callees below:</p>
<pre><code>index % time    self  children    called     name
-----------------------------------------------
                0.00    6.47  273169/273169  camlList__fold_left_1078 [7]
[8]     28.7    0.00    6.47  273169         camlOptim0__increment_1038 [8]
                4.50    0.00  273169/273169  camlList__assoc_1169 [9]
               1.97    0.00  260756/260756  camlList__remove_assoc_1189 [11]</code></pre>
<p>As expected, <code>increment</code> is only called by
<code>List.fold_left</code>. But it seems to account for only 29% of
time because <code>compare</code> is not analyzed correctly, thus not
included in time for <code>increment</code>.</p>
<h4 id="algorithmic-optimizations">9.5.2 Algorithmic Optimizations</h4>
<p>All times measured with profiling turned on:</p>
<p><strong><code>Optim0.ml</code></strong>: asymptotic time complexity
<span class="math inline">\mathcal{O}(n^2)</span>, time: 22.53s -
Garbage collection takes 6% of time - So little because data access
wastes a lot of time</p>
<p><strong>Optimize the data structure, keep the algorithm:</strong></p>
<div class="sourceCode" id="cb327"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb327-1"><a href="#cb327-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> empty () = <span class="dt">Hashtbl</span>.create <span class="dv">511</span></span>
<span id="cb327-2"><a href="#cb327-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb327-3"><a href="#cb327-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> increment h w =</span>
<span id="cb327-4"><a href="#cb327-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">try</span></span>
<span id="cb327-5"><a href="#cb327-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> c = <span class="dt">Hashtbl</span>.find h w <span class="kw">in</span></span>
<span id="cb327-6"><a href="#cb327-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Hashtbl</span>.replace h w (c+<span class="dv">1</span>); h</span>
<span id="cb327-7"><a href="#cb327-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">with</span> <span class="dt">Not_found</span> -&gt; <span class="dt">Hashtbl</span>.add h w <span class="dv">1</span>; h</span>
<span id="cb327-8"><a href="#cb327-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb327-9"><a href="#cb327-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> iterate f h = <span class="dt">Hashtbl</span>.iter f h</span></code></pre></div>
<p><strong><code>Optim1.ml</code></strong>: asymptotic time complexity
<span class="math inline">\mathcal{O}(n)</span>, time: 0.63s - Garbage
collection takes 17% of time</p>
<p><strong>Optimize the algorithm, keep the data structure:</strong></p>
<div class="sourceCode" id="cb328"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb328-1"><a href="#cb328-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> histogram words =</span>
<span id="cb328-2"><a href="#cb328-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> words = <span class="dt">List</span>.sort <span class="dt">String</span>.<span class="dt">compare</span> words <span class="kw">in</span></span>
<span id="cb328-3"><a href="#cb328-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> k,c,h = <span class="dt">List</span>.fold_left</span>
<span id="cb328-4"><a href="#cb328-4" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">fun</span> (k,c,h) w -&gt;</span>
<span id="cb328-5"><a href="#cb328-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> k = w <span class="kw">then</span> k, c+<span class="dv">1</span>, h <span class="kw">else</span> w, <span class="dv">1</span>, ((k,c)::h))</span>
<span id="cb328-6"><a href="#cb328-6" aria-hidden="true" tabindex="-1"></a>    (<span class="st">&quot;&quot;</span>, <span class="dv">0</span>, []) words <span class="kw">in</span></span>
<span id="cb328-7"><a href="#cb328-7" aria-hidden="true" tabindex="-1"></a>  (k,c)::h</span></code></pre></div>
<p><strong><code>Optim2.ml</code></strong>: asymptotic time complexity
<span class="math inline">\mathcal{O}(n \log n)</span>, time: 1s -
Garbage collection takes 40% of time</p>
<p>Optimizing for cache efficiency is more advanced; we will not attempt
it here.</p>
<p>With algorithmic optimizations we should be concerned with
<strong>asymptotic complexity</strong> in terms of the <span
class="math inline">\mathcal{O}(\cdot)</span> notation, but we will not
pursue complexity analysis in the remainder of the chapter.</p>
<h4 id="low-level-optimizations">9.5.3 Low-Level Optimizations</h4>
<p>The optimizations below have been made <em>for educational purposes
only</em>.</p>
<p><strong>Avoid polymorphism in generic comparison function
<code>(=)</code>:</strong></p>
<div class="sourceCode" id="cb329"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb329-1"><a href="#cb329-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> assoc x = <span class="kw">function</span></span>
<span id="cb329-2"><a href="#cb329-2" aria-hidden="true" tabindex="-1"></a>    [] -&gt; <span class="dt">raise</span> <span class="dt">Not_found</span></span>
<span id="cb329-3"><a href="#cb329-3" aria-hidden="true" tabindex="-1"></a>  | (a,b)::l -&gt; <span class="kw">if</span> <span class="dt">String</span>.<span class="dt">compare</span> a x = <span class="dv">0</span> <span class="kw">then</span> b <span class="kw">else</span> assoc x l</span>
<span id="cb329-4"><a href="#cb329-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb329-5"><a href="#cb329-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> remove_assoc x = <span class="kw">function</span></span>
<span id="cb329-6"><a href="#cb329-6" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; []</span>
<span id="cb329-7"><a href="#cb329-7" aria-hidden="true" tabindex="-1"></a>  | (a, b <span class="kw">as</span> pair) :: l -&gt;</span>
<span id="cb329-8"><a href="#cb329-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> <span class="dt">String</span>.<span class="dt">compare</span> a x = <span class="dv">0</span> <span class="kw">then</span> l <span class="kw">else</span> pair :: remove_assoc x l</span></code></pre></div>
<p><strong><code>Optim3.ml</code></strong> (based on
<code>Optim0.ml</code>): time: 19s</p>
<p>Despite implementation-wise the code being the same (as
<code>String.compare</code> equals <code>Pervasives.compare</code>
inside module <code>String</code>, and <code>List.assoc</code> is like
above but uses <code>Pervasives.compare</code>), we removed
polymorphism, so no longer need the <code>caml_compare_val</code>
function.</p>
<p>Usually, adding type annotations would be enough (especially useful
for numeric types <code>int</code>, <code>float</code>).</p>
<p><strong>Deforestation</strong> means removing intermediate data
structures:</p>
<pre><code>let read_to_histogram file =
  let input = open_in file in
  let h = empty () and more = ref true in
  try
    while !more do
      Scanf.fscanf input &quot;%[^a-zA-Z0-9&#39;]%[a-zA-Z0-9&#39;]&quot;
        (fun _ w -&gt;
          let w = String.lowercase_ascii w in
          ignore (increment h w); more := w &lt;&gt; &quot;&quot;)
    done; h
  with End_of_file -&gt; h</code></pre>
<p><strong><code>Optim4.ml</code></strong> (based on
<code>Optim1.ml</code>): time: 0.51s - Garbage collection takes 8% of
time - So little because we have eliminated garbage</p>
<p><strong>Defunctorization</strong> means computing functor
applications by hand. - There was a tool <code>ocamldefun</code> but it
is out of date - The slight speedup comes from the fact that functor
arguments are implemented as records of functions</p>
<h4 id="comparison-of-data-structure-implementations">9.5.4 Comparison
of Data Structure Implementations</h4>
<p>We perform a rough comparison of association lists, tree-based maps,
and hashtables. Sets would give the same results. We always create
hashtables with initial size 511.</p>
<p><span class="math inline">10^7</span> operations of: adding an
association (creation), finding a key that is in the map, finding a key
out of a small number of keys not in the map.</p>
<p>First row gives sizes of maps. Time in seconds, to two significant
digits.</p>
<p><strong>Create operations:</strong></p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr>
<th>Structure</th>
<th><span class="math inline">2^1</span></th>
<th><span class="math inline">2^2</span></th>
<th><span class="math inline">2^3</span></th>
<th><span class="math inline">2^4</span></th>
<th><span class="math inline">2^5</span></th>
<th><span class="math inline">2^6</span></th>
<th><span class="math inline">2^7</span></th>
<th><span class="math inline">2^8</span></th>
<th><span class="math inline">2^9</span></th>
<th><span class="math inline">2^{10}</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>assoc list</td>
<td>0.25</td>
<td>0.25</td>
<td>0.18</td>
<td>0.19</td>
<td>0.17</td>
<td>0.22</td>
<td>0.19</td>
<td>0.19</td>
<td>0.19</td>
<td>-</td>
</tr>
<tr>
<td>tree map</td>
<td>0.48</td>
<td>0.81</td>
<td>0.82</td>
<td>1.2</td>
<td>1.6</td>
<td>2.3</td>
<td>2.7</td>
<td>3.6</td>
<td>4.1</td>
<td>5.1</td>
</tr>
<tr>
<td>hashtable</td>
<td>27</td>
<td>9.1</td>
<td>5.5</td>
<td>4</td>
<td>2.9</td>
<td>2.4</td>
<td>2.1</td>
<td>1.9</td>
<td>1.8</td>
<td>3.7</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
</colgroup>
<thead>
<tr>
<th>Structure</th>
<th><span class="math inline">2^{11}</span></th>
<th><span class="math inline">2^{12}</span></th>
<th><span class="math inline">2^{13}</span></th>
<th><span class="math inline">2^{14}</span></th>
<th><span class="math inline">2^{15}</span></th>
<th><span class="math inline">2^{16}</span></th>
<th><span class="math inline">2^{17}</span></th>
<th><span class="math inline">2^{18}</span></th>
<th><span class="math inline">2^{19}</span></th>
<th><span class="math inline">2^{20}</span></th>
<th><span class="math inline">2^{21}</span></th>
<th><span class="math inline">2^{22}</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>tree map</td>
<td>6.5</td>
<td>8</td>
<td>9.8</td>
<td>15</td>
<td>19</td>
<td>26</td>
<td>34</td>
<td>41</td>
<td>51</td>
<td>67</td>
<td>80</td>
<td>130</td>
</tr>
<tr>
<td>hashtable</td>
<td>4.8</td>
<td>5.6</td>
<td>6.4</td>
<td>8.4</td>
<td>12</td>
<td>15</td>
<td>19</td>
<td>20</td>
<td>22</td>
<td>24</td>
<td>23</td>
<td>33</td>
</tr>
</tbody>
</table>
<p><strong>Found operations:</strong></p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr>
<th>Structure</th>
<th><span class="math inline">2^1</span></th>
<th><span class="math inline">2^2</span></th>
<th><span class="math inline">2^3</span></th>
<th><span class="math inline">2^4</span></th>
<th><span class="math inline">2^5</span></th>
<th><span class="math inline">2^6</span></th>
<th><span class="math inline">2^7</span></th>
<th><span class="math inline">2^8</span></th>
<th><span class="math inline">2^9</span></th>
<th><span class="math inline">2^{10}</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>assoc list</td>
<td>1.1</td>
<td>1.5</td>
<td>2.5</td>
<td>4.2</td>
<td>8.1</td>
<td>17</td>
<td>30</td>
<td>60</td>
<td>120</td>
<td>-</td>
</tr>
<tr>
<td>tree map</td>
<td>1</td>
<td>1.1</td>
<td>1.3</td>
<td>1.5</td>
<td>1.9</td>
<td>2.1</td>
<td>2.5</td>
<td>2.8</td>
<td>3.1</td>
<td>3.6</td>
</tr>
<tr>
<td>hashtable</td>
<td>1.4</td>
<td>1.5</td>
<td>1.4</td>
<td>1.4</td>
<td>1.5</td>
<td>1.5</td>
<td>1.6</td>
<td>1.6</td>
<td>1.8</td>
<td>1.8</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
</colgroup>
<thead>
<tr>
<th>Structure</th>
<th><span class="math inline">2^{11}</span></th>
<th><span class="math inline">2^{12}</span></th>
<th><span class="math inline">2^{13}</span></th>
<th><span class="math inline">2^{14}</span></th>
<th><span class="math inline">2^{15}</span></th>
<th><span class="math inline">2^{16}</span></th>
<th><span class="math inline">2^{17}</span></th>
<th><span class="math inline">2^{18}</span></th>
<th><span class="math inline">2^{19}</span></th>
<th><span class="math inline">2^{20}</span></th>
<th><span class="math inline">2^{21}</span></th>
<th><span class="math inline">2^{22}</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>tree map</td>
<td>4.3</td>
<td>5.2</td>
<td>6</td>
<td>7.6</td>
<td>9.4</td>
<td>12</td>
<td>15</td>
<td>17</td>
<td>19</td>
<td>24</td>
<td>28</td>
<td>32</td>
</tr>
<tr>
<td>hashtable</td>
<td>1.8</td>
<td>2</td>
<td>2.5</td>
<td>3.1</td>
<td>4</td>
<td>5.1</td>
<td>5.9</td>
<td>6.4</td>
<td>6.8</td>
<td>7.6</td>
<td>6.7</td>
<td>7.5</td>
</tr>
</tbody>
</table>
<p><strong>Not found operations:</strong></p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr>
<th>Structure</th>
<th><span class="math inline">2^1</span></th>
<th><span class="math inline">2^2</span></th>
<th><span class="math inline">2^3</span></th>
<th><span class="math inline">2^4</span></th>
<th><span class="math inline">2^5</span></th>
<th><span class="math inline">2^6</span></th>
<th><span class="math inline">2^7</span></th>
<th><span class="math inline">2^8</span></th>
<th><span class="math inline">2^9</span></th>
<th><span class="math inline">2^{10}</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>assoc list</td>
<td>1.8</td>
<td>2.6</td>
<td>4.6</td>
<td>8</td>
<td>16</td>
<td>32</td>
<td>60</td>
<td>120</td>
<td>240</td>
<td>-</td>
</tr>
<tr>
<td>tree map</td>
<td>1.5</td>
<td>1.5</td>
<td>1.8</td>
<td>2.1</td>
<td>2.4</td>
<td>2.7</td>
<td>3</td>
<td>3.2</td>
<td>3.5</td>
<td>3.8</td>
</tr>
<tr>
<td>hashtable</td>
<td>1.4</td>
<td>1.4</td>
<td>1.5</td>
<td>1.5</td>
<td>1.6</td>
<td>1.5</td>
<td>1.7</td>
<td>1.9</td>
<td>2</td>
<td>2.1</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
</colgroup>
<thead>
<tr>
<th>Structure</th>
<th><span class="math inline">2^{11}</span></th>
<th><span class="math inline">2^{12}</span></th>
<th><span class="math inline">2^{13}</span></th>
<th><span class="math inline">2^{14}</span></th>
<th><span class="math inline">2^{15}</span></th>
<th><span class="math inline">2^{16}</span></th>
<th><span class="math inline">2^{17}</span></th>
<th><span class="math inline">2^{18}</span></th>
<th><span class="math inline">2^{19}</span></th>
<th><span class="math inline">2^{20}</span></th>
<th><span class="math inline">2^{21}</span></th>
<th><span class="math inline">2^{22}</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>tree map</td>
<td>4.2</td>
<td>4.3</td>
<td>4.7</td>
<td>4.9</td>
<td>5.3</td>
<td>5.5</td>
<td>6.1</td>
<td>6.3</td>
<td>6.6</td>
<td>7.2</td>
<td>7.5</td>
<td>7.3</td>
</tr>
<tr>
<td>hashtable</td>
<td>1.8</td>
<td>1.9</td>
<td>2</td>
<td>1.9</td>
<td>1.9</td>
<td>1.9</td>
<td>2</td>
<td>2</td>
<td>2.2</td>
<td>2</td>
<td>2</td>
<td>1.9</td>
</tr>
</tbody>
</table>
<p>Using lists makes sense for up to about 15 elements.</p>
<p>Unfortunately, OCaml and Haskell do not encourage the use of
efficient maps the way Scala and Python have built-in syntax for
them.</p>
<h3 id="parsing-ocamllex-and-menhir">9.6 Parsing: ocamllex and
Menhir</h3>
<p><em>Parsing</em> means transforming text (a string of characters)
into a data structure that is well fitted for a given task, or generally
makes information in the text more explicit.</p>
<p>Parsing is usually done in stages: 1. <em>Lexing</em> or
<em>tokenizing</em>: dividing the text into smallest meaningful pieces
called <em>lexemes</em> or <em>tokens</em> 2. Composing bigger
structures out of lexemes/tokens (and smaller structures) according to a
<em>grammar</em> - Alternatively to building such hierarchical
structure, sometimes we build relational structure over the tokens,
e.g., <em>dependency grammars</em></p>
<p>We will use <code>ocamllex</code> for lexing, whose rules are like
pattern matching functions, but with patterns being <em>regular
expressions</em>.</p>
<p>We will either consume the results from the lexer directly, or use
<em>Menhir</em> for parsing, a successor of <code>ocamlyacc</code>,
belonging to the <em>yacc</em>/<em>bison</em> family of parsers.</p>
<h4 id="lexing-with-ocamllex">9.6.1 Lexing with ocamllex</h4>
<p>The format of lexer definitions is as follows (file with extension
<code>.mll</code>):</p>
<pre><code>{ header }
let ident1 = regexp ...
rule entrypoint1 [arg1 ... argN] =
  parse regexp { action1 }
      | ...
      | regexp { actionN }
and entrypointN [arg1 ... argN] =
  parse ...
and ...
{ trailer }</code></pre>
<ul>
<li>Comments are delimited by <code>(* *)</code>, as in OCaml</li>
<li>The <code>parse</code> keyword can be replaced by the
<code>shortest</code> keyword</li>
<li>“Header”, “trailer”, “action1”, … “actionN” are arbitrary OCaml
code</li>
<li>There can be multiple let-clauses and rule-clauses</li>
</ul>
<p>Let-clauses are shorthands for regular expressions.</p>
<p>Each rule-clause <code>entrypoint</code> defines function(s) that
take as the last argument (after <code>arg1</code> … <code>argN</code>
if N&gt;0) an argument <code>lexbuf</code> of type
<code>Lexing.lexbuf</code>. The <code>lexbuf</code> is also visible in
actions, just as a regular argument. Entry points can be mutually
recursive if we need to read more before we can return output.</p>
<p>We can use <code>lexbuf</code> in actions: -
<code>Lexing.lexeme lexbuf</code> – Return the matched string -
<code>Lexing.lexeme_char lexbuf n</code> – Return the nth character in
the matched string (first character is n = 0) -
<code>Lexing.lexeme_start</code>/<code>lexeme_end lexbuf</code> – Return
the absolute position in the input text of the beginning/end of the
matched string (first character read has offset 0)</p>
<p>The parser will call an <code>entrypoint</code> when it needs another
lexeme/token.</p>
<p><strong>The syntax of regular expressions:</strong></p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>Pattern</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>'c'</code></td>
<td>Match the character <code>'c'</code></td>
</tr>
<tr>
<td><code>_</code></td>
<td>Match a <strong>single</strong> character</td>
</tr>
<tr>
<td><code>eof</code></td>
<td>Match end of lexer input</td>
</tr>
<tr>
<td><code>"string"</code></td>
<td>Match the corresponding sequence of characters</td>
</tr>
<tr>
<td><code>[character set]</code></td>
<td>Match the character set (characters <code>'c'</code> and ranges
<code>'c'-'d'</code> separated by space)</td>
</tr>
<tr>
<td><code>[^character set]</code></td>
<td>Match characters outside the character set</td>
</tr>
<tr>
<td><code>[set1] # [set2]</code></td>
<td>Match the difference (only characters in set1 that are not in
set2)</td>
</tr>
<tr>
<td><code>regexp*</code></td>
<td>(repetition) Match zero or more strings matching regexp</td>
</tr>
<tr>
<td><code>regexp+</code></td>
<td>(strict repetition) Match one or more strings matching regexp</td>
</tr>
<tr>
<td><code>regexp?</code></td>
<td>(option) Match the empty string, or a string matching regexp</td>
</tr>
<tr>
<td><code>regexp1 \| regexp2</code></td>
<td>(alternative) Match any string that matches regexp1 or regexp2</td>
</tr>
<tr>
<td><code>regexp1 regexp2</code></td>
<td>(concatenation) Match concatenation of two strings</td>
</tr>
<tr>
<td><code>( regexp )</code></td>
<td>Match the same strings as regexp</td>
</tr>
<tr>
<td><code>ident</code></td>
<td>Reference the regular expression bound by
<code>let ident = regexp</code></td>
</tr>
<tr>
<td><code>regexp as ident</code></td>
<td>Bind the substring matched by regexp to identifier
<code>ident</code></td>
</tr>
</tbody>
</table>
<p>The precedences are: <code>#</code> highest, followed by
<code>*</code>, <code>+</code>, <code>?</code>, concatenation,
<code>|</code>, <code>as</code>.</p>
<p>The type of <code>as ident</code> variables can be
<code>string</code>, <code>char</code>, <code>string option</code>, or
<code>char option</code>: - <code>char</code> means obviously a single
character pattern - <code>option</code> means situations like
<code>(regexp as ident)?</code> or
<code>regexp1|(regexp2 as ident)</code> - The variables can repeat in
the pattern (<strong>unlike</strong> in normal patterns) – meaning both
regexps match the same substrings</p>
<p><code>ocamllex Lexer.mll</code> produces the lexer code in
<code>Lexer.ml</code>. The <code>ocamlbuild</code> tool will call
<code>ocamllex</code> and <code>ocamlyacc</code>/<code>menhir</code> if
needed.</p>
<p>Unfortunately if the lexer patterns are big we get an error:
<em>transition table overflow, automaton is too big</em>.</p>
<h5 id="example-finding-email-addresses">Example: Finding Email
Addresses</h5>
<p>We mine a text file for email addresses that could have been
obfuscated.</p>
<p>To compile and run <code>Emails.mll</code>, processing a file
<code>email_corpus.xml</code>:</p>
<pre><code>ocamlbuild Emails.native -- email_corpus.xml</code></pre>
<p>The lexer header defines types and helper functions:</p>
<pre><code>{                                         (* The header with OCaml code *)
  open Lexing                             (* Make accessing Lexing easier *)
  let nextline lexbuf =      (* Typical lexer function: move position to next line *)
    let pos = lexbuf.lex_curr_p in
    lexbuf.lex_curr_p &lt;- { pos with
      pos_lnum = pos.pos_lnum + 1;
      pos_bol = pos.pos_cnum;
    }
  type state =             (* Which step of searching for address we&#39;re at: *)
  | Seek                   (* Seek: still seeking, Addr (true...): possibly finished *)
  | Addr of bool * string * string list   (* Addr (false...): no domain *)

  let report state lexbuf =                     (* Report the found address, if any *)
    match state with
    | Seek -&gt; ()
    | Addr (false, _, _) -&gt; ()
    | Addr (true, name, addr) -&gt;               (* With line at which it is found *)
      Printf.printf &quot;%d: %s@%s\n&quot; lexbuf.lex_curr_p.pos_lnum
        name (String.concat &quot;.&quot; (List.rev addr))
}</code></pre>
<p>The lexer defines regular expressions for email patterns and rules
for matching:</p>
<pre><code>let newline = (&#39;\n&#39; | &quot;\r\n&quot;)                           (* Regexp for end of line *)
let addr_char = [&#39;a&#39;-&#39;z&#39; &#39;A&#39;-&#39;Z&#39; &#39;0&#39;-&#39;9&#39; &#39;-&#39; &#39;_&#39;]
let at_w_symb = &quot;where&quot; | &quot;WHERE&quot; | &quot;at&quot; | &quot;At&quot; | &quot;AT&quot;
let at_nw_symb = &#39;@&#39; | &quot;&amp;#x40;&quot; | &quot;&amp;#64;&quot;
let open_symb = &#39; &#39;* &#39;(&#39; &#39; &#39;* | &#39; &#39;+                    (* Demarcate a possible @ *)
let close_symb = &#39; &#39;* &#39;)&#39; &#39; &#39;* | &#39; &#39;+                   (* or . symbol *)
let at_sep_symb =
  open_symb? at_nw_symb close_symb? |
  open_symb at_w_symb close_symb

let dot_w_symb = &quot;dot&quot; | &quot;DOT&quot; | &quot;dt&quot; | &quot;DT&quot;
let dom_w_symb = dot_w_symb | &quot;dom&quot; | &quot;DOM&quot;             (* Obfuscation for last dot *)
let dot_sep_symb =
  open_symb dot_w_symb close_symb |
  open_symb? &#39;.&#39; close_symb?
let dom_sep_symb =
  open_symb dom_w_symb close_symb |
  open_symb? &#39;.&#39; close_symb?
let addr_dom = addr_char addr_char                      (* Restricted form of last *)
  | &quot;edu&quot; | &quot;EDU&quot; | &quot;org&quot; | &quot;ORG&quot; | &quot;com&quot; | &quot;COM&quot;       (* part of address *)</code></pre>
<p>The main rule processes the input character by character:</p>
<pre><code>rule email state = parse
| newline                                               (* Check state before moving on *)
    { report state lexbuf; nextline lexbuf;
      email Seek lexbuf }
| (addr_char+ as name) at_sep_symb (addr_char+ as addr) (* Detected possible start *)
    { email (Addr (false, name, [addr])) lexbuf }
| dom_sep_symb (addr_dom as dom)              (* Detected possible finish of address *)
    { let state =
        match state with
        | Seek -&gt; Seek                        (* We weren&#39;t looking at an address *)
        | Addr (_, name, addrs) -&gt;            (* Bingo *)
          Addr (true, name, dom::addrs) in
      email state lexbuf }
| dot_sep_symb (addr_char+ as addr)           (* Next part of address -- must be continued *)
    { let state =
        match state with
        | Seek -&gt; Seek
        | Addr (_, name, addrs) -&gt;
          Addr (false, name, addr::addrs) in
      email state lexbuf }
| eof                                                   (* End of file -- end loop *)
    { report state lexbuf }
| _                                    (* Some boring character -- not looking at address *)
    { report state lexbuf; email Seek lexbuf }</code></pre>
<p>The trailer opens a file and starts mining:</p>
<pre><code>{                                                 (* The trailer with OCaml code *)
  let _ =                         (* Open a file and start mining for email addresses *)
    let ch = open_in Sys.argv.(1) in
    email Seek (Lexing.from_channel ch);
    close_in ch                                   (* Close the file at the end *)
}</code></pre>
<h4 id="parsing-with-menhir">9.6.2 Parsing with Menhir</h4>
<p>The format of parser definitions is as follows (file with extension
<code>.mly</code>):</p>
<pre><code>%{ header %}                          (* OCaml code put in front *)
%parameter &lt; M : signature &gt;          (* Parameters make a functor *)
%token &lt; type1 &gt; Token1 Token2        (* Terminal productions, variants returned from lexer *)
%token &lt; type3 &gt; Token3
%token NoArgToken                     (* Without an argument, e.g. keywords or symbols *)
%nonassoc Token1                      (* This token cannot be stacked without parentheses *)
%left Token3                          (* Associates to left *)
%right Token2                         (* Associates to right *)
%type &lt; type4 &gt; rule1                 (* Type of the action of the rule *)
%start &lt; type5 &gt; rule2                (* The entry point of the grammar *)
%%                                    (* Separate out the rules part *)
%inline rule1 (id1, ..., idN) :       (* Inlined rules can propagate priorities *)
 | production1 { action1 }            (* If production matches, perform action *)
 | production2 | production3          (* Several productions *)
    { action2 }                       (* with the same action *)

%public rule2 :                       (* Visible in other files of the grammar *)
 | production4 { action4 }
%public rule3 :                       (* Override precedence of production5 *)
 | production5 { action5 } %prec Token1   (* to that of Token1 *)
%%                                    (* Separations needed even if sections empty *)
trailer                               (* OCaml code put at the end *)</code></pre>
<p>Header, actions, and trailer are OCaml code. Comments are
<code>(* ... *)</code> in OCaml code, <code>/* ... */</code> or
<code>// ...</code> outside.</p>
<p>Rules can optionally be separated by <code>;</code>. The
<code>%parameter</code> declaration turns the <strong>whole</strong>
resulting grammar into a functor; multiple parameters are allowed and
visible in <code>%{...%}</code>.</p>
<p>Terminal symbols <code>Token1</code> and <code>Token2</code> are both
variants with argument of type <code>type1</code>, called their
<em>semantic value</em>.</p>
<p><code>rule1</code> … <code>ruleN</code> must be lower-case
identifiers. Parameters <code>id1</code> … <code>idN</code> can be
lower- or upper-case.</p>
<p>Priorities (precedence) are declared implicitly:
<code>%nonassoc</code>, <code>%left</code>, <code>%right</code> list
tokens in increasing priority (<code>Token2</code> has highest
precedence).</p>
<ul>
<li>Higher precedence = a rule is applied even when tokens so far could
be part of the other rule</li>
<li>Precedence of a production comes from its rightmost terminal</li>
<li><code>%left</code>/<code>%right</code> means left/right
associativity: the rule will/won’t be applied if the “other” rule is the
same production</li>
</ul>
<p><code>%start</code> symbols become names of functions exported in the
<code>.mli</code> file to invoke the parser. They are automatically
<code>%public</code>.</p>
<p><code>%public</code> rules can even be defined over multiple files,
with productions joined by <code>|</code>.</p>
<p><strong>The syntax of productions:</strong></p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>Pattern</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rule2 Token1 rule3</code></td>
<td>Match tokens in sequence with <code>Token1</code> in the middle</td>
</tr>
<tr>
<td><code>a=rule2 t=Token3</code></td>
<td>Name semantic values produced by rules/tokens</td>
</tr>
<tr>
<td><code>rule2; Token3</code></td>
<td>Parts of pattern can be separated by semicolon</td>
</tr>
<tr>
<td><code>rule1(arg1,...,argN)</code></td>
<td>Use a rule that takes arguments</td>
</tr>
<tr>
<td><code>rule2?</code></td>
<td>Shorthand for <code>option(rule2)</code></td>
</tr>
<tr>
<td><code>rule2+</code></td>
<td>Shorthand for <code>nonempty_list(rule2)</code></td>
</tr>
<tr>
<td><code>rule2*</code></td>
<td>Shorthand for <code>list(rule2)</code></td>
</tr>
</tbody>
</table>
<p><strong>Always-visible “standard library”</strong> (most of rules
shown):</p>
<pre><code>%public option(X):
  /* nothing */
    { None }
| x = X
    { Some x }

%public %inline pair(X, Y):
  x = X; y = Y
    { (x, y) }

%public %inline separated_pair(X, sep, Y):
  x = X; sep; y = Y
    { (x, y) }

%public %inline delimited(opening, X, closing):
  opening; x = X; closing
    { x }

%public list(X):
  /* nothing */
    { [] }
| x = X; xs = list(X)
    { x :: xs }

%public nonempty_list(X):
  x = X
    { [ x ] }
| x = X; xs = nonempty_list(X)
    { x :: xs }

%public %inline separated_list(separator, X):
  xs = loption(separated_nonempty_list(separator, X))
    { xs }

%public separated_nonempty_list(separator, X):
  x = X
    { [ x ] }
| x = X; separator; xs = separated_nonempty_list(separator, X)
    { x :: xs }</code></pre>
<p>Only <em>left-recursive</em> rules are truly tail-recursive:</p>
<pre><code>declarations:
| { [] }
| ds = declarations; option(COMMA);
  d = declaration { d :: ds }</code></pre>
<p>This is opposite to code expressions (or <em>recursive descent
parsers</em>) – if both are OK, the first rather than last invocation
should be recursive.</p>
<p>Invocations can be nested in arguments:</p>
<pre><code>plist(X):
| xs = loption(                          (* Like option, but returns a list *)
    delimited(LPAREN,
              separated_nonempty_list(COMMA, X),
              RPAREN)) { xs }</code></pre>
<p>Higher-order parameters are allowed:</p>
<pre><code>procedure(list):
| PROCEDURE ID list(formal) SEMICOLON block SEMICOLON {...}</code></pre>
<p><strong>Example where inlining is required</strong> (besides being an
optimization):</p>
<pre><code>%token &lt; int &gt; INT
%token PLUS TIMES
%left PLUS
%left TIMES                              (* Multiplication has higher priority *)
%%
expression:
| i = INT { i }                          (* Without inlining, would not distinguish priorities *)
| e = expression; o = op; f = expression { o e f }
%inline op:                              (* Inline operator -- generate corresponding rules *)
| PLUS { ( + ) }
| TIMES { ( * ) }</code></pre>
<p>Menhir is an <span class="math inline">\text{LR}(1)</span> parser
generator, i.e., it fails for grammars where looking one token ahead,
together with precedences, is insufficient to determine whether a rule
applies. In particular, only unambiguous grammars are supported.</p>
<p>Although <span class="math inline">\text{LR}(1)</span> grammars are a
small subset of <em>context free grammars</em>, the semantic actions can
depend on context: actions can be functions that take some form of
context as input.</p>
<p>Positions are available in actions via keywords
<code>$startpos(x)</code> and <code>$endpos(x)</code> where
<code>x</code> is a name given to part of pattern.</p>
<p><strong>Note:</strong> Do not use the <code>Parsing</code> module
from OCaml standard library.</p>
<h5 id="example-parsing-arithmetic-expressions">Example: Parsing
Arithmetic Expressions</h5>
<p>Example based on a Menhir demo. Due to difficulties with
<code>ocamlbuild</code>, we use option <code>--external-tokens</code> to
provide <code>type token</code> directly rather than having it
generated.</p>
<p><strong>File <code>lexer.mll</code>:</strong></p>
<pre><code>{
  type token =
    | TIMES
    | RPAREN
    | PLUS
    | MINUS
    | LPAREN
    | INT of (int)
    | EOL
    | DIV
  exception Error of string
}

rule line = parse
| ([^&#39;\n&#39;]* &#39;\n&#39;) as line { line }
| eof  { exit 0 }

and token = parse
| [&#39; &#39; &#39;\t&#39;]      { token lexbuf }
| &#39;\n&#39; { EOL }
| [&#39;0&#39;-&#39;9&#39;]+ as i { INT (int_of_string i) }
| &#39;+&#39;  { PLUS }
| &#39;-&#39;  { MINUS }
| &#39;*&#39;  { TIMES }
| &#39;/&#39;  { DIV }
| &#39;(&#39;  { LPAREN }
| &#39;)&#39;  { RPAREN }
| eof  { exit 0 }
| _    { raise (Error (Printf.sprintf &quot;At offset %d: unexpected character.\n&quot;
                       (Lexing.lexeme_start lexbuf))) }</code></pre>
<p><strong>File <code>parser.mly</code>:</strong></p>
<pre><code>%token &lt;int&gt; INT                       (* We still need to define tokens, *)
%token PLUS MINUS TIMES DIV            (* Menhir does its own checks *)
%token LPAREN RPAREN
%token EOL
%left PLUS MINUS        /* lowest precedence */
%left TIMES DIV         /* medium precedence */
%nonassoc UMINUS        /* highest precedence */
%parameter&lt;Semantics : sig
  type number
  val inject: int -&gt; number
  val ( + ): number -&gt; number -&gt; number
  val ( - ): number -&gt; number -&gt; number
  val ( * ): number -&gt; number -&gt; number
  val ( / ): number -&gt; number -&gt; number
  val ( ~-): number -&gt; number
end&gt;
%start &lt;Semantics.number&gt; main
%{ open Semantics %}

%%
main:
| e = expr EOL   { e }

expr:
| i = INT     { inject i }
| LPAREN e = expr RPAREN    { e }
| e1 = expr PLUS e2 = expr  { e1 + e2 }
| e1 = expr MINUS e2 = expr { e1 - e2 }
| e1 = expr TIMES e2 = expr { e1 * e2 }
| e1 = expr DIV e2 = expr   { e1 / e2 }
| MINUS e = expr %prec UMINUS { - e }</code></pre>
<p><strong>File <code>calc.ml</code>:</strong></p>
<pre><code>module FloatSemantics = struct
  type number = float
  let inject = float_of_int
  let ( + ) = ( +. )
  let ( - ) = ( -. )
  let ( * ) = ( *. )
  let ( / ) = ( /. )
  let (~- ) = (~-. )
end

module FloatParser = Parser.Make(FloatSemantics)

let () =
  let stdinbuf = Lexing.from_channel stdin in
  while true do
    let linebuf =
      Lexing.from_string (Lexer.line stdinbuf) in
    try
      Printf.printf &quot;%.1f\n%!&quot;
        (FloatParser.main Lexer.token linebuf)
    with
    | Lexer.Error msg -&gt;
      Printf.fprintf stderr &quot;%s%!&quot; msg
    | FloatParser.Error -&gt;
      Printf.fprintf stderr
        &quot;At offset %d: syntax error.\n%!&quot;
        (Lexing.lexeme_start linebuf)
  done</code></pre>
<p><strong>Build and run command:</strong></p>
<pre><code>ocamlbuild calc.native -use-menhir -menhir &quot;menhir parser.mly --base
parser --external-tokens Lexer&quot; --</code></pre>
<ul>
<li>Other grammar files can be provided besides
<code>parser.mly</code></li>
<li><code>--base</code> gives the file (without extension) which will
become the module accessed from OCaml</li>
<li><code>--external-tokens</code> provides the OCaml module which
defines the <code>token</code> type</li>
</ul>
<h5 id="example-a-toy-sentence-grammar">Example: A Toy Sentence
Grammar</h5>
<p>Our lexer is a simple limited <em>part-of-speech tagger</em>. Not
re-entrant.</p>
<p>For debugging, we log execution in file <code>log.txt</code>.</p>
<p><strong>File <code>EngLexer.mll</code>:</strong></p>
<pre><code>{
 type sentence = {                   (* Could be in any module visible to EngParser *)
   subject : string;                 (* The actor/actors, i.e. subject noun *)
   action : string;                  (* The action, i.e. verb *)
   plural : bool;                    (* Whether one or multiple actors *)
   adjs : string list;               (* Characteristics of actor *)
   advs : string list                (* Characteristics of action *)
 }

 type token =
 | VERB of string
 | NOUN of string
 | ADJ of string
 | ADV of string
 | PLURAL | SINGULAR
 | A_DET | THE_DET | SOME_DET | THIS_DET | THAT_DET
 | THESE_DET | THOSE_DET
 | COMMA_CNJ | AND_CNJ | DOT_PUNCT

 let adjectives =                                         (* Recognized adjectives *)
   [&quot;smart&quot;; &quot;extreme&quot;; &quot;green&quot;; &quot;slow&quot;; &quot;old&quot;; &quot;incredible&quot;;
    &quot;quiet&quot;; &quot;diligent&quot;; &quot;mellow&quot;; &quot;new&quot;]
 let log_file = open_out &quot;log.txt&quot;               (* File with debugging information *)
 let log s = Printf.fprintf log_file &quot;%s\n%!&quot; s
 let last_tok = ref DOT_PUNCT                             (* State for better tagging *)

 let tokbuf = Queue.create ()                   (* Token buffer, since single word *)
 let push w =                                   (* is sometimes two tokens *)
   last_tok := w; Queue.push w tokbuf
 exception LexError of string
}

let alphanum = [&#39;0&#39;-&#39;9&#39; &#39;a&#39;-&#39;z&#39; &#39;A&#39;-&#39;Z&#39; &#39;&#39;&#39; &#39;-&#39;]

rule line = parse                                         (* For line-based interface *)
| ([^&#39;\n&#39;]* &#39;\n&#39;) as l { l }
| eof { exit 0 }

and lex_word = parse
| [&#39; &#39; &#39;\t&#39;]                                              (* Skip whitespace *)
    { lex_word lexbuf }
| &#39;.&#39; { push DOT_PUNCT }                                  (* End of sentence *)
| &quot;a&quot; { push A_DET } | &quot;the&quot; { push THE_DET }             (* &quot;Keywords&quot; *)
| &quot;some&quot; { push SOME_DET }
| &quot;this&quot; { push THIS_DET } | &quot;that&quot; { push THAT_DET }
| &quot;these&quot; { push THESE_DET } | &quot;those&quot; { push THOSE_DET }
| &quot;A&quot; { push A_DET } | &quot;The&quot; { push THE_DET }
| &quot;Some&quot; { push SOME_DET }
| &quot;This&quot; { push THIS_DET } | &quot;That&quot; { push THAT_DET }
| &quot;These&quot; { push THESE_DET } | &quot;Those&quot; { push THOSE_DET }
| &quot;and&quot; { push AND_CNJ }
| &#39;,&#39; { push COMMA_CNJ }
| (alphanum+ as w) &quot;ly&quot;               (* Adverb is adjective that ends in &quot;ly&quot; *)
    {
      if List.mem w adjectives
      then push (ADV w)
      else if List.mem (w^&quot;le&quot;) adjectives
      then push (ADV (w^&quot;le&quot;))
      else (push (NOUN w); push SINGULAR)
    }

| (alphanum+ as w) &quot;s&quot;                                    (* Plural noun or singular verb *)
    {
      if List.mem w adjectives then push (ADJ w)
      else match !last_tok with
      | THE_DET | SOME_DET | THESE_DET | THOSE_DET
      | DOT_PUNCT | ADJ _ -&gt;
        push (NOUN w); push PLURAL
      | _ -&gt; push (VERB w); push SINGULAR
    }
| alphanum+ as w                                          (* Noun contexts vs. verb contexts *)
    {
      if List.mem w adjectives then push (ADJ w)
      else match !last_tok with
      | A_DET | THE_DET | SOME_DET | THIS_DET | THAT_DET
      | DOT_PUNCT | ADJ _ -&gt;
        push (NOUN w); push SINGULAR
      | _ -&gt; push (VERB w); push PLURAL
    }

| _ as w
    { raise (LexError (&quot;Unrecognized character &quot;^
                       Char.escaped w)) }
{
  let lexeme lexbuf =       (* The proper interface reads from the token buffer *)
    if Queue.is_empty tokbuf then lex_word lexbuf;
    Queue.pop tokbuf
}</code></pre>
<p><strong>File <code>EngParser.mly</code>:</strong></p>
<pre><code>%{
  open EngLexer                       (* Source of the token type and sentence type *)
%}
%token &lt;string&gt; VERB NOUN ADJ ADV     (* Open word classes *)
%token PLURAL SINGULAR                (* Number marker *)
%token A_DET THE_DET SOME_DET THIS_DET THAT_DET   (* &quot;Keywords&quot; *)
%token THESE_DET THOSE_DET
%token COMMA_CNJ AND_CNJ DOT_PUNCT
%start &lt;EngLexer.sentence&gt; sentence   (* Grammar entry *)
%%

%public %inline sep2_list(sep1, sep2, X):                 (* General purpose *)
| xs = separated_nonempty_list(sep1, X) sep2 x=X
    { xs @ [x] }                      (* We use it for &quot;comma-and&quot; lists: *)
| x=option(X)                         (* smart, quiet and diligent *)
    { match x with None-&gt;[] | Some x-&gt;[x] }

sing_only_det:                                 (* How determiners relate to number *)
| A_DET | THIS_DET | THAT_DET { log &quot;prs: sing_only_det&quot; }

plu_only_det:
| THESE_DET | THOSE_DET { log &quot;prs: plu_only_det&quot; }

other_det:
| THE_DET | SOME_DET { log &quot;prs: other_det&quot; }

np(det):
| det adjs=list(ADJ) subject=NOUN
    { log &quot;prs: np&quot;; adjs, subject }

vp(NUM):
| advs=separated_list(AND_CNJ,ADV) action=VERB NUM
| action=VERB NUM advs=sep2_list(COMMA_CNJ,AND_CNJ,ADV)
    { log &quot;prs: vp&quot;; action, advs }

sent(det,NUM):                                  (* Sentence parameterized by number *)
| adjsub=np(det) NUM vbadv=vp(NUM)
    { log &quot;prs: sent&quot;;
      {subject=snd adjsub; action=fst vbadv; plural=false;
       adjs=fst adjsub; advs=snd vbadv} }

vbsent(NUM):                                    (* Unfortunately, it doesn&#39;t always work... *)
| NUM vbadv=vp(NUM)    { log &quot;prs: vbsent&quot;; vbadv }

sentence:                                       (* Sentence, either singular or plural *)
| s=sent(sing_only_det,SINGULAR) DOT_PUNCT
    { log &quot;prs: sentence1&quot;;
      {s with plural = false} }
| s=sent(plu_only_det,PLURAL) DOT_PUNCT
    { log &quot;prs: sentence2&quot;;
      {s with plural = true} }

| adjsub=np(other_det) vbadv=vbsent(SINGULAR) DOT_PUNCT
    { log &quot;prs: sentence3&quot;;     (* Because parser allows only one token look-ahead *)
      {subject=snd adjsub; action=fst vbadv; plural=false;
       adjs=fst adjsub; advs=snd vbadv} }
| adjsub=np(other_det) vbadv=vbsent(PLURAL) DOT_PUNCT
    { log &quot;prs: sentence4&quot;;     (* we need to factor-out the &quot;common subset&quot; *)
      {subject=snd adjsub; action=fst vbadv; plural=true;
       adjs=fst adjsub; advs=snd vbadv} }</code></pre>
<p><strong>File <code>Eng.ml</code>:</strong></p>
<pre><code>open EngLexer

let () =
  let stdinbuf = Lexing.from_channel stdin in
  while true do
    (* Read line by line. *)
    let linebuf = Lexing.from_string (line stdinbuf) in

    try
      (* Run the parser on a single line of input. *)
      let s = EngParser.sentence lexeme linebuf in
      Printf.printf
   &quot;subject=%s\nplural=%b\nadjs=%s\naction=%s\nadvs=%s\n\n%!&quot;
        s.subject s.plural (String.concat &quot;, &quot; s.adjs)
        s.action (String.concat &quot;, &quot; s.advs)
    with
    | LexError msg -&gt;
      Printf.fprintf stderr &quot;%s\n%!&quot; msg
    | EngParser.Error -&gt;
      Printf.fprintf stderr &quot;At offset %d: syntax error.\n%!&quot;
          (Lexing.lexeme_start linebuf)
  done</code></pre>
<p><strong>Build and run command:</strong></p>
<pre><code>ocamlbuild Eng.native -use-menhir -menhir &quot;menhir EngParser.mly
--base EngParser --external-tokens EngLexer&quot; --</code></pre>
<h3 id="example-phrase-search">9.7 Example: Phrase Search</h3>
<p>In lecture 6 we performed keyword search; now we turn to <em>phrase
search</em>, i.e., require that given words be consecutive in the
document.</p>
<p>We start with some English-specific transformations used in the
lexer:</p>
<pre><code>let wh_or_pronoun w =
  w = &quot;where&quot; || w = &quot;what&quot; || w = &quot;who&quot; ||
  w = &quot;he&quot; || w = &quot;she&quot; || w = &quot;it&quot; ||
  w = &quot;I&quot; || w = &quot;you&quot; || w = &quot;we&quot; || w = &quot;they&quot;

let abridged w1 w2 =                         (* Remove shortened forms like I&#39;ll or press&#39;d *)
  if w2 = &quot;ll&quot; then [w1; &quot;will&quot;]
  else if w2 = &quot;s&quot; then
    if wh_or_pronoun w1 then [w1; &quot;is&quot;]
    else [&quot;of&quot;; w1]
  else if w2 = &quot;d&quot; then [w1^&quot;ed&quot;]
  else if w1 = &quot;o&quot; || w1 = &quot;O&quot;
  then
    if w2.[0] = &#39;e&#39; &amp;&amp; w2.[1] = &#39;r&#39; then [w1^&quot;v&quot;^w2]
    else [&quot;of&quot;; w2]
  else if w2 = &quot;t&quot; then [w1; &quot;it&quot;]
  else [w1^&quot;&#39;&quot;^w2]</code></pre>
<p>For now we normalize words just by lowercasing (but see exercise 8
for Porter stemming).</p>
<p>In the lexer we <em>tokenize</em> text: separate words and normalize
them. We also handle simple aspects of <em>XML</em> syntax. We store the
number of each word occurrence, excluding XML tags.</p>
<p><strong>Parsing: the inverted index and the query:</strong></p>
<pre><code>type token =
| WORDS of (string * int) list
| OPEN of string | CLOSE of string | COMMENT of string
| SENTENCE of string | PUNCT of string
| EOF

let inv_index update ii lexer lexbuf =
  let rec aux ii =
    match lexer lexbuf with
    | WORDS ws -&gt;
      let ws = List.map (fun (w,p)-&gt;EngMorph.normalize w, p) ws in
      aux (List.fold_left update ii ws)
    | OPEN _ | CLOSE _ | SENTENCE _ | PUNCT _ | COMMENT _ -&gt;
      aux ii
    | EOF -&gt; ii in
  aux ii

let phrase lexer lexbuf =
  let rec aux words =
    match lexer lexbuf with
    | WORDS ws -&gt;
      let ws = List.map (fun (w,p)-&gt;EngMorph.normalize w) ws in
      aux (List.rev_append ws words)
    | OPEN _ | CLOSE _ | SENTENCE _ | PUNCT _ | COMMENT _ -&gt;
      aux words
    | EOF -&gt; List.rev words in
  aux []</code></pre>
<h4 id="naive-implementation-of-phrase-search">9.7.1 Naive
Implementation of Phrase Search</h4>
<p>We need <em>postings lists</em> with positions of words rather than
just the document or line of document they belong to.</p>
<p>First approach: association lists and merge postings lists
word-by-word.</p>
<pre><code>let update ii (w, p) =
  try
    let ps = List.assoc w ii in    (* Add position to the postings list of w *)
    (w, p::ps) :: List.remove_assoc w ii
  with Not_found -&gt; (w, [p])::ii

let empty = []
let find w ii = List.assoc w ii
let mapv f ii = List.map (fun (k,v)-&gt;k, f v) ii

let index file =
  let ch = open_in file in
  let lexbuf = Lexing.from_channel ch in
  EngLexer.reset_as_file lexbuf file;
  let ii =
    IndexParser.inv_index update empty EngLexer.token lexbuf in
  close_in ch;
  mapv List.rev ii, List.rev !EngLexer.linebreaks  (* Keep postings lists in increasing order *)

let find_line linebreaks p =             (* Recover the line in document of a position *)
  let rec aux line = function
    | [] -&gt; line
    | bp::_ when p &lt; bp -&gt; line
    | _::breaks -&gt; aux (line+1) breaks in
  aux 1 linebreaks

let search (ii, linebreaks) phrase =
  let lexbuf = Lexing.from_string phrase in
  EngLexer.reset_as_file lexbuf (&quot;search phrase: &quot;^phrase);
  let phrase = IndexParser.phrase EngLexer.token lexbuf in
  let rec aux wpos = function              (* Merge postings lists for words in query: *)
    | [] -&gt; wpos                           (* no more words in query *)
    | w::ws -&gt;                             (* for positions of w, keep those that are next to *)
      let nwpos = find w ii in             (* filtered positions of previous word *)
      aux (List.filter (fun p-&gt;List.mem (p-1) wpos) nwpos) ws in
  let wpos =
    match phrase with
    | [] -&gt; []                             (* No results for an empty query *)
    | w::ws -&gt; aux (find w ii) ws in
  List.map (find_line linebreaks) wpos     (* Answer in terms of document lines *)

let shakespeare = index &quot;./shakespeare.xml&quot;

let query q =
  let lines = search shakespeare q in
  Printf.printf &quot;%s: lines %s\n%!&quot; q
    (String.concat &quot;, &quot; (List.map string_of_int lines))</code></pre>
<p>Test: 200 searches of the queries:</p>
<pre><code>[&quot;first witch&quot;; &quot;wherefore art thou&quot;;
 &quot;captain&#39;s captain&quot;; &quot;flatter&#39;d&quot;; &quot;of Fulvia&quot;;
 &quot;that which we call a rose&quot;; &quot;the undiscovered country&quot;]</code></pre>
<p>Invocation: <code>ocamlbuild InvIndex.native -libs unix --</code></p>
<p>Time: 7.3s</p>
<h4 id="replace-association-list-with-hash-table">9.7.2 Replace
Association List with Hash Table</h4>
<p>I recommend using either <em>OCaml Batteries</em> or <em>OCaml
Core</em> – replacement for the standard library. <em>Batteries</em> has
efficient <code>Hashtbl.map</code> (our <code>mapv</code>).</p>
<p>Invocation:
<code>ocamlbuild InvIndex1.native -libs unix --</code></p>
<p>Time: 6.3s</p>
<h4 id="replace-naive-merging-with-ordered-merging">9.7.3 Replace Naive
Merging with Ordered Merging</h4>
<p>Postings lists are already ordered.</p>
<p>Invocation:
<code>ocamlbuild InvIndex2.native -libs unix --</code></p>
<p>Time: 2.5s</p>
<h4 id="bruteforce-optimization-biword-indexes">9.7.4 Bruteforce
Optimization: Biword Indexes</h4>
<p>Pairs of words are much less frequent than single words, so storing
them means less work for postings lists merging.</p>
<p>Can result in much bigger index size: <span
class="math inline">\min(W^2, N)</span> where <span
class="math inline">W</span> is the number of distinct words and <span
class="math inline">N</span> the total number of words in documents.</p>
<p>Invocation that gives us stack backtraces:</p>
<pre><code>ocamlbuild InvIndex3.native -cflag -g -libs unix; export OCAMLRUNPARAM=&quot;b&quot;; ./InvIndex3.native</code></pre>
<p>Time: 2.4s – disappointing.</p>
<h4 id="smart-way-information-retrieval-g.v.-cormack-et-al.">9.7.5 Smart
Way: Information Retrieval (G.V. Cormack et al.)</h4>
<p>You should classify your problem and search literature for
state-of-the-art algorithms to solve it.</p>
<p>The algorithm needs a data structure for inverted index that
supports: - <code>first(w)</code> – first position in documents at which
<code>w</code> appears - <code>last(w)</code> – last position of
<code>w</code> - <code>next(w,cp)</code> – first position of
<code>w</code> after position <code>cp</code> - <code>prev(w,cp)</code>
– last position of <code>w</code> before position <code>cp</code></p>
<p>We develop <code>next</code> and <code>prev</code> operations in
stages: 1. First, a naive (but FP) approach using the <code>Set</code>
module of OCaml - We could use our balanced binary search tree
implementation to avoid the overhead due to limitations of
<code>Set</code> API 2. Then, <em>binary search</em> based on arrays 3.
Imperative linear search 4. Imperative <em>galloping search</em>
optimization of binary search</p>
<h5 id="the-phrase-search-algorithm">The Phrase Search Algorithm</h5>
<p>During search we maintain <em>current position</em> <code>cp</code>
of the last found word or phrase.</p>
<p>The algorithm is almost purely functional; we use the
<code>Not_found</code> exception instead of option type for
convenience.</p>
<pre><code>let rec next_phrase ii phrase cp =      (* Return the beginning and end position *)
  let rec aux cp = function             (* of occurrence of phrase after position cp *)
    | [] -&gt; raise Not_found             (* Empty phrase counts as not occurring *)
    | [w] -&gt;                            (* Single or last word of phrase has the same *)
      let np = next ii w cp in np, np   (* beg. and end position *)
    | w::ws -&gt;                          (* After locating the endp. move back *)
      let np, fp = aux (next ii w cp) ws in
      prev ii w np, fp in
  let np, fp = aux cp phrase in         (* If distance is this small, *)
  if fp - np = List.length phrase - 1 then np, fp  (* words are consecutive *)
  else next_phrase ii phrase fp

let search (ii, linebreaks) phrase =
  let lexbuf = Lexing.from_string phrase in
  EngLexer.reset_as_file lexbuf (&quot;search phrase: &quot;^phrase);
  let phrase = IndexParser.phrase EngLexer.token lexbuf in
  let rec aux cp =
    try                                  (* Find all occurrences of the phrase *)
      let np, fp = next_phrase ii phrase cp in
      np :: aux fp
    with Not_found -&gt; [] in              (* Moved past last occurrence *)
  List.map (find_line linebreaks) (aux (-1))</code></pre>
<h5 id="naive-but-purely-functional-inverted-index">Naive but Purely
Functional Inverted Index</h5>
<pre><code>module S = Set.Make(struct type t=int let compare i j = i-j end)

let update ii (w, p) =
  (try
    let ps = Hashtbl.find ii w in
    Hashtbl.replace ii w (S.add p ps)
  with Not_found -&gt; Hashtbl.add ii w (S.singleton p));
  ii

let first ii w = S.min_elt (find w ii)       (* The functions raise Not_found *)
let last ii w = S.max_elt (find w ii)        (* whenever such position would not exist *)

let prev ii w cp =
  let ps = find w ii in                      (* Split the set into elements *)
  let smaller, _, _ = S.split cp ps in       (* smaller and bigger than cp *)
  S.max_elt smaller

let next ii w cp =
  let ps = find w ii in
  let _, _, bigger = S.split cp ps in
  S.min_elt bigger</code></pre>
<p>Invocation:
<code>ocamlbuild InvIndex4.native -libs unix --</code></p>
<p>Time: 3.3s – would be better without the overhead of
<code>S.split</code>.</p>
<h5 id="binary-search-based-inverted-index">Binary Search Based Inverted
Index</h5>
<pre><code>let prev ii w cp =
  let ps = find w ii in
  let rec aux b e =                    (* We implement binary search separately for prev *)
    if e-b &lt;= 1 then ps.(b)            (* to make sure here we return less than cp *)
    else let m = (b+e)/2 in
         if ps.(m) &lt; cp then aux m e
         else aux b m in
  let l = Array.length ps in
  if l = 0 || ps.(0) &gt;= cp then raise Not_found
  else aux 0 (l-1)

let next ii w cp =
  let ps = find w ii in
  let rec aux b e =
    if e-b &lt;= 1 then ps.(e)            (* and here more than cp *)
    else let m = (b+e)/2 in
         if ps.(m) &lt;= cp then aux m e
         else aux b m in
  let l = Array.length ps in
  if l = 0 || ps.(l-1) &lt;= cp then raise Not_found
  else aux 0 (l-1)</code></pre>
<p>File: <code>InvIndex5.ml</code>. Time: 2.4s</p>
<h5 id="imperative-linear-scan">Imperative, Linear Scan</h5>
<pre><code>let prev ii w cp =
  let cw,ps = find w ii in      (* For each word we add a cell with last visited occurrence *)
  let l = Array.length ps in
  if l = 0 || ps.(0) &gt;= cp then raise Not_found
  else if ps.(l-1) &lt; cp then cw := l-1
  else (                         (* Reset pointer if current position is not &quot;ahead&quot; of it *)
    if !cw &lt; l-1 &amp;&amp; ps.(!cw+1) &lt; cp then cw := l-1;    (* Otherwise scan *)
    while ps.(!cw) &gt;= cp do decr cw done               (* starting from last visited *)
  );
  ps.(!cw)

let next ii w cp =
  let cw,ps = find w ii in
  let l = Array.length ps in
  if l = 0 || ps.(l-1) &lt;= cp then raise Not_found
  else if ps.(0) &gt; cp then cw := 0
  else (                         (* Reset pointer if current position is not ahead of it *)
    if !cw &gt; 0 &amp;&amp; ps.(!cw-1) &gt; cp then cw := 0;
    while ps.(!cw) &lt;= cp do incr cw done
  );
  ps.(!cw)</code></pre>
<p>End of <code>index</code>-building function:</p>
<pre><code>mapv (fun ps-&gt;ref 0, Array.of_list (List.rev ps)) ii,...</code></pre>
<p>File: <code>InvIndex6.ml</code>. Time: 2.8s</p>
<h5 id="imperative-galloping-search">Imperative, Galloping Search</h5>
<pre><code>let next ii w cp =
  let cw,ps = find w ii in
  let l = Array.length ps in
  if l = 0 || ps.(l-1) &lt;= cp then raise Not_found;
  let rec jump (b,e as bounds) j =          (* Locate the interval with cp inside *)
    if e &lt; l-1 &amp;&amp; ps.(e) &lt;= cp then jump (e,e+j) (2*j)
    else bounds in
  let rec binse b e =                       (* Binary search over that interval *)
    if e-b &lt;= 1 then e
    else let m = (b+e)/2 in
         if ps.(m) &lt;= cp then binse m e
         else binse b m in
  if ps.(0) &gt; cp then cw := 0
  else (
    let b =                                 (* The invariant is that ps.(b) &lt;= cp *)
      if !cw &gt; 0 &amp;&amp; ps.(!cw-1) &lt;= cp then !cw-1 else 0 in
    let b,e = jump (b,b+1) 2 in             (* Locate interval starting near !cw *)
    let e = if e &gt; l-1 then l-1 else e in
    cw := binse b e
  );
  ps.(!cw)</code></pre>
<p><code>prev</code> is symmetric to <code>next</code>.</p>
<p>File: <code>InvIndex7.ml</code>. Time: 2.4s – minimal speedup in our
simple test case.</p>
<h3 id="exercises-8">9.8 Exercises</h3>
<ol type="1">
<li><p>(Exercise 6.1 from <em>“Modern Compiler Implementation in
ML”</em> by Andrew W. Appel.) Using the <code>ocamlopt</code> compiler
with parameter <code>-S</code> and other parameters turning on all
possible compiler optimizations, evaluate the compiled programs by these
criteria:</p>
<ul>
<li>Are local variables kept in registers? Show on an example.</li>
<li>If local variable <code>b</code> is live across more than one
procedure call, is it kept in a callee-save register? Explain how it
would speed up the program:
<code>let f a = let b = a+1 in let c = g () in let d = h c in b+c</code></li>
<li>If local variable <code>x</code> is never live across a procedure
call, is it properly kept in a caller-save register? Explain how doing
this would speed up the program:
<code>let h y = let x = y+1 in let z = f y in f z</code></li>
</ul></li>
<li><p>As above, verify whether escaping variables of a function are
kept in a closure corresponding to the function, or in closures
corresponding to the local (nested) functions that are returned from the
function (or assigned to a mutable field).</p></li>
<li><p>As above, verify that OCaml compiler performs <em>inline
expansion</em> of small functions. Check whether the compiler can
inline, or specialize (produce a local function to help inlining),
recursive functions.</p></li>
<li><p>Write a <code>.mll</code> program that anonymizes (or masks)
text. That is, it replaces identified probable full names (of persons,
companies etc.) with fresh shorthands <em>Mr. A</em>, <em>Ms. B</em>, or
<em>Mr./Ms. C</em> when the gender cannot be easily determined. The same
(full) name should be replaced with the same letter.</p>
<ul>
<li>Do only a very rough job of course, starting with recognizing two or
more capitalized words in a row.</li>
</ul></li>
<li><p>In the lexer <code>EngLexer</code> we call function
<code>abridged</code> from the module <code>EngMorph</code>. Inline the
operation of <code>abridged</code> into the lexer by adding a new
regular expression pattern for each if clause. Assess the speedup on the
<em>Shakespeare</em> corpus and the readability, and either keep the
change or revert it.</p></li>
<li><p>Make the lexer re-entrant for the second Menhir example (toy
English grammar parser).</p></li>
<li><p>Make the determiner optional in the toy English grammar.</p>
<ul>
<li>(*) Can you come up with a factorization that would avoid having two
more productions in total?</li>
</ul></li>
<li><p>Integrate into the <em>Phrase search</em> example the <em>Porter
Stemmer</em> whose source is in the <code>stemmer.ml</code>
file.</p></li>
<li><p>Revisit the search engine example from lecture 6.</p>
<ul>
<li>Perform optimization of data structure, i.e. replace association
lists with hash tables.</li>
<li>Optimize the algorithm: perform <em>query optimization</em>. Measure
time gains for selected queries.</li>
<li>For bonus points, as time and interest permits, extend the query
language with <em>OR</em> and <em>NOT</em> connectives, in addition to
<em>AND</em>.</li>
<li>(<em>) Extend query optimization to the query language with
</em>AND<em>, </em>OR* and <em>NOT</em> connectives.</li>
</ul></li>
<li><p>Write an XML parser tailored to the <code>shakespeare.xml</code>
corpus provided with the phrase search example. Modify the phrase search
engine to provide detailed information for each found location,
e.g. which play and who speaks the phrase.</p></li>
</ol>
<h2 id="chapter-10-functional-reactive-programming">Chapter 10:
Functional Reactive Programming</h2>
<p>This chapter explores techniques for dealing with change and
interaction in functional programming. We begin with zippers, a data
structure for navigating and modifying positions within larger
structures, then progress to adaptive (incremental) programming and
Functional Reactive Programming (FRP). We conclude with practical
examples including graphical user interfaces.</p>
<p><strong>Recommended Reading:</strong> - <em>“Zipper”</em> in Haskell
Wikibook and <em>“The Zipper”</em> by Gerard Huet - <em>“How
<code>froc</code> works”</em> by Jacob Donham - <em>“The Haskell School
of Expression”</em> by Paul Hudak - <em>“Deprecating the Observer
Pattern with <code>Scala.React</code>”</em> by Ingo Maier, Martin
Odersky</p>
<h3 id="zippers">10.1 Zippers</h3>
<p>Often we need to keep track of a position within a data structure:
easily access and modify it at that location, and easily move the
location around. Recall from earlier chapters how we defined <em>context
types</em> for datatypes – types that represent a data structure with
one of its elements missing.</p>
<p>Consider binary trees:</p>
<pre><code>type btree = Tip | Node of int * btree * btree</code></pre>
<p>Using our algebraic datatype calculus, where <span
class="math inline">T</span> represents the tree type:</p>
<p><span class="math display">
\begin{matrix}
T &amp; = &amp; 1 + xT^2 \\
\frac{\partial T}{\partial x} &amp; = &amp; 0 + T^2 + 2xT\frac{\partial
T}{\partial x} = TT + 2xT\frac{\partial T}{\partial x}
\end{matrix}
</span></p>
<p>This derivative gives us the context type:</p>
<pre><code>type btree_dir = LeftBranch | RightBranch
type btree_deriv =
  | Here of btree * btree
  | Below of btree_dir * int * btree * btree_deriv</code></pre>
<p>The key insight is that <strong>Location = context +
subtree</strong>! However, there is a problem with the representation
above: we cannot easily move the location if <code>Here</code> is at the
bottom. The part closest to the location should be on top.</p>
<h4 id="revisiting-the-equations">Revisiting the Equations</h4>
<p>Let us revisit the equations for trees and lists:</p>
<p><span class="math display">
\begin{matrix}
T &amp; = &amp; 1 + xT^2 \\
\frac{\partial T}{\partial x} &amp; = &amp; 0 + T^2 + 2xT\frac{\partial
T}{\partial x} \\
\frac{\partial T}{\partial x} &amp; = &amp; \frac{T^2}{1 - 2xT} \\
L(y) &amp; = &amp; 1 + yL(y) \\
L(y) &amp; = &amp; \frac{1}{1 - y} \\
\frac{\partial T}{\partial x} &amp; = &amp; T^2 L(2xT)
\end{matrix}
</span></p>
<p>This tells us that the context can be stored as a list with the root
as the last node. It does not matter whether we use built-in lists or a
type with <code>Above</code> and <code>Root</code> variants.</p>
<p>Contexts of subtrees are more useful than contexts of single
elements:</p>
<pre><code>type &#39;a tree = Tip | Node of &#39;a tree * &#39;a * &#39;a tree
type tree_dir = Left_br | Right_br
type &#39;a context = (tree_dir * &#39;a * &#39;a tree) list
type &#39;a location = {sub: &#39;a tree; ctx: &#39;a context}

let access {sub} = sub
let change {ctx} sub = {sub; ctx}
let modify f {sub; ctx} = {sub = f sub; ctx}</code></pre>
<p>We can imagine a location as a rooted tree which is hanging pinned at
one of its nodes. For visualizations, see
http://en.wikibooks.org/wiki/Haskell/Zippers.</p>
<h4 id="moving-around">Moving Around</h4>
<p>Navigation functions allow us to traverse the structure:</p>
<pre><code>let ascend loc =
  match loc.ctx with
  | [] -&gt; loc  (* Or raise exception *)
  | (Left_br, n, l) :: up_ctx -&gt;
    {sub = Node (l, n, loc.sub); ctx = up_ctx}
  | (Right_br, n, r) :: up_ctx -&gt;
    {sub = Node (loc.sub, n, r); ctx = up_ctx}

let desc_left loc =
  match loc.sub with
  | Tip -&gt; loc  (* Or raise exception *)
  | Node (l, n, r) -&gt;
    {sub = l; ctx = (Right_br, n, r) :: loc.ctx}

let desc_right loc =
  match loc.sub with
  | Tip -&gt; loc  (* Or raise exception *)
  | Node (l, n, r) -&gt;
    {sub = r; ctx = (Left_br, n, l) :: loc.ctx}</code></pre>
<h4 id="trees-with-arbitrary-branching">Trees with Arbitrary
Branching</h4>
<p>Following <em>The Zipper</em> by Gerard Huet, let us look at a tree
with an arbitrary number of branches, representing a document
structure:</p>
<pre><code>type doc = Text of string | Line | Group of doc list
type context = (doc list * doc list) list
type location = {sub: doc; ctx: context}</code></pre>
<p>The navigation functions for this more complex structure:</p>
<pre><code>let go_up loc =
  match loc.ctx with
  | [] -&gt; invalid_arg &quot;go_up: at top&quot;
  | (left, right) :: up_ctx -&gt;  (* Previous subdocument and its siblings *)
    {sub = Group (List.rev left @ loc.sub :: right); ctx = up_ctx}

let go_left loc =
  match loc.ctx with
  | [] -&gt; invalid_arg &quot;go_left: at top&quot;
  | (l :: left, right) :: up_ctx -&gt;  (* Left sibling of previous subdocument *)
    {sub = l; ctx = (left, loc.sub :: right) :: up_ctx}
  | ([], _) :: _ -&gt; invalid_arg &quot;go_left: at first&quot;

let go_right loc =
  match loc.ctx with
  | [] -&gt; invalid_arg &quot;go_right: at top&quot;
  | (left, r :: right) :: up_ctx -&gt;
    {sub = r; ctx = (loc.sub :: left, right) :: up_ctx}
  | (_, []) :: _ -&gt; invalid_arg &quot;go_right: at last&quot;

let go_down loc =  (* Go to the first (i.e. leftmost) subdocument *)
  match loc.sub with
  | Text _ -&gt; invalid_arg &quot;go_down: at text&quot;
  | Line -&gt; invalid_arg &quot;go_down: at line&quot;
  | Group [] -&gt; invalid_arg &quot;go_down: at empty&quot;
  | Group (doc :: docs) -&gt; {sub = doc; ctx = ([], docs) :: loc.ctx}</code></pre>
<h3 id="example-context-rewriting">10.2 Example: Context Rewriting</h3>
<p>Imagine a friend working on string theory asks us for help
simplifying equations. The task is to pull out particular subexpressions
as far to the left as possible, while changing the whole expression as
little as possible.</p>
<p>We can illustrate our algorithm using mathematical notation. Let: -
<span class="math inline">x</span> be the thing we pull out - <span
class="math inline">C[e]</span> and <span
class="math inline">D[e]</span> be big expressions with subexpression
<span class="math inline">e</span> - operator <span
class="math inline">\circ</span> stand for one of: <span
class="math inline">*, +</span></p>
<p>The rewriting rules are:</p>
<p><span class="math display">
\begin{matrix}
D[(C[x] \circ e_1) \circ e_2] &amp; \Rightarrow &amp; D[C[x] \circ (e_1
\circ e_2)] \\
D[e_2 \circ (C[x] \circ e_1)] &amp; \Rightarrow &amp; D[C[x] \circ (e_1
\circ e_2)] \\
D[(C[x] + e_1) e_2] &amp; \Rightarrow &amp; D[C[x] e_2 + e_1 e_2] \\
D[e_2 (C[x] + e_1)] &amp; \Rightarrow &amp; D[C[x] e_2 + e_1 e_2] \\
D[e \circ C[x]] &amp; \Rightarrow &amp; D[C[x] \circ e]
\end{matrix}
</span></p>
<p>First, the groundwork:</p>
<pre><code>type op = Add | Mul
type expr = Val of int | Var of string | App of expr * op * expr
type expr_dir = Left_arg | Right_arg
type context = (expr_dir * op * expr) list
type location = {sub: expr; ctx: context}</code></pre>
<p>To locate the subexpression described by predicate
<code>p</code>:</p>
<pre><code>let rec find_aux p e =
  if p e then Some (e, [])
  else match e with
  | Val _ | Var _ -&gt; None
  | App (l, op, r) -&gt;
    match find_aux p l with
    | Some (sub, up_ctx) -&gt;
      Some (sub, (Right_arg, op, r) :: up_ctx)
    | None -&gt;
      match find_aux p r with
      | Some (sub, up_ctx) -&gt;
        Some (sub, (Left_arg, op, l) :: up_ctx)
      | None -&gt; None

let find p e =
  match find_aux p e with
  | None -&gt; None
  | Some (sub, ctx) -&gt; Some {sub; ctx = List.rev ctx}</code></pre>
<p>Now we can implement the pull-out transformation:</p>
<pre><code>let rec pull_out loc =
  match loc.ctx with
  | [] -&gt; loc  (* Done *)
  | (Left_arg, op, l) :: up_ctx -&gt;
    (* D[e . C[x]] =&gt; D[C[x] . e] *)
    pull_out {loc with ctx = (Right_arg, op, l) :: up_ctx}
  | (Right_arg, op1, e1) :: (_, op2, e2) :: up_ctx
      when op1 = op2 -&gt;
    (* D[(C[x] . e1) . e2] / D[e2 . (C[x] . e1)] =&gt; D[C[x] . (e1 . e2)] *)
    pull_out {loc with ctx = (Right_arg, op1, App(e1, op1, e2)) :: up_ctx}
  | (Right_arg, Add, e1) :: (_, Mul, e2) :: up_ctx -&gt;
    (* D[(C[x] + e1) * e2] / D[e2 * (C[x] + e1)] =&gt; D[C[x] * e2 + e1 * e2] *)
    pull_out {loc with ctx =
        (Right_arg, Mul, e2) ::
          (Right_arg, Add, App(e1, Mul, e2)) :: up_ctx}
  | (Right_arg, op, r) :: up_ctx -&gt;  (* Move up the context *)
    pull_out {sub = App(loc.sub, op, r); ctx = up_ctx}</code></pre>
<p>Since operators are commutative, we ignore the direction for the
second piece of context above.</p>
<p>Testing the implementation:</p>
<pre><code>let (+) a b = App (a, Add, b)
let ( * ) a b = App (a, Mul, b)
let (!) a = Val a
let x = Var &quot;x&quot;
let y = Var &quot;y&quot;
let ex = !5 + y * (!7 + x) * (!3 + y)
let loc = find (fun e -&gt; e = x) ex
let sol =
  match loc with
  | None -&gt; raise Not_found
  | Some loc -&gt; pull_out loc
(* Result: &quot;(((x*y)*(3+y))+(((7*y)*(3+y))+5))&quot; *)</code></pre>
<p>For best results, we can iterate the <code>pull_out</code> function
until a fixpoint is reached.</p>
<h3 id="adaptive-programming-incremental-computing">10.3 Adaptive
Programming (Incremental Computing)</h3>
<p>While zippers are useful, they are somewhat unnatural for
general-purpose programming. Once we change the data structure, it is
difficult to propagate the changes – we would need to rewrite all
algorithms to work on context changes.</p>
<p>In <em>Adaptive Programming</em>, also known as <em>incremental
computation</em> or <em>self-adjusting computation</em>, we write
programs in a straightforward functional manner, but can later modify
any data causing only the minimal amount of work required to update
results.</p>
<p>The functional description of computation is within a monad. We can
change monadic values – for example, parts of input – from outside and
propagate the changes. In the <em>Froc</em> library, the monadic
<em>changeables</em> are <code>'a Froc_sa.t</code>, and the ability to
modify them is exposed by type <code>'a Froc_sa.u</code> – the
<em>writeables</em>.</p>
<h4 id="dependency-graphs">Dependency Graphs</h4>
<p>The monadic value <code>'a changeable</code> will be the
<em>dependency graph</em> of the computation of the represented value
<code>'a</code>. Consider the computation:</p>
<pre><code>let u = v / w + x * y + z</code></pre>
<p>The dependency graph shows how the result depends on the inputs. When
we modify inputs <code>v</code> and <code>z</code> simultaneously, we
need to update intermediate nodes in the correct order. For example, we
need to update <code>n2</code> before <code>u</code>.</p>
<p>We use the order of computation (represented as gray numbers in the
dependency visualization) for the order of updates. Similarly to
<code>parallel</code> in the concurrency monad, we provide
<code>bind2</code>, <code>bind3</code>, etc., and corresponding
<code>lift2</code>, <code>lift3</code>, etc., to introduce nodes with
several children:</p>
<pre><code>let n0 = bind2 v w (fun v w -&gt; return (v / w))
let n1 = bind2 x y (fun x y -&gt; return (x * y))
let n2 = bind2 n0 n1 (fun n0 n1 -&gt; return (n0 + n1))
let u = bind2 n2 z (fun n2 z -&gt; return (n2 + z))</code></pre>
<p>Do-notation is not necessary to have readable expressions:</p>
<pre><code>let (/) = lift2 (/)
let ( * ) = lift2 ( * )
let (+) = lift2 (+)
let u = v / w + x * y + z</code></pre>
<p>As in other monads, we can decrease overhead by using bigger
chunks:</p>
<pre><code>let n0 = blift2 v w (fun v w -&gt; v / w)
let n2 = blift3 n0 x y (fun n0 x y -&gt; n0 + x * y)
let u = blift2 n2 z (fun n2 z -&gt; n2 + z)</code></pre>
<h4 id="handling-conditional-dependencies">Handling Conditional
Dependencies</h4>
<p>We have a problem if we recompute all nodes simply by order of
computation:</p>
<pre><code>let b = x &gt;&gt;= fun x -&gt; return (x = 0)
let n0 = x &gt;&gt;= fun x -&gt; return (100 / x)
let y = bind2 b n0 (fun b n0 -&gt; if b then return 0 else n0)</code></pre>
<p>Rather than a single “time” stamp, we store intervals: begin and end
of computation. When updating the <code>y</code> node, we first detach
nodes in the range 4-9 from the graph. Computing the expression will
re-attach the nodes as needed.</p>
<p>When the value of <code>b</code> does not change, we skip updating
<code>y</code> and proceed with updating <code>n0</code>. The value of
<code>y</code> is a link to the value of <code>n0</code> so it will
change anyway.</p>
<p>We need memoization to re-attach the same nodes in case they do not
need updating. Are they up-to-date? Run updating past the node’s
timestamp range.</p>
<h4 id="example-using-froc">Example Using Froc</h4>
<p>The <code>Froc_sa</code> (for <em>self-adjusting</em>) module exports
the monadic type <code>t</code> for changeable computation, and a handle
type <code>u</code> for updating the computation:</p>
<pre><code>open Froc_sa

type tree =  (* Binary tree with nodes storing their screen location *)
  | Leaf of int * int  (* We will grow the tree *)
  | Node of int * int * tree t * tree t  (* by modifying subtrees *)</code></pre>
<p>Displaying the tree is a changeable effect. Whenever the tree
changes, displaying will be updated. Only new nodes will be drawn after
an update:</p>
<pre><code>let rec display px py t =
  match t with
  | Leaf (x, y) -&gt;
    return
      (Graphics.draw_poly_line [|px, py; x, y|];  (* We return *)
       Graphics.draw_circle x y 3)  (* a throwaway value *)
  | Node (x, y, l, r) -&gt;
    return (Graphics.draw_poly_line [|px, py; x, y|])
    &gt;&gt;= fun _ -&gt; l &gt;&gt;= display x y
    &gt;&gt;= fun _ -&gt; r &gt;&gt;= display x y</code></pre>
<p>Growing the tree:</p>
<pre><code>let grow_at (x, depth, upd) =
  let x_l = x - f2i (width *. (2.0 ** (~-. (i2f (depth + 1))))) in
  let l, upd_l = changeable (Leaf (x_l, (depth + 1) * 20)) in
  let x_r = x + f2i (width *. (2.0 ** (~-. (i2f (depth + 1))))) in
  let r, upd_r = changeable (Leaf (x_r, (depth + 1) * 20)) in
  write upd (Node (x, depth * 20, l, r));  (* Update the old leaf *)
  propagate ();  (* and keep handles to make future updates *)
  [x_l, depth + 1, upd_l; x_r, depth + 1, upd_r]</code></pre>
<p>The main loop:</p>
<pre><code>let rec loop t subts steps =
  if steps &lt;= 0 then ()
  else loop t (concat_map grow_at subts) (steps - 1)

let incremental steps () =
  Graphics.open_graph &quot; 1024x600&quot;;
  let t, u = changeable (Leaf (512, 20)) in
  let d = t &gt;&gt;= display (f2i (width /. 2.)) 0 in  (* Display once *)
  loop t [512, 1, u] steps;  (* new nodes will be drawn automatically *)
  Graphics.close_graph ()</code></pre>
<p>Unfortunately, the overhead of incremental computation is quite
large. Comparing byte code execution times:</p>
<table style="width:100%;">
<colgroup>
<col style="width: 12%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 11%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr>
<th>depth</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
<th>17</th>
<th>18</th>
<th>19</th>
<th>20</th>
</tr>
</thead>
<tbody>
<tr>
<td>incremental</td>
<td>0.66s</td>
<td>1s</td>
<td>2.2s</td>
<td>4.4s</td>
<td>9.3s</td>
<td>21s</td>
<td>50s</td>
<td>140s</td>
<td>255s</td>
</tr>
<tr>
<td>rebuilding</td>
<td>0.5s</td>
<td>0.63s</td>
<td>1.3s</td>
<td>3s</td>
<td>5.3s</td>
<td>13s</td>
<td>39s</td>
<td>190s</td>
<td>–</td>
</tr>
</tbody>
</table>
<h3 id="functional-reactive-programming">10.4 Functional Reactive
Programming</h3>
<p>FRP is an attempt to declaratively deal with time. <em>Behaviors</em>
are functions of time – a behavior has a specific value in each instant.
<em>Events</em> are sets of (time, value) pairs, organized into streams
of actions.</p>
<p>Two problems arise in FRP: 1. Behaviors and events are well-defined
when they do not depend on future 2. Efficiency: minimize overhead</p>
<p>FRP is <em>synchronous</em>: it is possible to set up for events to
happen at the same time. It is also <em>continuous</em>: behaviors can
have details at arbitrary time resolution. Although the results are
<em>sampled</em>, there is no fixed (minimal) time step for specifying
behavior. (Note: “Asynchrony” refers to various ideas, so always ask
what people mean when they use the term.)</p>
<h4 id="idealized-definitions">Idealized Definitions</h4>
<p>Ideally we would define:</p>
<pre><code>type time = float
type &#39;a behavior = time -&gt; &#39;a  (* Arbitrary function *)
type &#39;a event = (&#39;a, time) stream  (* Increasing time instants *)</code></pre>
<p>Forcing a lazy list (stream) of events would wait until an event
arrives. But behaviors need to react to external events:</p>
<pre><code>type user_action =
  | Key of char * bool
  | Button of int * int * bool * bool
  | MouseMove of int * int
  | Resize of int * int

type &#39;a behavior = user_action event -&gt; time -&gt; &#39;a</code></pre>
<p>Scanning through an event list since the beginning of time until
current time, each time we evaluate a behavior, is very wasteful with
respect to time and space. Producing a stream of behaviors for the
stream of time allows us to forget about events already in the past:</p>
<pre><code>type &#39;a behavior =
  user_action event -&gt; time stream -&gt; &#39;a stream</code></pre>
<p>The next optimization is to pair user actions with sampling
times:</p>
<pre><code>type &#39;a behavior =
  (user_action option * time) stream -&gt; &#39;a stream</code></pre>
<p>The <code>None</code> action corresponds to sampling time when
nothing happens.</p>
<p>Turning behaviors and events from functions of time into input-output
streams is similar to optimizing intersection of ordered lists from
<span class="math inline">O(mn)</span> to <span class="math inline">O(m
+ n)</span> time.</p>
<p>Now we can in turn define events in terms of behaviors:</p>
<pre><code>type &#39;a event = &#39;a option behavior</code></pre>
<p>although it betrays the discrete character of events (happening at
points in time rather than varying over intervals of time).</p>
<p>We have gotten very close to <em>stream processing</em> as discussed
in Chapter 7. Recall the incremental pretty-printing example that can
“react” to more input. Stream combinators, <em>fork</em> from the
exercises for Chapter 7, and a corresponding <em>merge</em>, turn stream
processing into <em>synchronous discrete reactive programming</em>.</p>
<h4 id="behaviors-as-monads">Behaviors as Monads</h4>
<p>Behaviors are monadic (but see the next point) – in the original
specification:</p>
<pre><code>type &#39;a behavior = time -&gt; &#39;a

val return : &#39;a -&gt; &#39;a behavior
let return a = fun _ -&gt; a

val bind : &#39;a behavior -&gt; (&#39;a -&gt; &#39;b behavior) -&gt; &#39;b behavior
let bind a f = fun t -&gt; f (a t) t</code></pre>
<p>As we have seen with changeables, we mostly use lifting. In the
Haskell world we would call behaviors <em>applicative</em>. To build our
own lifters in any monad:</p>
<pre><code>val ap : (&#39;a -&gt; &#39;b) monad -&gt; &#39;a monad -&gt; &#39;b monad
let ap fm am = perform
  f &lt;-- fm;
  a &lt;-- am;
  return (f a)</code></pre>
<p>Note that for changeables, the naive implementation above will
introduce unnecessary dependencies. Monadic libraries for
<em>incremental computing</em> or FRP should provide optimized variants
if needed. Compare with <code>parallel</code> for concurrent
computing.</p>
<h4 id="converting-between-events-and-behaviors">Converting Between
Events and Behaviors</h4>
<p>Going from events to behaviors, <code>until</code> and
<code>switch</code> have type:</p>
<pre><code>&#39;a behavior -&gt; &#39;a behavior event -&gt; &#39;a behavior</code></pre>
<p>while <code>step</code> has type:</p>
<pre><code>&#39;a -&gt; &#39;a event -&gt; &#39;a behavior</code></pre>
<ul>
<li><code>until b es</code> behaves as <code>b</code> until the first
event in <code>es</code>, then behaves as the behavior in that
event</li>
<li><code>switch b es</code> behaves as the behavior from the last event
in <code>es</code> prior to current time, if any, otherwise as
<code>b</code></li>
<li><code>step a b</code> starts with behavior returning <code>a</code>
and then switches to returning the value of the last event in
<code>b</code> (prior to current time) – a <em>step function</em></li>
</ul>
<p>We will use “<em>signal</em>” to refer to a behavior or an event.
Note that often “signal” is used to mean what we call behavior (check
terminology when looking at a new FRP library).</p>
<h3 id="reactivity-by-stream-processing">10.5 Reactivity by Stream
Processing</h3>
<p>The stream processing infrastructure should be familiar from earlier
chapters:</p>
<pre><code>type &#39;a stream = &#39;a stream_ Lazy.t
and &#39;a stream_ = Cons of &#39;a * &#39;a stream

let rec lmap f l = lazy (
  let Cons (x, xs) = Lazy.force l in
  Cons (f x, lmap f xs))

let rec liter (f : &#39;a -&gt; unit) (l : &#39;a stream) : unit =
  let Cons (x, xs) = Lazy.force l in
  f x; liter f xs

let rec lmap2 f xs ys = lazy (
  let Cons (x, xs) = Lazy.force xs in
  let Cons (y, ys) = Lazy.force ys in
  Cons (f x y, lmap2 f xs ys))

let rec lmap3 f xs ys zs = lazy (
  let Cons (x, xs) = Lazy.force xs in
  let Cons (y, ys) = Lazy.force ys in
  let Cons (z, zs) = Lazy.force zs in
  Cons (f x y z, lmap3 f xs ys zs))

let rec lfold acc f (l : &#39;a stream) = lazy (
  let Cons (x, xs) = Lazy.force l in  (* Fold a function over the stream *)
  let acc = f acc x in  (* producing a stream of partial results *)
  Cons (acc, lfold acc f xs))</code></pre>
<p>Since a behavior is a function of user actions and sample times, we
need to ensure that only one stream is created for the actual input
stream:</p>
<pre><code>type (&#39;a, &#39;b) memo1 =
  {memo_f : &#39;a -&gt; &#39;b; mutable memo_r : (&#39;a * &#39;b) option}

let memo1 f = {memo_f = f; memo_r = None}

let memo1_app f x =
  match f.memo_r with
  | Some (y, res) when x == y -&gt; res  (* Physical equality is OK -- *)
  | _ -&gt;  (* external input is &quot;physically&quot; unique *)
    let res = f.memo_f x in  (* While debugging, we can monitor *)
    f.memo_r &lt;- Some (x, res);  (* whether f.memo_r = None before *)
    res

let ($) = memo1_app

type &#39;a behavior =
  ((user_action option * time) stream, &#39;a stream) memo1</code></pre>
<h4 id="building-complex-behaviors">Building Complex Behaviors</h4>
<p>The monadic/applicative functions to build complex behaviors. If you
do not provide type annotations in <code>.ml</code> files, work together
with an <code>.mli</code> file to catch problems early. You can later
add more type annotations as needed to find out what is wrong.</p>
<pre><code>let returnB x : &#39;a behavior =
  let rec xs = lazy (Cons (x, xs)) in
  memo1 (fun _ -&gt; xs)

let ( !* ) = returnB

let liftB f fb = memo1 (fun uts -&gt; lmap f (fb $ uts))

let liftB2 f fb1 fb2 = memo1
  (fun uts -&gt; lmap2 f (fb1 $ uts) (fb2 $ uts))

let liftB3 f fb1 fb2 fb3 = memo1
  (fun uts -&gt; lmap3 f (fb1 $ uts) (fb2 $ uts) (fb3 $ uts))

let liftE f (fe : &#39;a event) : &#39;b event = memo1
  (fun uts -&gt; lmap
    (function Some e -&gt; Some (f e) | None -&gt; None)
    (fe $ uts))

let (=&gt;&gt;) fe f = liftE f fe
let (-&gt;&gt;) e v = e =&gt;&gt; fun _ -&gt; v</code></pre>
<p>Creating events out of behaviors:</p>
<pre><code>let whileB (fb : bool behavior) : unit event =
  memo1 (fun uts -&gt;
    lmap (function true -&gt; Some () | false -&gt; None)
      (fb $ uts))

let unique fe : &#39;a event =
  memo1 (fun uts -&gt;
    let xs = fe $ uts in
    lmap2 (fun x y -&gt; if x = y then None else y)
      (lazy (Cons (None, xs))) xs)

let whenB fb =
  memo1 (fun uts -&gt; unique (whileB fb) $ uts)

let snapshot fe fb : (&#39;a * &#39;b) event =
  memo1 (fun uts -&gt; lmap2
    (fun x -&gt; function Some y -&gt; Some (y, x) | None -&gt; None)
      (fb $ uts) (fe $ uts))</code></pre>
<p>Creating behaviors out of events:</p>
<pre><code>let step acc fe =  (* The step function: value of last event *)
  memo1 (fun uts -&gt; lfold acc
    (fun acc -&gt; function None -&gt; acc | Some v -&gt; v)
    (fe $ uts))

let step_accum acc ff =  (* Transform a value by a series of functions *)
  memo1 (fun uts -&gt;
    lfold acc (fun acc -&gt; function
      | None -&gt; acc | Some f -&gt; f acc)
      (ff $ uts))</code></pre>
<p>To numerically integrate a behavior, we need to access the sampling
times:</p>
<pre><code>let integral fb =
  let rec loop t0 acc uts bs =
    let Cons ((_, t1), uts) = Lazy.force uts in
    let Cons (b, bs) = Lazy.force bs in
    let acc = acc +. (t1 -. t0) *. b in  (* b = fb(t1), acc approx integral up to t0 *)
    Cons (acc, lazy (loop t1 acc uts bs)) in
  memo1 (fun uts -&gt; lazy (
    let Cons ((_, t), uts&#39;) = Lazy.force uts in
    Cons (0., lazy (loop t 0. uts&#39; (fb $ uts)))))</code></pre>
<p>In our <em>paddle game</em> example, we paradoxically express
position and velocity in mutually recursive manner. The trick is the
same as in Chapter 7 – integration introduces one step of delay.</p>
<p>User actions:</p>
<pre><code>let lbp : unit event =
  memo1 (fun uts -&gt; lmap
    (function Some(Button(_,_)), _ -&gt; Some() | _ -&gt; None)
    uts)

let mm : (int * int) event =
  memo1 (fun uts -&gt; lmap
    (function Some(MouseMove(x, y)), _ -&gt; Some(x, y) | _ -&gt; None)
    uts)

let screen : (int * int) event =
  memo1 (fun uts -&gt; lmap
    (function Some(Resize(x, y)), _ -&gt; Some(x, y) | _ -&gt; None)
    uts)

let mouse_x : int behavior = step 0 (liftE fst mm)
let mouse_y : int behavior = step 0 (liftE snd mm)
let width : int behavior = step 640 (liftE fst screen)
let height : int behavior = step 512 (liftE snd screen)</code></pre>
<h4 id="the-paddle-game-example">The Paddle Game Example</h4>
<p>A <em>scene graph</em> is a data structure that represents a “world”
which can be drawn on screen:</p>
<pre><code>type scene =
  | Rect of int * int * int * int  (* position, width, height *)
  | Circle of int * int * int  (* position, radius *)
  | Group of scene list
  | Color of Graphics.color * scene  (* color of subscene objects *)
  | Translate of float * float * scene  (* additional offset of origin *)</code></pre>
<p>Drawing a scene explains what we mean above:</p>
<pre><code>let draw sc =
  let f2i = int_of_float in
  let open Graphics in
  let rec aux t_x t_y = function  (* Accumulate translations *)
    | Rect (x, y, w, h) -&gt;
      fill_rect (f2i t_x + x) (f2i t_y + y) w h
    | Circle (x, y, r) -&gt;
      fill_circle (f2i t_x + x) (f2i t_y + y) r
    | Group scs -&gt;
      List.iter (aux t_x t_y) scs
    | Color (c, sc) -&gt; set_color c; aux t_x t_y sc  (* Set color for sc objects *)
    | Translate (x, y, sc) -&gt; aux (t_x +. x) (t_y +. y) sc in
  clear_graph ();  (* &quot;Fast and clean&quot; removing of previous picture *)
  aux 0. 0. sc;
  synchronize ()  (* Synchronize the double buffer -- avoiding flickering *)</code></pre>
<p>An animation is a scene behavior. To animate it we need to create the
input stream: the user actions and sampling times stream. We could
abstract away drawing from time sampling in <code>reactimate</code>,
asking for (i.e. passing as argument) a producer of user actions and a
consumer of scene graphs (like <code>draw</code>).</p>
<p>General-purpose behavior operators:</p>
<pre><code>let (+*) = liftB2 (+)
let (-*) = liftB2 (-)
let ( *** ) = liftB2 ( * )
let (/*) = liftB2 (/)
let (&amp;&amp;*) = liftB2 (&amp;&amp;)
let (||*) = liftB2 (||)
let (&lt;*) = liftB2 (&lt;)
let (&gt;*) = liftB2 (&gt;)</code></pre>
<p>The walls are drawn on left, top and right borders of the window:</p>
<pre><code>let walls =
  liftB2 (fun w h -&gt; Color (Graphics.blue, Group
    [Rect (0, 0, 20, h-1); Rect (0, h-21, w-1, 20);
     Rect (w-21, 0, 20, h-1)]))
    width height</code></pre>
<p>The paddle is tied to the mouse at the bottom border of the
window:</p>
<pre><code>let paddle = liftB (fun mx -&gt;
  Color (Graphics.black, Rect (mx, 0, 50, 10))) mouse_x</code></pre>
<p>The ball has a velocity in pixels per second. It bounces from the
walls, which is hard-coded in terms of distance from window borders.
Unfortunately OCaml, being an eager language, does not let us encode
recursive behaviors in an elegant way. We need to unpack behaviors and
events as functions of the input stream:</p>
<ul>
<li><code>xbounce -&gt;&gt; (~-.)</code> event is just the negation
function happening at each horizontal bounce</li>
<li><code>step_accum vel (xbounce -&gt;&gt; (~-.))</code> behavior is
<code>vel</code> value changing sign at each horizontal bounce</li>
<li><code>liftB int_of_float (integral xvel) +* width /* !*2</code> –
first integrate velocity, then truncate it to integers and offset to the
middle of the window</li>
<li><code>whenB ((xpos &gt;* width -* !*27) ||* (xpos &lt;* !*27))</code>
– issue an event the first time the position exceeds the bounds. This
ensures there are no further bouncings until the ball moves out of the
walls</li>
</ul>
<h3 id="reactivity-by-incremental-computing">10.6 Reactivity by
Incremental Computing</h3>
<p>In <em>Froc</em>, behaviors and events are both implemented as
changeables but only behaviors persist; events are “instantaneous.”
Behaviors are composed out of constants and prior events, capturing the
“changeable” aspect. Events capture the “writeable” aspect – after their
values are propagated, the values are removed. Events and behaviors are
collectively called <em>signals</em>.</p>
<p><em>Froc</em> does not represent time, and provides the function
<code>changes : 'a behavior -&gt; 'a event</code>, which violates the
continuous semantics we introduced before. It breaks the illusion that
behaviors vary continuously rather than at discrete points in time. But
it avoids the need to synchronize global time samples with events in the
system. It is “less continuous but more dense.”</p>
<p>Sending an event – <code>send</code> – starts an <em>update
cycle</em>. Signals cannot call <code>send</code>, but can
<code>send_deferred</code> which will send an event in the next cycle.
Things that happen in the same update cycle are <em>simultaneous</em>.
Events are removed (detached from dependency graph) after an update
cycle.</p>
<p><em>Froc</em> provides the <code>fix_b</code>, <code>fix_e</code>
functions to define signals recursively. Current value refers to value
from previous update cycle, and defers next recursive step to next
cycle, until convergence.</p>
<p>Update cycles can happen “back-to-back” via
<code>send_deferred</code> and <code>fix_b</code>, <code>fix_e</code>,
or can be invoked from outside <em>Froc</em> by sending events at
arbitrary times. With a <code>time</code> behavior that holds a
<code>clock</code> event value, events from “back-to-back” update cycles
can be at the same clock time although not simultaneous in this sense.
Update cycles prevent <em>glitches</em>, where outdated signal is used
e.g. to issue an event.</p>
<h4 id="pure-vs.-impure-style">Pure vs. Impure Style</h4>
<p>A behavior is written in <em>pure style</em> when its definition does
not use <code>send</code>, <code>send_deferred</code>,
<code>notify_e</code>, <code>notify_b</code> and
<code>sample</code>:</p>
<ul>
<li><code>sample</code>, <code>notify_e</code>, <code>notify_b</code>
are used from outside the behavior (from its “environment”) analogously
to observing the result of a function</li>
<li><code>send</code>, <code>send_deferred</code> are used from outside
analogously to providing input to a function</li>
</ul>
<p>When writing in impure style we need to remember to refer from
somewhere to all the pieces of our behavior, otherwise the unreferred
parts will be <strong>garbage collected</strong> breaking the behavior.
A value is referred to when it has a name in the global environment or
is part of a bigger value that is referred to (for example it is stored
somewhere). Signals can be referred to by being part of the dependency
graph, but also by any of the more general ways.</p>
<h4 id="reimplementing-the-paddle-game-example">Reimplementing the
Paddle Game Example</h4>
<p>Rather than following our incremental computing example (a scene with
changeable parts), we follow our FRP example: a scene behavior.</p>
<p>First we introduce time:</p>
<pre><code>open Froc
let clock, tick = make_event ()
let time = hold (Unix.gettimeofday ()) clock</code></pre>
<p>Next we define integration:</p>
<pre><code>let integral fb =
  let aux (sum, t0) t1 =
    sum +. (t1 -. t0) *. sample fb, t1 in
  collect_b aux (0., sample time) clock</code></pre>
<p>For convenience, the integral remembers the current upper limit of
integration. It will be useful to get the integer part:</p>
<pre><code>let integ_res fb =
  lift (fun (v, _) -&gt; int_of_float v) (integral fb)</code></pre>
<p>We can also define integration in pure style:</p>
<pre><code>let pair fa fb = lift2 (fun x y -&gt; x, y) fa fb

let integral_nice fb =
  let samples = changes (pair fb time) in
  let aux (sum, t0) (fv, t1) =
    sum +. (t1 -. t0) *. fv, t1 in
  collect_b aux (0., sample time) samples</code></pre>
<p>The initial value <code>(0., sample time)</code> is not “inside” the
behavior so <code>sample</code> here does not spoil the pure style.</p>
<h3 id="direct-control">10.7 Direct Control</h3>
<p>Real-world behaviors often are <em>state machines</em>, going through
several stages. We do not have declarative means for it yet. For
example, consider baking recipes: <em>1. Preheat the oven. 2. Put flour,
sugar, eggs into a bowl. 3. Spoon the mixture.</em> etc.</p>
<p>We want a <em>flow</em> to be able to proceed through events: when
the first event arrives we remember its result and wait for the next
event, disregarding any further arrivals of the first event! Therefore
<em>Froc</em> constructs like mapping an event (<code>map</code>) or
attaching a notification to a behavior change
(<code>bind b1 (fun v1 -&gt; notify_b ~now:false b2 (fun v2 -&gt; ...))</code>)
will not work.</p>
<p>We also want to be able to repeat or loop a flow, but starting from
the notification of the first event that happens after the notification
of the last event.</p>
<p><code>next e</code> is an event propagating only the first occurrence
of <code>e</code>. This will be the basis of our <code>await</code>
function.</p>
<p>The whole flow should be cancellable from outside at any time.</p>
<p>A flow is a kind of a <em>lightweight thread</em> as in the end of
Chapter 8; we will make it a monad. It only “stores” a non-unit value
when it <code>await</code>s an event. But it has a primitive to
<code>emit</code> values. We actually implement <em>coarse-grained</em>
threads (Chapter 8 exercise 11), with <code>await</code> in the role of
<code>suspend</code>.</p>
<p>We build a module <code>Flow</code> with monadic type
<code>('a, 'b) flow</code> “storing” <code>'b</code> and emitting
<code>'a</code>:</p>
<pre><code>type (&#39;a, &#39;b) flow
type cancellable  (* A handle to cancel a flow (stop further computation) *)
val noop_flow : (&#39;a, unit) flow  (* Same as return () *)
val return : &#39;b -&gt; (&#39;a, &#39;b) flow  (* Completed flow *)
val await : &#39;b Froc.event -&gt; (&#39;a, &#39;b) flow  (* Wait and store event: *)
val bind :  (* the principled way to input *)
  (&#39;a, &#39;b) flow -&gt; (&#39;b -&gt; (&#39;a, &#39;c) flow) -&gt; (&#39;a, &#39;c) flow
val emit : &#39;a -&gt; (&#39;a, unit) flow  (* The principled way to output *)
val cancel : cancellable -&gt; unit
val repeat :  (* Loop the given flow and store the stop event *)
  ?until:&#39;a Froc.event -&gt; (&#39;b, unit) flow -&gt; (&#39;b, &#39;a) flow
val event_flow :
  (&#39;a, unit) flow -&gt; &#39;a Froc.event * cancellable
val behavior_flow :  (* The initial value of a behavior and a flow to update it *)
  &#39;a -&gt; (&#39;a, unit) flow -&gt; &#39;a Froc.behavior * cancellable
val is_cancelled : cancellable -&gt; bool</code></pre>
<h4 id="implementation-details">Implementation Details</h4>
<p>We follow our (or <em>Lwt</em>) implementation of lightweight
threads, adapting it to the need of cancelling flows:</p>
<pre><code>module F = Froc
type &#39;a result =
  | Return of &#39;a  (* Notifications to cancel when cancelled *)
  | Sleep of (&#39;a -&gt; unit) list * F.cancel ref list
  | Cancelled
  | Link of &#39;a state
and &#39;a state = {mutable state : &#39;a result}
type cancellable = unit state</code></pre>
<p>Functions <code>find</code>, <code>wakeup</code>,
<code>connect</code> are as in Chapter 8 (but connecting to cancelled
thread cancels the other thread).</p>
<p>Our monad is actually a reader monad over the result state. The
reader supplies the <code>emit</code> function:</p>
<pre><code>type (&#39;a, &#39;b) flow = (&#39;a -&gt; unit) -&gt; &#39;b state</code></pre>
<p>The <code>return</code> and <code>bind</code> functions are as in our
lightweight threads, but we need to handle cancelled flows: for
<code>m = bind a b</code>, if <code>a</code> is cancelled then
<code>m</code> is cancelled, and if <code>m</code> is cancelled then we
do not wake up <code>b</code>:</p>
<pre><code>let waiter x =
  if not (is_cancelled m)
  then connect m (b x emit) in
  ...</code></pre>
<p><code>await</code> is implemented like <code>next</code>, but it
wakes up a flow:</p>
<pre><code>let await t = fun emit -&gt;
  let c = ref F.no_cancel in
  let m = {state = Sleep ([], [c])} in
  c :=
    F.notify_e_cancel t begin fun r -&gt;
      F.cancel !c;
      c := F.no_cancel;
      wakeup m r
    end;
  m</code></pre>
<p><code>repeat</code> attaches the whole loop as a waiter for the loop
body.</p>
<h4 id="example-drawing-shapes">Example: Drawing Shapes</h4>
<p>The scene is a list of shapes, the first shape is open:</p>
<pre><code>type scene = (int * int) list list

let draw sc =
  let open Graphics in
  clear_graph ();
  (match sc with
  | [] -&gt; ()
  | opn :: cld -&gt;
    draw_poly_line (Array.of_list opn);
    List.iter (fill_poly -| Array.of_list) cld);
  synchronize ()</code></pre>
<p>We build a flow and turn it into a behavior to animate:</p>
<pre><code>let painter =
  let cld = ref [] in  (* Global state of painter *)
  repeat (perform
      await mbutton_pressed;  (* Start when button down *)
      let opn = ref [] in
      repeat (perform
          mpos &lt;-- await mouse_move;  (* Add next position to line *)
          emit (opn := mpos :: !opn; !opn :: !cld))
        ~until:mbutton_released;  (* Start new shape *)
      emit (cld := !opn :: !cld; opn := []; [] :: !cld))

let painter, cancel_painter = behavior_flow [] painter
let () = reactimate painter</code></pre>
<h4 id="flows-and-state">Flows and State</h4>
<p>Global state and thread-local state can be used with lightweight
threads, but pay attention to semantics – which computations are inside
the monad and which while building the initial monadic value.</p>
<p>Side effects hidden in <code>return</code> and <code>emit</code>
arguments are not inside the monad. For example, if in the “first line”
of a loop effects are executed only at the start of the loop – but if
after bind (“below first line” of a loop), at each step of the loop:</p>
<pre><code>let f =
  repeat (perform
      emit (Printf.printf &quot;[0]\n%!&quot;; &#39;0&#39;);
      () &lt;-- await aas;
      emit (Printf.printf &quot;[1]\n%!&quot;; &#39;1&#39;);
      () &lt;-- await bs;
      emit (Printf.printf &quot;[2]\n%!&quot;; &#39;2&#39;);
      () &lt;-- await cs;
      emit (Printf.printf &quot;[3]\n%!&quot;; &#39;3&#39;);
      () &lt;-- await ds;
      emit (Printf.printf &quot;[4]\n%!&quot;; &#39;4&#39;))

let e, cancel_e = event_flow f
let () =
  F.notify_e e (fun c -&gt; Printf.printf &quot;flow: %c\n%!&quot; c);
  Printf.printf &quot;notification installed\n%!&quot;

let () =
  F.send a (); F.send b (); F.send c (); F.send d ();
  F.send a (); F.send b (); F.send c (); F.send d ()</code></pre>
<p>The output demonstrates the execution order: - <code>[0]</code> –
Only printed once, when building the loop -
<code>notification installed</code> – Only installed after the first
flow event sent - <code>event: a</code> – Event notification -
<code>[1]</code> – Second emit computed after first await returns -
<code>flow: 1</code> – Emitted signal - … and so on through the loop
iterations</p>
<h3 id="graphical-user-interfaces">10.8 Graphical User Interfaces</h3>
<p>In-depth discussion of GUIs is beyond the scope of this course. We
only cover what is needed for an example reactive program with direct
control.</p>
<p>We demonstrate two libraries: <em>LablTk</em> based on optional
labelled arguments (discussed in Chapter 2 exercise 2) and polymorphic
variants, and <em>LablGTk</em> additionally based on objects. We will
learn more about objects and polymorphic variants in the next
chapter.</p>
<h4 id="calculator-flow">Calculator Flow</h4>
<p>We represent the mechanics of the calculator directly as a flow:</p>
<pre><code>let digits, digit = F.make_event ()
let ops, op = F.make_event ()
let dots, dot = F.make_event ()

let calc =
  (* We need two state variables for two arguments of calculation *)
  let f = ref (fun x -&gt; x) and now = ref 0.0 in  (* but we *)
  repeat (perform  (* remember the older argument in partial application *)
      op &lt;-- repeat
        (perform  (* Enter the digits of a number (on later turns *)
            d &lt;-- await digits;  (* starting from the second digit) *)
            emit (now := 10. *. !now +. d; !now))
        ~until:ops;  (* until operator button is pressed *)
      emit (now := !f !now; f := op !now; !now);
      (* Compute the result and &quot;store away&quot; the operator *)
      d &lt;-- repeat
        (perform op &lt;-- await ops; return (f := op !now))
        ~until:digits;  (* The user can pick a different operator *)
      emit (now := d; !now))  (* Reset the state to a new number *)

let calc_e, cancel_calc = event_flow calc  (* Notifies display update *)</code></pre>
<h4 id="tk-labltk">Tk: LablTk</h4>
<p>Widget toolkit <em>Tk</em> is known from the <em>Tcl</em>
language.</p>
<p>Layout of the calculator – common across GUIs:</p>
<pre><code>let layout = [|
  [|&quot;7&quot;, `Di 7.; &quot;8&quot;, `Di 8.; &quot;9&quot;, `Di 9.; &quot;+&quot;, `O (+.)|];
  [|&quot;4&quot;, `Di 4.; &quot;5&quot;, `Di 5.; &quot;6&quot;, `Di 6.; &quot;-&quot;, `O (-.)|];
  [|&quot;1&quot;, `Di 1.; &quot;2&quot;, `Di 2.; &quot;3&quot;, `Di 3.; &quot;*&quot;, `O ( *.)|];
  [|&quot;0&quot;, `Di 0.; &quot;.&quot;, `Dot;   &quot;=&quot;,  `O sk; &quot;/&quot;, `O (/.)|]
|]</code></pre>
<p>Key concepts: - Every <em>widget</em> (window gadget) has a parent in
which it is located - <em>Buttons</em> have action associated with
pressing them, <em>labels</em> just provide information,
<em>entries</em> (aka. <em>edit</em> fields) are for entering info from
keyboard - Actions are <em>callback</em> functions passed as the
<code>~command</code> argument - <em>Frames</em> in <em>Tk</em> group
widgets - The parent is sent as last argument, after optional labelled
arguments</p>
<pre><code>let top = Tk.openTk ()

let btn_frame =
  Frame.create ~relief:`Groove ~borderwidth:2 top

let buttons =
  Array.map (Array.map (function
    | text, `Dot -&gt;
      Button.create ~text
        ~command:(fun () -&gt; F.send dot ()) btn_frame
    | text, `Di d -&gt;
      Button.create ~text
        ~command:(fun () -&gt; F.send digit d) btn_frame
    | text, `O f -&gt;
      Button.create ~text
        ~command:(fun () -&gt; F.send op f) btn_frame)) layout

let result = Label.create ~text:&quot;0&quot; ~relief:`Sunken top</code></pre>
<p>GUI toolkits have layout algorithms, so we only need to tell which
widgets hang together and whether they should fill all available space
etc. – via <code>pack</code>, or <code>grid</code> for “rectangular”
organization:</p>
<ul>
<li><code>~fill:</code> the allocated space in <code>`X</code>,
<code>`Y</code>, <code>`Both</code> or <code>`None</code> axes</li>
<li><code>~expand:</code> maximally how much space is allocated or only
as needed</li>
<li><code>~anchor:</code> allows to glue a widget in particular
direction (<code>`Center</code>, <code>`E</code>, <code>`Ne</code>
etc.)</li>
<li>The <code>grid</code> packing flexibility: <code>~columnspan</code>
and <code>~rowspan</code></li>
<li><code>configure</code> functions accept the same arguments as
<code>create</code> but change existing widgets</li>
</ul>
<pre><code>let () =
  Wm.title_set top &quot;Calculator&quot;;
  Tk.pack [result] ~side:`Top ~fill:`X;
  Tk.pack [btn_frame] ~side:`Bottom ~expand:true;
  Array.iteri (fun column -&gt; Array.iteri (fun row button -&gt;
    Tk.grid ~column ~row [button])) buttons;
  Wm.geometry_set top &quot;200x200&quot;;
  F.notify_e calc_e
    (fun now -&gt;
      Label.configure ~text:(string_of_float now) result);
  Tk.mainLoop ()</code></pre>
<h4 id="gtk-lablgtk">GTk+: LablGTk</h4>
<p><em>LablGTk</em> is built as an object-oriented layer over a
low-level layer of functions interfacing with the <em>GTk+</em> library,
which is written in <em>C</em>.</p>
<p>In OCaml, object fields are only visible to object methods, and
methods are called with <code>#</code> syntax,
e.g. <code>window#show ()</code>.</p>
<p>The interaction with the application is reactive: - Our events are
called signals in <em>GTk+</em> - Registering a notification is called
connecting a signal handler,
e.g. <code>button#connect#clicked ~callback:hello</code> which takes
<code>~callback:(unit -&gt; unit)</code> and returns
<code>GtkSignal.id</code> - As with <em>Froc</em> notifications,
multiple handlers can be attached - <em>GTk+</em> events are a subclass
of signals related to more specific window events,
e.g. <code>window#event#connect#delete ~callback:delete_event</code> -
<em>GTk+</em> event callbacks take more info:
<code>~callback:(event -&gt; unit)</code> for some type
<code>event</code></p>
<p>Automatic layout (aka. packing) seems less sophisticated than in
<em>Tk</em>: - only horizontal and vertical boxes - therefore
<code>~fill</code> is binary and <code>~anchor</code> is replaced by
<code>~from</code> <code>`START</code> or <code>`END</code></p>
<p>Automatic grid layout is called <code>table</code>: -
<code>~fill</code> and <code>~expand</code> take <code>`X</code>,
<code>`Y</code>, <code>`BOTH</code>, <code>`NONE</code></p>
<p>The <code>coerce</code> method casts the type of the object (in
<em>Tk</em> there is <code>coe</code> function). Labels do not have a
dedicated module. Widgets have setter methods <code>widget#set_X</code>
(instead of a single <code>configure</code> function in
<em>Tk</em>).</p>
<p>Setup:</p>
<pre><code>let _ = GtkMain.Main.init ()
let window =
  GWindow.window ~width:200 ~height:200 ~title:&quot;Calculator&quot; ()
let top = GPack.vbox ~packing:window#add ()
let result = GMisc.label ~text:&quot;0&quot; ~packing:top#add ()
let btn_frame =
  GPack.table ~rows:(Array.length layout)
   ~columns:(Array.length layout.(0)) ~packing:top#add ()</code></pre>
<p>Button actions:</p>
<pre><code>let buttons =
  Array.map (Array.map (function
    | label, `Dot -&gt;
      let b = GButton.button ~label () in
      let _ = b#connect#clicked
        ~callback:(fun () -&gt; F.send dot ()) in b
    | label, `Di d -&gt;
      let b = GButton.button ~label () in
      let _ = b#connect#clicked
        ~callback:(fun () -&gt; F.send digit d) in b
    | label, `O f -&gt;
      let b = GButton.button ~label () in
      let _ = b#connect#clicked
        ~callback:(fun () -&gt; F.send op f) in b)) layout</code></pre>
<p>Button layout, result notification, start application:</p>
<pre><code>let delete_event _ = GMain.Main.quit (); false

let () =
  let _ = window#event#connect#delete ~callback:delete_event in
  Array.iteri (fun column -&gt; Array.iteri (fun row button -&gt;
    btn_frame#attach ~left:column ~top:row
      ~fill:`BOTH ~expand:`BOTH (button#coerce))
  ) buttons;
  F.notify_e calc_e
    (fun now -&gt; result#set_label (string_of_float now));
  window#show ();
  GMain.Main.main ()</code></pre>
<h3 id="exercises-9">10.9 Exercises</h3>
<p><strong>Exercise 1:</strong> Introduce operators <span
class="math inline">-, /</span> into the context rewriting “pull out
subexpression” example. Remember that they are not commutative.</p>
<p><strong>Exercise 2:</strong> Add to the <em>paddle game</em> example:
1. game restart, 2. score keeping, 3. game quitting (in more-or-less
elegant way).</p>
<p><strong>Exercise 3:</strong> Our numerical integration function
roughly corresponds to the rectangle rule. Modify the rule and write a
test for the accuracy of: 1. the trapezoidal rule; 2. the Simpson’s
rule. See http://en.wikipedia.org/wiki/Simpson%27s_rule</p>
<p><strong>Exercise 4:</strong> Explain the recursive behavior of
integration: 1. In <em>paddle game</em> implemented by stream processing
(<code>Lec10b.ml</code>), do we look at past velocity to determine
current position, at past position to determine current velocity, both,
or neither? 2. What is the difference between <code>integral</code> and
<code>integral_nice</code> in <code>Lec10c.ml</code>, what happens when
we replace the former with the latter in the <code>pbal</code> function?
How about after rewriting <code>pbal</code> into pure style as in the
following exercise?</p>
<p><strong>Exercise 5:</strong> Reimplement the <em>Froc</em> based
paddle ball example in a pure style: rewrite the <code>pbal</code>
function to not use <code>notify_e</code>.</p>
<p><strong>Exercise 6:</strong> Our implementation of flows is a bit
heavy. One alternative approach is to use continuations, as in
<code>Scala.React</code>. OCaml has a continuations library
<em>Delimcc</em>; for how it can cooperate with <em>Froc</em>, see
http://ambassadortothecomputers.blogspot.com/2010/08/mixing-monadic-and-direct-style-code.html</p>
<p><strong>Exercise 7:</strong> Implement <code>parallel</code> for
flows, retaining coarse-grained implementation and using the event queue
from <em>Froc</em> somehow (instead of introducing a new job queue).</p>
<p><strong>Exercise 8:</strong> Add quitting, e.g. via a
<code>'q'</code> key press, to the <em>painter</em> example. Use the
<code>is_cancelled</code> function.</p>
<p><strong>Exercise 9:</strong> Our calculator example is not finished.
Implement entering decimal fractions: add handling of the
<code>dots</code> event.</p>
<p><strong>Exercise 10:</strong> The Flow module has reader monad
functions that have not been discussed in this chapter:</p>
<pre><code>let local f m = fun emit -&gt; m (fun x -&gt; emit (f x))
let local_opt f m = fun emit -&gt;
  m (fun x -&gt; match f x with None -&gt; () | Some y -&gt; emit y)

val local : (&#39;a -&gt; &#39;b) -&gt; (&#39;a, &#39;c) flow -&gt; (&#39;b, &#39;c) flow
val local_opt : (&#39;a -&gt; &#39;b option) -&gt; (&#39;a, &#39;c) flow -&gt; (&#39;b, &#39;c) flow</code></pre>
<p>Implement an example that uses this compositionality-increasing
capability.</p>
<h2 id="chapter-11-the-expression-problem">Chapter 11: The Expression
Problem</h2>
<p>This chapter explores <strong>the expression problem</strong>, a
classic challenge in software engineering that addresses how to design
systems that can be extended with both new data variants and new
operations without modifying existing code, while maintaining static
type safety. We examine multiple approaches in OCaml, ranging from
algebraic data types through object-oriented programming to polymorphic
variants with recursive modules. The chapter concludes with an
application to parser combinators and dynamic code loading.</p>
<h3 id="the-expression-problem-definition">11.1 The Expression Problem:
Definition</h3>
<p>The <strong>Expression Problem</strong> concerns the design of an
implementation for expressions where:</p>
<ul>
<li><strong>Datatype extensibility</strong>: New variants of expressions
can be added</li>
<li><strong>Functional extensibility</strong>: New operations on
expressions can be added</li>
</ul>
<p>By <em>extensibility</em> we mean three conditions:</p>
<ol type="1">
<li><strong>Code-level modularization</strong>: The new datatype
variants and new operations are in separate files</li>
<li><strong>Separate compilation</strong>: The files can be compiled and
distributed separately</li>
<li><strong>Static type safety</strong>: We do not lose type checking
help and guarantees</li>
</ol>
<p>The name comes from a classic example: extending a language of
expressions with new constructs. Consider two sub-languages:</p>
<ul>
<li><strong>Lambda calculus</strong>: variables <code>Var</code>, <span
class="math inline">\lambda</span>-abstractions <code>Abs</code>,
function applications <code>App</code></li>
<li><strong>Arithmetic</strong>: variables <code>Var</code>, constants
<code>Num</code>, addition <code>Add</code>, multiplication
<code>Mult</code></li>
</ul>
<p>And operations we want to support:</p>
<ul>
<li>Evaluation <code>eval</code></li>
<li>Pretty-printing to strings <code>string_of</code></li>
<li>Free variables computation <code>free_vars</code></li>
</ul>
<p>The challenge is to combine these sub-languages and add new
operations without breaking existing code or sacrificing type
safety.</p>
<h4 id="references">References</h4>
<ul>
<li>Ralf Lammel lectures on MSDN’s Channel 9: <a
href="http://channel9.msdn.com/Shows/Going+Deep/C9-Lectures-Dr-Ralf-Laemmel-Advanced-Functional-Programming-The-Expression-Problem">The
Expression Problem</a>, <a
href="http://channel9.msdn.com/Shows/Going+Deep/C9-Lectures-Dr-Ralf-Lmmel-Advanced-Functional-Programming-Type-Classes">Haskell’s
Type Classes</a></li>
<li>The book <em>Developing Applications with Objective Caml</em>: <a
href="http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora153.html">Comparison
of Modules and Objects</a>, <a
href="http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora154.html">Extending
Components</a></li>
<li><em>Real World OCaml</em>: <a
href="https://realworldocaml.org/v1/en/html/objects.html">Chapter 11:
Objects</a>, <a
href="https://realworldocaml.org/v1/en/html/classes.html">Chapter 12:
Classes</a></li>
<li>Jacques Garrigue’s <a
href="http://www.math.nagoya-u.ac.jp/~garrigue/papers/variant-reuse.ps.gz">Code
reuse through polymorphic variants</a>, and <a
href="http://www.math.nagoya-u.ac.jp/~garrigue/papers/nakata-icfp2006.pdf">Recursive
Modules for Programming</a> with Keiko Nakata</li>
<li><a
href="http://caml.inria.fr/pub/docs/manual-ocaml/extn.html#sec246">Extensible
variant types</a></li>
<li>Graham Hutton’s and Erik Meijer’s <a
href="https://www.cs.nott.ac.uk/~gmh/monparsing.pdf">Monadic Parser
Combinators</a></li>
</ul>
<h3
id="functional-programming-non-solution-ordinary-algebraic-datatypes">11.2
Functional Programming Non-Solution: Ordinary Algebraic Datatypes</h3>
<p>Pattern matching makes <strong>functional extensibility</strong> easy
in functional programming. However, ensuring <strong>datatype
extensibility</strong> is complicated when using standard variant
types.</p>
<p>For brevity, we place examples in a single file, but the component
type and function definitions are not mutually recursive, so they can be
put in separate modules.</p>
<p><strong>Non-solution penalty points:</strong></p>
<ul>
<li>Functions implemented for a broader language (e.g.,
<code>lexpr_t</code>) cannot be used with a value from a narrower
language (e.g., <code>expr_t</code>)</li>
<li>Significant memory (and some time) overhead due to <em>tagging</em>:
the work of <code>wrap</code> and <code>unwrap</code> functions, adding
tags such as <code>Lambda</code> and <code>Expr</code></li>
<li>Some code bloat due to tagging. For example, deep pattern matching
needs to be manually unrolled and interspersed with calls to
<code>unwrap</code></li>
</ul>
<p><strong>Verdict:</strong> Non-solution, but better than extensible
variant types-based approach and direct OOP approach.</p>
<p>Here is the implementation:</p>
<pre><code>type var = string  (* Variables constitute a sub-language of its own *)
                   (* We treat this sub-language slightly differently -- no need for a dedicated variant *)

let eval_var wrap sub (s : var) =
  try List.assoc s sub with Not_found -&gt; wrap s

type &#39;a lambda =  (* Here we define the sub-language of lambda-expressions *)
  VarL of var | Abs of string * &#39;a | App of &#39;a * &#39;a

(* During evaluation, we need to freshen variables to avoid capture *)
(* (mistaking distinct variables with the same name) *)
let gensym = let n = ref 0 in fun () -&gt; incr n; &quot;_&quot; ^ string_of_int !n

let eval_lambda eval_rec wrap unwrap subst e =
  match unwrap e with  (* Alternatively, unwrapping could use an exception *)
  | Some (VarL v) -&gt; eval_var (fun v -&gt; wrap (VarL v)) subst v
  | Some (App (l1, l2)) -&gt;  (* but we use the option type as it is safer *)
    let l1&#39; = eval_rec subst l1  (* and more flexible in this context *)
    and l2&#39; = eval_rec subst l2 in  (* Recursive processing function returns expression *)
    (match unwrap l1&#39; with  (* of the completed language, we need *)
    | Some (Abs (s, body)) -&gt;  (* to unwrap it into the current sub-language *)
      eval_rec [s, l2&#39;] body  (* The recursive call is already wrapped *)
    | _ -&gt; wrap (App (l1&#39;, l2&#39;)))  (* Wrap into the completed language *)
  | Some (Abs (s, l1)) -&gt;
    let s&#39; = gensym () in  (* Rename variable to avoid capture (alpha-equivalence) *)
    wrap (Abs (s&#39;, eval_rec ((s, wrap (VarL s&#39;))::subst) l1))
  | None -&gt; e  (* Falling-through when not in the current sub-language *)

type lambda_t = Lambda_t of lambda_t lambda  (* Defining lambda-expressions as the completed language *)

let rec eval1 subst =  (* and the corresponding eval function *)
  eval_lambda eval1
    (fun e -&gt; Lambda_t e) (fun (Lambda_t e) -&gt; Some e) subst</code></pre>
<p>Now we define the arithmetic sub-language:</p>
<pre><code>type &#39;a expr =  (* The sub-language of arithmetic expressions *)
  VarE of var | Num of int | Add of &#39;a * &#39;a | Mult of &#39;a * &#39;a

let eval_expr eval_rec wrap unwrap subst e =
  match unwrap e with
  | Some (Num _) -&gt; e
  | Some (VarE v) -&gt;
    eval_var (fun x -&gt; wrap (VarE x)) subst v
  | Some (Add (m, n)) -&gt;
    let m&#39; = eval_rec subst m
    and n&#39; = eval_rec subst n in
    (match unwrap m&#39;, unwrap n&#39; with  (* Unwrapping to check if the subexpressions *)
    | Some (Num m&#39;), Some (Num n&#39;) -&gt;  (* got computed to values *)
      wrap (Num (m&#39; + n&#39;))
    | _ -&gt; wrap (Add (m&#39;, n&#39;)))  (* Here m&#39; and n&#39; are wrapped *)
  | Some (Mult (m, n)) -&gt;
    let m&#39; = eval_rec subst m
    and n&#39; = eval_rec subst n in
    (match unwrap m&#39;, unwrap n&#39; with
    | Some (Num m&#39;), Some (Num n&#39;) -&gt;
      wrap (Num (m&#39; * n&#39;))
    | _ -&gt; wrap (Mult (m&#39;, n&#39;)))
  | None -&gt; e

type expr_t = Expr_t of expr_t expr  (* Defining arithmetic expressions as the completed language *)

let rec eval2 subst =  (* aka &quot;tying the recursive knot&quot; *)
  eval_expr eval2
    (fun e -&gt; Expr_t e) (fun (Expr_t e) -&gt; Some e) subst</code></pre>
<p>Finally, we merge the two sub-languages:</p>
<pre><code>type &#39;a lexpr =  (* The language merging lambda-expressions and arithmetic expressions *)
  Lambda of &#39;a lambda | Expr of &#39;a expr  (* can also be used as a sub-language for further extensions *)

let eval_lexpr eval_rec wrap unwrap subst e =
  eval_lambda eval_rec
    (fun e -&gt; wrap (Lambda e))
    (fun e -&gt;
      match unwrap e with
      | Some (Lambda e) -&gt; Some e
      | _ -&gt; None)
    subst
    (eval_expr eval_rec  (* We use the &quot;fall-through&quot; property of eval_expr *)
       (fun e -&gt; wrap (Expr e))  (* to combine the evaluators *)
       (fun e -&gt;
         match unwrap e with
         | Some (Expr e) -&gt; Some e
         | _ -&gt; None)
       subst e)

type lexpr_t = LExpr_t of lexpr_t lexpr  (* Tying the recursive knot one last time *)

let rec eval3 subst =
  eval_lexpr eval3
    (fun e -&gt; LExpr_t e)
    (fun (LExpr_t e) -&gt; Some e) subst</code></pre>
<h3 id="lightweight-fp-non-solution-extensible-variant-types">11.3
Lightweight FP Non-Solution: Extensible Variant Types</h3>
<p>Exceptions have always formed an extensible variant type in OCaml,
whose pattern matching is done using the <code>try...with</code> syntax.
Since recently, new extensible variant types can be defined. This
augments the normal function extensibility of FP with straightforward
data extensibility.</p>
<p><strong>Non-solution penalty points:</strong></p>
<ul>
<li>Giving up exhaustivity checking, which is an important aspect of
static type safety</li>
<li>More natural with “single inheritance” extension chains, although
merging is possible and demonstrated in our example</li>
<li>Requires “tying the recursive knot” for functions</li>
</ul>
<p><strong>Verdict:</strong> Pleasant-looking, but the worst approach
because of possible bugginess. Unless bug-proneness is not a concern,
then the best approach.</p>
<pre><code>type expr = ..  (* This is how extensible variant types are defined *)

type var_name = string
type expr += Var of string  (* We add a variant case *)

let eval_var sub = function
  | Var s as v -&gt; (try List.assoc s sub with Not_found -&gt; v)
  | e -&gt; e

let gensym = let n = ref 0 in fun () -&gt; incr n; &quot;_&quot; ^ string_of_int !n

type expr += Abs of string * expr | App of expr * expr
(* The sub-languages are not differentiated by types, a shortcoming of this non-solution *)

let eval_lambda eval_rec subst = function
  | Var _ as v -&gt; eval_var subst v
  | App (l1, l2) -&gt;
    let l2&#39; = eval_rec subst l2 in
    (match eval_rec subst l1 with
    | Abs (s, body) -&gt;
      eval_rec [s, l2&#39;] body
    | l1&#39; -&gt; App (l1&#39;, l2&#39;))
  | Abs (s, l1) -&gt;
    let s&#39; = gensym () in
    Abs (s&#39;, eval_rec ((s, Var s&#39;)::subst) l1)
  | e -&gt; e

let freevars_lambda freevars_rec = function
  | Var v -&gt; [v]
  | App (l1, l2) -&gt; freevars_rec l1 @ freevars_rec l2
  | Abs (s, l1) -&gt;
    List.filter (fun v -&gt; v &lt;&gt; s) (freevars_rec l1)
  | _ -&gt; []

let rec eval1 subst e = eval_lambda eval1 subst e
let rec freevars1 e = freevars_lambda freevars1 e

let test1 = App (Abs (&quot;x&quot;, Var &quot;x&quot;), Var &quot;y&quot;)
let e_test = eval1 [] test1
let fv_test = freevars1 test1</code></pre>
<p>Now we extend with arithmetic:</p>
<pre><code>type expr += Num of int | Add of expr * expr | Mult of expr * expr

let map_expr f = function
  | Add (e1, e2) -&gt; Add (f e1, f e2)
  | Mult (e1, e2) -&gt; Mult (f e1, f e2)
  | e -&gt; e

let eval_expr eval_rec subst e =
  match map_expr (eval_rec subst) e with
  | Add (Num m, Num n) -&gt; Num (m + n)
  | Mult (Num m, Num n) -&gt; Num (m * n)
  | (Num _ | Add _ | Mult _) as e -&gt; e
  | e -&gt; e

let freevars_expr freevars_rec = function
  | Num _ -&gt; []
  | Add (e1, e2) | Mult (e1, e2) -&gt; freevars_rec e1 @ freevars_rec e2
  | _ -&gt; []

let rec eval2 subst e = eval_expr eval2 subst e
let rec freevars2 e = freevars_expr freevars2 e

let test2 = Add (Mult (Num 3, Var &quot;x&quot;), Num 1)
let e_test2 = eval2 [] test2
let fv_test2 = freevars2 test2</code></pre>
<p>Merging the sub-languages:</p>
<pre><code>let eval_lexpr eval_rec subst e =
  eval_expr eval_rec subst (eval_lambda eval_rec subst e)

let freevars_lexpr freevars_rec e =
  freevars_lambda freevars_rec e @ freevars_expr freevars_rec e

let rec eval3 subst e = eval_lexpr eval3 subst e
let rec freevars3 e = freevars_lexpr freevars3 e

let test3 =
  App (Abs (&quot;x&quot;, Add (Mult (Num 3, Var &quot;x&quot;), Num 1)),
       Num 2)
let e_test3 = eval3 [] test3
let fv_test3 = freevars3 test3</code></pre>
<h3 id="object-oriented-programming-subtyping">11.4 Object-Oriented
Programming: Subtyping</h3>
<p>OCaml’s <strong>objects</strong> are values, somewhat similar to
records. Viewed from the outside, an OCaml object has only
<strong>methods</strong>, identifying the code with which to respond to
messages (method invocations). All methods are
<strong>late-bound</strong>; the object determines what code is run
(i.e., <em>virtual</em> in C++ parlance).</p>
<p><strong>Subtyping</strong> determines if an object can be used in
some context. OCaml has <strong>structural subtyping</strong>: the
content of the types concerned decides if an object can be used.
Parametric polymorphism can be used to infer if an object has the
required methods.</p>
<pre><code>let f x = x#m  (* Method invocation: object#method *)
(* val f : &lt; m : &#39;a; .. &gt; -&gt; &#39;a *)
(* Type polymorphic in two ways: &#39;a is the method type, *)
(* .. means that objects with more methods will be accepted *)</code></pre>
<p>Methods are computed when they are invoked, even if they do not take
arguments. We define objects inside <code>object...end</code> (compare:
records <code>{...}</code>) using keywords:</p>
<ul>
<li><code>method</code> for methods</li>
<li><code>val</code> for constant fields</li>
<li><code>val mutable</code> for mutable fields</li>
</ul>
<p>Constructor arguments can often be used instead of constant
fields:</p>
<pre><code>let square w = object
  method area = float_of_int (w * w)
  method width = w
end</code></pre>
<p>Subtyping often needs to be explicit: we write
<code>(object :&gt; supertype)</code> or in more complex cases
<code>(object : type :&gt; supertype)</code>.</p>
<p>Technically speaking, subtyping in OCaml always is explicit, and
<em>open types</em>, containing <code>..</code>, use <strong>row
polymorphism</strong> rather than subtyping.</p>
<pre><code>let a = object method m = 7  method x = &quot;a&quot; end  (* Toy example: object types *)
let b = object method m = 42 method y = &quot;b&quot; end  (* share some but not all methods *)

(* let l = [a; b]  -- Error: the exact types of the objects do not agree *)
(* Error: This expression has type &lt; m : int; y : string &gt;
         but an expression was expected of type &lt; m : int; x : string &gt;
         The second object type has no method y *)

let l = [(a :&gt; &lt;m : &#39;a&gt;); (b :&gt; &lt;m : &#39;a&gt;)]  (* But the types share a supertype *)
(* val l : &lt; m : int &gt; list *)</code></pre>
<h3 id="direct-object-oriented-non-solution">11.5 Direct Object-Oriented
Non-Solution</h3>
<p>We can try to solve the expression problem using objects directly.
However, adding new functionality still requires modifying old code, so
this approach does not fully solve the expression problem.</p>
<p><strong>Non-solution penalty points:</strong></p>
<ul>
<li>No way to add functionality without modifying old code (in
particular, the abstract class and all concrete classes)</li>
<li>No deep pattern matching</li>
</ul>
<p><strong>Verdict:</strong> Non-solution, and probably the worst
approach.</p>
<p>Here is an implementation using objects:</p>
<pre><code>type var_name = string

let gensym = let n = ref 0 in fun () -&gt; incr n; &quot;_&quot; ^ string_of_int !n

class virtual [&#39;lang] evaluable =
object
  method virtual eval : (var_name * &#39;lang) list -&gt; &#39;lang
  method virtual rename : var_name -&gt; var_name -&gt; &#39;lang
  method apply (_arg : &#39;lang)
    (fallback : unit -&gt; &#39;lang) (_subst : (var_name * &#39;lang) list) =
    fallback ()
end

class [&#39;lang] var (v : var_name) =
object (self)
  inherit [&#39;lang] evaluable
  val v = v
  method eval subst =
    try List.assoc v subst with Not_found -&gt; self
  method rename v1 v2 =
    if v = v1 then {&lt; v = v2 &gt;} else self
end

class [&#39;lang] abs (v : var_name) (body : &#39;lang) =
object (self)
  inherit [&#39;lang] evaluable
  val v = v
  val body = body
  method eval subst =
    let v&#39; = gensym () in
    {&lt; v = v&#39;; body = (body#rename v v&#39;)#eval subst &gt;}
  method rename v1 v2 =
    if v = v1 then self
    else {&lt; body = body#rename v1 v2 &gt;}
  method apply arg _ subst =
    body#eval ((v, arg)::subst)
end

class [&#39;lang] app (f : &#39;lang) (arg : &#39;lang) =
object (self)
  inherit [&#39;lang] evaluable
  val f = f
  val arg = arg
  method eval subst =
    let arg&#39; = arg#eval subst in
    f#apply arg&#39; (fun () -&gt; {&lt; f = f#eval subst; arg = arg&#39; &gt;}) subst
  method rename v1 v2 =
    {&lt; f = f#rename v1 v2; arg = arg#rename v1 v2 &gt;}
end

type evaluable_t = evaluable_t evaluable
let new_var1 v : evaluable_t = new var v
let new_abs1 v (body : evaluable_t) : evaluable_t = new abs v body
let new_app1 (arg1 : evaluable_t) (arg2 : evaluable_t) : evaluable_t =
  new app arg1 arg2

let test1 = new_app1 (new_abs1 &quot;x&quot; (new_var1 &quot;x&quot;)) (new_var1 &quot;y&quot;)
let e_test1 = test1#eval []</code></pre>
<p>Extending with arithmetic requires additional mixins:</p>
<pre><code>class virtual compute_mixin = object
  method compute : int option = None
end

class [&#39;lang] var_c v = object
  inherit [&#39;lang] var v
  inherit compute_mixin
end

class [&#39;lang] abs_c v body = object
  inherit [&#39;lang] abs v body
  inherit compute_mixin
end

class [&#39;lang] app_c f arg = object
  inherit [&#39;lang] app f arg
  inherit compute_mixin
end

class [&#39;lang] num (i : int) =
object (self)
  inherit [&#39;lang] evaluable
  val i = i
  method eval _subst = self
  method rename _ _ = self
  method compute = Some i
end

class virtual [&#39;lang] operation
    (num_inst : int -&gt; &#39;lang) (n1 : &#39;lang) (n2 : &#39;lang) =
object (self)
  inherit [&#39;lang] evaluable
  val n1 = n1
  val n2 = n2
  method eval subst =
    let self&#39; = {&lt; n1 = n1#eval subst; n2 = n2#eval subst &gt;} in
    match self&#39;#compute with
    | Some i -&gt; num_inst i
    | _ -&gt; self&#39;
  method rename v1 v2 = {&lt; n1 = n1#rename v1 v2; n2 = n2#rename v1 v2 &gt;}
end

class [&#39;lang] add num_inst n1 n2 =
object (self)
  inherit [&#39;lang] operation num_inst n1 n2
  method compute =
    match n1#compute, n2#compute with
    | Some i1, Some i2 -&gt; Some (i1 + i2)
    | _ -&gt; None
end

class [&#39;lang] mult num_inst n1 n2 =
object (self)
  inherit [&#39;lang] operation num_inst n1 n2
  method compute =
    match n1#compute, n2#compute with
    | Some i1, Some i2 -&gt; Some (i1 * i2)
    | _ -&gt; None
end

class virtual [&#39;lang] computable =
object
  inherit [&#39;lang] evaluable
  inherit compute_mixin
end

type computable_t = computable_t computable
let new_var2 v : computable_t = new var_c v
let new_abs2 v (body : computable_t) : computable_t = new abs_c v body
let new_app2 v (body : computable_t) : computable_t = new app_c v body
let new_num2 i : computable_t = new num i
let new_add2 (n1 : computable_t) (n2 : computable_t) : computable_t =
  new add new_num2 n1 n2
let new_mult2 (n1 : computable_t) (n2 : computable_t) : computable_t =
  new mult new_num2 n1 n2

let test2 =
  new_app2 (new_abs2 &quot;x&quot; (new_add2 (new_mult2 (new_num2 3) (new_var2 &quot;x&quot;))
                            (new_num2 1)))
    (new_num2 2)
let e_test2 = test2#eval []</code></pre>
<h3 id="oop-non-solution-the-visitor-pattern">11.6 OOP Non-Solution: The
Visitor Pattern</h3>
<p>The <strong>visitor pattern</strong> is a design pattern that
separates an algorithm from the object structure on which it operates.
This allows adding new operations to existing object structures without
modifying those structures.</p>
<p><strong>Non-solution penalty points:</strong></p>
<ul>
<li>Adding new functionality requires modifying old code (the abstract
visitor class)</li>
<li>No deep pattern matching</li>
<li>Uses mutable state for returning results</li>
</ul>
<p><strong>Verdict:</strong> Poor solution, better than approaches we
considered so far, and worse than approaches we consider next.</p>
<pre><code>type &#39;visitor visitable = &lt; accept : &#39;visitor -&gt; unit &gt;
(* The variants need be visitable *)
(* We store the computation as side effect because of the difficulty *)
(* to keep the visitor polymorphic but have the result type depend on the visitor *)

type var_name = string

class [&#39;visitor] var (v : var_name) =
object (self)  (* The &#39;visitor will determine the (sub)language *)
               (* to which a given var variant belongs *)
  method v = v
  method accept : &#39;visitor -&gt; unit =  (* The visitor pattern inverts the way *)
    fun visitor -&gt; visitor#visitVar self  (* pattern matching proceeds: the variant *)
end  (* selects the computation *)
let new_var v = (new var v :&gt; &#39;a visitable)

class [&#39;visitor] abs (v : var_name) (body : &#39;visitor visitable) =
object (self)
  method v = v
  method body = body
  method accept : &#39;visitor -&gt; unit =
    fun visitor -&gt; visitor#visitAbs self
end
let new_abs v body = (new abs v body :&gt; &#39;a visitable)

class [&#39;visitor] app (f : &#39;visitor visitable) (arg : &#39;visitor visitable) =
object (self)
  method f = f
  method arg = arg
  method accept : &#39;visitor -&gt; unit =
    fun visitor -&gt; visitor#visitApp self
end
let new_app f arg = (new app f arg :&gt; &#39;a visitable)

class virtual [&#39;visitor] lambda_visit =
object
  method virtual visitVar : &#39;visitor var -&gt; unit
  method virtual visitAbs : &#39;visitor abs -&gt; unit
  method virtual visitApp : &#39;visitor app -&gt; unit
end

let gensym = let n = ref 0 in fun () -&gt; incr n; &quot;_&quot; ^ string_of_int !n

class [&#39;visitor] eval_lambda
  (subst : (var_name * &#39;visitor visitable) list)
  (result : &#39;visitor visitable ref) =
object (self)
  inherit [&#39;visitor] lambda_visit
  val mutable subst = subst
  val mutable beta_redex : (var_name * &#39;visitor visitable) option = None
  method visitVar var =
    beta_redex &lt;- None;
    try result := List.assoc var#v subst
    with Not_found -&gt; result := (var :&gt; &#39;visitor visitable)
  method visitAbs abs =
    let v&#39; = gensym () in
    let orig_subst = subst in
    subst &lt;- (abs#v, new_var v&#39;)::subst;
    (abs#body)#accept self;
    let body&#39; = !result in
    subst &lt;- orig_subst;
    beta_redex &lt;- Some (v&#39;, body&#39;);
    result := new_abs v&#39; body&#39;
  method visitApp app =
    app#arg#accept self;
    let arg&#39; = !result in
    app#f#accept self;
    let f&#39; = !result in
    match beta_redex with
    | Some (v&#39;, body&#39;) -&gt;
      beta_redex &lt;- None;
      let orig_subst = subst in
      subst &lt;- (v&#39;, arg&#39;)::subst;
      body&#39;#accept self;
      subst &lt;- orig_subst
    | None -&gt; result := new_app f&#39; arg&#39;
end

class [&#39;visitor] freevars_lambda (result : var_name list ref) =
object (self)
  inherit [&#39;visitor] lambda_visit
  method visitVar var =
    result := var#v :: !result
  method visitAbs abs =
    (abs#body)#accept self;
    result := List.filter (fun v&#39; -&gt; v&#39; &lt;&gt; abs#v) !result
  method visitApp app =
    app#arg#accept self; app#f#accept self
end

type lambda_visit_t = lambda_visit_t lambda_visit
type lambda_t = lambda_visit_t visitable

let eval1 (e : lambda_t) subst : lambda_t =
  let result = ref (new_var &quot;&quot;) in
  e#accept (new eval_lambda subst result :&gt; lambda_visit_t);
  !result

let freevars1 (e : lambda_t) =
  let result = ref [] in
  e#accept (new freevars_lambda result);
  !result

let test1 =
  (new_app (new_abs &quot;x&quot; (new_var &quot;x&quot;)) (new_var &quot;y&quot;) :&gt; lambda_t)
let e_test = eval1 test1 []
let fv_test = freevars1 test1</code></pre>
<p>Extending with arithmetic expressions follows a similar pattern, and
the merged language visitor inherits from both <code>lambda_visit</code>
and <code>expr_visit</code>.</p>
<h3 id="polymorphic-variants">11.7 Polymorphic Variants</h3>
<p><strong>Polymorphic variants</strong> provide a flexible alternative
to standard variants. They allow combining types from different sources
without explicitly defining a common parent type.</p>
<p><strong>Penalty points:</strong></p>
<ul>
<li>Requires explicit type annotations more often</li>
<li>Requires “tying the recursive knots” for types, e.g.,
<code>type lambda_t = lambda_t lambda</code></li>
<li>Some loss of type-level distinction between sub-languages</li>
</ul>
<p><strong>Verdict:</strong> A flexible solution, better than the
previous approaches but still not perfect.</p>
<pre><code>type var = [`Var of string]

let eval_var sub (`Var s as v : var) =
  try List.assoc s sub with Not_found -&gt; v

type &#39;a lambda =
  [`Var of string | `Abs of string * &#39;a | `App of &#39;a * &#39;a]

let gensym = let n = ref 0 in fun () -&gt; incr n; &quot;_&quot; ^ string_of_int !n

let eval_lambda eval_rec subst : &#39;a lambda -&gt; &#39;a = function
  | #var as v -&gt; eval_var subst v
  | `App (l1, l2) -&gt;
    let l2&#39; = eval_rec subst l2 in
    (match eval_rec subst l1 with
    | `Abs (s, body) -&gt;
      eval_rec [s, l2&#39;] body
    | l1&#39; -&gt; `App (l1&#39;, l2&#39;))
  | `Abs (s, l1) -&gt;
    let s&#39; = gensym () in
    `Abs (s&#39;, eval_rec ((s, `Var s&#39;)::subst) l1)

let freevars_lambda freevars_rec : &#39;a lambda -&gt; &#39;b = function
  | `Var v -&gt; [v]
  | `App (l1, l2) -&gt; freevars_rec l1 @ freevars_rec l2
  | `Abs (s, l1) -&gt;
    List.filter (fun v -&gt; v &lt;&gt; s) (freevars_rec l1)

type lambda_t = lambda_t lambda

let rec eval1 subst e : lambda_t = eval_lambda eval1 subst e
let rec freevars1 (e : lambda_t) = freevars_lambda freevars1 e

let test1 = (`App (`Abs (&quot;x&quot;, `Var &quot;x&quot;), `Var &quot;y&quot;) :&gt; lambda_t)
let e_test = eval1 [] test1
let fv_test = freevars1 test1</code></pre>
<p>The arithmetic expression sub-language:</p>
<pre><code>type &#39;a expr =
  [`Var of string | `Num of int | `Add of &#39;a * &#39;a | `Mult of &#39;a * &#39;a]

let map_expr (f : _ -&gt; &#39;a) : &#39;a expr -&gt; &#39;a = function
  | #var as v -&gt; v
  | `Num _ as n -&gt; n
  | `Add (e1, e2) -&gt; `Add (f e1, f e2)
  | `Mult (e1, e2) -&gt; `Mult (f e1, f e2)

let eval_expr eval_rec subst (e : &#39;a expr) : &#39;a =
  match map_expr (eval_rec subst) e with
  | #var as v -&gt; eval_var subst v
  | `Add (`Num m, `Num n) -&gt; `Num (m + n)
  | `Mult (`Num m, `Num n) -&gt; `Num (m * n)
  | e -&gt; e

let freevars_expr freevars_rec : &#39;a expr -&gt; &#39;b = function
  | `Var v -&gt; [v]
  | `Num _ -&gt; []
  | `Add (e1, e2) | `Mult (e1, e2) -&gt; freevars_rec e1 @ freevars_rec e2

type expr_t = expr_t expr

let rec eval2 subst e : expr_t = eval_expr eval2 subst e
let rec freevars2 (e : expr_t) = freevars_expr freevars2 e

let test2 = (`Add (`Mult (`Num 3, `Var &quot;x&quot;), `Num 1) : expr_t)
let e_test2 = eval2 [&quot;x&quot;, `Num 2] test2
let fv_test2 = freevars2 test2</code></pre>
<p>Merging the sub-languages:</p>
<pre><code>type &#39;a lexpr = [&#39;a lambda | &#39;a expr]

let eval_lexpr eval_rec subst : &#39;a lexpr -&gt; &#39;a = function
  | #lambda as x -&gt; eval_lambda eval_rec subst x
  | #expr as x -&gt; eval_expr eval_rec subst x

let freevars_lexpr freevars_rec : &#39;a lexpr -&gt; &#39;b = function
  | #lambda as x -&gt; freevars_lambda freevars_rec x
  | #expr as x -&gt; freevars_expr freevars_rec x

type lexpr_t = lexpr_t lexpr

let rec eval3 subst e : lexpr_t = eval_lexpr eval3 subst e
let rec freevars3 (e : lexpr_t) = freevars_lexpr freevars3 e

let test3 =
  (`App (`Abs (&quot;x&quot;, `Add (`Mult (`Num 3, `Var &quot;x&quot;), `Num 1)),
         `Num 2) : lexpr_t)
let e_test3 = eval3 [] test3
let fv_test3 = freevars3 test3
let e_old_test = eval3 [] (test2 :&gt; lexpr_t)
let fv_old_test = freevars3 (test2 :&gt; lexpr_t)</code></pre>
<h3 id="polymorphic-variants-with-recursive-modules">11.8 Polymorphic
Variants with Recursive Modules</h3>
<p>Using recursive modules, we can clean up the confusing or cluttering
aspects of tying the recursive knots: type variables and recursive call
arguments.</p>
<p>We need <strong>private types</strong>, which for objects and
polymorphic variants means <em>private rows</em>. We can conceive of
open row types, e.g., <code>[&gt; \</code>Int of int | `String of
string]<code>as using a *row variable*, e.g.,</code>’a`:</p>
<p><code>[\</code>Int of int | `String of string | ’a]`</p>
<p>and then of private row types as abstracting the row variable:</p>
<pre><code>type &#39;row t = [`Int of int | `String of string | &#39;row]</code></pre>
<p>But the actual formalization of private row types is more
complex.</p>
<p><strong>Penalty points:</strong></p>
<ul>
<li>We still need to tie the recursive knots for types, for example
<code>private [&gt; 'a lambda] as 'a</code></li>
<li>There can be slight time costs due to the use of functors and
dispatch on merging of sub-languages</li>
</ul>
<p><strong>Verdict:</strong> A clean solution, best place.</p>
<pre><code>type var = [`Var of string]

let eval_var subst (`Var s as v : var) =
  try List.assoc s subst with Not_found -&gt; v

type &#39;a lambda =
  [`Var of string | `Abs of string * &#39;a | `App of &#39;a * &#39;a]

module type Eval =
sig type exp val eval : (string * exp) list -&gt; exp -&gt; exp end

module LF(X : Eval with type exp = private [&gt; &#39;a lambda] as &#39;a) =
struct
  type exp = X.exp lambda

  let gensym = let n = ref 0 in fun () -&gt; incr n; &quot;_&quot; ^ string_of_int !n

  let eval subst : exp -&gt; X.exp = function
    | #var as v -&gt; eval_var subst v
    | `App (l1, l2) -&gt;
      let l2&#39; = X.eval subst l2 in
      (match X.eval subst l1 with
      | `Abs (s, body) -&gt;
        X.eval [s, l2&#39;] body
      | l1&#39; -&gt; `App (l1&#39;, l2&#39;))
    | `Abs (s, l1) -&gt;
      let s&#39; = gensym () in
      `Abs (s&#39;, X.eval ((s, `Var s&#39;)::subst) l1)
end
module rec Lambda : (Eval with type exp = Lambda.exp lambda) =
  LF(Lambda)

module type FreeVars =
sig type exp val freevars : exp -&gt; string list end

module LFVF(X : FreeVars with type exp = private [&gt; &#39;a lambda] as &#39;a) =
struct
  type exp = X.exp lambda

  let freevars : exp -&gt; &#39;b = function
    | `Var v -&gt; [v]
    | `App (l1, l2) -&gt; X.freevars l1 @ X.freevars l2
    | `Abs (s, l1) -&gt;
      List.filter (fun v -&gt; v &lt;&gt; s) (X.freevars l1)
end
module rec LambdaFV : (FreeVars with type exp = LambdaFV.exp lambda) =
  LFVF(LambdaFV)

let test1 = (`App (`Abs (&quot;x&quot;, `Var &quot;x&quot;), `Var &quot;y&quot;) : Lambda.exp)
let e_test = Lambda.eval [] test1
let fv_test = LambdaFV.freevars test1</code></pre>
<p>The arithmetic expression sub-language:</p>
<pre><code>type &#39;a expr =
  [`Var of string | `Num of int | `Add of &#39;a * &#39;a | `Mult of &#39;a * &#39;a]

module type Operations =
sig include Eval include FreeVars with type exp := exp end

module EF(X : Operations with type exp = private [&gt; &#39;a expr] as &#39;a) =
struct
  type exp = X.exp expr

  let map_expr f = function
    | #var as v -&gt; v
    | `Num _ as n -&gt; n
    | `Add (e1, e2) -&gt; `Add (f e1, f e2)
    | `Mult (e1, e2) -&gt; `Mult (f e1, f e2)

  let eval subst (e : exp) : X.exp =
    match map_expr (X.eval subst) e with
    | #var as v -&gt; eval_var subst v
    | `Add (`Num m, `Num n) -&gt; `Num (m + n)
    | `Mult (`Num m, `Num n) -&gt; `Num (m * n)
    | e -&gt; e

  let freevars : exp -&gt; &#39;b = function
    | `Var v -&gt; [v]
    | `Num _ -&gt; []
    | `Add (e1, e2) | `Mult (e1, e2) -&gt; X.freevars e1 @ X.freevars e2
end
module rec Expr : (Operations with type exp = Expr.exp expr) =
  EF(Expr)

let test2 = (`Add (`Mult (`Num 3, `Var &quot;x&quot;), `Num 1) : Expr.exp)
let e_test2 = Expr.eval [&quot;x&quot;, `Num 2] test2
let fvs_test2 = Expr.freevars test2</code></pre>
<p>Merging the sub-languages:</p>
<pre><code>type &#39;a lexpr = [&#39;a lambda | &#39;a expr]

module LEF(X : Operations with type exp = private [&gt; &#39;a lexpr] as &#39;a) =
struct
  type exp = X.exp lexpr
  module LambdaX = LF(X)
  module LambdaFVX = LFVF(X)
  module ExprX = EF(X)

  let eval subst : exp -&gt; X.exp = function
    | #LambdaX.exp as x -&gt; LambdaX.eval subst x
    | #ExprX.exp as x -&gt; ExprX.eval subst x

  let freevars : exp -&gt; &#39;b = function
    | #lambda as x -&gt; LambdaFVX.freevars x  (* Either of #lambda or #LambdaX.exp is fine *)
    | #expr as x -&gt; ExprX.freevars x  (* Either of #expr or #ExprX.exp is fine *)
end
module rec LExpr : (Operations with type exp = LExpr.exp lexpr) =
  LEF(LExpr)

let test3 =
  (`App (`Abs (&quot;x&quot;, `Add (`Mult (`Num 3, `Var &quot;x&quot;), `Num 1)),
         `Num 2) : LExpr.exp)
let e_test3 = LExpr.eval [] test3
let fv_test3 = LExpr.freevars test3
let e_old_test = LExpr.eval [] (test2 :&gt; LExpr.exp)
let fv_old_test = LExpr.freevars (test2 :&gt; LExpr.exp)</code></pre>
<h3 id="parser-combinators">11.9 Parser Combinators</h3>
<p>We have done parsing using external languages OCamlLex and Menhir.
Now we look at parsers written directly in OCaml.</p>
<p>Language <strong>combinators</strong> are ways of defining languages
by composing definitions of smaller languages. For example, the
combinators of the <strong>Extended Backus-Naur Form</strong> notation
are:</p>
<ul>
<li><strong>Concatenation</strong>: <span class="math inline">S = A,
B</span> stands for <span class="math inline">S = \{ ab \mid a \in A, b
\in B \}</span></li>
<li><strong>Alternation</strong>: <span class="math inline">S = A \mid
B</span> stands for <span class="math inline">S = \{ a \mid a \in A \vee
a \in B \}</span></li>
<li><strong>Option</strong>: <span class="math inline">S = [A]</span>
stands for <span class="math inline">S = \{ \epsilon \} \cup A</span>,
where <span class="math inline">\epsilon</span> is an empty string</li>
<li><strong>Repetition</strong>: <span class="math inline">S = \{ A
\}</span> stands for <span class="math inline">S = \{ \epsilon \} \cup
\{ as \mid a \in A, s \in S \}</span></li>
<li><strong>Terminal string</strong>: <span class="math inline">S =
``a&quot;</span> stands for <span class="math inline">S = \{ a
\}</span></li>
</ul>
<p>Parsers implemented directly in a functional programming paradigm are
functions from character streams to the parsed values. Algorithmically
they are <strong>recursive descent parsers</strong>.</p>
<p><strong>Parser combinators</strong> approach builds parsers as
<strong>monad plus</strong> values:</p>
<ul>
<li><strong>Bind</strong>:
<code>val (&gt;&gt;=) : 'a parser -&gt; ('a -&gt; 'b parser) -&gt; 'b parser</code>
<ul>
<li><code>p &gt;&gt;= f</code> is a parser that first parses
<code>p</code>, and makes the result available for parsing
<code>f</code></li>
</ul></li>
<li><strong>Return</strong>:
<code>val return : 'a -&gt; 'a parser</code>
<ul>
<li><code>return x</code> parses an empty string, symbolically <span
class="math inline">S = \{ \epsilon \}</span>, and returns
<code>x</code></li>
</ul></li>
<li><strong>MZero</strong>: <code>val fail : 'a parser</code>
<ul>
<li><code>fail</code> fails to parse anything, symbolically <span
class="math inline">S = \varnothing = \{ \}</span></li>
</ul></li>
<li><strong>MPlus</strong>:
<code>val (&lt;|&gt;) : 'a parser -&gt; 'a parser -&gt; 'a parser</code>
<ul>
<li><code>p &lt;|&gt; q</code> tries <code>p</code>, and if
<code>p</code> succeeds, its result is returned, otherwise the parser
<code>q</code> is used</li>
</ul></li>
</ul>
<p>The only non-monad-plus operation that has to be built into the monad
is some way to consume a single character from the input stream, for
example:</p>
<ul>
<li><code>val satisfy : (char -&gt; bool) -&gt; char parser</code>
<ul>
<li><code>satisfy (fun c -&gt; c = 'a')</code> consumes the character
“a” from the input stream and returns it; if the input stream starts
with a different character, this parser fails</li>
</ul></li>
</ul>
<p>Ordinary monadic recursive descent parsers <strong>do not
allow</strong> <em>left-recursion</em>: if a cycle of calls not
consuming any character can be entered when a parse failure should
occur, the cycle will keep repeating.</p>
<p>For example, if we define numbers <span class="math inline">N := D
\mid N D</span>, where <span class="math inline">D</span> stands for
digits, then a stack of uses of the rule <span class="math inline">N
\rightarrow N D</span> will build up when the next character is not a
digit.</p>
<p>On the other hand, rules can share common prefixes.</p>
<h3 id="parser-combinators-implementation">11.10 Parser Combinators:
Implementation</h3>
<p>The parser monad is actually a composition of two monads:</p>
<ul>
<li>The <strong>state monad</strong> for storing the stream of
characters that remain to be parsed</li>
<li>The <strong>backtracking monad</strong> for handling parse failures
and ambiguities</li>
</ul>
<p>Alternatively, one can split the state monad into a reader monad with
the parsed string, and a state monad with the parsing position.</p>
<p>We experiment with a different approach to monad-plus:
<strong>lazy-monad-plus</strong>:</p>
<pre><code>val mplus : &#39;a monad -&gt; &#39;a monad Lazy.t -&gt; &#39;a monad</code></pre>
<h4 id="implementation-of-lazy-monad-plus">Implementation of
lazy-monad-plus</h4>
<p>First an operation from <code>MonadPlusOps</code>:</p>
<pre><code>let msum_map f l =
  List.fold_left  (* Folding left reverses the apparent order of composition *)
    (fun acc a -&gt; mplus acc (lazy (f a))) mzero l  (* order from l is preserved *)</code></pre>
<p>The implementation of the lazy-monad-plus using lazy lists:</p>
<pre><code>type &#39;a llist = LNil | LCons of &#39;a * &#39;a llist Lazy.t

let rec ltake n = function
  | LCons (a, l) when n &gt; 1 -&gt; a::(ltake (n-1) (Lazy.force l))
  | LCons (a, l) when n = 1 -&gt; [a]  (* Avoid forcing the tail if not needed *)
  | _ -&gt; []

let rec lappend l1 l2 =
  match l1 with LNil -&gt; Lazy.force l2
  | LCons (hd, tl) -&gt; LCons (hd, lazy (lappend (Lazy.force tl) l2))

let rec lconcat_map f = function
  | LNil -&gt; LNil
  | LCons (a, l) -&gt; lappend (f a) (lazy (lconcat_map f (Lazy.force l)))

module LListM = MonadPlus (struct
  type &#39;a t = &#39;a llist
  let bind a b = lconcat_map b a
  let return a = LCons (a, lazy LNil)
  let mzero = LNil
  let mplus = lappend
end)</code></pre>
<h4 id="the-parsec-monad">The Parsec Monad</h4>
<p>File <code>Parsec.ml</code>:</p>
<pre><code>open Monad

module type PARSE = sig
  type &#39;a backtracking_monad  (* Name for the underlying monad-plus *)
  type &#39;a parsing_state = int -&gt; (&#39;a * int) backtracking_monad  (* Processing state -- position *)
  type &#39;a t = string -&gt; &#39;a parsing_state  (* Reader for the parsed text *)
  include MONAD_PLUS_OPS
  val (&lt;|&gt;) : &#39;a monad -&gt; &#39;a monad Lazy.t -&gt; &#39;a monad  (* A synonym for mplus *)
  val run : &#39;a monad -&gt; &#39;a t
  val runT : &#39;a monad -&gt; string -&gt; int -&gt; &#39;a backtracking_monad
  val satisfy : (char -&gt; bool) -&gt; char monad  (* Consume a character of the specified class *)
  val end_of_text : unit monad  (* Check for end of the processed text *)
end

module ParseT (MP : MONAD_PLUS_OPS) :
  PARSE with type &#39;a backtracking_monad := &#39;a MP.monad =
struct
  type &#39;a backtracking_monad = &#39;a MP.monad
  type &#39;a parsing_state = int -&gt; (&#39;a * int) MP.monad
  module M = struct
    type &#39;a t = string -&gt; &#39;a parsing_state
    let return a = fun s p -&gt; MP.return (a, p)
    let bind m b = fun s p -&gt;
      MP.bind (m s p) (fun (a, p&#39;) -&gt; b a s p&#39;)
    let mzero = fun _ p -&gt; MP.mzero
    let mplus ma mb = fun s p -&gt;
      MP.mplus (ma s p) (lazy (Lazy.force mb s p))
  end
  include M
  include MonadPlusOps(M)
  let (&lt;|&gt;) ma mb = mplus ma mb
  let runT m s p = MP.lift fst (m s p)
  let satisfy f s p =
    if p &lt; String.length s &amp;&amp; f s.[p]  (* Consuming a character means accessing it *)
    then MP.return (s.[p], p + 1) else MP.mzero  (* and advancing the parsing position *)
  let end_of_text s p =
    if p &gt;= String.length s then MP.return ((), p) else MP.mzero
end</code></pre>
<h4 id="additional-parser-operations">Additional Parser Operations</h4>
<pre><code>module type PARSE_OPS = sig
  include PARSE
  val many : &#39;a monad -&gt; &#39;a list monad
  val opt : &#39;a monad -&gt; &#39;a option monad
  val (?|) : &#39;a monad -&gt; &#39;a option monad
  val seq : &#39;a monad -&gt; &#39;b monad Lazy.t -&gt; (&#39;a * &#39;b) monad  (* Exercise: why laziness here? *)
  val (&lt;*&gt;) : &#39;a monad -&gt; &#39;b monad Lazy.t -&gt; (&#39;a * &#39;b) monad  (* Synonym for seq *)
  val lowercase : char monad
  val uppercase : char monad
  val digit : char monad
  val alpha : char monad
  val alphanum : char monad
  val literal : string -&gt; unit monad  (* Consume characters of the given string *)
  val (&lt;&lt;&gt;) : string -&gt; &#39;a monad -&gt; &#39;a monad  (* Prefix and postfix keywords *)
  val (&lt;&gt;&gt;) : &#39;a monad -&gt; string -&gt; &#39;a monad
end

module ParseOps (R : MONAD_PLUS_OPS)
  (P : PARSE with type &#39;a backtracking_monad := &#39;a R.monad) :
  PARSE_OPS with type &#39;a backtracking_monad := &#39;a R.monad =
struct
  include P
  let rec many p =
    (perform
        r &lt;-- p; rs &lt;-- many p; return (r::rs))
    ++ lazy (return [])
  let opt p = (p &gt;&gt;= (fun x -&gt; return (Some x))) ++ lazy (return None)
  let (?|) p = opt p
  let seq p q = perform
      x &lt;-- p; y &lt;-- Lazy.force q; return (x, y)
  let (&lt;*&gt;) p q = seq p q
  let lowercase = satisfy (fun c -&gt; c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;)
  let uppercase = satisfy (fun c -&gt; c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;)
  let digit = satisfy (fun c -&gt; c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;)
  let alpha = lowercase ++ lazy uppercase
  let alphanum = alpha ++ lazy digit
  let literal l =
    let rec loop pos =
      if pos = String.length l then return ()
      else satisfy (fun c -&gt; c = l.[pos]) &gt;&gt;- loop (pos + 1) in
    loop 0
  let (&lt;&lt;&gt;) bra p = literal bra &gt;&gt;- p
  let (&lt;&gt;&gt;) p ket = p &gt;&gt;= (fun x -&gt; literal ket &gt;&gt;- return x)
end</code></pre>
<h3 id="parser-combinators-tying-the-recursive-knot">11.11 Parser
Combinators: Tying the Recursive Knot</h3>
<p>File <code>PluginBase.ml</code>:</p>
<pre><code>module ParseM =
  Parsec.ParseOps (Monad.LListM) (Parsec.ParseT (Monad.LListM))
open ParseM

let grammar_rules : (int monad -&gt; int monad) list ref = ref []

let get_language () : int monad =
  let rec result =
    lazy
      (List.fold_left
         (fun acc lang -&gt; acc &lt;|&gt; lazy (lang (Lazy.force result)))
          mzero !grammar_rules) in
  perform r &lt;-- Lazy.force result; end_of_text; return r  (* Ensure we parse the whole text *)</code></pre>
<h3 id="parser-combinators-dynamic-code-loading">11.12 Parser
Combinators: Dynamic Code Loading</h3>
<p>File <code>PluginRun.ml</code>:</p>
<pre><code>let load_plug fname : unit =
  let fname = Dynlink.adapt_filename fname in
  if Sys.file_exists fname then
    try Dynlink.loadfile fname
    with
    | (Dynlink.Error err) as e -&gt;
      Printf.printf &quot;\nERROR loading plugin: %s\n%!&quot;
        (Dynlink.error_message err);
      raise e
    | e -&gt; Printf.printf &quot;\nUnknow error while loading plugin\n%!&quot;
  else (
    Printf.printf &quot;\nPlugin file %s does not exist\n%!&quot; fname;
    exit (-1))

let () =
  for i = 2 to Array.length Sys.argv - 1 do
    load_plug Sys.argv.(i) done;
  let lang = PluginBase.get_language () in
  let result =
    Monad.LListM.run
      (PluginBase.ParseM.runT lang Sys.argv.(1) 0) in
  match Monad.ltake 1 result with
  | [] -&gt; Printf.printf &quot;\nParse error\n%!&quot;
  | r::_ -&gt; Printf.printf &quot;\nResult: %d\n%!&quot; r</code></pre>
<h3 id="parser-combinators-toy-example">11.13 Parser Combinators: Toy
Example</h3>
<p>File <code>Plugin1.ml</code>:</p>
<pre><code>open PluginBase.ParseM
let digit_of_char d = int_of_char d - int_of_char &#39;0&#39;

let number _ =  (* Numbers: N := D N | D where D is digits *)
  let rec num =
    lazy (  (perform
                d &lt;-- digit;
                (n, b) &lt;-- Lazy.force num;
                return (digit_of_char d * b + n, b * 10))
      &lt;|&gt; lazy (digit &gt;&gt;= (fun d -&gt; return (digit_of_char d, 10)))) in
  Lazy.force num &gt;&gt;| fst

let addition lang =  (* Addition rule: S -&gt; (S + S) *)
  perform  (* Requiring a parenthesis ( turns the rule into non-left-recursive *)
    literal &quot;(&quot;; n1 &lt;-- lang; literal &quot;+&quot;; n2 &lt;-- lang; literal &quot;)&quot;;
    return (n1 + n2)

let () =
  PluginBase.(grammar_rules := number :: addition :: !grammar_rules)</code></pre>
<p>File <code>Plugin2.ml</code>:</p>
<pre><code>open PluginBase.ParseM

let multiplication lang =  (* Multiplication rule: S -&gt; (S * S) *)
  perform
    literal &quot;(&quot;; n1 &lt;-- lang; literal &quot;*&quot;; n2 &lt;-- lang; literal &quot;)&quot;;
    return (n1 * n2)

let () =
  PluginBase.(grammar_rules := multiplication :: !grammar_rules)</code></pre>
<h3 id="exercises-10">11.14 Exercises</h3>
<p><strong>Exercise 1:</strong> Implement the <code>string_of_</code>
functions or methods, covering all data cases, corresponding to the
<code>eval_</code> functions in at least two examples from the lecture,
including both an object-based example and a variant-based example
(either standard, or polymorphic, or extensible variants).</p>
<p><strong>Exercise 2:</strong> Split at least one of the examples from
the previous exercise into multiple files and demonstrate separate
compilation.</p>
<p><strong>Exercise 3:</strong> Can we drop the tags
<code>Lambda_t</code>, <code>Expr_t</code> and <code>LExpr_t</code> used
in the examples based on standard variants (file
<code>FP_ADT.ml</code>)? When using polymorphic variants, such tags are
not needed.</p>
<p><strong>Exercise 4:</strong> Factor-out the sub-language consisting
only of variables, thus eliminating the duplication of tags
<code>VarL</code>, <code>VarE</code> in the examples based on standard
variants (file <code>FP_ADT.ml</code>).</p>
<p><strong>Exercise 5:</strong> Come up with a scenario where the
extensible variant types-based solution leads to a non-obvious or hard
to locate bug.</p>
<p><strong>Exercise 6:</strong> Re-implement the direct object-based
solution to the expression problem (file <code>Objects.ml</code>) to
make it more satisfying. For example, eliminate the need for some of the
<code>rename</code>, <code>apply</code>, <code>compute</code>
methods.</p>
<p><strong>Exercise 7:</strong> Re-implement the visitor pattern-based
solution to the expression problem (file <code>Visitor.ml</code>) in a
functional way, i.e., replace the mutable fields <code>subst</code> and
<code>beta_redex</code> in the <code>eval_lambda</code> class with a
different solution to the problem of treating <code>abs</code> and
non-<code>abs</code> expressions differently.</p>
<p><strong>Exercise 8:</strong> Extend the sub-language
<code>expr_visit</code> with variables, and add to arguments of the
evaluation constructor <code>eval_expr</code> the substitution. Handle
the problem of potentially duplicate fields <code>subst</code>. (One
approach might be to use ideas from exercise 6.)</p>
<p><strong>Exercise 9:</strong> Implement the following modifications to
the example from the file <code>PolyV.ml</code>:</p>
<ol type="1">
<li>Factor-out the sub-language of variables, around the already present
<code>var</code> type.</li>
<li>Open the types of functions <code>eval3</code>,
<code>freevars3</code> and other functions as required, so that explicit
subtyping, e.g., in <code>eval3 [] (test2 :&gt; lexpr_t)</code>, is not
necessary.</li>
<li>Remove the double-dispatch currently in <code>eval_lexpr</code> and
<code>freevars_lexpr</code>, by implementing a cascading design rather
than a “divide-and-conquer” design.</li>
</ol>
<p><strong>Exercise 10:</strong> Streamline the solution
<code>PolyRecM.ml</code> by extending the language of <span
class="math inline">\lambda</span>-expressions with arithmetic
expressions, rather than defining the sub-languages separately and then
merging them. See slide on page 15 of Jacques Garrigue <em>Structural
Types, Recursive Modules, and the Expression Problem</em>.</p>
<p><strong>Exercise 11:</strong> Transform a parser monad, or rewrite
the parser monad transformer, by adding state for the line and column
numbers.</p>
<p><strong>Exercise 12:</strong> Implement <code>_of_string</code>
functions as parser combinators on top of the example
<code>PolyRecM.ml</code>. Sections 4.3 and 6.2 of <em>Monadic Parser
Combinators</em> by Graham Hutton and Erik Meijer might be helpful.
Split the result into multiple files as in Exercise 2 and demonstrate
dynamic loading of code.</p>
<p><strong>Exercise 13:</strong> What are the benefits and drawbacks of
our lazy-monad-plus (built on top of <em>odd lazy lists</em>) approach,
as compared to regular monad-plus built on top of <em>even lazy
lists</em>? To additionally illustrate your answer:</p>
<ol type="1">
<li>Rewrite the parser combinators example to use regular monad-plus and
even lazy lists.</li>
<li>Select one example from Lecture 8 and rewrite it using
lazy-monad-plus and odd lazy lists.</li>
</ol>
</body>
</html>
