\documentclass{beamer}
\usepackage[english]{babel}
\usepackage{geometry,amsmath,amssymb,graphicx,stmaryrd,hyperref}
\geometry{landscape, letterpaper}

%%%%%%%%%% Start TeXmacs macros
\catcode`\<=\active \def<{
\fontencoding{T1}\selectfont\symbol{60}\fontencoding{\encodingdefault}}
\catcode`\>=\active \def>{
\fontencoding{T1}\selectfont\symbol{62}\fontencoding{\encodingdefault}}
\newcommand{\tmem}[1]{{\em #1\/}}
\newcommand{\tmfnhomepage}[1]{\thanks{\textit{Web:} \texttt{#1}}}
\newcommand{\tmmathbf}[1]{\ensuremath{\boldsymbol{#1}}}
\newcommand{\tmop}[1]{\ensuremath{\operatorname{#1}}}
\newcommand{\tmstrong}[1]{\textbf{#1}}
\newcommand{\tmverbatim}[1]{\text{{\ttfamily{#1}}}}
%%%%%%%%%% End TeXmacs macros

\begin{document}

\title{Functional Programming}

\author{
  {\L}ukasz Stafiniak
  \tmfnhomepage{www.ii.uni.wroc.pl/\~{}lukstafi}
}

\institute{{\L}ukasz Stafiniak}

\maketitle

\title{Lecture 8: Monads}

\subtitle{List comprehensions. Basic monads; transformers. Probabilistic
Programming.\\
Lightweight cooperative threads.\\
{\small{{\scriptsize{Some examples from Tomasz Wierzbicki.}} Jeff Newbern
{\tmem{``All About Monads''}}.\\
M. Erwig, S. Kollmansberger {\tmem{``Probabilistic Functional Programming in
Haskell''}}.\\
Jerome Vouillon {\tmem{``Lwt: a Cooperative Thread Library''}}.}}}

\maketitle

{\center{If you see any error on the slides, let me know!}}

\section{List comprehensions}

\begin{itemize}
  \item Recall the awkward syntax we used in the Countdown Problem example:
  \begin{itemize}
    \item Brute-force generation:
    
    {\small{{\hlkwa{let }}{\hlstd{combine l r }}{\hlopt{=}}{\hlendline{}}\\
    {\hlstd{ \ }}{\hlkwc{List}}{\hlopt{.}}{\hlstd{map }}{\hlopt{(}}{\hlkwa{fun
    }}{\hlstd{o}}{\hlopt{->}}{\hlkwd{App
    }}{\hlopt{(}}{\hlstd{o}}{\hlopt{,}}{\hlstd{l}}{\hlopt{,}}{\hlstd{r}}{\hlopt{))
    [}}{\hlkwd{Add}}{\hlopt{; }}{\hlkwd{Sub}}{\hlopt{;
    }}{\hlkwd{Mul}}{\hlopt{; }}{\hlkwd{Div}}{\hlopt{]}}{\hlendline{}}\\
    {\hlkwa{let rec }}{\hlstd{exprs }}{\hlopt{=
    }}{\hlkwa{function}}{\hlendline{}}\\
    {\hlstd{ \ }}{\hlopt{\textbar  [] -> []}}{\hlendline{}}\\
    {\hlstd{ \ }}{\hlopt{\textbar  [}}{\hlstd{n}}{\hlopt{] -> [}}{\hlkwd{Val
    }}{\hlstd{n}}{\hlopt{]}}{\hlendline{}}\\
    {\hlstd{ \ {\hlopt{\textbar}} ns }}{\hlopt{->}}{\hlendline{}}\\
    {\hlstd{ \ \ \ split ns {\hlopt{\textbar}}}}{\hlopt{-> (}}{\hlkwa{fun
    }}{\hlopt{(}}{\hlstd{ls}}{\hlopt{,}}{\hlstd{rs}}{\hlopt{)
    ->}}{\hlendline{}}\\
    {\hlstd{ \ \ \ \ \ exprs ls {\hlopt{\textbar}}}}{\hlopt{-> (}}{\hlkwa{fun
    }}{\hlstd{l }}{\hlopt{->}}{\hlendline{}}\\
    {\hlstd{ \ \ \ \ \ \ \ exprs rs {\hlopt{\textbar}}}}{\hlopt{->
    (}}{\hlkwa{fun }}{\hlstd{r }}{\hlopt{->}}{\hlendline{}}\\
    {\hlstd{ \ \ \ \ \ \ \ \ \ combine l r}}{\hlopt{)))}}{\hlendline{}}}}
    
    \item Genarate-and-test scheme:
    
    {\small{{\hlkwa{let }}{\hlstd{guard p e }}{\hlopt{=}}{\hlkwa{ if
    }}{\hlstd{p e }}{\hlkwa{then }}{\hlopt{[}}{\hlstd{e}}{\hlopt{]
    }}{\hlkwa{else }}{\hlopt{[]}}{\hlendline{}}\\
    {\hlkwa{let }}{\hlstd{solutions ns n }}{\hlopt{=}}{\hlendline{}}\\
    {\hlstd{ \ choices ns {\hlopt{\textbar}}}}{\hlopt{-> (}}{\hlkwa{fun
    }}{\hlstd{ns' }}{\hlopt{->}}{\hlendline{}}\\
    {\hlstd{ \ \ \ exprs ns' {\hlopt{\textbar}}}}{\hlopt{->}}{\hlendline{}}\\
    {\hlstd{ \ \ \ \ \ guard }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{e }}{\hlopt{->
    }}{\hlstd{eval e }}{\hlopt{= }}{\hlkwd{Some
    }}{\hlstd{n}}{\hlopt{))}}}}{\hlendline{}}
  \end{itemize}
  \item Recall that we introduced the operator
  
  {\hlkwa{let }}{\hlopt{( }}{\hlstd{{\hlopt{\textbar}}}}{\hlopt{-> )
  }}{\hlstd{x f }}{\hlopt{= }}{\hlstd{concat{\textunderscore}map f
  x}}{\hlendline{}}
  
  \item We can do better with {\tmem{list comprehensions}} syntax extension.
  
  {\hlstd{\#load }}{\hlstr{"dynlink.cma"}}{\hlopt{;;}}{\hlendline{}}\\
  {\hlstd{\#load }}{\hlstr{"camlp4o.cma"}}{\hlopt{;;}}{\hlendline{}}\\
  {\hlstd{\#load
  }}{\hlstr{"Camlp4Parsers/Camlp4ListComprehension.cmo"}}{\hlopt{;;}}{\hlendline{}}
  
  {\hlkwa{let }}{\hlstd{test }}{\hlopt{= [}}{\hlstd{i }}{\hlopt{* }}{\hlnum{2
  }}{\hlstd{{\hlopt{\textbar}} i }}{\hlopt{<-
  }}{\hlstd{from{\textunderscore}to }}{\hlnum{2 22}}{\hlopt{; }}{\hlstd{i
  }}{\hlkwa{mod }}{\hlnum{3 }}{\hlopt{= }}{\hlnum{0}}{\hlopt{]}}{\hlendline{}}
  
  \item What it means:
  \begin{itemize}
    \item {\hlopt{[}}{\hlstd{expr}}{\hlstd{ {\hlopt{\textbar  ]}}}} can be
    translated as {\hlopt{[}}{\hlstd{expr}}{\hlstd{{\hlopt{]}}}}
    
    \item {\hlstd{{\hlopt{[}}{\hlstd{expr}}{\hlopt{ \textbar}} v }}{\hlopt{<-
    }}{\hlstd{generator}}{\hlopt{; }}{\tmem{more}}{\hlopt{]}} can be
    translated as
    
    \tmverbatim{generator}{\hlopt{ \textbar -> (}}{\hlkwa{fun }}{\hlstd{v
    }}{\hlopt{-> }}translation of {\hlstd{{\hlopt{[}}{\hlstd{expr}}{\hlopt{
    \textbar}} }}{\tmem{more}}{\hlopt{]}}{\hlopt{)}}
    
    \item {\hlstd{{\hlopt{[}}{\hlstd{expr}}{\hlopt{ \textbar}}
    }}\tmverbatim{condition}{\hlopt{; }}{\tmem{more}}{\hlopt{]}} can be
    translated as
    
    {\hlkwa{if }}{\hlstd{condition }}{\hlkwa{then }}translation of
    {\hlopt{[}}\tmverbatim{expr }{\hlopt{\textbar }}{\tmem{more}}{\hlopt{]
    }}{\hlkwa{else }}{\hlopt{[]}}
  \end{itemize}
  \item Revisiting the Countdown Problem code snippets:
  \begin{itemize}
    \item Brute-force generation:
    
    {\hlkwa{let rec }}{\hlstd{exprs }}{\hlopt{=
    }}{\hlkwa{function}}{\hlendline{}}\\
    {\hlstd{ \ }}{\hlopt{\textbar  [] -> []}}{\hlendline{}}\\
    {\hlstd{ \ }}{\hlopt{\textbar  [}}{\hlstd{n}}{\hlopt{] -> [}}{\hlkwd{Val
    }}{\hlstd{n}}{\hlopt{]}}{\hlendline{}}\\
    {\hlstd{ \ {\hlopt{\textbar}} ns }}{\hlopt{->}}{\hlendline{}}\\
    {\hlstd{ \ \ \ }}{\hlopt{[}}{\hlkwd{App
    }}{\hlopt{(}}{\hlstd{o}}{\hlopt{,}}{\hlstd{l}}{\hlopt{,}}{\hlstd{r}}{\hlopt{)
    \textbar  (}}{\hlstd{ls}}{\hlopt{,}}{\hlstd{rs}}{\hlopt{) <-
    }}{\hlstd{split ns}}{\hlopt{;}}{\hlendline{}}\\
    {\hlstd{ \ \ \ \ l }}{\hlopt{<- }}{\hlstd{exprs ls}}{\hlopt{; }}{\hlstd{r
    }}{\hlopt{<- }}{\hlstd{exprs rs}}{\hlopt{;}}{\hlendline{}}\\
    {\hlstd{ \ \ \ \ o }}{\hlopt{<- [}}{\hlkwd{Add}}{\hlopt{;
    }}{\hlkwd{Sub}}{\hlopt{; }}{\hlkwd{Mul}}{\hlopt{;
    }}{\hlkwd{Div}}{\hlopt{]]}}{\hlendline{}}
    
    \item Genarate-and-test scheme:
    
    {\hlkwa{let }}{\hlstd{solutions ns n }}{\hlopt{=}}{\hlendline{}}\\
    {\hlstd{ \ }}{\hlopt{[}}{\hlstd{e {\hlopt{\textbar}} ns' }}{\hlopt{<-
    }}{\hlstd{choices ns}}{\hlopt{;}}{\hlendline{}}\\
    {\hlstd{ \ \ e }}{\hlopt{<- }}{\hlstd{exprs ns'}}{\hlopt{; }}{\hlstd{eval
    e }}{\hlopt{= }}{\hlkwd{Some }}{\hlstd{n}}{\hlopt{]}}{\hlendline{}}
  \end{itemize}
  \item Subsequences using list comprehensions (with garbage):
  
  {\hlkwa{let rec }}{\hlstd{subseqs l }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{match }}{\hlstd{l }}{\hlkwa{with}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlopt{\textbar  [] -> [[]]}}{\hlendline{}}\\
  {\hlstd{ \ \ \ {\hlopt{\textbar}} x}}{\hlopt{::}}{\hlstd{xs }}{\hlopt{->
  [}}{\hlstd{ys {\hlopt{\textbar}} px }}{\hlopt{<- }}{\hlstd{subseqs
  xs}}{\hlopt{; }}{\hlstd{ys }}{\hlopt{<- [}}{\hlstd{px}}{\hlopt{;
  }}{\hlstd{x}}{\hlopt{::}}{\hlstd{px}}{\hlopt{]]}}{\hlendline{}}
  
  \item Computing permutations using list comprehensions:
  \begin{itemize}
    \item via insertion
    
    {\hlkwa{let rec }}{\hlstd{insert x }}{\hlopt{=
    }}{\hlkwa{function}}{\hlendline{}}\\
    {\hlstd{ \ }}{\hlopt{\textbar  [] ->
    [[}}{\hlstd{x}}{\hlopt{]]}}{\hlendline{}}\\
    {\hlstd{ \ {\hlopt{\textbar}} y}}{\hlopt{::}}{\hlstd{ys' }}{\hlkwa{as
    }}{\hlstd{ys }}{\hlopt{->}}{\hlendline{}}\\
    {\hlstd{ \ \ \ }}{\hlopt{(}}{\hlstd{x}}{\hlopt{::}}{\hlstd{ys}}{\hlopt{)
    :: [}}{\hlstd{y}}{\hlopt{::}}{\hlstd{zs {\hlopt{\textbar}} zs }}{\hlopt{<-
    }}{\hlstd{insert x ys'}}{\hlopt{]}}{\hlendline{}}\\
    {\hlkwa{let rec }}{\hlstd{ins{\textunderscore}perms }}{\hlopt{=
    }}{\hlkwa{function}}{\hlendline{}}\\
    {\hlstd{ \ }}{\hlopt{\textbar  [] -> [[]]}}{\hlendline{}}\\
    {\hlstd{ \ {\hlopt{\textbar}} x}}{\hlopt{::}}{\hlstd{xs }}{\hlopt{->
    [}}{\hlstd{zs {\hlopt{\textbar}} ys }}{\hlopt{<-
    }}{\hlstd{ins{\textunderscore}perms xs}}{\hlopt{; }}{\hlstd{zs
    }}{\hlopt{<- }}{\hlstd{insert ys}}{\hlopt{]}}
    
    \item via selection
    
    {\hlkwa{let rec }}{\hlstd{select }}{\hlopt{=
    }}{\hlkwa{function}}{\hlendline{}}\\
    {\hlstd{ \ }}{\hlopt{\textbar  [}}{\hlstd{x}}{\hlopt{] ->
    [}}{\hlstd{x}}{\hlopt{,[]]}}{\hlendline{}}\\
    {\hlstd{ \ {\hlopt{\textbar}} x}}{\hlopt{::}}{\hlstd{xs }}{\hlopt{->
    (}}{\hlstd{x}}{\hlopt{,}}{\hlstd{xs}}{\hlopt{) :: [ }}{\hlstd{y}}{\hlopt{,
    }}{\hlstd{x}}{\hlopt{::}}{\hlstd{ys {\hlopt{\textbar}}
    y}}{\hlopt{,}}{\hlstd{ys }}{\hlopt{<- }}{\hlstd{select
    xs}}{\hlopt{]}}{\hlendline{}}\\
    {\hlkwa{let rec }}{\hlstd{sel{\textunderscore}perms }}{\hlopt{=
    }}{\hlkwa{function}}{\hlendline{}}\\
    {\hlstd{ \ }}{\hlopt{\textbar  [] -> [[]]}}{\hlendline{}}\\
    {\hlstd{ \ {\hlopt{\textbar}} xs }}{\hlopt{->}}{\hlendline{}}\\
    {\hlstd{ \ \ \ }}{\hlopt{[}}{\hlstd{x}}{\hlopt{::}}{\hlstd{ys
    {\hlopt{\textbar}} x}}{\hlopt{,}}{\hlstd{xs' }}{\hlopt{<- }}{\hlstd{select
    xs}}{\hlopt{; }}{\hlstd{ys }}{\hlopt{<-
    }}{\hlstd{sel{\textunderscore}perms xs'}}{\hlopt{]}}{\hlendline{}}
  \end{itemize}
\end{itemize}

\section{Generalized comprehensions aka. {\tmem{do-notation}}}

\begin{itemize}
  \item We need to install the syntax extension \tmverbatim{pa\_monad}
  \begin{itemize}
    \item by copying the \tmverbatim{pa\_monad.cmo or pa\_monad400.cmo} (for
    OCaml 4.0) file from the course page,
    
    \item or if it does not work, by compiling from sources at\\
    \href{http://www.cas.mcmaster.ca/~carette/pa_monad/}{http://www.cas.mcmaster.ca/\~{}carette/pa\_monad/}\\
    and installing under a Unix-like shell (Windows: the Cygwin shell).
    \begin{itemize}
      \item Under Debian/Ubuntu, you may need to install
      \tmverbatim{camlp4-extras}
    \end{itemize}
  \end{itemize}
  \item {\hlkwa{let rec }}{\hlstd{exprs }}{\hlopt{=
  }}{\hlkwa{function}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlopt{\textbar  [] -> []}}{\hlstd{{\hlendline{}}\\
  \ }}{\hlopt{\textbar  [}}{\hlstd{n}}{\hlopt{] -> }}{\hlopt{[}}{\hlkwd{Val
  }}{\hlstd{n}}{\hlopt{]}}{\hlendline{}}\\
  {\hlstd{ \ {\hlopt{\textbar}} ns }}{\hlopt{->}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{perform with
  }}{\hlopt{(}}{\hlstd{{\hlopt{\textbar}}}}{\hlopt{->)
  }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ }}{\hlopt{(}}{\hlstd{ls}}{\hlopt{,}}{\hlstd{rs}}{\hlopt{)
  <-- }}{\hlstd{split ns}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ l }}{\hlopt{<-- }}{\hlstd{exprs ls}}{\hlopt{; }}{\hlstd{r
  }}{\hlopt{<-- }}{\hlstd{exprs rs}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ o }}{\hlopt{<-- [}}{\hlkwd{Add}}{\hlopt{;
  }}{\hlkwd{Sub}}{\hlopt{; }}{\hlkwd{Mul}}{\hlopt{;
  }}{\hlkwd{Div}}{\hlopt{];}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ }}{\hlopt{[}}{\hlkwd{App
  }}{\hlopt{(}}{\hlstd{o}}{\hlopt{,}}{\hlstd{l}}{\hlopt{,}}{\hlstd{r}}{\hlopt{)]}}{\hlendline{}}
  
  \item The {\hlkwa{perform}} syntax does not seem to support guards...
  
  {\hlkwa{let }}{\hlstd{solutions ns n }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{perform with
  }}{\hlopt{(}}{\hlstd{{\hlopt{\textbar}}}}{\hlopt{->)
  }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ \ \ ns' }}{\hlopt{<-- }}{\hlstd{choices
  ns}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ e }}{\hlopt{<-- }}{\hlstd{exprs
  ns'}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ eval e }}{\hlopt{= }}{\hlkwd{Some
  }}{\hlstd{n}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ e}}{\hlendline{}}
  
  {\hlstd{ \ \ \ \ \ eval e }}{\hlopt{= }}{\hlkwd{Some
  }}{\hlstd{n}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \
  {\textasciicircum}{\textasciicircum}{\textasciicircum}{\textasciicircum}{\textasciicircum}{\textasciicircum}{\textasciicircum}{\textasciicircum}{\textasciicircum}{\textasciicircum}{\textasciicircum}{\textasciicircum}{\textasciicircum}{\textasciicircum}{\textasciicircum}}}{\hlendline{}}\\
  {\hlkwd{Error}}{\hlopt{: }}{\hlkwd{This }}{\hlstd{expression has
  }}{\hlkwa{type }}{\hlkwb{bool }}{\hlstd{but an expression was expected
  }}{\hlkwa{of type}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ \ \ \ 'a list}}{\hlendline{}}
  
  \item So it wants a list... What can we do?
  
  \item We can decide whether to return anything
  
  {\hlkwa{let }}{\hlstd{solutions ns n }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{perform with
  }}{\hlopt{(}}{\hlstd{{\hlopt{\textbar}}}}{\hlopt{->)
  }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ \ \ ns' }}{\hlopt{<-- }}{\hlstd{choices
  ns}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ e }}{\hlopt{<-- }}{\hlstd{exprs
  ns'}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{if }}{\hlstd{eval e }}{\hlopt{= }}{\hlkwd{Some
  }}{\hlstd{n }}{\hlkwa{then }}{\hlopt{[}}{\hlstd{e}}{\hlopt{] }}{\hlkwa{else
  }}{\hlopt{[]}}{\hlendline{}}
  
  \item But what if we want to check earlier...
  
  General ``guard check'' function
  
  {\hlkwa{let }}{\hlstd{guard p }}{\hlopt{= }}{\hlkwa{if }}{\hlstd{p
  }}{\hlkwa{then }}{\hlopt{[()] }}{\hlkwa{else }}{\hlopt{[]}}{\hlendline{}}
  
  \item {\hlkwa{let }}{\hlstd{solutions ns n }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{perform with
  }}{\hlopt{(}}{\hlstd{{\hlopt{\textbar}}}}{\hlopt{->)
  }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ \ \ ns' }}{\hlopt{<-- }}{\hlstd{choices
  ns}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ e }}{\hlopt{<-- }}{\hlstd{exprs
  ns'}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ guard }}{\hlopt{(}}{\hlstd{eval e }}{\hlopt{= }}{\hlkwd{Some
  }}{\hlstd{n}}{\hlopt{);}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlopt{[}}{\hlstd{e}}{\hlopt{]}}{\hlendline{}}
\end{itemize}

\section{Monads}

\begin{itemize}
  \item A polymorphic type \tmverbatim{'a monad} (or \tmverbatim{'a Monad.t},
  etc.) that supports at least two operations:
  \begin{itemize}
    \item \tmverbatim{bind : 'a monad -> ('a -> 'b monad) -> 'b monad}
    
    \item \tmverbatim{return : 'a -> 'a monad}
    
    \item {\hlopt{>>=}} is infix syntax for \tmverbatim{bind}: {\hlkwa{let
    }}{\hlopt{(>>=) }}{\hlstd{a b }}{\hlopt{= }}{\hlstd{bind a b}}
  \end{itemize}
  \item With \tmverbatim{bind} in scope, we do not need the {\hlkwa{with}}
  clause in {\hlkwa{perform}}
  
  {\hlkwa{let }}{\hlstd{bind a b }}{\hlopt{=
  }}{\hlstd{concat{\textunderscore}map b a}}{\hlendline{}}\\
  {\hlkwa{let }}{\hlstd{return x }}{\hlopt{= [}}{\hlstd{x}}{\hlopt{]}}{\hlstd{
  \ }}{\hlendline{}}\\
  {\hlkwa{let }}{\hlstd{solutions ns n }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{perform}}{\hlendline{}}\\
  {\hlstd{ \ \ \ ns' }}{\hlopt{<-- }}{\hlstd{choices
  ns}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ e }}{\hlopt{<-- }}{\hlstd{exprs
  ns'}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ guard }}{\hlopt{(}}{\hlstd{eval e }}{\hlopt{= }}{\hlkwd{Some
  }}{\hlstd{n}}{\hlopt{);}}{\hlendline{}}\\
  {\hlstd{ \ \ \ return e}}{\hlendline{}}
  
  \item Why \tmverbatim{guard} looks this way?
  
  {\hlkwa{let }}{\hlstd{fail }}{\hlopt{= []}}{\hlendline{}}\\
  {\hlkwa{let }}{\hlstd{guard p }}{\hlopt{= }}{\hlkwa{if }}{\hlstd{p
  }}{\hlkwa{then }}{\hlstd{return }}{\hlopt{() }}{\hlkwa{else
  }}{\hlstd{fail}}{\hlendline{}}
  \begin{itemize}
    \item Steps in monadic computation are composed with {\hlopt{>>=}}, e.g.
    {\hlopt{\textbar ->}}
    \begin{itemize}
      \item as if {\hlopt{;}} was replaced by {\hlopt{>>=}}
    \end{itemize}
    \item {\hlopt{[] \textbar -> }}... does not produce anything -- as needed
    by guarding
    
    \item {\hlopt{[()] \textbar -> }}... $\rightsquigarrow$
    {\hlopt{(}}{\hlkwa{fun }}{\hlopt{\_ -> }}...{\hlopt{) ()}}
    $\rightsquigarrow$ ... i.e. keep without change
  \end{itemize}
  \item Throwing away the binding argument is a common practice, with infix
  syntax {\hlopt{>>}} in Haskell, and supported in {\tmem{do-notation}} and
  {\hlkwa{perform}}.
  
  \item Everything is a monad?
  
  \item Different flavors of monads?
  
  \item Can \tmverbatim{guard} be defined for any monad?
  
  \item {\hlkwa{perform}} syntax in depth:
  
  \begin{tabular}{lll}
    {\hlkwa{perform }}{\hlstd{exp}} & $\Longrightarrow$ & \tmverbatim{exp}\\
    {\hlkwa{perform }}{\hlstd{pat }}{\hlopt{<-- }}{\hlstd{exp}}{\hlopt{;}} &
    $\Longrightarrow$ & {\hlstd{bind exp }}\\
    {\hlstd{ \ \ \ \ \ \ \ rest}} &  & {\hlopt{(}}{\hlkwa{fun }}{\hlstd{pat
    }}{\hlopt{-> }}{\hlkwa{perform }}{\hlstd{rest}}{\hlopt{)}}\\
    {\hlkwa{perform }}{\hlstd{exp}}{\hlopt{; }}{\hlstd{rest}} &
    $\Longrightarrow$ & {\hlstd{bind exp}}\\
    &  & {\hlopt{(}}{\hlkwa{fun }}{\hlstd{{\textunderscore} }}{\hlopt{->
    }}{\hlkwa{perform }}{\hlstd{rest}}{\hlopt{)}}\\
    {\hlkwa{perform let }}{\hlopt{... }}{\hlkwa{in }}{\hlstd{rest}} &
    $\Longrightarrow$ & {\hlkwa{let }}{\hlopt{... }}{\hlkwa{in perform
    }}{\hlstd{rest}}\\
    {\hlkwa{perform }}{\hlstd{rpt }}{\hlopt{<-- }}{\hlstd{exp}}{\hlopt{;}} &
    $\Longrightarrow$ & {\hlstd{bind exp}}\\
    {\hlstd{ \ \ \ \ \ \ \ rest}} &  & {\hlopt{(}}{\hlkwa{function }}\\
    &  & {\hlstd{{\hlopt{\textbar}} rpt }}{\hlopt{-> }}{\hlkwa{perform
    }}{\hlstd{rest}}\\
    &  & {\hlstd{{\hlopt{\textbar}} {\textunderscore} }}{\hlopt{->}}{\hlstd{
    failwith}}\\
    &  & {\hlstr{ \ \ \ \ \ \ "pattern match"}}{\hlopt{)}}\\
    &  & \\
    {\hlkwa{perform with }}{\hlstd{b }}[{\hlkwa{and }}{\hlstd{f}}] {\hlkwa{in
    }} & $\Longrightarrow$ & {\hlkwa{perform }}{\hlstd{body}}\\
    {\hlstd{ \ \ \ \ \ \ \ body}} &  & but uses \tmverbatim{b} instead of
    \tmverbatim{bind}\\
    &  & and \tmverbatim{f} instead of \tmverbatim{failwith}\\
    &  & during translation
  \end{tabular}
  
  \item It can be useful to redefine: {\hlkwa{let }}{\hlstd{failwith
  {\textunderscore} }}{\hlopt{= }}{\hlstd{fail}} ({\tmem{why?}})
\end{itemize}

\subsection{Monad laws}

\begin{itemize}
  \item A parametric data type is a monad only if its \tmverbatim{bind} and
  \tmverbatim{return} operations meet axioms:
  \begin{eqnarray*}
    \tmop{bind} (\tmop{return} a) f & \approx & f a\\
    \tmop{bind} a (\lambda x. \tmop{return} x) & \approx & a\\
    \tmop{bind} (\tmop{bind} a (\lambda x.b))  (\lambda y.c) & \approx &
    \tmop{bind} a (\lambda x. \tmop{bind} b (\lambda y.c))
  \end{eqnarray*}
  
  
  \item Check that the laws hold for our example monad
  
  {\hlkwa{let }}{\hlstd{bind a b }}{\hlopt{=
  }}{\hlstd{concat{\textunderscore}map b a}}{\hlendline{}}\\
  {\hlkwa{let }}{\hlstd{return x }}{\hlopt{= [}}{\hlstd{x}}{\hlopt{]}}{\hlstd{
  \ }}{\hlendline{}}
\end{itemize}

\subsection{Monoid laws and {\tmem{monad-plus}}}

\begin{itemize}
  \item A monoid is a type with, at least, two operations
  \begin{itemize}
    \item \tmverbatim{mzero : 'a monoid}
    
    \item \tmverbatim{mplus : 'a monoid -> 'a monoid -> 'a monoid}
  \end{itemize}
  that meet the laws:
  \begin{eqnarray*}
    \tmop{mplus} \tmop{mzero} a & \approx & a\\
    \tmop{mplus} a \tmop{mzero} & \approx & a\\
    \tmop{mplus} a (\tmop{mplus} b c) & \approx & \tmop{mplus} (\tmop{mplus} a
    b) c
  \end{eqnarray*}
  \item We will define \tmverbatim{fail} as synonym for \tmverbatim{mzero} and
  infix {\hlopt{++}} for \tmverbatim{mplus}.
  
  \item Fusing monads and monoids gives the most popular general flavor of
  monads which we call {\tmem{monad-plus}} after Haskell.
  
  \item Monad-plus requires additional axioms that relate its ``addition'' and
  its ``multiplication''.
  \begin{eqnarray*}
    \tmop{bind} \tmop{mzero} f & \approx & \tmop{mzero}\\
    \tmop{bind} m (\lambda x. \tmop{mzero}) & \approx & \tmop{mzero}
  \end{eqnarray*}
  \item Using infix notation with $\oplus$ as \tmverbatim{mplus},
  $\tmmathbf{0}$ as \tmverbatim{mzero}, $\vartriangleright$ as
  \tmverbatim{bind} and \ $\tmmathbf{1}$ as \tmverbatim{return}, we get
  monad-plus axioms
  \begin{eqnarray*}
    \tmmathbf{0} \oplus a & \approx & a\\
    a \oplus \tmmathbf{0} & \approx & a\\
    a \oplus (b \oplus c) & \approx & (a \oplus b) \oplus c\\
    \tmmathbf{1}x \vartriangleright f & \approx & f x\\
    a \vartriangleright \lambda x.\tmmathbf{1}x & \approx & a\\
    (a \vartriangleright \lambda x.b) \vartriangleright \lambda y.c & \approx
    & a \vartriangleright (\lambda x.b \vartriangleright \lambda y.c)\\
    \tmmathbf{0} \vartriangleright f & \approx & \tmmathbf{0}\\
    a \vartriangleright (\lambda x.\tmmathbf{0}) & \approx & \tmmathbf{0}
  \end{eqnarray*}
  \item The list type has a natural monad and monoid structure
  
  {\hlkwa{ \ let }}{\hlstd{mzero }}{\hlopt{= []}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{mplus }}{\hlopt{=
  (}}{\hlstd{@}}{\hlopt{)}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{bind a b }}{\hlopt{=
  }}{\hlstd{concat{\textunderscore}map b a{\hlendline{}}\\
  \ }}{\hlkwa{let }}{\hlstd{return a }}{\hlopt{=
  [}}{\hlstd{a}}{\hlopt{]}}{\hlendline{}}
  
  \item We can define in any monad-plus
  
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{fail }}{\hlopt{=
  }}{\hlstd{mzero{\hlendline{}}\\
  \ }}{\hlkwa{let }}{\hlstd{failwith {\textunderscore} }}{\hlopt{=
  }}{\hlstd{fail{\hlendline{}}\\
  \ }}{\hlkwa{let }}{\hlopt{(++) = }}{\hlstd{mplus{\hlendline{}}\\
  \ }}{\hlkwa{let }}{\hlopt{(>>=) }}{\hlstd{a b }}{\hlopt{= }}{\hlstd{bind a
  b{\hlendline{}}\\
  \ }}{\hlkwa{let }}{\hlstd{guard p }}{\hlopt{= }}{\hlkwa{if }}{\hlstd{p
  }}{\hlkwa{then }}{\hlstd{return }}{\hlopt{() }}{\hlkwa{else
  }}{\hlstd{fail}}{\hlendline{}}
\end{itemize}

\subsection{Backtracking: computation with choice}

We have seen \tmverbatim{mzero}, i.e. \tmverbatim{fail} in the countdown
problem. What about \tmverbatim{mplus}?

{\hlkwa{let }}{\hlstd{find{\textunderscore}to{\textunderscore}eat n
island{\textunderscore}size num{\textunderscore}islands
empty{\textunderscore}cells }}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlkwa{let }}{\hlstd{honey }}{\hlopt{=
}}{\hlstd{honey{\textunderscore}cells n empty{\textunderscore}cells
}}{\hlkwa{in}}{\hlendline{}}\\
{\hlstd{{\hlendline{}}\\
\ }}{\hlkwa{let rec }}{\hlstd{find{\textunderscore}board s
}}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlcom{(* Printf.printf "find{\textunderscore}board: \%sn"
(state{\textunderscore}str s); *)}}{\hlstd{{\hlendline{}}\\
\ \ \ }}{\hlkwa{match }}{\hlstd{visit{\textunderscore}cell s
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{None
}}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlkwa{perform}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ guard
}}{\hlopt{(}}{\hlstd{s}}{\hlopt{.}}{\hlstd{been{\textunderscore}islands
}}{\hlopt{=
}}{\hlstd{num{\textunderscore}islands}}{\hlopt{);}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ return s}}{\hlopt{.}}{\hlstd{eaten{\hlendline{}}\\
\ \ \ }}{\hlopt{\textbar }}{\hlkwd{Some }}{\hlopt{(}}{\hlstd{cell}}{\hlopt{,
}}{\hlstd{s}}{\hlopt{) ->}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlkwa{perform}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ s }}{\hlopt{<-- }}{\hlstd{find{\textunderscore}island
cell }}{\hlopt{(}}{\hlstd{fresh{\textunderscore}island
s}}{\hlopt{);}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ guard
}}{\hlopt{(}}{\hlstd{s}}{\hlopt{.}}{\hlstd{been{\textunderscore}size
}}{\hlopt{=
}}{\hlstd{island{\textunderscore}size}}{\hlopt{);}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ find{\textunderscore}board s{\hlendline{}}\\
\ }}{\hlkwa{and }}{\hlstd{find{\textunderscore}island current s
}}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{s }}{\hlopt{=
}}{\hlstd{keep{\textunderscore}cell current s
}}{\hlkwa{in}}{\hlstd{{\hlendline{}}\\
\ \ \ neighbors n empty{\textunderscore}cells current{\hlendline{}}\\
\ \ \ {\hlopt{\textbar}}}}{\hlopt{> }}{\hlstd{foldM{\hlendline{}}\\
\ \ \ \ \ \ \ }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{neighbor s
}}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ }}{\hlkwa{if
}}{\hlkwc{CellSet}}{\hlopt{.}}{\hlstd{mem neighbor
s}}{\hlopt{.}}{\hlstd{visited }}{\hlkwa{then }}{\hlstd{return
s{\hlendline{}}\\
\ \ \ \ \ \ \ \ \ }}{\hlkwa{else}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ }}{\hlkwa{let
}}{\hlstd{choose{\textunderscore}eat }}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ \ \ }}{\hlkwa{if
}}{\hlstd{s}}{\hlopt{.}}{\hlstd{more{\textunderscore}to{\textunderscore}eat
}}{\hlopt{<= }}{\hlnum{0 }}{\hlkwa{then }}{\hlstd{fail{\hlendline{}}\\
\ \ \ \ \ \ \ \ \ \ \ \ \ }}{\hlkwa{else }}{\hlstd{return
}}{\hlopt{(}}{\hlstd{eat{\textunderscore}cell neighbor
s}}{\hlopt{)}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ }}{\hlkwa{and
}}{\hlstd{choose{\textunderscore}keep }}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ \ \ }}{\hlkwa{if
}}{\hlstd{s}}{\hlopt{.}}{\hlstd{been{\textunderscore}size }}{\hlopt{>=
}}{\hlstd{island{\textunderscore}size }}{\hlkwa{then
}}{\hlstd{fail{\hlendline{}}\\
\ \ \ \ \ \ \ \ \ \ \ \ \ }}{\hlkwa{else
}}{\hlstd{find{\textunderscore}island neighbor s
}}{\hlkwa{in}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ mplus  choose{\textunderscore}eat
choose{\textunderscore}keep}}{\hlopt{)}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ s }}{\hlkwa{in}}{\hlendline{}}\\
{\hlstd{ \ {\hlendline{}}\\
\ }}{\hlkwa{let }}{\hlstd{cells{\textunderscore}to{\textunderscore}eat
}}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwc{List}}{\hlopt{.}}{\hlstd{length honey }}{\hlopt{-
}}{\hlstd{island{\textunderscore}size }}{\hlopt{*
}}{\hlstd{num{\textunderscore}islands }}{\hlkwa{in}}{\hlendline{}}\\
{\hlstd{ \ find{\textunderscore}board
}}{\hlopt{(}}{\hlstd{init{\textunderscore}state honey
cells{\textunderscore}to{\textunderscore}eat}}{\hlopt{)}}

\section{Monad ``flavors''}

\begin{itemize}
  \item Monads ``wrap around'' a type, but some monads need an additional type
  parameter.
  \begin{itemize}
    \item Usually the additional type does not change while within a monad --
    we will therefore stick to \tmverbatim{'a monad} rather than parameterize
    with an additional type \tmverbatim{('s, 'a) monad}.
  \end{itemize}
  \item As monad-plus shows, things get interesting when we add more
  operations to a basic monad (with \tmverbatim{bind} and
  \tmverbatim{return}).
  \begin{itemize}
    \item Monads with access:
    
    {\hlstd{access }}{\hlopt{: }}{\hlstd{'a}}{\hlstd{ monad }}{\hlopt{->
    }}{\hlstd{'a}}{\hlendline{}}
    
    Example: the lazy monad.
    
    \item Monad-plus, non-deterministic computation:
    
    \tmverbatim{mzero {\hlopt{: }}{\hlstd{'a}}{\hlopt{ }}monad}\\
    \tmverbatim{mplus {\hlopt{: }}{\hlstd{'a}} monad -> {\hlstd{'a}} monad ->
    {\hlstd{'a}}{\hlopt{ }}monad}
    
    \item Monads with environment or state -- parameterized by type
    \tmverbatim{store}:
    
    {\hlstd{get }}{\hlopt{: }}{\hlstd{store monad{\hlendline{}}\\
    put }}{\hlopt{: }}{\hlstd{store }}{\hlopt{-> }}{\hlkwb{unit}}{\hlstd{
    monad}}{\hlendline{}}
    
    There is a ``canonical'' state monad. Similar monads: the writer monad
    (with \tmverbatim{get} called \tmverbatim{listen} and \tmverbatim{put}
    called \tmverbatim{tell}); the reader monad, without \tmverbatim{put}, but
    with \tmverbatim{get} (called \tmverbatim{ask}) and \tmverbatim{local}:
    
    {\hlstd{local }}{\hlopt{: (}}{\hlstd{store }}{\hlopt{->
    }}{\hlstd{store}}{\hlopt{) -> }}{\hlstd{'a }}{\hlstd{monad }}{\hlopt{->
    }}{\hlstd{'a}}{\hlstd{ monad}}{\hlendline{}}
    
    \item The exception / error monads -- parameterized by type
    \tmverbatim{excn}:
    
    {\hlstd{throw }}{\hlopt{: }}{\hlstd{excn }}{\hlopt{-> }}{\hlstd{'a
    }}{\hlstd{monad{\hlendline{}}\\
    {\hlkwa{}}{\hlstd{catch }}{\hlopt{: }}{\hlstd{'a monad }}{\hlopt{->
    (}}{\hlstd{excn }}{\hlopt{-> }}{\hlstd{'a monad}}{\hlopt{) -> }}{\hlstd{'a
    monad}}{\hlendline{}}}}
    
    \item The continuation monad:
    
    {\hlstd{callCC }}{\hlopt{: ((}}{\hlstd{'a }}{\hlopt{-> }}{\hlstd{'b
    monad}}{\hlopt{) -> }}{\hlstd{'a monad}}{\hlopt{) -> }}{\hlstd{'a
    monad}}{\hlendline{}}
    
    We will not cover it.
    
    \item Probabilistic computation:
    
    {\hlstd{choose }}{\hlopt{: }}{\hlkwb{float }}{\hlopt{-> }}{\hlstd{'a monad
    }}{\hlopt{-> }}{\hlstd{'a monad }}{\hlopt{-> }}{\hlstd{'a monad}}
    
    satisfying the laws with $a \oplus_p b$ for \tmverbatim{choose p a b} and
    $pq$ for \tmverbatim{p*.q}, $0 \leqslant p, q \leqslant 1$:
    \begin{eqnarray*}
      a \oplus_0 b & \approx & b\\
      a \oplus_p b & \approx & b \oplus_{1 - p} a\\
      a \oplus_p (b \oplus_q c) & \approx & \left( a \oplus_{\frac{p}{p + q -
      pq}} b \right) \oplus_{p + q - pq} c\\
      a \oplus_p a & \approx & a
    \end{eqnarray*}
    \item Parallel computation as monad with access and parallel bind:
    
    {\hlstd{parallel }}{\hlopt{:}}{\hlendline{}}\\
    {\hlstd{'a monad}}{\hlopt{-> }}{\hlstd{'b monad}}{\hlopt{-> (}}{\hlstd{'a
    }}{\hlopt{-> }}{\hlstd{'b }}{\hlopt{-> }}{\hlstd{'c monad}}{\hlopt{) ->
    }}{\hlstd{'c monad}}
    
    Example: lightweight threads.
  \end{itemize}
\end{itemize}

\section{Interlude: the module system}

\begin{itemize}
  \item I provide below much more information about the module system than we
  need, just for completeness. You can use it as reference.
  \begin{itemize}
    \item Module system details will {\tmstrong{not}} be on the exam -- only
    the structure / signature definitions as discussed in lecture 5.
  \end{itemize}
  \item Modules collect related type definitions and operations together.
  
  \item Module ``values'' are introduced with {\hlkwa{struct }}...{\hlkwa{
  end}} -- structures.
  
  \item Module types are introduced with {\hlkwa{sig }}...{\hlkwa{ end}} --
  signatures.
  \begin{itemize}
    \item A structure is a package of definitions, a signature is an interface
    for packages.
  \end{itemize}
  \item A source file \tmverbatim{source.ml} or \tmverbatim{Source.ml} defines
  a module {\hlkwd{Source}}.
  
  A source file \tmverbatim{source.mli} or \tmverbatim{Source.mli} defines its
  type.
  
  \item We can create the initial interface by entering the module in the
  interactive toplevel or by command \tmverbatim{ocamlc -i source.ml}
  
  \item In the ``toplevel'' -- accurately, module level -- modules are defined
  with {\hlkwa{module }}{\hlkwd{ModuleName }}{\hlopt{=}} ... or {\hlkwa{module
  }}{\hlkwd{ModuleName }}{\hlopt{: }}{\hlkwd{MODULE\_TYPE}}{\hlopt{ =}} ...
  syntax, and module types with {\hlkwa{module type
  }}{\hlkwd{MODULE{\textunderscore}TYPE }}{\hlopt{=}} ... syntax.
  \begin{itemize}
    \item Corresponds to {\hlkwa{let}}\tmverbatim{ v\_name }{\hlopt{=}} ...
    resp. {\hlkwa{let}}\tmverbatim{ v\_name }{\hlopt{:}}{\hlstd{ v\_type
    }}{\hlopt{=}} ... syntax for values and {\hlkwa{type
    }}{\hlstd{v{\textunderscore}type }}{\hlopt{=}} ... syntax for types.
  \end{itemize}
  \item Locally in expressions, modules are defined with {\hlkwa{let module
  }}{\hlkwd{M }}{\hlopt{= }}...{\hlkwa{ in}} ... syntax.
  \begin{itemize}
    \item Corresponds to {\hlkwa{let}}\tmverbatim{ v\_name }{\hlopt{=
    }}...{\hlkwa{ in }}... syntax for values.
  \end{itemize}
  \item The content of a module is made visible in the remainder of another
  module by {\hlkwa{open }}{\hlkwd{Module}}
  \begin{itemize}
    \item Module {\hlkwd{Pervasives}} is initially visible, as if each file
    started with {\hlkwa{open}}{\hlkwd{ Pervasives}}.
  \end{itemize}
  \item The content of a module is made visible locally in an expression with
  {\hlkwa{let~open }}{\hlkwd{Module }}{\hlkwa{in }}... syntax.
  
  \item Content of a module is included into another module -- i.e. made part
  of it -- by {\hlkwa{include }}{\hlkwd{Module}}.
  \begin{itemize}
    \item Just having {\hlkwa{open }}{\hlkwd{Module}} inside {\hlkwd{Parent}}
    does not affect how {\hlkwd{Parent}} looks from outside.
  \end{itemize}
  \item Module functions -- functions from modules to modules -- are called
  {\tmem{func{\nobreak}tors}} {\small{(not the Haskell ones!)}}. The type of
  the parameter has to be given.
  
  {\hlkwa{module }}{\hlkwd{Funct }}{\hlopt{= }}{\hlkwa{functor
  }}{\hlopt{(}}{\hlkwd{Arg }}{\hlopt{: }}{\hlkwa{sig }}...{\hlkwa{
  end}}{\hlopt{) -> }}{\hlkwa{struct }}...{\hlkwa{ end}}
  
  {\hlkwa{module }}{\hlkwd{Funct }}{\hlopt{(}}{\hlkwd{Arg }}{\hlopt{:
  }}{\hlkwa{sig }}...{\hlkwa{ end}}{\hlopt{) = }}{\hlkwa{struct }}...{\hlkwa{
  end}}
  \begin{itemize}
    \item Functors can return functors, i.e. modules can be parameterized by
    multiple modules.
    
    \item Modules are either structures or functors.
    
    \item Different kind of thing than Haskell functors.
  \end{itemize}
  \item Functor application always uses parentheses: {\hlkwd{Funct
  }}{\hlopt{(}}{\hlkwa{struct }}{\hlopt{... }}{\hlkwa{end}}{\hlopt{)}}
  
  \item We can use named module type instead of signature and named module
  instead of structure above.
  
  \item Argument structures can contain more definitions than required.
  
  \item A signature {\hlkwd{MODULE{\textunderscore}TYPE }}{\hlkwa{with type
  }}{\hlstd{t\_name}}{\hlopt{ =}} ... is like
  {\hlkwd{MODULE{\textunderscore}TYPE }}but with \tmverbatim{t\_name} made
  more specific.
  
  \item We can also include signatures into other signatures, by
  {\hlkwa{include }}{\hlkwd{MODULE{\textunderscore}TYPE}}.
  \begin{itemize}
    \item {\hlkwa{include }}{\hlkwd{MODULE{\textunderscore}TYPE }}{\hlkwa{with
    type }}{\hlstd{t{\textunderscore}name }}{\hlopt{:= }}... will substitute
    type \tmverbatim{t\_name} with provided type.
  \end{itemize}
  \item Modules, just as expressions, are {\tmstrong{not}} recursive or
  mutually recursive by default. Syntax for recursive modules:\\
  {\hlkwa{module rec }}{\hlkwd{ModuleName }}{\hlopt{:
  }}{\hlkwd{MODULE{\textunderscore}TYPE }}{\hlopt{= }}...{\hlkwa{ and }}...
  
  \item We can recover the type -- i.e. signature -- of a module by\\
  {\hlkwa{module type of }}{\hlkwd{Module}}
  
  \item Finally, we can pass around modules in normal functions.
  \begin{itemize}
    \item {\hlopt{(}}{\hlkwa{module }}{\hlkwd{Module}}{\hlopt{)}} is an
    expression
    
    \item {\hlopt{(}}{\hlkwa{val
    }}{\hlstd{module{\textunderscore}v}}{\hlopt{)}} is a module
    
    \item \# {\hlkwa{module type }}{\hlkwd{T }}{\hlopt{= }}{\hlkwa{sig val
    }}{\hlstd{g }}{\hlopt{: }}{\hlkwb{int }}{\hlopt{-> }}{\hlkwb{int
    }}{\hlkwa{end}}{\hlendline{}}\\
    {\hlkwa{let }}{\hlstd{f mod{\textunderscore}v x
    }}{\hlopt{=}}{\hlendline{}}\\
    {\hlstd{ \ }}{\hlkwa{let module }}{\hlkwd{M }}{\hlopt{= (}}{\hlkwa{val
    }}{\hlstd{mod{\textunderscore}v }}{\hlopt{: }}{\hlkwd{T}}{\hlopt{)
    }}{\hlkwa{in}}{\hlendline{}}\\
    {\hlstd{ \ }}{\hlkwc{M}}{\hlopt{.}}{\hlstd{g x}}{\hlopt{;;}}{\hlendline{}}
    
    {\hlkwa{val }}{\hlstd{f }}{\hlopt{: (}}{\hlkwa{module
    }}{\hlkwd{T}}{\hlopt{) -> }}{\hlkwb{int }}{\hlopt{-> }}{\hlkwb{int
    }}{\hlopt{= <}}{\hlkwa{fun}}{\hlopt{>}}{\hlendline{}}
    
    \# {\hlkwa{let }}{\hlstd{test }}{\hlopt{= }}{\hlstd{f
    }}{\hlopt{(}}{\hlkwa{module struct let }}{\hlstd{g i }}{\hlopt{=
    }}{\hlstd{i}}{\hlopt{*}}{\hlstd{i }}{\hlkwa{end }}{\hlopt{:
    }}{\hlkwd{T}}{\hlopt{);;}}{\hlendline{}}
    
    {\hlkwa{val }}{\hlstd{test }}{\hlopt{: }}{\hlkwb{int }}{\hlopt{->
    }}{\hlkwb{int }}{\hlopt{= <}}{\hlkwa{fun}}{\hlopt{>}}{\hlendline{}}
  \end{itemize}
\end{itemize}

\section{The two metaphors}

\begin{itemize}
  \item Monads can be seen as {\tmstrong{containers}}: \tmverbatim{'a monad}
  contains stuff of type \tmverbatim{'a}
  
  \item and as {\tmstrong{computation}}: \tmverbatim{'a monad} is a special
  way to compute \tmverbatim{'a}.
  \begin{itemize}
    \item A monad fixes the sequence of computing steps -- unless it is a
    fancy monad like parallel computation monad.
  \end{itemize}
\end{itemize}

\subsection{Monads as containers}

\begin{itemize}
  \item A monad is a {\tmem{quarantine container}}:
  \begin{itemize}
    \item we can put something into the container with \tmverbatim{return}
    
    \item we can operate on it, but the result needs to stay in the container
    
    {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{lift f m }}{\hlopt{= }}{\hlkwa{perform
    }}{\hlstd{x }}{\hlopt{<-- }}{\hlstd{m}}{\hlopt{; }}{\hlstd{return
    }}{\hlopt{(}}{\hlstd{f x}}{\hlopt{)}}{\hlendline{}}\\
    {\hlkwa{ \ val }}{\hlstd{lift }}{\hlopt{: (}}{\hlstd{'a }}{\hlopt{->
    }}{\hlstd{'b}}{\hlopt{) -> }}{\hlstd{'a}}{\hlopt{ }}{\hlstd{monad
    }}{\hlopt{-> }}{\hlstd{'b}}{\hlstd{ monad}}
    
    \item We can deactivate-unwrap the quarantine container but only when it
    is in another container so the quarantine is not broken
    
    {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{join m }}{\hlopt{= }}{\hlkwa{perform
    }}{\hlstd{x }}{\hlopt{<-- }}{\hlstd{m}}{\hlopt{;
    }}{\hlstd{x}}{\hlendline{}}\\
    {\hlstd{ }}{\hlkwa{ val }}{\hlstd{join }}{\hlopt{: (}}{\hlstd{'a}}{\hlopt{
    }}{\hlstd{monad}}{\hlopt{) }}{\hlstd{monad }}{\hlopt{->
    }}{\hlstd{'a}}{\hlstd{ monad}}
  \end{itemize}
  \item The quarantine container for a {\tmstrong{monad-plus}} is more like
  other containers: it can be empty, or contain multiple elements.
  
  \item Monads with access allow us to extract the resulting element from the
  container, other monads provide a \tmverbatim{run} operation that exposes
  ``what really happened behind the quarantine''.
\end{itemize}

\subsection{Monads as computation}

\begin{itemize}
  \item To compute the result, {\hlkwa{perform}} instructions, naming partial
  results.
  
  \item Physical metaphor: {\tmstrong{assembly line}}
  
  \raisebox{-0.479429642114323\height}{\includegraphics[width=20.1878197560016cm,height=7.31627967991604cm]{functional-lecture08-via-latex-1.pdf}}
  
  {\hlkwa{let }}{\hlstd{assemblyLine w }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ \ }}{\hlkwa{perform}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ c }}{\hlopt{<-- }}{\hlstd{makeChopsticks w{\hlendline{}}\\
  \ \ \ \ c' }}{\hlopt{<-- }}{\hlstd{polishChopsticks c{\hlendline{}}\\
  \ \ \ \ c'' }}{\hlopt{<-- }}{\hlstd{wrapChopsticks c'{\hlendline{}}\\
  \ \ \ \ return c''}}{\hlendline{}}
  
  \item Any expression can be spread over a monad, e.g. for $\lambda$-terms:
  \begin{eqnarray*}
    \llbracket N \rrbracket = & \tmop{return} N & \text{(constant)}\\
    \llbracket x \rrbracket = & \tmop{return} x & \text{(variable)}\\
    \llbracket \lambda x.a \rrbracket = & \tmop{return} (\lambda x. \llbracket
    a \rrbracket) & \text{(function)}\\
    \llbracket \tmop{let} x = a \tmop{in} b \rrbracket = & \tmop{bind}
    \llbracket a \rrbracket  (\lambda x. \llbracket b \rrbracket) &
    \text{(local definition)}\\
    \llbracket a b \rrbracket = & \tmop{bind} \llbracket a \rrbracket 
    (\lambda v_a . \tmop{bind} \llbracket b \rrbracket  (\lambda v_b .v_a
    v_b)) & \text{(application)}
  \end{eqnarray*}
  \item When an expression is spread over a monad, its computation can be
  monitored or affected without modifying the expression.
\end{itemize}


\section{Monad classes}

\begin{itemize}
  \item To implement a monad we need to provide the implementation type,
  \tmverbatim{return} and \tmverbatim{bind} operations.
  
  {\hlkwa{module type }}{\hlkwd{MONAD }}{\hlopt{=
  }}{\hlkwa{sig}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{type }}{\hlstd{'a t{\hlendline{}}\\
  \ }}{\hlkwa{val }}{\hlstd{return }}{\hlopt{: }}{\hlstd{'a }}{\hlopt{->
  }}{\hlstd{'a t{\hlendline{}}\\
  \ }}{\hlkwa{val }}{\hlstd{bind }}{\hlopt{: }}{\hlstd{'a t }}{\hlopt{->
  (}}{\hlstd{'a }}{\hlopt{-> }}{\hlstd{'b t}}{\hlopt{) -> }}{\hlstd{'b
  t}}{\hlendline{}}\\
  {\hlkwa{end}}{\hlendline{}}
  \begin{itemize}
    \item Alternatively we could start from \tmverbatim{return},
    \tmverbatim{lift} and \tmverbatim{join} operations.
    
    {\small{\item For monads that change their additional type parameter we
    could define:
    
    {\hlkwa{module type }}{\hlkwd{MONAD }}{\hlopt{=
    }}{\hlkwa{sig}}{\hlendline{}}\\
    {\hlstd{ \ }}{\hlkwa{type }}{\hlopt{(}}{\hlstd{'s}}{\hlopt{,
    }}{\hlstd{'a}}{\hlopt{) }}{\hlstd{t{\hlendline{}}\\
    \ }}{\hlkwa{val }}{\hlstd{return }}{\hlopt{: }}{\hlstd{'a }}{\hlopt{->
    (}}{\hlstd{'s}}{\hlopt{, }}{\hlstd{'a}}{\hlopt{)
    }}{\hlstd{t{\hlendline{}}\\
    \ }}{\hlkwa{val }}{\hlstd{bind }}{\hlopt{:}}{\hlendline{}}\\
    {\hlstd{ \ \ \ }}{\hlopt{(}}{\hlstd{'s}}{\hlopt{, }}{\hlstd{'a}}{\hlopt{)
    }}{\hlstd{t }}{\hlopt{-> (}}{\hlstd{'a }}{\hlopt{->
    (}}{\hlstd{'s}}{\hlopt{, }}{\hlstd{'b}}{\hlopt{) }}{\hlstd{t}}{\hlopt{) ->
    (}}{\hlstd{'s}}{\hlopt{, }}{\hlstd{'b}}{\hlopt{)
    }}{\hlstd{t}}{\hlendline{}}\\
    {\hlkwa{end}}{\hlendline{}}}}
    
    \ 
  \end{itemize}
  \item Based on just these two operations, we can define a whole suite of
  general-purpose functions. We look at just a tiny selection.
  
  {\hlkwa{module type }}{\hlkwd{MONAD{\textunderscore}OPS }}{\hlopt{=
  }}{\hlkwa{sig}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{type }}{\hlstd{'a monad{\hlendline{}}\\
  \ }}{\hlkwa{include }}{\hlkwd{MONAD }}{\hlkwa{with type }}{\hlstd{'a t
  }}{\hlopt{:= }}{\hlstd{'a monad{\hlendline{}}\\
  \ }}{\hlkwa{val }}{\hlopt{( >>= ) :}}{\hlstd{'a monad }}{\hlopt{->
  (}}{\hlstd{'a }}{\hlopt{-> }}{\hlstd{'b monad}}{\hlopt{) -> }}{\hlstd{'b
  monad{\hlendline{}}\\
  \ }}{\hlkwa{val }}{\hlstd{foldM }}{\hlopt{:}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlopt{(}}{\hlstd{'a }}{\hlopt{-> }}{\hlstd{'b
  }}{\hlopt{-> }}{\hlstd{'a monad}}{\hlopt{) -> }}{\hlstd{'a }}{\hlopt{->
  }}{\hlstd{'b list }}{\hlopt{-> }}{\hlstd{'a monad{\hlendline{}}\\
  \ }}{\hlkwa{val }}{\hlstd{whenM }}{\hlopt{: }}{\hlkwb{bool }}{\hlopt{->
  }}{\hlkwb{unit }}{\hlstd{monad }}{\hlopt{-> }}{\hlkwb{unit
  }}{\hlstd{monad{\hlendline{}}\\
  \ }}{\hlkwa{val }}{\hlstd{lift }}{\hlopt{: (}}{\hlstd{'a }}{\hlopt{->
  }}{\hlstd{'b}}{\hlopt{) -> }}{\hlstd{'a monad }}{\hlopt{-> }}\tmverbatim{'b
  monad}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{val
  }}{\hlopt{(>>}}{\hlstd{{\hlopt{\textbar}}}}{\hlopt{) : }}{\hlstd{'a monad
  }}{\hlopt{-> (}}{\hlstd{'a }}{\hlopt{-> }}{\hlstd{'b}}{\hlopt{) ->
  }}{\hlstd{'b monad}}{\hlendline{}}\\
  \tmverbatim{ \ }{\hlkwa{val }}{\hlstd{join }}{\hlopt{: }}{\hlstd{'a monad
  monad }}{\hlopt{-> }}{\hlstd{'a monad{\hlendline{}}\\
  \ }}{\hlkwa{val }}{\hlopt{( >=> ) :}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlopt{(}}{\hlstd{'a }}{\hlopt{->}}{\hlstd{'b
  monad}}{\hlopt{) -> (}}{\hlstd{'b }}{\hlopt{->}}{\hlstd{'c monad}}{\hlopt{)
  -> }}{\hlstd{'a }}{\hlopt{-> }}{\hlstd{'c monad}}{\hlendline{}}\\
  {\hlkwa{end}}{\hlendline{}}\\
  
  
  \item Given a particular implementation, we define these functions.
  
  {\hlkwa{module }}{\hlkwd{MonadOps }}{\hlopt{(}}{\hlkwd{M }}{\hlopt{:
  }}{\hlkwd{MONAD}}{\hlopt{) = }}{\hlkwa{struct}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{open }}{\hlkwd{M}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{type }}{\hlstd{'a}}{\hlstd{ monad }}{\hlopt{=
  }}{\hlstd{'a}}{\hlstd{ t{\hlendline{}}\\
  \ }}{\hlkwa{let }}{\hlstd{run x }}{\hlopt{= }}{\hlstd{x{\hlendline{}}\\
  \ }}{\hlkwa{let }}{\hlopt{(>>=) }}{\hlstd{a b }}{\hlopt{= }}{\hlstd{bind a
  b{\hlendline{}}\\
  \ }}{\hlkwa{let rec }}{\hlstd{foldM f a }}{\hlopt{=
  }}{\hlkwa{function}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlopt{\textbar  [] -> }}{\hlstd{return a{\hlendline{}}\\
  \ \ \ {\hlopt{\textbar}} x}}{\hlopt{::}}{\hlstd{xs }}{\hlopt{-> }}{\hlstd{f
  a x }}{\hlopt{>>= }}{\hlkwa{fun }}{\hlstd{a' }}{\hlopt{-> }}{\hlstd{foldM f
  a' xs{\hlendline{}}\\
  \ }}{\hlkwa{let }}{\hlstd{whenM p s }}{\hlopt{= }}{\hlkwa{if }}{\hlstd{p
  }}{\hlkwa{then }}{\hlstd{s }}{\hlkwa{else }}{\hlstd{return
  }}{\hlopt{()}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{lift f m }}{\hlopt{= }}{\hlkwa{perform
  }}{\hlstd{x }}{\hlopt{<-- }}{\hlstd{m}}{\hlopt{; }}{\hlstd{return
  }}{\hlopt{(}}{\hlstd{f x}}{\hlopt{)}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let
  }}{\hlopt{(>>}}{\hlstd{{\hlopt{\textbar}}}}{\hlopt{) }}{\hlstd{a b
  }}{\hlopt{= }}{\hlstd{lift b a}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{join m }}{\hlopt{= }}{\hlkwa{perform
  }}{\hlstd{x }}{\hlopt{<-- }}{\hlstd{m}}{\hlopt{; }}{\hlstd{x{\hlendline{}}\\
  \ }}{\hlkwa{let }}{\hlopt{(>=>) }}{\hlstd{f g }}{\hlopt{= }}{\hlkwa{fun
  }}{\hlstd{x }}{\hlopt{-> }}{\hlstd{f x }}{\hlopt{>>=
  }}{\hlstd{g}}{\hlendline{}}\\
  {\hlkwa{end}}{\hlendline{}}
  
  \item We make the monad ``safe'' by keeping its type abstract. But
  \tmverbatim{run} exposes ``what really happened''.
  
  {\hlkwa{module }}{\hlkwd{Monad }}{\hlopt{(}}{\hlkwd{M }}{\hlopt{:
  }}{\hlkwd{MONAD}}{\hlopt{) :}}{\hlendline{}}\\
  {\hlkwa{sig}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{include
  }}{\hlkwd{MONAD{\textunderscore}OPS}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{val }}{\hlstd{run }}{\hlopt{: }}{\hlstd{'a}}{\hlstd{
  monad }}{\hlopt{-> }}{\hlstd{'a}}{\hlkwc{
  M}}{\hlopt{.}}{\hlstd{t}}{\hlendline{}}\\
  {\hlkwa{end }}{\hlopt{= }}{\hlkwa{struct}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{include }}{\hlkwd{M}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{include
  }}{\hlkwd{MonadOps}}{\hlopt{(}}{\hlkwd{M}}{\hlopt{)}}{\hlendline{}}\\
  {\hlkwa{end}}{\hlendline{}}
  \begin{itemize}
    \item Our \tmverbatim{run} function does not do anything at all. Often
    more useful functions are called \tmverbatim{run} but then they need to be
    defined for each implementation separately. Our \tmverbatim{access}
    operation (see section on monad flavors) is often called \tmverbatim{run}.
  \end{itemize}
  \item The monad-plus class of monads has a lot of implementations. They need
  to provide \tmverbatim{mzero} and \tmverbatim{mplus}.
  
  {\hlkwa{module type }}{\hlkwd{MONAD{\textunderscore}PLUS }}{\hlopt{=
  }}{\hlkwa{sig}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{include }}{\hlkwd{MONAD}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{val }}{\hlstd{mzero }}{\hlopt{: }}{\hlstd{'a
  t{\hlendline{}}\\
  \ }}{\hlkwa{val }}{\hlstd{mplus }}{\hlopt{: }}{\hlstd{'a t }}{\hlopt{->
  }}{\hlstd{'a t }}{\hlopt{-> }}{\hlstd{'a t}}{\hlendline{}}\\
  {\hlkwa{end}}{\hlendline{}}{\hlendline{}}
  
  \item Monad-plus class also has its general-purpose functions:
  
  {\hlkwa{module type }}{\hlkwd{MONAD{\textunderscore}PLUS{\textunderscore}OPS
  }}{\hlopt{= }}{\hlkwa{sig}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{include
  }}{\hlkwd{MONAD{\textunderscore}OPS}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{val }}{\hlstd{mzero }}{\hlopt{: }}{\hlstd{'a
  monad{\hlendline{}}\\
  \ }}{\hlkwa{val }}{\hlstd{mplus }}{\hlopt{: }}{\hlstd{'a monad }}{\hlopt{->
  }}{\hlstd{'a monad }}{\hlopt{-> }}{\hlstd{'a monad{\hlendline{}}\\
  \ }}{\hlkwa{val }}{\hlstd{fail }}{\hlopt{: }}{\hlstd{'a
  monad{\hlendline{}}\\
  \ }}{\hlkwa{val }}{\hlopt{(++) : }}{\hlstd{'a monad }}{\hlopt{->
  }}{\hlstd{'a monad }}{\hlopt{-> }}{\hlstd{'a monad{\hlendline{}}\\
  \ }}{\hlkwa{val }}{\hlstd{guard }}{\hlopt{: }}{\hlkwb{bool }}{\hlopt{->
  }}{\hlkwb{unit }}{\hlstd{monad{\hlendline{}}\\
  \ }}{\hlkwa{val }}{\hlstd{msum{\textunderscore}map }}{\hlopt{:
  (}}{\hlstd{'a }}{\hlopt{-> }}{\hlstd{'b monad}}{\hlopt{) -> }}{\hlstd{'a
  list }}{\hlopt{-> }}{\hlstd{'b monad}}{\hlendline{}}\\
  {\hlkwa{end}}{\hlendline{}}
  
  \item We again separate the ``implementation'' and the ``interface''.
  
  {\hlkwa{module }}{\hlkwd{MonadPlusOps }}{\hlopt{(}}{\hlkwd{M }}{\hlopt{:
  }}{\hlkwd{MONAD{\textunderscore}PLUS}}{\hlopt{) =
  }}{\hlkwa{struct}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{open }}{\hlkwd{M}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{include
  }}{\hlkwd{MonadOps}}{\hlopt{(}}{\hlkwd{M}}{\hlopt{)}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{fail }}{\hlopt{=
  }}{\hlstd{mzero{\hlendline{}}\\
  \ }}{\hlkwa{let }}{\hlopt{(++) }}{\hlstd{a b }}{\hlopt{= }}{\hlstd{mplus a
  b{\hlendline{}}\\
  \ }}{\hlkwa{let }}{\hlstd{guard p }}{\hlopt{= }}{\hlkwa{if }}{\hlstd{p
  }}{\hlkwa{then }}{\hlstd{return }}{\hlopt{() }}{\hlkwa{else
  }}{\hlstd{fail{\hlendline{}}\\
  \ }}{\hlkwa{let }}{\hlstd{msum{\textunderscore}map f l }}{\hlopt{=
  }}{\hlkwc{List}}{\hlopt{.}}{\hlstd{fold{\textunderscore}right{\hlendline{}}\\
  \ \ \ }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{a acc }}{\hlopt{-> }}{\hlstd{mplus
  }}{\hlopt{(}}{\hlstd{f a}}{\hlopt{) }}{\hlstd{acc}}{\hlopt{) }}{\hlstd{l
  mzero}}{\hlendline{}}\\
  {\hlkwa{end}}{\hlendline{}}
  
  {\hlkwa{module }}{\hlkwd{MonadPlus }}{\hlopt{(}}{\hlkwd{M }}{\hlopt{:
  }}{\hlkwd{MONAD{\textunderscore}PLUS}}{\hlopt{) :}}{\hlendline{}}\\
  {\hlkwa{sig}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{include
  }}{\hlkwd{MONAD{\textunderscore}PLUS{\textunderscore}OPS}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{val }}{\hlstd{run }}{\hlopt{: }}{\hlstd{'a monad
  }}{\hlopt{-> }}{\hlstd{'a
  }}{\hlkwc{M}}{\hlopt{.}}{\hlstd{t}}{\hlendline{}}\\
  {\hlkwa{end }}{\hlopt{= }}{\hlkwa{struct}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{include }}{\hlkwd{M}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{include
  }}{\hlkwd{MonadPlusOps}}{\hlopt{(}}{\hlkwd{M}}{\hlopt{)}}{\hlendline{}}\\
  {\hlkwa{end}}{\hlendline{}}\\
  
  
  \item We also need a class for computations with state.
  
  {\hlkwa{module type }}{\hlkwd{STATE }}{\hlopt{=
  }}{\hlkwa{sig}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{type }}{\hlstd{store{\hlendline{}}\\
  \ }}{\hlkwa{type }}{\hlstd{'a t{\hlendline{}}\\
  \ }}{\hlkwa{val }}{\hlstd{get }}{\hlopt{: }}{\hlstd{store t{\hlendline{}}\\
  \ }}{\hlkwa{val }}{\hlstd{put }}{\hlopt{: }}{\hlstd{store }}{\hlopt{->
  }}{\hlkwb{unit }}{\hlstd{t}}{\hlendline{}}\\
  {\hlkwa{end}}{\hlendline{}}
  
  The purpose of this signature is inclusion in other signatures.
\end{itemize}

\section{Monad instances}

\begin{itemize}
  \item We do not define a class for monads with access since accessing means
  running the monad, not useful while in the monad.
  
  \item Notation for laziness heavy? Try a monad! (Monads with access.)
  
  {\hlkwa{module }}{\hlkwd{LazyM }}{\hlopt{= }}{\hlkwd{Monad
  }}{\hlopt{(}}{\hlkwa{struct}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{type }}{\hlstd{'a}}{\hlstd{ t }}{\hlopt{= }}{\hlstd{'a
  }}{\hlkwc{Lazy}}{\hlopt{.}}{\hlstd{t{\hlendline{}}\\
  \ }}{\hlkwa{let }}{\hlstd{bind a b }}{\hlopt{= }}{\hlkwa{lazy
  }}{\hlopt{(}}{\hlkwc{Lazy}}{\hlopt{.}}{\hlstd{force }}{\hlopt{(}}{\hlstd{b
  }}{\hlopt{(}}{\hlkwc{Lazy}}{\hlopt{.}}{\hlstd{force
  a}}{\hlopt{)))}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{return a }}{\hlopt{= }}{\hlkwa{lazy
  }}{\hlstd{a}}{\hlendline{}}\\
  {\hlkwa{end}}{\hlopt{)}}{\hlendline{}}
  
  {\hlkwa{let }}{\hlstd{laccess m }}{\hlopt{=
  }}{\hlkwc{Lazy}}{\hlopt{.}}{\hlstd{force
  }}{\hlopt{(}}{\hlkwc{LazyM}}{\hlopt{.}}{\hlstd{run
  m}}{\hlopt{)}}{\hlendline{}}\\
  
  
  \item Our resident list monad. (Monad-plus.)
  
  {\hlkwa{module }}{\hlkwd{ListM }}{\hlopt{= }}{\hlkwd{MonadPlus
  }}{\hlopt{(}}{\hlkwa{struct}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{type }}{\hlstd{'a}}{\hlstd{ t }}{\hlopt{= }}{\hlstd{'a
  list{\hlendline{}}\\
  \ }}{\hlkwa{let }}{\hlstd{bind a b }}{\hlopt{=
  }}{\hlstd{concat{\textunderscore}map b a{\hlendline{}}\\
  \ }}{\hlkwa{let }}{\hlstd{return a }}{\hlopt{=
  [}}{\hlstd{a}}{\hlopt{]}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{mzero }}{\hlopt{= []}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{mplus }}{\hlopt{=
  }}{\hlkwc{List}}{\hlopt{.}}{\hlstd{append}}{\hlendline{}}\\
  {\hlkwa{end}}{\hlopt{)}}{\hlendline{}}
\end{itemize}

\subsection{Backtracking parameterized by monad-plus }

{\hlkwa{module }}{\hlkwd{Countdown }}{\hlopt{(}}{\hlkwd{M }}{\hlopt{:
}}{\hlkwd{MONAD{\textunderscore}PLUS{\textunderscore}OPS}}{\hlopt{) =
}}{\hlkwa{struct}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlkwa{open }}{\hlkwd{M}}{\hlendline{Open the module to make
monad operations visible.}}

{\hlkwa{ \ let rec }}{\hlstd{insert x }}{\hlopt{=
}}{\hlkwa{function}}{\hlendline{All choice-introducing operations}}\\
{\hlstd{ \ \ \ }}{\hlopt{\textbar  [] -> }}{\hlstd{return
}}{\hlopt{[}}{\hlstd{x}}{\hlopt{]}}{\hlendline{need to happen in the
monad.}}\\
{\hlstd{ \ \ \ {\hlopt{\textbar}} y}}{\hlopt{::}}{\hlstd{ys }}{\hlkwa{as
}}{\hlstd{xs }}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ return
}}{\hlopt{(}}{\hlstd{x}}{\hlopt{::}}{\hlstd{xs}}{\hlopt{) ++}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ }}{\hlkwa{perform }}{\hlstd{xys }}{\hlopt{<--
}}{\hlstd{insert x ys}}{\hlopt{; }}{\hlstd{return
}}{\hlopt{(}}{\hlstd{y}}{\hlopt{::}}{\hlstd{xys}}{\hlopt{)}}{\hlendline{}}

{\hlstd{ \ }}{\hlkwa{let rec }}{\hlstd{choices }}{\hlopt{=
}}{\hlkwa{function}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{\textbar  [] -> }}{\hlstd{return
}}{\hlopt{[]}}{\hlendline{}}\\
{\hlstd{ \ \ \ {\hlopt{\textbar}} x}}{\hlopt{::}}{\hlstd{xs }}{\hlopt{->
}}{\hlkwa{perform}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ cxs }}{\hlopt{<-- }}{\hlstd{choices
xs}}{\hlopt{;}}{\hlendline{Choosing which numbers in what order}}\\
{\hlstd{ \ \ \ \ \ \ \ return cxs }}{\hlopt{++ }}\tmverbatim{insert x
cxs}{\hlendline{and now whether with or without \tmverbatim{x}.}}

\tmverbatim{ \ }{\hlkwa{type }}{\hlstd{op }}{\hlopt{= }}{\hlkwd{Add
}}{\hlopt{\textbar }}{\hlkwd{Sub }}{\hlopt{\textbar }}{\hlkwd{Mul
}}{\hlopt{\textbar }}{\hlkwd{Div}}{\hlendline{}}

{\hlkwa{ \ let }}{\hlstd{apply op x y }}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwa{match }}{\hlstd{op }}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Add }}{\hlopt{-> }}{\hlstd{x
}}{\hlopt{+ }}{\hlstd{y{\hlendline{}}\\
\ \ \ }}{\hlopt{\textbar }}{\hlkwd{Sub }}{\hlopt{-> }}{\hlstd{x }}{\hlopt{-
}}{\hlstd{y{\hlendline{}}\\
\ \ \ }}{\hlopt{\textbar }}{\hlkwd{Mul }}{\hlopt{-> }}{\hlstd{x }}{\hlopt{*
}}{\hlstd{y{\hlendline{}}\\
\ \ \ }}{\hlopt{\textbar }}{\hlkwd{Div }}{\hlopt{-> }}{\hlstd{x }}{\hlopt{/
}}{\hlstd{y{\hlendline{}} \ }}

{\hlkwa{ \ let }}{\hlstd{valid op x y }}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwa{match }}{\hlstd{op }}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Add }}{\hlopt{-> }}{\hlstd{x
}}{\hlopt{<= }}{\hlstd{y{\hlendline{}}\\
\ \ \ }}{\hlopt{\textbar }}{\hlkwd{Sub }}{\hlopt{-> }}{\hlstd{x }}{\hlopt{>
}}{\hlstd{y{\hlendline{}}\\
\ \ \ }}{\hlopt{\textbar }}{\hlkwd{Mul }}{\hlopt{-> }}{\hlstd{x }}{\hlopt{<=
}}{\hlstd{y }}{\hlopt{\&\& }}{\hlstd{x }}{\hlopt{<> }}{\hlnum{1 }}{\hlopt{\&\&
}}{\hlstd{y }}{\hlopt{<> }}{\hlnum{1}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Div }}{\hlopt{-> }}{\hlstd{x
}}{\hlkwa{mod }}{\hlstd{y }}{\hlopt{= }}{\hlnum{0 }}{\hlopt{\&\& }}{\hlstd{y
}}{\hlopt{<> }}{\hlnum{1}}{\hlendline{}}

{\hlkwa{ \ type }}{\hlstd{expr }}{\hlopt{= }}{\hlkwd{Val }}{\hlkwa{of
}}{\hlkwb{int }}{\hlopt{\textbar }}{\hlkwd{App }}{\hlkwa{of }}{\hlstd{op
}}{\hlopt{* }}{\hlstd{expr }}{\hlopt{* }}{\hlstd{expr{\hlendline{}} \ }}

{\hlkwa{ \ let }}{\hlstd{op2str }}{\hlopt{=
}}{\hlkwa{function}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Add }}{\hlopt{->
}}{\hlstr{"+"}}{\hlstd{ {\hlopt{\textbar}} }}{\hlkwd{Sub }}{\hlopt{->
}}{\hlstr{"-"}}{\hlstd{ {\hlopt{\textbar}} }}{\hlkwd{Mul }}{\hlopt{->
}}{\hlstr{"*"}}{\hlstd{ {\hlopt{\textbar}} }}{\hlkwd{Div }}{\hlopt{->
}}{\hlstr{"/"}}{\hlstd{{\hlendline{}}\\
\ }}{\hlkwa{let rec }}{\hlstd{expr2str }}{\hlopt{=
}}{\hlkwa{function}}{\hlendline{We will provide solutions as strings.}}\\
{\hlstd{ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Val }}{\hlstd{n }}{\hlopt{->
}}{\hlstd{string{\textunderscore}of{\textunderscore}int n{\hlendline{}}\\
\ \ \ }}{\hlopt{\textbar }}{\hlkwd{App
}}{\hlopt{(}}{\hlstd{op}}{\hlopt{,}}{\hlstd{l}}{\hlopt{,}}{\hlstd{r}}{\hlopt{)
->}}{\hlstr{"("}}{\hlstd{{\textasciicircum}expr2str l{\textasciicircum}op2str
op{\textasciicircum}expr2str r{\textasciicircum}}}{\hlstr{")"}}

{\hlkwa{ \ let }}{\hlstd{combine
}}{\hlopt{(}}{\hlstd{l}}{\hlopt{,}}{\hlstd{x}}{\hlopt{)
(}}{\hlstd{r}}{\hlopt{,}}{\hlstd{y}}{\hlopt{) }}{\hlstd{o }}{\hlopt{=
}}{\hlkwa{perform}}{\hlendline{Try out an operator.}}\\
{\hlstd{ \ \ \ \ \ guard }}{\hlopt{(}}{\hlstd{valid o x
y}}{\hlopt{);}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ return }}{\hlopt{(}}{\hlkwd{App
}}{\hlopt{(}}{\hlstd{o}}{\hlopt{,}}{\hlstd{l}}{\hlopt{,}}{\hlstd{r}}{\hlopt{),
}}{\hlstd{apply o x y}}{\hlopt{)}}{\hlendline{}}

{\hlkwa{ \ let }}{\hlstd{split l }}{\hlopt{=}}{\hlendline{Another choice:
which numbers go into which argument.}}\\
{\hlstd{ \ \ \ }}{\hlkwa{let rec }}{\hlstd{aux lhs }}{\hlopt{=
}}{\hlkwa{function}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlopt{\textbar  [] \textbar 
[}}{\hlstd{{\textunderscore}}}{\hlopt{] -> }}\tmverbatim{fail}{\hlendline{Both
arguments need numbers.}}\\
\tmverbatim{ \ \ \ \ \ }{\hlopt{\textbar  [}}{\hlstd{y}}{\hlopt{;
}}{\hlstd{z}}{\hlopt{] -> }}{\hlstd{return
}}{\hlopt{(}}{\hlkwc{List}}{\hlopt{.}}{\hlstd{rev
}}{\hlopt{(}}{\hlstd{y}}{\hlopt{::}}{\hlstd{lhs}}{\hlopt{),
[}}{\hlstd{z}}{\hlopt{])}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ {\hlopt{\textbar}} hd}}{\hlopt{::}}{\hlstd{rhs
}}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ }}{\hlkwa{let }}{\hlstd{lhs }}{\hlopt{=
}}{\hlstd{hd}}{\hlopt{::}}{\hlstd{lhs }}{\hlkwa{in}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ return
}}{\hlopt{(}}{\hlkwc{List}}{\hlopt{.}}{\hlstd{rev lhs}}{\hlopt{,
}}{\hlstd{rhs}}{\hlopt{)}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ }}{\hlopt{++ }}{\hlstd{aux lhs rhs
}}{\hlkwa{in}}{\hlendline{}}\\
{\hlstd{ \ \ \ aux }}{\hlopt{[] }}{\hlstd{l{\hlendline{}} \ }}

{\hlkwa{ \ let rec }}{\hlstd{results }}{\hlopt{=
}}{\hlkwa{function}}{\hlendline{Build possible expressions once numbers}}\\
{\hlstd{ \ \ \ }}{\hlopt{\textbar  [] -> }}\tmverbatim{fail}{\hlendline{have
been picked.}}\\
\tmverbatim{ \ \ \ }{\hlopt{\textbar  [}}{\hlstd{n}}{\hlopt{] ->
}}{\hlkwa{perform}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ guard }}{\hlopt{(}}{\hlstd{n }}{\hlopt{>
}}{\hlnum{0}}{\hlopt{); }}{\hlstd{return }}{\hlopt{(}}{\hlkwd{Val
}}{\hlstd{n}}{\hlopt{, }}{\hlstd{n}}{\hlopt{)}}{\hlendline{}}\\
{\hlstd{ \ \ \ {\hlopt{\textbar}} ns }}{\hlopt{->
}}{\hlkwa{perform}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ }}{\hlopt{(}}{\hlstd{ls}}{\hlopt{,
}}{\hlstd{rs}}{\hlopt{) <-- }}{\hlstd{split ns}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ lx }}{\hlopt{<-- }}{\hlstd{results
ls}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ ly }}{\hlopt{<-- }}{\hlstd{results
rs}}{\hlopt{;}}{\hlendline{Collect solutions using each operator.}}\\
{\hlstd{ \ \ \ \ \ \ \ msum{\textunderscore}map }}{\hlopt{(}}{\hlstd{combine
lx ly}}{\hlopt{) [}}{\hlkwd{Add}}{\hlopt{; }}{\hlkwd{Sub}}{\hlopt{;
}}{\hlkwd{Mul}}{\hlopt{; }}{\hlkwd{Div}}{\hlopt{]}}{\hlendline{}}

{\hlkwa{ \ let }}{\hlstd{solutions ns n }}{\hlopt{=
}}{\hlkwa{perform}}{\hlendline{Solve the problem:}}\\
{\hlstd{ \ \ \ \ \ ns' }}{\hlopt{<-- }}{\hlstd{choices
ns}}{\hlopt{;}}{\hlendline{pick numbers and their order,}}\\
{\hlstd{ \ \ \ \ \ }}{\hlopt{(}}{\hlstd{e}}{\hlopt{,}}{\hlstd{m}}{\hlopt{) <--
}}{\hlstd{results ns'}}{\hlopt{;}}{\hlendline{build possible expressions,}}\\
{\hlstd{ \ \ \ \ \ guard
}}{\hlopt{(}}{\hlstd{m}}{\hlopt{=}}{\hlstd{n}}{\hlopt{);}}{\hlendline{check if
the expression gives target value,}}\\
{\hlstd{ \ \ \ \ \ return }}{\hlopt{(}}{\hlstd{expr2str
e}}{\hlopt{)}}{\hlendline{``print'' the solution.}}\\
{\hlkwa{end}}{\hlendline{}}

\subsection{Understanding laziness}

\begin{itemize}
  \item We will measure execution times:
  
  {\hlstd{\#load }}{\hlstr{"unix.cma"}}{\hlopt{;;}}{\hlendline{}}\\
  {\hlkwa{let }}{\hlstd{time f }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{tbeg }}{\hlopt{=
  }}{\hlkwc{Unix}}{\hlopt{.}}{\hlstd{gettimeofday }}{\hlopt{()
  }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{res }}{\hlopt{= }}{\hlstd{f }}{\hlopt{()
  }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{tend }}{\hlopt{=
  }}{\hlkwc{Unix}}{\hlopt{.}}{\hlstd{gettimeofday }}{\hlopt{()
  }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ tend }}{\hlopt{-. }}{\hlstd{tbeg}}{\hlopt{,
  }}{\hlstd{res}}{\hlendline{}}
  
  \item Let's check our generalized {\hlkwd{Countdown}} solver using original
  operations.
  
  {\hlkwa{module }}{\hlkwd{ListCountdown }}{\hlopt{= }}{\hlkwd{Countdown
  }}{\hlopt{(}}{\hlkwd{ListM}}{\hlopt{)}}{\hlendline{}}\\
  {\hlkwa{let }}{\hlstd{test1 }}{\hlopt{() =
  }}{\hlkwc{ListM}}{\hlopt{.}}{\hlstd{run
  }}{\hlopt{(}}{\hlkwc{ListCountdown}}{\hlopt{.}}{\hlstd{solutions
  }}{\hlopt{[}}{\hlnum{1}}{\hlopt{;}}{\hlnum{3}}{\hlopt{;}}{\hlnum{7}}{\hlopt{;}}{\hlnum{10}}{\hlopt{;}}{\hlnum{25}}{\hlopt{;}}{\hlnum{50}}{\hlopt{]
  }}{\hlnum{765}}{\hlopt{)}}{\hlendline{}}\\
  {\hlkwa{let }}{\hlstd{t1}}{\hlopt{, }}{\hlstd{sol1 }}{\hlopt{=
  }}{\hlstd{time test1}}{\hlendline{}}
  
  \item {\hlkwa{val }}{\hlstd{t1 }}{\hlopt{: }}{\hlkwb{float }}{\hlopt{=
  }}{\hlnum{2.2856600284576416}}{\hlendline{}}\\
  {\hlkwa{val }}{\hlstd{sol1 }}{\hlopt{: }}{\hlkwb{string }}{\hlstd{list
  }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlopt{[}}{\hlstr{"((25-(3+7))*(1+50))"}}{\hlopt{;
  }}{\hlstr{"(((25-3)-7)*(1+50))"}}{\hlopt{; ...}}{\hlendline{}}
  
  \item What if we want only one solution? Laziness to the rescue!
  
  {\hlkwa{type }}{\hlstd{'a llist }}{\hlopt{= }}{\hlkwd{LNil
  }}{\hlopt{\textbar }}{\hlkwd{LCons }}{\hlkwa{of }}{\hlstd{'a }}{\hlopt{*
  }}{\hlstd{'a llist }}{\hlkwc{Lazy}}{\hlopt{.}}{\hlstd{t}}{\hlendline{}}\\
  {\hlkwa{let rec }}{\hlstd{ltake n }}{\hlopt{=
  }}{\hlkwa{function}}{\hlendline{}}\\
  {\hlstd{ {\hlopt{\textbar}} }}{\hlkwd{LCons
  }}{\hlopt{(}}{\hlstd{a}}{\hlopt{, }}{\hlkwa{lazy }}{\hlstd{l}}{\hlopt{)
  }}{\hlkwa{when }}{\hlstd{n }}{\hlopt{> }}{\hlnum{0 }}{\hlopt{->
  }}{\hlstd{a}}{\hlopt{::(}}{\hlstd{ltake
  }}{\hlopt{(}}{\hlstd{n}}{\hlopt{-}}{\hlnum{1}}{\hlopt{)
  }}{\hlstd{l}}{\hlopt{)}}{\hlendline{}}\\
  {\hlstd{ {\hlopt{\textbar}} {\textunderscore} }}{\hlopt{->
  []}}{\hlendline{}}\\
  {\hlkwa{let rec }}{\hlstd{lappend l1 l2 }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{match }}{\hlstd{l1 }}{\hlkwa{with }}{\hlkwd{LNil
  }}{\hlopt{-> }}{\hlstd{l2{\hlendline{}}\\
  \ }}{\hlopt{\textbar }}{\hlkwd{LCons }}{\hlopt{(}}{\hlstd{hd}}{\hlopt{,
  }}{\hlstd{tl}}{\hlopt{) ->}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwd{LCons }}{\hlopt{(}}{\hlstd{hd}}{\hlopt{,
  }}{\hlkwa{lazy }}{\hlopt{(}}{\hlstd{lappend
  }}{\hlopt{(}}{\hlkwc{Lazy}}{\hlopt{.}}{\hlstd{force tl}}{\hlopt{)
  }}{\hlstd{l2}}{\hlopt{))}}{\hlendline{}}\\
  {\hlkwa{let rec }}{\hlstd{lconcat{\textunderscore}map f }}{\hlopt{=
  }}{\hlkwa{function}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlopt{\textbar }}{\hlkwd{LNil }}{\hlopt{->
  }}{\hlkwd{LNil}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlopt{\textbar }}{\hlkwd{LCons
  }}{\hlopt{(}}{\hlstd{a}}{\hlopt{, }}{\hlkwa{lazy }}{\hlstd{l}}{\hlopt{)
  ->}}{\hlendline{}}\\
  {\hlstd{ \ \ \ lappend }}{\hlopt{(}}{\hlstd{f a}}{\hlopt{)
  (}}{\hlstd{lconcat{\textunderscore}map f l}}{\hlopt{)}}{\hlendline{}}
  
  \item That is, another monad-plus.
  
  {\hlkwa{module }}{\hlkwd{LListM }}{\hlopt{= }}{\hlkwd{MonadPlus
  }}{\hlopt{(}}{\hlkwa{struct}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{type }}{\hlstd{'a}}{\hlstd{ t }}{\hlopt{= }}{\hlstd{'a
  llist{\hlendline{}}\\
  \ }}{\hlkwa{let }}{\hlstd{bind a b }}{\hlopt{=
  }}{\hlstd{lconcat{\textunderscore}map b a{\hlendline{}}\\
  \ }}{\hlkwa{let }}{\hlstd{return a }}{\hlopt{= }}{\hlkwd{LCons
  }}{\hlopt{(}}{\hlstd{a}}{\hlopt{, }}{\hlkwa{lazy
  }}{\hlkwd{LNil}}{\hlopt{)}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{mzero }}{\hlopt{=
  }}{\hlkwd{LNil}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{mplus }}{\hlopt{=
  }}{\hlstd{lappend}}{\hlendline{}}\\
  {\hlkwa{end}}{\hlopt{)}}{\hlendline{}}
  
  \item {\hlkwa{module }}{\hlkwd{LListCountdown }}{\hlopt{=
  }}{\hlkwd{Countdown }}{\hlopt{(}}{\hlkwd{LListM}}{\hlopt{)}}{\hlendline{}}\\
  {\hlkwa{let }}{\hlstd{test2 }}{\hlopt{() =
  }}{\hlkwc{LListM}}{\hlopt{.}}{\hlstd{run
  }}{\hlopt{(}}{\hlkwc{LListCountdown}}{\hlopt{.}}{\hlstd{solutions
  }}{\hlopt{[}}{\hlnum{1}}{\hlopt{;}}{\hlnum{3}}{\hlopt{;}}{\hlnum{7}}{\hlopt{;}}{\hlnum{10}}{\hlopt{;}}{\hlnum{25}}{\hlopt{;}}{\hlnum{50}}{\hlopt{]
  }}{\hlnum{765}}{\hlopt{)}}{\hlendline{}}
  
  \item {\hlstd{\# }}{\hlkwa{let }}{\hlstd{t2a}}{\hlopt{, }}{\hlstd{sol2
  }}{\hlopt{= }}{\hlstd{time test2}}{\hlopt{;;}}{\hlendline{}}\\
  {\hlkwa{val }}{\hlstd{t2a }}{\hlopt{: }}{\hlkwb{float }}{\hlopt{=
  }}{\hlnum{2.51197600364685059}}{\hlendline{}}\\
  {\hlkwa{val }}{\hlstd{sol2 }}{\hlopt{: }}{\hlkwb{string }}{\hlstd{llist
  }}{\hlopt{= }}{\hlkwd{LCons
  }}{\hlopt{(}}{\hlstr{"((25-(3+7))*(1+50))"}}{\hlopt{,
  <}}{\hlkwa{lazy}}{\hlopt{>)}}{\hlendline{}}
  
  Not good, almost the same time to even get the lazy list!
  
  \item {\hlstd{\# }}{\hlkwa{let }}{\hlstd{t2b}}{\hlopt{,
  }}{\hlstd{sol2{\textunderscore}1 }}{\hlopt{= }}{\hlstd{time
  }}{\hlopt{(}}{\hlkwa{fun }}{\hlopt{() -> }}{\hlstd{ltake }}{\hlnum{1
  }}{\hlstd{sol2}}{\hlopt{);;}}{\hlendline{}}\\
  {\hlkwa{val }}{\hlstd{t2b }}{\hlopt{: }}{\hlkwb{float }}{\hlopt{=
  }}{\hlnum{2.86102294921875e-06}}{\hlendline{}}\\
  {\hlkwa{val }}{\hlstd{sol2{\textunderscore}1 }}{\hlopt{: }}{\hlkwb{string
  }}{\hlstd{list }}{\hlopt{=
  [}}{\hlstr{"((25-(3+7))*(1+50))"}}{\hlopt{]}}{\hlendline{}}\\
  {\hlstd{\# }}{\hlkwa{let }}{\hlstd{t2c}}{\hlopt{,
  }}{\hlstd{sol2{\textunderscore}9 }}{\hlopt{= }}{\hlstd{time
  }}{\hlopt{(}}{\hlkwa{fun }}{\hlopt{() -> }}{\hlstd{ltake }}{\hlnum{10
  }}{\hlstd{sol2}}{\hlopt{);;}}{\hlendline{}}\\
  {\hlkwa{val }}{\hlstd{t2c }}{\hlopt{: }}{\hlkwb{float }}{\hlopt{=
  }}{\hlnum{9.059906005859375e-06}}{\hlendline{}}\\
  {\hlkwa{val }}{\hlstd{sol2{\textunderscore}9 }}{\hlopt{: }}{\hlkwb{string
  }}{\hlstd{list }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlopt{[}}{\hlstr{"((25-(3+7))*(1+50))"}}{\hlopt{;
  }}{\hlstr{"(((25-3)-7)*(1+50))"}}{\hlopt{; ...}}{\hlendline{}}\\
  {\hlstd{\# }}{\hlkwa{let }}{\hlstd{t2d}}{\hlopt{,
  }}{\hlstd{sol2{\textunderscore}39 }}{\hlopt{= }}{\hlstd{time
  }}{\hlopt{(}}{\hlkwa{fun }}{\hlopt{() -> }}{\hlstd{ltake }}{\hlnum{49
  }}{\hlstd{sol2}}{\hlopt{);;}}{\hlendline{}}\\
  {\hlkwa{val }}{\hlstd{t2d }}{\hlopt{: }}{\hlkwb{float }}{\hlopt{=
  }}{\hlnum{4.00543212890625e-05}}{\hlendline{}}\\
  {\hlkwa{val }}{\hlstd{sol2{\textunderscore}39 }}{\hlopt{: }}{\hlkwb{string
  }}{\hlstd{list }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlopt{[}}{\hlstr{"((25-(3+7))*(1+50))"}}{\hlopt{;
  }}{\hlstr{"(((25-3)-7)*(1+50))"}}{\hlopt{; ...}}{\hlendline{}}
  
  Getting elements from the list shows they are almost already computed.
  
  \item Wait! Perhaps we should not store all candidates when we are only
  interested in one.
  
  {\hlkwa{module }}{\hlkwd{OptionM }}{\hlopt{= }}{\hlkwd{MonadPlus
  }}{\hlopt{(}}{\hlkwa{struct}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{type }}{\hlstd{'a}}{\hlstd{ t }}{\hlopt{= }}{\hlstd{'a
  }}{\hlkwb{option}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{bind a b }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{match }}{\hlstd{a }}{\hlkwa{with }}{\hlkwd{None
  }}{\hlopt{-> }}{\hlkwd{None }}{\hlopt{\textbar }}{\hlkwd{Some }}{\hlstd{x
  }}{\hlopt{-> }}{\hlstd{b x{\hlendline{}}\\
  \ }}{\hlkwa{let }}{\hlstd{return a }}{\hlopt{= }}{\hlkwd{Some
  }}{\hlstd{a{\hlendline{}}\\
  \ }}{\hlkwa{let }}{\hlstd{mzero }}{\hlopt{=
  }}{\hlkwd{None}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{mplus a b }}{\hlopt{= }}{\hlkwa{match
  }}{\hlstd{a }}{\hlkwa{with }}{\hlkwd{None }}{\hlopt{-> }}{\hlstd{b
  {\hlopt{\textbar}} }}{\hlkwd{Some }}{\hlstd{{\textunderscore} }}{\hlopt{->
  }}{\hlstd{a}}{\hlendline{}}\\
  {\hlkwa{end}}{\hlopt{)}}{\hlendline{}}
  
  \item {\hlkwa{module }}{\hlkwd{OptCountdown }}{\hlopt{= }}{\hlkwd{Countdown
  }}{\hlopt{(}}{\hlkwd{OptionM}}{\hlopt{)}}{\hlendline{}}\\
  {\hlkwa{let }}{\hlstd{test3 }}{\hlopt{() =
  }}{\hlkwc{OptionM}}{\hlopt{.}}{\hlstd{run
  }}{\hlopt{(}}{\hlkwc{OptCountdown}}{\hlopt{.}}{\hlstd{solutions
  }}{\hlopt{[}}{\hlnum{1}}{\hlopt{;}}{\hlnum{3}}{\hlopt{;}}{\hlnum{7}}{\hlopt{;}}{\hlnum{10}}{\hlopt{;}}{\hlnum{25}}{\hlopt{;}}{\hlnum{50}}{\hlopt{]
  }}{\hlnum{765}}{\hlopt{)}}{\hlendline{}}
  
  \item {\hlstd{\# }}{\hlkwa{let }}{\hlstd{t3}}{\hlopt{, }}{\hlstd{sol3
  }}{\hlopt{= }}{\hlstd{time test3}}{\hlopt{;;}}{\hlendline{}}\\
  {\hlkwa{val }}{\hlstd{t3 }}{\hlopt{: }}{\hlkwb{float }}{\hlopt{=
  }}{\hlnum{5.0067901611328125e-06}}{\hlendline{}}\\
  {\hlkwa{val }}{\hlstd{sol3 }}{\hlopt{: }}{\hlkwb{string option }}{\hlopt{=
  }}{\hlkwd{None}}{\hlendline{}}
  
  It very quickly computes... nothing. Why?
  \begin{itemize}
    \item What is the {\hlkwd{OptionM}} monad (\tmverbatim{Maybe} monad in
    Haskell) good for?
  \end{itemize}
  \item Our lazy list type is not lazy enough.
  \begin{itemize}
    \item Whenever we ``make'' a choice: \tmverbatim{a
    }{\hlopt{++}}\tmverbatim{ b} or \tmverbatim{msum\_map} ..., it computes
    the first candidate for each choice path.
    
    \item When we bind consecutive steps, it computes the second candidate of
    the first step even when the first candidate would suffice.
  \end{itemize}
  \item We want the whole monad to be lazy: it's called {\tmem{even lazy
  lists}}.
  \begin{itemize}
    \item Our \tmverbatim{llist} are called {\tmem{odd lazy lists}}.
  \end{itemize}
  {\hlkwa{type }}{\hlstd{'a lazy{\textunderscore}list }}{\hlopt{= }}{\hlstd{'a
  lazy{\textunderscore}list{\textunderscore}
  }}{\hlkwc{Lazy}}{\hlopt{.}}{\hlstd{t}}{\hlendline{}}\\
  {\hlkwa{and }}{\hlstd{'a lazy{\textunderscore}list{\textunderscore}
  }}{\hlopt{= }}{\hlkwd{LazNil }}{\hlopt{\textbar }}{\hlkwd{LazCons
  }}{\hlkwa{of }}{\hlstd{'a }}{\hlopt{* }}{\hlstd{'a
  lazy{\textunderscore}list}}{\hlendline{}}\\
  {\hlkwa{let rec }}{\hlstd{laztake n }}{\hlopt{=
  }}{\hlkwa{function}}{\hlendline{}}\\
  {\hlstd{ {\hlopt{\textbar}} }}{\hlkwa{lazy }}{\hlopt{(}}{\hlkwd{LazCons
  }}{\hlopt{(}}{\hlstd{a}}{\hlopt{, }}{\hlstd{l}}{\hlopt{)) }}{\hlkwa{when
  }}{\hlstd{n }}{\hlopt{> }}{\hlnum{0 }}{\hlopt{->}}{\hlendline{}}\\
  {\hlstd{ \ \ a}}{\hlopt{::(}}{\hlstd{laztake
  }}{\hlopt{(}}{\hlstd{n}}{\hlopt{-}}{\hlnum{1}}{\hlopt{)
  }}{\hlstd{l}}{\hlopt{)}}{\hlendline{}}\\
  {\hlstd{ {\hlopt{\textbar}} {\textunderscore} }}{\hlopt{->
  []}}{\hlendline{}}\\
  {\hlkwa{let rec }}{\hlstd{append{\textunderscore}aux l1 l2
  }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{match }}{\hlstd{l1 }}{\hlkwa{with lazy }}{\hlkwd{LazNil
  }}{\hlopt{-> }}{\hlkwc{Lazy}}{\hlopt{.}}{\hlstd{force l2{\hlendline{}}\\
  \ }}{\hlopt{\textbar }}{\hlkwa{lazy }}{\hlopt{(}}{\hlkwd{LazCons
  }}{\hlopt{(}}{\hlstd{hd}}{\hlopt{, }}{\hlstd{tl}}{\hlopt{))
  ->}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwd{LazCons }}{\hlopt{(}}{\hlstd{hd}}{\hlopt{,
  }}{\hlkwa{lazy }}{\hlopt{(}}{\hlstd{append{\textunderscore}aux tl
  l2}}{\hlopt{))}}{\hlendline{}}\\
  {\hlkwa{let }}{\hlstd{lazappend l1 l2 }}{\hlopt{= }}{\hlkwa{lazy
  }}{\hlopt{(}}{\hlstd{append{\textunderscore}aux l1
  l2}}{\hlopt{)}}{\hlendline{}}\\
  {\hlkwa{let rec }}{\hlstd{concat{\textunderscore}map{\textunderscore}aux f
  }}{\hlopt{= }}{\hlkwa{function}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlopt{\textbar }}{\hlkwa{lazy }}{\hlkwd{LazNil }}{\hlopt{->
  }}{\hlkwd{LazNil}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlopt{\textbar }}{\hlkwa{lazy }}{\hlopt{(}}{\hlkwd{LazCons
  }}{\hlopt{(}}{\hlstd{a}}{\hlopt{, }}{\hlstd{l}}{\hlopt{))
  ->}}{\hlendline{}}\\
  {\hlstd{ \ \ \ append{\textunderscore}aux }}{\hlopt{(}}{\hlstd{f
  a}}{\hlopt{) (}}{\hlkwa{lazy
  }}{\hlopt{(}}{\hlstd{concat{\textunderscore}map{\textunderscore}aux f
  l}}{\hlopt{))}}{\hlendline{}}\\
  {\hlkwa{let }}{\hlstd{lazconcat{\textunderscore}map f l }}{\hlopt{=
  }}{\hlkwa{lazy
  }}{\hlopt{(}}{\hlstd{concat{\textunderscore}map{\textunderscore}aux f
  l}}{\hlopt{)}}{\hlendline{}}
  
  \item {\hlkwa{module }}{\hlkwd{LazyListM }}{\hlopt{= }}{\hlkwd{MonadPlus
  }}{\hlopt{(}}{\hlkwa{struct}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{type }}{\hlstd{'a}}{\hlstd{ t }}{\hlopt{= }}{\hlstd{'a
  lazy{\textunderscore}list{\hlendline{}}\\
  \ }}{\hlkwa{let }}{\hlstd{bind a b }}{\hlopt{=
  }}{\hlstd{lazconcat{\textunderscore}map b a{\hlendline{}}\\
  \ }}{\hlkwa{let }}{\hlstd{return a }}{\hlopt{= }}{\hlkwa{lazy
  }}{\hlopt{(}}{\hlkwd{LazCons }}{\hlopt{(}}{\hlstd{a}}{\hlopt{,
  }}{\hlkwa{lazy }}{\hlkwd{LazNil}}{\hlopt{))}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{mzero }}{\hlopt{= }}{\hlkwa{lazy
  }}{\hlkwd{LazNil}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{mplus }}{\hlopt{=
  }}{\hlstd{lazappend}}{\hlendline{}}\\
  {\hlkwa{end}}{\hlopt{)}}{\hlendline{}}
  
  \item {\hlkwa{module }}{\hlkwd{LazyCountdown }}{\hlopt{= }}{\hlkwd{Countdown
  }}{\hlopt{(}}{\hlkwd{LazyListM}}{\hlopt{)}}{\hlendline{}}\\
  {\hlkwa{let }}{\hlstd{test4 }}{\hlopt{() =
  }}{\hlkwc{LazyListM}}{\hlopt{.}}{\hlstd{run
  }}{\hlopt{(}}{\hlkwc{LazyCountdown}}{\hlopt{.}}{\hlstd{solutions
  }}{\hlopt{[}}{\hlnum{1}}{\hlopt{;}}{\hlnum{3}}{\hlopt{;}}{\hlnum{7}}{\hlopt{;}}{\hlnum{10}}{\hlopt{;}}{\hlnum{25}}{\hlopt{;}}{\hlnum{50}}{\hlopt{]
  }}{\hlnum{765}}{\hlopt{)}}{\hlendline{}}
  
  \item {\hlstd{\# }}{\hlkwa{let }}{\hlstd{t4a}}{\hlopt{, }}{\hlstd{sol4
  }}{\hlopt{= }}{\hlstd{time test4}}{\hlopt{;;}}{\hlendline{}}\\
  {\hlkwa{val }}{\hlstd{t4a }}{\hlopt{: }}{\hlkwb{float }}{\hlopt{=
  }}{\hlnum{2.86102294921875e-06}}{\hlendline{}}\\
  {\hlkwa{val }}{\hlstd{sol4 }}{\hlopt{: }}{\hlkwb{string
  }}{\hlstd{lazy{\textunderscore}list }}{\hlopt{=
  <}}{\hlkwa{lazy}}{\hlopt{>}}{\hlendline{}}\\
  {\hlstd{\# }}{\hlkwa{let }}{\hlstd{t4b}}{\hlopt{,
  }}{\hlstd{sol4{\textunderscore}1 }}{\hlopt{= }}{\hlstd{time
  }}{\hlopt{(}}{\hlkwa{fun }}{\hlopt{() -> }}{\hlstd{laztake }}{\hlnum{1
  }}{\hlstd{sol4}}{\hlopt{);;}}{\hlendline{}}\\
  {\hlkwa{val }}{\hlstd{t4b }}{\hlopt{: }}{\hlkwb{float }}{\hlopt{=
  }}{\hlnum{0.367874860763549805}}{\hlendline{}}\\
  {\hlkwa{val }}{\hlstd{sol4{\textunderscore}1 }}{\hlopt{: }}{\hlkwb{string
  }}{\hlstd{list }}{\hlopt{=
  [}}{\hlstr{"((25-(3+7))*(1+50))"}}{\hlopt{]}}{\hlendline{}}\\
  {\hlstd{\# }}{\hlkwa{let }}{\hlstd{t4c}}{\hlopt{,
  }}{\hlstd{sol4{\textunderscore}9 }}{\hlopt{= }}{\hlstd{time
  }}{\hlopt{(}}{\hlkwa{fun }}{\hlopt{() -> }}{\hlstd{laztake }}{\hlnum{10
  }}{\hlstd{sol4}}{\hlopt{);;}}{\hlendline{}}\\
  {\hlkwa{val }}{\hlstd{t4c }}{\hlopt{: }}{\hlkwb{float }}{\hlopt{=
  }}{\hlnum{0.234670877456665039}}{\hlendline{}}\\
  {\hlkwa{val }}{\hlstd{sol4{\textunderscore}9 }}{\hlopt{: }}{\hlkwb{string
  }}{\hlstd{list }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlopt{[}}{\hlstr{"((25-(3+7))*(1+50))"}}{\hlopt{;
  }}{\hlstr{"(((25-3)-7)*(1+50))"}}{\hlopt{; ...}}{\hlendline{}}\\
  {\hlstd{\# }}{\hlkwa{let }}{\hlstd{t4d}}{\hlopt{,
  }}{\hlstd{sol4{\textunderscore}39 }}{\hlopt{= }}{\hlstd{time
  }}{\hlopt{(}}{\hlkwa{fun }}{\hlopt{() -> }}{\hlstd{laztake }}{\hlnum{49
  }}{\hlstd{sol4}}{\hlopt{);;}}{\hlendline{}}\\
  {\hlkwa{val }}{\hlstd{t4d }}{\hlopt{: }}{\hlkwb{float }}{\hlopt{=
  }}{\hlnum{4.0594940185546875}}{\hlendline{}}\\
  {\hlkwa{val }}{\hlstd{sol4{\textunderscore}39 }}{\hlopt{: }}{\hlkwb{string
  }}{\hlstd{list }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlopt{[}}{\hlstr{"((25-(3+7))*(1+50))"}}{\hlopt{;
  }}{\hlstr{"(((25-3)-7)*(1+50))"}}{\hlopt{; ...}}{\hlendline{}}
  \begin{itemize}
    \item Finally, the first solution in considerably less time than all
    solutions.
    
    \item The next 9 solutions are almost computed once the first one is.
    
    \item But computing all solutions takes nearly twice as long as without
    the overhead of lazy computation.
  \end{itemize}
\end{itemize}

\subsection{The exception monad}

\begin{itemize}
  \item Built-in non-functional exceptions in OCaml are more efficient (and
  more flexible).
  
  \item Instead of specifying a type of exceptional values, we could use OCaml
  open type \tmverbatim{exn}, restoring some flexibility.
  
  \item Monadic exceptions are safer than standard exceptions in situations
  like multi-threading. Monadic lightweight-thread library {\hlkwc{Lwt}} has
  \tmverbatim{throw} (called \tmverbatim{fail} there) and \tmverbatim{catch}
  operations in its monad.
\end{itemize}
{\hlkwa{module }}{\hlkwd{ExceptionM}}{\hlopt{(}}{\hlkwd{Excn }}{\hlopt{:
}}{\hlkwa{sig type }}{\hlstd{t }}{\hlkwa{end}}{\hlopt{) :
}}{\hlkwa{sig}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlkwa{type }}{\hlstd{excn }}{\hlopt{=
}}{\hlkwc{Excn}}{\hlopt{.}}{\hlstd{t{\hlendline{}}\\
\ }}{\hlkwa{type }}{\hlstd{'a t }}{\hlopt{= }}{\hlkwd{OK }}{\hlkwa{of
}}{\hlstd{'a {\hlopt{\textbar}} }}{\hlkwd{Bad }}{\hlkwa{of
}}{\hlstd{excn{\hlendline{}}\\
\ }}{\hlkwa{include }}{\hlkwd{MONAD{\textunderscore}OPS}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlkwa{val }}{\hlstd{run }}{\hlopt{: }}{\hlstd{'a monad
}}{\hlopt{-> }}{\hlstd{'a t{\hlendline{}}\\
\ }}{\hlkwa{val }}{\hlstd{throw }}{\hlopt{: }}{\hlstd{excn }}{\hlopt{->
}}{\hlstd{'a monad{\hlendline{}}\\
\ }}{\hlkwa{val }}{\hlstd{catch }}{\hlopt{: }}{\hlstd{'a monad }}{\hlopt{->
(}}{\hlstd{excn }}{\hlopt{-> }}{\hlstd{'a monad}}{\hlopt{) -> }}{\hlstd{'a
monad}}{\hlendline{}}\\
{\hlkwa{end }}{\hlopt{= }}{\hlkwa{struct}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlkwa{type }}{\hlstd{excn }}{\hlopt{=
}}{\hlkwc{Excn}}{\hlopt{.}}\tmverbatim{t}{\hlendline{}}

\tmverbatim{ \ }{\hlkwa{module }}{\hlkwd{M }}{\hlopt{=
}}{\hlkwa{struct}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwa{type }}{\hlstd{'a t }}{\hlopt{= }}{\hlkwd{OK
}}{\hlkwa{of }}{\hlstd{'a {\hlopt{\textbar}} }}{\hlkwd{Bad }}{\hlkwa{of
}}{\hlstd{excn{\hlendline{}}\\
\ \ \ }}{\hlkwa{let }}{\hlstd{return a }}{\hlopt{= }}{\hlkwd{OK
}}{\hlstd{a{\hlendline{}}\\
\ \ \ }}{\hlkwa{let }}{\hlstd{bind m b }}{\hlopt{= }}{\hlkwa{match
}}{\hlstd{m }}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{OK }}{\hlstd{a }}{\hlopt{->
}}{\hlstd{b a{\hlendline{}}\\
\ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Bad }}{\hlstd{e }}{\hlopt{->
}}{\hlkwd{Bad }}{\hlstd{e{\hlendline{}}\\
\ }}{\hlkwa{end}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlkwa{include }}{\hlkwd{M}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlkwa{include
}}{\hlkwd{MonadOps}}{\hlopt{(}}{\hlkwd{M}}{\hlopt{)}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlkwa{let }}{\hlstd{throw e }}{\hlopt{= }}{\hlkwd{Bad
}}{\hlstd{e{\hlendline{}}\\
\ }}{\hlkwa{let }}{\hlstd{catch m handler }}{\hlopt{= }}{\hlkwa{match
}}{\hlstd{m }}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{OK }}{\hlstd{{\textunderscore}
}}{\hlopt{-> }}{\hlstd{m{\hlendline{}}\\
\ \ \ }}{\hlopt{\textbar }}{\hlkwd{Bad }}{\hlstd{e }}{\hlopt{->
}}{\hlstd{handler e}}{\hlendline{}}\\
{\hlkwa{end}}{\hlstd{ \ \ \ }}{\hlendline{}}

\subsection{The state monad}

{\hlkwa{module }}{\hlkwd{StateM}}{\hlopt{(}}{\hlkwd{Store }}{\hlopt{:
}}{\hlkwa{sig type }}{\hlstd{t }}{\hlkwa{end}}{\hlopt{) :
}}{\hlkwa{sig}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlkwa{type }}{\hlstd{store }}{\hlopt{=
}}{\hlkwc{Store}}{\hlopt{.}}\tmverbatim{t}{\hlendline{Pass the current
\tmverbatim{store} value to get the next value.}}\\
\tmverbatim{ \ }{\hlkwa{type }}{\hlstd{'a t }}{\hlopt{= }}{\hlstd{store
}}{\hlopt{-> }}{\hlstd{'a }}{\hlopt{* }}{\hlstd{store{\hlendline{}}\\
\ }}{\hlkwa{include }}{\hlkwd{MONAD{\textunderscore}OPS}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlkwa{include }}{\hlkwd{STATE }}{\hlkwa{with type }}{\hlstd{'a
t }}{\hlopt{:= }}{\hlstd{'a monad{\hlendline{}}\\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }}{\hlkwa{and type }}{\hlstd{store }}{\hlopt{:=
}}{\hlstd{store{\hlendline{}}\\
\ }}{\hlkwa{val }}{\hlstd{run }}{\hlopt{: }}{\hlstd{'a monad }}{\hlopt{->
}}{\hlstd{'a t}}{\hlendline{}}\\
{\hlkwa{end }}{\hlopt{= }}{\hlkwa{struct}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlkwa{type }}{\hlstd{store }}{\hlopt{=
}}{\hlkwc{Store}}{\hlopt{.}}{\hlstd{t{\hlendline{}}\\
\ }}{\hlkwa{module }}{\hlkwd{M }}{\hlopt{= }}{\hlkwa{struct}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwa{type }}{\hlstd{'a t }}{\hlopt{= }}{\hlstd{store
}}{\hlopt{-> }}{\hlstd{'a }}{\hlopt{* }}{\hlstd{store{\hlendline{}}\\
\ \ \ }}{\hlkwa{let }}{\hlstd{return a }}{\hlopt{= }}{\hlkwa{fun }}{\hlstd{s
}}{\hlopt{-> }}{\hlstd{a}}{\hlopt{, }}\tmverbatim{s}{\hlendline{Keep the
current value unchanged.}}\\
\tmverbatim{ \ \ \ }{\hlkwa{let }}{\hlstd{bind m b }}{\hlopt{= }}{\hlkwa{fun
}}{\hlstd{s }}{\hlopt{-> }}{\hlkwa{let }}{\hlstd{a}}{\hlopt{, }}{\hlstd{s'
}}{\hlopt{= }}{\hlstd{m s }}{\hlkwa{in }}{\hlstd{b a s'{\hlendline{}}\\
\ }}{\hlkwa{end}}{\hlendline{To bind two steps, pass the value after first
step to the second step.}}\\
{\hlstd{ \ }}{\hlkwa{include }}{\hlkwd{M}}{\hlkwa{ include
}}{\hlkwd{MonadOps}}{\hlopt{(}}{\hlkwd{M}}{\hlopt{)}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlkwa{let }}{\hlstd{get }}{\hlopt{= }}{\hlkwa{fun }}{\hlstd{s
}}{\hlopt{-> }}{\hlstd{s}}{\hlopt{, }}\tmverbatim{s}{\hlendline{Keep the value
unchanged but put it in monad.}}\tmverbatim{\\
\ }{\hlkwa{let }}{\hlstd{put s' }}{\hlopt{= }}{\hlkwa{fun
}}{\hlstd{{\textunderscore} }}{\hlopt{-> (), }}{\hlstd{s'}}{\hlendline{Change
the value; a throwaway in monad.}}\\
{\hlkwa{end}}
\begin{itemize}
  \item The state monad is useful to hide passing-around of a ``current''
  value.
  
  \item We will rename variables in $\lambda$-terms to get rid of possible
  name clashes.
  \begin{itemize}
    \item This does not make a $\lambda$-term safe for multiple steps of
    $\beta$-reduction. Find a counter-example.
  \end{itemize}
  \item {\hlkwa{type }}{\hlstd{term }}{\hlopt{=}}{\hlendline{}}\\
  {\hlopt{\textbar }}{\hlkwd{Var }}{\hlkwa{of
  }}{\hlkwb{string}}{\hlendline{}}\\
  {\hlopt{\textbar }}{\hlkwd{Lam }}{\hlkwa{of }}{\hlkwb{string }}{\hlopt{*
  }}{\hlstd{term{\hlendline{}}\\
  {\hlopt{\textbar}} }}{\hlkwd{App }}{\hlkwa{of }}{\hlstd{term }}{\hlopt{*
  }}{\hlstd{term}}{\hlendline{}}
  
  \item {\hlkwa{let }}{\hlopt{(!) }}{\hlstd{x }}{\hlopt{= }}{\hlkwd{Var
  }}{\hlstd{x}}{\hlendline{}}\\
  {\hlkwa{let }}{\hlopt{(}}{\hlstd{{\hlopt{\textbar}}}}{\hlopt{->) }}{\hlstd{x
  t }}{\hlopt{= }}{\hlkwd{Lam }}{\hlopt{(}}{\hlstd{x}}{\hlopt{,
  }}{\hlstd{t}}{\hlopt{)}}{\hlendline{}}\\
  {\hlkwa{let }}{\hlopt{(}}{\hlstd{@}}{\hlopt{) }}{\hlstd{t1 t2 }}{\hlopt{=
  }}{\hlkwd{App }}{\hlopt{(}}{\hlstd{t1}}{\hlopt{,
  }}{\hlstd{t2}}{\hlopt{)}}{\hlendline{}}\\
  {\hlkwa{let }}{\hlstd{test }}{\hlopt{= }}{\hlstr{"x"}}{\hlstd{
  {\hlopt{\textbar}}}}{\hlopt{-> (}}{\hlstr{"x"}}{\hlstd{
  {\hlopt{\textbar}}}}{\hlopt{-> !}}{\hlstr{"y"}}{\hlstd{ @
  }}{\hlopt{!}}{\hlstr{"x"}}{\hlopt{) }}{\hlstd{@
  }}{\hlopt{!}}{\hlstr{"x"}}{\hlendline{}}
  
  \item {\hlkwa{module }}{\hlkwd{S }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwd{StateM}}{\hlopt{(}}{\hlkwa{struct type }}{\hlstd{t
  }}{\hlopt{= }}{\hlkwb{int }}{\hlopt{* (}}{\hlkwb{string }}{\hlopt{*
  }}{\hlkwb{string}}{\hlopt{) }}{\hlstd{list }}{\hlkwa{end}}{\hlopt{)}}\\
  {\hlkwa{open }}{\hlkwd{S}}
  
  Without opening the module, we would write {\hlkwd{S}}\tmverbatim{.get},
  {\hlkwd{S}}\tmverbatim{.put} and {\hlkwa{perform with }}{\hlkwd{S}}{\hlkwa{
  in}}...{\hlendline{}}
  
  \item {\hlkwa{let rec }}{\hlstd{alpha{\textunderscore}conv }}{\hlopt{=
  }}{\hlkwa{function}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlopt{\textbar }}{\hlkwd{Var }}{\hlstd{x }}{\hlkwa{as
  }}{\hlstd{v }}{\hlopt{-> }}{\hlkwa{perform}}{\hlendline{Function from terms
  to {\hlkwd{StateM}} monad.}}\\
  {\hlstd{ \ \ \ }}{\hlopt{(}}{\hlstd{\_}}{\hlopt{, }}{\hlstd{env}}{\hlopt{)
  <-- }}{\hlstd{get}}{\hlopt{;}}{\hlendline{Seeing a variable does not change
  state}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{v }}{\hlopt{= }}{\hlkwa{try
  }}{\hlkwd{Var }}{\hlopt{(}}{\hlkwc{List}}{\hlopt{.}}{\hlstd{assoc x
  env}}{\hlopt{)}}{\hlendline{but we need its new name.}}\\
  {\hlstd{ \ \ \ \ \ }}{\hlkwa{with }}{\hlkwd{Not{\textunderscore}found
  }}{\hlopt{-> }}{\hlstd{v }}{\hlkwa{in}}{\hlendline{Free variables don't
  change name.}}\\
  {\hlstd{ \ \ \ return v{\hlendline{}}\\
  \ }}{\hlopt{\textbar }}{\hlkwd{Lam }}{\hlopt{(}}{\hlstd{x}}{\hlopt{,
  }}{\hlstd{t}}{\hlopt{) -> }}{\hlkwa{perform}}{\hlendline{We rename each
  bound variable.}}\\
  {\hlstd{ \ \ \ }}{\hlopt{(}}{\hlstd{fresh}}{\hlopt{,
  }}{\hlstd{env}}{\hlopt{) <-- }}{\hlstd{get}}{\hlopt{;}}{\hlendline{We need a
  fresh number.}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{x' }}{\hlopt{= }}{\hlstd{x
  {\textasciicircum} string{\textunderscore}of{\textunderscore}int fresh
  }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ \ \ put
  }}{\hlopt{(}}{\hlstd{fresh}}{\hlopt{+}}{\hlnum{1}}{\hlopt{,
  (}}{\hlstd{x}}{\hlopt{,
  }}{\hlstd{x'}}{\hlopt{)::}}{\hlstd{env}}{\hlopt{);}}{\hlendline{Remember new
  name, update number.}}\\
  {\hlstd{ \ \ \ t' }}{\hlopt{<-- }}{\hlstd{alpha{\textunderscore}conv
  t}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlopt{(}}{\hlstd{fresh'}}{\hlopt{,
  }}{\hlstd{{\textunderscore}}}{\hlopt{) <--
  }}{\hlstd{get}}{\hlopt{;}}{\hlendline{We need to restore names,}}\\
  {\hlstd{ \ \ \ put }}{\hlopt{(}}{\hlstd{fresh'}}{\hlopt{,
  }}{\hlstd{env}}{\hlopt{);}}{\hlendline{but keep the number fresh.}}\\
  {\hlstd{ \ \ \ return }}{\hlopt{(}}{\hlkwd{Lam
  }}{\hlopt{(}}{\hlstd{x'}}{\hlopt{,
  }}{\hlstd{t'}}{\hlopt{))}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlopt{\textbar }}{\hlkwd{App
  }}{\hlopt{(}}{\hlstd{t1}}{\hlopt{, }}{\hlstd{t2}}{\hlopt{) ->
  }}{\hlkwa{perform}}{\hlendline{}}\\
  {\hlstd{ \ \ \ t1 }}{\hlopt{<-- }}{\hlstd{alpha{\textunderscore}conv
  t1}}{\hlopt{;}}{\hlendline{Passing around of names}}\\
  {\hlstd{ \ \ \ t2 }}{\hlopt{<-- }}{\hlstd{alpha{\textunderscore}conv
  t2}}{\hlopt{;}}{\hlendline{and the currently fresh number}}\\
  {\hlstd{ \ \ \ return }}{\hlopt{(}}{\hlkwd{App
  }}{\hlopt{(}}{\hlstd{t1}}{\hlopt{, }}{\hlstd{t2}}{\hlopt{))}}{\hlendline{is
  done by the monad.}}
  
  \item {\hlkwa{val }}{\hlstd{test }}{\hlopt{: }}{\hlstd{term }}{\hlopt{=
  }}{\hlkwd{Lam }}{\hlopt{(}}{\hlstr{"x"}}{\hlopt{, }}{\hlkwd{App
  }}{\hlopt{(}}{\hlkwd{Lam }}{\hlopt{(}}{\hlstr{"x"}}{\hlopt{, }}{\hlkwd{App
  }}{\hlopt{(}}{\hlkwd{Var }}{\hlstr{"y"}}{\hlopt{, }}{\hlkwd{Var
  }}{\hlstr{"x"}}{\hlopt{)), }}{\hlkwd{Var
  }}{\hlstr{"x"}}{\hlopt{))}}{\hlendline{}}\\
  {\hlstd{\# }}{\hlkwa{let }}{\hlstd{{\textunderscore} }}{\hlopt{=
  }}{\hlkwc{StateM}}{\hlopt{.}}{\hlstd{run
  }}{\hlopt{(}}{\hlstd{alpha{\textunderscore}conv test}}{\hlopt{)
  (}}{\hlnum{5}}{\hlopt{, []);;}}{\hlendline{}}\\
  {\hlopt{- : }}{\hlstd{term }}{\hlopt{* (}}{\hlkwb{int }}{\hlopt{*
  (}}{\hlkwb{string }}{\hlopt{* }}{\hlkwb{string}}{\hlopt{)
  }}{\hlstd{list}}{\hlopt{) =}}{\hlendline{}}\\
  {\hlopt{(}}{\hlkwd{Lam }}{\hlopt{(}}{\hlstr{"x5"}}{\hlopt{, }}{\hlkwd{App
  }}{\hlopt{(}}{\hlkwd{Lam }}{\hlopt{(}}{\hlstr{"x6"}}{\hlopt{, }}{\hlkwd{App
  }}{\hlopt{(}}{\hlkwd{Var }}{\hlstr{"y"}}{\hlopt{, }}{\hlkwd{Var
  }}{\hlstr{"x6"}}{\hlopt{)), }}{\hlkwd{Var }}{\hlstr{"x5"}}{\hlopt{)),
  (}}{\hlnum{7}}{\hlopt{, []))}}{\hlendline{}}
  
  \item If we separated the reader monad and the state monad, we would avoid
  the lines:\\
  {\hlstd{ \ \ \ }}{\hlopt{(}}{\hlstd{fresh'}}{\hlopt{,
  }}{\hlstd{{\textunderscore}}}{\hlopt{) <--
  }}{\hlstd{get}}{\hlopt{;}}{\hlendline{Restoring the ``reader'' part
  \tmverbatim{env}}}\\
  {\hlstd{ \ \ \ put }}{\hlopt{(}}{\hlstd{fresh'}}{\hlopt{,
  }}{\hlstd{env}}{\hlopt{);}}{\hlendline{but preserving the ``state'' part
  \tmverbatim{fresh}.}}
  
  \item The elegant way is to define the monad locally:
  
  {\hlkwa{let }}{\hlstd{alpha{\textunderscore}conv t
  }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let module }}{\hlkwd{S }}{\hlopt{=
  }}{\hlkwd{StateM}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlopt{(}}{\hlkwa{struct type }}{\hlstd{t }}{\hlopt{=
  }}{\hlkwb{int }}{\hlopt{* (}}{\hlkwb{string }}{\hlopt{*
  }}{\hlkwb{string}}{\hlopt{) }}{\hlstd{list }}{\hlkwa{end}}{\hlopt{)
  }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let open }}{\hlkwd{S }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let rec }}{\hlstd{aux }}{\hlopt{=
  }}{\hlkwa{function}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Var }}{\hlstd{x }}{\hlkwa{as
  }}{\hlstd{v }}{\hlopt{-> }}{\hlkwa{perform}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ }}{\hlopt{(}}{\hlstd{fresh}}{\hlopt{,
  }}{\hlstd{env}}{\hlopt{) <-- }}{\hlstd{get}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ }}{\hlkwa{let }}{\hlstd{v }}{\hlopt{= }}{\hlkwa{try
  }}{\hlkwd{Var }}{\hlopt{(}}{\hlkwc{List}}{\hlopt{.}}{\hlstd{assoc x
  env}}{\hlopt{)}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ \ \ }}{\hlkwa{with }}{\hlkwd{Not{\textunderscore}found
  }}{\hlopt{-> }}{\hlstd{v }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ return v{\hlendline{}}\\
  \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Lam }}{\hlopt{(}}{\hlstd{x}}{\hlopt{,
  }}{\hlstd{t}}{\hlopt{) -> }}{\hlkwa{perform}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ }}{\hlopt{(}}{\hlstd{fresh}}{\hlopt{,
  }}{\hlstd{env}}{\hlopt{) <-- }}{\hlstd{get}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ }}{\hlkwa{let }}{\hlstd{x' }}{\hlopt{= }}{\hlstd{x
  {\textasciicircum} string{\textunderscore}of{\textunderscore}int fresh
  }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ put
  }}{\hlopt{(}}{\hlstd{fresh}}{\hlopt{+}}{\hlnum{1}}{\hlopt{,
  (}}{\hlstd{x}}{\hlopt{,
  }}{\hlstd{x'}}{\hlopt{)::}}{\hlstd{env}}{\hlopt{);}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ t' }}{\hlopt{<-- }}{\hlstd{aux
  t}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ }}{\hlopt{(}}{\hlstd{fresh'}}{\hlopt{,
  }}{\hlstd{{\textunderscore}}}{\hlopt{) <--
  }}{\hlstd{get}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ put }}{\hlopt{(}}{\hlstd{fresh'}}{\hlopt{,
  }}{\hlstd{env}}{\hlopt{);}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ return }}{\hlopt{(}}{\hlkwd{Lam
  }}{\hlopt{(}}{\hlstd{x'}}{\hlopt{,
  }}{\hlstd{t'}}{\hlopt{))}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{App
  }}{\hlopt{(}}{\hlstd{t1}}{\hlopt{, }}{\hlstd{t2}}{\hlopt{) ->
  }}{\hlkwa{perform}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ t1 }}{\hlopt{<-- }}{\hlstd{aux t1}}{\hlopt{; }}{\hlstd{t2
  }}{\hlopt{<-- }}{\hlstd{aux t2}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ return }}{\hlopt{(}}{\hlkwd{App
  }}{\hlopt{(}}{\hlstd{t1}}{\hlopt{, }}{\hlstd{t2}}{\hlopt{))
  }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlstd{run }}{\hlopt{(}}{\hlstd{aux t}}{\hlopt{)
  (}}{\hlnum{0}}{\hlopt{, [])}}{\hlendline{}}
\end{itemize}

\section{Monad transformers}

\begin{itemize}
  \item Based on:
  \href{http://lambda.jimpryor.net/monad_transformers/}{http://lambda.jimpryor.net/monad\_transformers/}
  
  \item Sometimes we need merits of multiple monads at the same time, e.g.
  monads {\hlkwc{AM}} and {\hlkwc{BM}}.
  
  \item Straightforwad idea is to nest one monad within another:
  \begin{itemize}
    \item either {\hlstd{'a }}{\hlkwc{AM}}{\hlopt{.}}{\hlstd{monad
    }}{\hlkwc{BM}}{\hlopt{.}}{\hlstd{monad}}
    
    \item or {\hlstd{'a }}{\hlkwc{BM}}{\hlopt{.}}{\hlstd{monad
    }}{\hlkwc{AM}}{\hlopt{.}}{\hlstd{monad}}.
  \end{itemize}
  \item But we want a monad that has operations of both {\hlkwc{AM}} and
  {\hlkwc{BM}}.
  
  \item It turns out that the straightforward approach does not lead to
  operations with the meaning we want.
  
  \item A {\tmem{monad transformer}} {\hlkwc{AT}} takes a monad {\hlkwc{BM}}
  and turns it into a monad {\hlkwc{AT{\hlopt{(}}BM{\hlopt{)}}}} which
  actually wraps around {\hlkwc{BM}} on both sides.
  {\hlkwc{AT{\hlopt{(}}BM{\hlopt{)}}}} has operations of both monads.
  
  \item We will develop a monad transformer {\hlkwc{StateT}} which adds state
  to a monad-plus. The resulting monad has all: \tmverbatim{return},
  \tmverbatim{bind}, \tmverbatim{mzero}, \tmverbatim{mplus}, \tmverbatim{put},
  \tmverbatim{get} and their supporting general-purpose functions.
  \begin{itemize}
    \item There is no reason for {\hlkwc{StateT}} not to provide state to any
    flavor of monads. Our restriction to monad-plus is because the type/module
    system makes more general solutions harder.
  \end{itemize}
  \item We need monad transformers in OCaml because ``monads are
  conta{\nobreak}gious'': although we have built-in state and exceptions, we
  need to use monadic state and exceptions when we are inside a monad.
  \begin{itemize}
    \item The reason {\tmem{Lwt}} is both a concurrency and an exception
    monad.
  \end{itemize}
  \item Things get {\tmem{interesting}} when we have several monad
  transformers, e.g. {\hlkwc{AT}}, {\hlkwc{BT}}, ... We can compose them in
  various orders: {\hlkwc{AT{\hlopt{(}}BT{\hlopt{(}}CM{\hlopt{))}}}},
  {\hlkwc{BT{\hlopt{(}}AT{\hlopt{(}}CM{\hlopt{))}}}}, ... achieving different
  results.
  \begin{itemize}
    \item With a single trasformer, we will not get into issues with
    multiple-layer monads...
    
    \item They are worth exploring -- especially if you plan a career around
    programming in Haskell.
  \end{itemize}
  \item The state monad, using {\hlopt{(}}{\hlkwa{fun }}{\hlstd{x }}{\hlopt{->
  }}...{\hlopt{) }}{\hlstd{a}} instead of {\hlkwa{let }}{\hlstd{x }}{\hlopt{=
  }}{\hlstd{a }}{\hlkwa{in }}...
  
  {\hlkwa{type }}{\hlstd{'a state }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ \ \ store }}{\hlopt{-> (}}{\hlstd{'a }}{\hlopt{*
  }}{\hlstd{store}}{\hlopt{)}}{\hlendline{}}
  
  {\hlkwa{let }}\tmverbatim{return} {\hlopt{(}}{\hlstd{a }}{\hlopt{:
  }}{\hlstd{'a}}{\hlopt{) : }}{\hlstd{'a state }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{fun }}{\hlstd{s }}{\hlopt{->
  (}}{\hlstd{a}}{\hlopt{, }}{\hlstd{s}}{\hlopt{)}}{\hlendline{}}
  
  {\hlkwa{let }}{\hlstd{bind }}{\hlopt{(}}{\hlstd{u }}{\hlopt{: }}{\hlstd{'a
  state}}{\hlopt{) (}}{\hlstd{f }}{\hlopt{: }}{\hlstd{'a }}{\hlopt{->
  }}{\hlstd{'b state}}{\hlopt{) : }}{\hlstd{'b state
  }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{fun }}{\hlstd{s }}{\hlopt{-> (}}{\hlkwa{fun
  }}{\hlopt{(}}{\hlstd{a}}{\hlopt{, }}{\hlstd{s'}}{\hlopt{) -> }}{\hlstd{f a
  s'}}{\hlopt{) (}}{\hlstd{u s}}{\hlopt{)}}{\hlendline{}}
  
  \item Monad {\hlkwc{M}} transformed to add state, in pseudo-code:
  
  {\hlkwa{type }}{\hlstd{'a stateT}}{\hlopt{(}}{\hlkwd{M}}{\hlopt{)
  =}}{\hlendline{}}\\
  {\hlstd{ \ \ \ store }}{\hlopt{-> (}}{\hlstd{'a }}{\hlopt{*
  }}{\hlstd{store}}{\hlopt{) }}{\hlkwd{M}}{\hlendline{}}\\
  {\hlcom{(* notice this is not an ('a M) state *)}}{\hlendline{}}
  
  {\hlkwa{let }}\tmverbatim{return }{\hlopt{(}}{\hlstd{a }}{\hlopt{:
  }}{\hlstd{'a}}{\hlopt{) : }}{\hlstd{'a
  stateT}}{\hlopt{(}}{\hlkwd{M}}{\hlopt{) =}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{fun }}{\hlstd{s }}{\hlopt{->
  }}{\hlkwc{M}}{\hlopt{.}}\tmverbatim{return }{\hlopt{(}}{\hlstd{a}}{\hlopt{,
  }}{\hlstd{s}}{\hlopt{)}}{\hlendline{}}Rather than returning, M.return
  
  {\hlkwa{let }}{\hlstd{bind}}{\hlopt{(}}{\hlstd{u}}{\hlopt{:}}{\hlstd{'a
  stateT}}{\hlopt{(}}{\hlkwd{M}}{\hlopt{))(}}{\hlstd{f}}{\hlopt{:}}{\hlstd{'a}}{\hlopt{->}}{\hlstd{'b
  stateT}}{\hlopt{(}}{\hlkwd{M}}{\hlopt{)):}}{\hlstd{'b
  stateT}}{\hlopt{(}}{\hlkwd{M}}{\hlopt{)=}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{fun }}{\hlstd{s }}{\hlopt{->
  }}{\hlkwc{M}}{\hlopt{.}}{\hlstd{bind }}{\hlopt{(}}{\hlstd{u s}}{\hlopt{)
  (}}{\hlkwa{fun }}{\hlopt{(}}{\hlstd{a}}{\hlopt{, }}{\hlstd{s'}}{\hlopt{) ->
  }}{\hlstd{f a s'}}{\hlopt{)}}{\hlendline{}}\\
  {\hlendline{}}Rather than let-binding, M.bind
\end{itemize}

\subsection{State transformer}

{\hlkwa{module }}{\hlkwd{StateT }}{\hlopt{(}}{\hlkwd{MP }}{\hlopt{:
}}{\hlkwd{MONAD{\textunderscore}PLUS{\textunderscore}OPS}}{\hlopt{)
(}}{\hlkwd{Store }}{\hlopt{: }}{\hlkwa{sig type }}{\hlstd{t
}}{\hlkwa{end}}{\hlopt{) : }}{\hlkwa{sig}}{\hlendline{Functor takes two
modules -- the second one}}\\
{\hlstd{ \ }}{\hlkwa{type }}{\hlstd{store }}{\hlopt{=
}}{\hlkwc{Store}}{\hlopt{.}}\tmverbatim{t}{\hlendline{provides only the
storage type.}}\\
\tmverbatim{ \ }{\hlkwa{type }}{\hlstd{'a t }}{\hlopt{= }}{\hlstd{store
}}{\hlopt{-> (}}{\hlstd{'a }}{\hlopt{* }}{\hlstd{store}}{\hlopt{)
}}{\hlkwc{MP}}{\hlopt{.}}{\hlstd{monad{\hlendline{}}\\
\ }}{\hlkwa{include
}}{\hlkwd{MONAD{\textunderscore}PLUS{\textunderscore}OPS}}{\hlendline{Exporting
all the monad-plus operations}}\\
{\hlstd{ \ }}{\hlkwa{include }}{\hlkwd{STATE }}{\hlkwa{with type }}{\hlstd{'a
t }}{\hlopt{:= }}\tmverbatim{'a monad}{\hlendline{and state operations.}}\\
\tmverbatim{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }{\hlkwa{and type }}{\hlstd{store
}}{\hlopt{:= }}{\hlstd{store{\hlendline{}}\\
\ }}{\hlkwa{val }}{\hlstd{run }}{\hlopt{: }}{\hlstd{'a monad }}{\hlopt{->
}}\tmverbatim{'a t}{\hlendline{Expose ``what happened'' -- resulting
states.}}\\
\tmverbatim{ \ }{\hlkwa{val }}{\hlstd{runT }}{\hlopt{: }}{\hlstd{'a monad
}}{\hlopt{-> }}{\hlstd{store }}{\hlopt{-> }}{\hlstd{'a
}}{\hlkwc{MP}}{\hlopt{.}}{\hlstd{monad}}{\hlendline{}}\\
{\hlkwa{end }}{\hlopt{= }}{\hlkwa{struct}}{\hlendline{Run the state
transformer -- get the resulting values.}}\\
{\hlstd{ \ }}{\hlkwa{type }}{\hlstd{store }}{\hlopt{=
}}{\hlkwc{Store}}{\hlopt{.}}\tmverbatim{t}{\hlendline{}}

\tmverbatim{ \ }{\hlkwa{module }}{\hlkwd{M }}{\hlopt{=
}}{\hlkwa{struct}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwa{type }}{\hlstd{'a t }}{\hlopt{= }}{\hlstd{store
}}{\hlopt{-> (}}{\hlstd{'a }}{\hlopt{* }}{\hlstd{store}}{\hlopt{)
}}{\hlkwc{MP}}{\hlopt{.}}{\hlstd{monad{\hlendline{}}\\
\ \ \ }}{\hlkwa{let }}{\hlstd{return a }}{\hlopt{= }}{\hlkwa{fun }}{\hlstd{s
}}{\hlopt{-> }}{\hlkwc{MP}}{\hlopt{.}}{\hlstd{return
}}{\hlopt{(}}{\hlstd{a}}{\hlopt{, }}{\hlstd{s}}{\hlopt{)}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{bind m b }}{\hlopt{= }}{\hlkwa{fun
}}{\hlstd{s }}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlkwc{MP}}{\hlopt{.}}{\hlstd{bind
}}{\hlopt{(}}{\hlstd{m s}}{\hlopt{) (}}{\hlkwa{fun
}}{\hlopt{(}}{\hlstd{a}}{\hlopt{, }}{\hlstd{s'}}{\hlopt{) -> }}{\hlstd{b a
s'}}{\hlopt{)}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{mzero }}{\hlopt{= }}{\hlkwa{fun
}}{\hlstd{{\textunderscore} }}{\hlopt{->
}}{\hlkwc{MP}}{\hlopt{.}}\tmverbatim{mzero}{\hlendline{{\tmem{Lift}} the
monad-plus operations.}}\\
\tmverbatim{ \ \ \ }{\hlkwa{let }}{\hlstd{mplus ma mb }}{\hlopt{=
}}{\hlkwa{fun }}{\hlstd{s }}{\hlopt{-> }}{\hlkwc{MP}}{\hlopt{.}}{\hlstd{mplus
}}{\hlopt{(}}{\hlstd{ma s}}{\hlopt{) (}}{\hlstd{mb
s}}{\hlopt{)}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlkwa{end}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlkwa{include }}{\hlkwd{M}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlkwa{include
}}{\hlkwd{MonadPlusOps}}{\hlopt{(}}{\hlkwd{M}}{\hlopt{)}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlkwa{let }}{\hlstd{get }}{\hlopt{= }}{\hlkwa{fun }}{\hlstd{s
}}{\hlopt{-> }}{\hlkwc{MP}}{\hlopt{.}}{\hlstd{return
}}{\hlopt{(}}{\hlstd{s}}{\hlopt{, }}{\hlstd{s}}{\hlopt{)}}{\hlendline{Instead
of just returning,}}\\
{\hlstd{ \ }}{\hlkwa{let }}{\hlstd{put s' }}{\hlopt{= }}{\hlkwa{fun
}}{\hlstd{{\textunderscore} }}{\hlopt{->
}}{\hlkwc{MP}}{\hlopt{.}}{\hlstd{return }}{\hlopt{((),
}}{\hlstd{s'}}{\hlopt{)}}{\hlendline{MP.return.}}\\
{\hlstd{ \ }}{\hlkwa{let }}{\hlstd{runT m s }}{\hlopt{=
}}{\hlkwc{MP}}{\hlopt{.}}{\hlstd{lift fst }}{\hlopt{(}}{\hlstd{m
s}}{\hlopt{)}}{\hlendline{}}\\
{\hlkwa{end}}{\hlstd{ \ \ \ }}{\hlendline{}}

\subsection{Backtracking with state}

{\hlkwa{module }}{\hlkwd{HoneyIslands }}{\hlopt{(}}{\hlkwd{M }}{\hlopt{:
}}{\hlkwd{MONAD{\textunderscore}PLUS{\textunderscore}OPS}}{\hlopt{) =
}}{\hlkwa{struct}}{\hlendline{}}\\
{\hlkwa{ \ type }}{\hlstd{state }}{\hlopt{= \{}}{\hlendline{For use with list
monad or lazy list monad.}}\\
{\hlstd{ \ \ \ been{\textunderscore}size}}{\hlopt{:
}}{\hlkwb{int}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ \ \ been{\textunderscore}islands}}{\hlopt{:
}}{\hlkwb{int}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ \ \ unvisited}}{\hlopt{: }}{\hlstd{cell
list}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ \ \ visited}}{\hlopt{:
}}{\hlkwc{CellSet}}{\hlopt{.}}{\hlstd{t}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ \ \ eaten}}{\hlopt{: }}{\hlstd{cell
list}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ \ \ more{\textunderscore}to{\textunderscore}eat}}{\hlopt{:
}}{\hlkwb{int}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlopt{\}}}{\hlendline{}}\\
{\hlstd{{\hlendline{}}\\
\ }}{\hlkwa{let }}{\hlstd{init{\textunderscore}state unvisited
more{\textunderscore}to{\textunderscore}eat }}{\hlopt{= \{}}{\hlendline{}}\\
{\hlstd{ \ \ \ been{\textunderscore}size }}{\hlopt{=
}}{\hlnum{0}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ \ \ been{\textunderscore}islands }}{\hlopt{=
}}{\hlnum{0}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ \ \ unvisited}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ \ \ visited }}{\hlopt{=
}}{\hlkwc{CellSet}}{\hlopt{.}}{\hlstd{empty}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ \ \ eaten }}{\hlopt{= [];}}{\hlendline{}}\\
{\hlstd{ \ \ \
more{\textunderscore}to{\textunderscore}eat}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlopt{\}}}{\hlendline{}}

{\hlkwa{ \ module }}{\hlkwd{BacktrackingM }}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwd{StateT }}{\hlopt{(}}{\hlkwd{M}}{\hlopt{)
(}}{\hlkwa{struct type }}{\hlstd{t }}{\hlopt{= }}{\hlstd{state
}}{\hlkwa{end}}{\hlopt{)}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlkwa{open }}{\hlkwd{BacktrackingM}}{\hlendline{}}\\
{\hlstd{{\hlendline{}}\\
\ }}{\hlkwa{let rec }}{\hlstd{visit{\textunderscore}cell }}{\hlopt{() =
}}{\hlkwa{perform}}{\hlendline{State update actions.}}\\
{\hlstd{ \ \ \ \ \ s }}{\hlopt{<-- }}{\hlstd{get}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlkwa{match }}{\hlstd{s}}{\hlopt{.}}{\hlstd{unvisited
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlopt{\textbar  [] -> }}{\hlstd{return
}}{\hlkwd{None}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ {\hlopt{\textbar}} c}}{\hlopt{::}}{\hlstd{remaining
}}{\hlkwa{when }}{\hlkwc{CellSet}}{\hlopt{.}}{\hlstd{mem c
s}}{\hlopt{.}}{\hlstd{visited }}{\hlopt{-> }}{\hlkwa{perform}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ put }}{\hlopt{\{}}{\hlstd{s }}{\hlkwa{with
}}{\hlstd{unvisited}}{\hlopt{=}}{\hlstd{remaining}}{\hlopt{\};}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ visit{\textunderscore}cell
}}{\hlopt{()}}{\hlendline{Throwaway argument because of recursion. See (*)}}\\
{\hlstd{ \ \ \ {\hlopt{\textbar}} c}}{\hlopt{::}}{\hlstd{remaining
}}{\hlcom{(* when c not visited *)}}{\hlstd{ }}{\hlopt{->
}}{\hlkwa{perform}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ put }}{\hlopt{\{}}{\hlstd{s
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \
unvisited}}{\hlopt{=}}{\hlstd{remaining}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ visited }}{\hlopt{=
}}{\hlkwc{CellSet}}{\hlopt{.}}{\hlstd{add c
s}}{\hlopt{.}}{\hlstd{visited}}{\hlopt{\};}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ return }}{\hlopt{(}}{\hlkwd{Some
}}{\hlstd{c}}{\hlopt{)}}{\hlendline{This action returns a value.}}

{\hlkwa{ \ let }}{\hlstd{eat{\textunderscore}cell c }}{\hlopt{=
}}{\hlkwa{perform}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ s }}{\hlopt{<-- }}{\hlstd{get}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ put }}{\hlopt{\{}}{\hlstd{s }}{\hlkwa{with }}{\hlstd{eaten
}}{\hlopt{=
}}{\hlstd{c}}{\hlopt{::}}{\hlstd{s}}{\hlopt{.}}{\hlstd{eaten}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ visited }}{\hlopt{=
}}{\hlkwc{CellSet}}{\hlopt{.}}{\hlstd{add c
s}}{\hlopt{.}}{\hlstd{visited}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ more{\textunderscore}to{\textunderscore}eat }}{\hlopt{=
}}{\hlstd{s}}{\hlopt{.}}{\hlstd{more{\textunderscore}to{\textunderscore}eat
}}{\hlopt{- }}{\hlnum{1}}{\hlopt{\};}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ return }}{\hlopt{()}}{\hlendline{Remaining state update
actions just affect the state.}}\\
{\hlstd{{\hlendline{}}\\
\ }}{\hlkwa{let }}{\hlstd{keep{\textunderscore}cell c }}{\hlopt{=
}}{\hlkwa{perform}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ s }}{\hlopt{<-- }}{\hlstd{get}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ put }}{\hlopt{\{}}{\hlstd{s
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ visited }}{\hlopt{=
}}{\hlkwc{CellSet}}{\hlopt{.}}{\hlstd{add c
s}}{\hlopt{.}}{\hlstd{visited}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ been{\textunderscore}size }}{\hlopt{=
}}{\hlstd{s}}{\hlopt{.}}{\hlstd{been{\textunderscore}size }}{\hlopt{+
}}{\hlnum{1}}{\hlopt{\};}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ return }}{\hlopt{()}}{\hlendline{}}\\
{\hlstd{{\hlendline{}}\\
\ }}{\hlkwa{let }}{\hlstd{fresh{\textunderscore}island }}{\hlopt{=
}}{\hlkwa{perform}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ s }}{\hlopt{<-- }}{\hlstd{get}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ put }}{\hlopt{\{}}{\hlstd{s }}{\hlkwa{with
}}{\hlstd{been{\textunderscore}size }}{\hlopt{=
}}{\hlnum{0}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ been{\textunderscore}islands }}{\hlopt{=
}}{\hlstd{s}}{\hlopt{.}}{\hlstd{been{\textunderscore}islands }}{\hlopt{+
}}{\hlnum{1}}{\hlopt{\};}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ return }}{\hlopt{()}}{\hlendline{}}

{\hlkwa{ \ let }}{\hlstd{find{\textunderscore}to{\textunderscore}eat n
island{\textunderscore}size num{\textunderscore}islands
empty{\textunderscore}cells }}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{honey }}{\hlopt{=
}}{\hlstd{honey{\textunderscore}cells n empty{\textunderscore}cells
}}{\hlkwa{in}}{\hlendline{}}\\
{\hlendline{OCaml does not realize that \tmverbatim{'a monad} with state is
actually a function --}}\\
\ \ \ {\hlkwa{let rec }}{\hlstd{find{\textunderscore}board }}{\hlopt{() =
}}{\hlkwa{perform}}{\hlendline{it's an abstract type.(*)}}\\
{\hlstd{ \ \ \ \ \ \ \ cell }}{\hlopt{<-- }}{\hlstd{visit{\textunderscore}cell
}}{\hlopt{();}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ }}{\hlkwa{match }}{\hlstd{cell
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{None }}{\hlopt{->
}}{\hlkwa{perform}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ s }}{\hlopt{<--
}}{\hlstd{get}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ guard
}}{\hlopt{(}}{\hlstd{s}}{\hlopt{.}}{\hlstd{been{\textunderscore}islands
}}{\hlopt{=
}}{\hlstd{num{\textunderscore}islands}}{\hlopt{);}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ return
s}}{\hlopt{.}}{\hlstd{eaten{\hlendline{}}\\
\ \ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Some }}{\hlstd{cell }}{\hlopt{->
}}{\hlkwa{perform}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \
fresh{\textunderscore}island}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ find{\textunderscore}island
cell}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ s }}{\hlopt{<--
}}{\hlstd{get}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ guard
}}{\hlopt{(}}{\hlstd{s}}{\hlopt{.}}{\hlstd{been{\textunderscore}size
}}{\hlopt{=
}}{\hlstd{island{\textunderscore}size}}{\hlopt{);}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ find{\textunderscore}board
}}{\hlopt{()}}{\hlendline{}}

{\hlkwa{ \ \ \ and }}{\hlstd{find{\textunderscore}island current }}{\hlopt{=
}}{\hlkwa{perform}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ keep{\textunderscore}cell
current}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ neighbors n empty{\textunderscore}cells
current{\hlendline{}}\\
\ \ \ \ \ \ \ {\hlopt{\textbar}}}}{\hlopt{>
}}\tmverbatim{foldM}{\hlendline{The partial answer sits in the state --
throwaway result.}}\\
\tmverbatim{ \ \ \ \ \ \ \ \ \ \ \ }{\hlopt{(}}{\hlkwa{fun }}{\hlopt{()
}}{\hlstd{neighbor }}{\hlopt{-> }}{\hlkwa{perform}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ s }}{\hlopt{<--
}}{\hlstd{get}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ whenM }}{\hlopt{(}}{\hlstd{not
}}{\hlopt{(}}{\hlkwc{CellSet}}{\hlopt{.}}{\hlstd{mem neighbor
s}}{\hlopt{.}}{\hlstd{visited}}{\hlopt{))}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }}{\hlopt{(}}{\hlkwa{let
}}{\hlstd{choose{\textunderscore}eat }}{\hlopt{=
}}{\hlkwa{perform}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ guard
}}{\hlopt{(}}{\hlstd{s}}{\hlopt{.}}{\hlstd{more{\textunderscore}to{\textunderscore}eat
}}{\hlopt{> }}{\hlnum{0}}{\hlopt{);}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ eat{\textunderscore}cell
neighbor{\hlendline{}}\\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }}{\hlkwa{and
}}{\hlstd{choose{\textunderscore}keep }}{\hlopt{=
}}{\hlkwa{perform}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ guard
}}{\hlopt{(}}{\hlstd{s}}{\hlopt{.}}{\hlstd{been{\textunderscore}size
}}{\hlopt{<
}}{\hlstd{island{\textunderscore}size}}{\hlopt{);}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ find{\textunderscore}island
neighbor }}{\hlkwa{in}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ choose{\textunderscore}eat
}}{\hlopt{++ }}{\hlstd{choose{\textunderscore}keep}}{\hlopt{)) ()
}}{\hlkwa{in}}{\hlendline{}}

{\hlkwa{ \ \ \ let }}{\hlstd{cells{\textunderscore}to{\textunderscore}eat
}}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlkwc{List}}{\hlopt{.}}{\hlstd{length honey }}{\hlopt{-
}}{\hlstd{island{\textunderscore}size }}{\hlopt{*
}}{\hlstd{num{\textunderscore}islands }}{\hlkwa{in}}{\hlendline{}}\\
{\hlstd{ \ \ \ init{\textunderscore}state honey
cells{\textunderscore}to{\textunderscore}eat{\hlendline{}}\\
\ \ \ {\hlopt{\textbar}}}}{\hlopt{> }}{\hlstd{runT
}}{\hlopt{(}}{\hlstd{find{\textunderscore}board
}}{\hlopt{())}}{\hlendline{}}\\
{\hlendline{}}\\
{\hlkwa{end}}{\hlendline{}}\\
{\hlendline{}}\\
{\hlkwa{module }}{\hlkwd{HoneyL }}{\hlopt{= }}{\hlkwd{HoneyIslands
}}{\hlopt{(}}{\hlkwd{ListM}}{\hlopt{)}}{\hlendline{}}\\
{\hlkwa{let }}{\hlstd{find{\textunderscore}to{\textunderscore}eat a b c d
}}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlkwc{ListM}}{\hlopt{.}}{\hlstd{run
}}{\hlopt{(}}{\hlkwc{HoneyL}}{\hlopt{.}}{\hlstd{find{\textunderscore}to{\textunderscore}eat
a b c d}}{\hlopt{)}}{\hlendline{}}\\


\section{Probabilistic Programming}

\begin{itemize}
  \item Using a random number generator, we can define procedures that produce
  various output. This is {\tmstrong{not functional}} -- mathematical
  functions have a deterministic result for fixed arguments.
  
  \item Similarly to how we can ``simulate'' (mutable) variables with state
  monad and non-determinism (i.e. making choices) with list monad, we can
  ``simulate'' random computation with probability monad.
  
  \item The probability monad class means much more than having randomized
  computation. We can ask questions about probabilities of results. Monad
  instances can make tradeoffs of efficiency vs. accuracy (exact vs.
  approximate probabilities).
  
  \item Probability monad imposes limitations on what approximation algorithms
  can be implemented.
  \begin{itemize}
    \item Efficient {\tmem{probabilistic programming}} library for OCaml,
    based on continuations, memoisation and reified search trees:\\
    \href{http://okmij.org/ftp/kakuritu/index.html}{http://okmij.org/ftp/kakuritu/index.html}
  \end{itemize}
\end{itemize}

\subsection{The probability monad}

\begin{itemize}
  \item The essential functions for the probability monad class are
  \tmverbatim{choose} and \tmverbatim{distrib} -- remaining functions could be
  defined in terms of these but are provided by each instance for efficiency.
  
  \item Inside-monad operations:
  \begin{itemize}
    \item {\hlstd{choose }}{\hlopt{: }}{\hlkwb{float }}{\hlopt{-> }}{\hlstd{'a
    monad }}{\hlopt{-> }}{\hlstd{'a monad }}{\hlopt{-> }}{\hlstd{'a monad}}
    
    \tmverbatim{choose p a b} represents an event or distribution which is $a$
    with probability $p$ and is $b$ with probability $1 - p$.
    
    \item {\hlkwa{val }}{\hlstd{pick }}{\hlopt{: (}}{\hlstd{'a }}{\hlopt{*
    }}{\hlkwb{float}}{\hlopt{) }}{\hlstd{list }}{\hlopt{-> }}{\hlstd{'a
    t}}{\hlendline{}}
    
    A result from the provided distribution over values. The argument must be
    a probability distribution: positive values summing to 1.
    
    \item {\hlkwa{val }}{\hlstd{uniform }}{\hlopt{: }}{\hlstd{'a list
    }}{\hlopt{-> }}{\hlstd{'a monad}}{\hlendline{}}
    
    Uniform distribution over given values.
    
    \item {\hlkwa{val }}{\hlstd{flip }}{\hlopt{: }}\tmverbatim{}{\hlkwb{float
    {\hlopt{-> }}bool }}{\hlstd{monad}}{\hlendline{}}
    
    Equal to \tmverbatim{choose 0.5 (return true) (return false)}.
    
    \item {\hlkwa{val }}{\hlstd{coin }}{\hlopt{: }}{\hlkwb{bool
    }}{\hlstd{monad}}{\hlendline{Equal to \tmverbatim{flip 0.5}.}}
  \end{itemize}
  \item And some operations for getting out of the monad:
  \begin{itemize}
    \item {\hlkwa{val }}{\hlstd{prob }}{\hlopt{: (}}{\hlstd{'a }}{\hlopt{->
    }}{\hlkwb{bool}}{\hlopt{) -> }}{\hlstd{'a monad }}{\hlopt{->
    }}{\hlkwb{float}}{\hlendline{}}
    
    Returns the probability that the predicate holds.
    
    \item {\hlkwa{val }}{\hlstd{distrib }}{\hlopt{: }}{\hlstd{'a monad
    }}{\hlopt{-> (}}{\hlstd{'a }}{\hlopt{* }}{\hlkwb{float}}{\hlopt{)
    }}{\hlstd{list}}{\hlendline{}}
    
    Returns the distribution of probabilities over the resulting values.
    
    \item {\hlkwa{val }}{\hlstd{access {\hlopt{:}} 'a monad }}{\hlopt{->
    }}{\hlstd{'a}}{\hlendline{}}
    
    Samples a {\tmem{random}} result from the distribution --
    {\tmstrong{non-functional}} behavior.
  \end{itemize}
  \item We give two instances of the probability monad: exact distribution
  monad, and sampling monad, which can approximate distributions.
  \begin{itemize}
    \item The sampling monad is entirely non-functional: in Haskell, it lives
    in the IO monad.
  \end{itemize}
  \item The monad instances indeed represent probability distributions:
  collections of positive numbers that add up to 1 -- although often
  \tmverbatim{merge} rather than \tmverbatim{normalize} is used. {\small{If
  \tmverbatim{pick} and \tmverbatim{choose} are used correctly.}}
  
  \item {\hlkwa{module type }}{\hlkwd{PROBABILITY }}{\hlopt{=
  }}{\hlkwa{sig}}{\hlendline{Probability monad class.}}\\
  {\hlstd{ \ }}{\hlkwa{include
  }}{\hlkwd{MONAD{\textunderscore}OPS}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{val }}{\hlstd{choose }}{\hlopt{: }}{\hlkwb{float
  }}{\hlopt{-> }}{\hlstd{'a monad }}{\hlopt{-> }}{\hlstd{'a monad }}{\hlopt{->
  }}{\hlstd{'a monad{\hlendline{}}\\
  \ }}{\hlkwa{val }}{\hlstd{pick }}{\hlopt{: (}}{\hlstd{'a }}{\hlopt{*
  }}{\hlkwb{float}}{\hlopt{) }}{\hlstd{list }}{\hlopt{-> }}\tmverbatim{'a
  monad}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{val }}{\hlstd{uniform }}{\hlopt{: }}{\hlstd{'a list
  }}{\hlopt{-> }}{\hlstd{'a monad}}{\hlendline{}}\\
  \tmverbatim{ \ }{\hlkwa{val }}{\hlstd{coin }}{\hlopt{: }}{\hlkwb{bool
  }}{\hlstd{monad{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{val }}{\hlstd{flip }}{\hlopt{: }}{\hlkwb{float
  }}{\hlopt{-> }}{\hlkwb{bool }}{\hlstd{monad}}{\hlendline{}}\\
  \ }}{\hlkwa{val }}{\hlstd{prob }}{\hlopt{: (}}{\hlstd{'a }}{\hlopt{->
  }}{\hlkwb{bool}}{\hlopt{) -> }}{\hlstd{'a monad }}{\hlopt{->
  }}{\hlkwb{float}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{val }}{\hlstd{distrib }}{\hlopt{: }}{\hlstd{'a monad
  }}{\hlopt{-> (}}{\hlstd{'a }}{\hlopt{* }}{\hlkwb{float}}{\hlopt{)
  }}{\hlstd{list{\hlendline{}}\\
  \ }}{\hlkwa{val }}{\hlstd{access }}{\hlopt{: }}{\hlstd{'a monad
  }}{\hlopt{-> }}{\hlstd{'a}}{\hlendline{}}\\
  {\hlkwa{end}}{\hlendline{}}
  
  \item {\hlkwa{let }}{\hlstd{total dist }}{\hlopt{=}}{\hlendline{Helper
  functions.}}\\
  {\hlstd{ \ }}{\hlkwc{List}}{\hlopt{.}}{\hlstd{fold{\textunderscore}left
  }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{a
  }}{\hlopt{(}}{\hlstd{{\textunderscore}}}{\hlopt{,}}{\hlstd{b}}{\hlopt{)->}}{\hlstd{a}}{\hlopt{+.}}{\hlstd{b}}{\hlopt{)
  }}{\hlnum{0}}{\hlopt{. }}{\hlstd{dist}}{\hlendline{}}\\
  {\hlkwa{let }}{\hlstd{merge dist }}{\hlopt{=}}{\hlendline{Merge repeating
  elements.}}\\
  {\hlstd{ \ map{\textunderscore}reduce }}{\hlopt{(}}{\hlkwa{fun
  }}{\hlstd{x}}{\hlopt{->}}{\hlstd{x}}{\hlopt{) (+.) }}{\hlnum{0}}{\hlopt{.
  }}{\hlstd{dist}}{\hlendline{}}\\
  {\hlkwa{let }}{\hlstd{normalize dist }}{\hlopt{= }}{\hlendline{Normalize a
  measure into a distribution.}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{tot }}{\hlopt{= }}{\hlstd{total dist
  }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{if }}{\hlstd{tot }}{\hlopt{= }}{\hlnum{0}}{\hlopt{.
  }}{\hlkwa{then }}{\hlstd{dist}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{else }}{\hlkwc{List}}{\hlopt{.}}{\hlstd{map
  }}{\hlopt{(}}{\hlkwa{fun
  }}{\hlopt{(}}{\hlstd{e}}{\hlopt{,}}{\hlstd{w}}{\hlopt{)->}}{\hlstd{e}}{\hlopt{,}}{\hlstd{w}}{\hlopt{/.}}{\hlstd{tot}}{\hlopt{)
  }}{\hlstd{dist}}{\hlendline{}}\\
  {\hlkwa{let }}{\hlstd{roulette dist }}{\hlopt{=}}{\hlendline{Roulette wheel
  from a distribution/measure.}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{tot }}{\hlopt{= }}{\hlstd{total dist
  }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let rec }}{\hlstd{aux r }}{\hlopt{= }}{\hlkwa{function
  }}{\hlopt{[] -> }}{\hlkwa{assert false}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlopt{\textbar 
  (}}{\hlstd{e}}{\hlopt{,}}{\hlstd{w}}{\hlopt{)::}}{\hlstd{{\textunderscore}
  }}{\hlkwa{when }}{\hlstd{w }}{\hlopt{<= }}{\hlstd{r }}{\hlopt{->
  }}{\hlstd{e{\hlendline{}}\\
  \ \ \ }}{\hlopt{\textbar 
  (}}{\hlstd{{\textunderscore}}}{\hlopt{,}}{\hlstd{w}}{\hlopt{)::}}{\hlstd{tl
  }}{\hlopt{-> }}{\hlstd{aux
  }}{\hlopt{(}}{\hlstd{r}}{\hlopt{-.}}{\hlstd{w}}{\hlopt{) }}{\hlstd{tl
  }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ aux }}{\hlopt{(}}{\hlkwc{Random}}{\hlopt{.}}{\hlkwb{float
  }}{\hlstd{tot}}{\hlopt{) }}{\hlstd{dist}}{\hlendline{}}
  
  \item {\hlkwa{module }}{\hlkwd{DistribM }}{\hlopt{: }}{\hlkwd{PROBABILITY
  }}{\hlopt{= }}{\hlkwa{struct}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{module }}{\hlkwd{M }}{\hlopt{=
  }}{\hlkwa{struct}}{\hlendline{Exact probability distribution -- naive
  implementation.}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{type }}{\hlstd{'a t }}{\hlopt{= (}}{\hlstd{'a
  }}{\hlopt{* }}{\hlkwb{float}}{\hlopt{) }}{\hlstd{list{\hlendline{}}\\
  \ \ \ }}{\hlkwa{let }}{\hlstd{bind a b }}{\hlopt{=
  }}\tmverbatim{merge}{\hlendline{\tmverbatim{x} w.p. $p$ and then
  \tmverbatim{y} w.p. $q$ happens =}}\tmverbatim{\\
  \ \ \ \ \ }{\hlopt{[}}{\hlstd{y}}{\hlopt{,
  }}{\hlstd{q}}{\hlopt{*.}}{\hlstd{p {\hlopt{\textbar}}
  }}{\hlopt{(}}{\hlstd{x}}{\hlopt{,}}{\hlstd{p}}{\hlopt{) <-
  }}{\hlstd{a}}{\hlopt{; (}}{\hlstd{y}}{\hlopt{,}}{\hlstd{q}}{\hlopt{) <-
  }}{\hlstd{b x}}{\hlopt{]}}{\hlendline{\tmverbatim{y} results w.p. $p q$.}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{return a }}{\hlopt{=
  [}}{\hlstd{a}}{\hlopt{, }}{\hlnum{1}}{\hlopt{.]}}{\hlendline{Certainly
  \tmverbatim{a}.}}\\
  {\hlstd{ \ }}{\hlkwa{end}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{include }}{\hlkwd{M }}{\hlkwa{include
  }}{\hlkwd{MonadOps }}{\hlopt{(}}{\hlkwd{M}}{\hlopt{)}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{choose p a b
  }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwc{List}}{\hlopt{.}}{\hlstd{map
  }}{\hlopt{(}}{\hlkwa{fun
  }}{\hlopt{(}}{\hlstd{e}}{\hlopt{,}}{\hlstd{w}}{\hlopt{) ->
  }}{\hlstd{e}}{\hlopt{, }}{\hlstd{p}}{\hlopt{*.}}{\hlstd{w}}{\hlopt{)
  }}{\hlstd{a @{\hlendline{}}\\
  \ \ \ \ \ }}{\hlkwc{List}}{\hlopt{.}}{\hlstd{map }}{\hlopt{(}}{\hlkwa{fun
  }}{\hlopt{(}}{\hlstd{e}}{\hlopt{,}}{\hlstd{w}}{\hlopt{) ->
  }}{\hlstd{e}}{\hlopt{, (}}{\hlnum{1}}{\hlopt{.
  -.}}{\hlstd{p}}{\hlopt{)*.}}{\hlstd{w}}{\hlopt{) }}{\hlstd{b{\hlendline{}}\\
  \ }}{\hlkwa{let }}{\hlstd{pick dist }}{\hlopt{=
  }}\tmverbatim{dist}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{uniform elems }}{\hlopt{=
  }}{\hlstd{normalize{\hlendline{}}\\
  \ \ \ }}{\hlopt{(}}{\hlkwc{List}}{\hlopt{.}}{\hlstd{map
  }}{\hlopt{(}}{\hlkwa{fun
  }}{\hlstd{e}}{\hlopt{->}}{\hlstd{e}}{\hlopt{,}}{\hlnum{1}}{\hlopt{.)
  }}{\hlstd{elems}}{\hlopt{)}}{\hlendline{}}\\
  \tmverbatim{ \ }{\hlkwa{let }}{\hlstd{coin }}{\hlopt{=
  [}}{\hlkwa{true}}{\hlopt{, }}{\hlnum{0.5}}{\hlopt{;
  }}{\hlkwa{false}}{\hlopt{, }}{\hlnum{0.5}}{\hlopt{]}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{flip p }}{\hlopt{=
  [}}{\hlkwa{true}}{\hlopt{, }}{\hlstd{p}}{\hlopt{; }}{\hlkwa{false}}{\hlopt{,
  }}{\hlnum{1}}{\hlopt{. -. }}{\hlstd{p}}{\hlopt{]}}{\hlendline{}}
  
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{prob p m }}{\hlopt{=
  }}{\hlstd{m{\hlendline{}}\\
  \ \ \ {\hlopt{\textbar}}}}{\hlopt{>
  }}{\hlkwc{List}}{\hlopt{.}}{\hlstd{filter }}{\hlopt{(}}{\hlkwa{fun
  }}{\hlopt{(}}{\hlstd{e}}{\hlopt{,}}{\hlstd{{\textunderscore}}}{\hlopt{) ->
  }}{\hlstd{p e}}{\hlopt{)}}{\hlendline{All cases where \tmverbatim{p}
  holds,}}\\
  {\hlstd{ \ \ \ {\hlopt{\textbar}}}}{\hlopt{>
  }}{\hlkwc{List}}{\hlopt{.}}{\hlstd{map snd {\hlopt{\textbar}}}}{\hlopt{>
  }}{\hlkwc{List}}{\hlopt{.}}{\hlstd{fold{\textunderscore}left }}{\hlopt{(+.)
  }}{\hlnum{0}}{\hlopt{.}}{\hlendline{add up.}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{distrib m }}{\hlopt{=
  }}{\hlstd{m{\hlendline{}}\\
  \ }}{\hlkwa{let }}{\hlstd{access m }}{\hlopt{= }}{\hlstd{roulette
  m}}{\hlendline{}}\\
  {\hlkwa{end}}{\hlendline{}}
  
  \item {\hlkwa{module }}{\hlkwd{SamplingM }}{\hlopt{(}}{\hlkwd{S }}{\hlopt{:
  }}{\hlkwa{sig val }}{\hlstd{samples }}{\hlopt{: }}{\hlkwb{int
  }}{\hlkwa{end}}{\hlopt{)}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlopt{: }}{\hlkwd{PROBABILITY }}{\hlopt{=
  }}{\hlkwa{struct}}{\hlendline{Parameterized by how many samples}}\\
  {\hlstd{ \ }}{\hlkwa{module }}{\hlkwd{M }}{\hlopt{=
  }}{\hlkwa{struct}}{\hlendline{used to approximate \tmverbatim{prob} or
  \tmverbatim{distrib}.}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{type }}{\hlstd{'a t }}{\hlopt{= }}{\hlkwb{unit
  }}{\hlopt{-> }}\tmverbatim{'a}{\hlendline{Randomized computation -- each
  call {\hlstd{a}}{\hlopt{()}}}}\tmverbatim{\\
  \ \ \ }{\hlkwa{let }}{\hlstd{bind a b }}{\hlopt{() = }}{\hlstd{b
  }}{\hlopt{(}}{\hlstd{a }}{\hlopt{()) ()}}{\hlendline{ is an independent
  sample.}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{return a }}{\hlopt{= }}{\hlkwa{fun
  }}{\hlopt{() -> }}\tmverbatim{a}{\hlendline{Always
  \tmverbatim{a}.}}\tmverbatim{\\
  \ }{\hlkwa{end}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{include }}{\hlkwd{M }}{\hlkwa{include
  }}{\hlkwd{MonadOps }}{\hlopt{(}}{\hlkwd{M}}{\hlopt{)}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{choose p a b }}{\hlopt{()
  =}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{if }}{\hlkwc{Random}}{\hlopt{.}}{\hlkwb{float
  }}{\hlnum{1}}{\hlopt{. <= }}{\hlstd{p }}{\hlkwa{then }}{\hlstd{a
  }}{\hlopt{() }}{\hlkwa{else }}{\hlstd{b }}{\hlopt{()}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{pick dist }}{\hlopt{= }}{\hlkwa{fun
  }}{\hlopt{() -> }}\tmverbatim{roulette dist}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{uniform elems
  }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{n }}{\hlopt{=
  }}{\hlkwc{List}}{\hlopt{.}}{\hlstd{length elems
  }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{fun }}{\hlopt{() ->
  }}{\hlkwc{List}}{\hlopt{.}}{\hlstd{nth
  }}{\hlopt{(}}{\hlkwc{Random}}{\hlopt{.}}{\hlkwb{int }}{\hlstd{n}}{\hlopt{)
  }}{\hlstd{elems}}{\hlendline{}}\\
  \tmverbatim{ \ }{\hlkwa{let }}{\hlstd{coin }}{\hlopt{=
  }}{\hlkwc{Random}}{\hlopt{.}}{\hlkwb{bool}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{flip p }}{\hlopt{= }}{\hlstd{choose p
  }}{\hlopt{(}}{\hlstd{return }}{\hlkwa{true}}{\hlopt{) (}}{\hlstd{return
  }}{\hlkwa{false}}{\hlopt{)}}{\hlendline{}}
  
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{prob p m }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{count }}{\hlopt{= }}{\hlkwb{ref
  }}{\hlnum{0 }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{for }}{\hlstd{i }}{\hlopt{= }}{\hlnum{1
  }}{\hlkwa{to }}{\hlkwc{S}}{\hlopt{.}}{\hlstd{samples
  }}{\hlkwa{do}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ }}{\hlkwa{if }}{\hlstd{p }}{\hlopt{(}}{\hlstd{m
  }}{\hlopt{()) }}{\hlkwa{then }}{\hlstd{incr count{\hlendline{}}\\
  \ \ \ }}{\hlkwa{done}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ float{\textunderscore}of{\textunderscore}int
  }}{\hlopt{!}}{\hlstd{count }}{\hlopt{/.
  }}{\hlstd{float{\textunderscore}of{\textunderscore}int
  }}{\hlkwc{S}}{\hlopt{.}}\tmverbatim{samples}{\hlendline{}}\\
  \tmverbatim{ \ }{\hlkwa{let }}{\hlstd{distrib m
  }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{dist }}{\hlopt{= }}{\hlkwb{ref
  }}{\hlopt{[] }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{for }}{\hlstd{i }}{\hlopt{= }}{\hlnum{1
  }}{\hlkwa{to }}{\hlkwc{S}}{\hlopt{.}}{\hlstd{samples
  }}{\hlkwa{do}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ dist }}{\hlopt{:= (}}{\hlstd{m }}{\hlopt{(),
  }}{\hlnum{1}}{\hlopt{.) :: !}}{\hlstd{dist
  }}{\hlkwa{done}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ normalize }}{\hlopt{(}}\tmverbatim{merge
  }{\hlopt{!}}{\hlstd{dist{\hlopt{)}}{\hlendline{}}\\
  \ }}{\hlkwa{let }}{\hlstd{access m }}{\hlopt{= }}{\hlstd{m
  }}{\hlopt{()}}{\hlendline{}}\\
  {\hlkwa{end}}{\hlendline{}}
\end{itemize}

\subsection{Example: The Monty Hall problem}

\begin{itemize}
  \item
  \href{http://en.wikipedia.org/wiki/Monty_Hall_problem}{http://en.wikipedia.org/wiki/Monty\_Hall\_problem}:
  
  \begin{quotation}
    In search of a new car, the player picks a door, say 1. The game host then
    opens one of the other doors, say 3, to reveal a goat and offers to let
    the player pick door 2 instead of door 1.
    
    \scalebox{1.45}{\includegraphics{functional-lecture08-via-latex-2.pdf}}
  \end{quotation}
  
  \item {\hlkwa{module }}{\hlkwd{MontyHall }}{\hlopt{(}}{\hlkwd{P }}{\hlopt{:
  }}{\hlkwd{PROBABILITY}}{\hlopt{) = }}{\hlkwa{struct}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{open }}{\hlkwd{P}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{type }}{\hlstd{door }}{\hlopt{= }}{\hlkwd{A
  }}{\hlopt{\textbar }}{\hlkwd{B }}{\hlopt{\textbar
  }}{\hlkwd{C}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{doors }}{\hlopt{= [}}{\hlkwd{A}}{\hlopt{;
  }}{\hlkwd{B}}{\hlopt{; }}{\hlkwd{C}}{\hlopt{]}}{\hlendline{}}
  
  {\hlkwa{ \ let }}{\hlstd{monty{\textunderscore}win switch }}{\hlopt{=
  }}{\hlkwa{perform}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ prize }}{\hlopt{<-- }}{\hlstd{uniform
  doors}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ chosen }}{\hlopt{<-- }}{\hlstd{uniform
  doors}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ opened }}{\hlopt{<-- }}{\hlstd{uniform{\hlendline{}}\\
  \ \ \ \ \ \ \ }}{\hlopt{(}}{\hlstd{list{\textunderscore}diff doors
  }}{\hlopt{[}}{\hlstd{prize}}{\hlopt{;
  }}{\hlstd{chosen}}{\hlopt{]);}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ }}{\hlkwa{let }}{\hlstd{final
  }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ \ \ }}{\hlkwa{if }}{\hlstd{switch }}{\hlkwa{then
  }}{\hlkwc{List}}{\hlopt{.}}{\hlstd{hd{\hlendline{}}\\
  \ \ \ \ \ \ \ \ \ }}{\hlopt{(}}{\hlstd{list{\textunderscore}diff doors
  }}{\hlopt{[}}{\hlstd{opened}}{\hlopt{;
  }}{\hlstd{chosen}}{\hlopt{])}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ \ \ }}{\hlkwa{else }}{\hlstd{chosen
  }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ return }}{\hlopt{(}}{\hlstd{final }}{\hlopt{=
  }}{\hlstd{prize}}{\hlopt{)}}{\hlendline{}}\\
  {\hlkwa{end}}{\hlendline{}}
  
  \item {\hlkwa{module }}{\hlkwd{MontyExact }}{\hlopt{= }}{\hlkwd{MontyHall
  }}{\hlopt{(}}{\hlkwd{DistribM}}{\hlopt{)}}{\hlendline{}}\\
  {\hlkwa{module }}{\hlkwd{Sampling1000 }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwd{SamplingM }}{\hlopt{(}}{\hlkwa{struct let
  }}{\hlstd{samples }}{\hlopt{= }}{\hlnum{1000
  }}{\hlkwa{end}}{\hlopt{)}}{\hlendline{}}\\
  {\hlkwa{module }}{\hlkwd{MontySimul }}{\hlopt{= }}{\hlkwd{MontyHall
  }}{\hlopt{(}}{\hlkwd{Sampling1000}}{\hlopt{)}}{\hlendline{}}
  
  \item {\small{{\hlstd{\# }}{\hlkwa{let }}{\hlstd{t1 }}{\hlopt{=
  }}{\hlkwc{DistribM}}{\hlopt{.}}{\hlstd{distrib
  }}{\hlopt{(}}{\hlkwc{MontyExact}}{\hlopt{.}}{\hlstd{monty{\textunderscore}win
  }}{\hlkwa{false}}{\hlopt{);;}}{\hlendline{}}\\
  {\hlkwa{val }}{\hlstd{t1 }}{\hlopt{: (}}{\hlkwb{bool }}{\hlopt{*
  }}{\hlkwb{float}}{\hlopt{) }}{\hlstd{list }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlopt{[(}}{\hlkwa{true}}{\hlopt{,
  }}{\hlnum{0.333333333333333315}}{\hlopt{); (}}{\hlkwa{false}}{\hlopt{,
  }}{\hlnum{0.66666666666666663}}{\hlopt{)]}}{\hlendline{}}\\
  {\hlstd{\# }}{\hlkwa{let }}{\hlstd{t2 }}{\hlopt{=
  }}{\hlkwc{DistribM}}{\hlopt{.}}{\hlstd{distrib
  }}{\hlopt{(}}{\hlkwc{MontyExact}}{\hlopt{.}}{\hlstd{monty{\textunderscore}win
  }}{\hlkwa{true}}{\hlopt{);;}}{\hlendline{}}\\
  {\hlkwa{val }}{\hlstd{t2 }}{\hlopt{: (}}{\hlkwb{bool }}{\hlopt{*
  }}{\hlkwb{float}}{\hlopt{) }}{\hlstd{list }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlopt{[(}}{\hlkwa{true}}{\hlopt{,
  }}{\hlnum{0.66666666666666663}}{\hlopt{); (}}{\hlkwa{false}}{\hlopt{,
  }}{\hlnum{0.333333333333333315}}{\hlopt{)]}}{\hlendline{}}\\
  {\hlstd{\# }}{\hlkwa{let }}{\hlstd{t3 }}{\hlopt{=
  }}{\hlkwc{Sampling1000}}{\hlopt{.}}{\hlstd{distrib
  }}{\hlopt{(}}{\hlkwc{MontySimul}}{\hlopt{.}}{\hlstd{monty{\textunderscore}win
  }}{\hlkwa{false}}{\hlopt{);;}}{\hlendline{}}\\
  {\hlkwa{val }}{\hlstd{t3 }}{\hlopt{: (}}{\hlkwb{bool }}{\hlopt{*
  }}{\hlkwb{float}}{\hlopt{) }}{\hlstd{list }}{\hlopt{=
  [(}}{\hlkwa{true}}{\hlopt{, }}{\hlnum{0.313}}{\hlopt{);
  (}}{\hlkwa{false}}{\hlopt{, }}{\hlnum{0.687}}{\hlopt{)]}}{\hlendline{}}\\
  {\hlstd{\# }}{\hlkwa{let }}{\hlstd{t4 }}{\hlopt{=
  }}{\hlkwc{Sampling1000}}{\hlopt{.}}{\hlstd{distrib
  }}{\hlopt{(}}{\hlkwc{MontySimul}}{\hlopt{.}}{\hlstd{monty{\textunderscore}win
  }}{\hlkwa{true}}{\hlopt{);;}}{\hlendline{}}\\
  {\hlkwa{val }}{\hlstd{t4 }}{\hlopt{: (}}{\hlkwb{bool }}{\hlopt{*
  }}{\hlkwb{float}}{\hlopt{) }}{\hlstd{list }}{\hlopt{=
  [(}}{\hlkwa{true}}{\hlopt{, }}{\hlnum{0.655}}{\hlopt{);
  (}}{\hlkwa{false}}{\hlopt{, }}{\hlnum{0.345}}{\hlopt{)]}}{\hlendline{}}}}
\end{itemize}

\subsection{Conditional probabilities}

\begin{itemize}
  \item Wouldn't it be nice to have a monad-plus rather than a monad?
  
  \item We could use \tmverbatim{guard} -- conditional probabilities!
  \begin{itemize}
    \item $P (A|B)$
    \begin{itemize}
      \item Compute what is needed for both $A$ and $B$.
      
      \item Guard $B$.
      
      \item Return $A$.
    \end{itemize}
  \end{itemize}
  \item For the exact distribution monad it turns out very easy -- we just
  need to allow intermediate distributions to be unnormalized (sum to less
  than 1).
  
  \item For the sampling monad we use rejection sampling.
  \begin{itemize}
    \item \tmverbatim{mplus} has no straightforward correct implementation.
  \end{itemize}
  \item We implemented {\hlkwd{PROBABILITY}} separately for educational
  purposes only, as {\hlkwd{COND\_PROBAB}} introduced below supersedes it.
  
  \item {\hlkwa{module type }}{\hlkwd{COND{\textunderscore}PROBAB }}{\hlopt{=
  }}{\hlkwa{sig}}{\hlendline{Class for conditional probability monad,}}\\
  {\hlstd{ \ }}{\hlkwa{include }}{\hlkwd{PROBABILITY}}{\hlendline{where
  \tmverbatim{guard cond} conditions on \tmverbatim{cond}.}}\\
  {\hlstd{ \ }}{\hlkwa{include
  }}{\hlkwd{MONAD{\textunderscore}PLUS{\textunderscore}OPS }}{\hlkwa{with type
  }}{\hlstd{'a monad }}{\hlopt{:= }}{\hlstd{'a monad}}{\hlendline{}}\\
  {\hlkwa{end}}{\hlendline{}}
  
  \item {\hlkwa{module }}{\hlkwd{DistribMP }}{\hlopt{:
  }}{\hlkwd{COND{\textunderscore}PROBAB }}{\hlopt{=
  }}{\hlkwa{struct}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{module }}{\hlkwd{MP }}{\hlopt{=
  }}{\hlkwa{struct}}{\hlendline{The measures no longer restricted to}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{type }}{\hlstd{'a t }}{\hlopt{= (}}{\hlstd{'a
  }}{\hlopt{* }}{\hlkwb{float}}{\hlopt{)
  }}\tmverbatim{list}{\hlendline{probability distributions:}}\\
  \ \ \ {\hlkwa{let }}{\hlstd{bind a b }}{\hlopt{=
  }}{\hlstd{merge{\hlendline{}}\\
  \ \ \ \ \ }}{\hlopt{[}}{\hlstd{y}}{\hlopt{,
  }}{\hlstd{q}}{\hlopt{*.}}{\hlstd{p {\hlopt{\textbar}}
  }}{\hlopt{(}}{\hlstd{x}}{\hlopt{,}}{\hlstd{p}}{\hlopt{) <-
  }}{\hlstd{a}}{\hlopt{; (}}{\hlstd{y}}{\hlopt{,}}{\hlstd{q}}{\hlopt{) <-
  }}{\hlstd{b x}}{\hlopt{]}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{return a }}{\hlopt{=
  [}}{\hlstd{a}}{\hlopt{, }}{\hlnum{1}}{\hlopt{.]}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{mzero }}{\hlopt{=
  []}}{\hlendline{Measure equal 0 everywhere is OK.}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{mplus }}{\hlopt{=
  }}{\hlkwc{List}}{\hlopt{.}}{\hlstd{append{\hlendline{}}\\
  \ }}{\hlkwa{end}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{include }}{\hlkwd{MP }}{\hlkwa{include
  }}{\hlkwd{MonadPlusOps }}{\hlopt{(}}{\hlkwd{MP}}{\hlopt{)}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{choose p a b }}{\hlopt{=}}{\hlendline{It
  isn't \tmverbatim{a} w.p. $p$ \& \tmverbatim{b} w.p. $(1 - p)$ since
  \tmverbatim{a} and \tmverbatim{b}}}\\
  {\hlstd{ \ \ \ }}{\hlkwc{List}}{\hlopt{.}}{\hlstd{map
  }}{\hlopt{(}}{\hlkwa{fun
  }}{\hlopt{(}}{\hlstd{e}}{\hlopt{,}}{\hlstd{w}}{\hlopt{) ->
  }}{\hlstd{e}}{\hlopt{, }}{\hlstd{p}}{\hlopt{*.}}{\hlstd{w}}{\hlopt{)
  }}{\hlstd{a }}{\hlopt{@}}{\hlendline{are not normalized!}}\\
  \tmverbatim{ \ \ \ \ \ }{\hlkwc{List}}{\hlopt{.}}{\hlstd{map
  }}{\hlopt{(}}{\hlkwa{fun
  }}{\hlopt{(}}{\hlstd{e}}{\hlopt{,}}{\hlstd{w}}{\hlopt{) ->
  }}{\hlstd{e}}{\hlopt{, (}}{\hlnum{1}}{\hlopt{.
  -.}}{\hlstd{p}}{\hlopt{)*.}}{\hlstd{w}}{\hlopt{) }}{\hlstd{b}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{pick dist }}{\hlopt{=
  }}\tmverbatim{dist}{\hlendline{}}
  
  \tmverbatim{ \ }{\hlkwa{let }}{\hlstd{uniform elems }}{\hlopt{=
  }}{\hlstd{normalize{\hlendline{}}\\
  \ \ \ }}{\hlopt{(}}{\hlkwc{List}}{\hlopt{.}}{\hlstd{map
  }}{\hlopt{(}}{\hlkwa{fun
  }}{\hlstd{e}}{\hlopt{->}}{\hlstd{e}}{\hlopt{,}}{\hlnum{1}}{\hlopt{.)
  }}{\hlstd{elems}}{\hlopt{)}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{coin }}{\hlopt{=
  [}}{\hlkwa{true}}{\hlopt{, }}{\hlnum{0.5}}{\hlopt{;
  }}{\hlkwa{false}}{\hlopt{, }}{\hlnum{0.5}}{\hlopt{]}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{flip p }}{\hlopt{=
  [}}{\hlkwa{true}}{\hlopt{, }}{\hlstd{p}}{\hlopt{; }}{\hlkwa{false}}{\hlopt{,
  }}{\hlnum{1}}{\hlopt{. -. }}{\hlstd{p}}{\hlopt{]}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{prob p m }}{\hlopt{=
  }}\tmverbatim{normalize m}{\hlendline{Final normalization step.}}\\
  \tmverbatim{ \ \ \ }{\hlopt{\textbar}}{\hlopt{>
  }}{\hlkwc{List}}{\hlopt{.}}{\hlstd{filter }}{\hlopt{(}}{\hlkwa{fun
  }}{\hlopt{(}}{\hlstd{e}}{\hlopt{,}}{\hlstd{{\textunderscore}}}{\hlopt{) ->
  }}{\hlstd{p e}}{\hlopt{)}}{\hlendline{}}\\
  {\hlstd{ \ \ \ {\hlopt{\textbar}}}}{\hlopt{>
  }}{\hlkwc{List}}{\hlopt{.}}{\hlstd{map snd {\hlopt{\textbar}}}}{\hlopt{>
  }}{\hlkwc{List}}{\hlopt{.}}{\hlstd{fold{\textunderscore}left }}{\hlopt{(+.)
  }}{\hlnum{0}}{\hlopt{.}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{distrib m }}{\hlopt{= }}{\hlstd{normalize
  m{\hlendline{}}\\
  \ }}{\hlkwa{let }}{\hlstd{access m }}{\hlopt{= }}{\hlstd{roulette
  m}}{\hlendline{}}\\
  {\hlkwa{end}}{\hlendline{}}
  
  \item We write the rejection sampler in mostly imperative style:
  
  {\hlkwa{module }}{\hlkwd{SamplingMP }}{\hlopt{(}}{\hlkwd{S }}{\hlopt{:
  }}{\hlkwa{sig val }}{\hlstd{samples }}{\hlopt{: }}{\hlkwb{int
  }}{\hlkwa{end}}{\hlopt{)}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlopt{: }}{\hlkwd{COND{\textunderscore}PROBAB }}{\hlopt{=
  }}{\hlkwa{struct}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{exception }}{\hlkwd{Rejected}}{\hlendline{For rejecting
  current sample.}}\\
  {\hlstd{ \ }}{\hlkwa{module }}{\hlkwd{MP }}{\hlopt{=
  }}{\hlkwa{struct}}{\hlendline{Monad operations are exactly as for
  {\hlkwd{SamplingM}}}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{type }}{\hlstd{'a t }}{\hlopt{= }}{\hlkwb{unit
  }}{\hlopt{-> }}{\hlstd{'a{\hlendline{}}\\
  \ \ \ }}{\hlkwa{let }}{\hlstd{bind a b }}{\hlopt{() = }}{\hlstd{b
  }}{\hlopt{(}}{\hlstd{a }}{\hlopt{()) ()}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{return a }}{\hlopt{= }}{\hlkwa{fun
  }}{\hlopt{() -> }}\tmverbatim{a}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{mzero }}{\hlopt{= }}{\hlkwa{fun
  }}{\hlopt{() -> }}{\hlstd{raise }}{\hlkwd{Rejected}}{\hlendline{but now we
  can \tmverbatim{fail}.}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{mplus a b }}{\hlopt{= }}{\hlkwa{fun
  }}{\hlopt{() ->}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ failwith }}{\hlstr{"SamplingMP.mplus not
  implemented"}}{\hlstd{{\hlendline{}}\\
  \ }}{\hlkwa{end}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{include }}{\hlkwd{MP }}{\hlkwa{include
  }}{\hlkwd{MonadPlusOps }}{\hlopt{(}}{\hlkwd{MP}}{\hlopt{)}}{\hlendline{}}
  
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{choose p a b }}{\hlopt{()
  =}}{\hlendline{Inside-monad operations don't change.}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{if }}{\hlkwc{Random}}{\hlopt{.}}{\hlkwb{float
  }}{\hlnum{1}}{\hlopt{. <= }}{\hlstd{p }}{\hlkwa{then }}{\hlstd{a
  }}{\hlopt{() }}{\hlkwa{else }}{\hlstd{b }}{\hlopt{()}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{pick dist }}{\hlopt{= }}{\hlkwa{fun
  }}{\hlopt{() -> }}\tmverbatim{roulette dist}{\hlendline{}}\\
  \tmverbatim{ \ }{\hlkwa{let }}{\hlstd{uniform elems
  }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{n }}{\hlopt{=
  }}{\hlkwc{List}}{\hlopt{.}}{\hlstd{length elems
  }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{fun }}{\hlopt{() ->
  }}{\hlkwc{List}}{\hlopt{.}}{\hlstd{nth elems
  }}{\hlopt{(}}{\hlkwc{Random}}{\hlopt{.}}{\hlkwb{int
  }}{\hlstd{n}}{\hlopt{)}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{coin }}{\hlopt{=
  }}{\hlkwc{Random}}{\hlopt{.}}{\hlkwb{bool}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{flip p }}{\hlopt{= }}{\hlstd{choose p
  }}{\hlopt{(}}{\hlstd{return }}{\hlkwa{true}}{\hlopt{) (}}{\hlstd{return
  }}{\hlkwa{false}}{\hlopt{)}}{\hlendline{}}
  
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{prob p m }}{\hlopt{=}}{\hlendline{Getting
  out of monad: handle rejected samples.}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{count }}{\hlopt{= }}{\hlkwb{ref
  }}{\hlnum{0 }}{\hlkwa{and }}{\hlstd{tot }}{\hlopt{= }}{\hlkwb{ref
  }}{\hlnum{0 }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{while }}{\hlopt{!}}{\hlstd{tot }}{\hlopt{<
  }}{\hlkwc{S}}{\hlopt{.}}{\hlstd{samples }}{\hlkwa{do}}{\hlendline{Count up
  to the required}}\\
  {\hlstd{ \ \ \ \ \ }}{\hlkwa{try}}{\hlendline{number of samples.}}\\
  {\hlstd{ \ \ \ \ \ \ \ }}{\hlkwa{if }}{\hlstd{p }}{\hlopt{(}}{\hlstd{m
  }}{\hlopt{()) }}{\hlkwa{then }}{\hlstd{incr
  count}}{\hlopt{;}}{\hlendline{{\hlstd{m}}{\hlopt{()}} can fail.}}\\
  \tmverbatim{ \ \ \ \ \ \ \ incr tot}{\hlendline{But if we got here it
  hasn't.}}\\
  \tmverbatim{ \ \ \ \ \ }{\hlkwa{with }}{\hlkwd{Rejected }}{\hlopt{->
  ()}}{\hlendline{Rejected, keep sampling.}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{done}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ float{\textunderscore}of{\textunderscore}int
  }}{\hlopt{!}}{\hlstd{count }}{\hlopt{/.
  }}{\hlstd{float{\textunderscore}of{\textunderscore}int
  }}{\hlkwc{S}}{\hlopt{.}}\tmverbatim{samples}{\hlendline{}}
  
  \tmverbatim{ \ }{\hlkwa{let }}{\hlstd{distrib m
  }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{dist }}{\hlopt{= }}{\hlkwb{ref
  }}{\hlopt{[] }}{\hlkwa{and }}{\hlstd{tot }}{\hlopt{= }}{\hlkwb{ref
  }}{\hlnum{0 }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{while }}{\hlopt{!}}{\hlstd{tot }}{\hlopt{<
  }}{\hlkwc{S}}{\hlopt{.}}{\hlstd{samples }}{\hlkwa{do}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ }}{\hlkwa{try}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ \ \ dist }}{\hlopt{:= (}}{\hlstd{m }}{\hlopt{(),
  }}{\hlnum{1}}{\hlopt{.) :: !}}{\hlstd{dist}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ \ \ incr tot{\hlendline{}}\\
  \ \ \ \ \ }}{\hlkwa{with }}{\hlkwd{Rejected }}{\hlopt{->
  ()}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{done}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ normalize }}{\hlopt{(}}{\hlstd{merge
  }}{\hlopt{!}}{\hlstd{dist}}{\hlopt{)}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let rec }}{\hlstd{access m
  }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{try }}{\hlstd{m }}{\hlopt{() }}{\hlkwa{with
  }}{\hlkwd{Rejected }}{\hlopt{-> }}{\hlstd{access m}}{\hlendline{}}\\
  {\hlkwa{end}}{\hlendline{}}
\end{itemize}

\subsection{Burglary example: encoding a Bayes net}

\begin{itemize}
  \item We're faced with a problem with the following dependency structure:
  
  \raisebox{-0.487656612279371\height}{\includegraphics[width=20.4642857142857cm,height=12.1926406926407cm]{functional-lecture08-via-latex-3.pdf}}
  \begin{itemize}
    \item Alarm can be due to either a burglary or an earthquake.
    
    \item I've left on vacations.
    
    \item I've asked neighbors John and Mary to call me if the alarm rings.
    
    \item Mary only calls when she is really sure about the alarm, but John
    has better hearing.
    
    \item Earthquakes are twice as probable as burglaries.
    
    \item The alarm has about 30\% chance of going off during earthquake.
    
    \item I can check on the radio if there was an earthquake, but I might
    miss the news.
  \end{itemize}
  \item {\hlkwa{module }}{\hlkwd{Burglary }}{\hlopt{(}}{\hlkwd{P }}{\hlopt{:
  }}{\hlkwd{COND{\textunderscore}PROBAB}}{\hlopt{) =
  }}{\hlkwa{struct}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{open }}{\hlkwd{P}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{type }}{\hlstd{what{\textunderscore}happened
  }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwd{Safe }}{\hlopt{\textbar }}{\hlkwd{Burgl
  }}{\hlopt{\textbar }}{\hlkwd{Earthq }}{\hlopt{\textbar
  }}{\hlkwd{Burgl{\textunderscore}n{\textunderscore}earthq}}{\hlendline{}}
  
  \tmverbatim{ \ }{\hlkwa{let }}{\hlstd{check
  $\sim$john{\textunderscore}called $\sim$mary{\textunderscore}called
  $\sim$radio }}{\hlopt{= }}{\hlkwa{perform}}{\hlendline{}}\\
  {\hlstd{ \ \ \ earthquake }}{\hlopt{<-- }}{\hlstd{flip
  }}{\hlnum{0.002}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ guard }}{\hlopt{(}}{\hlstd{radio }}{\hlopt{= }}{\hlkwd{None
  }}{\hlstd{{\hlopt{\textbar\textbar}} radio }}{\hlopt{= }}{\hlkwd{Some
  }}{\hlstd{earthquake}}{\hlopt{);}}{\hlendline{}}\\
  {\hlstd{ \ \ \ burglary }}{\hlopt{<-- }}{\hlstd{flip
  }}{\hlnum{0.001}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{alarm{\textunderscore}p
  }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ }}{\hlkwa{match }}{\hlstd{burglary}}{\hlopt{,
  }}{\hlstd{earthquake }}{\hlkwa{with}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwa{false}}{\hlopt{,
  }}{\hlkwa{false }}{\hlopt{-> }}{\hlnum{0.001}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwa{false}}{\hlopt{,
  }}{\hlkwa{true }}{\hlopt{-> }}{\hlnum{0.29}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwa{true}}{\hlopt{,
  }}{\hlkwa{false }}{\hlopt{-> }}{\hlnum{0.94}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwa{true}}{\hlopt{,
  }}{\hlkwa{true }}{\hlopt{-> }}{\hlnum{0.95 }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ \ \ alarm }}{\hlopt{<-- }}{\hlstd{flip
  alarm{\textunderscore}p}}{\hlopt{;}}{\hlendline{}}
  
  {\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{john{\textunderscore}p }}{\hlopt{=
  }}{\hlkwa{if }}{\hlstd{alarm }}{\hlkwa{then }}{\hlnum{0.9 }}{\hlkwa{else
  }}{\hlnum{0.05 }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ \ \ john{\textunderscore}calls }}{\hlopt{<-- }}{\hlstd{flip
  john{\textunderscore}p}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ guard }}{\hlopt{(}}{\hlstd{john{\textunderscore}calls
  }}{\hlopt{=
  }}{\hlstd{john{\textunderscore}called}}{\hlopt{);}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{mary{\textunderscore}p }}{\hlopt{=
  }}{\hlkwa{if }}{\hlstd{alarm }}{\hlkwa{then }}{\hlnum{0.7 }}{\hlkwa{else
  }}{\hlnum{0.01 }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ \ \ mary{\textunderscore}calls }}{\hlopt{<-- }}{\hlstd{flip
  mary{\textunderscore}p}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ \ \ guard }}{\hlopt{(}}{\hlstd{mary{\textunderscore}calls
  }}{\hlopt{=
  }}{\hlstd{mary{\textunderscore}called}}{\hlopt{);}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{match }}{\hlstd{burglary}}{\hlopt{,
  }}{\hlstd{earthquake }}{\hlkwa{with}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlopt{\textbar }}{\hlkwa{false}}{\hlopt{, }}{\hlkwa{false
  }}{\hlopt{-> }}{\hlstd{return }}{\hlkwd{Safe}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlopt{\textbar }}{\hlkwa{true}}{\hlopt{, }}{\hlkwa{false
  }}{\hlopt{-> }}{\hlstd{return }}{\hlkwd{Burgl}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlopt{\textbar }}{\hlkwa{false}}{\hlopt{, }}{\hlkwa{true
  }}{\hlopt{-> }}{\hlstd{return }}{\hlkwd{Earthq}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlopt{\textbar }}{\hlkwa{true}}{\hlopt{, }}{\hlkwa{true
  }}{\hlopt{-> }}{\hlstd{return
  }}{\hlkwd{Burgl{\textunderscore}n{\textunderscore}earthq}}{\hlendline{}}\\
  {\hlkwa{end}}{\hlendline{}}
  
  \item {\hlkwa{module }}{\hlkwd{BurglaryExact }}{\hlopt{= }}{\hlkwd{Burglary
  }}{\hlopt{(}}{\hlkwd{DistribMP}}{\hlopt{)}}{\hlendline{}}\\
  {\hlkwa{module }}{\hlkwd{Sampling2000 }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwd{SamplingMP }}{\hlopt{(}}{\hlkwa{struct let
  }}{\hlstd{samples }}{\hlopt{= }}{\hlnum{2000
  }}{\hlkwa{end}}{\hlopt{)}}{\hlendline{}}\\
  {\hlkwa{module }}{\hlkwd{BurglarySimul }}{\hlopt{= }}{\hlkwd{Burglary
  }}{\hlopt{(}}{\hlkwd{Sampling2000}}{\hlopt{)}}{\hlendline{}}
\end{itemize}
{\newpage}

{\scriptsize{{\hlstd{\# }}{\hlkwa{let }}{\hlstd{t1 }}{\hlopt{=
}}{\hlkwc{DistribMP}}{\hlopt{.}}{\hlstd{distrib{\hlendline{}}\\
\ }}{\hlopt{(}}{\hlkwc{BurglaryExact}}{\hlopt{.}}{\hlstd{check
$\sim$john{\textunderscore}called}}{\hlopt{:}}{\hlkwa{true
}}{\hlstd{$\sim$mary{\textunderscore}called}}{\hlopt{:}}{\hlkwa{false}}{\hlendline{}}\\
{\hlstd{ \ \ \ \
$\sim$radio}}{\hlopt{:}}{\hlkwd{None}}{\hlopt{);;}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwa{val }}{\hlstd{t1 }}{\hlopt{:
(}}{\hlkwc{BurglaryExact}}{\hlopt{.}}{\hlstd{what{\textunderscore}happened
}}{\hlopt{* }}{\hlkwb{float}}{\hlopt{) }}{\hlstd{list
}}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \
}}{\hlopt{[(}}{\hlkwc{BurglaryExact}}{\hlopt{.}}{\hlkwd{Burgl{\textunderscore}n{\textunderscore}earthq}}{\hlopt{,
}}{\hlnum{1.03476433660005444e-05}}{\hlopt{);}}{\hlendline{}}\\
{\hlstd{ \ \
}}{\hlopt{(}}{\hlkwc{BurglaryExact}}{\hlopt{.}}{\hlkwd{Earthq}}{\hlopt{,
}}{\hlnum{0.00452829235738691407}}{\hlopt{);}}{\hlendline{}}\\
{\hlstd{ \ \
}}{\hlopt{(}}{\hlkwc{BurglaryExact}}{\hlopt{.}}{\hlkwd{Burgl}}{\hlopt{,
}}{\hlnum{0.00511951049003530299}}{\hlopt{);}}{\hlendline{}}\\
{\hlstd{ \ \
}}{\hlopt{(}}{\hlkwc{BurglaryExact}}{\hlopt{.}}{\hlkwd{Safe}}{\hlopt{,
}}{\hlnum{0.99034184950921178}}{\hlopt{)]}}{\hlendline{}}\\
{\hlstd{\# }}{\hlkwa{let }}{\hlstd{t2 }}{\hlopt{=
}}{\hlkwc{DistribMP}}{\hlopt{.}}{\hlstd{distrib{\hlendline{}}\\
\ }}{\hlopt{(}}{\hlkwc{BurglaryExact}}{\hlopt{.}}{\hlstd{check
$\sim$john{\textunderscore}called}}{\hlopt{:}}{\hlkwa{true
}}{\hlstd{$\sim$mary{\textunderscore}called}}{\hlopt{:}}{\hlkwa{true}}{\hlendline{}}\\
{\hlstd{ \ \ \ \
$\sim$radio}}{\hlopt{:}}{\hlkwd{None}}{\hlopt{);;}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwa{val }}{\hlstd{t2 }}{\hlopt{:
(}}{\hlkwc{BurglaryExact}}{\hlopt{.}}{\hlstd{what{\textunderscore}happened
}}{\hlopt{* }}{\hlkwb{float}}{\hlopt{) }}{\hlstd{list
}}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \
}}{\hlopt{[(}}{\hlkwc{BurglaryExact}}{\hlopt{.}}{\hlkwd{Burgl{\textunderscore}n{\textunderscore}earthq}}{\hlopt{,
}}{\hlnum{0.00057437256500405794}}{\hlopt{);}}{\hlendline{}}\\
{\hlstd{ \ \
}}{\hlopt{(}}{\hlkwc{BurglaryExact}}{\hlopt{.}}{\hlkwd{Earthq}}{\hlopt{,
}}{\hlnum{0.175492465840075218}}{\hlopt{);}}{\hlendline{}}\\
{\hlstd{ \ \
}}{\hlopt{(}}{\hlkwc{BurglaryExact}}{\hlopt{.}}{\hlkwd{Burgl}}{\hlopt{,
}}{\hlnum{0.283597462799388911}}{\hlopt{);}}{\hlendline{}}\\
{\hlstd{ \ \
}}{\hlopt{(}}{\hlkwc{BurglaryExact}}{\hlopt{.}}{\hlkwd{Safe}}{\hlopt{,
}}{\hlnum{0.540335698795532}}{\hlopt{)]}}{\hlendline{}}\\
{\hlstd{\# }}{\hlkwa{let }}{\hlstd{t3 }}{\hlopt{=
}}{\hlkwc{DistribMP}}{\hlopt{.}}{\hlstd{distrib{\hlendline{}}\\
\ }}{\hlopt{(}}{\hlkwc{BurglaryExact}}{\hlopt{.}}{\hlstd{check
$\sim$john{\textunderscore}called}}{\hlopt{:}}{\hlkwa{true
}}{\hlstd{$\sim$mary{\textunderscore}called}}{\hlopt{:}}{\hlkwa{true}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ $\sim$radio}}{\hlopt{:(}}{\hlkwd{Some
}}{\hlkwa{true}}{\hlopt{));;}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwa{val }}{\hlstd{t3 }}{\hlopt{:
(}}{\hlkwc{BurglaryExact}}{\hlopt{.}}{\hlstd{what{\textunderscore}happened
}}{\hlopt{* }}{\hlkwb{float}}{\hlopt{) }}{\hlstd{list
}}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \
}}{\hlopt{[(}}{\hlkwc{BurglaryExact}}{\hlopt{.}}{\hlkwd{Burgl{\textunderscore}n{\textunderscore}earthq}}{\hlopt{,
}}{\hlnum{0.0032622416021499262}}{\hlopt{);}}{\hlendline{}}\\
{\hlstd{ \ \
}}{\hlopt{(}}{\hlkwc{BurglaryExact}}{\hlopt{.}}{\hlkwd{Earthq}}{\hlopt{,
}}{\hlnum{0.99673775839785006}}{\hlopt{)]}}{\hlendline{}}

{\hlstd{\# }}{\hlkwa{let }}{\hlstd{t4 }}{\hlopt{=
}}{\hlkwc{Sampling2000}}{\hlopt{.}}{\hlstd{distrib{\hlendline{}}\\
\ }}{\hlopt{(}}{\hlkwc{BurglarySimul}}{\hlopt{.}}{\hlstd{check
$\sim$john{\textunderscore}called}}{\hlopt{:}}{\hlkwa{true
}}{\hlstd{$\sim$mary{\textunderscore}called}}{\hlopt{:}}{\hlkwa{false}}{\hlendline{}}\\
{\hlstd{ \ \ \ \
$\sim$radio}}{\hlopt{:}}{\hlkwd{None}}{\hlopt{);;}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwa{val }}{\hlstd{t4 }}{\hlopt{:
(}}{\hlkwc{BurglarySimul}}{\hlopt{.}}{\hlstd{what{\textunderscore}happened
}}{\hlopt{* }}{\hlkwb{float}}{\hlopt{) }}{\hlstd{list
}}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \
}}{\hlopt{[(}}{\hlkwc{BurglarySimul}}{\hlopt{.}}{\hlkwd{Earthq}}{\hlopt{,
}}{\hlnum{0.0035}}{\hlopt{);
(}}{\hlkwc{BurglarySimul}}{\hlopt{.}}{\hlkwd{Burgl}}{\hlopt{,
}}{\hlnum{0.0035}}{\hlopt{);}}{\hlendline{}}\\
{\hlstd{ \ \
}}{\hlopt{(}}{\hlkwc{BurglarySimul}}{\hlopt{.}}{\hlkwd{Safe}}{\hlopt{,
}}{\hlnum{0.993}}{\hlopt{)]}}{\hlendline{}}\\
{\hlstd{\# }}{\hlkwa{let }}{\hlstd{t5 }}{\hlopt{=
}}{\hlkwc{Sampling2000}}{\hlopt{.}}{\hlstd{distrib{\hlendline{}}\\
\ }}{\hlopt{(}}{\hlkwc{BurglarySimul}}{\hlopt{.}}{\hlstd{check
$\sim$john{\textunderscore}called}}{\hlopt{:}}{\hlkwa{true
}}{\hlstd{$\sim$mary{\textunderscore}called}}{\hlopt{:}}{\hlkwa{true}}{\hlendline{}}\\
{\hlstd{ \ \ \ \
$\sim$radio}}{\hlopt{:}}{\hlkwd{None}}{\hlopt{);;}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwa{val }}{\hlstd{t5 }}{\hlopt{:
(}}{\hlkwc{BurglarySimul}}{\hlopt{.}}{\hlstd{what{\textunderscore}happened
}}{\hlopt{* }}{\hlkwb{float}}{\hlopt{) }}{\hlstd{list
}}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \
}}{\hlopt{[(}}{\hlkwc{BurglarySimul}}{\hlopt{.}}{\hlkwd{Burgl{\textunderscore}n{\textunderscore}earthq}}{\hlopt{,
}}{\hlnum{0.0005}}{\hlopt{);
(}}{\hlkwc{BurglarySimul}}{\hlopt{.}}{\hlkwd{Earthq}}{\hlopt{,
}}{\hlnum{0.1715}}{\hlopt{);}}{\hlendline{}}\\
{\hlstd{ \ \
}}{\hlopt{(}}{\hlkwc{BurglarySimul}}{\hlopt{.}}{\hlkwd{Burgl}}{\hlopt{,
}}{\hlnum{0.2875}}{\hlopt{);
(}}{\hlkwc{BurglarySimul}}{\hlopt{.}}{\hlkwd{Safe}}{\hlopt{,
}}{\hlnum{0.5405}}{\hlopt{)]}}{\hlendline{}}\\
{\hlstd{\# }}{\hlkwa{let }}{\hlstd{t6 }}{\hlopt{=
}}{\hlkwc{Sampling2000}}{\hlopt{.}}{\hlstd{distrib{\hlendline{}}\\
\ }}{\hlopt{(}}{\hlkwc{BurglarySimul}}{\hlopt{.}}{\hlstd{check
$\sim$john{\textunderscore}called}}{\hlopt{:}}{\hlkwa{true
}}{\hlstd{$\sim$mary{\textunderscore}called}}{\hlopt{:}}{\hlkwa{true}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ $\sim$radio}}{\hlopt{:(}}{\hlkwd{Some
}}{\hlkwa{true}}{\hlopt{));;}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwa{val }}{\hlstd{t6 }}{\hlopt{:
(}}{\hlkwc{BurglarySimul}}{\hlopt{.}}{\hlstd{what{\textunderscore}happened
}}{\hlopt{* }}{\hlkwb{float}}{\hlopt{) }}{\hlstd{list
}}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \
}}{\hlopt{[(}}{\hlkwc{BurglarySimul}}{\hlopt{.}}{\hlkwd{Burgl{\textunderscore}n{\textunderscore}earthq}}{\hlopt{,
}}{\hlnum{0.0015}}{\hlopt{);
(}}{\hlkwc{BurglarySimul}}{\hlopt{.}}{\hlkwd{Earthq}}{\hlopt{,
}}{\hlnum{0.9985}}{\hlopt{)]}}{\hlendline{}}}}

\section{Lightweight cooperative threads}

\begin{itemize}
  \item \tmverbatim{bind} is inherently sequential: {\hlstd{bind a
  }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{x }}{\hlopt{-> }}{\hlstd{b}}{\hlopt{)}}
  computes \tmverbatim{a}, and resumes computing \tmverbatim{b} only once the
  result \tmverbatim{x} is known.
  
  \item For concurrency we need to ``suppress'' this sequentiality. We
  introduce
  
  {\hlstd{parallel }}{\hlopt{:}}{\hlendline{}}\\
  {\hlstd{'a monad}}{\hlopt{-> }}{\hlstd{'b monad}}{\hlopt{-> (}}{\hlstd{'a
  }}{\hlopt{-> }}{\hlstd{'b }}{\hlopt{-> }}{\hlstd{'c monad}}{\hlopt{) ->
  }}{\hlstd{'c monad}}
  
  where {\hlstd{parallel a b }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{x y
  }}{\hlopt{-> }}{\hlstd{c}}{\hlopt{)}} does not wait for \tmverbatim{a} to be
  computed before it can start computing \tmverbatim{b}.
  
  \item It can be that only accessing the value in the monad triggers the
  computation of the value, as we've seen in some monads.
  \begin{itemize}
    \item The state monad does not start computing until you ``get out of the
    monad'' and pass the initial value.
    
    \item The list monad computes right away -- the \tmverbatim{'a monad}
    value is the computed results.
  \end{itemize}
  In former case, a ``built-in'' \tmverbatim{parallel} is necessary for
  concurrency.
  
  \item If the monad starts computing right away, as in the {\tmem{Lwt}}
  library, \tmverbatim{parallel $e_a$ $e_b$ c} is equivalent to
  
  {\hlkwa{perform}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{a }}{\hlopt{= }}$e_a${\hlkwa{
  in}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{b }}{\hlopt{= }}$e_b${\hlkwa{
  in}}{\hlendline{}}\\
  {\hlstd{ \ x }}{\hlopt{<-- }}{\hlstd{a}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ y }}{\hlopt{<-- }}{\hlstd{b}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{ \ c x y}}{\hlendline{}}
  \begin{itemize}
    \item We will follow this model, with an imperative implementation.
    
    \item In any case, do not call \tmverbatim{run} or \tmverbatim{access}
    from within a monad.
  \end{itemize}
  \item We still need to decide on when concurrency happens.
  \begin{itemize}
    \item Under {\tmstrong{fine-grained}} concurrency, every \tmverbatim{bind}
    is suspended and computation moves to other threads.
    \begin{itemize}
      \item It comes back to complete the \tmverbatim{bind} before running
      threads created since the \tmverbatim{bind} was suspended.
      
      \item We implement this model in our example.
    \end{itemize}
    \item Under {\tmstrong{coarse-grained}} concurrency, computation is only
    suspended when requested.
    \begin{itemize}
      \item Operation \tmverbatim{suspend} is often called \tmverbatim{yield}
      but the meaning is \ more similar to \tmverbatim{Await} than
      \tmverbatim{Yield} from lecture 7.
      
      \item Library operations that need to wait for an event or completion of
      IO (file operations, etc.) should call \tmverbatim{suspend} or its
      equivalent internally.
      
      \item We leave coarse-grained concurrency as exercise 11.
    \end{itemize}
  \end{itemize}
  \item The basic operations of a multithreading monad class.
  
  {\hlkwa{module type }}{\hlkwd{THREADS }}{\hlopt{=
  }}{\hlkwa{sig}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{include }}{\hlkwd{MONAD}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{val }}{\hlstd{parallel }}{\hlopt{:}}{\hlendline{}}\\
  {\hlstd{ \ \ \ 'a t }}{\hlopt{-> }}{\hlstd{'b t }}{\hlopt{-> (}}{\hlstd{'a
  }}{\hlopt{-> }}{\hlstd{'b }}{\hlopt{-> }}{\hlstd{'c t}}{\hlopt{) ->
  }}{\hlstd{'c t}}{\hlendline{}}\\
  {\hlkwa{end}}{\hlendline{}}
  
  \item Although in our implementation \tmverbatim{parallel} will be
  redundant, it is a principled way to make sure subthreads of a thread are
  run concurrently.
  
  \item All within-monad operations.
  
  {\hlkwa{module type }}{\hlkwd{THREAD{\textunderscore}OPS }}{\hlopt{=
  }}{\hlkwa{sig}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{include }}{\hlkwd{MONAD{\textunderscore}OPS
  }}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{include }}{\hlkwd{THREADS }}{\hlkwa{with type
  }}{\hlstd{'a t }}{\hlopt{:= }}{\hlstd{'a monad{\hlendline{}}\\
  \ }}{\hlkwa{val }}{\hlstd{parallel{\textunderscore}map
  }}{\hlopt{:}}{\hlendline{}}\\
  {\hlstd{ \ \ \ 'a list }}{\hlopt{-> (}}{\hlstd{'a }}{\hlopt{-> }}{\hlstd{'b
  monad}}{\hlopt{) -> }}{\hlstd{'b list monad{\hlendline{}}\\
  \ }}{\hlkwa{val
  }}{\hlopt{(>}}{\hlstd{{\hlopt{\textbar\textbar}}}}{\hlopt{=)
  :}}{\hlendline{}}\\
  {\hlstd{ \ \ \ 'a monad }}{\hlopt{-> }}{\hlstd{'b monad }}{\hlopt{->
  (}}{\hlstd{'a }}{\hlopt{-> }}{\hlstd{'b }}{\hlopt{-> }}{\hlstd{'c
  monad}}{\hlopt{) ->}}{\hlendline{}}\\
  {\hlstd{ \ \ \ 'c monad{\hlendline{}}\\
  \ }}{\hlkwa{val }}{\hlopt{(>}}{\hlstd{{\hlopt{\textbar\textbar}}}}{\hlopt{)
  :}}{\hlendline{}}\\
  {\hlstd{ \ \ \ 'a monad }}{\hlopt{-> }}{\hlstd{'b monad }}{\hlopt{->
  (}}{\hlkwb{unit }}{\hlopt{-> }}{\hlstd{'c monad}}{\hlopt{)
  ->}}{\hlendline{}}\\
  {\hlstd{ \ \ \ 'c monad}}{\hlendline{}}\\
  {\hlkwa{end}}{\hlendline{}}
  
  \item Outside-monad operations.
  
  {\hlkwa{module type }}{\hlkwd{THREADSYS }}{\hlopt{=
  }}{\hlkwa{sig}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{include }}{\hlkwd{THREADS}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{val }}{\hlstd{access }}{\hlopt{: }}{\hlstd{'a t
  }}{\hlopt{-> }}{\hlstd{'a{\hlendline{}}\\
  \ }}{\hlkwa{val }}{\hlstd{kill{\textunderscore}threads }}{\hlopt{:
  }}{\hlkwb{unit }}{\hlopt{-> }}{\hlkwb{unit}}{\hlendline{}}\\
  {\hlkwa{end}}{\hlendline{}}
  
  \item Helper functions.
  
  {\hlkwa{module }}{\hlkwd{ThreadOps }}{\hlopt{(}}{\hlkwd{M }}{\hlopt{:
  }}{\hlkwd{THREADS}}{\hlopt{) = }}{\hlkwa{struct}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{open }}{\hlkwd{M}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{include }}{\hlkwd{MonadOps
  }}{\hlopt{(}}{\hlkwd{M}}{\hlopt{)}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{parallel{\textunderscore}map l f
  }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwc{List}}{\hlopt{.}}{\hlstd{fold{\textunderscore}right
  }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{a bs }}{\hlopt{->}}{\hlendline{}}\\
  {\hlstd{ \ \ \ \ \ parallel }}{\hlopt{(}}{\hlstd{f a}}{\hlopt{)
  }}{\hlstd{bs{\hlendline{}}\\
  \ \ \ \ \ \ \ }}{\hlopt{(}}{\hlkwa{fun }}{\hlstd{a bs }}{\hlopt{->
  }}{\hlstd{return }}{\hlopt{(}}{\hlstd{a}}{\hlopt{::}}{\hlstd{bs}}{\hlopt{)))
  }}{\hlstd{l }}{\hlopt{(}}{\hlstd{return }}{\hlopt{[])}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let
  }}{\hlopt{(>}}{\hlstd{{\hlopt{\textbar\textbar}}}}{\hlopt{=) =
  }}{\hlstd{parallel{\hlendline{}}\\
  \ }}{\hlkwa{let }}{\hlopt{(>}}{\hlstd{{\hlopt{\textbar\textbar}}}}{\hlopt{)
  }}{\hlstd{a b c }}{\hlopt{= }}{\hlstd{parallel a b }}{\hlopt{(}}{\hlkwa{fun
  }}{\hlstd{{\textunderscore} {\textunderscore} }}{\hlopt{-> }}{\hlstd{c
  }}{\hlopt{())}}{\hlendline{}}\\
  {\hlkwa{end}}{\hlendline{}}
  
  \item Put an interface around an implementation.
  
  {\hlkwa{module }}{\hlkwd{Threads }}{\hlopt{(}}{\hlkwd{M }}{\hlopt{:
  }}{\hlkwd{THREADSYS}}{\hlopt{) :}}{\hlendline{}}\\
  {\hlkwa{sig}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{include
  }}{\hlkwd{THREAD{\textunderscore}OPS}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{val }}{\hlstd{access }}{\hlopt{: }}{\hlstd{'a monad
  }}{\hlopt{-> }}{\hlstd{'a{\hlendline{}}\\
  \ }}{\hlkwa{val }}{\hlstd{kill{\textunderscore}threads }}{\hlopt{:
  }}{\hlkwb{unit }}{\hlopt{-> }}{\hlkwb{unit}}{\hlendline{}}\\
  {\hlkwa{end }}{\hlopt{= }}{\hlkwa{struct}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{include }}{\hlkwd{M}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{include
  }}{\hlkwd{ThreadOps}}{\hlopt{(}}{\hlkwd{M}}{\hlopt{)}}{\hlendline{}}\\
  {\hlkwa{end}}{\hlendline{}}
  
  \item Our implementation, following the {\tmem{Lwt}} paper.
\end{itemize}
{\hlkwa{module }}{\hlkwd{Cooperative }}{\hlopt{=
}}{\hlkwd{Threads}}{\hlopt{(}}{\hlkwa{struct}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlkwa{type }}{\hlstd{'a state }}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \ }}{\hlopt{\textbar }}{\hlkwd{Return }}{\hlkwa{of
}}\tmverbatim{'a}{\hlendline{The thread has returned.}}\\
\tmverbatim{ \ }{\hlopt{\textbar }}{\hlkwd{Sleep }}{\hlkwa{of
}}{\hlopt{(}}{\hlstd{'a }}{\hlopt{-> }}{\hlkwb{unit}}{\hlopt{)
}}\tmverbatim{list}{\hlendline{When thread returns, wake up waiters.}}\\
\tmverbatim{ \ }{\hlopt{\textbar }}{\hlkwd{Link }}{\hlkwa{of }}\tmverbatim{'a
t}{\hlendline{A link to the actual thread.}}\\
\tmverbatim{ \ }{\hlkwa{and }}{\hlstd{'a t }}{\hlopt{= \{}}{\hlkwa{mutable
}}{\hlstd{state }}{\hlopt{: }}{\hlstd{'a state}}{\hlopt{\}}}{\hlendline{State
of the thread can change}}\\
{\hlendline{-- it can return, or more waiters can be added.}}\tmverbatim{\\
\ }{\hlkwa{let rec }}{\hlstd{find t }}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwa{match }}{\hlstd{t}}{\hlopt{.}}{\hlstd{state
}}{\hlkwa{with}}{\hlendline{Union-find style link chasing.}}\\
{\hlstd{ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Link }}{\hlstd{t }}{\hlopt{->
}}{\hlstd{find t{\hlendline{}}\\
\ \ \ {\hlopt{\textbar}} {\textunderscore} }}{\hlopt{->
}}{\hlstd{t{\hlendline{}}\\
{\hlendline{}}\\
\ }}{\hlkwa{let }}{\hlstd{jobs }}{\hlopt{=
}}{\hlkwc{Queue}}{\hlopt{.}}{\hlstd{create }}{\hlopt{()}}{\hlendline{Work
queue -- will store}}\\
{\hlendline{{\hlkwb{unit }}{\hlopt{-> }}{\hlkwb{unit}} procedures.}}\\
{\hlkwa{ \ let }}{\hlstd{wakeup m a }}{\hlopt{=}}{\hlendline{Thread
\tmverbatim{m} has actually finished --}}\\
{\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{m }}{\hlopt{= }}{\hlstd{find m
}}{\hlkwa{in}}{\hlendline{updating its state.}}\\
{\hlstd{ \ \ \ }}{\hlkwa{match }}{\hlstd{m}}{\hlopt{.}}{\hlstd{state
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Return }}{\hlstd{{\textunderscore}
}}{\hlopt{-> }}{\hlkwa{assert false}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Sleep }}{\hlstd{waiters
}}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ m}}{\hlopt{.}}{\hlstd{state }}{\hlopt{<- }}{\hlkwd{Return
}}{\hlstd{a}}{\hlopt{;}}{\hlendline{Set the state, and only then}}\\
{\hlstd{ \ \ \ \ \ }}{\hlkwc{List}}{\hlopt{.}}{\hlstd{iter
}}{\hlopt{((}}{\hlstd{{\hlopt{\textbar}}}}{\hlopt{>) }}{\hlstd{a}}{\hlopt{)
}}\tmverbatim{waiters}{\hlendline{wake up the waiters.}}\\
\tmverbatim{ \ \ }{\hlopt{\textbar }}{\hlkwd{Link }}{\hlstd{{\textunderscore}
}}{\hlopt{-> }}{\hlkwa{assert false}}{\hlendline{}}\\
{\hlstd{{\hlendline{}}\\
\ }}{\hlkwa{let }}{\hlstd{return a }}{\hlopt{= \{}}{\hlstd{state }}{\hlopt{=
}}{\hlkwd{Return }}{\hlstd{a}}{\hlopt{\}}}{\hlendline{}}\\
{\hlendline{}}\\
\tmverbatim{ \ }{\hlkwa{let }}{\hlstd{connect t t'
}}{\hlopt{=}}{\hlendline{\tmverbatim{t} was a placeholder for
\tmverbatim{t'}.}}\\
{\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{t' }}{\hlopt{= }}{\hlstd{find t'
}}{\hlkwa{in}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwa{match }}{\hlstd{t'}}{\hlopt{.}}{\hlstd{state
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Sleep }}{\hlstd{waiters'
}}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlkwa{let }}{\hlstd{t }}{\hlopt{= }}{\hlstd{find t
}}{\hlkwa{in}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlopt{(}}{\hlkwa{match
}}{\hlstd{t}}{\hlopt{.}}{\hlstd{state }}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Sleep }}{\hlstd{waiters
}}{\hlopt{->}}{\hlendline{If both sleep, collect their waiters}}\\
{\hlstd{ \ \ \ \ \ \ \ t}}{\hlopt{.}}{\hlstd{state }}{\hlopt{<-
}}{\hlkwd{Sleep }}{\hlopt{(}}{\hlstd{waiters' @
waiters}}{\hlopt{);}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ t'}}{\hlopt{.}}{\hlstd{state }}{\hlopt{<-
}}{\hlkwd{Link }}\tmverbatim{t}{\hlendline{and link one to the other.}}\\
\tmverbatim{ \ \ \ \ \ }{\hlopt{\textbar}} {\textunderscore} {\hlopt{->
}}{\hlkwa{assert false}}{\hlopt{)}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Return }}{\hlstd{x }}{\hlopt{->
}}\tmverbatim{wakeup t x}{\hlendline{If \tmverbatim{t'} returned, wake up the
placeholder.}}\tmverbatim{\\
\ \ \ }{\hlopt{\textbar }}{\hlkwd{Link }}{\hlstd{{\textunderscore}
}}{\hlopt{-> }}{\hlkwa{assert false}}{\hlendline{}}\\
{\hlendline{}}\\
\tmverbatim{ \ }{\hlkwa{let rec }}{\hlstd{bind a b
}}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{a }}{\hlopt{= }}{\hlstd{find a
}}{\hlkwa{in}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{m }}{\hlopt{= \{}}{\hlstd{state
}}{\hlopt{= }}{\hlkwd{Sleep }}{\hlopt{[]\} }}{\hlkwa{in}}{\hlendline{The
resulting monad.}}\\
{\hlstd{ \ \ \ }}{\hlopt{(}}{\hlkwa{match
}}{\hlstd{a}}{\hlopt{.}}{\hlstd{state }}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Return }}{\hlstd{x
}}{\hlopt{->}}{\hlendline{If \tmverbatim{a} returned, we suspend further
work.}}\\
{\hlstd{ \ \ \ \ \ }}{\hlkwa{let }}{\hlstd{job }}{\hlopt{() =
}}{\hlstd{connect m }}{\hlopt{(}}{\hlstd{b x}}{\hlopt{)
}}{\hlkwa{in}}{\hlendline{(In exercise 11, this should}}\\
{\hlstd{ \ \ \ \ \ }}{\hlkwc{Queue}}{\hlopt{.}}\tmverbatim{push job
jobs}{\hlendline{only happen after \tmverbatim{suspend}.)}}\\
\tmverbatim{ \ \ \ }{\hlopt{\textbar }}{\hlkwd{Sleep }}{\hlstd{waiters
}}{\hlopt{->}}{\hlendline{If \tmverbatim{a} sleeps, we wait for it to
return.}}\\
{\hlstd{ \ \ \ \ \ }}{\hlkwa{let }}{\hlstd{job x }}{\hlopt{= }}{\hlstd{connect
m }}{\hlopt{(}}{\hlstd{b x}}{\hlopt{) }}{\hlkwa{in}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ a}}{\hlopt{.}}{\hlstd{state }}{\hlopt{<- }}{\hlkwd{Sleep
}}{\hlopt{(}}{\hlstd{job}}{\hlopt{::}}{\hlstd{waiters}}{\hlopt{)}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Link }}{\hlstd{{\textunderscore}
}}{\hlopt{-> }}{\hlkwa{assert false}}{\hlopt{);}}{\hlendline{}}\\
{\hlstd{ \ \ \ m{\hlendline{}}\\
{\hlendline{}}\\
\ }}{\hlkwa{let }}{\hlstd{parallel a b c }}{\hlopt{=
}}{\hlkwa{perform}}{\hlendline{Since in our implementation}}\\
{\hlstd{ \ \ \ x }}{\hlopt{<-- }}{\hlstd{a}}{\hlopt{;}}{\hlendline{the threads
run as soon as they are created,}}\\
{\hlstd{ \ \ \ y }}{\hlopt{<--
}}{\hlstd{b}}{\hlopt{;}}{\hlendline{\tmverbatim{parallel} is redundant.}}\\
\tmverbatim{ \ \ \ c x y}{\hlendline{}}\\
{\hlendline{}}\\
\tmverbatim{ \ }{\hlkwa{let rec }}{\hlstd{access m
}}{\hlopt{=}}{\hlendline{Accessing not only gets the result of
\tmverbatim{m},}}\\
{\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{m }}{\hlopt{= }}{\hlstd{find m
}}{\hlkwa{in}}{\hlendline{but spins the thread loop till \tmverbatim{m}
terminates.}}\\
{\hlstd{ \ \ \ }}{\hlkwa{match }}{\hlstd{m}}{\hlopt{.}}{\hlstd{state
}}{\hlkwa{with}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Return }}{\hlstd{x }}{\hlopt{->
}}\tmverbatim{x}{\hlendline{No further work.}}\\
\tmverbatim{ \ \ \ }{\hlopt{\textbar }}{\hlkwd{Sleep
}}{\hlstd{{\textunderscore} }}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ }}{\hlopt{(}}{\hlkwa{try
}}{\hlkwc{Queue}}{\hlopt{.}}{\hlstd{pop jobs }}{\hlopt{()}}{\hlendline{Perform
suspended work.}}\\
{\hlstd{ \ \ \ \ \ \ }}{\hlkwa{with }}{\hlkwc{Queue}}{\hlopt{.}}{\hlkwd{Empty
}}{\hlopt{->}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ \ \ \ failwith }}{\hlstr{"access: result not
available"}}{\hlopt{);}}{\hlendline{}}\\
{\hlstd{ \ \ \ \ \ access m{\hlendline{}}\\
\ \ \ }}{\hlopt{\textbar }}{\hlkwd{Link }}{\hlstd{{\textunderscore}
}}{\hlopt{-> }}{\hlkwa{assert false}}{\hlendline{}}\\
{\hlstd{{\hlendline{}}\\
\ }}{\hlkwa{let }}{\hlstd{kill{\textunderscore}threads }}{\hlopt{() =
}}{\hlkwc{Queue}}{\hlopt{.}}{\hlstd{clear jobs}}{\hlendline{Remove pending
work.}}\\
{\hlkwa{end}}{\hlopt{)}}{\hlendline{}}
\begin{itemize}
  \item {\hlkwa{module }}{\hlkwd{TTest }}{\hlopt{(}}{\hlkwd{T }}{\hlopt{:
  }}{\hlkwd{THREAD{\textunderscore}OPS}}{\hlopt{) =
  }}{\hlkwa{struct}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{open }}{\hlkwd{T}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let rec }}{\hlstd{loop s n }}{\hlopt{=
  }}{\hlkwa{perform}}{\hlendline{}}\\
  {\hlstd{ \ \ \ return }}{\hlopt{(}}{\hlkwc{Printf}}{\hlopt{.}}{\hlstd{printf
  }}{\hlstr{"-- \%s(\%d)\textbackslash}}{\hlesc{n}}{\hlstr{\%!"}}{\hlstd{ s
  n}}{\hlopt{);}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{if }}{\hlstd{n }}{\hlopt{> }}{\hlnum{0
  }}{\hlkwa{then }}{\hlstd{loop s
  }}{\hlopt{(}}{\hlstd{n}}{\hlopt{-}}{\hlnum{1}}{\hlopt{)}}{\hlendline{We
  cannot use \tmverbatim{whenM} because}}\\
  {\hlstd{ \ \ \ }}{\hlkwa{else }}{\hlstd{return }}{\hlopt{()}}{\hlendline{the
  thread would be created regardless of condition.}}\\
  {\hlkwa{end}}{\hlendline{}}\\
  {\hlkwa{module }}{\hlkwd{TT }}{\hlopt{= }}{\hlkwd{TTest
  }}{\hlopt{(}}{\hlkwd{Cooperative}}{\hlopt{)}}{\hlendline{}}
  
  \item {\hlkwa{let }}{\hlstd{test }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \
  }}{\hlkwc{Cooperative}}{\hlopt{.}}{\hlstd{kill{\textunderscore}threads
  }}{\hlopt{();}}{\hlendline{Clean-up after previous tests.}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{thread1 }}{\hlopt{=
  }}{\hlkwc{TT}}{\hlopt{.}}{\hlstd{loop }}{\hlstr{"A"}}{\hlstd{ }}{\hlnum{5
  }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{thread2 }}{\hlopt{=
  }}{\hlkwc{TT}}{\hlopt{.}}{\hlstd{loop }}{\hlstr{"B"}}{\hlstd{ }}{\hlnum{4
  }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwc{Cooperative}}{\hlopt{.}}{\hlstd{access
  thread1}}{\hlopt{;}}{\hlendline{We ensure threads finish computing}}\\
  {\hlstd{ \ }}{\hlkwc{Cooperative}}{\hlopt{.}}{\hlstd{access
  thread2}}{\hlendline{before we proceed.}}
\end{itemize}
{\newpage}

{\small{{\hlstd{\# }}{\hlkwa{let }}{\hlstd{test }}{\hlopt{=}}{\hlendline{}}\\
{\hlstd{ \ \ \
}}{\hlkwc{Cooperative}}{\hlopt{.}}{\hlstd{kill{\textunderscore}threads
}}{\hlopt{();}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{thread1 }}{\hlopt{=
}}{\hlkwc{TT}}{\hlopt{.}}{\hlstd{loop }}{\hlstr{"A"}}{\hlstd{ }}{\hlnum{5
}}{\hlkwa{in}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwa{let }}{\hlstd{thread2 }}{\hlopt{=
}}{\hlkwc{TT}}{\hlopt{.}}{\hlstd{loop }}{\hlstr{"B"}}{\hlstd{ }}{\hlnum{4
}}{\hlkwa{in}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwc{Cooperative}}{\hlopt{.}}{\hlstd{access
thread1}}{\hlopt{;}}{\hlendline{}}\\
{\hlstd{ \ \ \ }}{\hlkwc{Cooperative}}{\hlopt{.}}{\hlstd{access
thread2}}{\hlopt{;;}}{\hlendline{}}\\
{\hlopt{-- }}{\hlkwd{A}}{\hlopt{(}}{\hlnum{5}}{\hlopt{)}}{\hlendline{}}\\
{\hlopt{-- }}{\hlkwd{B}}{\hlopt{(}}{\hlnum{4}}{\hlopt{)}}{\hlendline{}}\\
{\hlopt{-- }}{\hlkwd{A}}{\hlopt{(}}{\hlnum{4}}{\hlopt{)}}{\hlendline{}}\\
{\hlopt{-- }}{\hlkwd{B}}{\hlopt{(}}{\hlnum{3}}{\hlopt{)}}{\hlendline{}}\\
{\hlopt{-- }}{\hlkwd{A}}{\hlopt{(}}{\hlnum{3}}{\hlopt{)}}{\hlendline{}}\\
{\hlopt{-- }}{\hlkwd{B}}{\hlopt{(}}{\hlnum{2}}{\hlopt{)}}{\hlendline{}}\\
{\hlopt{-- }}{\hlkwd{A}}{\hlopt{(}}{\hlnum{2}}{\hlopt{)}}{\hlendline{}}\\
{\hlopt{-- }}{\hlkwd{B}}{\hlopt{(}}{\hlnum{1}}{\hlopt{)}}{\hlendline{}}\\
{\hlopt{-- }}{\hlkwd{A}}{\hlopt{(}}{\hlnum{1}}{\hlopt{)}}{\hlendline{}}\\
{\hlopt{-- }}{\hlkwd{B}}{\hlopt{(}}{\hlnum{0}}{\hlopt{)}}{\hlendline{}}\\
{\hlopt{-- }}{\hlkwd{A}}{\hlopt{(}}{\hlnum{0}}{\hlopt{)}}{\hlendline{}}\\
{\hlkwa{val }}{\hlstd{test }}{\hlopt{: }}{\hlkwb{unit }}{\hlopt{=
()}}{\hlendline{}}\\
}}

\end{document}
