\documentclass{article}
\usepackage[english]{babel}
\usepackage{geometry,amsmath,alltt,theorem}
\geometry{letterpaper}

%%%%%%%%%% Start TeXmacs macros
\catcode`\>=\active \def>{
\fontencoding{T1}\selectfont\symbol{62}\fontencoding{\encodingdefault}}
\newcommand{\tmem}[1]{{\em #1\/}}
\newcommand{\tmverbatim}[1]{\text{{\ttfamily{#1}}}}
\newenvironment{tmcode}[1][]{\begin{alltt} }{\end{alltt}}
{\theorembodyfont{\rmfamily\small}\newtheorem{exercise}{Exercise}}
%%%%%%%%%% End TeXmacs macros

\begin{document}

{\class{Functional Programming}}{\titledate{February 5th 2013}}

{\title{Exam set 3}}

\begin{exercise}
  (Blue.) What is the type of the subexpression \tmverbatim{f y} as part of
  the expression below assuming that the whole expression has the type given?
  
  {\hlopt{(}}{\hlkwa{fun }}{\hlstd{double g x }}{\hlopt{-> }}{\hlstd{double
  }}{\hlopt{(}}{\hlstd{g x}}{\hlopt{)) (}}{\hlstd{}}{\hlkwa{fun}}{\hlstd{ f y
  }}{\hlopt{-> }}{\hlstd{f }}{\hlopt{(}}\begin{tabular}{|l|}
    \hline
    {\hlstd{f y}}\\
    \hline
  \end{tabular}{\hlopt{))}}
  
  {\hlopt{ : (}}{\hlstd{'a }}{\hlopt{-> }}{\hlstd{'b }}{\hlopt{->
  }}{\hlstd{'b}}{\hlopt{) -> }}{\hlstd{'a }}{\hlopt{-> }}{\hlstd{'b
  }}{\hlopt{-> }}{\hlstd{'b}}
\end{exercise}

\begin{exercise}
  (Blue.) Write an example function with type:
  
  \tmverbatim{(int -> int -> bool option) -> bool list}
  
  Tell ``in your words'' what it does. 
\end{exercise}

\begin{exercise}
  (Green.) Find the k'th element of a list.
\end{exercise}

\begin{exercise}
  (Green.) Insert an element at a given position into a list.
\end{exercise}

\begin{exercise}
  (Yellow.) Group the elements of a set into disjoint subsets. Represent sets
  as lists, preserve the order of elements. The required sizes of subsets are
  given as a list of numbers.
\end{exercise}

\begin{exercise}
  (Yellow.) A complete binary tree with height $H$ is defined as follows: The
  levels $1, 2, 3, \ldots, H - 1$ contain the maximum number of nodes (i.e
  $2^{i - 1}$ at the level $i$, note that we start counting the levels from
  $1$ at the root). In level $H$, which may contain less than the maximum
  possible number of nodes, all the nodes are "left-adjusted". This means that
  in a levelorder tree traversal all internal nodes come first, the leaves
  come second, and empty successors (the nil's which are not really nodes!)
  come last.
  
  We can assign an address number to each node in a complete binary tree by
  enumerating the nodes in levelorder, starting at the root with number 1. In
  doing so, we realize that for every node X with address A the following
  property holds: The address of X's left and right successors are 2*A and
  2*A+1, respectively, supposed the successors do exist. This fact can be used
  to elegantly construct a complete binary tree structure. Write a function
  \tmverbatim{is\_complete\_binary\_tree} with the following specification:
  \tmverbatim{is\_complete\_binary\_tree n t} returns true iff \tmverbatim{t}
  is a complete binary tree with \tmverbatim{n} nodes.
\end{exercise}

\begin{exercise}
  (White.) Write two sorting algorithms, working on lists: merge sort and
  quicksort.
  \begin{enumerate}
    \item Merge sort splits the list roughly in half, sorts the parts, and
    merges the sorted parts into the sorted result.
    
    \item Quicksort splits the list into elements smaller/greater than the
    first element, sorts the parts, and puts them together.
  \end{enumerate}
\end{exercise}

\begin{exercise}
  (White.) Express in terms of \tmverbatim{fold\_left} or
  \tmverbatim{fold\_right}, i.e. with all recursion contained in the call to
  one of these functions, run-length encoding of a list (exercise 10 from
  {\tmem{99 Problems}}).
  \begin{itemize}
    \item \tmverbatim{encode [`a;`a;`a;`a;`b;`c;`c;`a;`a;`d] = [4,`a; 1,`b;
    2,`c; 2,`a; 1,`d]}
  \end{itemize}
\end{exercise}

\begin{exercise}
  (Orange.) Implement Priority Queue module that is an abstract data type for
  polymorphic queues parameterized by comparison function: the empty queue
  creation has signature
  
  \ \tmverbatim{val make\_empty : leq:('a -> 'a -> bool) -> 'a prio\_queue}
  
  Provide only functions: \tmverbatim{make\_empty}, \tmverbatim{add},
  \tmverbatim{min}, \tmverbatim{delete\_min}. Is this data structure "safe"?
  
  Implement the heap as a {\tmem{heap-ordered tree}}, i.e. in which the
  element at each node is no larger than the elements at its children.
  Unbalanced binary trees are OK.
\end{exercise}

\begin{exercise}
  (Orange.) Write a function that transposes a rectangular matrix represented
  as a list of lists.
\end{exercise}

\begin{exercise}
  (Purple.) Find the bijective functions between the types corresponding to $a
  (a^b + c)$ and $a^{b + 1} + ac$ (in OCaml).
\end{exercise}

\begin{exercise}
  (Purple.) Show the monad-plus laws for \tmverbatim{OptionM} monad.
\end{exercise}

\begin{exercise}
  (Red.) As a preparation for drawing the tree, a layout algorithm is required
  to determine the position of each node in a rectangular grid. Several layout
  methods are conceivable, one of them is shown in the illustration below.
  
  Layout\_bin\_tree-p64.png
  
  In this layout strategy, the position of a node v is obtained by the
  following two rules:
  \begin{itemize}
    \item x(v) is equal to the position of the node v in the inorder sequence;
    
    \item y(v) is equal to the depth of the node v in the tree.
  \end{itemize}
  In order to store the position of the nodes, we redefine the OCaml type
  representing a node (and its successors) as follows:
  \begin{tmcode}
  type 'a pos_binary_tree =
    | E (* represents the empty tree *)
    | N of 'a * int * int * 'a pos_binary_tree * 'a pos_binary_tree
  \end{tmcode}
  \tmverbatim{N(w,x,y,l,r)} represents a (non-empty) binary tree with root w
  "positioned" at \tmverbatim{(x,y)}, and subtrees \tmverbatim{l} and
  \tmverbatim{r}. Write a function \tmverbatim{layout\_binary\_tree} with the
  following specification: \tmverbatim{layout\_binary\_tree t} returns the
  "positioned" binary tree obtained from the binary tree \tmverbatim{t}.
  
  An alternative layout method is depicted in the illustration:
  
  Layout\_bin\_tree-p65.png
  
  Find out the rules and write the corresponding function.
  
  Hint: On a given level, the horizontal distance between neighboring nodes is
  constant.
\end{exercise}

\begin{exercise}
  (Crimson.) Nonograms. Each row and column of a rectangular bitmap is
  annotated with the respective lengths of its distinct strings of occupied
  cells. The person who solves the puzzle must complete the bitmap given only
  these lengths.
  \begin{tmcode}
            Problem statement:          Solution:

          |_|_|_|_|_|_|_|_| 3         |_|X|X|X|_|_|_|_| 3
          |_|_|_|_|_|_|_|_| 2 1       |X|X|_|X|_|_|_|_| 2 1
          |_|_|_|_|_|_|_|_| 3 2       |_|X|X|X|_|_|X|X| 3 2
          |_|_|_|_|_|_|_|_| 2 2       |_|_|X|X|_|_|X|X| 2 2
          |_|_|_|_|_|_|_|_| 6         |_|_|X|X|X|X|X|X| 6
          |_|_|_|_|_|_|_|_| 1 5       |X|_|X|X|X|X|X|_| 1 5
          |_|_|_|_|_|_|_|_| 6         |X|X|X|X|X|X|_|_| 6
          |_|_|_|_|_|_|_|_| 1         |_|_|_|_|X|_|_|_| 1
          |_|_|_|_|_|_|_|_| 2         |_|_|_|X|X|_|_|_| 2
           1 3 1 7 5 3 4 3             1 3 1 7 5 3 4 3
           2 1 5 1                     2 1 5 1
  \end{tmcode}
  For the example above, the problem can be stated as the two lists
  \tmverbatim{[[3];[2;1];[3;2];[2;2];[6];[1;5];[6];[1];[2]]} and
  \tmverbatim{[[1;2];[3;1];[1;5];[7;1];[5];[3];[4];[3]]} which give the
  "solid" lengths of the rows and columns, top-to-bottom and left-to-right,
  respectively. Published puzzles are larger than this example, e.g. 25*20,
  and apparently always have unique solutions.
\end{exercise}

\begin{exercise}
  (Black.) Leftist heaps are heap-ordered binary trees that satisfy the
  {\tmem{leftist property}}: the rank of any left child is at least as large
  as the rank of its right sibling. The rank of a node is defined to be the
  length of its {\tmem{right spine}}, i.e. the rightmost path from the node in
  question to an empty node. Implement $O (\log n)$ worst case time complexity
  Priority Queues based on leftist heaps. Each node of the tree should contain
  its rank.
  
  Note that the elements along any path through a heap-ordered tree are stored
  in sorted order. The key insight behind leftist heaps is that two heaps can
  be merged by merging their right spines as you would merge two sorted lists,
  and then swapping the children of nodes along this path as necessary to
  restore the leftist property.
\end{exercise}

\

\end{document}
