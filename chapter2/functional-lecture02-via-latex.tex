\documentclass{article}
\usepackage[english]{babel}
\usepackage{geometry,amsmath,graphicx,alltt}
\geometry{landscape, letterpaper}

%%%%%%%%%% Start TeXmacs macros
\newcommand{\tmem}[1]{{\em #1\/}}
\newcommand{\tmemail}[1]{\\ \textit{Email:} \texttt{#1}}
\newcommand{\tmhomepage}[1]{\\ \textit{Web:} \texttt{#1}}
\newcommand{\tmop}[1]{\ensuremath{\operatorname{#1}}}
\newcommand{\tmstrong}[1]{\textbf{#1}}
\newcommand{\tmsubtitle}[1]{\thanks{\textit{Subtitle:} #1}}
\newcommand{\tmverbatim}[1]{\text{{\ttfamily{#1}}}}
\newenvironment{tmcode}[1][]{\begin{alltt} }{\end{alltt}}
%%%%%%%%%% End TeXmacs macros

\begin{document}

\title{Functional Programming}

\author{
  {\L}ukasz Stafiniak
  \tmemail{lukstafi@gmail.com, lukstafi@ii.uni.wroc.pl}
  \tmhomepage{www.ii.uni.wroc.pl/\~{}lukstafi}
}

\maketitle

\title{
  Lecture 2: Algebra
  \tmsubtitle{Algebraic Data Types and some curious analogies}
}

\maketitle

{\newpage}

\section{A Glimpse at Type Inference}

For a refresher, let's try to use the rules we introduced last time on some
simple examples. Starting with \tmverbatim{fun x -> x}. $[?]$ will mean
``dunno yet''.
\begin{eqnarray*}
  & \frac{[?]}{\text{\tmverbatim{fun x -> x}} : [?]} & \text{use }
  \rightarrow \text{ introduction:}\\
  & \frac{\frac{}{\text{\tmverbatim{x}} : a}
  \scriptsize{x}}{\text{\tmverbatim{fun x -> x}} : [?] \rightarrow [?]} &
  \frac{}{\text{\tmverbatim{x}} : a} \scriptsize{x} \text{ matches with }
  \hspace{-0.00839564475928112cm}\raisebox{-0.764310582139098\height}{\includegraphics[width=1.02997507542962cm,height=2.43034238488784cm]{functional-lecture02-via-latex-1.pdf}}\hspace{-0.0236783418601602cm}
  \scriptsize{x} \text{ since } e = \text{\tmverbatim{x}}\\
  & \frac{\frac{}{\text{\tmverbatim{x}} : a}
  \scriptsize{x}}{\text{\tmverbatim{fun x -> x}} : a \rightarrow a} &
  \text{since } b = a \text{ because } x : a \text{ matched with } e : b
\end{eqnarray*}
Because $a$ is arbitrary, OCaml puts a {\tmem{type variable}} \tmverbatim{'a}
for it:
\begin{tmcode}
\# fun x -> x;;
- : 'a -> 'a = <fun>
\end{tmcode}
{\newpage}

Let's try \tmverbatim{fun x -> x+1}, which is the same as \tmverbatim{fun x ->
((+) x) 1}\\
(try it with OCaml/F\#!). $[? \alpha]$ will mean ``dunno yet, but the same as
in other places with $[? \alpha]$''.
\begin{eqnarray*}
  & \frac{[?]}{\text{\tmverbatim{fun x -> ((+) x) 1}} : [?]} & \text{use }
  \rightarrow \text{ introduction:}\\
  & \frac{\frac{[?]}{\text{\tmverbatim{((+) x) 1}} : [?
  \alpha]}}{\text{\tmverbatim{fun x -> ((+) x) 1}} : [?] \rightarrow [?
  \alpha]} & \text{use } \rightarrow \text{ elimination:}\\
  & \frac{\frac{\begin{array}{ll}
    \frac{[?]}{\text{\tmverbatim{(+) x}} : [? \beta] \rightarrow [? \alpha]} &
    \frac{[?]}{\text{\tmverbatim{1}} : [? \beta]}
  \end{array}}{\text{\tmverbatim{((+) x) 1}} : [?
  \alpha]}}{\text{\tmverbatim{fun x -> ((+) x) 1}} : [?] \rightarrow [?
  \alpha]} & \text{we know that \tmverbatim{1}} : \text{\tmverbatim{int}}\\
  & \frac{\frac{\begin{array}{ll}
    \frac{[?]}{\text{\tmverbatim{(+) x}} : \text{\tmverbatim{int}} \rightarrow
    [? \alpha]} & \frac{}{\text{\tmverbatim{1}} : \text{\tmverbatim{int}}}
    \scriptsize{\text{(constant)}}
  \end{array}}{\text{\tmverbatim{((+) x) 1}} : [?
  \alpha]}}{\text{\tmverbatim{fun x -> ((+) x) 1}} : [?] \rightarrow [?
  \alpha]} & \text{application again:}\\
  & \frac{\frac{\begin{array}{ll}
    \frac{\begin{array}{ll}
      \frac{[?]}{\text{\tmverbatim{(+)}} : [? \gamma] \rightarrow
      \text{\tmverbatim{int}} \rightarrow [? \alpha]} &
      \frac{[?]}{\text{\tmverbatim{x}} : [? \gamma]}
    \end{array}}{\text{\tmverbatim{(+) x}} : \text{\tmverbatim{int}}
    \rightarrow [? \alpha]} & \frac{}{\text{\tmverbatim{1}} :
    \text{\tmverbatim{int}}} \scriptsize{\text{(constant)}}
  \end{array}}{\text{\tmverbatim{((+) x) 1}} : [?
  \alpha]}}{\text{\tmverbatim{fun x -> ((+) x) 1}} : [?] \rightarrow [?
  \alpha]} & \text{it's our \tmverbatim{x}!}\\
  & \frac{\frac{\begin{array}{ll}
    \frac{\begin{array}{ll}
      \frac{[?]}{\text{\tmverbatim{(+)}} : [? \gamma] \rightarrow
      \text{\tmverbatim{int}} \rightarrow [? \alpha]} &
      \frac{}{\text{\tmverbatim{x}} : [? \gamma]}
      \scriptsize{\text{\tmverbatim{x}}}
    \end{array}}{\text{\tmverbatim{(+) x}} : \text{\tmverbatim{int}}
    \rightarrow [? \alpha]} & \frac{}{\text{\tmverbatim{1}} :
    \text{\tmverbatim{int}}} \scriptsize{\text{(constant)}}
  \end{array}}{\text{\tmverbatim{((+) x) 1}} : [?
  \alpha]}}{\text{\tmverbatim{fun x -> ((+) x) 1}} : [? \gamma] \rightarrow [?
  \alpha]} & \text{but \tmverbatim{(+)}} : \text{\tmverbatim{int}} \rightarrow
  \text{\tmverbatim{int}} \rightarrow \text{\tmverbatim{int}}\\
  & \frac{\frac{\begin{array}{ll}
    \frac{\begin{array}{ll}
      \frac{}{\text{\tmverbatim{(+)}} : \text{\tmverbatim{int}} \rightarrow
      \text{\tmverbatim{int}} \rightarrow \text{\tmverbatim{int}}}
      \scriptsize{\text{(constant)}} & \frac{}{\text{\tmverbatim{x}} :
      \text{\tmverbatim{int}}} \scriptsize{\text{\tmverbatim{x}}}
    \end{array}}{\text{\tmverbatim{(+) x}} : \text{\tmverbatim{int}}
    \rightarrow \text{\tmverbatim{int}}} & \frac{}{\text{\tmverbatim{1}} :
    \text{\tmverbatim{int}}} \scriptsize{\text{(constant)}}
  \end{array}}{\text{\tmverbatim{((+) x) 1}} :
  \text{\tmverbatim{int}}}}{\text{\tmverbatim{fun x -> ((+) x) 1}} :
  \text{\tmverbatim{int}} \rightarrow \text{\tmverbatim{int}}} & 
\end{eqnarray*}
{\newpage}

\subsection{Curried form}

When there are several arrows ``on the same depth'' in a function type, it
means that the function returns a function: e.g. $\text{\tmverbatim{(+)}} :
\text{\tmverbatim{int}} \rightarrow \text{\tmverbatim{int}} \rightarrow
\text{\tmverbatim{int}}$ is just a shorthand for $\text{\tmverbatim{(+)}} :
\text{\tmverbatim{int}} \rightarrow \left( \text{\tmverbatim{int}} \rightarrow
\text{\tmverbatim{int}} \right)$. It is very different from
\[ \text{\tmverbatim{fun f -> (f 1) + 1}} : \left( \text{\tmverbatim{int}}
   \rightarrow \text{\tmverbatim{int}} \right) \rightarrow
   \text{\tmverbatim{int}} \]
For addition, instead of \tmverbatim{(fun x -> x+1)} we can write
\tmverbatim{((+) 1)}. What expanded form does \tmverbatim{((+) 1)} correspond
to exactly (computationally)?

We will get used to functions returning functions when learning about the
{\tmem{lambda calculus}}.

\section{Algebraic Data Types}

\begin{itemize}
  \item Last time we learned about the \tmverbatim{unit} type, variant types
  like:
  \begin{tmcode}
  type int_string_choice = A of int | B of string
  \end{tmcode}
  and also tuple types, record types, and type definitions.
  
  \item Variants don't have to have arguments: instead of \tmverbatim{A of
  unit} just use \tmverbatim{A}.
  \begin{itemize}
    \item In OCaml, variants take multiple arguments rather than taking tuples
    as arguments: \tmverbatim{A of int * string} is different than\\
    \tmverbatim{A of (int * string)}. But it's not important {\small{unless
    you get bitten by it.}}
  \end{itemize}
  \item Type definitions can be recursive!
  \begin{tmcode}
  type int_list = Empty | Cons of int * int_list
  \end{tmcode}
  Let's see what we have in \tmverbatim{int\_list}:\\
  \tmverbatim{Empty}, \tmverbatim{Cons (5, Cons (7, Cons (13, Empty)))}, etc.
  
  \item Type \tmverbatim{bool} can be seen as \tmverbatim{type bool = true
  \textbar  false}, type \tmverbatim{int} can be seen as a very large
  \tmverbatim{type int = 0 \textbar  -1 \textbar  1 \textbar  -2 \textbar  2
  \textbar  ...}
  
  \item Type definitions can be {\tmem{parametric}} with respect to types of
  their components (more on this in lecture about polymorphism), for example a
  list elements of arbitrary type:
  \begin{tmcode}
  type 'elem list = Empty | Cons of 'elem * 'elem list
  \end{tmcode}
  \begin{itemize}
    \item Type variables must start with \tmverbatim{'}, but since OCaml will
    not remember the names we give, it's customary to use the names OCaml
    uses: \tmverbatim{'a}, \tmverbatim{'b}, \tmverbatim{'c},
    \tmverbatim{'d}...
    
    \item The syntax in OCaml is a bit strange: in F\# we write
    \tmverbatim{list<'elem>}. OCaml syntax mimics English, silly example:
    \begin{tmcode}
    type 'white_color dog = Dog of 'white_color
    \end{tmcode}
    \item With multiple parameters:
    \begin{itemize}
      \item OCaml:\\
      \tmverbatim{type ('a, 'b) choice = Left of 'a \textbar  Right of 'b}
      
      \item F\#:\\
      \tmverbatim{type choice<'a,'b> = Left of 'a \textbar  Right of 'b}
      
      \item Haskell:\\
      \tmverbatim{data Choice a b = Left a \textbar  Right b}
    \end{itemize}
  \end{itemize}
\end{itemize}

\section{Syntactic Bread and Sugar}

\begin{itemize}
  \item Names of variants, called {\tmem{constructors}}, must start with
  capital letter -- so if we wanted to define our own booleans, it would be
  \begin{tmcode}
  
  \end{tmcode}
  Only constructors and module names can start with capital letter.
  \begin{itemize}
    \item {\tmem{Modules}} are ``shelves'' with values. For example,
    \tmverbatim{List} has operations on lists, like \tmverbatim{List.map} and
    \tmverbatim{List.filter}.
  \end{itemize}
  \item Did I mention that we can use \tmverbatim{record.field} to access a
  field?
  
  \item \tmverbatim{fun x y -> e} stands for \tmverbatim{fun x -> fun y -> e},
  etc. -- and of course,\\
  \tmverbatim{fun x -> fun y -> e} parses as \tmverbatim{fun x -> (fun y ->
  e)}
  
  \item \tmverbatim{function A x -> e1 \textbar  B y -> e2} stands for
  \tmverbatim{fun p -> match p with A x -> e1 \textbar  B y -> e2}, etc.
  \begin{itemize}
    \item the general form is: \tmverbatim{function {\tmem{PATTERN-MATCHING}}}
    stands for\\
    \tmverbatim{fun $v$ -> match $v$ with {\tmem{PATTERN-MATCHING}}}
  \end{itemize}
  \item \tmverbatim{let f $\tmop{ARGS}$ = e} is a shorthand for
  \tmverbatim{let f = fun $\tmop{ARGS}$ -> e}
\end{itemize}


\section{Pattern Matching}

\begin{itemize}
  \item Recall that we introduced \tmverbatim{fst} and \tmverbatim{snd} as
  means to access elements of a pair. But what about bigger tuples? The
  ``basic'' way of accessing any tuple reuses the \tmverbatim{match}
  construct. Functions \tmverbatim{fst} and \tmverbatim{snd} can easily be
  defined!
  \begin{tmcode}
  let fst = fun p -> match p with (a, b) -> a
let snd = fun p -> match p with (a, b) -> b
  \end{tmcode}
  \item It also works with records:
  \begin{tmcode}
  type person = \{name: string; surname: string; age: int\}
match \{name="Walker"; surname="Johnnie"; age=207\}
with \{name=n; surname=sn; age=a\} -> "Hi "^sn^"!"
  \end{tmcode}
  \item The left-hand-sides of \tmverbatim{->} in \tmverbatim{match}
  expressions are called {\tmstrong{patterns}}.
  
  \item Patterns can be nested:
  \begin{tmcode}
  match Some (5, 7) with None -> "sum: nothing"
  | Some (x, y) -> "sum: " ^ string_of_int (x+y)
  \end{tmcode}
  \item A pattern can just match the whole value, without performing
  destructuring: \tmverbatim{match f x with v ->}... is the same as
  \tmverbatim{let v = f x in }...
  
  \item When we do not need a value in a pattern, it is good practice to use
  the underscore: \tmverbatim{\_} (which is not a variable!)
  \begin{tmcode}
  let fst (a,_) = a
let snd (_,b) = b
  \end{tmcode}
  \item A variable can only appear once in a pattern (it is called
  {\tmem{linearity}}).
  
  \item But we can add conditions to the patterns after \tmverbatim{when}, so
  linearity is not really a problem!
  \begin{tmcode}
  match p with (x, y) when x = y -> "diag" | _ -> "off-diag"
  \end{tmcode}
  \begin{tmcode}
  let compare a b = match a, b with
  | (x, y) when x < y -> -1
  | (x, y) when x = y -> 0
  | _ -> 1
  \end{tmcode}
  \item We can skip over unused fields of a record in a pattern.
  
  \item We can compress our patterns by using \tmverbatim{\textbar} inside a
  single pattern:
  \begin{tmcode}
  type month =
  | Jan | Feb | Mar | Apr | May | Jun
  | Jul | Aug | Sep | Oct | Nov | Dec
type weekday = Mon | Tue | Wed | Thu | Fri | Sat | Sun
type date =
  \{year: int; month: month; day: int; weekday: weekday\}
let day =
  \{year = 2012; month = Feb; day = 14; weekday = Wed\};;
match day with
  | \{weekday = Sat | Sun\} -> "Weekend!"
  | _ -> "Work day"
  \end{tmcode}
  \item We use \tmverbatim{(pattern {\tmstrong{as}} v)} to name a nested
  pattern:
  \begin{tmcode}
  match day with
  | \{weekday = (Mon | Tue | Wed | Thu | Fri  wday)\}
      when not (day.month = Dec && day.day = 24) ->
    Some (work (get_plan wday))
  | _ -> None
  \end{tmcode}
\end{itemize}
{\newpage}

\section{Interpreting Algebraic DTs as Polynomials}

Let's do a peculiar translation: take a data type and replace
\tmverbatim{\textbar} with $+$, \tmverbatim{*} with $\times$, treating record
types as tuple types (i.e. erasing field names and translationg \tmverbatim{;}
as $\times$).

There is a special type for which we cannot build a value:
\begin{tmcode}
type void
\end{tmcode}
(yes, it is its definition, no \tmverbatim{= something} part). Translate it as
$0$.

Translate the \tmverbatim{unit} type as $1$. Since variants without arguments
behave as variants \tmverbatim{of unit}, translate them as $1$ as well.
Translate \tmverbatim{bool} as $2$.

Translate \tmverbatim{int}, \tmverbatim{string}, \tmverbatim{float}, type
parameters and other types of interest as variables. Translate defined types
by their translations (substituting variables if necessary).

Give name to the type being defined (denoting a function of the variables
introduced). Now interpret the result as ordinary numeric polynomial! (Or
``rational function'' if it is recursively defined.)

Let's have fun with it.{\newpage}
\begin{tmcode}
type date = \{year: int; month: int; day: int\}
\end{tmcode}
\[ D = xxx = x^3 \]
\begin{tmcode}
type 'a option = None | Some of 'a   (* built-in type *)
\end{tmcode}
\[ O = 1 + x \]
\begin{tmcode}
type 'a my_list = Empty | Cons of 'a * 'a my_list
\end{tmcode}
\[ L = 1 + xL \]
\begin{tmcode}
type btree = Tip | Node of int * btree * btree
\end{tmcode}
\[ T = 1 + xTT = 1 + xT^2 \]
When translations of two types are equal according to laws of high-school
algebra, the types are {\tmem{isomorphic}}, that is, there exist 1-to-1
functions from one type to the other.{\newpage}

Let's play with the type of binary trees:
\begin{eqnarray*}
  T & = & 1 + xT^2 = 1 + xT + x^2 T^3 = 1 + x + x^2 T^2 + x^2 T^3 =\\
  & = & 1 + x + x^2 T^2  (1 + T) = 1 + x (1 + xT^2  (1 + T))
\end{eqnarray*}
Now let's translate the resulting type:
\begin{tmcode}
type repr =
  (int * (int * btree * btree * btree option) option) option
\end{tmcode}
Try to find the isomorphism functions \tmverbatim{iso1} and \tmverbatim{iso2}
\begin{tmcode}
val iso1 : btree -> repr
val iso2 : repr -> btree
\end{tmcode}
i.e. functions such that for all trees \tmverbatim{t}, \tmverbatim{iso2 (iso1
t) = t}, and for all representations \tmverbatim{r}, \tmverbatim{iso1 (iso2 r)
= r}.

My first failed attempt:
\begin{tmcode}
\# let iso1 (t : btree) : repr =
  match t with
    | Tip -> None
    | Node (x, Tip, Tip) -> Some (x, None)
    | Node (x, Node (y, t1, t2), Tip) ->
      Some (x, Some (y, t1, t2, None))
    | Node (x, Node (y, t1, t2), t3) ->
      Some (x, Some (y, t1, t2, Some t3));;
            Characters 32-261: [...]
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Node (_, Tip, Node (_, _, _))
\end{tmcode}
I forgot about one case. It seems difficult to guess the solution, have you
found it on your try?{\newpage}

Let's divide the task into smaller steps corresponding to selected
intermediate points in the transformation of the polynomial:
\begin{tmcode}
type ('a, 'b) choice = Left of 'a | Right of 'b
type interm1 =
  ((int * btree, int * int * btree * btree * btree) choice)
  option
type interm2 =
  ((int, int * int * btree * btree * btree option) choice)
  option

let step1r (t : btree) : interm1 =
  match t with
    | Tip -> None
    | Node (x, t1, Tip) -> Some (Left (x, t1))
    | Node (x, t1, Node (y, t2, t3)) ->
      Some (Right (x, y, t1, t2, t3))

let step2r (r : interm1) : interm2 =
  match r with
    | None -> None
    | Some (Left (x, Tip)) -> Some (Left x)
    | Some (Left (x, Node (y, t1, t2))) ->
      Some (Right (x, y, t1, t2, None))
    | Some (Right (x, y, t1, t2, t3)) ->
      Some (Right (x, y, t1, t2, Some t3))

let step3r (r : interm2) : repr =
  match r with
    | None -> None
    | Some (Left x) -> Some (x, None)
    | Some (Right (x, y, t1, t2, t3opt)) ->
      Some (x, Some (y, t1, t2, t3opt))

let iso1 (t : btree) : repr =
  step3r (step2r (step1r t))
\end{tmcode}
Define \tmverbatim{step1l}, \tmverbatim{step2l}, \tmverbatim{step3l}, and
\tmverbatim{iso2}. Hint: now it's trivial!{\newpage}

Take-home lessons:
\begin{itemize}
  \item Try to define data structures so that only information that makes
  sense can be represented -- as long as it does not overcomplicate the data
  structures. Avoid catch-all clauses when defining functions. The compiler
  will then tell you if you have forgotten about a case.
  
  \item Divide solutions into small steps so that each step can be easily
  understood and checked.
\end{itemize}

\subsection{Differentiating Algebraic Data Types}

Of course, you would say, the pompous title is wrong, we will differentiate
the translated polynomials. But what sense does it make?

It turns out, that taking the partial derivative of a polynomial resulting
from translating a data type, gives us, when translated back, a type
representing how to change one occurrence of a value of type corresponding to
the variable with respect to which we computed the partial derivative.

Take the ``date'' example:
\begin{tmcode}
type date = \{year: int; month: int; day: int\}
\end{tmcode}
\begin{eqnarray*}
  D & = & xxx = x^3\\
  \frac{\partial D}{\partial x} & = & 3 x^2 = xx + xx + xx
\end{eqnarray*}
(we could have left it at $3 xx$ as well). Now we construct the type:
\begin{tmcode}
type date_deriv =
  Year of int * int | Month of int * int | Day of int * int
\end{tmcode}
Now we need to introduce and use (``eliminate'') the type
\tmverbatim{date\_deriv}.
\begin{tmcode}
let date_deriv \{year=y; month=m; day=d\} =
  [Year (m, d); Month (y, d); Day (y, m)]

let date_integr n = function
  | Year (m, d) -> \{year=n; month=m; day=d\}
  | Month (y, d) -> \{year=y; month=n; day=d\}
  | Day (y, m) -> \{year=y; month=m, day=n\}
;;
List.map (date_integr 7)
  (date_deriv \{year=2012; month=2; day=14\})
\end{tmcode}
{\newpage}

Let's do now the more difficult case of binary trees:
\begin{tmcode}
type btree = Tip | Node of int * btree * btree
\end{tmcode}
\begin{eqnarray*}
  T & = & 1 + xT^2\\
  \frac{\partial T}{\partial x} & = & 0 + T^2 + 2 xT \frac{\partial
  T}{\partial x} = TT + 2 xT \frac{\partial T}{\partial x}
\end{eqnarray*}
(again, we could expand further into $\frac{\partial T}{\partial x} = TT + xT
\frac{\partial T}{\partial x} + xT \frac{\partial T}{\partial x}$).

Instead of translating $2$ as \tmverbatim{bool}, we will introduce new type
for clarity:
\begin{tmcode}
type btree_dir = LeftBranch | RightBranch
type btree_deriv =
  | Here of btree * btree
  | Below of btree_dir * int * btree * btree_deriv
\end{tmcode}
(You might someday hear about {\tmem{zippers}} -- they are ``inverted'' w.r.t.
our type, in zippers the hole comes first.)

Write a function that takes a number and a \tmverbatim{btree\_deriv}, and
builds a \tmverbatim{btree} by putting the number into the ``hole'' in
\tmverbatim{btree\_deriv}.{\newpage}

Solution:
\begin{tmcode}
let rec btree_integr n =
  | Here (ltree, rtree) -> Node (n, ltree, rtree)
  | Below (LeftBranch, m, rtree) ->
    Node (m, btree_integr n ltree, rtree)
  | Below (RightBranch, m, ltree) ->
    Node (m, ltree, btree_integr n rtree)
\end{tmcode}

\section{Homework}

Write a function \tmverbatim{btree\_deriv\_at} that takes a predicate over
integers (i.e. a function \tmverbatim{f: int -> bool}), and a
\tmverbatim{btree}, and builds a \tmverbatim{btree\_deriv} whose ``hole'' is
in the first position for which the predicate returns true. It should actually
return a \tmverbatim{btree\_deriv option}, with \tmverbatim{None} in case the
predicate does not hold for any node.

{\tmem{This homework is due for the class {\tmstrong{after}} the Computation
class, i.e. for (before) the Functions class.}}

\end{document}
