<TeXmacs|1.99.2>

<style|<tuple|beamer|highlight>>

<\body>
  <screens|<\shown>
    <tit|The Expression Problem>

    <doc-data|<doc-title|The Expression Problem>|<doc-subtitle|Code
    organization, extensibility and reuse>|<doc-author|<author-data|<author-name|Šukasz
    Stafiniak>|<author-email|lukstafi@gmail.com>|<author-homepage|www.ii.uni.wroc.pl/~lukstafi>>>>

    <\itemize>
      <item>Ralf Lämmel lectures on MSDN's Channel 9:<next-line><hlink|The
      Expression Problem|http://channel9.msdn.com/Shows/Going+Deep/C9-Lectures-Dr-Ralf-Laemmel-Advanced-Functional-Programming-The-Expression-Problem>,
      <hlink|Haskell's Type Classes|http://channel9.msdn.com/Shows/Going+Deep/C9-Lectures-Dr-Ralf-Lmmel-Advanced-Functional-Programming-Type-Classes>

      <item>The old book <em|Developing Applications with Objective
      Caml>:<next-line><hlink|Comparison of Modules and
      Objects|http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora153.html>,
      <hlink|Extending Components|http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora154.html>

      <item>The new book <em|Real World OCaml>: <hlink|Chapter 11:
      Objects|https://realworldocaml.org/v1/en/html/objects.html>,
      <hlink|Chapter 12: Classes|https://realworldocaml.org/v1/en/html/classes.html>

      <item>Jacques Garrigue's <hlink|Code reuse through polymorphic
      variants|http://www.math.nagoya-u.ac.jp/~garrigue/papers/variant-reuse.ps.gz>,<next-line>and
      <hlink|Recursive Modules for Programming|http://www.math.nagoya-u.ac.jp/~garrigue/papers/nakata-icfp2006.pdf>
      with Keiko Nakata

      <item><hlink|Extensible variant types|http://caml.inria.fr/pub/docs/manual-ocaml/extn.html#sec246>

      <item>Graham Hutton's and Erik Meijer's <hlink|Monadic Parser
      Combinators|https://www.cs.nott.ac.uk/~gmh/monparsing.pdf>
    </itemize>
  </shown>|<\hidden>
    <tit|The Expression Problem: Definition>

    <\itemize>
      <item>The <em|Expression Problem>: design an implementation for
      expressions, where:

      <\itemize>
        <item>new variants of expressions can be added (<em|datatype
        extensibility>),

        <item>new operations on the expressions can be added (<em|functional
        extensibility>).
      </itemize>

      <item>By <em|extensibility> we mean three conditions:

      <\itemize>
        <item>code-level modularization: the new datatype variants, and new
        operations, are in separate files,

        <item>separate compilation: the files can be compiled and distributed
        separately,

        <item>static type safety: we do not lose the type checking help and
        guarantees.
      </itemize>

      <item>The name comes from an example: extend a language of expressions
      with new constructs:

      <\itemize>
        <item>lambda calculus: variables <verbatim|Var>,
        <math|\<lambda\>>-abstractions <verbatim|Abs>, function applications
        <verbatim|App>;

        <item>arithmetics: variables <verbatim|Var>, constants
        <verbatim|Num>, addition <verbatim|Add>, multiplication
        <verbatim|Mult>; ...
      </itemize>

      and new oparations:

      <\itemize>
        <item>evaluation <verbatim|eval>;

        <item>pretty-printing to strings <verbatim|string_of>;

        <item>free variables <verbatim|free_vars>; ...
      </itemize>
    </itemize>
  </hidden>|<\hidden>
    <tit|Functional Programming Non-solution: ordinary Algebraic Datatypes>

    <\itemize>
      <item>Pattern matching makes functional extensibility easy in
      functional programming.

      <item>Ensuring datatype extensibility is complicated when using
      standard variant types.

      <item>For brevity, we will place examples in a single file, but the
      component type and function definitions are not mutually recursive so
      can be put in separate modules.

      <item>Non-solution penalty points:

      <\itemize>
        <item>Functions implemented for a broader language (e.g.
        <verbatim|lexpr_t>) cannot be used with a value from a narrower
        langugage (e.g. <verbatim|expr_t>).

        <item>Significant memory (and some time) overhead due to so called
        <em|tagging>: work of the <verbatim|wrap> and <verbatim|unwrap>
        functions, adding tags e.g. <verbatim|Lambda> and <verbatim|Expr>.

        <item>Some code bloat due to tagging. For example, deep pattern
        matching needs to be manually unrolled and interspersed with calls to
        <verbatim|unwrap>.
      </itemize>

      Verdict: non-solution, but better than extensible variant types-based
      approach (next) and direct OOP approach (later).
    </itemize>

    <hlkwa|type<space|0.5em>><hlstd|var<space|0.5em>><hlopt|=<space|0.5em>><hlkwb|string><hlendline|Variables
    constitute a sub-language of its own.><next-line><hlendline|We treat this
    sub-language slightly differently -- no need for a dedicated
    variant.><next-line><hlkwa|let<space|0.5em>><hlstd|eval<textunderscore>var<space|0.5em>wrap<space|0.5em>sub<space|0.5em>><hlopt|(><hlstd|s<space|0.5em>><hlopt|:<space|0.5em>><hlstd|var><hlopt|)<space|0.5em>=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|try<space|0.5em>><hlkwc|List><hlopt|.><hlstd|assoc<space|0.5em>s<space|0.5em>sub<space|0.5em>><hlkwa|with<space|0.5em>><hlkwd|Not<textunderscore>found<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|wrap<space|0.5em>s><hlendline|><next-line><hlendline|><next-line><hlkwa|type<space|0.5em>><hlstd|'a<space|0.5em>lambda<space|0.5em>><hlopt|=><hlendline|Here
    we define the sub-language of <math|\<lambda\>>-expressions.><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwd|VarL<space|0.5em>><hlkwa|of<space|0.5em>><hlstd|var<space|0.5em><hlopt|\||<space|0.5em>>><hlkwd|Abs<space|0.5em>><hlkwa|of<space|0.5em>><hlkwb|string<space|0.5em>><hlopt|*<space|0.5em>><hlstd|'a<space|0.5em><hlopt|\||<space|0.5em>>><hlkwd|App<space|0.5em>><hlkwa|of<space|0.5em>><hlstd|'a<space|0.5em>><hlopt|*<space|0.5em>><hlstd|'a><hlendline|><next-line><hlendline|During
    evaluation, we need to freshen variables to avoid
    capture><next-line><hlkwa|let<space|0.5em>><hlstd|gensym<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|let<space|0.5em>><hlstd|n<space|0.5em>><hlopt|=<space|0.5em>><hlkwb|ref<space|0.5em>><hlnum|0<space|0.5em>><hlkwa|in<space|0.5em>fun<space|0.5em>><hlopt|()<space|0.5em>-\<gtr\><space|0.5em>><hlstd|incr<space|0.5em>n><hlopt|;<space|0.5em>><hlstr|"<textunderscore>"><hlstd|<space|0.5em>\B<space|0.5em>string<textunderscore>of<textunderscore>int<space|0.5em>><hlopt|!><hlstd|n><hlendline|><next-line><hlendline|(mistaking
    distinct variables with the same name).><next-line><hlkwa|let<space|0.5em>><hlstd|eval<textunderscore>lambda<space|0.5em>eval<textunderscore>rec<space|0.5em>wrap<space|0.5em>unwrap<space|0.5em>subst<space|0.5em>e<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|match<space|0.5em>><hlstd|unwrap<space|0.5em>e<space|0.5em>><hlkwa|with><hlendline|Alternatively,
    unwrapping could use an exception,><next-line><hlstd|<space|0.5em><space|0.5em>><hlopt|\|<space|0.5em>><hlkwd|Some<space|0.5em>><hlopt|(><hlkwd|VarL<space|0.5em>><hlstd|v><hlopt|)<space|0.5em>-\<gtr\><space|0.5em>><hlstd|eval<textunderscore>var<space|0.5em>><hlopt|(><hlkwa|fun<space|0.5em>><hlstd|v<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|wrap<space|0.5em>><hlopt|(><hlkwd|VarL<space|0.5em>><hlstd|v><hlopt|))<space|0.5em>><hlstd|subst<space|0.5em>v<hlendline|><next-line><space|0.5em><space|0.5em>><hlopt|\|<space|0.5em>><hlkwd|Some<space|0.5em>><hlopt|(><hlkwd|App<space|0.5em>><hlopt|(><hlstd|l1><hlopt|,<space|0.5em>><hlstd|l2><hlopt|))<space|0.5em>-\<gtr\>><hlendline|but
    we use the option type as it is safer><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|l1'<space|0.5em>><hlopt|=<space|0.5em>><verbatim|eval<textunderscore>rec<space|0.5em>subst<space|0.5em>l1><hlendline|and
    more flexible in this context.><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlkwa|and<space|0.5em>><hlstd|l2'<space|0.5em>><hlopt|=<space|0.5em>><hlstd|eval<textunderscore>rec<space|0.5em>subst<space|0.5em>l2<space|0.5em>><hlkwa|in><hlendline|Recursive
    processing function returns expression><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|(><hlkwa|match<space|0.5em>><hlstd|unwrap<space|0.5em>l1'<space|0.5em>><hlkwa|with><hlendline|of
    the completed language, we need><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|\|<space|0.5em>><hlkwd|Some<space|0.5em>><hlopt|(><hlkwd|Abs<space|0.5em>><hlopt|(><hlstd|s><hlopt|,<space|0.5em>><hlstd|body><hlopt|))<space|0.5em>-\<gtr\>><hlendline|to
    unwrap it into the current sub-language.><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>eval<textunderscore>rec<space|0.5em>><hlopt|[><hlstd|s><hlopt|,<space|0.5em>><hlstd|l2'><hlopt|]<space|0.5em>><verbatim|body><hlendline|The
    recursive call is already wrapped.><next-line><verbatim|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|\||<space|0.5em>|<textunderscore>|<space|0.5em>><hlkwd|
    _ ><hlopt|-\<gtr\><space|0.5em>><hlstd|wrap<space|0.5em>><hlopt|(><hlkwd|App<space|0.5em>><hlopt|(><hlstd|l1'><hlopt|,<space|0.5em>><hlstd|l2'><hlopt|)))><hlendline|Wrap
    into the completed language.><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|Some<space|0.5em>><hlopt|(><hlkwd|Abs<space|0.5em>><hlopt|(><hlstd|s><hlopt|,<space|0.5em>><hlstd|l1><hlopt|))<space|0.5em>-\<gtr\>><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|s'<space|0.5em>><hlopt|=<space|0.5em>><hlstd|gensym<space|0.5em>><hlopt|()<space|0.5em>><hlkwa|in><hlendline|Rename
    variable to avoid capture (<math|\<alpha\>>-equivalence).><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>wrap<space|0.5em>><hlopt|(><hlkwd|Abs<space|0.5em>><hlopt|(><hlstd|s'><hlopt|,<space|0.5em>><hlstd|eval<textunderscore>rec<space|0.5em>><hlopt|((><hlstd|s><hlopt|,<space|0.5em>><hlstd|wrap<space|0.5em>><hlopt|(><hlkwd|VarL<space|0.5em>><hlstd|s'><hlopt|))::><hlstd|subst><hlopt|)<space|0.5em>><hlstd|l1><hlopt|))><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|None<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|e><hlendline|Falling-through
    when not in the current sub-language.><next-line><hlendline|><next-line><hlkwa|type<space|0.5em>><hlstd|lambda<textunderscore>t<space|0.5em>><hlopt|=<space|0.5em>><hlkwd|Lambda<textunderscore>t<space|0.5em>><hlkwa|of<space|0.5em>><hlstd|lambda<textunderscore>t<space|0.5em>lambda><hlendline|Defining
    <math|\<lambda\>>-expressions><next-line><hlendline|as the completed
    language,><next-line><hlkwa|let<space|0.5em>rec<space|0.5em>><hlstd|eval1<space|0.5em>subst<space|0.5em>><hlopt|=><hlendline|and
    the corresponding <verbatim|eval> function.><next-line><hlstd|<space|0.5em><space|0.5em>eval<textunderscore>lambda<space|0.5em>eval1<hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|(><hlkwa|fun<space|0.5em>><hlstd|e<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwd|Lambda<textunderscore>t<space|0.5em>><hlstd|e><hlopt|)<space|0.5em>(><hlkwa|fun<space|0.5em>><hlopt|(><hlkwd|Lambda<textunderscore>t<space|0.5em>><hlstd|e><hlopt|)<space|0.5em>-\<gtr\><space|0.5em>><hlkwd|Some<space|0.5em>><hlstd|e><hlopt|)<space|0.5em>><hlstd|subst><hlendline|><next-line><hlendline|><next-line><hlkwa|type<space|0.5em>><hlstd|'a<space|0.5em>expr<space|0.5em>><hlopt|=><hlendline|The
    sub-language of arithmetic expressions.><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwd|VarE<space|0.5em>><hlkwa|of<space|0.5em>><hlstd|var<space|0.5em><hlbar><space|0.5em>><hlkwd|Num<space|0.5em>><hlkwa|of<space|0.5em>><hlkwb|int<space|0.5em>><hlstd|<hlbar><space|0.5em>><hlkwd|Add<space|0.5em>><hlkwa|of<space|0.5em>><hlstd|'a<space|0.5em>><hlopt|*<space|0.5em>><hlstd|'a<space|0.5em><hlbar><space|0.5em>><hlkwd|Mult<space|0.5em>><hlkwa|of<space|0.5em>><hlstd|'a<space|0.5em>><hlopt|*<space|0.5em>><hlstd|'a><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|eval<textunderscore>expr<space|0.5em>eval<textunderscore>rec<space|0.5em>wrap<space|0.5em>unwrap<space|0.5em>subst<space|0.5em>e<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|match<space|0.5em>><hlstd|unwrap<space|0.5em>e<space|0.5em>><hlkwa|with><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|Some<space|0.5em>><hlopt|(><hlkwd|Num<space|0.5em>><hlstd|<textunderscore>><hlopt|)<space|0.5em>-\<gtr\><space|0.5em>><hlstd|e<hlendline|><next-line><space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|Some<space|0.5em>><hlopt|(><hlkwd|VarE<space|0.5em>><hlstd|v><hlopt|)<space|0.5em>-\<gtr\>><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>eval<textunderscore>var<space|0.5em>><hlopt|(><hlkwa|fun<space|0.5em>><hlstd|x<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|wrap<space|0.5em>><hlopt|(><hlkwd|VarE<space|0.5em>><hlstd|x><hlopt|))<space|0.5em>><hlstd|subst<space|0.5em>v<hlendline|><next-line><space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|Some<space|0.5em>><hlopt|(><hlkwd|Add<space|0.5em>><hlopt|(><hlstd|m><hlopt|,<space|0.5em>><hlstd|n><hlopt|))<space|0.5em>-\<gtr\>><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|m'<space|0.5em>><hlopt|=<space|0.5em>><hlstd|eval<textunderscore>rec<space|0.5em>subst<space|0.5em>m<hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|and<space|0.5em>><hlstd|n'<space|0.5em>><hlopt|=<space|0.5em>><hlstd|eval<textunderscore>rec<space|0.5em>subst<space|0.5em>n<space|0.5em>><hlkwa|in><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|(><hlkwa|match<space|0.5em>><hlstd|unwrap<space|0.5em>m'><hlopt|,<space|0.5em>><hlstd|unwrap<space|0.5em>n'<space|0.5em>><hlkwa|with><hlendline|Unwrapping
    to check if the subexpressions><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|Some<space|0.5em>><hlopt|(><hlkwd|Num<space|0.5em>><hlstd|m'><hlopt|),<space|0.5em>><hlkwd|Some<space|0.5em>><hlopt|(><hlkwd|Num<space|0.5em>><hlstd|n'><hlopt|)<space|0.5em>-\<gtr\>><hlendline|got
    computed to values.><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>wrap<space|0.5em>><hlopt|(><hlkwd|Num<space|0.5em>><hlopt|(><hlstd|m'<space|0.5em>><hlopt|+<space|0.5em>><hlstd|n'><hlopt|))><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><hlunderscore>><hlopt|-\<gtr\><space|0.5em>><hlstd|wrap<space|0.5em>><hlopt|(><hlkwd|Add<space|0.5em>><hlopt|(><hlstd|m'><hlopt|,<space|0.5em>><hlstd|n'><hlopt|)))><hlendline|Here
    <verbatim|m'> and <verbatim|n'> are wrapped.><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|Some<space|0.5em>><hlopt|(><hlkwd|Mult<space|0.5em>><hlopt|(><hlstd|m><hlopt|,<space|0.5em>><hlstd|n><hlopt|))<space|0.5em>-\<gtr\>><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|m'<space|0.5em>><hlopt|=<space|0.5em>><hlstd|eval<textunderscore>rec<space|0.5em>subst<space|0.5em>m<hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|and<space|0.5em>><hlstd|n'<space|0.5em>><hlopt|=<space|0.5em>><hlstd|eval<textunderscore>rec<space|0.5em>subst<space|0.5em>n<space|0.5em>><hlkwa|in><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|(><hlkwa|match<space|0.5em>><hlstd|unwrap<space|0.5em>m'><hlopt|,<space|0.5em>><hlstd|unwrap<space|0.5em>n'<space|0.5em>><hlkwa|with><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|Some<space|0.5em>><hlopt|(><hlkwd|Num<space|0.5em>><hlstd|m'><hlopt|),<space|0.5em>><hlkwd|Some<space|0.5em>><hlopt|(><hlkwd|Num<space|0.5em>><hlstd|n'><hlopt|)<space|0.5em>-\<gtr\>><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>wrap<space|0.5em>><hlopt|(><hlkwd|Num<space|0.5em>><hlopt|(><hlstd|m'<space|0.5em>><hlopt|*<space|0.5em>><hlstd|n'><hlopt|))><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><hlunderscore>><hlopt|-\<gtr\><space|0.5em>><hlstd|wrap<space|0.5em>><hlopt|(><hlkwd|Mult<space|0.5em>><hlopt|(><hlstd|m'><hlopt|,<space|0.5em>><hlstd|n'><hlopt|)))><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|None<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|e><hlendline|><next-line><hlendline|><next-line><hlkwa|type<space|0.5em>><hlstd|expr<textunderscore>t<space|0.5em>><hlopt|=<space|0.5em>><hlkwd|Expr<textunderscore>t<space|0.5em>><hlkwa|of<space|0.5em>><hlstd|expr<textunderscore>t<space|0.5em>expr><hlendline|Defining
    arithmetic expressions><next-line><hlendline|as the completed
    language,><next-line><hlkwa|let<space|0.5em>rec<space|0.5em>><hlstd|eval2<space|0.5em>subst<space|0.5em>><hlopt|=><hlendline|aka.
    ``tying the recursive knot''.><next-line><hlstd|<space|0.5em><space|0.5em>eval<textunderscore>expr<space|0.5em>eval2<hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|(><hlkwa|fun<space|0.5em>><hlstd|e<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwd|Expr<textunderscore>t<space|0.5em>><hlstd|e><hlopt|)<space|0.5em>(><hlkwa|fun<space|0.5em>><hlopt|(><hlkwd|Expr<textunderscore>t<space|0.5em>><hlstd|e><hlopt|)<space|0.5em>-\<gtr\><space|0.5em>><hlkwd|Some<space|0.5em>><hlstd|e><hlopt|)<space|0.5em>><hlstd|subst><hlendline|><next-line><hlendline|><next-line><hlkwa|type<space|0.5em>><hlstd|'a<space|0.5em>lexpr<space|0.5em>><hlopt|=><hlendline|The
    language merging <math|\<lambda\>>-expressions and arithmetic
    expressions,><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwd|Lambda<space|0.5em>><hlkwa|of<space|0.5em>><hlstd|'a<space|0.5em>lambda<space|0.5em><hlbar><space|0.5em>><hlkwd|Expr<space|0.5em>><hlkwa|of<space|0.5em>><hlstd|'a<space|0.5em>expr><hlendline|can
    also be used as><next-line><hlendline|a sub-language for further
    extensions.><next-line><hlkwa|let<space|0.5em>><hlstd|eval<textunderscore>lexpr<space|0.5em>eval<textunderscore>rec<space|0.5em>wrap<space|0.5em>unwrap<space|0.5em>subst<space|0.5em>e<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>eval<textunderscore>lambda<space|0.5em>eval<textunderscore>rec<hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|(><hlkwa|fun<space|0.5em>><hlstd|e<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|wrap<space|0.5em>><hlopt|(><hlkwd|Lambda<space|0.5em>><hlstd|e><hlopt|))><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|(><hlkwa|fun<space|0.5em>><hlstd|e<space|0.5em>><hlopt|-\<gtr\>><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|match<space|0.5em>><hlstd|unwrap<space|0.5em>e<space|0.5em>><hlkwa|with><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|Some<space|0.5em>><hlopt|(><hlkwd|Lambda<space|0.5em>><hlstd|e><hlopt|)<space|0.5em>-\<gtr\><space|0.5em>><hlkwd|Some<space|0.5em>><hlstd|e<hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><hlunderscore>><hlopt|-\<gtr\><space|0.5em>><hlkwd|None><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>subst<hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|(><verbatim|eval<textunderscore>expr<space|0.5em>eval<textunderscore>rec><hlendline|We
    use the ``fall-through'' property of <verbatim|eval_expr>><next-line><verbatim|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|(><hlkwa|fun<space|0.5em>><hlstd|e<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|wrap<space|0.5em>><hlopt|(><hlkwd|Expr<space|0.5em>><hlstd|e><hlopt|))><hlendline|to
    combine the evaluators.><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|(><hlkwa|fun<space|0.5em>><hlstd|e<space|0.5em>><hlopt|-\<gtr\>><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|match<space|0.5em>><hlstd|unwrap<space|0.5em>e<space|0.5em>><hlkwa|with><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|Some<space|0.5em>><hlopt|(><hlkwd|Expr<space|0.5em>><hlstd|e><hlopt|)<space|0.5em>-\<gtr\><space|0.5em>><hlkwd|Some<space|0.5em>><hlstd|e<hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><hlunderscore>><hlopt|-\<gtr\><space|0.5em>><hlkwd|None><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>subst<space|0.5em>e><hlopt|)><hlendline|><next-line><hlendline|><next-line><hlkwa|type<space|0.5em>><hlstd|lexpr<textunderscore>t<space|0.5em>><hlopt|=<space|0.5em>><hlkwd|LExpr<textunderscore>t<space|0.5em>><hlkwa|of<space|0.5em>><hlstd|lexpr<textunderscore>t<space|0.5em>lexpr><hlendline|Tying
    the recursive knot one last time.><next-line><hlkwa|let<space|0.5em>rec<space|0.5em>><hlstd|eval3<space|0.5em>subst<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>eval<textunderscore>lexpr<space|0.5em>eval3<hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|(><hlkwa|fun<space|0.5em>><hlstd|e<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwd|LExpr<textunderscore>t<space|0.5em>><hlstd|e><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|(><hlkwa|fun<space|0.5em>><hlopt|(><hlkwd|LExpr<textunderscore>t<space|0.5em>><hlstd|e><hlopt|)<space|0.5em>-\<gtr\><space|0.5em>><hlkwd|Some<space|0.5em>><hlstd|e><hlopt|)<space|0.5em>><hlstd|subst><hlendline|><next-line>
  </hidden>|<\hidden>
    <tit|Lightweight FP non-solution: Extensible Variant Types>

    <\itemize>
      <item>Exceptions have always formed an extensible variant type in
      OCaml, whose pattern matching is done using the
      <hlkwa|try><math|\<ldots\>><hlkwa|with> syntax. Since recently, new
      extensible variant types can be defined. This augments the normal
      function extensibility of FP with straightforward data extensibility.

      <item>Non-solution penalty points:

      <\itemize>
        <item>Giving up exhaustivity checking, which is an important aspect
        of static type safety.

        <item>More natural with ``single inheritance'' extension chains,
        although merging is possible, and demonstrated in our example.

        <item>Requires ``tying the recursive knot'' for functions.
      </itemize>

      Verdict: pleasant-looking, but the worst approach because of possible
      bugginess. Unless bug-proneness is not a concern, then the best
      approach.
    </itemize>

    <hlkwa|type<space|0.5em>><hlstd|expr<space|0.5em>><hlopt|=<space|0.5em>..><hlendline|This
    is how extensible variant types are defined.><next-line><hlkwa|type<space|0.5em>><hlstd|var<textunderscore>name<space|0.5em>><hlopt|=<space|0.5em>><hlkwb|string><hlendline|><next-line><hlkwa|type<space|0.5em>><hlstd|expr<space|0.5em>><hlopt|+=<space|0.5em>><hlkwd|Var<space|0.5em>><hlkwa|of<space|0.5em>><hlkwb|string><hlendline|We
    add a variant case.><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|eval<textunderscore>var<space|0.5em>sub<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|function><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|Var<space|0.5em>><hlstd|s<space|0.5em>><hlkwa|as<space|0.5em>><hlstd|v<space|0.5em>><hlopt|-\<gtr\><space|0.5em>(><hlkwa|try<space|0.5em>><hlkwc|List><hlopt|.><hlstd|assoc<space|0.5em>s<space|0.5em>sub<space|0.5em>><hlkwa|with<space|0.5em>><hlkwd|Not<textunderscore>found<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|v><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>e<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|e><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|gensym<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|let<space|0.5em>><hlstd|n<space|0.5em>><hlopt|=<space|0.5em>><hlkwb|ref<space|0.5em>><hlnum|0<space|0.5em>><hlkwa|in<space|0.5em>fun<space|0.5em>><hlopt|()<space|0.5em>-\<gtr\><space|0.5em>><hlstd|incr<space|0.5em>n><hlopt|;<space|0.5em>><hlstr|"<textunderscore>"><hlstd|<space|0.5em><hlcircum><space|0.5em>string<textunderscore>of<textunderscore>int<space|0.5em>><hlopt|!><hlstd|n><hlendline|><next-line><hlendline|><next-line><hlkwa|type<space|0.5em>><hlstd|expr<space|0.5em>><hlopt|+=<space|0.5em>><hlkwd|Abs<space|0.5em>><hlkwa|of<space|0.5em>><hlkwb|string<space|0.5em>><hlopt|*<space|0.5em>><hlstd|expr<space|0.5em><hlbar><space|0.5em>><hlkwd|App<space|0.5em>><hlkwa|of<space|0.5em>><hlstd|expr<space|0.5em>><hlopt|*<space|0.5em>><hlstd|expr><hlendline|The
    sub-languages><next-line><hlendline|are not differentiated by types, a
    shortcoming of this non-solution.><next-line><hlkwa|let<space|0.5em>><hlstd|eval<textunderscore>lambda<space|0.5em>eval<textunderscore>rec<space|0.5em>subst<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|function><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|Var<space|0.5em>><hlstd|<textunderscore><space|0.5em>><hlkwa|as<space|0.5em>><hlstd|v<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|eval<textunderscore>var<space|0.5em>subst<space|0.5em>v<hlendline|><next-line><space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|App<space|0.5em>><hlopt|(><hlstd|l1><hlopt|,<space|0.5em>><hlstd|l2><hlopt|)<space|0.5em>-\<gtr\>><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|l2'<space|0.5em>><hlopt|=<space|0.5em>><hlstd|eval<textunderscore>rec<space|0.5em>subst<space|0.5em>l2<space|0.5em>><hlkwa|in><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|(><hlkwa|match<space|0.5em>><hlstd|eval<textunderscore>rec<space|0.5em>subst<space|0.5em>l1<space|0.5em>><hlkwa|with><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|Abs<space|0.5em>><hlopt|(><hlstd|s><hlopt|,<space|0.5em>><hlstd|body><hlopt|)<space|0.5em>-\<gtr\>><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>eval<textunderscore>rec<space|0.5em>><hlopt|[><hlstd|s><hlopt|,<space|0.5em>><hlstd|l2'><hlopt|]<space|0.5em>><hlstd|body<hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>l1'<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwd|App<space|0.5em>><hlopt|(><hlstd|l1'><hlopt|,<space|0.5em>><hlstd|l2'><hlopt|))><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|Abs<space|0.5em>><hlopt|(><hlstd|s><hlopt|,<space|0.5em>><hlstd|l1><hlopt|)<space|0.5em>-\<gtr\>><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|s'<space|0.5em>><hlopt|=<space|0.5em>><hlstd|gensym<space|0.5em>><hlopt|()<space|0.5em>><hlkwa|in><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwd|Abs<space|0.5em>><hlopt|(><hlstd|s'><hlopt|,<space|0.5em>><hlstd|eval<textunderscore>rec<space|0.5em>><hlopt|((><hlstd|s><hlopt|,<space|0.5em>><hlkwd|Var<space|0.5em>><hlstd|s'><hlopt|)::><hlstd|subst><hlopt|)<space|0.5em>><hlstd|l1><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>e<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|e><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|freevars<textunderscore>lambda<space|0.5em>freevars<textunderscore>rec<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|function><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|Var<space|0.5em>><hlstd|v<space|0.5em>><hlopt|-\<gtr\><space|0.5em>[><hlstd|v><hlopt|]><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|App<space|0.5em>><hlopt|(><hlstd|l1><hlopt|,<space|0.5em>><hlstd|l2><hlopt|)<space|0.5em>-\<gtr\><space|0.5em>><hlstd|freevars<textunderscore>rec<space|0.5em>l1<space|0.5em>><hlopt|@<space|0.5em>><hlstd|freevars<textunderscore>rec<space|0.5em>l2<hlendline|><next-line><space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|Abs<space|0.5em>><hlopt|(><hlstd|s><hlopt|,<space|0.5em>><hlstd|l1><hlopt|)<space|0.5em>-\<gtr\>><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwc|List><hlopt|.><hlstd|filter<space|0.5em>><hlopt|(><hlkwa|fun<space|0.5em>><hlstd|v<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|v<space|0.5em>><hlopt|\<less\>\<gtr\><space|0.5em>><hlstd|s><hlopt|)<space|0.5em>(><hlstd|freevars<textunderscore>rec<space|0.5em>l1><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><hlunderscore>><hlopt|-\<gtr\><space|0.5em>[]><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>rec<space|0.5em>><hlstd|eval1<space|0.5em>subst<space|0.5em>e<space|0.5em>><hlopt|=<space|0.5em>><hlstd|eval<textunderscore>lambda<space|0.5em>eval1<space|0.5em>subst<space|0.5em>e><hlendline|><next-line><hlkwa|let<space|0.5em>rec<space|0.5em>><hlstd|freevars1<space|0.5em>e<space|0.5em>><hlopt|=<space|0.5em>><hlstd|freevars<textunderscore>lambda<space|0.5em>freevars1<space|0.5em>e><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|test1<space|0.5em>><hlopt|=<space|0.5em>><hlkwd|App<space|0.5em>><hlopt|(><hlkwd|Abs<space|0.5em>><hlopt|(><hlstr|"x"><hlopt|,<space|0.5em>><hlkwd|Var<space|0.5em>><hlstr|"x"><hlopt|),<space|0.5em>><hlkwd|Var<space|0.5em>><hlstr|"y"><hlopt|)><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|e<textunderscore>test<space|0.5em>><hlopt|=<space|0.5em>><hlstd|eval1<space|0.5em>><hlopt|[]<space|0.5em>><hlstd|test1><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|fv<textunderscore>test<space|0.5em>><hlopt|=<space|0.5em>><hlstd|freevars1<space|0.5em>test1><hlendline|><next-line><hlendline|><next-line><hlkwa|type<space|0.5em>><hlstd|expr<space|0.5em>><hlopt|+=<space|0.5em>><hlkwd|Num<space|0.5em>><hlkwa|of<space|0.5em>><hlkwb|int<space|0.5em>><hlstd|<hlbar><space|0.5em>><hlkwd|Add<space|0.5em>><hlkwa|of<space|0.5em>><hlstd|expr<space|0.5em>><hlopt|*<space|0.5em>><hlstd|expr<space|0.5em><hlbar><space|0.5em>><hlkwd|Mult<space|0.5em>><hlkwa|of<space|0.5em>><hlstd|expr<space|0.5em>><hlopt|*<space|0.5em>><hlstd|expr><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|map<textunderscore>expr<space|0.5em>f<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|function><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|Add<space|0.5em>><hlopt|(><hlstd|e1><hlopt|,<space|0.5em>><hlstd|e2><hlopt|)<space|0.5em>-\<gtr\><space|0.5em>><hlkwd|Add<space|0.5em>><hlopt|(><hlstd|f<space|0.5em>e1><hlopt|,<space|0.5em>><hlstd|f<space|0.5em>e2><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|Mult<space|0.5em>><hlopt|(><hlstd|e1><hlopt|,<space|0.5em>><hlstd|e2><hlopt|)<space|0.5em>-\<gtr\><space|0.5em>><hlkwd|Mult<space|0.5em>><hlopt|(><hlstd|f<space|0.5em>e1><hlopt|,<space|0.5em>><hlstd|f<space|0.5em>e2><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>e<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|e><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|eval<textunderscore>expr<space|0.5em>eval<textunderscore>rec<space|0.5em>subst<space|0.5em>e<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|match<space|0.5em>><hlstd|map<textunderscore>expr<space|0.5em>><hlopt|(><hlstd|eval<textunderscore>rec<space|0.5em>subst><hlopt|)<space|0.5em>><hlstd|e<space|0.5em>><hlkwa|with><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|Add<space|0.5em>><hlopt|(><hlkwd|Num<space|0.5em>><hlstd|m><hlopt|,<space|0.5em>><hlkwd|Num<space|0.5em>><hlstd|n><hlopt|)<space|0.5em>-\<gtr\><space|0.5em>><hlkwd|Num<space|0.5em>><hlopt|(><hlstd|m<space|0.5em>><hlopt|+<space|0.5em>><hlstd|n><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|Mult<space|0.5em>><hlopt|(><hlkwd|Num<space|0.5em>><hlstd|m><hlopt|,<space|0.5em>><hlkwd|Num<space|0.5em>><hlstd|n><hlopt|)<space|0.5em>-\<gtr\><space|0.5em>><hlkwd|Num<space|0.5em>><hlopt|(><hlstd|m<space|0.5em>><hlopt|*<space|0.5em>><hlstd|n><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>><hlopt|(><hlkwd|Num<space|0.5em>><hlstd|<textunderscore><space|0.5em><hlbar><space|0.5em>><hlkwd|Add<space|0.5em>><hlstd|<textunderscore><space|0.5em><hlbar><space|0.5em>><hlkwd|Mult<space|0.5em>><hlstd|<textunderscore>><hlopt|)<space|0.5em>><hlkwa|as<space|0.5em>><hlstd|e<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|e<hlendline|><next-line><space|0.5em><space|0.5em><hlbar><space|0.5em>e<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|e><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|freevars<textunderscore>expr<space|0.5em>freevars<textunderscore>rec<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|function><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|Num<space|0.5em>><hlstd|<textunderscore><space|0.5em>><hlopt|-\<gtr\><space|0.5em>[]><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|Add<space|0.5em>><hlopt|(><hlstd|e1><hlopt|,<space|0.5em>><hlstd|e2><hlopt|)<space|0.5em>><hlstd|<hlbar><space|0.5em>><hlkwd|Mult<space|0.5em>><hlopt|(><hlstd|e1><hlopt|,<space|0.5em>><hlstd|e2><hlopt|)<space|0.5em>-\<gtr\><space|0.5em>><hlstd|freevars<textunderscore>rec<space|0.5em>e1<space|0.5em>><hlopt|@<space|0.5em>><hlstd|freevars<textunderscore>rec<space|0.5em>e2<hlendline|><next-line><space|0.5em><space|0.5em><hlbar><hlunderscore>><hlopt|-\<gtr\><space|0.5em>[]><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>rec<space|0.5em>><hlstd|eval2<space|0.5em>subst<space|0.5em>e<space|0.5em>><hlopt|=<space|0.5em>><hlstd|eval<textunderscore>expr<space|0.5em>eval2<space|0.5em>subst<space|0.5em>e><hlendline|><next-line><hlkwa|let<space|0.5em>rec<space|0.5em>><hlstd|freevars2<space|0.5em>e<space|0.5em>><hlopt|=<space|0.5em>><hlstd|freevars<textunderscore>expr<space|0.5em>freevars2<space|0.5em>e><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|test2<space|0.5em>><hlopt|=<space|0.5em>><hlkwd|Add<space|0.5em>><hlopt|(><hlkwd|Mult<space|0.5em>><hlopt|(><hlkwd|Num<space|0.5em>><hlnum|3><hlopt|,<space|0.5em>><hlkwd|Var<space|0.5em>><hlstr|"x"><hlopt|),<space|0.5em>><hlkwd|Num<space|0.5em>><hlnum|1><hlopt|)><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|e<textunderscore>test2<space|0.5em>><hlopt|=<space|0.5em>><hlstd|eval2<space|0.5em>><hlopt|[]<space|0.5em>><hlstd|test2><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|fv<textunderscore>test2<space|0.5em>><hlopt|=<space|0.5em>><hlstd|freevars2<space|0.5em>test2><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|eval<textunderscore>lexpr<space|0.5em>eval<textunderscore>rec<space|0.5em>subst<space|0.5em>e<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>eval<textunderscore>expr<space|0.5em>eval<textunderscore>rec<space|0.5em>subst<space|0.5em>><hlopt|(><hlstd|eval<textunderscore>lambda<space|0.5em>eval<textunderscore>rec<space|0.5em>subst<space|0.5em>e><hlopt|)><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|freevars<textunderscore>lexpr<space|0.5em>freevars<textunderscore>rec<space|0.5em>e<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>freevars<textunderscore>lambda<space|0.5em>freevars<textunderscore>rec<space|0.5em>e<space|0.5em>><hlopt|@<space|0.5em>><hlstd|freevars<textunderscore>expr<space|0.5em>freevars<textunderscore>rec<space|0.5em>e><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>rec<space|0.5em>><hlstd|eval3<space|0.5em>subst<space|0.5em>e<space|0.5em>><hlopt|=<space|0.5em>><hlstd|eval<textunderscore>lexpr<space|0.5em>eval3<space|0.5em>subst<space|0.5em>e><hlendline|><next-line><hlkwa|let<space|0.5em>rec<space|0.5em>><hlstd|freevars3<space|0.5em>e<space|0.5em>><hlopt|=<space|0.5em>><hlstd|freevars<textunderscore>lexpr<space|0.5em>freevars3<space|0.5em>e><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|test3<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwd|App<space|0.5em>><hlopt|(><hlkwd|Abs<space|0.5em>><hlopt|(><hlstr|"x"><hlopt|,<space|0.5em>><hlkwd|Add<space|0.5em>><hlopt|(><hlkwd|Mult<space|0.5em>><hlopt|(><hlkwd|Num<space|0.5em>><hlnum|3><hlopt|,<space|0.5em>><hlkwd|Var<space|0.5em>><hlstr|"x"><hlopt|),<space|0.5em>><hlkwd|Num<space|0.5em>><hlnum|1><hlopt|)),><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwd|Num<space|0.5em>><hlnum|2><hlopt|)><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|e<textunderscore>test3<space|0.5em>><hlopt|=<space|0.5em>><hlstd|eval3<space|0.5em>><hlopt|[]<space|0.5em>><hlstd|test3><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|fv<textunderscore>test3<space|0.5em>><hlopt|=<space|0.5em>><hlstd|freevars3<space|0.5em>test3><hlendline|>
  </hidden>|<\hidden>
    <tit|Object Oriented Programming: Subtyping>

    <\itemize>
      <item>OCaml's <em|objects> are values, somewhat similar to records.

      <item>Viewed from the outside, an OCaml object has only <em|methods>,
      identifying the code with which to respond to messages, i.e. method
      invocations.

      <item>All methods are <em|late-bound>, the object determines what code
      is run (i.e. <em|virtual> in C++ parlance).

      <item><em|Subtyping> determines if an object can be used in some
      context. OCaml has <em|structural subtyping>: the content of the types
      concerned decides if an object can be used.

      <item>Parametric polymorphism can be used to infer if an object has the
      required methods.
    </itemize>

    <hlkwa|let<space|0.5em>><hlstd|f<space|0.5em>x<space|0.5em>><hlopt|=<space|0.5em>><hlstd|x><hlopt|#><hlstd|m><hlendline|Method
    invocation: object<hlopt|#>method.><next-line><hlkwa|val<space|0.5em>><hlstd|f<space|0.5em>><hlopt|:<space|0.5em>\<less\><space|0.5em>><hlstd|m<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'a><hlopt|;<space|0.5em>..<space|0.5em>\<gtr\><space|0.5em>-\<gtr\><space|0.5em>><hlstd|'a><hlendline|Type
    poymorphic in two ways: <verbatim|'a> is the method
    type,><next-line><hlendline|<hlopt|..> means that objects with more
    methods will be accepted.>

    <\itemize>
      <item>Methods are computed when they are invoked, even if they do not
      take arguments.

      <item>We define objects inside <hlkwa|object>...<hlkwa|end> (compare:
      records <hlopt|{>...<hlopt|}>) using keywords <hlkwa|method> for
      methods, <hlkwa|val> for constant fields and <hlkwa|val mutable> for
      mutable fields. Constructor arguments can often be used instead of
      constant fields:

      <hlkwa|let<space|0.5em>><hlstd|square<space|0.5em>w<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|object><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|area<space|0.5em>><hlopt|=<space|0.5em>><hlstd|float<textunderscore>of<textunderscore>int<space|0.5em>><hlopt|(><hlstd|w<space|0.5em>><hlopt|*<space|0.5em>><hlstd|w><hlopt|)<space|0.5em>><hlkwa|method<space|0.5em>><hlstd|width<space|0.5em>><hlopt|=<space|0.5em>><hlstd|w<space|0.5em>><hlkwa|end><hlendline|>

      <item>Subtyping often needs to be explicit: we write <hlopt|(>object
      <hlopt|:\<gtr\>> supertype<hlopt|)> or in more complex cases
      <hlopt|(>object <hlopt|:> type <hlopt|:\<gtr\>> supertype<hlopt|)>.

      <\itemize>
        <item><small|Technically speaking, subtyping in OCaml always is
        explicit, and <em|open types>, containing <hlopt|..>, use <em|row
        polymorphism> rather than subtyping.>
      </itemize>
    </itemize>

    <hlkwa|let<space|0.5em>><hlstd|a<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|object<space|0.5em>method<space|0.5em>><hlstd|m<space|0.5em>><hlopt|=<space|0.5em>><hlnum|7><hlstd|<space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|x<space|0.5em>><hlopt|=<space|0.5em>><hlstr|"a"><hlstd|<space|0.5em>><hlkwa|end><hlendline|Toy
    example: object types><next-line><hlkwa|let<space|0.5em>><hlstd|b<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|object<space|0.5em>method<space|0.5em>><hlstd|m<space|0.5em>><hlopt|=<space|0.5em>><hlnum|42<space|0.5em>><hlkwa|method<space|0.5em>><hlstd|y<space|0.5em>><hlopt|=<space|0.5em>><hlstr|"b"><hlstd|<space|0.5em>><hlkwa|end><hlendline|share
    some but not all methods.><next-line><hlkwa|let<space|0.5em>><hlstd|l<space|0.5em>><hlopt|=<space|0.5em>[><hlstd|a><hlopt|;<space|0.5em>><hlstd|b><hlopt|]><hlendline|The
    exact types of the objects do not agree.><next-line><hlkwd|Error><hlopt|:<space|0.5em>><hlkwd|This<space|0.5em>><hlstd|expression<space|0.5em>has<space|0.5em>type<space|0.5em>><hlopt|\<less\><space|0.5em>><hlstd|m<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|int><hlopt|;<space|0.5em>><hlstd|y<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|string<space|0.5em>><hlopt|\<gtr\>><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>but<space|0.5em>an<space|0.5em>expression<space|0.5em>was<space|0.5em>expected<space|0.5em>of<space|0.5em>type<space|0.5em>><hlopt|\<less\><space|0.5em>><hlstd|m<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|int><hlopt|;<space|0.5em>><hlstd|x<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|string<space|0.5em>><hlopt|\<gtr\>><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwd|The<space|0.5em>><hlstd|second<space|0.5em>object<space|0.5em>type<space|0.5em>><hlstd|has<space|0.5em>no<space|0.5em>><hlstd|method<space|0.5em>y><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|l<space|0.5em>><hlopt|=<space|0.5em>[(><hlstd|a<space|0.5em>><hlopt|:\<gtr\><space|0.5em>\<less\>><hlstd|m<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'a><hlopt|\<gtr\>);<space|0.5em>(><hlstd|b<space|0.5em>><hlopt|:\<gtr\><space|0.5em>\<less\>><hlstd|m<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'a><hlopt|\<gtr\>)]><hlendline|But
    the types share a supertype.><next-line><hlkwa|val<space|0.5em>><hlstd|l<space|0.5em>><hlopt|:<space|0.5em>\<less\><space|0.5em>><hlstd|m<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|int<space|0.5em>><hlopt|\<gtr\><space|0.5em>><hlstd|list><hlendline|>

    <\itemize>
      <item><em|Variance> determines how type parameters behave wrt.
      subtyping:

      <\itemize>
        <item><em|Invariant parameters> cannot be subtyped:

        <hlkwa|let<space|0.5em>><hlstd|f<space|0.5em>x<space|0.5em>><hlopt|=<space|0.5em>(><hlstd|x<space|0.5em>><hlopt|:<space|0.5em>\<less\>><hlstd|m<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|int><hlopt|;<space|0.5em>><hlstd|n<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|float><hlopt|\<gtr\><space|0.5em>><hlstd|array<space|0.5em>><hlopt|:\<gtr\><space|0.5em>\<less\>><hlstd|m<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|int><hlopt|\<gtr\><space|0.5em>><hlstd|array><hlopt|)><hlendline|><next-line><hlkwd|Error><hlopt|:<space|0.5em>><hlkwd|Type<space|0.5em>><hlopt|\<less\><space|0.5em>><hlstd|m<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|int><hlopt|;<space|0.5em>><hlstd|n<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|float<space|0.5em>><hlopt|\<gtr\><space|0.5em>><hlstd|array<space|0.5em>is<space|0.5em>not<space|0.5em>a<space|0.5em>subtype<space|0.5em>><hlkwa|of><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|\<less\><space|0.5em>><hlstd|m<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|int<space|0.5em>><hlopt|\<gtr\><space|0.5em>><hlstd|array<space|0.5em><hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwd|The<space|0.5em>><hlstd|second<space|0.5em>><hlkwa|object<space|0.5em>type<space|0.5em>><hlstd|has<space|0.5em>no<space|0.5em>><hlkwa|method<space|0.5em>><hlstd|n><hlendline|>

        <item><em|Covariant parameters> are subtyped in the same direction as
        the type:

        <hlkwa|let<space|0.5em>><hlstd|f<space|0.5em>x<space|0.5em>><hlopt|=<space|0.5em>(><hlstd|x<space|0.5em>><hlopt|:<space|0.5em>\<less\>><hlstd|m<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|int><hlopt|;<space|0.5em>><hlstd|n<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|float><hlopt|\<gtr\><space|0.5em>><hlstd|list<space|0.5em>><hlopt|:\<gtr\><space|0.5em>\<less\>><hlstd|m<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|int><hlopt|\<gtr\><space|0.5em>><hlstd|list><hlopt|)><hlendline|><next-line><hlkwa|val<space|0.5em>><hlstd|f<space|0.5em>><hlopt|:<space|0.5em>\<less\><space|0.5em>><hlstd|m<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|int><hlopt|;<space|0.5em>><hlstd|n<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|float<space|0.5em>><hlopt|\<gtr\><space|0.5em>><hlstd|list<space|0.5em>><hlopt|-\<gtr\><space|0.5em>\<less\><space|0.5em>><hlstd|m<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|int<space|0.5em>><hlopt|\<gtr\><space|0.5em>><hlstd|list><hlendline|>

        <item><em|Contravariant parameters> are subtyped in the opposite
        direction:

        <small|<hlkwa|let<space|0.5em>><hlstd|f<space|0.5em>x<space|0.5em>><hlopt|=<space|0.5em>(><hlstd|x<space|0.5em>><hlopt|:<space|0.5em>\<less\>><hlstd|m<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|int><hlopt|;<space|0.5em>><hlstd|n<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|float><hlopt|\<gtr\><space|0.5em>-\<gtr\><space|0.5em>><hlkwb|float<space|0.5em>><hlopt|:\<gtr\><space|0.5em>\<less\>><hlstd|m<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|int><hlopt|\<gtr\><space|0.5em>-\<gtr\><space|0.5em>><hlkwb|float><hlopt|)><hlendline|><next-line><hlkwd|Error><hlopt|:<space|0.5em>><hlkwd|Type<space|0.5em>><hlopt|\<less\><space|0.5em>><hlstd|m<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|int><hlopt|;<space|0.5em>><hlstd|n<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|float<space|0.5em>><hlopt|\<gtr\><space|0.5em>-\<gtr\><space|0.5em>><hlkwb|float<space|0.5em>><hlstd|is<space|0.5em>not<space|0.5em>a<space|0.5em>subtype<space|0.5em>><hlkwa|of><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|\<less\><space|0.5em>><hlstd|m<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|int<space|0.5em>><hlopt|\<gtr\><space|0.5em>-\<gtr\><space|0.5em>><hlkwb|float<space|0.5em>><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwd|Type<space|0.5em>><hlopt|\<less\><space|0.5em>><hlstd|m<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|int<space|0.5em>><hlopt|\<gtr\><space|0.5em>><hlstd|is<space|0.5em>not<space|0.5em>a<space|0.5em>subtype<space|0.5em>><hlkwa|of<space|0.5em>><hlopt|\<less\><space|0.5em>><hlstd|m<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|int><hlopt|;<space|0.5em>><hlstd|n<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|float<space|0.5em>><hlopt|\<gtr\><space|0.5em>><next-line><hlkwa|let<space|0.5em>><hlstd|f<space|0.5em>x<space|0.5em>><hlopt|=<space|0.5em>(><hlstd|x<space|0.5em>><hlopt|:<space|0.5em>\<less\>><hlstd|m<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|int><hlopt|\<gtr\><space|0.5em>-\<gtr\><space|0.5em>><hlkwb|float<space|0.5em>><hlopt|:\<gtr\><space|0.5em>\<less\>><hlstd|m<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|int><hlopt|;<space|0.5em>><hlstd|n<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|float><hlopt|\<gtr\><space|0.5em>-\<gtr\><space|0.5em>><hlkwb|float><hlopt|)><hlendline|><next-line><hlkwa|val<space|0.5em>><hlstd|f<space|0.5em>><hlopt|:<space|0.5em>(\<less\><space|0.5em>><hlstd|m<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|int<space|0.5em>><hlopt|\<gtr\><space|0.5em>-\<gtr\><space|0.5em>><hlkwb|float><hlopt|)<space|0.5em>-\<gtr\><space|0.5em>\<less\><space|0.5em>><hlstd|m<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|int><hlopt|;<space|0.5em>><hlstd|n<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|float<space|0.5em>><hlopt|\<gtr\><space|0.5em>-\<gtr\><space|0.5em>><hlkwb|float><hlendline|>>
      </itemize>
    </itemize>
  </hidden>|<\hidden>
    <tit|Object Oriented Programming: Inheritance>

    <\itemize>
      <item>The system of object classes in OCaml is similar to the module
      system.

      <\itemize>
        <item>Object classes are not types. Classes are a way to build object
        <em|constructors> -- functions that return objects.

        <item>Classes have their types (compare: modules and signatures).
      </itemize>

      <item>In OCaml parlance:

      <\itemize>
        <item>late binding is not called anything -- all methods are
        late-bound (in C++ called virtual)

        <item>a method or field declared to be defined in sub-classes is
        <em|virtual> (in C++ called abstract); classes that use virtual
        methods or fields are also called virtual

        <item>a method that is only visible in sub-classes is <em|private>
        (in C++ called protected)

        <item>a method not visible outside the class is not called anything
        (in C++ called private) -- provide the type for the class, and omit
        the method in the class type (compare: module signatures and
        <verbatim|.mli> files)
      </itemize>

      <item>OCaml allows multiple inheritance, which can be used to implement
      <em|mixins> as virtual / abstract classes.

      <item>Inheritance works somewhat similarly to textual inclusion.

      <item>See the excellent examples in
      <hlink|https://realworldocaml.org/v1/en/html/classes.html|https://realworldocaml.org/v1/en/html/classes.html>

      <item>You can perform <verbatim|ocamlc -i Objects.ml> etc. to see
      inferred object and class types.
    </itemize>

    \;
  </hidden>|<\hidden>
    <tit|OOP Non-solution: direct approach>

    <\itemize>
      <item>It turns out that although object oriented programming was
      designed with data extensibility in mind, it is a bad fit for recursive
      types, like in the expression problem. Below is my attempt at solving
      our problem using classes -- can you do better?

      <item>Non-solution penalty points:

      <\itemize>
        <item>Functions implemented for a broader language (e.g.
        corresponding to <verbatim|lexpr_t> on other slides) cannot handle
        values from a narrower one (e.g. corresponding to <verbatim|expr_t>).

        <item>Writing a new function requires extending the language.

        <item>No deep pattern matching.
      </itemize>

      Verdict: non-solution, better only than the extensible variant
      types-based approach.
    </itemize>

    <small|<hlkwa|type<space|0.5em>><hlstd|var<textunderscore>name<space|0.5em>><hlopt|=<space|0.5em>><hlkwb|string><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|gensym<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|let<space|0.5em>><hlstd|n<space|0.5em>><hlopt|=<space|0.5em>><hlkwb|ref<space|0.5em>><hlnum|0<space|0.5em>><hlkwa|in<space|0.5em>fun<space|0.5em>><hlopt|()<space|0.5em>-\<gtr\><space|0.5em>><hlstd|incr<space|0.5em>n><hlopt|;<space|0.5em>><hlstr|"<textunderscore>"><hlstd|<space|0.5em><hlcircum><space|0.5em>string<textunderscore>of<textunderscore>int<space|0.5em>><hlopt|!><hlstd|n><hlendline|><next-line><hlendline|><next-line><hlkwa|class<space|0.5em>virtual<space|0.5em>><hlopt|[><hlstd|'lang><hlopt|]<space|0.5em>><hlstd|evaluable<space|0.5em>><hlopt|=><hlendline|The
    abstract class for objects supporting the <verbatim|eval>
    method.><next-line><hlkwa|object<space|0.5em>><hlendline|For
    <math|\<lambda\>>-calculus, we need helper
    functions:><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>virtual<space|0.5em>><hlstd|eval<space|0.5em>><hlopt|:<space|0.5em>(><hlstd|var<textunderscore>name<space|0.5em>><hlopt|*<space|0.5em>><hlstd|'lang><hlopt|)<space|0.5em>><hlstd|list<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|'lang<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>virtual<space|0.5em>><hlstd|rename<space|0.5em>><hlopt|:<space|0.5em>><hlstd|var<textunderscore>name<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|var<textunderscore>name<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><verbatim|'lang><hlendline|renaming
    of free variables,><next-line><space|0.5em><space|0.5em><hlkwa|method<space|0.5em>><hlstd|apply<space|0.5em>><hlopt|(><hlstd|<textunderscore>arg<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'lang><hlopt|)><hlendline|<math|\<beta\>>-reduction
    if possible (fallback otherwise).><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|(><hlstd|fallback<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|unit<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|'lang><hlopt|)<space|0.5em>(><hlstd|<textunderscore>subst<space|0.5em>><hlopt|:<space|0.5em>(><hlstd|var<textunderscore>name<space|0.5em>><hlopt|*<space|0.5em>><hlstd|'lang><hlopt|)<space|0.5em>><hlstd|list><hlopt|)<space|0.5em>=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>fallback<space|0.5em>><hlopt|()><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlendline|><next-line><hlkwa|class<space|0.5em>><hlopt|[><hlstd|'lang><hlopt|]<space|0.5em>><hlstd|var<space|0.5em>><hlopt|(><hlstd|v<space|0.5em>><hlopt|:<space|0.5em>><hlstd|var<textunderscore>name><hlopt|)<space|0.5em>=><hlendline|><next-line><hlkwa|object<space|0.5em>><hlopt|(><hlstd|self><hlopt|)><hlendline|We
    name the current object <verbatim|self>.><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|inherit<space|0.5em>><hlopt|[><hlstd|'lang><hlopt|]<space|0.5em>><hlstd|evaluable<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|val<space|0.5em>><hlstd|v<space|0.5em>><hlopt|=<space|0.5em>><hlstd|v<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|eval<space|0.5em>subst<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|try<space|0.5em>><hlkwc|List><hlopt|.><hlstd|assoc<space|0.5em>v<space|0.5em>subst<space|0.5em>><hlkwa|with<space|0.5em>><hlkwd|Not<textunderscore>found<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|self<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|rename<space|0.5em>v1<space|0.5em>v2<space|0.5em>><hlopt|=><hlendline|Renaming
    a variable:><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|if<space|0.5em>><hlstd|v<space|0.5em>><hlopt|=<space|0.5em>><hlstd|v1<space|0.5em>><hlkwa|then<space|0.5em>><hlopt|{\<less\><space|0.5em>><hlstd|v<space|0.5em>><hlopt|=<space|0.5em>><hlstd|v2<space|0.5em>><hlopt|\<gtr\>}<space|0.5em>><hlkwa|else<space|0.5em>><hlstd|self><hlendline|we
    clone the current object putting the new
    name.><next-line><hlkwa|end><hlendline|><next-line><hlendline|><next-line><hlkwa|class<space|0.5em>><hlopt|[><hlstd|'lang><hlopt|]<space|0.5em>><hlstd|abs<space|0.5em>><hlopt|(><hlstd|v<space|0.5em>><hlopt|:<space|0.5em>><hlstd|var<textunderscore>name><hlopt|)<space|0.5em>(><hlstd|body<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'lang><hlopt|)<space|0.5em>=><hlendline|><next-line><hlkwa|object<space|0.5em>><hlopt|(><hlstd|self><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|inherit<space|0.5em>><hlopt|[><hlstd|'lang><hlopt|]<space|0.5em>><hlstd|evaluable<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|val<space|0.5em>><hlstd|v<space|0.5em>><hlopt|=<space|0.5em>><hlstd|v<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|val<space|0.5em>><hlstd|body<space|0.5em>><hlopt|=<space|0.5em>><hlstd|body<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|eval<space|0.5em>subst<space|0.5em>><hlopt|=><hlendline|We
    do <math|\<alpha\>>-conversion prior to
    evaluation.><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|v'<space|0.5em>><hlopt|=<space|0.5em>><hlstd|gensym<space|0.5em>><hlopt|()<space|0.5em>><hlkwa|in><hlendline|Alternatively,
    we could evaluate with><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|{\<less\><space|0.5em>><hlstd|v<space|0.5em>><hlopt|=<space|0.5em>><hlstd|v'><hlopt|;<space|0.5em>><hlstd|body<space|0.5em>><hlopt|=<space|0.5em>(><hlstd|body><hlopt|#><hlstd|rename<space|0.5em>v<space|0.5em>v'><hlopt|)#><hlstd|eval<space|0.5em>subst<space|0.5em>><hlopt|\<gtr\>}><hlendline|substitution
    of <verbatim|v>><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|rename<space|0.5em>v1<space|0.5em>v2<space|0.5em>><hlopt|=><hlendline|by
    <verbatim|v_inst v' : 'lang> similar to <verbatim|num_inst>
    below.><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|if<space|0.5em>><hlstd|v<space|0.5em>><hlopt|=<space|0.5em>><hlstd|v1<space|0.5em>><hlkwa|then<space|0.5em>><verbatim|self><hlendline|Renaming
    the free variable <verbatim|v1>, so no work if
    <verbatim|v=v1>.><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlkwa|else<space|0.5em>><hlopt|{\<less\><space|0.5em>><hlstd|body<space|0.5em>><hlopt|=<space|0.5em>><hlstd|body><hlopt|#><hlstd|rename<space|0.5em>v1<space|0.5em>v2<space|0.5em>><hlopt|\<gtr\>}><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|apply<space|0.5em>arg<hlunderscore>subst<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>body><hlopt|#><hlstd|eval<space|0.5em>><hlopt|((><hlstd|v><hlopt|,<space|0.5em>><hlstd|arg><hlopt|)::><hlstd|subst><hlopt|)><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlendline|><next-line><hlkwa|class<space|0.5em>><hlopt|[><hlstd|'lang><hlopt|]<space|0.5em>><hlstd|app<space|0.5em>><hlopt|(><hlstd|f<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'lang><hlopt|)<space|0.5em>(><hlstd|arg<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'lang><hlopt|)<space|0.5em>=><hlendline|><next-line><hlkwa|object<space|0.5em>><hlopt|(><hlstd|self><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|inherit<space|0.5em>><hlopt|[><hlstd|'lang><hlopt|]<space|0.5em>><hlstd|evaluable<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|val<space|0.5em>><hlstd|f<space|0.5em>><hlopt|=<space|0.5em>><hlstd|f<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|val<space|0.5em>><hlstd|arg<space|0.5em>><hlopt|=<space|0.5em>><hlstd|arg<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|eval<space|0.5em>subst<space|0.5em>><hlopt|=><hlendline|We
    use <verbatim|apply> to differentiate between <verbatim|f <math|=>
    abs>><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|arg'<space|0.5em>><hlopt|=<space|0.5em>><hlstd|arg><hlopt|#><hlstd|eval<space|0.5em>subst<space|0.5em>><hlkwa|in><hlendline|
    (<math|\<beta\>>-redexes) and <verbatim|f <math|\<neq\>>
    abs>.><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>f><hlopt|#><hlstd|apply<space|0.5em>arg'<space|0.5em>><hlopt|(><hlkwa|fun<space|0.5em>><hlopt|()<space|0.5em>-\<gtr\><space|0.5em>{\<less\><space|0.5em>><hlstd|f<space|0.5em>><hlopt|=<space|0.5em>><hlstd|f><hlopt|#><hlstd|eval<space|0.5em>subst><hlopt|;<space|0.5em>><hlstd|arg<space|0.5em>><hlopt|=<space|0.5em>><hlstd|arg'<space|0.5em>><hlopt|\<gtr\>})<space|0.5em>><hlstd|subst<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|rename<space|0.5em>v1<space|0.5em>v2<space|0.5em>><hlopt|=><hlendline|Cloning
    the object ensures that it will be a subtype of
    <verbatim|'lang>><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|{\<less\><space|0.5em>><hlstd|f<space|0.5em>><hlopt|=<space|0.5em>><hlstd|f><hlopt|#><hlstd|rename<space|0.5em>v1<space|0.5em>v2><hlopt|;<space|0.5em>><hlstd|arg<space|0.5em>><hlopt|=<space|0.5em>><hlstd|arg><hlopt|#><hlstd|rename<space|0.5em>v1<space|0.5em>v2<space|0.5em>><hlopt|\<gtr\>}><hlendline|rather
    than just <verbatim|'lang app>.><next-line><hlkwa|end><hlendline|><next-line><hlendline|><next-line><hlkwa|type<space|0.5em>><hlstd|evaluable<textunderscore>t<space|0.5em>><hlopt|=<space|0.5em>><hlstd|evaluable<textunderscore>t<space|0.5em>evaluable><hlendline|These
    definitions only add nice-looking types.><next-line><hlkwa|let<space|0.5em>><hlstd|new<textunderscore>var1<space|0.5em>v<space|0.5em>><hlopt|:<space|0.5em>><hlstd|evaluable<textunderscore>t<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|new<space|0.5em>><hlstd|var<space|0.5em>v><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|new<textunderscore>abs1<space|0.5em>v<space|0.5em>><hlopt|(><hlstd|body<space|0.5em>><hlopt|:<space|0.5em>><hlstd|evaluable<textunderscore>t><hlopt|)<space|0.5em>:<space|0.5em>><hlstd|evaluable<textunderscore>t<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|new<space|0.5em>><hlstd|abs<space|0.5em>v<space|0.5em>body><hlendline|><next-line><hlendline|><next-line><hlkwa|class<space|0.5em>virtual<space|0.5em>><hlstd|compute<textunderscore>mixin<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|object><hlendline|For
    evaluating arithmetic expressions we need><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|compute<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|int<space|0.5em>option<space|0.5em>><hlopt|=<space|0.5em>><hlkwd|None><hlstd|<space|0.5em><space|0.5em>><hlendline|a
    heper method <verbatim|compute>.><next-line><hlkwa|end><hlendline|><next-line><hlkwa|class<space|0.5em>><hlopt|[><hlstd|'lang><hlopt|]<space|0.5em>><hlstd|var<textunderscore>c<space|0.5em>v<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|object><hlendline|To
    use <math|\<lambda\>>-expressions together with arithmetic
    expressions><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|inherit<space|0.5em>><hlopt|[><hlstd|'lang><hlopt|]<space|0.5em>><verbatim|var<space|0.5em>v><hlendline|we
    need to upgrade them with the helper method.><next-line><space|0.5em><space|0.5em><hlkwa|inherit<space|0.5em>><hlstd|compute<textunderscore>mixin><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlkwa|class<space|0.5em>><hlopt|[><hlstd|'lang><hlopt|]<space|0.5em>><hlstd|abs<textunderscore>c<space|0.5em>v<space|0.5em>body<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|object><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|inherit<space|0.5em>><hlopt|[><hlstd|'lang><hlopt|]<space|0.5em>><hlstd|abs<space|0.5em>v<space|0.5em>body<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|inherit<space|0.5em>><hlstd|compute<textunderscore>mixin><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlkwa|class<space|0.5em>><hlopt|[><hlstd|'lang><hlopt|]<space|0.5em>><hlstd|app<textunderscore>c<space|0.5em>f<space|0.5em>arg<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|object><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|inherit<space|0.5em>><hlopt|[><hlstd|'lang><hlopt|]<space|0.5em>><hlstd|app<space|0.5em>f<space|0.5em>arg<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|inherit<space|0.5em>><hlstd|compute<textunderscore>mixin><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlendline|><next-line><hlkwa|class<space|0.5em>><hlopt|[><hlstd|'lang><hlopt|]<space|0.5em>><hlstd|num<space|0.5em>><hlopt|(><hlstd|i<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|int><hlopt|)<space|0.5em>=><hlendline|A
    numerical constant.><next-line><hlkwa|object<space|0.5em>><hlopt|(><hlstd|self><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|inherit<space|0.5em>><hlopt|[><hlstd|'lang><hlopt|]<space|0.5em>><hlstd|evaluable<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|val<space|0.5em>><hlstd|i<space|0.5em>><hlopt|=<space|0.5em>><hlstd|i<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|eval<space|0.5em><textunderscore>subst<space|0.5em>><hlopt|=<space|0.5em>><hlstd|self<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|rename<hlunderscore><textunderscore><space|0.5em>><hlopt|=<space|0.5em>><hlstd|self<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|compute<space|0.5em>><hlopt|=<space|0.5em>><hlkwd|Some<space|0.5em>><hlstd|i><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlendline|><next-line><hlkwa|class<space|0.5em>virtual<space|0.5em>><hlopt|[><hlstd|'lang><hlopt|]<space|0.5em>><verbatim|operation><hlendline|Abstract
    class for evaluating arithmetic operations.><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlopt|(><hlstd|num<textunderscore>inst<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|int<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|'lang><hlopt|)<space|0.5em>(><hlstd|n1<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'lang><hlopt|)<space|0.5em>(><hlstd|n2<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'lang><hlopt|)<space|0.5em>=><hlendline|><next-line><hlkwa|object<space|0.5em>><hlopt|(><hlstd|self><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|inherit<space|0.5em>><hlopt|[><hlstd|'lang><hlopt|]<space|0.5em>><hlstd|evaluable<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|val<space|0.5em>><hlstd|n1<space|0.5em>><hlopt|=<space|0.5em>><hlstd|n1<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|val<space|0.5em>><hlstd|n2<space|0.5em>><hlopt|=<space|0.5em>><hlstd|n2<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|eval<space|0.5em>subst<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|self'<space|0.5em>><hlopt|=<space|0.5em>{\<less\><space|0.5em>><hlstd|n1<space|0.5em>><hlopt|=<space|0.5em>><hlstd|n1><hlopt|#><hlstd|eval<space|0.5em>subst><hlopt|;<space|0.5em>><hlstd|n2<space|0.5em>><hlopt|=<space|0.5em>><hlstd|n2><hlopt|#><hlstd|eval<space|0.5em>subst<space|0.5em>><hlopt|\<gtr\>}<space|0.5em>><hlkwa|in><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|match<space|0.5em>><hlstd|self'><hlopt|#><hlstd|compute<space|0.5em>><hlkwa|with><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|Some<space|0.5em>><hlstd|i<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><verbatim|num<textunderscore>inst<space|0.5em>i><hlendline|We
    need to inject the integer as a constant that
    is><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><hlunderscore><hlopt|-\<gtr\><space|0.5em>><verbatim|self'><hlendline|a
    subtype of <verbatim|'lang>.><next-line><space|0.5em><space|0.5em><hlkwa|method<space|0.5em>><hlstd|rename<space|0.5em>v1<space|0.5em>v2<space|0.5em>><hlopt|=<space|0.5em>{\<less\><space|0.5em>><hlstd|n1<space|0.5em>><hlopt|=<space|0.5em>><hlstd|n1><hlopt|#><hlstd|rename<space|0.5em>v1<space|0.5em>v2><hlopt|;<space|0.5em>><hlstd|n2<space|0.5em>><hlopt|=<space|0.5em>><hlstd|n2><hlopt|#><hlstd|rename<space|0.5em>v1<space|0.5em>v2<space|0.5em>><hlopt|\<gtr\>}><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlendline|><next-line><hlkwa|class<space|0.5em>><hlopt|[><hlstd|'lang><hlopt|]<space|0.5em>><hlstd|add<space|0.5em>num<textunderscore>inst<space|0.5em>n1<space|0.5em>n2<space|0.5em>><hlopt|=><hlendline|><next-line><hlkwa|object<space|0.5em>><hlopt|(><hlstd|self><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|inherit<space|0.5em>><hlopt|[><hlstd|'lang><hlopt|]<space|0.5em>><hlstd|operation<space|0.5em>num<textunderscore>inst<space|0.5em>n1<space|0.5em>n2<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|compute<space|0.5em>><hlopt|=><hlendline|If
    <verbatim|compute> is called by <verbatim|eval>, as
    intended,><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|match<space|0.5em>><hlstd|n1><hlopt|#><hlstd|compute><hlopt|,<space|0.5em>><hlstd|n2><hlopt|#><hlstd|compute<space|0.5em>><hlkwa|with><hlendline|then
    <verbatim|n1> and <verbatim|n2> are already
    computed.><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|Some<space|0.5em>><hlstd|i1><hlopt|,<space|0.5em>><hlkwd|Some<space|0.5em>><hlstd|i2<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwd|Some<space|0.5em>><hlopt|(><hlstd|i1<space|0.5em>><hlopt|+<space|0.5em>><hlstd|i2><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><hlunderscore>><hlopt|-\<gtr\><space|0.5em>><hlkwd|None><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlendline|><next-line><hlkwa|class<space|0.5em>><hlopt|[><hlstd|'lang><hlopt|]<space|0.5em>><hlstd|mult<space|0.5em>num<textunderscore>inst<space|0.5em>n1<space|0.5em>n2<space|0.5em>><hlopt|=><hlendline|><next-line><hlkwa|object<space|0.5em>><hlopt|(><hlstd|self><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|inherit<space|0.5em>><hlopt|[><hlstd|'lang><hlopt|]<space|0.5em>><hlstd|operation<space|0.5em>num<textunderscore>inst<space|0.5em>n1<space|0.5em>n2<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|compute<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|match<space|0.5em>><hlstd|n1><hlopt|#><hlstd|compute><hlopt|,<space|0.5em>><hlstd|n2><hlopt|#><hlstd|compute<space|0.5em>><hlkwa|with><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|Some<space|0.5em>><hlstd|i1><hlopt|,<space|0.5em>><hlkwd|Some<space|0.5em>><hlstd|i2<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwd|Some<space|0.5em>><hlopt|(><hlstd|i1<space|0.5em>><hlopt|*<space|0.5em>><hlstd|i2><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><hlunderscore>><hlopt|-\<gtr\><space|0.5em>><hlkwd|None><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlendline|><next-line><hlkwa|class<space|0.5em>virtual<space|0.5em>><hlopt|[><hlstd|'lang><hlopt|]<space|0.5em>><hlstd|computable<space|0.5em>><hlopt|=><hlendline|This
    class is defined merely to provide an object
    type,><next-line><hlkwa|object><hlendline|we could also define this
    object type ``by hand''.><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|inherit<space|0.5em>><hlopt|[><hlstd|'lang><hlopt|]<space|0.5em>><hlstd|evaluable<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|inherit<space|0.5em>><hlstd|compute<textunderscore>mixin><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlendline|><next-line><hlkwa|type<space|0.5em>><hlstd|computable<textunderscore>t<space|0.5em>><hlopt|=<space|0.5em>><hlstd|computable<textunderscore>t<space|0.5em>computable><hlendline|Nice
    types for all the constructors.><next-line><hlkwa|let<space|0.5em>><hlstd|new<textunderscore>var2<space|0.5em>v<space|0.5em>><hlopt|:<space|0.5em>><hlstd|computable<textunderscore>t<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|new<space|0.5em>><hlstd|var<textunderscore>c<space|0.5em>v><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|new<textunderscore>abs2<space|0.5em>v<space|0.5em>><hlopt|(><hlstd|body<space|0.5em>><hlopt|:<space|0.5em>><hlstd|computable<textunderscore>t><hlopt|)<space|0.5em>:<space|0.5em>><hlstd|computable<textunderscore>t<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|new<space|0.5em>><hlstd|abs<textunderscore>c<space|0.5em>v<space|0.5em>body><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|new<textunderscore>app2<space|0.5em>v<space|0.5em>><hlopt|(><hlstd|body<space|0.5em>><hlopt|:<space|0.5em>><hlstd|computable<textunderscore>t><hlopt|)<space|0.5em>:<space|0.5em>><hlstd|computable<textunderscore>t<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|new<space|0.5em>><hlstd|app<textunderscore>c<space|0.5em>v<space|0.5em>body><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|new<textunderscore>num2<space|0.5em>i<space|0.5em>><hlopt|:<space|0.5em>><hlstd|computable<textunderscore>t<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|new<space|0.5em>><hlstd|num<space|0.5em>i><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|new<textunderscore>add2<space|0.5em>><hlopt|(><hlstd|n1<space|0.5em>><hlopt|:<space|0.5em>><hlstd|computable<textunderscore>t><hlopt|)<space|0.5em>(><hlstd|n2<space|0.5em>><hlopt|:<space|0.5em>><hlstd|computable<textunderscore>t><hlopt|)<space|0.5em>:<space|0.5em>><hlstd|computable<textunderscore>t<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|new<space|0.5em>><hlstd|add<space|0.5em>new<textunderscore>num2<space|0.5em>n1<space|0.5em>n2><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|new<textunderscore>mult2<space|0.5em>><hlopt|(><hlstd|n1<space|0.5em>><hlopt|:<space|0.5em>><hlstd|computable<textunderscore>t><hlopt|)<space|0.5em>(><hlstd|n2<space|0.5em>><hlopt|:<space|0.5em>><hlstd|computable<textunderscore>t><hlopt|)<space|0.5em>:<space|0.5em>><hlstd|computable<textunderscore>t<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|new<space|0.5em>><hlstd|mult<space|0.5em>new<textunderscore>num2<space|0.5em>n1<space|0.5em>n2><hlendline|>>
  </hidden>|<\hidden>
    <tit|OOP: The Visitor Pattern>

    <\itemize>
      <item>The <em|Visitor Pattern> is an object-oriented programming
      pattern for turning objects into variants with shallow pattern-matching
      (i.e. dispatch based on which variant a value is). It replaces data
      extensibility by operation extensibility.

      <item>I needed to use imperative features (mutable fields), can you do
      better?

      <item>Penalty points:

      <\itemize>
        <item>Heavy code bloat.

        <item>Side-effects appear to be required.

        <item>No deep pattern matching.
      </itemize>

      Verdict: poor solution, better than approaches we considered so far,
      and worse than approaches we consider next.
    </itemize>

    <small|<hlkwa|type<space|0.5em>><hlstd|'visitor<space|0.5em>visitable<space|0.5em>><hlopt|=<space|0.5em>\<less\><space|0.5em>><hlstd|accept<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'visitor<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwb|unit<space|0.5em>><hlopt|\<gtr\>><hlendline|The
    variants need be visitable.><next-line><hlendline|We store the
    computation as side effect because of the
    difficulty><next-line><hlkwa|type<space|0.5em>><hlstd|var<textunderscore>name<space|0.5em>><hlopt|=<space|0.5em>><hlkwb|string><hlendline|to
    keep the visitor polymorphic but have the result
    type><next-line><hlendline|depend on the
    visitor.><next-line><hlkwa|class<space|0.5em>><hlopt|[><hlstd|'visitor><hlopt|]<space|0.5em>><hlstd|var<space|0.5em>><hlopt|(><hlstd|v<space|0.5em>><hlopt|:<space|0.5em>><hlstd|var<textunderscore>name><hlopt|)<space|0.5em>=><hlendline|The
    <verbatim|'visitor> will determine the
    (sub)language><next-line><hlkwa|object<space|0.5em>><hlopt|(><hlstd|self><hlopt|)><hlendline|to
    which a given <verbatim|var> variant belongs.><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|v<space|0.5em>><hlopt|=<space|0.5em>><hlstd|v<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|accept<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'visitor<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwb|unit<space|0.5em>><hlopt|=><hlendline|The
    visitor pattern inverts the way><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|fun<space|0.5em>><hlstd|visitor<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|visitor><hlopt|#><hlstd|visitVar<space|0.5em>self><hlendline|pattern
    matching proceeds: the variant><next-line><hlkwa|end><hlendline|selects
    the pattern matching branch.><next-line><hlkwa|let<space|0.5em>><hlstd|new<textunderscore>var<space|0.5em>v<space|0.5em>><hlopt|=<space|0.5em>(><hlkwa|new<space|0.5em>><hlstd|var<space|0.5em>v<space|0.5em>><hlopt|:\<gtr\><space|0.5em>><hlstd|'a<space|0.5em>visitable><hlopt|)><hlendline|Visitors
    need to see the stored data,><next-line><hlendline|but distinct
    constructors need to belong to the same
    type.><next-line><hlkwa|class<space|0.5em>><hlopt|[><hlstd|'visitor><hlopt|]<space|0.5em>><hlstd|abs<space|0.5em>><hlopt|(><hlstd|v<space|0.5em>><hlopt|:<space|0.5em>><hlstd|var<textunderscore>name><hlopt|)<space|0.5em>(><hlstd|body<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'visitor<space|0.5em>visitable><hlopt|)<space|0.5em>=><hlendline|><next-line><hlkwa|object<space|0.5em>><hlopt|(><hlstd|self><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|v<space|0.5em>><hlopt|=<space|0.5em>><hlstd|v<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|body<space|0.5em>><hlopt|=<space|0.5em>><hlstd|body<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|accept<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'visitor<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwb|unit<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|fun<space|0.5em>><hlstd|visitor<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|visitor><hlopt|#><hlstd|visitAbs<space|0.5em>self><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|new<textunderscore>abs<space|0.5em>v<space|0.5em>body<space|0.5em>><hlopt|=<space|0.5em>(><hlkwa|new<space|0.5em>><hlstd|abs<space|0.5em>v<space|0.5em>body<space|0.5em>><hlopt|:\<gtr\><space|0.5em>><hlstd|'a<space|0.5em>visitable><hlopt|)><hlendline|><next-line><hlendline|><next-line><hlkwa|class<space|0.5em>><hlopt|[><hlstd|'visitor><hlopt|]<space|0.5em>><hlstd|app<space|0.5em>><hlopt|(><hlstd|f<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'visitor<space|0.5em>visitable><hlopt|)<space|0.5em>(><hlstd|arg<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'visitor<space|0.5em>visitable><hlopt|)<space|0.5em>=><hlendline|><next-line><hlkwa|object<space|0.5em>><hlopt|(><hlstd|self><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|f<space|0.5em>><hlopt|=<space|0.5em>><hlstd|f<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|arg<space|0.5em>><hlopt|=<space|0.5em>><hlstd|arg<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|accept<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'visitor<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwb|unit<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|fun<space|0.5em>><hlstd|visitor<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|visitor><hlopt|#><hlstd|visitApp<space|0.5em>self><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|new<textunderscore>app<space|0.5em>f<space|0.5em>arg<space|0.5em>><hlopt|=<space|0.5em>(><hlkwa|new<space|0.5em>><hlstd|app<space|0.5em>f<space|0.5em>arg<space|0.5em>><hlopt|:\<gtr\><space|0.5em>><hlstd|'a<space|0.5em>visitable><hlopt|)><hlendline|><next-line><hlendline|><next-line><hlkwa|class<space|0.5em>virtual<space|0.5em>><hlopt|[><hlstd|'visitor><hlopt|]<space|0.5em>><hlstd|lambda<textunderscore>visit<space|0.5em>><hlopt|=><hlendline|This
    abstract class has two uses:><next-line><hlkwa|object><hlendline|it
    defines the visitors for the sub-langauge of
    <math|\<lambda\>>-expressions,><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>virtual<space|0.5em>><hlstd|visitVar<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'visitor<space|0.5em>var<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwb|unit><hlendline|and
    it will provide an early check><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>virtual<space|0.5em>><hlstd|visitAbs<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'visitor<space|0.5em>abs<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwb|unit><hlendline|that
    the visitor classes><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>virtual<space|0.5em>><hlstd|visitApp<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'visitor<space|0.5em>app<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwb|unit><hlendline|implement
    all the methods.><next-line><hlkwa|end><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|gensym<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|let<space|0.5em>><hlstd|n<space|0.5em>><hlopt|=<space|0.5em>><hlkwb|ref<space|0.5em>><hlnum|0<space|0.5em>><hlkwa|in<space|0.5em>fun<space|0.5em>><hlopt|()<space|0.5em>-\<gtr\><space|0.5em>><hlstd|incr<space|0.5em>n><hlopt|;<space|0.5em>><hlstr|"<textunderscore>"><hlstd|<space|0.5em><hlcircum><space|0.5em>string<textunderscore>of<textunderscore>int<space|0.5em>><hlopt|!><hlstd|n><hlendline|><next-line><hlendline|><next-line><hlkwa|class<space|0.5em>><hlopt|[><hlstd|'visitor><hlopt|]<space|0.5em>><verbatim|eval<textunderscore>lambda><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlopt|(><hlstd|subst<space|0.5em>><hlopt|:<space|0.5em>(><hlstd|var<textunderscore>name<space|0.5em>><hlopt|*<space|0.5em>><hlstd|'visitor<space|0.5em>visitable><hlopt|)<space|0.5em>><hlstd|list><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlopt|(><hlstd|result<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'visitor<space|0.5em>visitable<space|0.5em>><hlkwb|ref><hlopt|)<space|0.5em>=><hlendline|An
    output argument, but also used internally><next-line><hlkwa|object<space|0.5em>><hlopt|(><hlstd|self><hlopt|)><hlendline|to
    store intermediate results.><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|inherit<space|0.5em>><hlopt|[><hlstd|'visitor><hlopt|]<space|0.5em>><hlstd|lambda<textunderscore>visit<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|val<space|0.5em>mutable<space|0.5em>><hlstd|subst<space|0.5em>><hlopt|=<space|0.5em>><verbatim|subst><hlendline|We
    avoid threading the argument through the visit
    methods.><next-line><space|0.5em><space|0.5em><hlkwa|val<space|0.5em>mutable<space|0.5em>><hlstd|beta<textunderscore>redex<space|0.5em>><hlopt|:<space|0.5em>(><hlstd|var<textunderscore>name<space|0.5em>><hlopt|*<space|0.5em>><hlstd|'visitor<space|0.5em>visitable><hlopt|)<space|0.5em>><hlkwb|option<space|0.5em>><hlopt|=<space|0.5em>><hlkwd|None><hlendline|We
    work around><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|visitVar<space|0.5em>var<space|0.5em>><hlopt|=><hlendline|the
    need to differentiate between <verbatim|abs> and non-<verbatim|abs>
    values><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>beta<textunderscore>redex<space|0.5em>><hlopt|\<less\>-<space|0.5em>><hlkwd|None><hlopt|;><hlendline|of
    <hlstd|app><hlopt|#><hlstd|f> inside <verbatim|visitApp>.><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|try<space|0.5em>><hlstd|result<space|0.5em>><hlopt|:=<space|0.5em>><hlkwc|List><hlopt|.><hlstd|assoc<space|0.5em>var><hlopt|#><hlstd|v<space|0.5em>subst<hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|with<space|0.5em>><hlkwd|Not<textunderscore>found<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|result<space|0.5em>><hlopt|:=<space|0.5em>(><hlstd|var<space|0.5em>><hlopt|:\<gtr\><space|0.5em>><hlstd|'visitor<space|0.5em>visitable><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|visitAbs<space|0.5em>abs<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|v'<space|0.5em>><hlopt|=<space|0.5em>><hlstd|gensym<space|0.5em>><hlopt|()<space|0.5em>><hlkwa|in><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|orig<textunderscore>subst<space|0.5em>><hlopt|=<space|0.5em>><hlstd|subst<space|0.5em>><hlkwa|in><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>subst<space|0.5em>><hlopt|\<less\>-<space|0.5em>(><hlstd|abs><hlopt|#><hlstd|v><hlopt|,<space|0.5em>><hlstd|new_var<space|0.5em>v'><hlopt|)::><hlstd|subst><hlopt|;><hlendline|``Pass''
    the updated substitution><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|(><hlstd|abs><hlopt|#><hlstd|body><hlopt|)#><hlstd|accept<space|0.5em>self><hlopt|;><hlendline|to
    the recursive call><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|body'<space|0.5em>><hlopt|=<space|0.5em>!><hlstd|result<space|0.5em>><hlkwa|in><hlendline|and
    collect the result of the recursive call.><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>subst<space|0.5em>><hlopt|\<less\>-<space|0.5em>><hlstd|orig<textunderscore>subst><hlopt|;><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>beta<textunderscore>redex<space|0.5em>><hlopt|\<less\>-<space|0.5em>><hlkwd|Some<space|0.5em>><hlopt|(><hlstd|v'><hlopt|,<space|0.5em>><hlstd|body'><hlopt|);><hlendline|Indicate
    that an <verbatim|abs> has just been visited.><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>result<space|0.5em>><hlopt|:=<space|0.5em>><hlstd|new<textunderscore>abs<space|0.5em>v'<space|0.5em>body'<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|visitApp<space|0.5em>app<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>app><hlopt|#><hlstd|arg><hlopt|#><hlstd|accept<space|0.5em>self><hlopt|;><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|arg'<space|0.5em>><hlopt|=<space|0.5em>!><hlstd|result<space|0.5em>><hlkwa|in><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>app><hlopt|#><hlstd|f><hlopt|#><hlstd|accept<space|0.5em>self><hlopt|;><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|f'<space|0.5em>><hlopt|=<space|0.5em>!><hlstd|result<space|0.5em>><hlkwa|in><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|match<space|0.5em>><hlstd|beta<textunderscore>redex<space|0.5em>><hlkwa|with><hlendline|Pattern-match
    on <hlstd|app><hlopt|#><hlstd|f>.><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|Some<space|0.5em>><hlopt|(><hlstd|v'><hlopt|,<space|0.5em>><hlstd|body'><hlopt|)<space|0.5em>-\<gtr\>><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>beta<textunderscore>redex<space|0.5em>><hlopt|\<less\>-<space|0.5em>><hlkwd|None><hlopt|;><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|orig<textunderscore>subst<space|0.5em>><hlopt|=<space|0.5em>><hlstd|subst<space|0.5em>><hlkwa|in><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>subst<space|0.5em>><hlopt|\<less\>-<space|0.5em>(><hlstd|v'><hlopt|,<space|0.5em>><hlstd|arg'><hlopt|)::><hlstd|subst><hlopt|;><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>body'><hlopt|#><hlstd|accept<space|0.5em>self><hlopt|;><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>subst<space|0.5em>><hlopt|\<less\>-<space|0.5em>><hlstd|orig<textunderscore>subst<hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|None<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|result<space|0.5em>><hlopt|:=<space|0.5em>><hlstd|new<textunderscore>app<space|0.5em>f'<space|0.5em>arg'><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlendline|><next-line><hlkwa|class<space|0.5em>><hlopt|[><hlstd|'visitor><hlopt|]<space|0.5em>><hlstd|freevars<textunderscore>lambda<space|0.5em>><hlopt|(><hlstd|result<space|0.5em>><hlopt|:<space|0.5em>><hlstd|var<textunderscore>name<space|0.5em>list<space|0.5em>><hlkwb|ref><hlopt|)<space|0.5em>=><hlendline|><next-line><hlkwa|object<space|0.5em>><hlopt|(><hlstd|self><hlopt|)><hlendline|We
    use <verbatim|result> as an accumulator.><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|inherit<space|0.5em>><hlopt|[><hlstd|'visitor><hlopt|]<space|0.5em>><hlstd|lambda<textunderscore>visit<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|visitVar<space|0.5em>var<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>result<space|0.5em>><hlopt|:=<space|0.5em>><hlstd|var><hlopt|#><hlstd|v<space|0.5em>><hlopt|::<space|0.5em>!><hlstd|result<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|visitAbs<space|0.5em>abs<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|(><hlstd|abs><hlopt|#><hlstd|body><hlopt|)#><hlstd|accept<space|0.5em>self><hlopt|;><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>result<space|0.5em>><hlopt|:=<space|0.5em>><hlkwc|List><hlopt|.><hlstd|filter<space|0.5em>><hlopt|(><hlkwa|fun<space|0.5em>><hlstd|v'<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|v'<space|0.5em>><hlopt|\<less\>\<gtr\><space|0.5em>><hlstd|abs><hlopt|#><hlstd|v><hlopt|)<space|0.5em>!><hlstd|result<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|visitApp<space|0.5em>app<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>app><hlopt|#><hlstd|arg><hlopt|#><hlstd|accept<space|0.5em>self><hlopt|;<space|0.5em>><hlstd|app><hlopt|#><hlstd|f><hlopt|#><hlstd|accept<space|0.5em>self><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlendline|><next-line><hlkwa|type<space|0.5em>><hlstd|lambda<textunderscore>visit<textunderscore>t<space|0.5em>><hlopt|=<space|0.5em>><hlstd|lambda<textunderscore>visit<textunderscore>t<space|0.5em>lambda<textunderscore>visit><hlendline|Visitor
    for the language of <math|\<lambda\>>-expressions.><next-line><hlkwa|type<space|0.5em>><hlstd|lambda<textunderscore>t<space|0.5em>><hlopt|=<space|0.5em>><hlstd|lambda<textunderscore>visit<textunderscore>t<space|0.5em>visitable><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|eval1<space|0.5em>><hlopt|(><hlstd|e<space|0.5em>><hlopt|:<space|0.5em>><hlstd|lambda<textunderscore>t><hlopt|)<space|0.5em>><hlstd|subst<space|0.5em>><hlopt|:<space|0.5em>><hlstd|lambda<textunderscore>t<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|result<space|0.5em>><hlopt|=<space|0.5em>><hlkwb|ref<space|0.5em>><hlopt|(><hlstd|new<textunderscore>var<space|0.5em>><hlstr|""><hlopt|)<space|0.5em>><hlkwa|in><hlendline|This
    initial value will be ignored.><next-line><hlstd|<space|0.5em><space|0.5em>e><hlopt|#><hlstd|accept<space|0.5em>><hlopt|(><hlkwa|new<space|0.5em>><hlstd|eval<textunderscore>lambda<space|0.5em>subst<space|0.5em>result<space|0.5em>><hlopt|:\<gtr\><space|0.5em>><hlstd|lambda<textunderscore>visit<textunderscore>t><hlopt|);><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlopt|!><hlstd|result><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|freevars1<space|0.5em>><hlopt|(><hlstd|e<space|0.5em>><hlopt|:<space|0.5em>><hlstd|lambda<textunderscore>t><hlopt|)<space|0.5em>=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|result<space|0.5em>><hlopt|=<space|0.5em>><hlkwb|ref<space|0.5em>><hlopt|[]<space|0.5em>><hlkwa|in><hlendline|Initial
    value of the accumulator.><next-line><hlstd|<space|0.5em><space|0.5em>e><hlopt|#><hlstd|accept<space|0.5em>><hlopt|(><hlkwa|new<space|0.5em>><hlstd|freevars<textunderscore>lambda<space|0.5em>result><hlopt|);><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlopt|!><hlstd|result><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|test1<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlopt|(><hlstd|new<textunderscore>app<space|0.5em>><hlopt|(><hlstd|new<textunderscore>abs<space|0.5em>><hlstr|"x"><hlstd|<space|0.5em>><hlopt|(><hlstd|new<textunderscore>var<space|0.5em>><hlstr|"x"><hlopt|))<space|0.5em>(><hlstd|new<textunderscore>var<space|0.5em>><hlstr|"y"><hlopt|)<space|0.5em>:\<gtr\><space|0.5em>><hlstd|lambda<textunderscore>t><hlopt|)><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|e<textunderscore>test<space|0.5em>><hlopt|=<space|0.5em>><hlstd|eval1<space|0.5em>test1<space|0.5em>><hlopt|[]><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|fv<textunderscore>test<space|0.5em>><hlopt|=<space|0.5em>><hlstd|freevars1<space|0.5em>test1><hlendline|><next-line><hlendline|><next-line><hlkwa|class<space|0.5em>><hlopt|[><hlstd|'visitor><hlopt|]<space|0.5em>><hlstd|num<space|0.5em>><hlopt|(><hlstd|i<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|int><hlopt|)<space|0.5em>=><hlendline|><next-line><hlkwa|object<space|0.5em>><hlopt|(><hlstd|self><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|i<space|0.5em>><hlopt|=<space|0.5em>><hlstd|i<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|accept<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'visitor<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwb|unit<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|fun<space|0.5em>><hlstd|visitor<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|visitor><hlopt|#><hlstd|visitNum<space|0.5em>self><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|new<textunderscore>num<space|0.5em>i<space|0.5em>><hlopt|=<space|0.5em>(><hlkwa|new<space|0.5em>><hlstd|num<space|0.5em>i<space|0.5em>><hlopt|:\<gtr\><space|0.5em>><hlstd|'a<space|0.5em>visitable><hlopt|)><hlendline|><next-line><hlendline|><next-line><hlkwa|class<space|0.5em>virtual<space|0.5em>><hlopt|[><hlstd|'visitor><hlopt|]<space|0.5em>><hlstd|operation<hlendline|><next-line><space|0.5em><space|0.5em>><hlopt|(><hlstd|arg1<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'visitor<space|0.5em>visitable><hlopt|)<space|0.5em>(><hlstd|arg2<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'visitor<space|0.5em>visitable><hlopt|)<space|0.5em>=><hlendline|><next-line><hlkwa|object<space|0.5em>><hlopt|(><hlstd|self><hlopt|)><hlendline|Shared
    accessor methods.><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|arg1<space|0.5em>><hlopt|=<space|0.5em>><hlstd|arg1<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|arg2<space|0.5em>><hlopt|=<space|0.5em>><hlstd|arg2><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlendline|><next-line><hlkwa|class<space|0.5em>><hlopt|[><hlstd|'visitor><hlopt|]<space|0.5em>><hlstd|add<space|0.5em>arg1<space|0.5em>arg2<space|0.5em>><hlopt|=><hlendline|><next-line><hlkwa|object<space|0.5em>><hlopt|(><hlstd|self><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|inherit<space|0.5em>><hlopt|[><hlstd|'visitor><hlopt|]<space|0.5em>><hlstd|operation<space|0.5em>arg1<space|0.5em>arg2<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|accept<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'visitor<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwb|unit<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|fun<space|0.5em>><hlstd|visitor<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|visitor><hlopt|#><hlstd|visitAdd<space|0.5em>self><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|new<textunderscore>add<space|0.5em>arg1<space|0.5em>arg2<space|0.5em>><hlopt|=<space|0.5em>(><hlkwa|new<space|0.5em>><hlstd|add<space|0.5em>arg1<space|0.5em>arg2<space|0.5em>><hlopt|:\<gtr\><space|0.5em>><hlstd|'a<space|0.5em>visitable><hlopt|)><hlendline|><next-line><hlendline|><next-line><hlkwa|class<space|0.5em>><hlopt|[><hlstd|'visitor><hlopt|]<space|0.5em>><hlstd|mult<space|0.5em>arg1<space|0.5em>arg2<space|0.5em>><hlopt|=><hlendline|><next-line><hlkwa|object<space|0.5em>><hlopt|(><hlstd|self><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|inherit<space|0.5em>><hlopt|[><hlstd|'visitor><hlopt|]<space|0.5em>><hlstd|operation<space|0.5em>arg1<space|0.5em>arg2<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|accept<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'visitor<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwb|unit<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|fun<space|0.5em>><hlstd|visitor<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|visitor><hlopt|#><hlstd|visitMult<space|0.5em>self><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|new<textunderscore>mult<space|0.5em>arg1<space|0.5em>arg2<space|0.5em>><hlopt|=<space|0.5em>(><hlkwa|new<space|0.5em>><hlstd|mult<space|0.5em>arg1<space|0.5em>arg2<space|0.5em>><hlopt|:\<gtr\><space|0.5em>><hlstd|'a<space|0.5em>visitable><hlopt|)><hlendline|><next-line><hlendline|><next-line><hlkwa|class<space|0.5em>virtual<space|0.5em>><hlopt|[><hlstd|'visitor><hlopt|]<space|0.5em>><hlstd|expr<textunderscore>visit<space|0.5em>><hlopt|=><hlendline|The
    sub-language of arithmetic expressions.><next-line><hlkwa|object><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>virtual<space|0.5em>><hlstd|visitNum<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'visitor<space|0.5em>num<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwb|unit><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>virtual<space|0.5em>><hlstd|visitAdd<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'visitor<space|0.5em>add<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwb|unit><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>virtual<space|0.5em>><hlstd|visitMult<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'visitor<space|0.5em>mult<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwb|unit><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlendline|><next-line><hlkwa|class<space|0.5em>><hlopt|[><hlstd|'visitor><hlopt|]<space|0.5em>><hlstd|eval<textunderscore>expr<hlendline|><next-line><space|0.5em><space|0.5em>><hlopt|(><hlstd|result<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'visitor<space|0.5em>visitable<space|0.5em>><hlkwb|ref><hlopt|)<space|0.5em>=><hlendline|><next-line><hlkwa|object<space|0.5em>><hlopt|(><hlstd|self><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|inherit<space|0.5em>><hlopt|[><hlstd|'visitor><hlopt|]<space|0.5em>><hlstd|expr<textunderscore>visit<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|val<space|0.5em>mutable<space|0.5em>><hlstd|num<textunderscore>redex<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|int<space|0.5em>option<space|0.5em>><hlopt|=<space|0.5em>><hlkwd|None><hlendline|The
    numeric result, if any.><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|visitNum<space|0.5em>num<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>num<textunderscore>redex<space|0.5em>><hlopt|\<less\>-<space|0.5em>><hlkwd|Some<space|0.5em>><hlstd|num><hlopt|#><hlstd|i><hlopt|;><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>result<space|0.5em>><hlopt|:=<space|0.5em>(><hlstd|num<space|0.5em>><hlopt|:\<gtr\><space|0.5em>><hlstd|'visitor<space|0.5em>visitable><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>private<space|0.5em>><hlstd|visitOperation<space|0.5em>new<textunderscore>e<space|0.5em>op<space|0.5em>e<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|(><hlstd|e><hlopt|#><hlstd|arg1><hlopt|)#><hlstd|accept<space|0.5em>self><hlopt|;><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|arg1'<space|0.5em>><hlopt|=<space|0.5em>!><hlstd|result<space|0.5em>><hlkwa|and<space|0.5em>><hlstd|i1<space|0.5em>><hlopt|=<space|0.5em>><hlstd|num<textunderscore>redex<space|0.5em>><hlkwa|in><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|(><hlstd|e><hlopt|#><hlstd|arg2><hlopt|)#><hlstd|accept<space|0.5em>self><hlopt|;><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|arg2'<space|0.5em>><hlopt|=<space|0.5em>!><hlstd|result<space|0.5em>><hlkwa|and<space|0.5em>><hlstd|i2<space|0.5em>><hlopt|=<space|0.5em>><hlstd|num<textunderscore>redex<space|0.5em>><hlkwa|in><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|match<space|0.5em>><hlstd|i1><hlopt|,<space|0.5em>><hlstd|i2<space|0.5em>><hlkwa|with><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|Some<space|0.5em>><hlstd|i1><hlopt|,<space|0.5em>><hlkwd|Some<space|0.5em>><hlstd|i2<space|0.5em>><hlopt|-\<gtr\>><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|res<space|0.5em>><hlopt|=<space|0.5em>><hlstd|op<space|0.5em>i1<space|0.5em>i2<space|0.5em>><hlkwa|in><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>num<textunderscore>redex<space|0.5em>><hlopt|\<less\>-<space|0.5em>><hlkwd|Some<space|0.5em>><hlstd|res><hlopt|;<space|0.5em>><hlstd|result<space|0.5em>><hlopt|:=<space|0.5em>><hlstd|new<textunderscore>num<space|0.5em>res<hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><hlunderscore>><hlopt|-\<gtr\>><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>num<textunderscore>redex<space|0.5em>><hlopt|\<less\>-<space|0.5em>><hlkwd|None><hlopt|;><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>result<space|0.5em>><hlopt|:=<space|0.5em>><hlstd|new<textunderscore>e<space|0.5em>arg1'<space|0.5em>arg2'<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|visitAdd<space|0.5em>add<space|0.5em>><hlopt|=<space|0.5em>><hlstd|self><hlopt|#><hlstd|visitOperation<space|0.5em>new<textunderscore>add<space|0.5em>><hlopt|(<space|0.5em>+<space|0.5em>)<space|0.5em>><hlstd|add<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|visitMult<space|0.5em>mult<space|0.5em>><hlopt|=<space|0.5em>><hlstd|self><hlopt|#><hlstd|visitOperation<space|0.5em>new<textunderscore>mult<space|0.5em>><hlopt|(<space|0.5em>*<space|0.5em>)<space|0.5em>><hlstd|mult><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlendline|><next-line><hlkwa|class<space|0.5em>><hlopt|[><hlstd|'visitor><hlopt|]<space|0.5em>><hlstd|freevars<textunderscore>expr<space|0.5em>><hlopt|(><hlstd|result<space|0.5em>><hlopt|:<space|0.5em>><hlstd|var<textunderscore>name<space|0.5em>list<space|0.5em>><hlkwb|ref><hlopt|)<space|0.5em>=><hlendline|Flow-through
    class><next-line><hlkwa|object<space|0.5em>><hlopt|(><hlstd|self><hlopt|)><hlendline|for
    computing free variables.><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|inherit<space|0.5em>><hlopt|[><hlstd|'visitor><hlopt|]<space|0.5em>><hlstd|expr<textunderscore>visit<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|visitNum<hlunderscore>><hlopt|=<space|0.5em>()><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|visitAdd<space|0.5em>add<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>add><hlopt|#><hlstd|arg1><hlopt|#><hlstd|accept<space|0.5em>self><hlopt|;<space|0.5em>><hlstd|add><hlopt|#><hlstd|arg2><hlopt|#><hlstd|accept<space|0.5em>self<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|method<space|0.5em>><hlstd|visitMult<space|0.5em>mult<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>mult><hlopt|#><hlstd|arg1><hlopt|#><hlstd|accept<space|0.5em>self><hlopt|;<space|0.5em>><hlstd|mult><hlopt|#><hlstd|arg2><hlopt|#><hlstd|accept<space|0.5em>self><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlendline|><next-line><hlkwa|type<space|0.5em>><hlstd|expr<textunderscore>visit<textunderscore>t<space|0.5em>><hlopt|=<space|0.5em>><hlstd|expr<textunderscore>visit<textunderscore>t<space|0.5em>expr<textunderscore>visit><hlendline|The
    language of arithmetic expressions><next-line><hlkwa|type<space|0.5em>><hlstd|expr<textunderscore>t<space|0.5em>><hlopt|=<space|0.5em>><hlstd|expr<textunderscore>visit<textunderscore>t<space|0.5em>visitable><hlendline|--
    in this example without variables.><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|eval2<space|0.5em>><hlopt|(><hlstd|e<space|0.5em>><hlopt|:<space|0.5em>><hlstd|expr<textunderscore>t><hlopt|)<space|0.5em>:<space|0.5em>><hlstd|expr<textunderscore>t<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|result<space|0.5em>><hlopt|=<space|0.5em>><hlkwb|ref<space|0.5em>><hlopt|(><hlstd|new<textunderscore>num<space|0.5em>><hlnum|0><hlopt|)<space|0.5em>><hlkwa|in><hlendline|This
    initial value will be ignored.><next-line><hlstd|<space|0.5em><space|0.5em>e><hlopt|#><hlstd|accept<space|0.5em>><hlopt|(><hlkwa|new<space|0.5em>><hlstd|eval<textunderscore>expr<space|0.5em>result><hlopt|);><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlopt|!><hlstd|result><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|test2<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlopt|(><hlstd|new<textunderscore>add<space|0.5em>><hlopt|(><hlstd|new<textunderscore>mult<space|0.5em>><hlopt|(><hlstd|new<textunderscore>num<space|0.5em>><hlnum|3><hlopt|)<space|0.5em>(><hlstd|new<textunderscore>num<space|0.5em>><hlnum|3><hlopt|))<space|0.5em>(><hlstd|new<textunderscore>num<space|0.5em>><hlnum|1><hlopt|)<space|0.5em>:\<gtr\><space|0.5em>><hlstd|expr<textunderscore>t><hlopt|)><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|e<textunderscore>test<space|0.5em>><hlopt|=<space|0.5em>><hlstd|eval2<space|0.5em>test2><hlendline|><next-line><hlendline|><next-line><hlkwa|class<space|0.5em>virtual<space|0.5em>><hlopt|[><hlstd|'visitor><hlopt|]<space|0.5em>><hlstd|lexpr<textunderscore>visit<space|0.5em>><hlopt|=><hlendline|Combining
    the variants / constructors.><next-line><hlkwa|object><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|inherit<space|0.5em>><hlopt|[><hlstd|'visitor><hlopt|]<space|0.5em>><hlstd|lambda<textunderscore>visit<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|inherit<space|0.5em>><hlopt|[><hlstd|'visitor><hlopt|]<space|0.5em>><hlstd|expr<textunderscore>visit><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlendline|><next-line><hlkwa|class<space|0.5em>><hlopt|[><hlstd|'visitor><hlopt|]<space|0.5em>><hlstd|eval<textunderscore>lexpr<space|0.5em>subst<space|0.5em>result<space|0.5em>><hlopt|=><hlendline|Combining
    the ``pattern-matching branches''.><next-line><hlkwa|object><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|inherit<space|0.5em>><hlopt|[><hlstd|'visitor><hlopt|]<space|0.5em>><hlstd|eval<textunderscore>expr<space|0.5em>result<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|inherit<space|0.5em>><hlopt|[><hlstd|'visitor><hlopt|]<space|0.5em>><hlstd|eval<textunderscore>lambda<space|0.5em>subst<space|0.5em>result><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlendline|><next-line><hlkwa|class<space|0.5em>><hlopt|[><hlstd|'visitor><hlopt|]<space|0.5em>><hlstd|freevars<textunderscore>lexpr<space|0.5em>result<space|0.5em>><hlopt|=><hlendline|><next-line><hlkwa|object><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|inherit<space|0.5em>><hlopt|[><hlstd|'visitor><hlopt|]<space|0.5em>><hlstd|freevars<textunderscore>expr<space|0.5em>result<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|inherit<space|0.5em>><hlopt|[><hlstd|'visitor><hlopt|]<space|0.5em>><hlstd|freevars<textunderscore>lambda<space|0.5em>result><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlendline|><next-line><hlkwa|type<space|0.5em>><hlstd|lexpr<textunderscore>visit<textunderscore>t<space|0.5em>><hlopt|=<space|0.5em>><hlstd|lexpr<textunderscore>visit<textunderscore>t<space|0.5em>lexpr<textunderscore>visit><hlendline|The
    language combining><next-line><hlkwa|type<space|0.5em>><hlstd|lexpr<textunderscore>t<space|0.5em>><hlopt|=<space|0.5em>><hlstd|lexpr<textunderscore>visit<textunderscore>t<space|0.5em>visitable><hlendline|<math|\<lambda\>>-expressions
    and arithmetic expressions.><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|eval3<space|0.5em>><hlopt|(><hlstd|e<space|0.5em>><hlopt|:<space|0.5em>><hlstd|lexpr<textunderscore>t><hlopt|)<space|0.5em>><hlstd|subst<space|0.5em>><hlopt|:<space|0.5em>><hlstd|lexpr<textunderscore>t<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|result<space|0.5em>><hlopt|=<space|0.5em>><hlkwb|ref<space|0.5em>><hlopt|(><hlstd|new<textunderscore>num<space|0.5em>><hlnum|0><hlopt|)<space|0.5em>><hlkwa|in><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>e><hlopt|#><hlstd|accept<space|0.5em>><hlopt|(><hlkwa|new<space|0.5em>><hlstd|eval<textunderscore>lexpr<space|0.5em>subst<space|0.5em>result><hlopt|);><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlopt|!><hlstd|result><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|freevars3<space|0.5em>><hlopt|(><hlstd|e<space|0.5em>><hlopt|:<space|0.5em>><hlstd|lexpr<textunderscore>t><hlopt|)<space|0.5em>=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|result<space|0.5em>><hlopt|=<space|0.5em>><hlkwb|ref<space|0.5em>><hlopt|[]<space|0.5em>><hlkwa|in><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>e><hlopt|#><hlstd|accept<space|0.5em>><hlopt|(><hlkwa|new<space|0.5em>><hlstd|freevars<textunderscore>lexpr<space|0.5em>result><hlopt|);><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlopt|!><hlstd|result><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|test3<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlopt|(><hlstd|new<textunderscore>add<space|0.5em>><hlopt|(><hlstd|new<textunderscore>mult<space|0.5em>><hlopt|(><hlstd|new<textunderscore>num<space|0.5em>><hlnum|3><hlopt|)<space|0.5em>(><hlstd|new<textunderscore>var<space|0.5em>><hlstr|"x"><hlopt|))<space|0.5em>(><hlstd|new<textunderscore>num<space|0.5em>><hlnum|1><hlopt|)<space|0.5em>:\<gtr\><space|0.5em>><hlstd|lexpr<textunderscore>t><hlopt|)><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|e<textunderscore>test<space|0.5em>><hlopt|=<space|0.5em>><hlstd|eval3<space|0.5em>test3<space|0.5em>><hlopt|[]><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|fv<textunderscore>test<space|0.5em>><hlopt|=<space|0.5em>><hlstd|freevars3<space|0.5em>test3><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|old<textunderscore>e<textunderscore>test<space|0.5em>><hlopt|=<space|0.5em>><hlstd|eval3<space|0.5em>><hlopt|(><hlstd|test2<space|0.5em>><hlopt|:\<gtr\><space|0.5em>><hlstd|lexpr<textunderscore>t><hlopt|)<space|0.5em>[]><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|old<textunderscore>fv<textunderscore>test<space|0.5em>><hlopt|=<space|0.5em>><hlstd|eval3<space|0.5em>><hlopt|(><hlstd|test2<space|0.5em>><hlopt|:\<gtr\><space|0.5em>><hlstd|lexpr<textunderscore>t><hlopt|)<space|0.5em>[]><hlendline|>>
  </hidden>|<\hidden>
    <tit|Polymorphic Variant Types: Subtyping>

    <\itemize>
      <item>Polymorphic variants are to ordinary variants as objects are to
      records: both enable <em|open types> and subtyping, both allow
      different types to share the same components.

      <\itemize>
        <item>They are <em|dual> concepts in that if we replace ``product''
        of records / objects by ``sum'' (see lecture 2), we get variants /
        polymorphic variants.<next-line><small|Duality implies many behaviors
        are opposite.>
      </itemize>

      <item>While object subtypes have more methods, polymorphic variant
      subtypes have less tags.

      <item>The <hlopt|\<gtr\>> sign means ``these tags or more'':

      <hlkwa|let<space|0.5em>><hlstd|l<space|0.5em>><hlopt|=<space|0.5em>[><hlstd|`><hlkwd|Int<space|0.5em>><hlnum|3><hlopt|;<space|0.5em>><hlstd|`><hlkwd|Float<space|0.5em>><hlnum|4><hlopt|.];;><hlendline|><next-line><hlkwa|val<space|0.5em>><hlstd|l<space|0.5em>><hlopt|:<space|0.5em>[\<gtr\><space|0.5em>><hlstd|`><hlkwd|Float<space|0.5em>><hlkwa|of<space|0.5em>><hlkwb|float<space|0.5em>><hlstd|<hlbar><space|0.5em>`><hlkwd|Int<space|0.5em>><hlkwa|of<space|0.5em>><hlkwb|int<space|0.5em>><hlopt|]<space|0.5em>><hlstd|list<space|0.5em>><hlopt|=<space|0.5em>[><hlstd|`><hlkwd|Int<space|0.5em>><hlnum|3><hlopt|;<space|0.5em>><hlstd|`><hlkwd|Float<space|0.5em>><hlnum|4><hlopt|.]>

      <item>The <hlopt|\<less\>> sign means ``these tags or less'':

      <hlkwa|let<space|0.5em>><hlstd|is<textunderscore>positive<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|function><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|Int><hlstd|<space|0.5em><space|0.5em><space|0.5em>x<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwd|Some<space|0.5em>><hlopt|(><hlstd|x<space|0.5em>><hlopt|\<gtr\><space|0.5em>><hlnum|0><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|Float<space|0.5em>><hlstd|x<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwd|Some<space|0.5em>><hlopt|(><hlstd|x<space|0.5em>><hlopt|\<gtr\><space|0.5em>><hlnum|0><hlopt|.)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|Not<textunderscore>a<textunderscore>number<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwd|None><hlopt|;;><hlendline|><next-line><hlkwa|val<space|0.5em>><hlstd|is<textunderscore>positive<space|0.5em>><hlopt|:><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlopt|[\<less\><space|0.5em>><hlstd|`><hlkwd|Float<space|0.5em>><hlkwa|of<space|0.5em>><hlkwb|float<space|0.5em>><hlstd|<hlbar><space|0.5em>`><hlkwd|Int<space|0.5em>><hlkwa|of<space|0.5em>><hlkwb|int<space|0.5em>><hlstd|<hlbar><space|0.5em>`><hlkwd|Not<textunderscore>a<textunderscore>number<space|0.5em>><hlopt|]<space|0.5em>-<no-break>\<gtr\><space|0.5em>><next-line><hlkwb|
      \ \ \ bool<space|0.5em>option<space|0.5em>><hlopt|=<space|0.5em>\<less\>><hlkwa|fun><hlopt|\<gtr\>><hlendline|>

      <item>No sign means a closed type (similar to an object type without
      the <hlopt|..>)

      <item>Both an upper and a lower bound are sometimes
      inferred,<next-line>see <hlink|https://realworldocaml.org/v1/en/html/variants.html|https://realworldocaml.org/v1/en/html/variants.html>

      <hlkwc|List><hlopt|.><hlstd|filter<hlendline|><next-line><space|0.5em><space|0.5em>><hlopt|(><hlkwa|fun<space|0.5em>><hlstd|x<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwa|match<space|0.5em>><hlstd|is<textunderscore>positive<space|0.5em>x<space|0.5em>><hlkwa|with<space|0.5em>><hlkwd|None<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwa|false<space|0.5em>><hlstd|<hlbar><space|0.5em>><hlkwd|Some<space|0.5em>><hlstd|b<space|0.5em>><hlopt|-<no-break>\<gtr\><space|0.5em>><hlstd|b><hlopt|)<space|0.5em>><hlstd|l><hlopt|;;><next-line><hlopt|-<space|0.5em>:<space|0.5em>[\<less\><space|0.5em>><hlstd|`><hlkwd|Float<space|0.5em>><hlkwa|of<space|0.5em>><hlkwb|float<space|0.5em>><hlstd|<hlbar><space|0.5em>`><hlkwd|Int<space|0.5em>><hlkwa|of<space|0.5em>><hlkwb|int<space|0.5em>><hlstd|<hlbar><space|0.5em>`><hlkwd|Not<textunderscore>a<textunderscore>number<space|0.5em>><hlopt|\<gtr\><space|0.5em>><hlstd|`><hlkwd|Float<space|0.5em>><hlstd|`><hlkwd|Int<space|0.5em>><hlopt|]<space|0.5em>><next-line><hlstd|
      \ \ \ \ \ list<space|0.5em>><hlopt|=><next-line><hlopt|[><hlstd|`><hlkwd|Int<space|0.5em>><hlnum|3><hlopt|;<space|0.5em>><hlstd|`><hlkwd|Float<space|0.5em>><hlnum|4><hlopt|.]><hlendline|>
    </itemize>
  </hidden>|<\hidden>
    <tit|Polymorphic Variant Types: The Expression Problem>

    <\itemize>
      <item>Because distinct polymorphic variant types can share the same
      tags, the solution to the Expression Problem is straightforward.

      <item>Penalty points:

      <\itemize>
        <item>The need to ``tie the recursive knot'' separately both at the
        type level and the function level. At the function level, an
        <math|\<eta\>>-expansion is required due to <em|value recursion>
        problem. At the type level, the type variable can be confusing.

        <item>There can be a slight time cost compared to the visitor
        pattern-based approach: additional dispatch at each level of type
        aggregation (i.e. merging sub-languages).
      </itemize>

      Verdict: a flexible and concise solution, second-best place.
    </itemize>

    <hlkwa|type<space|0.5em>><hlstd|var<space|0.5em>><hlopt|=<space|0.5em>[><hlstd|`><hlkwd|Var<space|0.5em>><hlkwa|of<space|0.5em>><hlkwb|string><hlopt|]><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|eval<textunderscore>var<space|0.5em>sub<space|0.5em>><hlopt|(><hlstd|`><hlkwd|Var<space|0.5em>><hlstd|s<space|0.5em>><hlkwa|as<space|0.5em>><hlstd|v<space|0.5em>><hlopt|:<space|0.5em>><hlstd|var><hlopt|)<space|0.5em>=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|try<space|0.5em>><hlkwc|List><hlopt|.><hlstd|assoc<space|0.5em>s<space|0.5em>sub<space|0.5em>><hlkwa|with<space|0.5em>><hlkwd|Not<textunderscore>found<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|v><hlendline|><next-line><hlendline|><next-line><hlkwa|type<space|0.5em>><hlstd|'a<space|0.5em>lambda<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlopt|[><hlstd|`><hlkwd|Var<space|0.5em>><hlkwa|of<space|0.5em>><hlkwb|string<space|0.5em>><hlstd|<hlbar><space|0.5em>`><hlkwd|Abs<space|0.5em>><hlkwa|of<space|0.5em>><hlkwb|string<space|0.5em>><hlopt|*<space|0.5em>><hlstd|'a<space|0.5em><hlbar><space|0.5em>`><hlkwd|App<space|0.5em>><hlkwa|of<space|0.5em>><hlstd|'a<space|0.5em>><hlopt|*<space|0.5em>><hlstd|'a><hlopt|]><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|gensym<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|let<space|0.5em>><hlstd|n<space|0.5em>><hlopt|=<space|0.5em>><hlkwb|ref<space|0.5em>><hlnum|0<space|0.5em>><hlkwa|in<space|0.5em>fun<space|0.5em>><hlopt|()<space|0.5em>-\<gtr\><space|0.5em>><hlstd|incr<space|0.5em>n><hlopt|;<space|0.5em>><hlstr|"<textunderscore>"><hlstd|<space|0.5em><hlcircum><space|0.5em>string<textunderscore>of<textunderscore>int<space|0.5em>><hlopt|!><hlstd|n><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|eval<textunderscore>lambda<space|0.5em>eval<textunderscore>rec<space|0.5em>subst<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'a<space|0.5em>lambda<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|'a<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|function><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>><hlopt|#><hlstd|var<space|0.5em>><hlkwa|as<space|0.5em>><hlstd|v<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><verbatim|eval<textunderscore>var<space|0.5em>subst<space|0.5em>v><hlendline|We
    could also leave the type open><next-line><space|0.5em><space|0.5em><hlbar><space|0.5em>`<hlkwd|App<space|0.5em>><hlopt|(><hlstd|l1><hlopt|,<space|0.5em>><hlstd|l2><hlopt|)<space|0.5em>-\<gtr\>><hlendline|rather
    than closing it to <verbatim|lambda>.><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|l2'<space|0.5em>><hlopt|=<space|0.5em>><hlstd|eval<textunderscore>rec<space|0.5em>subst<space|0.5em>l2<space|0.5em>><hlkwa|in><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|(><hlkwa|match<space|0.5em>><hlstd|eval<textunderscore>rec<space|0.5em>subst<space|0.5em>l1<space|0.5em>><hlkwa|with><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|Abs<space|0.5em>><hlopt|(><hlstd|s><hlopt|,<space|0.5em>><hlstd|body><hlopt|)<space|0.5em>-\<gtr\>><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>eval<textunderscore>rec<space|0.5em>><hlopt|[><hlstd|s><hlopt|,<space|0.5em>><hlstd|l2'><hlopt|]<space|0.5em>><hlstd|body<hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>l1'<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|`><hlkwd|App<space|0.5em>><hlopt|(><hlstd|l1'><hlopt|,<space|0.5em>><hlstd|l2'><hlopt|))><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|Abs<space|0.5em>><hlopt|(><hlstd|s><hlopt|,<space|0.5em>><hlstd|l1><hlopt|)<space|0.5em>-\<gtr\>><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|s'<space|0.5em>><hlopt|=<space|0.5em>><hlstd|gensym<space|0.5em>><hlopt|()<space|0.5em>><hlkwa|in><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>`><hlkwd|Abs<space|0.5em>><hlopt|(><hlstd|s'><hlopt|,<space|0.5em>><hlstd|eval<textunderscore>rec<space|0.5em>><hlopt|((><hlstd|s><hlopt|,<space|0.5em>><hlstd|`><hlkwd|Var<space|0.5em>><hlstd|s'><hlopt|)::><hlstd|subst><hlopt|)<space|0.5em>><hlstd|l1><hlopt|)><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|freevars<textunderscore>lambda<space|0.5em>freevars<textunderscore>rec<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'a<space|0.5em>lambda<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|'b<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|function><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|Var<space|0.5em>><hlstd|v<space|0.5em>><hlopt|-\<gtr\><space|0.5em>[><hlstd|v><hlopt|]><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|App<space|0.5em>><hlopt|(><hlstd|l1><hlopt|,<space|0.5em>><hlstd|l2><hlopt|)<space|0.5em>-\<gtr\><space|0.5em>><hlstd|freevars<textunderscore>rec<space|0.5em>l1<space|0.5em>><hlopt|@<space|0.5em>><hlstd|freevars<textunderscore>rec<space|0.5em>l2<hlendline|><next-line><space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|Abs<space|0.5em>><hlopt|(><hlstd|s><hlopt|,<space|0.5em>><hlstd|l1><hlopt|)<space|0.5em>-\<gtr\>><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwc|List><hlopt|.><hlstd|filter<space|0.5em>><hlopt|(><hlkwa|fun<space|0.5em>><hlstd|v<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|v<space|0.5em>><hlopt|\<less\>\<gtr\><space|0.5em>><hlstd|s><hlopt|)<space|0.5em>(><hlstd|freevars<textunderscore>rec<space|0.5em>l1><hlopt|)><hlendline|><next-line><hlendline|><next-line><hlkwa|type<space|0.5em>><hlstd|lambda<textunderscore>t<space|0.5em>><hlopt|=<space|0.5em>><hlstd|lambda<textunderscore>t<space|0.5em>lambda><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>rec<space|0.5em>><hlstd|eval1<space|0.5em>subst<space|0.5em>e<space|0.5em>><hlopt|:<space|0.5em>><hlstd|lambda<textunderscore>t<space|0.5em>><hlopt|=<space|0.5em>><hlstd|eval<textunderscore>lambda<space|0.5em>eval1<space|0.5em>subst<space|0.5em>e><hlendline|><next-line><hlkwa|let<space|0.5em>rec<space|0.5em>><hlstd|freevars1<space|0.5em>><hlopt|(><hlstd|e<space|0.5em>><hlopt|:<space|0.5em>><hlstd|lambda<textunderscore>t><hlopt|)<space|0.5em>=<space|0.5em>><hlstd|freevars<textunderscore>lambda<space|0.5em>freevars1<space|0.5em>e><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|test1<space|0.5em>><hlopt|=<space|0.5em>(><hlstd|`><hlkwd|App<space|0.5em>><hlopt|(><hlstd|`><hlkwd|Abs<space|0.5em>><hlopt|(><hlstr|"x"><hlopt|,<space|0.5em>><hlstd|`><hlkwd|Var<space|0.5em>><hlstr|"x"><hlopt|),<space|0.5em>><hlstd|`><hlkwd|Var<space|0.5em>><hlstr|"y"><hlopt|)<space|0.5em>:\<gtr\><space|0.5em>><hlstd|lambda<textunderscore>t><hlopt|)><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|e<textunderscore>test<space|0.5em>><hlopt|=<space|0.5em>><hlstd|eval1<space|0.5em>><hlopt|[]<space|0.5em>><hlstd|test1><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|fv<textunderscore>test<space|0.5em>><hlopt|=<space|0.5em>><hlstd|freevars1<space|0.5em>test1><hlendline|><next-line><hlendline|><next-line><hlkwa|type<space|0.5em>><hlstd|'a<space|0.5em>expr<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlopt|[><hlstd|`><hlkwd|Var<space|0.5em>><hlkwa|of<space|0.5em>><hlkwb|string<space|0.5em>><hlstd|<hlbar><space|0.5em>`><hlkwd|Num<space|0.5em>><hlkwa|of<space|0.5em>><hlkwb|int<space|0.5em>><hlstd|<hlbar><space|0.5em>`><hlkwd|Add<space|0.5em>><hlkwa|of<space|0.5em>><hlstd|'a<space|0.5em>><hlopt|*<space|0.5em>><hlstd|'a<space|0.5em><hlbar><space|0.5em>`><hlkwd|Mult<space|0.5em>><hlkwa|of<space|0.5em>><hlstd|'a<space|0.5em>><hlopt|*<space|0.5em>><hlstd|'a><hlopt|]><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|map<textunderscore>expr<space|0.5em>><hlopt|(><hlstd|f<space|0.5em>><hlopt|:<space|0.5em>><hlstd|<textunderscore><space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|'a><hlopt|)<space|0.5em>:<space|0.5em>><hlstd|'a<space|0.5em>expr<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|'a<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|function><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>><hlopt|#><hlstd|var<space|0.5em>><hlkwa|as<space|0.5em>><hlstd|v<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|v<hlendline|><next-line><space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|Num<space|0.5em>><hlstd|<textunderscore><space|0.5em>><hlkwa|as<space|0.5em>><hlstd|n<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|n<hlendline|><next-line><space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|Add<space|0.5em>><hlopt|(><hlstd|e1><hlopt|,<space|0.5em>><hlstd|e2><hlopt|)<space|0.5em>-\<gtr\><space|0.5em>><hlstd|`><hlkwd|Add<space|0.5em>><hlopt|(><hlstd|f<space|0.5em>e1><hlopt|,<space|0.5em>><hlstd|f<space|0.5em>e2><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|Mult<space|0.5em>><hlopt|(><hlstd|e1><hlopt|,<space|0.5em>><hlstd|e2><hlopt|)<space|0.5em>-\<gtr\><space|0.5em>><hlstd|`><hlkwd|Mult<space|0.5em>><hlopt|(><hlstd|f<space|0.5em>e1><hlopt|,<space|0.5em>><hlstd|f<space|0.5em>e2><hlopt|)><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|eval<textunderscore>expr<space|0.5em>eval<textunderscore>rec<space|0.5em>subst<space|0.5em>><hlopt|(><hlstd|e<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'a<space|0.5em>expr><hlopt|)<space|0.5em>:<space|0.5em>><hlstd|'a<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|match<space|0.5em>><hlstd|map<textunderscore>expr<space|0.5em>><hlopt|(><hlstd|eval<textunderscore>rec<space|0.5em>subst><hlopt|)<space|0.5em>><hlstd|e<space|0.5em>><hlkwa|with><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>><hlopt|#><hlstd|var<space|0.5em>><hlkwa|as<space|0.5em>><hlstd|v<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><verbatim|eval<textunderscore>var<space|0.5em>subst<space|0.5em>v><hlendline|Here
    and elsewhere, we could also factor-out><next-line><space|0.5em><space|0.5em><hlbar><verbatim|<space|0.5em>`><hlkwd|Add<space|0.5em>><hlopt|(><hlstd|`><hlkwd|Num<space|0.5em>><hlstd|m><hlopt|,<space|0.5em>><hlstd|`><hlkwd|Num<space|0.5em>><hlstd|n><hlopt|)<space|0.5em>-\<gtr\><space|0.5em>><hlstd|`><hlkwd|Num<space|0.5em>><hlopt|(><hlstd|m<space|0.5em>><hlopt|+<space|0.5em>><hlstd|n><hlopt|)><hlendline|the
    sub-language of variables.><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|Mult<space|0.5em>><hlopt|(><hlstd|`><hlkwd|Num<space|0.5em>><hlstd|m><hlopt|,<space|0.5em>><hlstd|`><hlkwd|Num<space|0.5em>><hlstd|n><hlopt|)<space|0.5em>-\<gtr\><space|0.5em>><hlstd|`><hlkwd|Num<space|0.5em>><hlopt|(><hlstd|m<space|0.5em>><hlopt|*<space|0.5em>><hlstd|n><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>e<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|e><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|freevars<textunderscore>expr<space|0.5em>freevars<textunderscore>rec<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'a<space|0.5em>expr<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|'b<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|function><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|Var<space|0.5em>><hlstd|v<space|0.5em>><hlopt|-\<gtr\><space|0.5em>[><hlstd|v><hlopt|]><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|Num<space|0.5em>><hlstd|<textunderscore><space|0.5em>><hlopt|-\<gtr\><space|0.5em>[]><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|Add<space|0.5em>><hlopt|(><hlstd|e1><hlopt|,<space|0.5em>><hlstd|e2><hlopt|)<space|0.5em>><hlstd|<hlbar><space|0.5em>`><hlkwd|Mult<space|0.5em>><hlopt|(><hlstd|e1><hlopt|,<space|0.5em>><hlstd|e2><hlopt|)<space|0.5em>-\<gtr\><space|0.5em>><hlstd|freevars<textunderscore>rec<space|0.5em>e1<space|0.5em>><hlopt|@<space|0.5em>><hlstd|freevars<textunderscore>rec<space|0.5em>e2><hlendline|><next-line><hlendline|><next-line><hlkwa|type<space|0.5em>><hlstd|expr<textunderscore>t<space|0.5em>><hlopt|=<space|0.5em>><hlstd|expr<textunderscore>t<space|0.5em>expr><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>rec<space|0.5em>><hlstd|eval2<space|0.5em>subst<space|0.5em>e<space|0.5em>><hlopt|:<space|0.5em>><hlstd|expr<textunderscore>t<space|0.5em>><hlopt|=<space|0.5em>><hlstd|eval<textunderscore>expr<space|0.5em>eval2<space|0.5em>subst<space|0.5em>e><hlendline|><next-line><hlkwa|let<space|0.5em>rec<space|0.5em>><hlstd|freevars2<space|0.5em>><hlopt|(><hlstd|e<space|0.5em>><hlopt|:<space|0.5em>><hlstd|expr<textunderscore>t><hlopt|)<space|0.5em>=<space|0.5em>><hlstd|freevars<textunderscore>expr<space|0.5em>freevars2<space|0.5em>e><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|test2<space|0.5em>><hlopt|=<space|0.5em>(><hlstd|`><hlkwd|Add<space|0.5em>><hlopt|(><hlstd|`><hlkwd|Mult<space|0.5em>><hlopt|(><hlstd|`><hlkwd|Num<space|0.5em>><hlnum|3><hlopt|,<space|0.5em>><hlstd|`><hlkwd|Var<space|0.5em>><hlstr|"x"><hlopt|),<space|0.5em>><hlstd|`><hlkwd|Num<space|0.5em>><hlnum|1><hlopt|)<space|0.5em>:<space|0.5em>><hlstd|expr<textunderscore>t><hlopt|)><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|e<textunderscore>test2<space|0.5em>><hlopt|=<space|0.5em>><hlstd|eval2<space|0.5em>><hlopt|[><hlstr|"x"><hlopt|,<space|0.5em>><hlstd|`><hlkwd|Num<space|0.5em>><hlnum|2><hlopt|]<space|0.5em>><hlstd|test2><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|fv<textunderscore>test2<space|0.5em>><hlopt|=<space|0.5em>><hlstd|freevars2<space|0.5em>test2><hlendline|><next-line><hlendline|><next-line><hlkwa|type<space|0.5em>><hlstd|'a<space|0.5em>lexpr<space|0.5em>><hlopt|=<space|0.5em>[><hlstd|'a<space|0.5em>lambda<space|0.5em><hlbar><space|0.5em>'a<space|0.5em>expr><hlopt|]><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|eval<textunderscore>lexpr<space|0.5em>eval<textunderscore>rec<space|0.5em>subst<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'a<space|0.5em>lexpr<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|'a<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|function><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>><hlopt|#><hlstd|lambda<space|0.5em>><hlkwa|as<space|0.5em>><hlstd|x<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|eval<textunderscore>lambda<space|0.5em>eval<textunderscore>rec<space|0.5em>subst<space|0.5em>x<hlendline|><next-line><space|0.5em><space|0.5em><hlbar><space|0.5em>><hlopt|#><hlstd|expr<space|0.5em>><hlkwa|as<space|0.5em>><hlstd|x<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|eval<textunderscore>expr<space|0.5em>eval<textunderscore>rec<space|0.5em>subst<space|0.5em>x><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|freevars<textunderscore>lexpr<space|0.5em>freevars<textunderscore>rec<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'a<space|0.5em>lexpr<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|'b<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|function><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>><hlopt|#><hlstd|lambda<space|0.5em>><hlkwa|as<space|0.5em>><hlstd|x<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|freevars<textunderscore>lambda<space|0.5em>freevars<textunderscore>rec<space|0.5em>x<hlendline|><next-line><space|0.5em><space|0.5em><hlbar><space|0.5em>><hlopt|#><hlstd|expr<space|0.5em>><hlkwa|as<space|0.5em>><hlstd|x<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|freevars<textunderscore>expr<space|0.5em>freevars<textunderscore>rec<space|0.5em>x><hlendline|><next-line><hlendline|><next-line><hlkwa|type<space|0.5em>><hlstd|lexpr<textunderscore>t<space|0.5em>><hlopt|=<space|0.5em>><hlstd|lexpr<textunderscore>t<space|0.5em>lexpr><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>rec<space|0.5em>><hlstd|eval3<space|0.5em>subst<space|0.5em>e<space|0.5em>><hlopt|:<space|0.5em>><hlstd|lexpr<textunderscore>t<space|0.5em>><hlopt|=<space|0.5em>><hlstd|eval<textunderscore>lexpr<space|0.5em>eval3<space|0.5em>subst<space|0.5em>e><hlendline|><next-line><hlkwa|let<space|0.5em>rec<space|0.5em>><hlstd|freevars3<space|0.5em>><hlopt|(><hlstd|e<space|0.5em>><hlopt|:<space|0.5em>><hlstd|lexpr<textunderscore>t><hlopt|)<space|0.5em>=<space|0.5em>><hlstd|freevars<textunderscore>lexpr<space|0.5em>freevars3<space|0.5em>e><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|test3<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlopt|(><hlstd|`><hlkwd|App<space|0.5em>><hlopt|(><hlstd|`><hlkwd|Abs<space|0.5em>><hlopt|(><hlstr|"x"><hlopt|,<space|0.5em>><hlstd|`><hlkwd|Add<space|0.5em>><hlopt|(><hlstd|`><hlkwd|Mult<space|0.5em>><hlopt|(><hlstd|`><hlkwd|Num<space|0.5em>><hlnum|3><hlopt|,<space|0.5em>><hlstd|`><hlkwd|Var<space|0.5em>><hlstr|"x"><hlopt|),<space|0.5em>><hlstd|`><hlkwd|Num<space|0.5em>><hlnum|1><hlopt|)),><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>`><hlkwd|Num<space|0.5em>><hlnum|2><hlopt|)<space|0.5em>:<space|0.5em>><hlstd|lexpr<textunderscore>t><hlopt|)><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|e<textunderscore>test3<space|0.5em>><hlopt|=<space|0.5em>><hlstd|eval3<space|0.5em>><hlopt|[]<space|0.5em>><hlstd|test3><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|fv<textunderscore>test3<space|0.5em>><hlopt|=<space|0.5em>><hlstd|freevars3<space|0.5em>test3><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|e<textunderscore>old<textunderscore>test<space|0.5em>><hlopt|=<space|0.5em>><hlstd|eval3<space|0.5em>><hlopt|[]<space|0.5em>(><hlstd|test2<space|0.5em>><hlopt|:\<gtr\><space|0.5em>><hlstd|lexpr<textunderscore>t><hlopt|)><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|fv<textunderscore>old<textunderscore>test<space|0.5em>><hlopt|=<space|0.5em>><hlstd|freevars3<space|0.5em>><hlopt|(><hlstd|test2<space|0.5em>><hlopt|:\<gtr\><space|0.5em>><hlstd|lexpr<textunderscore>t><hlopt|)><hlendline|>
  </hidden>|<\hidden>
    <tit|Polymorphic Variants and Recursive Modules>

    <\itemize>
      <item>Using recursive modules, we can clean-up the confusing or
      cluttering aspects of tying the recursive knots: type variables,
      recursive call arguments.

      <item>We need <em|private types>, which for objects and polymorphic
      variants means <em|private rows>.

      <\itemize>
        <item>We can conceive of open row types, e.g. <hlopt|[\<gtr\>
        ><hlstd|`><hlkwd|Int<space|0.5em>><hlkwa|of<space|0.5em>><hlkwb|int<space|0.5em>><hlstd|<hlbar><space|0.5em>`><hlkwd|String<space|0.5em>><hlkwa|of<space|0.5em>><hlkwb|string><hlopt|]>
        as using a <em|row variable>, e.g. <verbatim|'a>:

        <hlopt|[><hlstd|`><hlkwd|Int<space|0.5em>><hlkwa|of<space|0.5em>><hlkwb|int<space|0.5em>><hlstd|<hlbar><space|0.5em>`><hlkwd|String<space|0.5em>><hlkwa|of<space|0.5em>><hlkwb|string<space|0.5em>><hlstd|<hlbar><space|0.5em>'a><hlopt|]><hlendline|>

        and then of private row types as abstracting the row variable:

        <hlkwa|type<space|0.5em>><hlstd|t<textunderscore>row><hlendline|><next-line><hlkwa|type<space|0.5em>><hlstd|t<space|0.5em>><hlopt|=<space|0.5em>[><hlstd|`><hlkwd|Int<space|0.5em>><hlkwa|of<space|0.5em>><hlkwb|int<space|0.5em>><hlstd|<hlbar><space|0.5em>`><hlkwd|String<space|0.5em>><hlkwa|of<space|0.5em>><hlkwb|string<space|0.5em>><hlstd|<hlbar><space|0.5em>t<textunderscore>row><hlopt|]><hlendline|>

        But the actual formalization of private row types is more complex.
      </itemize>

      <item>Penalty points:

      <\itemize>
        <item>We still need to tie the recursive knots for types, for example
        <hlkwa|private<space|0.5em>><hlopt|[\<gtr\><space|0.5em>><hlstd|'a<space|0.5em>lambda><hlopt|]<space|0.5em>><hlkwa|as<space|0.5em>><hlstd|'a>.

        <item>There can be slight time costs due to the use of functors and
        dispatch on merging of sub-languages.
      </itemize>

      <item>Verdict: a clean solution, best place.
    </itemize>

    <hlkwa|type<space|0.5em>><hlstd|var<space|0.5em>><hlopt|=<space|0.5em>[><hlstd|`><hlkwd|Var<space|0.5em>><hlkwa|of<space|0.5em>><hlkwb|string><hlopt|]><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|eval<textunderscore>var<space|0.5em>subst<space|0.5em>><hlopt|(><hlstd|`><hlkwd|Var<space|0.5em>><hlstd|s<space|0.5em>><hlkwa|as<space|0.5em>><hlstd|v<space|0.5em>><hlopt|:<space|0.5em>><hlstd|var><hlopt|)<space|0.5em>=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|try<space|0.5em>><hlkwc|List><hlopt|.><hlstd|assoc<space|0.5em>s<space|0.5em>subst<space|0.5em>><hlkwa|with<space|0.5em>><hlkwd|Not<textunderscore>found<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|v><hlendline|><next-line><hlendline|><next-line><hlkwa|type<space|0.5em>><hlstd|'a<space|0.5em>lambda<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlopt|[><hlstd|`><hlkwd|Var<space|0.5em>><hlkwa|of<space|0.5em>><hlkwb|string<space|0.5em>><hlstd|<hlbar><space|0.5em>`><hlkwd|Abs<space|0.5em>><hlkwa|of<space|0.5em>><hlkwb|string<space|0.5em>><hlopt|*<space|0.5em>><hlstd|'a<space|0.5em><hlbar><space|0.5em>`><hlkwd|App<space|0.5em>><hlkwa|of<space|0.5em>><hlstd|'a<space|0.5em>><hlopt|*<space|0.5em>><hlstd|'a><hlopt|]><hlendline|><next-line><hlendline|><next-line><hlkwa|module<space|0.5em>type<space|0.5em>><hlkwd|Eval<space|0.5em>><hlopt|=><hlendline|><next-line><hlkwa|sig<space|0.5em>type<space|0.5em>><hlstd|exp<space|0.5em>><hlkwa|val<space|0.5em>><hlstd|eval<space|0.5em>><hlopt|:<space|0.5em>(><hlkwb|string<space|0.5em>><hlopt|*<space|0.5em>><hlstd|exp><hlopt|)<space|0.5em>><hlstd|list<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|exp<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|exp<space|0.5em>><hlkwa|end><hlendline|><next-line><hlendline|><next-line><hlkwa|module<space|0.5em>><hlkwd|LF><hlopt|(><hlkwd|X<space|0.5em>><hlopt|:<space|0.5em>><hlkwd|Eval<space|0.5em>><hlkwa|with<space|0.5em>type<space|0.5em>><hlstd|exp<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|private<space|0.5em>><hlopt|[\<gtr\><space|0.5em>><hlstd|'a<space|0.5em>lambda><hlopt|]<space|0.5em>><hlkwa|as<space|0.5em>><hlstd|'a><hlopt|)<space|0.5em>=><hlendline|><next-line><hlkwa|struct><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|type<space|0.5em>><hlstd|exp<space|0.5em>><hlopt|=<space|0.5em>><hlkwc|X><hlopt|.><hlstd|exp<space|0.5em>lambda<hlendline|><next-line><hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|gensym<space|0.5em>><hlopt|=<space|0.5em>><next-line><hlkwa|
    \ \ \ let<space|0.5em>><hlstd|n<space|0.5em>><hlopt|=<space|0.5em>><hlkwb|ref<space|0.5em>><hlnum|0<space|0.5em>><hlkwa|in<space|0.5em>fun<space|0.5em>><hlopt|()<space|0.5em>-<no-break>\<gtr\><space|0.5em>><hlstd|incr<space|0.5em>n><hlopt|;<space|0.5em>><hlstr|"<textunderscore>"><hlstd|<space|0.5em><hlcircum><space|0.5em>string<textunderscore>of<textunderscore>int<space|0.5em>><hlopt|!><hlstd|n<hlendline|><next-line><hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|eval<space|0.5em>subst<space|0.5em>><hlopt|:<space|0.5em>><hlstd|exp<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwc|X><hlopt|.><hlstd|exp<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|function><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>><hlopt|#><hlstd|var<space|0.5em>><hlkwa|as<space|0.5em>><hlstd|v<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|eval<textunderscore>var<space|0.5em>subst<space|0.5em>v<hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|App<space|0.5em>><hlopt|(><hlstd|l1><hlopt|,<space|0.5em>><hlstd|l2><hlopt|)<space|0.5em>-\<gtr\>><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|l2'<space|0.5em>><hlopt|=<space|0.5em>><hlkwc|X><hlopt|.><hlstd|eval<space|0.5em>subst<space|0.5em>l2<space|0.5em>><hlkwa|in><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|(><hlkwa|match<space|0.5em>><hlkwc|X><hlopt|.><hlstd|eval<space|0.5em>subst<space|0.5em>l1<space|0.5em>><hlkwa|with><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|Abs<space|0.5em>><hlopt|(><hlstd|s><hlopt|,<space|0.5em>><hlstd|body><hlopt|)<space|0.5em>-\<gtr\>><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwc|X><hlopt|.><hlstd|eval<space|0.5em>><hlopt|[><hlstd|s><hlopt|,<space|0.5em>><hlstd|l2'><hlopt|]<space|0.5em>><hlstd|body<hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>l1'<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|`><hlkwd|App<space|0.5em>><hlopt|(><hlstd|l1'><hlopt|,<space|0.5em>><hlstd|l2'><hlopt|))><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|Abs<space|0.5em>><hlopt|(><hlstd|s><hlopt|,<space|0.5em>><hlstd|l1><hlopt|)<space|0.5em>-\<gtr\>><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|s'<space|0.5em>><hlopt|=<space|0.5em>><hlstd|gensym<space|0.5em>><hlopt|()<space|0.5em>><hlkwa|in><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>`><hlkwd|Abs<space|0.5em>><hlopt|(><hlstd|s'><hlopt|,<space|0.5em>><hlkwc|X><hlopt|.><hlstd|eval<space|0.5em>><hlopt|((><hlstd|s><hlopt|,<space|0.5em>><hlstd|`><hlkwd|Var<space|0.5em>><hlstd|s'><hlopt|)::><hlstd|subst><hlopt|)<space|0.5em>><hlstd|l1><hlopt|)><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlkwa|module<space|0.5em>rec<space|0.5em>><hlkwd|Lambda<space|0.5em>><hlopt|:<space|0.5em>(><hlkwd|Eval<space|0.5em>><hlkwa|with<space|0.5em>type<space|0.5em>><hlstd|exp<space|0.5em>><hlopt|=<space|0.5em>><hlkwc|Lambda><hlopt|.><hlstd|exp<space|0.5em>lambda><hlopt|)<space|0.5em>=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwd|LF><hlopt|(><hlkwd|Lambda><hlopt|)><hlendline|><next-line><hlendline|><next-line><hlkwa|module<space|0.5em>type<space|0.5em>><hlkwd|FreeVars<space|0.5em>><hlopt|=><hlendline|><next-line><hlkwa|sig<space|0.5em>type<space|0.5em>><hlstd|exp<space|0.5em>><hlkwa|val<space|0.5em>><hlstd|freevars<space|0.5em>><hlopt|:<space|0.5em>><hlstd|exp<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwb|string<space|0.5em>><hlstd|list<space|0.5em>><hlkwa|end><hlendline|><next-line><hlendline|><next-line><hlkwa|module<space|0.5em>><hlkwd|LFVF><hlopt|(><hlkwd|X<space|0.5em>><hlopt|:<space|0.5em>><hlkwd|FreeVars<space|0.5em>><hlkwa|with<space|0.5em>type<space|0.5em>><hlstd|exp<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|private<space|0.5em>><hlopt|[\<gtr\><space|0.5em>><hlstd|'a<space|0.5em>lambda><hlopt|]<space|0.5em>><hlkwa|as<space|0.5em>><hlstd|'a><hlopt|)<space|0.5em>=><hlendline|><next-line><hlkwa|struct><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|type<space|0.5em>><hlstd|exp<space|0.5em>><hlopt|=<space|0.5em>><hlkwc|X><hlopt|.><hlstd|exp<space|0.5em>lambda<hlendline|><next-line><hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|freevars<space|0.5em>><hlopt|:<space|0.5em>><hlstd|exp<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|'b<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|function><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|Var<space|0.5em>><hlstd|v<space|0.5em>><hlopt|-\<gtr\><space|0.5em>[><hlstd|v><hlopt|]><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|App<space|0.5em>><hlopt|(><hlstd|l1><hlopt|,<space|0.5em>><hlstd|l2><hlopt|)<space|0.5em>-\<gtr\><space|0.5em>><hlkwc|X><hlopt|.><hlstd|freevars<space|0.5em>l1<space|0.5em>><hlopt|@<space|0.5em>><hlkwc|X><hlopt|.><hlstd|freevars<space|0.5em>l2<hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|Abs<space|0.5em>><hlopt|(><hlstd|s><hlopt|,<space|0.5em>><hlstd|l1><hlopt|)<space|0.5em>-\<gtr\>><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwc|List><hlopt|.><hlstd|filter<space|0.5em>><hlopt|(><hlkwa|fun<space|0.5em>><hlstd|v<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|v<space|0.5em>><hlopt|\<less\>\<gtr\><space|0.5em>><hlstd|s><hlopt|)<space|0.5em>(><hlkwc|X><hlopt|.><hlstd|freevars<space|0.5em>l1><hlopt|)><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlkwa|module<space|0.5em>rec<space|0.5em>><hlkwd|LambdaFV<space|0.5em>><hlopt|:<space|0.5em>(><hlkwd|FreeVars<space|0.5em>><hlkwa|with<space|0.5em>type<space|0.5em>><hlstd|exp<space|0.5em>><hlopt|=<space|0.5em>><hlkwc|LambdaFV><hlopt|.><hlstd|exp<space|0.5em>lambda><hlopt|)<space|0.5em>=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwd|LFVF><hlopt|(><hlkwd|LambdaFV><hlopt|)><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|test1<space|0.5em>><hlopt|=<space|0.5em>(><hlstd|`><hlkwd|App<space|0.5em>><hlopt|(><hlstd|`><hlkwd|Abs<space|0.5em>><hlopt|(><hlstr|"x"><hlopt|,<space|0.5em>><hlstd|`><hlkwd|Var<space|0.5em>><hlstr|"x"><hlopt|),<space|0.5em>><hlstd|`><hlkwd|Var<space|0.5em>><hlstr|"y"><hlopt|)<space|0.5em>:<space|0.5em>><hlkwc|Lambda><hlopt|.><hlstd|exp><hlopt|)><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|e<textunderscore>test<space|0.5em>><hlopt|=<space|0.5em>><hlkwc|Lambda><hlopt|.><hlstd|eval<space|0.5em>><hlopt|[]<space|0.5em>><hlstd|test1><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|fv<textunderscore>test<space|0.5em>><hlopt|=<space|0.5em>><hlkwc|LambdaFV><hlopt|.><hlstd|freevars<space|0.5em>test1><hlendline|><next-line><hlendline|><next-line><hlkwa|type<space|0.5em>><hlstd|'a<space|0.5em>expr<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlopt|[><hlstd|`><hlkwd|Var<space|0.5em>><hlkwa|of<space|0.5em>><hlkwb|string<space|0.5em>><hlstd|<hlbar><space|0.5em>`><hlkwd|Num<space|0.5em>><hlkwa|of<space|0.5em>><hlkwb|int<space|0.5em>><hlstd|<hlbar><space|0.5em>`><hlkwd|Add<space|0.5em>><hlkwa|of<space|0.5em>><hlstd|'a<space|0.5em>><hlopt|*<space|0.5em>><hlstd|'a<space|0.5em><hlbar><space|0.5em>`><hlkwd|Mult<space|0.5em>><hlkwa|of<space|0.5em>><hlstd|'a<space|0.5em>><hlopt|*<space|0.5em>><hlstd|'a><hlopt|]><hlendline|><next-line><hlendline|><next-line><hlkwa|module<space|0.5em>type<space|0.5em>><hlkwd|Operations<space|0.5em>><hlopt|=><hlendline|><next-line><hlkwa|sig<space|0.5em>include<space|0.5em>><hlkwd|Eval<space|0.5em>><hlkwa|include<space|0.5em>><hlkwd|FreeVars<space|0.5em>><hlkwa|with<space|0.5em>type<space|0.5em>><hlstd|exp<space|0.5em>><hlopt|:=<space|0.5em>><hlstd|exp<space|0.5em>><hlkwa|end><hlendline|><next-line><hlendline|><next-line><hlkwa|module<space|0.5em>><hlkwd|EF><hlopt|(><hlkwd|X<space|0.5em>><hlopt|:<space|0.5em>><hlkwd|Operations<space|0.5em>><hlkwa|with<space|0.5em>type<space|0.5em>><hlstd|exp<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|private<space|0.5em>><hlopt|[\<gtr\><space|0.5em>><hlstd|'a<space|0.5em>expr><hlopt|]<space|0.5em>><hlkwa|as<space|0.5em>><hlstd|'a><hlopt|)<space|0.5em>=><hlendline|><next-line><hlkwa|struct><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|type<space|0.5em>><hlstd|exp<space|0.5em>><hlopt|=<space|0.5em>><hlkwc|X><hlopt|.><hlstd|exp<space|0.5em>expr<hlendline|><next-line><hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|map<textunderscore>expr<space|0.5em>f<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|function><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>><hlopt|#><hlstd|var<space|0.5em>><hlkwa|as<space|0.5em>><hlstd|v<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|v<hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|Num<space|0.5em>><hlstd|<textunderscore><space|0.5em>><hlkwa|as<space|0.5em>><hlstd|n<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|n<hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|Add<space|0.5em>><hlopt|(><hlstd|e1><hlopt|,<space|0.5em>><hlstd|e2><hlopt|)<space|0.5em>-\<gtr\><space|0.5em>><hlstd|`><hlkwd|Add<space|0.5em>><hlopt|(><hlstd|f<space|0.5em>e1><hlopt|,<space|0.5em>><hlstd|f<space|0.5em>e2><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|Mult<space|0.5em>><hlopt|(><hlstd|e1><hlopt|,<space|0.5em>><hlstd|e2><hlopt|)<space|0.5em>-\<gtr\><space|0.5em>><hlstd|`><hlkwd|Mult<space|0.5em>><hlopt|(><hlstd|f<space|0.5em>e1><hlopt|,<space|0.5em>><hlstd|f<space|0.5em>e2><hlopt|)><hlendline|><next-line><hlstd|<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|eval<space|0.5em>subst<space|0.5em>><hlopt|(><hlstd|e<space|0.5em>><hlopt|:<space|0.5em>><hlstd|exp><hlopt|)<space|0.5em>:<space|0.5em>><hlkwc|X><hlopt|.><hlstd|exp<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|match<space|0.5em>><hlstd|map<textunderscore>expr<space|0.5em>><hlopt|(><hlkwc|X><hlopt|.><hlstd|eval<space|0.5em>subst><hlopt|)<space|0.5em>><hlstd|e<space|0.5em>><hlkwa|with><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>><hlopt|#><hlstd|var<space|0.5em>><hlkwa|as<space|0.5em>><hlstd|v<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|eval<textunderscore>var<space|0.5em>subst<space|0.5em>v<hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|Add<space|0.5em>><hlopt|(><hlstd|`><hlkwd|Num<space|0.5em>><hlstd|m><hlopt|,<space|0.5em>><hlstd|`><hlkwd|Num<space|0.5em>><hlstd|n><hlopt|)<space|0.5em>-\<gtr\><space|0.5em>><hlstd|`><hlkwd|Num<space|0.5em>><hlopt|(><hlstd|m<space|0.5em>><hlopt|+<space|0.5em>><hlstd|n><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|Mult<space|0.5em>><hlopt|(><hlstd|`><hlkwd|Num<space|0.5em>><hlstd|m><hlopt|,<space|0.5em>><hlstd|`><hlkwd|Num<space|0.5em>><hlstd|n><hlopt|)<space|0.5em>-\<gtr\><space|0.5em>><hlstd|`><hlkwd|Num<space|0.5em>><hlopt|(><hlstd|m<space|0.5em>><hlopt|*<space|0.5em>><hlstd|n><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>e<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|e<hlendline|><next-line><hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|freevars<space|0.5em>><hlopt|:<space|0.5em>><hlstd|exp<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|'b<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|function><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|Var<space|0.5em>><hlstd|v<space|0.5em>><hlopt|-\<gtr\><space|0.5em>[><hlstd|v><hlopt|]><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|Num<space|0.5em>><hlstd|<textunderscore><space|0.5em>><hlopt|-\<gtr\><space|0.5em>[]><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>`><hlkwd|Add<space|0.5em>><hlopt|(><hlstd|e1><hlopt|,<space|0.5em>><hlstd|e2><hlopt|)<space|0.5em>><hlstd|<hlbar><space|0.5em>`><hlkwd|Mult<space|0.5em>><hlopt|(><hlstd|e1><hlopt|,<space|0.5em>><hlstd|e2><hlopt|)<space|0.5em>-\<gtr\><space|0.5em>><hlkwc|X><hlopt|.><hlstd|freevars<space|0.5em>e1<space|0.5em>><hlopt|@<space|0.5em>><hlkwc|X><hlopt|.><hlstd|freevars<space|0.5em>e2><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlkwa|module<space|0.5em>rec<space|0.5em>><hlkwd|Expr<space|0.5em>><hlopt|:<space|0.5em>(><hlkwd|Operations<space|0.5em>><hlkwa|with<space|0.5em>type<space|0.5em>><hlstd|exp<space|0.5em>><hlopt|=<space|0.5em>><hlkwc|Expr><hlopt|.><hlstd|exp<space|0.5em>expr><hlopt|)<space|0.5em>=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwd|EF><hlopt|(><hlkwd|Expr><hlopt|)><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|test2<space|0.5em>><hlopt|=<space|0.5em>(><hlstd|`><hlkwd|Add<space|0.5em>><hlopt|(><hlstd|`><hlkwd|Mult<space|0.5em>><hlopt|(><hlstd|`><hlkwd|Num<space|0.5em>><hlnum|3><hlopt|,<space|0.5em>><hlstd|`><hlkwd|Var<space|0.5em>><hlstr|"x"><hlopt|),<space|0.5em>><hlstd|`><hlkwd|Num<space|0.5em>><hlnum|1><hlopt|)<space|0.5em>:<space|0.5em>><hlkwc|Expr><hlopt|.><hlstd|exp><hlopt|)><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|e<textunderscore>test2<space|0.5em>><hlopt|=<space|0.5em>><hlkwc|Expr><hlopt|.><hlstd|eval<space|0.5em>><hlopt|[><hlstr|"x"><hlopt|,<space|0.5em>><hlstd|`><hlkwd|Num<space|0.5em>><hlnum|2><hlopt|]<space|0.5em>><hlstd|test2><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|fvs<textunderscore>test2<space|0.5em>><hlopt|=<space|0.5em>><hlkwc|Expr><hlopt|.><hlstd|freevars<space|0.5em>test2><hlendline|><next-line><hlendline|><next-line><hlkwa|type<space|0.5em>><hlstd|'a<space|0.5em>lexpr<space|0.5em>><hlopt|=<space|0.5em>[><hlstd|'a<space|0.5em>lambda<space|0.5em><hlbar><space|0.5em>'a<space|0.5em>expr><hlopt|]><hlendline|><next-line><hlendline|><next-line><hlkwa|module<space|0.5em>><hlkwd|LEF><hlopt|(><hlkwd|X<space|0.5em>><hlopt|:<space|0.5em>><hlkwd|Operations<space|0.5em>><hlkwa|with<space|0.5em>type<space|0.5em>><hlstd|exp<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|private<space|0.5em>><hlopt|[\<gtr\><space|0.5em>><hlstd|'a<space|0.5em>lexpr><hlopt|]<space|0.5em>><hlkwa|as<space|0.5em>><hlstd|'a><hlopt|)<space|0.5em>=><hlendline|><next-line><hlkwa|struct><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|type<space|0.5em>><hlstd|exp<space|0.5em>><hlopt|=<space|0.5em>><hlkwc|X><hlopt|.><hlstd|exp<space|0.5em>lexpr<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|module<space|0.5em>><hlkwd|LambdaX<space|0.5em>><hlopt|=<space|0.5em>><hlkwd|LF><hlopt|(><hlkwd|X><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|module<space|0.5em>><hlkwd|LambdaFVX<space|0.5em>><hlopt|=<space|0.5em>><hlkwd|LFVF><hlopt|(><hlkwd|X><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|module<space|0.5em>><hlkwd|ExprX<space|0.5em>><hlopt|=<space|0.5em>><hlkwd|EF><hlopt|(><hlkwd|X><hlopt|)><hlendline|><next-line><hlstd|<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|eval<space|0.5em>subst<space|0.5em>><hlopt|:<space|0.5em>><hlstd|exp<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwc|X><hlopt|.><hlstd|exp<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|function><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>><hlopt|#><hlkwc|LambdaX><hlopt|.><hlstd|exp<space|0.5em>><hlkwa|as<space|0.5em>><hlstd|x<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwc|LambdaX><hlopt|.><hlstd|eval<space|0.5em>subst<space|0.5em>x<hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>><hlopt|#><hlkwc|ExprX><hlopt|.><hlstd|exp<space|0.5em>><hlkwa|as<space|0.5em>><hlstd|x<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwc|ExprX><hlopt|.><hlstd|eval<space|0.5em>subst<space|0.5em>x<hlendline|><next-line><hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|freevars<space|0.5em>><hlopt|:<space|0.5em>><hlstd|exp<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|'b<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|function><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>><hlopt|#><hlstd|lambda<space|0.5em>><hlkwa|as<space|0.5em>><hlstd|x<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwc|LambdaFVX><hlopt|.>freevars<space|0.5em>x<hlendline|Either
    of <hlopt|#><hlstd|lambda> or <hlopt|#><hlkwc|LambdaX><hlopt|.><hlstd|exp>
    is fine.><next-line><verbatim|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlbar><space|0.5em><hlopt|#><hlstd|expr<space|0.5em>><hlkwa|as<space|0.5em>><hlstd|x<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwc|ExprX><hlopt|.><hlstd|freevars<space|0.5em>x><hlendline|Either
    of <hlopt|#><hlstd|expr> or <hlopt|#><hlkwc|ExprX><hlopt|.><hlstd|exp> is
    fine.><next-line><hlkwa|end><hlendline|><next-line><hlkwa|module<space|0.5em>rec<space|0.5em>><hlkwd|LExpr<space|0.5em>><hlopt|:<space|0.5em>(><hlkwd|Operations<space|0.5em>><hlkwa|with<space|0.5em>type<space|0.5em>><hlstd|exp<space|0.5em>><hlopt|=<space|0.5em>><hlkwc|LExpr><hlopt|.><hlstd|exp<space|0.5em>lexpr><hlopt|)<space|0.5em>=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwd|LEF><hlopt|(><hlkwd|LExpr><hlopt|)><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|test3<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlopt|(><hlstd|`><hlkwd|App<space|0.5em>><hlopt|(><hlstd|`><hlkwd|Abs<space|0.5em>><hlopt|(><hlstr|"x"><hlopt|,<space|0.5em>><hlstd|`><hlkwd|Add<space|0.5em>><hlopt|(><hlstd|`><hlkwd|Mult<space|0.5em>><hlopt|(><hlstd|`><hlkwd|Num<space|0.5em>><hlnum|3><hlopt|,<space|0.5em>><hlstd|`><hlkwd|Var<space|0.5em>><hlstr|"x"><hlopt|),<space|0.5em>><hlstd|`><hlkwd|Num<space|0.5em>><hlnum|1><hlopt|)),><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>`><hlkwd|Num<space|0.5em>><hlnum|2><hlopt|)<space|0.5em>:<space|0.5em>><hlkwc|LExpr><hlopt|.><hlstd|exp><hlopt|)><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|e<textunderscore>test3<space|0.5em>><hlopt|=<space|0.5em>><hlkwc|LExpr><hlopt|.><hlstd|eval<space|0.5em>><hlopt|[]<space|0.5em>><hlstd|test3><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|fv<textunderscore>test3<space|0.5em>><hlopt|=<space|0.5em>><hlkwc|LExpr><hlopt|.><hlstd|freevars<space|0.5em>test3><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|e<textunderscore>old<textunderscore>test<space|0.5em>><hlopt|=<space|0.5em>><hlkwc|LExpr><hlopt|.><hlstd|eval<space|0.5em>><hlopt|[]<space|0.5em>(><hlstd|test2<space|0.5em>><hlopt|:\<gtr\><space|0.5em>><hlkwc|LExpr><hlopt|.><hlstd|exp><hlopt|)><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|fv<textunderscore>old<textunderscore>test<space|0.5em>><hlopt|=<space|0.5em>><hlkwc|LExpr><hlopt|.><hlstd|freevars<space|0.5em>><hlopt|(><hlstd|test2<space|0.5em>><hlopt|:\<gtr\><space|0.5em>><hlkwc|LExpr><hlopt|.><hlstd|exp><hlopt|)><hlendline|>
  </hidden>|<\hidden>
    <tit|Digression: Parser Combinators>

    <\itemize>
      <item>We have done parsing using external languages <name|OCamlLex> and
      <name|Menhir>, now we will look at parsers written directly in OCaml.

      <item>Language <em|combinators> are ways defining languages by
      composing definitions of smaller languages. For example, the
      combinators of the <em|Extended Backus-Naur Form> notation are:

      <\itemize>
        <item>concatenation: <math|S=A ,B> stands for <math|S=<around*|{|a
        b\|a\<in\>A,b\<in\>b|}>>,

        <item>alternation: <math|S=A\|B> stands for
        <math|S=<around*|{|a\|a\<in\>A\<vee\>a\<in\>B|}>>,

        <item>option: <math|S=<around*|[|A|]>> stands for
        <math|S=<around*|{|\<epsilon\>|}>\<cup\>A>, where <math|\<epsilon\>>
        is an empty string,

        <item>repetition: <math|S=<around*|{|A|}>> stands for
        <math|S=<around*|{|\<epsilon\>|}>\<cup\><around*|{|a
        s\|a\<in\>A,s\<in\>S|}>>,

        <item>terminal string: <math|S=<rprime|''>a<rprime|''>> stands for
        <math|S=<around*|{|a|}>>.
      </itemize>

      <item>Parsers implemented directly in a functional programming paradigm
      are functions from character streams to the parsed values.
      Algorithmically they are <em|recursive descent parsers>.

      <item><em|Parser combinators> approach builds parsers as <em|monad
      plus> values:

      <\itemize>
        <item>Bind: <verbatim|<hlkwa|val> <hlopt|(\<gtr\>\<gtr\>=)> <hlopt|:>
        'a parser <hlopt|-\<gtr\>> <hlopt|(>'a <hlopt|-\<gtr\>> 'b
        parser<hlopt|)> <hlopt|-\<gtr\>> 'b parser>

        <\itemize>
          <item><verbatim|p <hlopt|\<gtr\>\<gtr\>=> f> is a parser that first
          parses <verbatim|p>, and makes the result available for parsing
          <verbatim|f>.
        </itemize>

        <item>Return: <verbatim|<hlkwa|val> return <hlopt|:> 'a
        <hlopt|-\<gtr\>> 'a parser>

        <\itemize>
          <item><verbatim|return x> parses an empty string, symbolically
          <math|S=<around*|{|\<epsilon\>|}>>, and returns <verbatim|x>.
        </itemize>

        <item>MZero: <verbatim|<hlkwa|val> fail <hlopt|:> 'a parser>

        <\itemize>
          <item><verbatim|fail> fails to parse anything, symbolically
          <math|S=\<varnothing\>=<around*|{||}>>.
        </itemize>

        <item>MPlus: either <verbatim|<hlkwa|val> <hlopt|\<less\>\|\<gtr\>>
        <hlopt|:> 'a parser <hlopt|-\<gtr\>> 'a parser <hlopt|-\<gtr\>> 'a
        parser>,

        or <verbatim|<hlkwa|val> <hlopt|\<less\>\|\<gtr\>> <hlopt|:> 'a
        parser <hlopt|-\<gtr\>> 'b parser <hlopt|-\<gtr\>>
        <hlopt|(>'a<hlopt|,> 'b<hlopt|)> choice parser>

        <\itemize>
          <item><verbatim|p <hlopt|\<less\>\|\<gtr\>> q> tries <verbatim|p>,
          and if <verbatim|p> succeeds, its result is returned, otherwise the
          parser <verbatim|q> is used.
        </itemize>
      </itemize>

      The only non-monad-plus operation that has to be built into the monad
      is some way to consume a single character from the input stream, for
      example:

      <\itemize>
        <item><verbatim|<hlkwa|val> satisfy <hlopt|:> <hlopt|(>char
        <hlopt|-\<gtr\>> bool<hlopt|)> <hlopt|-\<gtr\>> char parser>

        <\itemize>
          <item><verbatim|satisfy <hlopt|(><hlkwa|fun> c <hlopt|-\<gtr\>> c =
          <hlopt|'>a<hlopt|')>> consumes the character ``a'' from the input
          stream and returns it; if the input stream starts with a different
          character, this parser fails.
        </itemize>
      </itemize>

      <item>Ordinary monadic recursive descent parsers <strong|do not allow>
      <em|left-<no-break>recursion>: if a cycle of calls not consuming any
      character can be entered when a parse failure should occur, the cycle
      will keep repeating.

      <\itemize>
        <item>For example, if we define numbers <math|N\<assign\>D<mid|\|>N
        D>, where <math|D> stands for digits, then a stack of uses of the
        rule <math|N\<rightarrow\>N D> will build up when the next character
        is not a digit.\ 

        <item>On the other hand, rules can share common prefixes.
      </itemize>
    </itemize>
  </hidden>|<\hidden>
    <tit|Parser Combinators: Implementation>

    <\itemize>
      <item>The parser monad is actually a composition of two monads:

      <\itemize>
        <item>the state monad for storing the stream of characters that
        remain to be parsed,

        <item>the backtracking monad for handling parse failures and
        ambiguities.
      </itemize>

      Alternatively, one can split the state monad into a reader monad with
      the parsed string, and a state monad with the parsing position.

      <item>Recall Lecture 8, especially slides 54-63.

      <item>On my new OPAM installation of OCaml, I run the parsing example
      with:

      <verbatim|ocamlbuild Plugin1.cmxs -pp "camlp4o
      /home/lukstafi/.opam/4.02.1/lib/monad-custom/pa_monad.cmo">

      <verbatim|ocamlbuild Plugin2.cmxs -pp "camlp4o
      /home/lukstafi/.opam/4.02.1/lib/monad-custom/pa_monad.cmo">

      <verbatim|ocamlbuild PluginRun.native -lib dynlink -pp "camlp4o
      ~/.opam/4.02.1/lib/monad-custom/pa_monad.cmo" -- "(3*(6+1))"
      _build/Plugin1.cmxs _build/Plugin2.cmxs>

      <item>We experiment with a different approach to <em|monad-plus>. The
      merits of this approach (or lack thereof) is left as an exercise.
      <em|lazy-monad-plus>:

      <hlkwa|val<space|0.5em>><hlstd|mplus<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'a<space|0.5em>monad><hlopt|
      -\<gtr\><space|0.5em>><hlstd|'a<space|0.5em>monad<space|0.5em>><hlkwc|Lazy><hlopt|.><hlstd|t<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|'a<space|0.5em>monad>
    </itemize>

    \;
  </hidden>|<\hidden>
    <tit|Parser Combinators: Implementation of lazy-monad-plus>

    <\itemize>
      <item>Excerpts from <verbatim|Monad.ml>. First an operation from
      <hlkwd|MonadPlusOps>.
    </itemize>

    <hlstd|<space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|msum<textunderscore>map<space|0.5em>f<space|0.5em>l<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwc|List><hlopt|.><verbatim|fold<textunderscore>left><hlendline|Folding
    left reversers the apparent order of composition,><next-line><verbatim|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|(><hlkwa|fun<space|0.5em>><hlstd|acc<space|0.5em>a<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|mplus<space|0.5em>acc<space|0.5em>><hlopt|(><hlkwa|lazy<space|0.5em>><hlopt|(><hlstd|f<space|0.5em>a><hlopt|)))<space|0.5em>><hlstd|mzero<space|0.5em>l><hlendline|order
    from <verbatim|l> is preserved.>

    <\itemize>
      <item>The implementation of the lazy-monad-plus.
    </itemize>

    <small|<hlkwa|type<space|0.5em>><hlstd|'a<space|0.5em>llist<space|0.5em>><hlopt|=<space|0.5em>><hlkwd|LNil<space|0.5em>><hlstd|<hlbar><space|0.5em>><hlkwd|LCons<space|0.5em>><hlkwa|of<space|0.5em>><hlstd|'a<space|0.5em>><hlopt|*<space|0.5em>><hlstd|'a<space|0.5em>llist<space|0.5em>><hlkwc|Lazy><hlopt|.><hlstd|t><hlendline|><next-line><hlkwa|let<space|0.5em>rec<space|0.5em>><hlstd|ltake<space|0.5em>n<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|function><hlendline|><next-line><hlstd|<space|0.5em><hlbar><space|0.5em>><hlkwd|LCons<space|0.5em>><hlopt|(><hlstd|a><hlopt|,<space|0.5em>><hlstd|l><hlopt|)<space|0.5em>><hlkwa|when<space|0.5em>><hlstd|n<space|0.5em>><hlopt|\<gtr\><space|0.5em>><hlnum|1<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|a><hlopt|::(><hlstd|ltake<space|0.5em>><hlopt|(><hlstd|n><hlopt|-><hlnum|1><hlopt|)<space|0.5em>(><hlkwc|Lazy><hlopt|.><hlstd|force<space|0.5em>l><hlopt|))><hlendline|><next-line><hlstd|<space|0.5em><hlbar><space|0.5em>><hlkwd|LCons<space|0.5em>><hlopt|(><hlstd|a><hlopt|,<space|0.5em>><hlstd|l><hlopt|)<space|0.5em>><hlkwa|when<space|0.5em>><hlstd|n<space|0.5em>><hlopt|=<space|0.5em>><hlnum|1<space|0.5em>><hlopt|-\<gtr\><space|0.5em>[><hlstd|a><hlopt|]><hlendline|Avoid
    forcing the tail if not needed.><next-line><hlstd|<space|0.5em><hlbar><hlunderscore>><hlopt|-\<gtr\><space|0.5em>[]><hlendline|><next-line><hlkwa|let<space|0.5em>rec<space|0.5em>><hlstd|lappend<space|0.5em>l1<space|0.5em>l2<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|match<space|0.5em>><hlstd|l1<space|0.5em>><hlkwa|with<space|0.5em>><hlkwd|LNil<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwc|Lazy><hlopt|.><verbatim|force<space|0.5em>l2><hlendline|><next-line><space|0.5em><space|0.5em><hlbar><space|0.5em><hlkwd|LCons<space|0.5em>><hlopt|(><hlstd|hd><hlopt|,<space|0.5em>><hlstd|tl><hlopt|)<space|0.5em>-\<gtr\>
    ><hlkwd|LCons<space|0.5em>><hlopt|(><hlstd|hd><hlopt|,<space|0.5em>><hlkwa|lazy<space|0.5em>><hlopt|(><hlstd|lappend<space|0.5em>><hlopt|(><hlkwc|Lazy><hlopt|.><hlstd|force<space|0.5em>tl><hlopt|)<space|0.5em>><hlstd|l2><hlopt|))><hlendline|><next-line><hlkwa|let<space|0.5em>rec<space|0.5em>><hlstd|lconcat<textunderscore>map<space|0.5em>f<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|function><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|LNil<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwd|LNil><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>><hlkwd|LCons<space|0.5em>><hlopt|(><hlstd|a><hlopt|,<space|0.5em>><hlstd|l><hlopt|)<space|0.5em>-\<gtr\>><hlstd|<space|0.5em>lappend<space|0.5em>><hlopt|(><hlstd|f<space|0.5em>a><hlopt|)<space|0.5em>(><hlkwa|lazy<space|0.5em>><hlopt|(><hlstd|lconcat<textunderscore>map<space|0.5em>f<space|0.5em>><hlopt|(><hlkwc|Lazy><hlopt|.><hlstd|force<space|0.5em>l><hlopt|)))><hlendline|><next-line><hlkwa|module<space|0.5em>><hlkwd|LListM<space|0.5em>><hlopt|=<space|0.5em>><hlkwd|MonadPlus<space|0.5em>><hlopt|(><hlkwa|struct><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|type<space|0.5em>><hlstd|'a<space|0.5em>t<space|0.5em>><hlopt|=<space|0.5em>><hlstd|'a<space|0.5em>llist<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|bind<space|0.5em>a<space|0.5em>b<space|0.5em>><hlopt|=<space|0.5em>><hlstd|lconcat<textunderscore>map<space|0.5em>b<space|0.5em>a<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|return<space|0.5em>a<space|0.5em>><hlopt|=<space|0.5em>><hlkwd|LCons<space|0.5em>><hlopt|(><hlstd|a><hlopt|,<space|0.5em>><hlkwa|lazy<space|0.5em>><hlkwd|LNil><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|mzero<space|0.5em>><hlopt|=<space|0.5em>><hlkwd|LNil><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|mplus<space|0.5em>><hlopt|=<space|0.5em>><hlstd|lappend><hlendline|><next-line><hlkwa|end><hlopt|)><hlendline|>>
  </hidden>|<\hidden>
    <tit|Parser Combinators: the <em|Parsec> Monad>

    <\itemize>
      <item>File <verbatim|Parsec.ml>:
    </itemize>

    <small|<hlkwa|open<space|0.5em>><hlkwd|Monad><hlendline|><next-line><hlkwa|module<space|0.5em>type<space|0.5em>><hlkwd|PARSE<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|sig><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|type<space|0.5em>><verbatim|'a<space|0.5em>backtracking<textunderscore>monad><hlendline|Name
    for the underlying monad-plus.><next-line><space|0.5em><space|0.5em><hlkwa|type<space|0.5em>><hlstd|'a<space|0.5em>parsing<textunderscore>state<space|0.5em>><hlopt|=<space|0.5em>><hlkwb|int<space|0.5em>><hlopt|-\<gtr\><space|0.5em>(><hlstd|'a<space|0.5em>><hlopt|*<space|0.5em>><hlkwb|int><hlopt|)<space|0.5em>><verbatim|backtracking<textunderscore>monad><hlendline|Processing
    state -- position.><next-line><space|0.5em><space|0.5em><hlkwa|type<space|0.5em>><hlstd|'a<space|0.5em>t<space|0.5em>><hlopt|=<space|0.5em>><hlkwb|string<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><verbatim|'a<space|0.5em>parsing<textunderscore>state><hlendline|Reader
    for the parsed text.><next-line><space|0.5em><space|0.5em><hlkwa|include<space|0.5em>><hlkwd|MONAD<textunderscore>PLUS<textunderscore>OPS><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|val<space|0.5em>><hlopt|(\<less\>><hlstd|<hlbar>><hlopt|\<gtr\>)<space|0.5em>:<space|0.5em>><hlstd|'a<space|0.5em>monad<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|'a<space|0.5em>monad<space|0.5em>><hlkwc|Lazy><hlopt|.><hlstd|t<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><verbatim|'a<space|0.5em>monad><hlendline|A
    synonym for <verbatim|mplus>.><next-line><space|0.5em><space|0.5em><hlkwa|val<space|0.5em>><hlstd|run<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'a<space|0.5em>monad<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|'a<space|0.5em>t<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|val<space|0.5em>><hlstd|runT<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'a<space|0.5em>monad<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwb|string<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwb|int<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|'a<space|0.5em>backtracking<textunderscore>monad<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|val<space|0.5em>><hlstd|satisfy<space|0.5em>><hlopt|:<space|0.5em>(><hlstd|char<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwb|bool><hlopt|)<space|0.5em>-\<gtr\><space|0.5em>><verbatim|char<space|0.5em>monad><hlendline|Consume
    a character of the specified class.><next-line><space|0.5em><space|0.5em><hlkwa|val<space|0.5em>><hlstd|end<textunderscore>of<textunderscore>text<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|unit<space|0.5em>><hlstd|monad><hlendline|Check
    for end of the processed text.><next-line><hlkwa|end><hlendline|><next-line><hlkwa|module<space|0.5em>><hlkwd|ParseT<space|0.5em>><hlopt|(><hlkwd|MP<space|0.5em>><hlopt|:<space|0.5em>><hlkwd|MONAD<textunderscore>PLUS<textunderscore>OPS><hlopt|)<space|0.5em>:><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwd|PARSE<space|0.5em>><hlkwa|with<space|0.5em>type<space|0.5em>><hlstd|'a<space|0.5em>backtracking<textunderscore>monad<space|0.5em>><hlopt|:=<space|0.5em>><hlstd|'a<space|0.5em>><hlkwc|MP><hlopt|.><hlstd|monad<space|0.5em>><hlopt|=><hlendline|><next-line><hlkwa|struct><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|type<space|0.5em>><hlstd|'a<space|0.5em>backtracking<textunderscore>monad<space|0.5em>><hlopt|=<space|0.5em>><hlstd|'a<space|0.5em>><hlkwc|MP><hlopt|.><hlstd|monad<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|type<space|0.5em>><hlstd|'a<space|0.5em>parsing<textunderscore>state<space|0.5em>><hlopt|=<space|0.5em>><hlkwb|int<space|0.5em>><hlopt|-\<gtr\><space|0.5em>(><hlstd|'a<space|0.5em>><hlopt|*<space|0.5em>><hlkwb|int><hlopt|)<space|0.5em>><hlkwc|MP><hlopt|.><hlstd|monad<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|module<space|0.5em>><hlkwd|M<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|struct><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|type<space|0.5em>><hlstd|'a<space|0.5em>t<space|0.5em>><hlopt|=<space|0.5em>><hlkwb|string<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|'a<space|0.5em>parsing<textunderscore>state<space|0.5em><hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|return<space|0.5em>a<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|fun<space|0.5em>><hlstd|s<space|0.5em>p<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwc|MP><hlopt|.><hlstd|return<space|0.5em>><hlopt|(><hlstd|a><hlopt|,<space|0.5em>><hlstd|p><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|bind<space|0.5em>m<space|0.5em>b<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|fun<space|0.5em>><hlstd|s<space|0.5em>p<space|0.5em>><hlopt|-\<gtr\>><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwc|MP><hlopt|.><hlstd|bind<space|0.5em>><hlopt|(><hlstd|m<space|0.5em>s<space|0.5em>p><hlopt|)<space|0.5em>(><hlkwa|fun<space|0.5em>><hlopt|(><hlstd|a><hlopt|,<space|0.5em>><hlstd|p'><hlopt|)<space|0.5em>-\<gtr\><space|0.5em>><hlstd|b<space|0.5em>a<space|0.5em>s<space|0.5em>p'><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|mzero<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|fun<space|0.5em>><hlstd|<textunderscore><space|0.5em>_<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwc|MP><hlopt|.><hlstd|mzero<hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|mplus<space|0.5em>ma<space|0.5em>mb<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|fun<space|0.5em>><hlstd|s<space|0.5em>p<space|0.5em>><hlopt|-\<gtr\>><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwc|MP><hlopt|.><hlstd|mplus<space|0.5em>><hlopt|(><hlstd|ma<space|0.5em>s<space|0.5em>p><hlopt|)<space|0.5em>(><hlkwa|lazy<space|0.5em>><hlopt|(><hlkwc|Lazy><hlopt|.><hlstd|force<space|0.5em>mb<space|0.5em>s<space|0.5em>p><hlopt|))><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|end><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|include<space|0.5em>><hlkwd|M><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|include<space|0.5em>><hlkwd|MonadPlusOps><hlopt|(><hlkwd|M><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlopt|(\<less\>><hlstd|<hlbar>><hlopt|\<gtr\>)<space|0.5em>><hlstd|ma<space|0.5em>mb<space|0.5em>><hlopt|=<space|0.5em>><hlstd|mplus<space|0.5em>ma<space|0.5em>mb<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|runT<space|0.5em>m<space|0.5em>s<space|0.5em>p<space|0.5em>><hlopt|=<space|0.5em>><hlkwc|MP><hlopt|.><hlstd|lift<space|0.5em>fst<space|0.5em>><hlopt|(><hlstd|m<space|0.5em>s<space|0.5em>p><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|satisfy<space|0.5em>f<space|0.5em>s<space|0.5em>p<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|if<space|0.5em>><hlstd|p<space|0.5em>><hlopt|\<less\><space|0.5em>><hlkwc|String><hlopt|.><hlstd|length<space|0.5em>s<space|0.5em>><hlopt|&&<space|0.5em>><hlstd|f<space|0.5em>s><hlopt|.[><hlstd|p><hlopt|]><hlendline|Consuming
    a character means accessing it><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|then<space|0.5em>><hlkwc|MP><hlopt|.><hlstd|return<space|0.5em>><hlopt|(><hlstd|s><hlopt|.[><hlstd|p><hlopt|],<space|0.5em>><hlstd|p<space|0.5em>><hlopt|+<space|0.5em>><hlnum|1><hlopt|)<space|0.5em>><hlkwa|else<space|0.5em>><hlkwc|MP><hlopt|.><verbatim|mzero><hlendline|and
    advancing the parsing position.><next-line><space|0.5em><space|0.5em><hlkwa|let<space|0.5em>><hlstd|end<textunderscore>of<textunderscore>text<space|0.5em>s<space|0.5em>p<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|if<space|0.5em>><hlstd|p<space|0.5em>><hlopt|\<gtr\>=<space|0.5em>><hlkwc|String><hlopt|.><hlstd|length<space|0.5em>s<space|0.5em>><hlkwa|then<space|0.5em>><hlkwc|MP><hlopt|.><hlstd|return<space|0.5em>><hlopt|((),<space|0.5em>><hlstd|p><hlopt|)<space|0.5em>><hlkwa|else<space|0.5em>><hlkwc|MP><hlopt|.><hlstd|mzero><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlkwa|module<space|0.5em>type<space|0.5em>><hlkwd|PARSE<textunderscore>OPS<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|sig><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|include<space|0.5em>><hlkwd|PARSE><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|val<space|0.5em>><hlstd|many<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'a<space|0.5em>monad<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|'a<space|0.5em>list<space|0.5em>monad<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|val<space|0.5em>><hlstd|opt<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'a<space|0.5em>monad<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|'a<space|0.5em>><hlkwb|option<space|0.5em>><hlstd|monad<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|val<space|0.5em>><hlopt|(><hlstd|?<hlbar>><hlopt|)<space|0.5em>:<space|0.5em>><hlstd|'a<space|0.5em>monad<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|'a<space|0.5em>><hlkwb|option<space|0.5em>><hlstd|monad<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|val<space|0.5em>><hlstd|seq<space|0.5em>><hlopt|:<space|0.5em>><hlstd|'a<space|0.5em>monad<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|'b<space|0.5em>monad<space|0.5em>><hlkwc|Lazy><hlopt|.><hlstd|t<space|0.5em>><hlopt|-\<gtr\><space|0.5em>(><hlstd|'a<space|0.5em>><hlopt|*<space|0.5em>><hlstd|'b><hlopt|)<space|0.5em>><verbatim|monad><hlendline|Exercise:
    why laziness here?><next-line><space|0.5em><space|0.5em><hlkwa|val<space|0.5em>><hlopt|(\<less\>*\<gtr\>)<space|0.5em>:<space|0.5em>><hlstd|'a<space|0.5em>monad<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|'b<space|0.5em>monad<space|0.5em>><hlkwc|Lazy><hlopt|.><hlstd|t<space|0.5em>><hlopt|-\<gtr\><space|0.5em>(><hlstd|'a<space|0.5em>><hlopt|*<space|0.5em>><hlstd|'b><hlopt|)<space|0.5em>><verbatim|monad><hlendline|Synonym
    for <verbatim|seq>.><next-line><space|0.5em><space|0.5em><hlkwa|val<space|0.5em>><hlstd|lowercase<space|0.5em>><hlopt|:<space|0.5em>><hlstd|char<space|0.5em>monad<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|val<space|0.5em>><hlstd|uppercase<space|0.5em>><hlopt|:<space|0.5em>><hlstd|char<space|0.5em>monad<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|val<space|0.5em>><hlstd|digit<space|0.5em>><hlopt|:<space|0.5em>><hlstd|char<space|0.5em>monad<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|val<space|0.5em>><hlstd|alpha<space|0.5em>><hlopt|:<space|0.5em>><hlstd|char<space|0.5em>monad<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|val<space|0.5em>><hlstd|alphanum<space|0.5em>><hlopt|:<space|0.5em>><hlstd|char<space|0.5em>monad<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|val<space|0.5em>><hlstd|literal<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|string<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwb|unit<space|0.5em>><verbatim|monad><hlendline|Consume
    characters of the given string.><next-line><space|0.5em><space|0.5em><hlkwa|val<space|0.5em>><hlopt|(\<less\>\<less\>\<gtr\>)<space|0.5em>:<space|0.5em>><hlkwb|string<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|'a<space|0.5em>monad<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><verbatim|'a<space|0.5em>monad><hlendline|Prefix
    and postfix keywords.><next-line><space|0.5em><space|0.5em><hlkwa|val<space|0.5em>><hlopt|(\<less\>\<gtr\>\<gtr\>)<space|0.5em>:<space|0.5em>><hlstd|'a<space|0.5em>monad<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwb|string<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|'a<space|0.5em>monad><hlendline|><next-line><hlkwa|end><hlendline|><next-line><hlkwa|module<space|0.5em>><hlkwd|ParseOps<space|0.5em>><hlopt|(><hlkwd|R<space|0.5em>><hlopt|:<space|0.5em>><hlkwd|MONAD<textunderscore>PLUS<textunderscore>OPS><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlopt|(><hlkwd|P<space|0.5em>><hlopt|:<space|0.5em>><hlkwd|PARSE<space|0.5em>><hlkwa|with<space|0.5em>type<space|0.5em>><hlstd|'a<space|0.5em>backtracking<textunderscore>monad<space|0.5em>><hlopt|:=<space|0.5em>><hlstd|'a<space|0.5em>><hlkwc|R><hlopt|.><hlstd|monad><hlopt|)<space|0.5em>:><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwd|PARSE<textunderscore>OPS<space|0.5em>><hlkwa|with<space|0.5em>type<space|0.5em>><hlstd|'a<space|0.5em>backtracking<textunderscore>monad<space|0.5em>><hlopt|:=<space|0.5em>><hlstd|'a<space|0.5em>><hlkwc|R><hlopt|.><hlstd|monad<space|0.5em>><hlopt|=><hlendline|><next-line><hlkwa|struct><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|include<space|0.5em>><hlkwd|P><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>rec<space|0.5em>><hlstd|many<space|0.5em>p<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|(><hlkwa|perform><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>r<space|0.5em>><hlopt|\<less\>--<space|0.5em>><hlstd|p><hlopt|;<space|0.5em>><hlstd|rs<space|0.5em>><hlopt|\<less\>--<space|0.5em>><hlstd|many<space|0.5em>p><hlopt|;<space|0.5em>><hlstd|return<space|0.5em>><hlopt|(><hlstd|r><hlopt|::><hlstd|rs><hlopt|))><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|++<space|0.5em>><hlkwa|lazy<space|0.5em>><hlopt|(><hlstd|return<space|0.5em>><hlopt|[])><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|opt<space|0.5em>p<space|0.5em>><hlopt|=<space|0.5em>(><hlstd|p<space|0.5em>><hlopt|\<gtr\>\<gtr\>=<space|0.5em>(><hlkwa|fun<space|0.5em>><hlstd|x<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|return<space|0.5em>><hlopt|(><hlkwd|Some<space|0.5em>><hlstd|x><hlopt|)))<space|0.5em>++<space|0.5em>><hlkwa|lazy<space|0.5em>><hlopt|(><hlstd|return<space|0.5em>><hlkwd|None><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlopt|(><hlstd|?<hlbar>><hlopt|)<space|0.5em>><hlstd|p<space|0.5em>><hlopt|=<space|0.5em>><hlstd|opt<space|0.5em>p<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|seq<space|0.5em>p<space|0.5em>q<space|0.5em>><hlopt|=<space|0.5em>><hlkwa|perform><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>x<space|0.5em>><hlopt|\<less\>--<space|0.5em>><hlstd|p><hlopt|;<space|0.5em>><hlstd|y<space|0.5em>><hlopt|\<less\>--<space|0.5em>><hlkwc|Lazy><hlopt|.><hlstd|force<space|0.5em>q><hlopt|;<space|0.5em>><hlstd|return<space|0.5em>><hlopt|(><hlstd|x><hlopt|,<space|0.5em>><hlstd|y><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlopt|(\<less\>*\<gtr\>)<space|0.5em>><hlstd|p<space|0.5em>q<space|0.5em>><hlopt|=<space|0.5em>><hlstd|seq<space|0.5em>p<space|0.5em>q<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|lowercase<space|0.5em>><hlopt|=<space|0.5em>><hlstd|satisfy<space|0.5em>><hlopt|(><hlkwa|fun<space|0.5em>><hlstd|c<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|c<space|0.5em>><hlopt|\<gtr\>=<space|0.5em>><hlstd|'a'<space|0.5em>><hlopt|&&<space|0.5em>><hlstd|c<space|0.5em>><hlopt|\<less\>=<space|0.5em>><hlstd|'z'><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|uppercase<space|0.5em>><hlopt|=<space|0.5em>><hlstd|satisfy<space|0.5em>><hlopt|(><hlkwa|fun<space|0.5em>><hlstd|c<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|c<space|0.5em>><hlopt|\<gtr\>=<space|0.5em>><hlstd|'><hlkwd|A'<space|0.5em>><hlopt|&&<space|0.5em>><hlstd|c<space|0.5em>><hlopt|\<less\>=<space|0.5em>><hlstd|'><hlkwd|Z'><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|digit<space|0.5em>><hlopt|=<space|0.5em>><hlstd|satisfy<space|0.5em>><hlopt|(><hlkwa|fun<space|0.5em>><hlstd|c<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|c<space|0.5em>><hlopt|\<gtr\>=<space|0.5em>><hlstd|'><hlnum|0><hlstd|'<space|0.5em>><hlopt|&&<space|0.5em>><hlstd|c<space|0.5em>><hlopt|\<less\>=<space|0.5em>><hlstd|'><hlnum|9><hlstd|'><hlopt|)><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|alpha<space|0.5em>><hlopt|=<space|0.5em>><hlstd|lowercase<space|0.5em>><hlopt|++<space|0.5em>><hlkwa|lazy<space|0.5em>><hlstd|uppercase<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|alphanum<space|0.5em>><hlopt|=<space|0.5em>><hlstd|alpha<space|0.5em>><hlopt|++<space|0.5em>><hlkwa|lazy<space|0.5em>><hlstd|digit<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|literal<space|0.5em>l<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>rec<space|0.5em>><hlstd|loop<space|0.5em>pos<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|if<space|0.5em>><hlstd|pos<space|0.5em>><hlopt|=<space|0.5em>><hlkwc|String><hlopt|.><hlstd|length<space|0.5em>l<space|0.5em>><hlkwa|then<space|0.5em>><hlstd|return<space|0.5em>><hlopt|()><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|else<space|0.5em>><hlstd|satisfy<space|0.5em>><hlopt|(><hlkwa|fun<space|0.5em>><hlstd|c<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|c<space|0.5em>><hlopt|=<space|0.5em>><hlstd|l><hlopt|.[><hlstd|pos><hlopt|])<space|0.5em>\<gtr\>\<gtr\>-<space|0.5em>><hlstd|loop<space|0.5em>><hlopt|(><hlstd|pos<space|0.5em>><hlopt|+<space|0.5em>><hlnum|1><hlopt|)<space|0.5em>><hlkwa|in><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>loop<space|0.5em>><hlnum|0><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlopt|(\<less\>\<less\>\<gtr\>)<space|0.5em>><hlstd|bra<space|0.5em>p<space|0.5em>><hlopt|=<space|0.5em>><hlstd|literal<space|0.5em>bra<space|0.5em>><hlopt|\<gtr\>\<gtr\>-<space|0.5em>><hlstd|p<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlopt|(\<less\>\<gtr\>\<gtr\>)<space|0.5em>><hlstd|p<space|0.5em>ket<space|0.5em>><hlopt|=<space|0.5em>><hlstd|p<space|0.5em>><hlopt|\<gtr\>\<gtr\>=<space|0.5em>(><hlkwa|fun<space|0.5em>><hlstd|x<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|literal<space|0.5em>ket<space|0.5em>><hlopt|\<gtr\>\<gtr\>-<space|0.5em>><hlstd|return<space|0.5em>x><hlopt|)><hlendline|><next-line><hlkwa|end><hlendline|>>
  </hidden>|<\hidden>
    <tit|Parser Combinators: Tying the Recursive Knot>

    <\itemize>
      <item>File <verbatim|PluginBase.ml>:
    </itemize>

    <hlkwa|module<space|0.5em>><hlkwd|ParseM<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwc|Parsec><hlopt|.><hlkwd|ParseOps<space|0.5em>><hlopt|(><hlkwc|Monad><hlopt|.><hlkwd|LListM><hlopt|)<space|0.5em>(><hlkwc|Parsec><hlopt|.><hlkwd|ParseT<space|0.5em>><hlopt|(><hlkwc|Monad><hlopt|.><hlkwd|LListM><hlopt|))><hlendline|><next-line><hlkwa|open<space|0.5em>><hlkwd|ParseM><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|grammar<textunderscore>rules<space|0.5em>><hlopt|:<space|0.5em>(><hlkwb|int<space|0.5em>><hlstd|monad<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwb|int<space|0.5em>><hlstd|monad><hlopt|)<space|0.5em>><hlstd|list<space|0.5em>><hlkwb|ref<space|0.5em>><hlopt|=<space|0.5em>><hlkwb|ref<space|0.5em>><hlopt|[]><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|get<textunderscore>language<space|0.5em>><hlopt|()<space|0.5em>:<space|0.5em>><hlkwb|int<space|0.5em>><hlstd|monad<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>rec<space|0.5em>><hlstd|result<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|lazy><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|(><hlkwc|List><hlopt|.><hlstd|fold<textunderscore>left<hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|(><hlkwa|fun<space|0.5em>><hlstd|acc<space|0.5em>lang<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|acc<space|0.5em>><hlopt|\<less\>><hlstd|<hlbar>><hlopt|\<gtr\><space|0.5em>><hlkwa|lazy<space|0.5em>><hlopt|(><hlstd|lang<space|0.5em>><hlopt|(><hlkwc|Lazy><hlopt|.><hlstd|force<space|0.5em>result><hlopt|)))><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>mzero<space|0.5em>><hlopt|!><hlstd|grammar<textunderscore>rules><hlopt|)<space|0.5em>><hlkwa|in><hlendline|Ensure
    we parse the whole text.><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|perform<space|0.5em>><hlstd|r<space|0.5em>><hlopt|\<less\>--<space|0.5em>><hlkwc|Lazy><hlopt|.><hlstd|force<space|0.5em>result><hlopt|;<space|0.5em>><hlstd|end<textunderscore>of<textunderscore>text><hlopt|;<space|0.5em>><hlstd|return<space|0.5em>r><hlendline|>
  </hidden>|<\hidden>
    <tit|Parser Combinators: Dynamic Code Loading>

    <\itemize>
      <item>File <verbatim|PluginRun.ml>:
    </itemize>

    <small|<hlkwa|let<space|0.5em>><hlstd|load<textunderscore>plug<space|0.5em>fname<space|0.5em>><hlopt|:<space|0.5em>><hlkwb|unit<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|fname<space|0.5em>><hlopt|=<space|0.5em>><hlkwc|Dynlink><hlopt|.><hlstd|adapt<textunderscore>filename<space|0.5em>fname<space|0.5em>><hlkwa|in><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|if<space|0.5em>><hlkwc|Sys><hlopt|.><hlstd|file<textunderscore>exists<space|0.5em>fname<space|0.5em>><hlkwa|then><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|try<space|0.5em>><hlkwc|Dynlink><hlopt|.><hlstd|loadfile<space|0.5em>fname<hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|with<space|0.5em>><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>><hlopt|(><hlkwc|Dynlink><hlopt|.><hlkwd|Error<space|0.5em>><hlstd|err><hlopt|)<space|0.5em>><hlkwa|as<space|0.5em>><hlstd|e<space|0.5em>><hlopt|-\<gtr\>><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwc|Printf><hlopt|.><hlstd|printf<space|0.5em>><hlstr|"><hlesc|\\n><hlstr|ERROR<space|0.5em>loading<space|0.5em>plugin:<space|0.5em>%s><hlesc|\\n><hlstr|%!"><hlstd|<hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|(><hlkwc|Dynlink><hlopt|.><hlstd|error<textunderscore>message<space|0.5em>err><hlopt|);><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>raise<space|0.5em>e<hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em><hlbar><space|0.5em>e<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwc|Printf><hlopt|.><hlstd|printf<space|0.5em>><hlstr|"><hlesc|\\n><hlstr|Unknow<space|0.5em>error<space|0.5em>while<space|0.5em>loading<space|0.5em>plugin><hlesc|\\n><hlstr|%!"><hlstd|<hlendline|><next-line><space|0.5em><space|0.5em>><hlkwa|else<space|0.5em>><hlopt|(><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwc|Printf><hlopt|.><hlstd|printf<space|0.5em>><hlstr|"><hlesc|\\n><hlstr|Plugin<space|0.5em>file<space|0.5em>%s<space|0.5em>does<space|0.5em>not<space|0.5em>exist><hlesc|\\n><hlstr|%!"><hlstd|<space|0.5em>fname><hlopt|;><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>exit<space|0.5em>><hlopt|(-><hlnum|1><hlopt|))><hlendline|><next-line><hlendline|><next-line><hlkwa|let<space|0.5em>><hlopt|()<space|0.5em>=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|for<space|0.5em>><hlstd|i<space|0.5em>><hlopt|=<space|0.5em>><hlnum|2<space|0.5em>><hlkwa|to<space|0.5em>><hlkwc|Array><hlopt|.><hlstd|length<space|0.5em>><hlkwc|Sys><hlopt|.><hlstd|argv<space|0.5em>><hlopt|-<space|0.5em>><hlnum|1<space|0.5em>><hlkwa|do><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>load<textunderscore>plug<space|0.5em>><hlkwc|Sys><hlopt|.><hlstd|argv><hlopt|.(><hlstd|i><hlopt|)<space|0.5em>><hlkwa|done><hlopt|;><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|lang<space|0.5em>><hlopt|=<space|0.5em>><hlkwc|PluginBase><hlopt|.><hlstd|get<textunderscore>language<space|0.5em>><hlopt|()<space|0.5em>><hlkwa|in><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>><hlstd|result<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwc|Monad><hlopt|.><hlkwc|LListM><hlopt|.><hlstd|run<hlendline|><next-line><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|(><hlkwc|PluginBase><hlopt|.><hlkwc|ParseM><hlopt|.><hlstd|runT<space|0.5em>lang<space|0.5em>><hlkwc|Sys><hlopt|.><hlstd|argv><hlopt|.(><hlnum|1><hlopt|)<space|0.5em>><hlnum|0><hlopt|)<space|0.5em>><hlkwa|in><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|match<space|0.5em>><hlkwc|Monad><hlopt|.><hlstd|ltake<space|0.5em>><hlnum|1<space|0.5em>><hlstd|result<space|0.5em>><hlkwa|with><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><hlbar><space|0.5em>><hlopt|[]<space|0.5em>-\<gtr\><space|0.5em>><hlkwc|Printf><hlopt|.><hlstd|printf<space|0.5em>><hlstr|"><hlesc|\\n><hlstr|Parse<space|0.5em>error><hlesc|\\n><hlstr|%!"><hlstd|<hlendline|><next-line><space|0.5em><space|0.5em><hlbar><space|0.5em>r><hlopt|::><hlstd|<textunderscore><space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlkwc|Printf><hlopt|.><hlstd|printf<space|0.5em>><hlstr|"><hlesc|\\n><hlstr|Result:<space|0.5em>%d><hlesc|\\n><hlstr|%!"><hlstd|<space|0.5em>r><hlendline|>>
  </hidden>|<\hidden>
    <tit|Parser Combinators: Toy Example>

    <\itemize>
      <item>File <verbatim|Plugin1.ml>:
    </itemize>

    <small|<hlkwa|open<space|0.5em>><hlkwc|PluginBase><hlopt|.><hlkwd|ParseM><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|digit<textunderscore>of<textunderscore>char<space|0.5em>d<space|0.5em>><hlopt|=<space|0.5em>><hlstd|int<textunderscore>of<textunderscore>char<space|0.5em>d<space|0.5em>><hlopt|-<space|0.5em>><hlstd|int<textunderscore>of<textunderscore>char<space|0.5em>'><hlnum|0><hlstd|'><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|number<hlunderscore>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|let<space|0.5em>rec<space|0.5em>><hlstd|num<space|0.5em>><hlopt|=><hlendline|Numbers:
    <math|N\<assign\>D N<mid|\|>D> where <math|D> is
    digits.><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlkwa|lazy<space|0.5em>><hlopt|(><hlstd|<space|0.5em><space|0.5em>><hlopt|(><hlkwa|perform><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>d<space|0.5em>><hlopt|\<less\>--<space|0.5em>><hlstd|digit><hlopt|;><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|(><hlstd|n><hlopt|,<space|0.5em>><hlstd|b><hlopt|)<space|0.5em>\<less\>--<space|0.5em>><hlkwc|Lazy><hlopt|.><hlstd|force<space|0.5em>num><hlopt|;><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>return<space|0.5em>><hlopt|(><hlstd|digit<textunderscore>of<textunderscore>char<space|0.5em>d<space|0.5em>><hlopt|*<space|0.5em>><hlstd|b<space|0.5em>><hlopt|+<space|0.5em>><hlstd|n><hlopt|,<space|0.5em>><hlstd|b<space|0.5em>><hlopt|*<space|0.5em>><hlnum|10><hlopt|))><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em><space|0.5em>><hlopt|\<less\>><hlstd|<hlbar>><hlopt|\<gtr\><space|0.5em>><hlkwa|lazy<space|0.5em>><hlopt|(><hlstd|digit<space|0.5em>><hlopt|\<gtr\>\<gtr\>=<space|0.5em>(><hlkwa|fun<space|0.5em>><hlstd|d<space|0.5em>><hlopt|-\<gtr\><space|0.5em>><hlstd|return<space|0.5em>><hlopt|(><hlstd|digit<textunderscore>of<textunderscore>char<space|0.5em>d><hlopt|,<space|0.5em>><hlnum|10><hlopt|))))<space|0.5em>><hlkwa|in><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwc|Lazy><hlopt|.><hlstd|force<space|0.5em>num<space|0.5em>><hlopt|\<gtr\>\<gtr\>><hlstd|<hlbar><space|0.5em>fst><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|addition<space|0.5em>lang<space|0.5em>><hlopt|=><hlendline|Addition
    rule: <math|S\<rightarrow\><around*|(|S+S|)>>.><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|perform><hlendline|Requiring
    a parenthesis <verbatim|(> turns the rule into
    non-left-recursive.><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>literal<space|0.5em>><hlstr|"("><hlopt|;<space|0.5em>><hlstd|n1<space|0.5em>><hlopt|\<less\>--<space|0.5em>><hlstd|lang><hlopt|;<space|0.5em>><hlstd|literal<space|0.5em>><hlstr|"+"><hlopt|;<space|0.5em>><hlstd|n2<space|0.5em>><hlopt|\<less\>--<space|0.5em>><hlstd|lang><hlopt|;<space|0.5em>><hlstd|literal<space|0.5em>><hlstr|")"><hlopt|;><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>return<space|0.5em>><hlopt|(><hlstd|n1<space|0.5em>><hlopt|+<space|0.5em>><hlstd|n2><hlopt|)><hlendline|><next-line><hlkwa|let<space|0.5em>><hlopt|()<space|0.5em>=
    ><hlkwc|PluginBase><hlopt|.(><hlstd|grammar<textunderscore>rules<space|0.5em>><hlopt|:=<space|0.5em>><hlstd|number<space|0.5em>><hlopt|::<space|0.5em>><hlstd|addition<space|0.5em>><hlopt|::<space|0.5em>!><hlstd|grammar<textunderscore>rules><hlopt|)><hlendline|>>

    <\itemize>
      <item>File <verbatim|Plugin2.ml>:
    </itemize>

    <small|<hlkwa|open<space|0.5em>><hlkwc|PluginBase><hlopt|.><hlkwd|ParseM><hlendline|><next-line><hlkwa|let<space|0.5em>><hlstd|multiplication<space|0.5em>lang<space|0.5em>><hlopt|=><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em>><hlkwa|perform><hlendline|Multiplication
    rule: <math|S\<rightarrow\><around*|(|S\<ast\>S|)>>.><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>literal<space|0.5em>><hlstr|"("><hlopt|;<space|0.5em>><hlstd|n1<space|0.5em>><hlopt|\<less\>--<space|0.5em>><hlstd|lang><hlopt|;<space|0.5em>><hlstd|literal<space|0.5em>><hlstr|"*"><hlopt|;<space|0.5em>><hlstd|n2<space|0.5em>><hlopt|\<less\>--<space|0.5em>><hlstd|lang><hlopt|;<space|0.5em>><hlstd|literal<space|0.5em>><hlstr|")"><hlopt|;><hlendline|><next-line><hlstd|<space|0.5em><space|0.5em><space|0.5em><space|0.5em>return<space|0.5em>><hlopt|(><hlstd|n1<space|0.5em>><hlopt|*<space|0.5em>><hlstd|n2><hlopt|)><hlendline|><next-line><hlkwa|let<space|0.5em>><hlopt|()<space|0.5em>=
    ><hlkwc|PluginBase><hlopt|.(><hlstd|grammar<textunderscore>rules<space|0.5em>><hlopt|:=<space|0.5em>><hlstd|multiplication<space|0.5em>><hlopt|::<space|0.5em>!><hlstd|grammar<textunderscore>rules><hlopt|)><hlendline|>>
  </hidden>>
</body>

<\initial>
  <\collection>
    <associate|page-type|letter>
  </collection>
</initial>

<\references>
  <\collection>
    <associate|auto-1|<tuple|1|?>>
  </collection>
</references>