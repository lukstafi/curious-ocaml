\documentclass{article}
\usepackage[english]{babel}
\usepackage{geometry,amsmath,hyperref,theorem}
\geometry{letterpaper}

%%%%%%%%%% Start TeXmacs macros
\catcode`\<=\active \def<{
\fontencoding{T1}\selectfont\symbol{60}\fontencoding{\encodingdefault}}
\catcode`\>=\active \def>{
\fontencoding{T1}\selectfont\symbol{62}\fontencoding{\encodingdefault}}
\newcommand{\tmem}[1]{{\em #1\/}}
\newcommand{\tmverbatim}[1]{\text{{\ttfamily{#1}}}}
{\theorembodyfont{\rmfamily\small}\newtheorem{exercise}{Exercise}}
%%%%%%%%%% End TeXmacs macros

\begin{document}

{\class{Functional Programming}}

{\title{Algebraic Data Types}}

\begin{exercise}
  Due to Yaron Minsky.
  
  Consider a datatype to store internet connection information. The time
  \tmverbatim{when\_initiated} marks the start of connecting and is not needed
  after the connection is established (it is only used to decide whether to
  give up trying to connect). The ping information is available for
  established connection but not straight away.
  
  \\
  {\hlstd{}}{\hlkwa{type }}{\hlstd{connection{\textunderscore}state
  }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{}}{\hlstd{ \ }}{\hlopt{\textbar
  }}{\hlkwd{Connecting}}{\hlendline{}}\\
  {\hlstd{}}{\hlstd{ \ }}{\hlopt{\textbar
  }}{\hlkwd{Connected}}{\hlendline{}}\\
  {\hlstd{}}{\hlstd{ \ }}{\hlopt{\textbar
  }}{\hlkwd{Disconnected}}{\hlendline{}}\\
  {\hlstd{}}{\hlendline{}}\\
  {\hlkwa{type }}{\hlstd{connection{\textunderscore}info }}{\hlopt{=
  \{}}{\hlendline{}}\\
  {\hlstd{}}{\hlstd{ \ }}{\hlstd{state }}{\hlopt{:
  }}{\hlstd{connection{\textunderscore}state}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{}}{\hlstd{ \ }}{\hlstd{server }}{\hlopt{:
  }}{\hlstd{}}{\hlkwc{Inet{\textunderscore}addr}}{\hlstd{}}{\hlopt{.}}{\hlstd{t}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{}}{\hlstd{ \
  }}{\hlstd{last{\textunderscore}ping{\textunderscore}time }}{\hlopt{:
  }}{\hlstd{}}{\hlkwc{Time}}{\hlstd{}}{\hlopt{.}}{\hlstd{t
  }}{\hlkwb{option}}{\hlstd{}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{}}{\hlstd{ \ }}{\hlstd{last{\textunderscore}ping{\textunderscore}id
  }}{\hlopt{: }}{\hlstd{}}{\hlkwb{int
  option}}{\hlstd{}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{}}{\hlstd{ \ }}{\hlstd{session{\textunderscore}id }}{\hlopt{:
  }}{\hlstd{}}{\hlkwb{string option}}{\hlstd{}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{}}{\hlstd{ \ }}{\hlstd{when{\textunderscore}initiated }}{\hlopt{:
  }}{\hlstd{}}{\hlkwc{Time}}{\hlstd{}}{\hlopt{.}}{\hlstd{t
  }}{\hlkwb{option}}{\hlstd{}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{}}{\hlstd{ \ }}{\hlstd{when{\textunderscore}disconnected }}{\hlopt{:
  }}{\hlstd{}}{\hlkwc{Time}}{\hlstd{}}{\hlopt{.}}{\hlstd{t
  }}{\hlkwb{option}}{\hlstd{}}{\hlopt{;}}{\hlendline{}}\\
  {\hlstd{}}{\hlopt{\}}}{\hlstd{}}{\hlendline{}}
  
  (The types {\hlkwc{Time}}{\hlstd{}}{\hlopt{.}}{\hlstd{t }}and
  {\hlkwc{Inet{\textunderscore}addr}}{\hlstd{}}{\hlopt{.}}{\hlstd{t}} come
  from the library {\tmem{Core}} used where Yaron Minsky works. You can
  replace them with \tmverbatim{float} and
  {\hlkwc{Unix}}{\hlstd{}}{\hlopt{.}}{\hlstd{inet\_addr}}. Load the Unix
  library in the interactive toplevel by \tmverbatim{\#load "unix.cma";;}.)
  Rewrite the type definitions so that the datatype will contain only
  reasonable combinations of information.
\end{exercise}

\begin{exercise}
  In OCaml, functions can have named arguments, and also default arguments
  (parameters, possibly with default values, which can be omitted when
  providing arguments). The names of arguments are called labels. The labels
  can be different from the names of the argument values:
  
  \\
  {\hlkwa{let }}{\hlstd{f
  $\sim$meaningful{\textunderscore}name}}{\hlopt{:}}{\hlstd{n }}{\hlopt{=
  }}{\hlstd{n}}{\hlopt{+}}{\hlnum{1}}{\hlendline{}}\\
  {\hlkwa{let }}{\hlstd{{\textunderscore} }}{\hlopt{= }}{\hlstd{f
  $\sim$meaningful{\textunderscore}name}}{\hlopt{:}}{\hlnum{5}}{\hlendline{We
  do not need the result so we ignore it.}}
  
  \
  
  When the label and value names are the same, the syntax is shorter:
  
  \\
  {\hlkwa{let }}{\hlstd{g $\sim$pos $\sim$len }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwc{StringLabels}}{\hlopt{.}}{\hlstd{sub
  }}{\hlstr{"0123456789abcdefghijklmnopqrstuvwxyz"}}{\hlstd{ $\sim$pos
  $\sim$len}}{\hlendline{}}\\
  {\hlkwa{let }}{\hlopt{() =}}{\hlendline{A nicer way to mark computations
  that do not produce a result (return \tmverbatim{unit}).}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{pos }}{\hlopt{=
  }}{\hlkwc{Random}}{\hlopt{.}}{\hlkwb{int }}{\hlnum{26
  }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{let }}{\hlstd{len }}{\hlopt{=
  }}{\hlkwc{Random}}{\hlopt{.}}{\hlkwb{int }}{\hlnum{10
  }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{ \ print{\textunderscore}string }}{\hlopt{(}}{\hlstd{g $\sim$pos
  $\sim$len}}{\hlopt{)}}{\hlendline{}}\\
  
  
  When some function arguments are optional, the function has to take
  non-optional arguments after the last optional argument. When the optional
  parameters have default values:
  
  \\
  {\hlkwa{let }}{\hlstd{h
  ?}}{\hlopt{(}}{\hlstd{len}}{\hlopt{=}}{\hlnum{1}}{\hlopt{) }}{\hlstd{pos
  }}{\hlopt{= }}{\hlstd{g $\sim$pos $\sim$len}}{\hlendline{}}\\
  {\hlkwa{let }}{\hlopt{() = }}{\hlstd{print{\textunderscore}string
  }}{\hlopt{(}}{\hlstd{h }}{\hlnum{10}}{\hlopt{)}}{\hlendline{}}\\
  
  
  Optional arguments are implemented as parameters of an option type. This
  allows us to check whether the argument was actually provided:
  
  \\
  {\hlkwa{let }}{\hlstd{foo ?bar n }}{\hlopt{=}}{\hlendline{}}\\
  {\hlstd{ \ }}{\hlkwa{match }}{\hlstd{bar }}{\hlkwa{with}}{\hlendline{}}\\
  {\hlstd{ \ \ \ }}{\hlopt{\textbar }}{\hlkwd{None }}{\hlopt{->
  }}{\hlstr{"Argument = "}}{\hlstd{ {\textasciicircum}
  string{\textunderscore}of{\textunderscore}int n{\hlendline{}}\\
  \ \ \ }}{\hlopt{\textbar }}{\hlkwd{Some }}{\hlstd{m }}{\hlopt{->
  }}{\hlstr{"Sum = "}}{\hlstd{ {\textasciicircum}
  string{\textunderscore}of{\textunderscore}int }}{\hlopt{(}}{\hlstd{m
  }}{\hlopt{+ }}{\hlstd{n}}{\hlopt{)}}{\hlendline{}}\\
  {\hlopt{;;}}{\hlendline{}}\\
  {\hlstd{foo }}{\hlnum{5}}{\hlopt{;;}}{\hlendline{}}\\
  {\hlstd{foo $\sim$bar}}{\hlopt{:}}{\hlnum{5 7}}{\hlopt{;;}}{\hlendline{}}\\
  
  
  We can also provide the option value directly:
  
  \\
  {\hlkwa{let }}{\hlstd{bar }}{\hlopt{= }}{\hlkwa{if
  }}{\hlkwc{Random}}{\hlopt{.}}{\hlkwb{int }}{\hlnum{10 }}{\hlopt{<
  }}{\hlnum{5 }}{\hlkwa{then }}{\hlkwd{None }}{\hlkwa{else }}{\hlkwd{Some
  }}{\hlnum{7 }}{\hlkwa{in}}{\hlendline{}}\\
  {\hlstd{foo ?bar }}{\hlnum{7}}{\hlopt{;;}}{\hlendline{}}\\
  
  \begin{enumerate}
    \item Observe the types that functions with labelled and optional
    arguments have. Come up with coding style guidelines, e.g. when to use
    labeled arguments.
    
    \item Write a rectangle-drawing procedure that takes three optional
    arguments: left-upper corner, right-lower corner, and a width-height pair.
    It should draw a correct rectangle whenever two arguments are given, and
    raise exception otherwise. Load the graphics library in the interactive
    toplevel by \tmverbatim{\#load "graphics.cma";;}. Use ``functions''
    \tmverbatim{invalid\_arg},
    {\hlkwc{Graphics}}{\hlopt{.}}\tmverbatim{open\_graph} and
    {\hlkwc{Graphics}}{\hlopt{.}}\tmverbatim{draw\_rect}.
    
    \item Write a function that takes an optional argument of arbitrary type
    and a function argument, and passes the optional argument to the function
    without inspecting it.
  \end{enumerate}
\end{exercise}

\begin{exercise}
  From last year's exam.
  \begin{enumerate}
    \item Give the (most general) types of the following expressions, either
    by guessing or inferring by hand:
    \begin{enumerate}
      \item {\hlstd{}}{\hlkwa{let }}{\hlstd{double f y }}{\hlopt{= }}{\hlstd{f
      }}{\hlopt{(}}{\hlstd{f y}}{\hlopt{) }}{\hlstd{}}{\hlkwa{in fun
      }}{\hlstd{g x }}{\hlopt{-> }}{\hlstd{double }}{\hlopt{(}}{\hlstd{g
      x}}{\hlopt{)}}{\hlstd{}}
      
      \item {\hlkwa{let rec }}{\hlstd{tails l }}{\hlopt{= }}{\hlkwa{match
      }}{\hlstd{l }}{\hlkwa{with }}{\hlopt{[] -> []
      }}{\hlstd{{\hlopt{\textbar}} x}}{\hlopt{::}}{\hlstd{xs }}{\hlopt{->
      }}{\hlstd{xs}}{\hlopt{::}}{\hlstd{tails xs
      }}{\hlkwa{in}}{\hlendline{}}\\
      {\hlkwa{fun }}{\hlstd{l }}{\hlopt{->
      }}{\hlkwc{List}}{\hlopt{.}}{\hlstd{combine l }}{\hlopt{(}}{\hlstd{tails
      l}}{\hlopt{)}}
    \end{enumerate}
    \item Give example expressions that have the following types (without
    using type constraints):
    \begin{enumerate}
      \item \tmverbatim{(int -> int) -> bool}
      
      \item \tmverbatim{'a option -> 'a list}
    \end{enumerate}
  \end{enumerate}
\end{exercise}

\begin{exercise}
  We have seen in the class, that algebraic data types can be related to
  analytic functions (the subset that can be defined out of polynomials via
  recursion) -- by literally interpreting sum types (i.e. variant types) as
  sums and product types (i.e. tuple and record types) as products. We can
  extend this interpretation to all OCaml types that we introduced, by
  interpreting a function type $a \rightarrow b$ as $b^a$, $b$ to the power of
  $a$. Note that the $b^a$ notation is actually used to denote functions in
  set theory.
  \begin{enumerate}
    \item Translate $a^{b + cd}$ and $a^b  (a^c)^d$ into OCaml types, using
    any distinct types for $a, b, c, d$, and using the \tmverbatim{('a,'b)
    choice = Left of 'a \textbar  Right of 'b} datatype for $+$. Write the
    bijection function in both directions.
    
    \item Come up with a type \tmverbatim{'t exp}, that shares with the
    exponential function the following property: $\frac{\partial \exp
    (t)}{\partial t} = \exp (t)$, where we translate a derivative of a type as
    a context, i.e. the type with a ``hole'', as in the lecture. Explain why
    your answer is correct. Hint: in computer science, our logarithms are
    mostly base 2.
  \end{enumerate}
  Further reading:\\
  \href{http://bababadalgharaghtakamminarronnkonnbro.blogspot.com/2012/10/algebraic-type-systems-combinatorial.html}{http://bababadalgharaghtakamminarronnkonnbro.blogspot.com/2012/10/algebraic-type-systems-combinatorial.html}
\end{exercise}

\end{document}
