<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Lukasz Stafiniak" />
  <title>Curious OCaml</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Curious OCaml</h1>
<p class="author">Lukasz Stafiniak</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#curious-ocaml" id="toc-curious-ocaml">Curious OCaml</a>
<ul>
<li><a href="#chapter-1-logic" id="toc-chapter-1-logic">Chapter 1:
Logic</a>
<ul>
<li><a href="#in-the-beginning-there-was-logos"
id="toc-in-the-beginning-there-was-logos">1.1 In the Beginning there was
Logos</a></li>
<li><a href="#rules-for-logical-connectives"
id="toc-rules-for-logical-connectives">1.2 Rules for Logical
Connectives</a></li>
<li><a href="#logos-was-programmed-in-ocaml"
id="toc-logos-was-programmed-in-ocaml">1.3 Logos was Programmed in
OCaml</a></li>
<li><a href="#exercises" id="toc-exercises">1.4 Exercises</a></li>
</ul></li>
<li><a href="#chapter-2-algebra" id="toc-chapter-2-algebra">Chapter 2:
Algebra</a>
<ul>
<li><a href="#a-glimpse-at-type-inference"
id="toc-a-glimpse-at-type-inference">2.1 A Glimpse at Type
Inference</a></li>
<li><a href="#algebraic-data-types" id="toc-algebraic-data-types">2.2
Algebraic Data Types</a></li>
<li><a href="#syntactic-conventions" id="toc-syntactic-conventions">2.3
Syntactic Conventions</a></li>
<li><a href="#pattern-matching" id="toc-pattern-matching">2.4 Pattern
Matching</a></li>
<li><a href="#interpreting-algebraic-data-types-as-polynomials"
id="toc-interpreting-algebraic-data-types-as-polynomials">2.5
Interpreting Algebraic Data Types as Polynomials</a></li>
<li><a href="#differentiating-algebraic-data-types"
id="toc-differentiating-algebraic-data-types">2.6 Differentiating
Algebraic Data Types</a></li>
<li><a href="#exercises-1" id="toc-exercises-1">2.7 Exercises</a></li>
</ul></li>
<li><a href="#chapter-3-computation"
id="toc-chapter-3-computation">Chapter 3: Computation</a>
<ul>
<li><a href="#function-composition" id="toc-function-composition">3.1
Function Composition</a></li>
<li><a href="#evaluation-rules-reduction-semantics"
id="toc-evaluation-rules-reduction-semantics">3.2 Evaluation Rules
(Reduction Semantics)</a></li>
<li><a href="#symbolic-derivation-example"
id="toc-symbolic-derivation-example">3.3 Symbolic Derivation
Example</a></li>
<li><a href="#tail-calls-and-tail-recursion"
id="toc-tail-calls-and-tail-recursion">3.4 Tail Calls and Tail
Recursion</a></li>
<li><a href="#first-encounter-of-continuation-passing-style"
id="toc-first-encounter-of-continuation-passing-style">3.5 First
Encounter of Continuation Passing Style</a></li>
<li><a href="#exercises-2" id="toc-exercises-2">3.6 Exercises</a></li>
</ul></li>
<li><a href="#chapter-4-functions" id="toc-chapter-4-functions">Chapter
4: Functions</a>
<ul>
<li><a href="#review-computation-by-hand"
id="toc-review-computation-by-hand">4.1 Review: Computation by
Hand</a></li>
<li><a href="#language-and-rules-of-the-untyped-lambda-calculus"
id="toc-language-and-rules-of-the-untyped-lambda-calculus">4.2 Language
and Rules of the Untyped Lambda-Calculus</a></li>
<li><a href="#booleans" id="toc-booleans">4.3 Booleans</a></li>
<li><a href="#if-then-else-and-pairs"
id="toc-if-then-else-and-pairs">4.4 If-then-else and Pairs</a></li>
<li><a href="#pair-encoded-natural-numbers"
id="toc-pair-encoded-natural-numbers">4.5 Pair-Encoded Natural
Numbers</a></li>
<li><a href="#church-numerals" id="toc-church-numerals">4.6 Church
Numerals</a></li>
<li><a href="#recursion-fixpoint-combinators"
id="toc-recursion-fixpoint-combinators">4.7 Recursion: Fixpoint
Combinators</a></li>
<li><a href="#encoding-lists-and-trees"
id="toc-encoding-lists-and-trees">4.8 Encoding Lists and Trees</a></li>
<li><a href="#looping-recursion" id="toc-looping-recursion">4.9 Looping
Recursion</a></li>
<li><a href="#exercises-3" id="toc-exercises-3">4.10 Exercises</a></li>
</ul></li>
<li><a href="#chapter-5-polymorphism-and-abstract-data-types"
id="toc-chapter-5-polymorphism-and-abstract-data-types">Chapter 5:
Polymorphism and Abstract Data Types</a>
<ul>
<li><a href="#type-inference" id="toc-type-inference">5.1 Type
Inference</a></li>
<li><a href="#parametric-types" id="toc-parametric-types">5.2 Parametric
Types</a></li>
<li><a href="#type-inference-formally"
id="toc-type-inference-formally">5.3 Type Inference, Formally</a></li>
<li><a href="#algebraic-specification"
id="toc-algebraic-specification">5.4 Algebraic Specification</a></li>
<li><a href="#homomorphisms" id="toc-homomorphisms">5.5
Homomorphisms</a></li>
<li><a href="#example-maps" id="toc-example-maps">5.6 Example:
Maps</a></li>
<li><a href="#modules-and-interfaces-signatures-syntax"
id="toc-modules-and-interfaces-signatures-syntax">5.7 Modules and
Interfaces (Signatures): Syntax</a></li>
<li><a href="#implementing-maps-association-lists"
id="toc-implementing-maps-association-lists">5.8 Implementing Maps:
Association Lists</a></li>
<li><a href="#implementing-maps-binary-search-trees"
id="toc-implementing-maps-binary-search-trees">5.9 Implementing Maps:
Binary Search Trees</a></li>
<li><a href="#implementing-maps-red-black-trees"
id="toc-implementing-maps-red-black-trees">5.10 Implementing Maps:
Red-Black Trees</a></li>
<li><a href="#exercises-4" id="toc-exercises-4">Exercises</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<!-- Do NOT modify this file, it is automatically generated -->
<h1 id="curious-ocaml">Curious OCaml</h1>
<h2 id="chapter-1-logic">Chapter 1: Logic</h2>
<p><em>From logic rules to programming constructs</em></p>
<h3 id="in-the-beginning-there-was-logos">1.1 In the Beginning there was
Logos</h3>
<p>What logical connectives do you know?</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th><span class="math inline">\top</span></th>
<th><span class="math inline">\bot</span></th>
<th><span class="math inline">\wedge</span></th>
<th><span class="math inline">\vee</span></th>
<th><span class="math inline">\rightarrow</span></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td><span class="math inline">a \wedge b</span></td>
<td><span class="math inline">a \vee b</span></td>
<td><span class="math inline">a \rightarrow b</span></td>
</tr>
<tr>
<td>truth</td>
<td>falsehood</td>
<td>conjunction</td>
<td>disjunction</td>
<td>implication</td>
</tr>
<tr>
<td>“trivial”</td>
<td>“impossible”</td>
<td><span class="math inline">a</span> and <span
class="math inline">b</span></td>
<td><span class="math inline">a</span> or <span
class="math inline">b</span></td>
<td><span class="math inline">a</span> gives <span
class="math inline">b</span></td>
</tr>
<tr>
<td></td>
<td>shouldn’t get</td>
<td>got both</td>
<td>got at least one</td>
<td>given <span class="math inline">a</span>, we get <span
class="math inline">b</span></td>
</tr>
</tbody>
</table>
<p>How can we define them? Think in terms of <em>derivation
trees</em>:</p>
<p><span class="math display">
\frac{
\frac{\frac{\,}{\text{a premise}} \; \frac{\,}{\text{another
premise}}}{\text{some fact}} \;
\frac{\frac{\,}{\text{this we have by default}}}{\text{another fact}}}
{\text{final conclusion}}
</span></p>
<p>We define connectives by providing rules for using them. For example,
a rule <span class="math inline">\frac{a \; b}{c}</span> matches parts
of the tree that have two premises, represented by variables <span
class="math inline">a</span> and <span class="math inline">b</span>, and
have any conclusion, represented by variable <span
class="math inline">c</span>.</p>
<p><strong>Design principle:</strong> Try to use only the connective you
define in its definition.</p>
<h3 id="rules-for-logical-connectives">1.2 Rules for Logical
Connectives</h3>
<p><strong>Introduction rules</strong> say how to <em>produce</em> a
connective.</p>
<p><strong>Elimination rules</strong> say how to <em>use</em> it.</p>
<p>Text in parentheses is comments. Letters are variables that can stand
for anything.</p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 38%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr>
<th>Connective</th>
<th>Introduction Rules</th>
<th>Elimination Rules</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\top</span></td>
<td><span class="math inline">\frac{}{\top}</span></td>
<td>doesn’t have</td>
</tr>
<tr>
<td><span class="math inline">\bot</span></td>
<td>doesn’t have</td>
<td><span class="math inline">\frac{\bot}{a}</span> (i.e.,
anything)</td>
</tr>
<tr>
<td><span class="math inline">\wedge</span></td>
<td><span class="math inline">\frac{a \quad b}{a \wedge b}</span></td>
<td><span class="math inline">\frac{a \wedge b}{a}</span> (take first)  
<span class="math inline">\frac{a \wedge b}{b}</span> (take second)</td>
</tr>
<tr>
<td><span class="math inline">\vee</span></td>
<td><span class="math inline">\frac{a}{a \vee b}</span> (put first)  
<span class="math inline">\frac{b}{a \vee b}</span> (put second)</td>
<td><span class="math inline">\frac{a \vee b \quad
\genfrac{}{}{0pt}{}{[a]^x}{\vdots \; c} \quad
\genfrac{}{}{0pt}{}{[b]^y}{\vdots \; c}}{c}</span> using <span
class="math inline">x, y</span></td>
</tr>
<tr>
<td><span class="math inline">\rightarrow</span></td>
<td><span class="math inline">\frac{\genfrac{}{}{0pt}{}{[a]^x}{\vdots \;
b}}{a \rightarrow b}</span> using <span
class="math inline">x</span></td>
<td><span class="math inline">\frac{a \rightarrow b \quad
a}{b}</span></td>
</tr>
</tbody>
</table>
<h4 id="notation-for-hypothetical-derivations">Notation for Hypothetical
Derivations</h4>
<p>The notation <span
class="math inline">\genfrac{}{}{0pt}{}{[a]^x}{\vdots \; b}</span>
(sometimes written as a tree) matches any subtree that derives <span
class="math inline">b</span> and can use <span
class="math inline">a</span> as an assumption (marked with label <span
class="math inline">x</span>), even though <span
class="math inline">a</span> might not otherwise be warranted.</p>
<p>For example, we can derive “sunny <span
class="math inline">\rightarrow</span> happy” by showing that
<em>assuming</em> it’s sunny, we can derive happiness:</p>
<p><span class="math display">
\frac{\frac{\frac{\frac{\frac{\,}{\text{sunny}}^x}{\text{go
outdoor}}}{\text{playing}}}{\text{happy}}}{\text{sunny} \rightarrow
\text{happy}} \text{ using } x
</span></p>
<p>Such assumptions can only be used in the matched subtree! But they
can be used several times. For example, if someone’s mood is more
difficult to influence:</p>
<p><span class="math display">
\frac{\frac{
  \frac{\frac{\frac{\,}{\text{sunny}}^x}{\text{go
outdoor}}}{\text{playing}} \quad
  \frac{\frac{\,}{\text{sunny}}^x \quad
\frac{\frac{\,}{\text{sunny}}^x}{\text{go outdoor}}}{\text{nice view}}
}{\text{happy}}}{\text{sunny} \rightarrow \text{happy}} \text{ using } x
</span></p>
<h4 id="reasoning-by-cases">Reasoning by Cases</h4>
<p>The elimination rule for disjunction represents <strong>reasoning by
cases</strong>.</p>
<p>How can we use the fact that it is sunny <span
class="math inline">\vee</span> cloudy (but not rainy)?</p>
<p><span class="math display">
\frac{
  \frac{\,}{\text{sunny} \vee \text{cloudy}}^{\text{forecast}} \quad
  \frac{\frac{\,}{\text{sunny}}^x}{\text{no-umbrella}} \quad
  \frac{\frac{\,}{\text{cloudy}}^y}{\text{no-umbrella}}
}{\text{no-umbrella}} \text{ using } x, y
</span></p>
<p>We know that it will be sunny or cloudy (by watching the weather
forecast). If it will be sunny, we won’t need an umbrella. If it will be
cloudy, we won’t need an umbrella. Therefore, we won’t need an
umbrella.</p>
<h4 id="reasoning-by-induction">Reasoning by Induction</h4>
<p>We need one more kind of rule to do serious math: <strong>reasoning
by induction</strong> (somewhat similar to reasoning by cases). Example
rule for induction on natural numbers:</p>
<p><span class="math display">
\frac{p(0) \quad \genfrac{}{}{0pt}{}{[p(x)]^x}{\vdots \; p(x+1)}}{p(n)}
\text{ by induction, using } x
</span></p>
<p>We get property <span class="math inline">p</span> for any natural
number <span class="math inline">n</span>, provided we can: 1. Establish
<span class="math inline">p(0)</span> (the base case) 2. Show that
assuming <span class="math inline">p(x)</span> holds, we can derive
<span class="math inline">p(x+1)</span> (the inductive step)</p>
<p>Here <span class="math inline">x</span> is a unique variable—we
cannot substitute a particular number for it because we write “using
<span class="math inline">x</span>” on the side.</p>
<h3 id="logos-was-programmed-in-ocaml">1.3 Logos was Programmed in
OCaml</h3>
<p>There is a deep correspondence between logic and programming, known
as the <strong>Curry-Howard correspondence</strong> (or “propositions as
types”). The following table shows how logical connectives correspond to
programming constructs:</p>
<table>
<thead>
<tr>
<th>Logic</th>
<th>Type</th>
<th>Expression</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\top</span></td>
<td><code>unit</code></td>
<td><code>()</code></td>
</tr>
<tr>
<td><span class="math inline">\bot</span></td>
<td><code>'a</code></td>
<td><code>raise</code></td>
</tr>
<tr>
<td><span class="math inline">\wedge</span></td>
<td><code>*</code></td>
<td><code>(,)</code></td>
</tr>
<tr>
<td><span class="math inline">\vee</span></td>
<td><code>|</code></td>
<td><code>match</code></td>
</tr>
<tr>
<td><span class="math inline">\rightarrow</span></td>
<td><code>-&gt;</code></td>
<td><code>fun</code></td>
</tr>
<tr>
<td>induction</td>
<td>—</td>
<td><code>rec</code></td>
</tr>
</tbody>
</table>
<p><strong>Typing rules for OCaml constructs:</strong></p>
<ul>
<li><p><strong>Unit (truth):</strong> <span
class="math inline">\frac{}{\texttt{()} : \texttt{unit}}</span></p></li>
<li><p><strong>Exception (falsehood):</strong> <span
class="math inline">\frac{\text{oops!}}{\texttt{raise exn} : c}</span> —
can produce any type</p></li>
<li><p><strong>Pair (conjunction):</strong></p>
<ul>
<li>Introduction: <span class="math inline">\frac{s : a \quad t : b}{(s,
t) : a * b}</span></li>
<li>Elimination: <span class="math inline">\frac{p : a *
b}{\texttt{fst}~p : a}</span> and <span class="math inline">\frac{p : a
* b}{\texttt{snd}~p : b}</span></li>
</ul></li>
<li><p><strong>Variant (disjunction):</strong></p>
<ul>
<li>Introduction: <span class="math inline">\frac{s : a}{\texttt{A}(s) :
\texttt{A of}~a~|~\texttt{B of}~b}</span></li>
<li>Elimination (match): given <span class="math inline">t</span> of
variant type and branches for each case, produce result <span
class="math inline">c</span></li>
</ul></li>
<li><p><strong>Function (implication):</strong></p>
<ul>
<li>Introduction: <span class="math inline">\frac{\genfrac{}{}{0pt}{}{[x
: a]}{e : b}}{\texttt{fun}~x \to e : a \to b}</span></li>
<li>Elimination (application): <span class="math inline">\frac{f : a \to
b \quad t : a}{f~t : b}</span></li>
</ul></li>
<li><p><strong>Recursion (induction):</strong> <span
class="math inline">\frac{\genfrac{}{}{0pt}{}{[x : a]}{e :
a}}{\texttt{rec}~x = e : a}</span></p></li>
</ul>
<h4 id="definitions">1.3.1 Definitions</h4>
<p>Writing out expressions and types repetitively is tedious: we need
definitions.</p>
<p><strong>Type definitions</strong> are written: <code>type ty =</code>
some type.</p>
<ul>
<li><p>Writing <code>A(s) : A of a | B of b</code> in the table was
cheating. Usually we have to define the type and then use it. For
example, using <code>int</code> for <span class="math inline">a</span>
and <code>string</code> for <span class="math inline">b</span>:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> int_string_choice = A <span class="kw">of</span> <span class="dt">int</span> | B <span class="kw">of</span> <span class="dt">string</span></span></code></pre></div>
<p>This allows us to write
<code>A(s) : int_string_choice</code>.</p></li>
<li><p>Without the type definition, it is difficult to know what other
variants there are when one <em>infers</em> (i.e., “guesses”, computes)
the type!</p></li>
<li><p>In OCaml we can write <code>`A(s) : [`A of a | `B of b]</code>.
With “<code>`</code>” variants (polymorphic variants), OCaml does guess
what other variants there are. These types are interesting, but we will
not focus on them in this book.</p></li>
<li><p>Tuple elements don’t need labels because we always know at which
position a tuple element stands. But having labels makes code more
clear, so we can define a <em>record type</em>:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> int_string_record = {a: <span class="dt">int</span>; b: <span class="dt">string</span>}</span></code></pre></div>
<p>and create its values: <code>{a = 7; b = "Mary"}</code>.</p></li>
<li><p>We access the <em>fields</em> of records using the dot notation:
<code>{a=7; b="Mary"}.b = "Mary"</code>.</p></li>
</ul>
<h4 id="expression-definitions">1.3.2 Expression Definitions</h4>
<p>The recursive expression <code>rec x = e</code> in the table was
cheating: <code>rec</code> (usually called <code>fix</code> in theory)
cannot appear alone in OCaml! It must be part of a definition.</p>
<p><strong>Definitions for expressions</strong> are introduced by rules
a bit more complex:</p>
<p><span class="math display">
\frac{e_1 : a \quad \frac{[x : a]}{e_2 : b}}{\texttt{let } x = e_1
\texttt{ in } e_2 : b}
</span></p>
<p>(Note that this rule is the same as introducing and eliminating <span
class="math inline">\rightarrow</span>.)</p>
<p>For recursive definitions:</p>
<p><span class="math display">
\frac{\frac{[x : a]}{e_1 : a} \quad \frac{[x : a]}{e_2 : b}}{\texttt{let
rec } x = e_1 \texttt{ in } e_2 : b}
</span></p>
<p>We will cover what is missing in the above rules when we discuss
<strong>polymorphism</strong>.</p>
<h4 id="scoping-rules">1.3.3 Scoping Rules</h4>
<ul>
<li><p><strong>Type definitions</strong> we have seen above are
<em>global</em>: they need to be at the top-level (not nested in
expressions), and they extend from the point they occur till the end of
the source file or interactive session.</p></li>
<li><p><strong><code>let</code>-<code>in</code> definitions</strong> for
expressions: <code>let x = e1 in e2</code> are <em>local</em>—<span
class="math inline">x</span> is only visible in <span
class="math inline">e_2</span>. But <strong><code>let</code>
definitions</strong> without <code>in</code> are global: placing
<code>let x = e1</code> at the top-level makes <span
class="math inline">x</span> visible from after <span
class="math inline">e_1</span> till the end of the source file or
interactive session.</p></li>
<li><p>In the interactive session (toplevel/REPL), we mark the end of a
top-level “sentence” with <code>;;</code>—this is unnecessary in source
files.</p></li>
</ul>
<h4 id="operators">1.3.4 Operators</h4>
<p>Operators like <code>+</code>, <code>*</code>, <code>&lt;</code>,
<code>=</code> are names of functions. Just like other names, you can
use operator names for your own functions:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (+:) a b = <span class="dt">String</span>.concat <span class="st">&quot;&quot;</span> [a; b]  <span class="co">(* Special way of defining *)</span></span></code></pre></div>
<div class="sourceCode" id="cb4"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;Alpha&quot;</span> +: <span class="st">&quot;Beta&quot;</span>  <span class="co">(* but normal way of using operators *)</span></span></code></pre></div>
<p>Operators in OCaml are <strong>not overloaded</strong>. This means
that every type needs its own set of operators: - <code>+</code>,
<code>*</code>, <code>/</code> work for integers - <code>+.</code>,
<code>*.</code>, <code>/.</code> work for floating point numbers</p>
<p><strong>Exception:</strong> Comparisons <code>&lt;</code>,
<code>=</code>, etc. work for all values other than functions.</p>
<h3 id="exercises">1.4 Exercises</h3>
<p>Exercises from <em>Think OCaml: How to Think Like a Computer
Scientist</em> by Nicholas Monje and Allen Downey.</p>
<ol type="1">
<li><p>Assume that we execute the following assignment statements:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> width = <span class="dv">17</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> height = <span class="fl">12.0</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> delimiter = <span class="ch">&#39;.&#39;</span></span></code></pre></div>
<p>For each of the following expressions, write the value of the
expression and the type (of the value of the expression), or the
resulting type error.</p>
<ol type="1">
<li><code>width/2</code></li>
<li><code>width/.2.0</code></li>
<li><code>height/3</code></li>
<li><code>1 + 2 * 5</code></li>
<li><code>delimiter * 5</code></li>
</ol></li>
<li><p>Practice using the OCaml interpreter as a calculator:</p>
<ol type="1">
<li>The volume of a sphere with radius <span
class="math inline">r</span> is <span class="math inline">\frac{4}{3}
\pi r^3</span>. What is the volume of a sphere with radius 5?
(<em>Hint:</em> 392.6 is wrong!)</li>
<li>Suppose the cover price of a book is $24.95, but bookstores get a
40% discount. Shipping costs $3 for the first copy and 75 cents for each
additional copy. What is the total wholesale cost for 60 copies?</li>
<li>If I leave my house at 6:52 am and run 1 mile at an easy pace (8:15
per mile), then 3 miles at tempo (7:12 per mile) and 1 mile at easy pace
again, what time do I get home for breakfast?</li>
</ol></li>
<li><p>You’ve probably heard of the Fibonacci numbers before, but in
case you haven’t, they’re defined by the following recursive
relationship: <span class="math display">
\begin{cases}
f(0) = 0 \\
f(1) = 1 \\
f(n+1) = f(n) + f(n-1) &amp; \text{for } n = 2, 3, \ldots
\end{cases}
</span> Write a recursive function to calculate these numbers.</p></li>
<li><p>A palindrome is a word that is spelled the same backward and
forward, like “noon” and “redivider”. Recursively, a word is a
palindrome if the first and last letters are the same and the middle is
a palindrome.</p>
<p>The following are functions that take a string argument and return
the first, last, and middle letters:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> first_char word = word.[<span class="dv">0</span>]</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> last_char word =</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> len = <span class="dt">String</span>.length word - <span class="dv">1</span> <span class="kw">in</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  word.[len]</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> middle word =</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> len = <span class="dt">String</span>.length word - <span class="dv">2</span> <span class="kw">in</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">String</span>.sub word <span class="dv">1</span> len</span></code></pre></div>
<ol type="1">
<li>Enter these functions into the toplevel and test them out. What
happens if you call <code>middle</code> with a string with two letters?
One letter? What about the empty string <code>""</code>?</li>
<li>Write a function called <code>is_palindrome</code> that takes a
string argument and returns <code>true</code> if it is a palindrome and
<code>false</code> otherwise.</li>
</ol></li>
<li><p>The greatest common divisor (GCD) of <span
class="math inline">a</span> and <span class="math inline">b</span> is
the largest number that divides both of them with no remainder.</p>
<p>One way to find the GCD of two numbers is Euclid’s algorithm, which
is based on the observation that if <span class="math inline">r</span>
is the remainder when <span class="math inline">a</span> is divided by
<span class="math inline">b</span>, then <span
class="math inline">\gcd(a, b) = \gcd(b, r)</span>. As a base case, we
can consider <span class="math inline">\gcd(a, 0) = a</span>.</p>
<p>Write a function called <code>gcd</code> that takes parameters
<code>a</code> and <code>b</code> and returns their greatest common
divisor.</p>
<p>If you need help, see <a
href="http://en.wikipedia.org/wiki/Euclidean_algorithm">http://en.wikipedia.org/wiki/Euclidean_algorithm</a>.</p></li>
</ol>
<h2 id="chapter-2-algebra">Chapter 2: Algebra</h2>
<p><em>Algebraic Data Types and some curious analogies</em></p>
<h3 id="a-glimpse-at-type-inference">2.1 A Glimpse at Type
Inference</h3>
<p>For a refresher, let us apply the type inference rules introduced in
Chapter 1 to some simple examples. We will start with the identity
function <code>fun x -&gt; x</code>. In the derivations below, <span
class="math inline">[?]</span> means “type unknown yet.”</p>
<p>We begin with an incomplete derivation:</p>
<p><span class="math display">
\frac{[?]}{\texttt{fun x -&gt; x} : [?]}
</span></p>
<p>Using the <span class="math inline">\rightarrow</span> introduction
rule, we need to derive the body <code>x</code> assuming <code>x</code>
has some type <span class="math inline">a</span>:</p>
<p><span class="math display">
\frac{\frac{\,}{\texttt{x} : a}^x}{\texttt{fun x -&gt; x} : [?]
\rightarrow [?]}
</span></p>
<p>The premise <span class="math inline">\frac{\,}{\texttt{x} :
a}^x</span> matches the pattern for hypothetical derivations since <span
class="math inline">e = \texttt{x}</span>. Since the body <code>x</code>
has type <span class="math inline">a</span> (from our assumption), and
the parameter <code>x</code> also has type <span
class="math inline">a</span>, we conclude:</p>
<p><span class="math display">
\frac{\frac{\,}{\texttt{x} : a}^x}{\texttt{fun x -&gt; x} : a
\rightarrow a}
</span></p>
<p>Because <span class="math inline">a</span> is arbitrary (we made no
assumptions constraining it), OCaml introduces a <em>type variable</em>
<code>'a</code> to represent it:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">fun</span> x -&gt; x;;</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>- : &#39;a -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
<h4 id="a-more-complex-example">A More Complex Example</h4>
<p>Let us try <code>fun x -&gt; x+1</code>, which is the same as
<code>fun x -&gt; ((+) x) 1</code> (try it in OCaml!). We will use the
notation <span class="math inline">[?\alpha]</span> to mean “type
unknown yet, but the same as in other places marked <span
class="math inline">[?\alpha]</span>.”</p>
<p>Starting the derivation and applying <span
class="math inline">\rightarrow</span> introduction:</p>
<p><span class="math display">
\frac{\frac{[?]}{\texttt{((+) x) 1} : [?\alpha]}}{\texttt{fun x -&gt;
((+) x) 1} : [?] \rightarrow [?\alpha]}
</span></p>
<p>Applying <span class="math inline">\rightarrow</span> elimination
(function application) to <code>((+) x) 1</code>:</p>
<p><span class="math display">
\frac{\frac{\frac{[?]}{\texttt{(+) x} : [?\beta] \rightarrow [?\alpha]}
\quad \frac{[?]}{\texttt{1} : [?\beta]}}{\texttt{((+) x) 1} :
[?\alpha]}}{\texttt{fun x -&gt; ((+) x) 1} : [?] \rightarrow [?\alpha]}
</span></p>
<p>We know that <code>1 : int</code>, so <span
class="math inline">[?\beta] = \texttt{int}</span>:</p>
<p><span class="math display">
\frac{\frac{\frac{[?]}{\texttt{(+) x} : \texttt{int} \rightarrow
[?\alpha]} \quad \frac{\,}{\texttt{1} :
\texttt{int}}^{\text{(constant)}}}{\texttt{((+) x) 1} :
[?\alpha]}}{\texttt{fun x -&gt; ((+) x) 1} : [?] \rightarrow [?\alpha]}
</span></p>
<p>Applying function application again to <code>(+) x</code>:</p>
<p><span class="math display">
\frac{\frac{\frac{\frac{[?]}{\texttt{(+)} : [?\gamma] \rightarrow
\texttt{int} \rightarrow [?\alpha]} \quad \frac{[?]}{\texttt{x} :
[?\gamma]}}{\texttt{(+) x} : \texttt{int} \rightarrow [?\alpha]} \quad
\frac{\,}{\texttt{1} : \texttt{int}}^{\text{(constant)}}}{\texttt{((+)
x) 1} : [?\alpha]}}{\texttt{fun x -&gt; ((+) x) 1} : [?\gamma]
\rightarrow [?\alpha]}
</span></p>
<p>Since <code>(+) : int -&gt; int -&gt; int</code>, we have <span
class="math inline">[?\gamma] = \texttt{int}</span> and <span
class="math inline">[?\alpha] = \texttt{int}</span>:</p>
<p><span class="math display">
\frac{\frac{\frac{\frac{\,}{\texttt{(+)} : \texttt{int} \rightarrow
\texttt{int} \rightarrow \texttt{int}}^{\text{(constant)}} \quad
\frac{\,}{\texttt{x} : \texttt{int}}^x}{\texttt{(+) x} : \texttt{int}
\rightarrow \texttt{int}} \quad \frac{\,}{\texttt{1} :
\texttt{int}}^{\text{(constant)}}}{\texttt{((+) x) 1} :
\texttt{int}}}{\texttt{fun x -&gt; ((+) x) 1} : \texttt{int} \rightarrow
\texttt{int}}
</span></p>
<h4 id="curried-form">2.1.1 Curried Form</h4>
<p>When there are several arrows “on the same depth” in a function type,
it means that the function returns a function. For example,
<code>(+) : int -&gt; int -&gt; int</code> is just a shorthand for
<code>(+) : int -&gt; (int -&gt; int)</code>. This is very different
from:</p>
<p><span class="math display">
\texttt{fun f -&gt; (f 1) + 1} : (\texttt{int} \rightarrow \texttt{int})
\rightarrow \texttt{int}
</span></p>
<p>In the first case, <code>(+)</code> is a function that takes an
integer and returns a function from integers to integers. In the second
case, we have a function that takes a function as an argument.</p>
<p>For addition, instead of <code>(fun x -&gt; x+1)</code> we can write
<code>((+) 1)</code>. What expanded form does <code>((+) 1)</code>
correspond to exactly (computationally)? It corresponds to
<code>fun y -&gt; 1 + y</code>.</p>
<p>We will become more familiar with functions returning functions when
we study the <em>lambda calculus</em> in a later chapter.</p>
<h3 id="algebraic-data-types">2.2 Algebraic Data Types</h3>
<p>In Chapter 1, we learned about the <code>unit</code> type and variant
types like:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> int_string_choice = A <span class="kw">of</span> <span class="dt">int</span> | B <span class="kw">of</span> <span class="dt">string</span></span></code></pre></div>
<p>We also covered tuple types, record types, and type definitions. Let
us now explore these concepts more deeply.</p>
<h4 id="variants-without-arguments">Variants Without Arguments</h4>
<p>Variants do not have to carry arguments. Instead of writing
<code>A of unit</code>, we can simply use <code>A</code>. This is more
convenient and idiomatic:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> color = Red | Green | Blue</span></code></pre></div>
<p><strong>A subtle point about OCaml:</strong> In OCaml, variants take
multiple arguments rather than taking tuples as arguments. This means
<code>A of int * string</code> is different from
<code>A of (int * string)</code>. The first takes two separate
arguments, while the second takes a single tuple argument. This
distinction is usually not important unless you encounter situations
where it matters.</p>
<h4 id="recursive-type-definitions">Recursive Type Definitions</h4>
<p>Type definitions can be recursive! This allows us to define data
structures of arbitrary size:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> int_list = Empty | Cons <span class="kw">of</span> <span class="dt">int</span> * int_list</span></code></pre></div>
<p>Let us see what values inhabit <code>int_list</code>: -
<code>Empty</code> represents the empty list -
<code>Cons (5, Empty)</code> is a list containing just 5 -
<code>Cons (5, Cons (7, Cons (13, Empty)))</code> is a list containing
5, 7, and 13</p>
<p>The built-in type <code>bool</code> can be viewed as if it were
defined as <code>type bool = true | false</code>. Similarly,
<code>int</code> can be thought of as a very large variant:
<code>type int = 0 | -1 | 1 | -2 | 2 | ...</code></p>
<h4 id="parametric-type-definitions">Parametric Type Definitions</h4>
<p>Type definitions can be <em>parametric</em> with respect to the types
of their components. This allows us to define generic data structures
that work with any element type. For example, a list of elements of
arbitrary type:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;elem <span class="dt">list</span> = Empty | Cons <span class="kw">of</span> &#39;elem * &#39;elem <span class="dt">list</span></span></code></pre></div>
<p>Several conventions and syntax rules apply to parametric types:</p>
<ul>
<li><p>Type variables must start with <code>'</code>, but since OCaml
will not remember the names we give, it is customary to use the names
OCaml uses: <code>'a</code>, <code>'b</code>, <code>'c</code>,
<code>'d</code>, etc.</p></li>
<li><p>The OCaml syntax places the type parameter before the type name,
mimicking English word order. A silly example:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;white_color dog = Dog <span class="kw">of</span> &#39;white_color</span></code></pre></div></li>
<li><p>With multiple parameters, OCaml uses parentheses:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (&#39;a, &#39;b) choice = Left <span class="kw">of</span> &#39;a | Right <span class="kw">of</span> &#39;b</span></code></pre></div>
<p>Compare this to F# syntax:
<code>type choice&lt;'a,'b&gt; = Left of 'a | Right of 'b</code></p>
<p>And Haskell syntax:
<code>data Choice a b = Left a | Right b</code></p></li>
</ul>
<h3 id="syntactic-conventions">2.3 Syntactic Conventions</h3>
<h4 id="constructor-naming">Constructor Naming</h4>
<p>Names of variants, called <em>constructors</em>, must start with a
capital letter. If we wanted to define our own booleans, we would
write:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> my_bool = True | False</span></code></pre></div>
<p>Only constructors and module names can start with capital letters in
OCaml. <em>Modules</em> are organizational units (like “shelves”)
containing related values. For example, the <code>List</code> module
provides operations on lists, including <code>List.map</code> and
<code>List.filter</code>.</p>
<h4 id="accessing-record-fields">Accessing Record Fields</h4>
<p>We can use dot notation to access record fields:
<code>record.field</code>. For example, if we have
<code>let person = {name="Alice"; age=30}</code>, we can write
<code>person.name</code> to get <code>"Alice"</code>.</p>
<h4 id="function-definition-shortcuts">Function Definition
Shortcuts</h4>
<p>Several syntactic shortcuts make function definitions more
concise:</p>
<ul>
<li><p><code>fun x y -&gt; e</code> stands for
<code>fun x -&gt; fun y -&gt; e</code>. Note that
<code>fun x -&gt; fun y -&gt; e</code> parses as
<code>fun x -&gt; (fun y -&gt; e)</code>.</p></li>
<li><p><code>function A x -&gt; e1 | B y -&gt; e2</code> stands for
<code>fun p -&gt; match p with A x -&gt; e1 | B y -&gt; e2</code>. The
general form is: <code>function PATTERN-MATCHING</code> stands for
<code>fun v -&gt; match v with PATTERN-MATCHING</code>.</p></li>
<li><p><code>let f ARGS = e</code> is a shorthand for
<code>let f = fun ARGS -&gt; e</code>.</p></li>
</ul>
<h3 id="pattern-matching">2.4 Pattern Matching</h3>
<p>Recall that we introduced <code>fst</code> and <code>snd</code> as
means to access elements of a pair. But what about larger tuples? The
fundamental way to access any tuple uses the <code>match</code>
construct. In fact, <code>fst</code> and <code>snd</code> can easily be
defined using pattern matching:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">fst</span> = <span class="kw">fun</span> p -&gt; <span class="kw">match</span> p <span class="kw">with</span> (a, b) -&gt; a</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">snd</span> = <span class="kw">fun</span> p -&gt; <span class="kw">match</span> p <span class="kw">with</span> (a, b) -&gt; b</span></code></pre></div>
<h4 id="matching-on-records">Matching on Records</h4>
<p>Pattern matching also works with records:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> person = {name: <span class="dt">string</span>; surname: <span class="dt">string</span>; age: <span class="dt">int</span>}</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> greet_person () =</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> {name=<span class="st">&quot;Walker&quot;</span>; surname=<span class="st">&quot;Johnnie&quot;</span>; age=<span class="dv">207</span>}</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">with</span> {name=n; surname=sn; age=a} -&gt; <span class="st">&quot;Hi &quot;</span> ^ sn ^ <span class="st">&quot;!&quot;</span></span></code></pre></div>
<h4 id="understanding-patterns">Understanding Patterns</h4>
<p>The left-hand sides of <code>-&gt;</code> in <code>match</code>
expressions are called <strong>patterns</strong>. Patterns describe the
structure of values we want to match against.</p>
<p>Patterns can be nested, allowing us to match complex structures:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> <span class="dt">Some</span> (<span class="dv">5</span>, <span class="dv">7</span>) <span class="kw">with</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>| <span class="dt">None</span> -&gt; <span class="st">&quot;sum: nothing&quot;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>| <span class="dt">Some</span> (x, y) -&gt; <span class="st">&quot;sum: &quot;</span> ^ <span class="dt">string_of_int</span> (x+y)</span></code></pre></div>
<h4 id="simple-patterns-and-wildcards">Simple Patterns and
Wildcards</h4>
<p>A pattern can simply bind the entire value without destructuring.
Writing <code>match f x with v -&gt; ...</code> is the same as
<code>let v = f x in ...</code>.</p>
<p>When we do not need a value in a pattern, it is good practice to use
the underscore <code>_</code>, which is a wildcard (not a variable):</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">fst</span> (a, _) = a</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">snd</span> (_, b) = b</span></code></pre></div>
<h4 id="pattern-linearity">Pattern Linearity</h4>
<p>A variable can only appear once in a pattern. This property is called
<em>linearity</em>. However, we can add conditions to patterns using
<code>when</code>, so linearity is not a limitation:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> describe_point p =</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> p <span class="kw">with</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  | (x, y) <span class="kw">when</span> x = y -&gt; <span class="st">&quot;diag&quot;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; <span class="st">&quot;off-diag&quot;</span></span></code></pre></div>
<p>Here is a more elaborate example:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">compare</span> a b = <span class="kw">match</span> a, b <span class="kw">with</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  | (x, y) <span class="kw">when</span> x &lt; y -&gt; <span class="dv">-1</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  | (x, y) <span class="kw">when</span> x = y -&gt; <span class="dv">0</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; <span class="dv">1</span></span></code></pre></div>
<h4 id="partial-record-patterns">Partial Record Patterns</h4>
<p>We can skip unused fields of a record in a pattern. Only the fields
we care about need to be mentioned.</p>
<h4 id="or-patterns">Or-Patterns</h4>
<p>We can compress patterns by using <code>|</code> inside a single
pattern to match multiple alternatives:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> month =</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  | Jan | Feb | Mar | Apr | May | Jun</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  | Jul | Aug | Sep | Oct | Nov | Dec</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> weekday = Mon | Tue | Wed | Thu | Fri | Sat | Sun</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date =</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>  {year: <span class="dt">int</span>; month: month; day: <span class="dt">int</span>; weekday: weekday}</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> day =</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>  {year = <span class="dv">2012</span>; month = Feb; day = <span class="dv">14</span>; weekday = Wed};;</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> day <span class="kw">with</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>  | {weekday = Sat | Sun} -&gt; <span class="st">&quot;Weekend!&quot;</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; <span class="st">&quot;Work day&quot;</span></span></code></pre></div>
<h4 id="named-patterns-with-as">Named Patterns with <code>as</code></h4>
<p>We use <code>(pattern as v)</code> to name a nested pattern, binding
the matched value to <code>v</code>:</p>
<pre><code>match day with
  | {weekday = (Mon | Tue | Wed | Thu | Fri as wday)}
      when not (day.month = Dec &amp;&amp; day.day = 24) -&gt;
    Some (work (get_plan wday))
  | _ -&gt; None</code></pre>
<p>This example shows the <code>as</code> keyword binding the matched
weekday to <code>wday</code> for use in the expression on the right side
of the arrow.</p>
<h3 id="interpreting-algebraic-data-types-as-polynomials">2.5
Interpreting Algebraic Data Types as Polynomials</h3>
<p>Let us explore a curious analogy between algebraic data types and
polynomials. We translate data types to mathematical expressions by:</p>
<ul>
<li>Replacing <code>|</code> (variant choice) with <span
class="math inline">+</span></li>
<li>Replacing <code>*</code> (tuple product) with <span
class="math inline">\times</span></li>
<li>Treating record types as tuple types (erasing field names and
translating <code>;</code> as <span
class="math inline">\times</span>)</li>
</ul>
<p>We also need translations for some special types:</p>
<ul>
<li><p>The <strong>void type</strong> (a type with no constructors,
hence no values):</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> void</span></code></pre></div>
<p>(Yes, this is its complete definition, with no
<code>= something</code> part.) Translate it as <span
class="math inline">0</span>.</p></li>
<li><p>The <strong>unit type</strong> translates as <span
class="math inline">1</span>. Since variants without arguments behave
like variants <code>of unit</code>, translate them as <span
class="math inline">1</span> as well.</p></li>
<li><p>The <strong>bool type</strong> translates as <span
class="math inline">2</span>.</p></li>
<li><p>Types like <code>int</code>, <code>string</code>,
<code>float</code>, and type parameters translate as variables.</p></li>
<li><p>Defined types translate according to their definitions
(substituting variables as necessary).</p></li>
</ul>
<p>Give a name to the type being defined (representing a function of the
introduced variables). Now interpret the result as an ordinary numeric
polynomial! (Or a “rational function” if recursively defined.)</p>
<p>Let us have some fun with this translation.</p>
<h4 id="example-date-type">Example: Date Type</h4>
<div class="sourceCode" id="cb24"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = {year: <span class="dt">int</span>; month: <span class="dt">int</span>; day: <span class="dt">int</span>}</span></code></pre></div>
<p>Translating to a polynomial (using <span class="math inline">x</span>
for <code>int</code>):</p>
<p><span class="math display">D = x \times x \times x = x^3</span></p>
<h4 id="example-option-type">Example: Option Type</h4>
<p>The built-in option type is defined as:</p>
<pre><code>type &#39;a option = None | Some of &#39;a</code></pre>
<p>Translating:</p>
<p><span class="math display">O = 1 + x</span></p>
<h4 id="example-list-type">Example: List Type</h4>
<div class="sourceCode" id="cb26"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a my_list = Empty | Cons <span class="kw">of</span> &#39;a * &#39;a my_list</span></code></pre></div>
<p>Translating (where <span class="math inline">L</span> represents the
list type):</p>
<p><span class="math display">L = 1 + x \cdot L</span></p>
<h4 id="example-binary-tree-type">Example: Binary Tree Type</h4>
<div class="sourceCode" id="cb27"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree = Tip | Node <span class="kw">of</span> <span class="dt">int</span> * btree * btree</span></code></pre></div>
<p>Translating:</p>
<p><span class="math display">T = 1 + x \cdot T \cdot T = 1 + x \cdot
T^2</span></p>
<h4 id="type-isomorphisms">Type Isomorphisms</h4>
<p>When translations of two types are equal according to the laws of
high-school algebra, the types are <em>isomorphic</em>. This means there
exist bijective (one-to-one and onto) functions between them.</p>
<p>Let us manipulate the binary tree polynomial:</p>
<p><span class="math display">
\begin{aligned}
T &amp;= 1 + x \cdot T^2 \\
  &amp;= 1 + x \cdot T + x^2 \cdot T^3 \\
  &amp;= 1 + x + x^2 \cdot T^2 + x^2 \cdot T^3 \\
  &amp;= 1 + x + x^2 \cdot T^2 \cdot (1 + T) \\
  &amp;= 1 + x \cdot (1 + x \cdot T^2 \cdot (1 + T))
\end{aligned}
</span></p>
<p>Now let us translate the resulting expression back to a type:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> repr =</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">int</span> * (<span class="dt">int</span> * btree * btree * btree <span class="dt">option</span>) <span class="dt">option</span>) <span class="dt">option</span></span></code></pre></div>
<p>The challenge is to find isomorphism functions with signatures:</p>
<pre><code>val iso1 : btree -&gt; repr
val iso2 : repr -&gt; btree</code></pre>
<p>These functions should satisfy: for all trees <code>t</code>,
<code>iso2 (iso1 t) = t</code>, and for all representations
<code>r</code>, <code>iso1 (iso2 r) = r</code>.</p>
<h4 id="a-first-attempt">A First Attempt</h4>
<p>Here is a first (failed) attempt:</p>
<pre><code># let iso1 (t : btree) : repr =
  match t with
    | Tip -&gt; None
    | Node (x, Tip, Tip) -&gt; Some (x, None)
    | Node (x, Node (y, t1, t2), Tip) -&gt;
      Some (x, Some (y, t1, t2, None))
    | Node (x, Node (y, t1, t2), t3) -&gt;
      Some (x, Some (y, t1, t2, Some t3));;

Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Node (_, Tip, Node (_, _, _))</code></pre>
<p>We forgot about one case! It seems difficult to guess the solution
directly.</p>
<h4 id="breaking-down-the-problem">Breaking Down the Problem</h4>
<p>Let us divide the task into smaller steps corresponding to
intermediate points in the polynomial transformation:</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (&#39;a, &#39;b) choice = Left <span class="kw">of</span> &#39;a | Right <span class="kw">of</span> &#39;b</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> interm1 =</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>  ((<span class="dt">int</span> * btree, <span class="dt">int</span> * <span class="dt">int</span> * btree * btree * btree) choice)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">option</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> interm2 =</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>  ((<span class="dt">int</span>, <span class="dt">int</span> * <span class="dt">int</span> * btree * btree * btree <span class="dt">option</span>) choice)</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">option</span></span></code></pre></div>
<p>Now we can define each step:</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> step1r (t : btree) : interm1 =</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> t <span class="kw">with</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    | Tip -&gt; <span class="dt">None</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    | Node (x, t1, Tip) -&gt; <span class="dt">Some</span> (Left (x, t1))</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    | Node (x, t1, Node (y, t2, t3)) -&gt;</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Some</span> (Right (x, y, t1, t2, t3))</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> step2r (r : interm1) : interm2 =</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> r <span class="kw">with</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">None</span> -&gt; <span class="dt">None</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (Left (x, Tip)) -&gt; <span class="dt">Some</span> (Left x)</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (Left (x, Node (y, t1, t2))) -&gt;</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Some</span> (Right (x, y, t1, t2, <span class="dt">None</span>))</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (Right (x, y, t1, t2, t3)) -&gt;</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Some</span> (Right (x, y, t1, t2, <span class="dt">Some</span> t3))</span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> step3r (r : interm2) : repr =</span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> r <span class="kw">with</span></span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">None</span> -&gt; <span class="dt">None</span></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (Left x) -&gt; <span class="dt">Some</span> (x, <span class="dt">None</span>)</span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (Right (x, y, t1, t2, t3opt)) -&gt;</span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Some</span> (x, <span class="dt">Some</span> (y, t1, t2, t3opt))</span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> iso1 (t : btree) : repr =</span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a>  step3r (step2r (step1r t))</span></code></pre></div>
<p>Defining <code>step1l</code>, <code>step2l</code>,
<code>step3l</code>, and <code>iso2</code> is now straightforward—each
step is the inverse of its corresponding forward step.</p>
<h4 id="take-home-lessons">Take-Home Lessons</h4>
<ol type="1">
<li><p><strong>Design for validity:</strong> Try to define data
structures so that only meaningful information can be represented—as
long as it does not overcomplicate the data structures. Avoid catch-all
clauses when defining functions. The compiler will then tell you if you
have forgotten about a case.</p></li>
<li><p><strong>Divide and conquer:</strong> Break solutions into small
steps so that each step can be easily understood and verified.</p></li>
</ol>
<h3 id="differentiating-algebraic-data-types">2.6 Differentiating
Algebraic Data Types</h3>
<p>The title might seem strange—we will differentiate the translated
polynomials, not the types themselves. But what sense does this
make?</p>
<p>It turns out that taking the partial derivative of a polynomial
(translated from a data type), when translated back, gives a type
representing how to change one occurrence of a value corresponding to
the variable with respect to which we differentiated. In other words,
the derivative represents a “context” or “hole” in the data
structure.</p>
<h4 id="example-differentiating-the-date-type">Example: Differentiating
the Date Type</h4>
<div class="sourceCode" id="cb33"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = {year: <span class="dt">int</span>; month: <span class="dt">int</span>; day: <span class="dt">int</span>}</span></code></pre></div>
<p>The translation:</p>
<p><span class="math display">
\begin{aligned}
D &amp;= x \cdot x \cdot x = x^3 \\
\frac{\partial D}{\partial x} &amp;= 3x^2 = x \cdot x + x \cdot x + x
\cdot x
\end{aligned}
</span></p>
<p>We could have left it as <span class="math inline">3 \cdot x \cdot
x</span>, but expanding shows the structure more clearly. Translating
back to a type:</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date_deriv =</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>  Year <span class="kw">of</span> <span class="dt">int</span> * <span class="dt">int</span> | Month <span class="kw">of</span> <span class="dt">int</span> * <span class="dt">int</span> | Day <span class="kw">of</span> <span class="dt">int</span> * <span class="dt">int</span></span></code></pre></div>
<p>Each variant represents a “hole” at a different position:
<code>Year</code> means the year field is missing (and we have the month
and day), and so on.</p>
<p>Now we can define functions to introduce and eliminate this
derivative type:</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> date_deriv {year=y; month=m; day=d} =</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  [Year (m, d); Month (y, d); Day (y, m)]</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> date_integr n = <span class="kw">function</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>  | Year (m, d) -&gt; {year=n; month=m; day=d}</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>  | Month (y, d) -&gt; {year=y; month=n; day=d}</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>  | Day (y, m) -&gt; {year=y; month=m; day=n}</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>;;</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.map (date_integr <span class="dv">7</span>)</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>  (date_deriv {year=<span class="dv">2012</span>; month=<span class="dv">2</span>; day=<span class="dv">14</span>})</span></code></pre></div>
<p>The <code>date_deriv</code> function produces all contexts (one for
each field), and <code>date_integr</code> fills in a hole with a new
value.</p>
<h4 id="example-differentiating-binary-trees">Example: Differentiating
Binary Trees</h4>
<p>Let us tackle the more challenging case of binary trees:</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree = Tip | Node <span class="kw">of</span> <span class="dt">int</span> * btree * btree</span></code></pre></div>
<p>The translation and differentiation:</p>
<p><span class="math display">
\begin{aligned}
T &amp;= 1 + x \cdot T^2 \\
\frac{\partial T}{\partial x} &amp;= 0 + T^2 + 2 \cdot x \cdot T \cdot
\frac{\partial T}{\partial x} = T \cdot T + 2 \cdot x \cdot T \cdot
\frac{\partial T}{\partial x}
\end{aligned}
</span></p>
<p>The derivative is recursive! This makes sense: a context in a tree is
either at the current node (<span class="math inline">T \cdot T</span>,
the two subtrees) or somewhere below (<span class="math inline">2 \cdot
x \cdot T \cdot \frac{\partial T}{\partial x}</span>, choosing left or
right, with the node value, the other subtree, and a deeper
context).</p>
<p>Instead of translating <span class="math inline">2</span> as
<code>bool</code>, we introduce a more descriptive type:</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree_dir = LeftBranch | RightBranch</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree_deriv =</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>  | Here <span class="kw">of</span> btree * btree</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>  | Below <span class="kw">of</span> btree_dir * <span class="dt">int</span> * btree * btree_deriv</span></code></pre></div>
<p>(You might someday hear about <em>zippers</em>—they are “inverted”
relative to our type, with the hole coming first.)</p>
<p>The integration function fills the hole with a value:</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> btree_integr n = <span class="kw">function</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>  | Here (ltree, rtree) -&gt; Node (n, ltree, rtree)</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>  | Below (LeftBranch, m, rtree, deriv) -&gt;</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    Node (m, btree_integr n deriv, rtree)</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>  | Below (RightBranch, m, ltree, deriv) -&gt;</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>    Node (m, ltree, btree_integr n deriv)</span></code></pre></div>
<h3 id="exercises-1">2.7 Exercises</h3>
<h4 id="exercise-1">Exercise 1</h4>
<p><em>Due to Yaron Minsky.</em></p>
<p>Consider a datatype to store internet connection information. The
time <code>when_initiated</code> marks the start of connecting and is
not needed after the connection is established (it is only used to
decide whether to give up trying to connect). The ping information is
available for established connections but not straight away.</p>
<pre><code>type connectionstate = Connecting | Connected | Disconnected

type connectioninfo = {
  state : connectionstate;
  server : Inetaddr.t;
  lastpingtime : Time.t option;
  lastpingid : int option;
  sessionid : string option;
  wheninitiated : Time.t option;
  whendisconnected : Time.t option;
}</code></pre>
<p>(The types <code>Time.t</code> and <code>Inetaddr.t</code> come from
the <em>Core</em> library. You can replace them with <code>float</code>
and <code>Unix.inet_addr</code>. Load the Unix library in the
interactive toplevel with <code>#load "unix.cma";;</code>.)</p>
<p>Rewrite the type definitions so that the datatype will contain only
reasonable combinations of information.</p>
<h4 id="exercise-2">Exercise 2</h4>
<p>In OCaml, functions can have labeled arguments and optional arguments
(parameters with default values that can be omitted). Labels can differ
from the names of argument values:</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f ~meaningfulname:n = n + <span class="dv">1</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> _ = f ~meaningfulname:<span class="dv">5</span>  <span class="co">(* We do not need the result so we ignore it. *)</span></span></code></pre></div>
<p>When the label and value names are the same, the syntax is
shorter:</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> g ~pos ~len =</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">StringLabels</span>.sub <span class="st">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span> ~pos ~len</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () =  <span class="co">(* A nicer way to mark computations that return unit. *)</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> pos = <span class="dt">Random</span>.<span class="dt">int</span> <span class="dv">26</span> <span class="kw">in</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> len = <span class="dt">Random</span>.<span class="dt">int</span> <span class="dv">10</span> <span class="kw">in</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">print_string</span> (g ~pos ~len)</span></code></pre></div>
<p>When some function arguments are optional, the function must take
non-optional arguments after the last optional argument. Optional
parameters with default values:</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> h ?(len=<span class="dv">1</span>) pos = g ~pos ~len</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () = <span class="dt">print_string</span> (h <span class="dv">10</span>)</span></code></pre></div>
<p>Optional arguments are implemented as parameters of an option type.
This allows checking whether the argument was provided:</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo ?bar n =</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> bar <span class="kw">with</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">None</span> -&gt; <span class="st">&quot;Argument = &quot;</span> ^ <span class="dt">string_of_int</span> n</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> m -&gt; <span class="st">&quot;Sum = &quot;</span> ^ <span class="dt">string_of_int</span> (m + n)</span></code></pre></div>
<p>We can use it in various ways:</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> _ = foo <span class="dv">5</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> _ = foo ~bar:<span class="dv">5</span> <span class="dv">7</span></span></code></pre></div>
<p>We can also provide the option value directly:</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> test_foo () =</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> bar = <span class="kw">if</span> <span class="dt">Random</span>.<span class="dt">int</span> <span class="dv">10</span> &lt; <span class="dv">5</span> <span class="kw">then</span> <span class="dt">None</span> <span class="kw">else</span> <span class="dt">Some</span> <span class="dv">7</span> <span class="kw">in</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>  foo ?bar <span class="dv">7</span></span></code></pre></div>
<ol type="1">
<li><p>Observe the types that functions with labeled and optional
arguments have. Come up with coding style guidelines for when to use
labeled arguments.</p></li>
<li><p>Write a rectangle-drawing procedure that takes three optional
arguments: left-upper corner, right-lower corner, and a width-height
pair. It should draw a correct rectangle whenever two arguments are
given, and raise an exception otherwise. Load the graphics library with
<code>#load "graphics.cma";;</code>. Use <code>invalid_arg</code>,
<code>Graphics.open_graph</code>, and
<code>Graphics.draw_rect</code>.</p></li>
<li><p>Write a function that takes an optional argument of arbitrary
type and a function argument, and passes the optional argument to the
function without inspecting it.</p></li>
</ol>
<h4 id="exercise-3">Exercise 3</h4>
<p><em>From a past exam.</em></p>
<ol type="1">
<li>Give the (most general) types of the following expressions, either
by guessing or by inferring by hand:
<ol type="1">
<li><code>let double f y = f (f y) in fun g x -&gt; double (g x)</code></li>
<li><code>let rec tails l = match l with [] -&gt; [] | x::xs -&gt; xs::tails xs in fun l -&gt; List.combine l (tails l)</code></li>
</ol></li>
<li>Give example expressions that have the following types (without
using type constraints):
<ol type="1">
<li><code>(int -&gt; int) -&gt; bool</code></li>
<li><code>'a option -&gt; 'a list</code></li>
</ol></li>
</ol>
<h4 id="exercise-4">Exercise 4</h4>
<p>We have seen that algebraic data types can be related to analytic
functions (the subset definable from polynomials via recursion)—by
literally interpreting sum types (variant types) as sums and product
types (tuple and record types) as products. We can extend this
interpretation to function types by interpreting <span
class="math inline">a \rightarrow b</span> as <span
class="math inline">b^a</span> (i.e., <span class="math inline">b</span>
to the power of <span class="math inline">a</span>). Note that the <span
class="math inline">b^a</span> notation is actually used to denote
functions in set theory.</p>
<ol type="1">
<li><p>Translate <span class="math inline">a^{b + cd}</span> and <span
class="math inline">a^b \cdot (a^c)^d</span> into OCaml types, using any
distinct types for <span class="math inline">a, b, c, d</span>, and
using <code>type ('a,'b) choice = Left of 'a | Right of 'b</code> for
<span class="math inline">+</span>. Write the bijection function in both
directions.</p></li>
<li><p>Come up with a type <code>'t exp</code> that shares with the
exponential function the following property: <span
class="math inline">\frac{\partial \exp(t)}{\partial t} =
\exp(t)</span>, where we translate a derivative of a type as a context
(i.e., the type with a “hole”), as in this chapter. Explain why your
answer is correct. <em>Hint:</em> in computer science, our logarithms
are mostly base 2.</p></li>
</ol>
<p><em>Further reading:</em> <a
href="http://bababadalgharaghtakamminarronnkonnbro.blogspot.com/2012/10/algebraic-type-systems-combinatorial.html">Algebraic
Type Systems - Combinatorial Species</a></p>
<h4 id="exercise-5-homework">Exercise 5 (Homework)</h4>
<p>Write a function <code>btree_deriv_at</code> that takes a predicate
over integers (i.e., a function <code>f: int -&gt; bool</code>) and a
<code>btree</code>, and builds a <code>btree_deriv</code> whose “hole”
is in the first position for which the predicate returns true. It should
return a <code>btree_deriv option</code>, with <code>None</code> if the
predicate does not hold for any node.</p>
<h2 id="chapter-3-computation">Chapter 3: Computation</h2>
<p><em>Reduction semantics and operational reasoning</em></p>
<p><strong>References:</strong></p>
<ul>
<li>“Using, Understanding and Unraveling the OCaml Language” by Didier
Remy, Chapter 1</li>
<li>“The OCaml system” manual, the tutorial part, Chapter 1</li>
</ul>
<h3 id="function-composition">3.1 Function Composition</h3>
<p>The usual way function composition is defined in mathematics is
“backward”—the notation follows the convention of mathematical function
application:</p>
<p><span class="math display">
(f \circ g)(x) = f(g(x))
</span></p>
<p>This means that when we write <span class="math inline">f \circ
g</span>, we first apply <span class="math inline">g</span> and then
apply <span class="math inline">f</span> to the result. Here is how this
is expressed in different functional programming languages:</p>
<table>
<thead>
<tr>
<th>Language</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td>Math</td>
<td><span class="math inline">(f \circ g)(x) = f(g(x))</span></td>
</tr>
<tr>
<td>OCaml</td>
<td><code>let (-|) f g x = f (g x)</code></td>
</tr>
<tr>
<td>F#</td>
<td><code>let (&lt;&lt;) f g x = f (g x)</code></td>
</tr>
<tr>
<td>Haskell</td>
<td><code>(.) f g = \x -&gt; f (g x)</code></td>
</tr>
</tbody>
</table>
<p>This backward composition looks like function application but needs
fewer parentheses. Recall the functions <code>iso1</code> and
<code>iso2</code> from the previous chapter on type isomorphisms. Using
backward composition, we could write:</p>
<pre><code>let iso2 = step1l -| step2l -| step3l</code></pre>
<p>A more natural definition of function composition is “forward”
composition, which follows the order in which computation actually
proceeds:</p>
<table>
<thead>
<tr>
<th>Language</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td>OCaml</td>
<td><code>let (\|-) f g x = g (f x)</code></td>
</tr>
<tr>
<td>F#</td>
<td><code>let (&gt;&gt;) f g x = g (f x)</code></td>
</tr>
</tbody>
</table>
<p>With forward composition, data flows from left to right, matching how
we typically read code:</p>
<pre><code>let iso1 = step1r |- step2r |- step3r</code></pre>
<h4 id="partial-application">Partial Application</h4>
<p>Both composition examples above use <strong>partial
application</strong>. Recall from the previous chapter that
<code>((+) 1)</code> is a function that adds 1 to its argument. Partial
application occurs when we do not pass all the arguments a function
needs; the result is a function that requires the remaining
arguments.</p>
<p>In the composition <code>step1r |- step2r |- step3r</code>, each
<code>stepNr</code> function is partially applied. The composition
operator <code>(|-)</code> takes two functions <code>f</code> and
<code>g</code> and returns a new function that first applies
<code>f</code>, then applies <code>g</code> to the result.</p>
<h4 id="power-function">Power Function</h4>
<p>Now we define iterated function composition:</p>
<p><span class="math display">
f^n(x) := \underbrace{(f \circ \cdots \circ f)}_{n \text{ times}}(x)
</span></p>
<p>In OCaml, we first define the backward composition operator, then use
it in <code>power</code>:</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (-|) f g x = f (g x)</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> power f n =</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> (<span class="kw">fun</span> x -&gt; x) <span class="kw">else</span> f -| power f (n<span class="dv">-1</span>)</span></code></pre></div>
<p>When <code>n &lt;= 0</code>, we return the identity function.
Otherwise, we compose <code>f</code> with <code>power f (n-1)</code>,
which gives us one more application of <code>f</code>.</p>
<h4 id="numerical-derivative">Numerical Derivative</h4>
<p>Using <code>power</code>, we can define a numerical approximation of
the derivative:</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> derivative dx f = <span class="kw">fun</span> x -&gt; (f(x +. dx) -. f(x)) /. dx</span></code></pre></div>
<p>This definition emphasizes that <code>derivative dx f</code> is
itself a function of <code>x</code>. We can write it more concisely
as:</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> derivative dx f x = (f(x +. dx) -. f(x)) /. dx</span></code></pre></div>
<p>Note that OCaml uses different operators for floating-point
arithmetic. We have <code>(+): int -&gt; int -&gt; int</code> for
integers, so we cannot use <code>+</code> with floating-point numbers.
Instead, operators followed by a dot work on <code>float</code> values:
<code>+.</code>, <code>-.</code>, <code>*.</code>, <code>/.</code>.</p>
<h4 id="computing-higher-order-derivatives">Computing Higher-Order
Derivatives</h4>
<p>With <code>power</code> and <code>derivative</code>, we can easily
compute higher-order derivatives:</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pi = <span class="fl">4.0</span> *. <span class="dt">atan</span> <span class="fl">1.0</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> sin&#39;&#39;&#39; = (power (derivative <span class="fl">1e-5</span>) <span class="dv">3</span>) <span class="dt">sin</span>;;</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>sin&#39;&#39;&#39; pi</span></code></pre></div>
<p>Here <code>sin'''</code> is the third derivative of sine. The result
should be approximately <span class="math inline">-\cos(\pi) = 1</span>
(with some numerical error due to the finite difference
approximation).</p>
<h3 id="evaluation-rules-reduction-semantics">3.2 Evaluation Rules
(Reduction Semantics)</h3>
<p>To understand how OCaml programs compute their results, we need to
formalize the evaluation process. This section presents
<strong>reduction semantics</strong>, which describes computation as a
series of rewriting steps.</p>
<h4 id="expressions">Expressions</h4>
<p>Programs consist of <strong>expressions</strong>. Here is the grammar
of expressions for a simplified version of OCaml:</p>
<p><span class="math display">
\begin{array}{lcll}
a &amp; := &amp; x &amp; \text{variables} \\
  &amp; |  &amp; \texttt{fun } x \texttt{ -&gt; } a &amp;
\text{(defined) functions} \\
  &amp; |  &amp; a \; a &amp; \text{applications} \\
  &amp; |  &amp; C^0 &amp; \text{value constructors of arity } 0 \\
  &amp; |  &amp; C^n(a, \ldots, a) &amp; \text{value constructors of
arity } n \\
  &amp; |  &amp; f^n &amp; \text{built-in values (primitives) of arity }
n \\
  &amp; |  &amp; \texttt{let } x = a \texttt{ in } a &amp; \text{name
bindings (local definitions)} \\
  &amp; |  &amp; \texttt{match } a \texttt{ with} &amp; \\
  &amp;    &amp; \quad p \texttt{ -&gt; } a \texttt{ | } \cdots \texttt{
| } p \texttt{ -&gt; } a &amp; \text{pattern matching} \\[1em]
p &amp; := &amp; x &amp; \text{pattern variables} \\
  &amp; |  &amp; (p, \ldots, p) &amp; \text{tuple patterns} \\
  &amp; |  &amp; C^0 &amp; \text{variant patterns of arity } 0 \\
  &amp; |  &amp; C^n(p, \ldots, p) &amp; \text{variant patterns of arity
} n
\end{array}
</span></p>
<p><strong>Arity</strong> means how many arguments something requires
(and for tuples, the length of the tuple).</p>
<h4 id="the-fix-primitive">The <code>fix</code> Primitive</h4>
<p>To simplify our presentation of recursion, we use a primitive
<code>fix</code> to define a limited form of <code>let rec</code>:</p>
<p><span class="math display">
\texttt{let rec } f \; x = e_1 \texttt{ in } e_2 \equiv \texttt{let } f
= \texttt{fix (fun } f \; x \texttt{ -&gt; } e_1 \texttt{) in } e_2
</span></p>
<p>The <code>fix</code> primitive captures the essence of recursion: it
takes a function that expects to receive itself as an argument and
produces a fixed point—a function that, when called, behaves as if it
had access to itself.</p>
<h4 id="values">Values</h4>
<p>Expressions evaluate (i.e., compute) to <strong>values</strong>.
Values are expressions that cannot be reduced further:</p>
<p><span class="math display">
\begin{array}{lcll}
v &amp; := &amp; \texttt{fun } x \texttt{ -&gt; } a &amp;
\text{(defined) functions} \\
  &amp; |  &amp; C^n(v_1, \ldots, v_n) &amp; \text{constructed values}
\\
  &amp; |  &amp; f^n \; v_1 \; \cdots \; v_k &amp; k &lt; n \text{
(partially applied primitives)}
\end{array}
</span></p>
<p>Note that functions are values: <code>fun x -&gt; x + 1</code> is
already fully evaluated. Partially applied primitives like
<code>(+) 3</code> are also values—they are waiting for more
arguments.</p>
<h4 id="substitution">Substitution</h4>
<p>To <strong>substitute</strong> a value <span
class="math inline">v</span> for a variable <span
class="math inline">x</span> in expression <span
class="math inline">a</span>, we write <span class="math inline">a[x :=
v]</span>. This notation means that every occurrence of <span
class="math inline">x</span> in <span class="math inline">a</span> is
replaced by <span class="math inline">v</span>.</p>
<p>In the actual implementation, the value <span
class="math inline">v</span> is not duplicated in memory. Instead, OCaml
uses references or closures to share the value efficiently.</p>
<h4 id="reduction-rules-redexes">Reduction Rules (Redexes)</h4>
<p>Reduction (i.e., computation) proceeds by finding reducible
expressions called <strong>redexes</strong> and applying reduction
rules. Here are the fundamental redexes:</p>
<p><strong>Function application (beta reduction):</strong> <span
class="math display">
(\texttt{fun } x \texttt{ -&gt; } a) \; v \rightsquigarrow a[x := v]
</span></p>
<p>When we apply a function to a value, we substitute the value for the
parameter in the function body.</p>
<p><strong>Let binding:</strong> <span class="math display">
\texttt{let } x = v \texttt{ in } a \rightsquigarrow a[x := v]
</span></p>
<p>A let binding with a value substitutes that value into the body.</p>
<p><strong>Primitive application:</strong> <span class="math display">
f^n \; v_1 \; \cdots \; v_n \rightsquigarrow f(v_1, \ldots, v_n)
</span></p>
<p>When a primitive receives all its arguments, it computes the result.
Here <span class="math inline">f(v_1, \ldots, v_n)</span> denotes the
actual result of the primitive operation.</p>
<p><strong>Pattern matching with a variable pattern:</strong> <span
class="math display">
\texttt{match } v \texttt{ with } x \texttt{ -&gt; } a \texttt{ | }
\cdots \rightsquigarrow a[x := v]
</span></p>
<p><strong>Pattern matching with a non-matching constructor:</strong>
<span class="math display">
\frac{C_1 \neq C_2}{\texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{
with } C_2^k(p_1, \ldots, p_k) \texttt{ -&gt; } a \texttt{ | } pm
\rightsquigarrow \texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{ with }
pm}
</span></p>
<p>If the constructor does not match, we try the next pattern.</p>
<p><strong>Pattern matching with a matching constructor:</strong> <span
class="math display">
\texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{ with } C_1^n(x_1,
\ldots, x_n) \texttt{ -&gt; } a \texttt{ | } \cdots \rightsquigarrow
a[x_1 := v_1; \ldots; x_n := v_n]
</span></p>
<p>If the constructor matches, we substitute all the bound values.</p>
<p>If <span class="math inline">n = 0</span>, then <span
class="math inline">C_1^n(v_1, \ldots, v_n)</span> stands for simply
<span class="math inline">C_1^0</span>, a constructor with no arguments.
We omit the more complex cases of nested pattern matching.</p>
<h4 id="rule-variables">Rule Variables</h4>
<p>In these rules, the metavariables have specific meanings: - <span
class="math inline">x</span> matches any expression or pattern variable
- <span class="math inline">a, a_1, \ldots, a_n</span> match any
expression - <span class="math inline">v, v_1, \ldots, v_n</span> match
any value</p>
<p>To apply a rule, find substitutions for these metavariables that make
the left-hand side match your expression. The right-hand side (with the
same substitutions) is the reduced expression.</p>
<h4 id="evaluation-context-rules">Evaluation Context Rules</h4>
<p>The rules above only apply when the arguments are already values. We
also need rules that allow evaluation of subexpressions. If <span
class="math inline">a_i \rightsquigarrow a_i&#39;</span>, then:</p>
<p><span class="math display">
\begin{array}{lcl}
a_1 \; a_2 &amp; \rightsquigarrow &amp; a_1&#39; \; a_2 \\
a_1 \; a_2 &amp; \rightsquigarrow &amp; a_1 \; a_2&#39; \\
C^n(a_1, \ldots, a_i, \ldots, a_n) &amp; \rightsquigarrow &amp; C^n(a_1,
\ldots, a_i&#39;, \ldots, a_n) \\
\texttt{let } x = a_1 \texttt{ in } a_2 &amp; \rightsquigarrow &amp;
\texttt{let } x = a_1&#39; \texttt{ in } a_2 \\
\texttt{match } a_1 \texttt{ with } pm &amp; \rightsquigarrow &amp;
\texttt{match } a_1&#39; \texttt{ with } pm
\end{array}
</span></p>
<p>These rules say that: - In an application, either the function or the
argument can be evaluated (in arbitrary order) - In a constructor, any
argument can be evaluated - In a let binding, the bound expression is
evaluated before the body - In a match, the scrutinee is evaluated
before matching</p>
<h4 id="the-fix-rule">The <code>fix</code> Rule</h4>
<p>Finally, the rule for the <code>fix</code> primitive, which enables
recursion:</p>
<p><span class="math display">
\texttt{fix}^2 \; v_1 \; v_2 \rightsquigarrow v_1 \; (\texttt{fix}^2 \;
v_1) \; v_2
</span></p>
<p>Because <code>fix</code> is a binary primitive (arity 2), the
expression <span class="math inline">(\texttt{fix}^2 \; v_1)</span> is
already a value (a partially applied primitive). This means it will not
be further evaluated until it is applied inside <span
class="math inline">v_1</span>. This delayed evaluation is what makes
recursion work without infinite loops.</p>
<h4 id="practice">Practice</h4>
<p><strong>Exercise:</strong> Compute some simple programs by hand using
these rules. For example, trace the evaluation of:</p>
<div class="sourceCode" id="cb52"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> double x = x + x <span class="kw">in</span> double <span class="dv">3</span></span></code></pre></div>
<h3 id="symbolic-derivation-example">3.3 Symbolic Derivation
Example</h3>
<p>Let us see the reduction rules in action with a more complex example.
Consider the symbolic expression evaluator from
<code>Lec3.ml</code>:</p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> expression =</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>  | Const <span class="kw">of</span> <span class="dt">float</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>  | Var <span class="kw">of</span> <span class="dt">string</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>  | Sum <span class="kw">of</span> expression * expression    <span class="co">(* e1 + e2 *)</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>  | Diff <span class="kw">of</span> expression * expression   <span class="co">(* e1 - e2 *)</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>  | Prod <span class="kw">of</span> expression * expression   <span class="co">(* e1 * e2 *)</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>  | Quot <span class="kw">of</span> expression * expression   <span class="co">(* e1 / e2 *)</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a><span class="kw">exception</span> Unbound_variable <span class="kw">of</span> <span class="dt">string</span></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> eval env <span class="dt">exp</span> =</span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> <span class="dt">exp</span> <span class="kw">with</span></span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>  | Const c -&gt; c</span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>  | Var v -&gt;</span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">try</span> <span class="dt">List</span>.assoc v env <span class="kw">with</span> <span class="dt">Not_found</span> -&gt; <span class="dt">raise</span> (Unbound_variable v))</span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a>  | Sum(f, g) -&gt; eval env f +. eval env g</span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a>  | Diff(f, g) -&gt; eval env f -. eval env g</span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true" tabindex="-1"></a>  | Prod(f, g) -&gt; eval env f *. eval env g</span>
<span id="cb53-19"><a href="#cb53-19" aria-hidden="true" tabindex="-1"></a>  | Quot(f, g) -&gt; eval env f /. eval env g</span></code></pre></div>
<p>We can also define symbolic differentiation:</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> deriv <span class="dt">exp</span> dv =</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> <span class="dt">exp</span> <span class="kw">with</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>  | Const c -&gt; Const <span class="fl">0.0</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>  | Var v -&gt; <span class="kw">if</span> v = dv <span class="kw">then</span> Const <span class="fl">1.0</span> <span class="kw">else</span> Const <span class="fl">0.0</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>  | Sum(f, g) -&gt; Sum(deriv f dv, deriv g dv)</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>  | Diff(f, g) -&gt; Diff(deriv f dv, deriv g dv)</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>  | Prod(f, g) -&gt; Sum(Prod(f, deriv g dv), Prod(deriv f dv, g))</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>  | Quot(f, g) -&gt; Quot(Diff(Prod(deriv f dv, g), Prod(f, deriv g dv)),</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>                       Prod(g, g))</span></code></pre></div>
<p>For convenience, let us define some operators and variables:</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = Var <span class="st">&quot;x&quot;</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> y = Var <span class="st">&quot;y&quot;</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (+:) f g = Sum (f, g)</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (-:) f g = Diff (f, g)</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ( *: ) f g = Prod (f, g)</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (/:) f g = Quot (f, g)</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (!:) i = Const i</span></code></pre></div>
<p>Now consider evaluating the expression <code>3x + 2y + x^2 y</code>
at <span class="math inline">x = 1, y = 2</span>:</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> example = !:<span class="fl">3.0</span> *: x +: !:<span class="fl">2.0</span> *: y +: x *: x *: y</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> env = [<span class="st">&quot;x&quot;</span>, <span class="fl">1.0</span>; <span class="st">&quot;y&quot;</span>, <span class="fl">2.0</span>]</span></code></pre></div>
<p>When we trace the evaluation, we can see the recursive structure of
the computation:</p>
<pre><code>eval_1_2 &lt;-- 3.00 * x + 2.00 * y + x * x * y
  eval_1_2 &lt;-- x * x * y
    eval_1_2 &lt;-- y
    eval_1_2 --&gt; 2.
    eval_1_2 &lt;-- x * x
      eval_1_2 &lt;-- x
      eval_1_2 --&gt; 1.
      eval_1_2 &lt;-- x
      eval_1_2 --&gt; 1.
    eval_1_2 --&gt; 1.
  eval_1_2 --&gt; 2.
  eval_1_2 &lt;-- 3.00 * x + 2.00 * y
    eval_1_2 &lt;-- 2.00 * y
      eval_1_2 &lt;-- y
      eval_1_2 --&gt; 2.
      eval_1_2 &lt;-- 2.00
      eval_1_2 --&gt; 2.
    eval_1_2 --&gt; 4.
    eval_1_2 &lt;-- 3.00 * x
      eval_1_2 &lt;-- x
      eval_1_2 --&gt; 1.
      eval_1_2 &lt;-- 3.00
      eval_1_2 --&gt; 3.
    eval_1_2 --&gt; 3.
  eval_1_2 --&gt; 7.
eval_1_2 --&gt; 9.
- : float = 9.</code></pre>
<p>The indentation levels in this trace correspond to <strong>stack
frames</strong>—the runtime structures that store the state of each
function call. This brings us to an important optimization
technique.</p>
<h3 id="tail-calls-and-tail-recursion">3.4 Tail Calls and Tail
Recursion</h3>
<p>Computers normally evaluate programs by creating <strong>stack
frames</strong> on the call stack for each function call. The trace
above illustrates this: each level of indentation represents a new stack
frame.</p>
<h4 id="what-is-a-tail-call">What is a Tail Call?</h4>
<p>A <strong>tail call</strong> is a function call that is performed
last when computing a function—there is nothing more to do after the
call returns. For example, in:</p>
<pre><code>let f x = g (x + 1)</code></pre>
<p>The call to <code>g</code> is a tail call because after
<code>g</code> returns, <code>f</code> immediately returns that
value.</p>
<p>In contrast, in:</p>
<pre><code>let f x = 1 + g x</code></pre>
<p>The call to <code>g</code> is <em>not</em> a tail call because after
<code>g</code> returns, we still need to add 1 to the result.</p>
<h4 id="tail-call-optimization">Tail Call Optimization</h4>
<p>Functional language compilers (including OCaml’s) recognize tail
calls and optimize them. Instead of creating a new stack frame, they
reuse the current frame by performing a “jump” to the called function.
This means tail calls use constant stack space.</p>
<h4 id="tail-recursive-functions">Tail Recursive Functions</h4>
<p>A function is <strong>tail recursive</strong> if it calls itself (and
any mutually recursive functions it depends on) only using tail
calls.</p>
<p>Tail recursive functions often use special
<strong>accumulator</strong> arguments that store intermediate
computation results. In a non-tail-recursive function, these
intermediate results would be values of subexpressions stored on the
stack.</p>
<p>The key insight is that the accumulated result is computed in
“reverse order”—while climbing up the recursion (making calls) rather
than while descending (returning from calls).</p>
<h4 id="example-counting">Example: Counting</h4>
<p>Compare these two counting functions:</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> count n =</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> <span class="dv">1</span> + (count (n<span class="dv">-1</span>))</span></code></pre></div>
<p>This is <em>not</em> tail recursive because after the recursive call
returns, we still need to add 1.</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> count_tcall acc n =</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> acc <span class="kw">else</span> count_tcall (acc+<span class="dv">1</span>) (n<span class="dv">-1</span>)</span></code></pre></div>
<p>This <em>is</em> tail recursive: the recursive call is the last thing
the function does.</p>
<h4 id="example-building-lists">Example: Building Lists</h4>
<p>Let us see a more dramatic example:</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> unfold n = <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> [] <span class="kw">else</span> n :: unfold (n<span class="dv">-1</span>)</span></code></pre></div>
<p>This function builds a list counting down from <code>n</code>. It is
not tail recursive because after the recursive call, we must cons
<code>n</code> onto the result.</p>
<pre><code># unfold 100000;;
- : int list = [100000; 99999; 99998; 99997; ...]

# unfold 1000000;;
Stack overflow during evaluation (looping recursion?).</code></pre>
<p>With a million elements, we run out of stack space! Now consider the
tail-recursive version:</p>
<div class="sourceCode" id="cb64"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> unfold_tcall acc n =</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> acc <span class="kw">else</span> unfold_tcall (n::acc) (n<span class="dv">-1</span>)</span></code></pre></div>
<p>The accumulator <code>acc</code> collects the list as we go. Note
that the list is built in reverse order:</p>
<pre><code># unfold_tcall [] 100000;;
- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; ...]

# unfold_tcall [] 1000000;;
- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; ...]</code></pre>
<p>The tail-recursive version handles a million elements with no
problem.</p>
<h4 id="a-challenge-tree-depth">A Challenge: Tree Depth</h4>
<p>Is it possible to find the depth of a tree using a tail-recursive
function?</p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree = Tip | Node <span class="kw">of</span> <span class="dt">int</span> * btree * btree</span></code></pre></div>
<p>The naive approach:</p>
<div class="sourceCode" id="cb67"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> depth tree = <span class="kw">match</span> tree <span class="kw">with</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>  | Tip -&gt; <span class="dv">0</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>  | Node(_, left, right) -&gt; <span class="dv">1</span> + <span class="dt">max</span> (depth left) (depth right)</span></code></pre></div>
<p>This is not tail recursive: after both recursive calls, we still need
to compute <code>1 + max ...</code>. The challenge is that we have
<em>two</em> recursive calls, and we cannot simply use an
accumulator.</p>
<h4 id="note-on-lazy-languages">Note on Lazy Languages</h4>
<p>The issue of tail recursion is more complex for <strong>lazy</strong>
programming languages like Haskell. In a lazy language, the cons
operation <code>(:)</code> does not immediately evaluate its arguments,
so building a list with <code>n :: unfold (n-1)</code> does not consume
stack space in the same way.</p>
<h3 id="first-encounter-of-continuation-passing-style">3.5 First
Encounter of Continuation Passing Style</h3>
<p>We can solve the tree depth problem using <strong>Continuation
Passing Style (CPS)</strong>. The key idea is to postpone doing actual
work until the very last moment by passing around a “continuation”—a
function that represents “what to do next.”</p>
<div class="sourceCode" id="cb68"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> depth_cps tree k = <span class="kw">match</span> tree <span class="kw">with</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>  | Tip -&gt; k <span class="dv">0</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>  | Node(_, left, right) -&gt;</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>    depth_cps left (<span class="kw">fun</span> dleft -&gt;</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>      depth_cps right (<span class="kw">fun</span> dright -&gt;</span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>        k (<span class="dv">1</span> + (<span class="dt">max</span> dleft dright))))</span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> depth tree = depth_cps tree (<span class="kw">fun</span> d -&gt; d)</span></code></pre></div>
<p>Let us understand how this works:</p>
<ol type="1">
<li><p>The function takes an extra parameter <code>k</code>, called the
<strong>continuation</strong>. It represents what to do with the final
result.</p></li>
<li><p>In the <code>Tip</code> case, we call the continuation with the
depth 0.</p></li>
<li><p>In the <code>Node</code> case, we recursively compute the depth
of the left subtree, passing a continuation that:</p>
<ul>
<li>Receives the left depth <code>dleft</code></li>
<li>Then recursively computes the depth of the right subtree, passing a
continuation that:
<ul>
<li>Receives the right depth <code>dright</code></li>
<li>Finally calls the original continuation with
<code>1 + max dleft dright</code></li>
</ul></li>
</ul></li>
<li><p>The wrapper function passes the identity function
<code>fun d -&gt; d</code> as the initial continuation.</p></li>
</ol>
<p>The magic is that each recursive call is now a tail call! The “work”
of computing <code>1 + max dleft dright</code> is captured in the
continuation closures, which are allocated on the heap rather than the
stack.</p>
<p>However, this does not completely solve the stack overflow problem—we
are trading stack space for heap space (storing the continuation
closures). For very deep trees, we might still run out of memory. True
solutions involve trampolining or iterative approaches with explicit
stacks.</p>
<p>CPS is a powerful technique that appears throughout functional
programming. We will encounter it again when studying monads and
advanced control flow.</p>
<h3 id="exercises-2">3.6 Exercises</h3>
<p><strong>Exercise 1:</strong> By “traverse a tree” below we mean:
write a function that takes a tree and returns a list of values in the
nodes of the tree.</p>
<ol type="1">
<li><p>Write a function (of type <code>btree -&gt; int list</code>) that
traverses a binary tree in <strong>prefix order</strong>—first the value
stored in a node, then values in all nodes to the left, then values in
all nodes to the right.</p></li>
<li><p>Write a traversal in <strong>infix order</strong>—first values in
all nodes to the left, then the value stored in the node, then values in
all nodes to the right (so it is “left-to-right” order).</p></li>
<li><p>Write a traversal in <strong>breadth-first order</strong>—first
values in shallower nodes before deeper nodes.</p></li>
</ol>
<p><strong>Exercise 2:</strong> Turn the function from Exercise 1
(prefix or infix traversal) into continuation passing style.</p>
<p><strong>Exercise 3:</strong> Do the homework from the end of Chapter
2: write <code>btree_deriv_at</code> that takes a predicate over
integers and a <code>btree</code>, and builds a <code>btree_deriv</code>
whose “hole” is in the first position for which the predicate returns
true.</p>
<p><strong>Exercise 4:</strong> Write a function
<code>simplify: expression -&gt; expression</code> that simplifies
symbolic expressions, so that for example the result of
<code>simplify (deriv exp dv)</code> looks more like what a human would
get computing the derivative of <code>exp</code> with respect to
<code>dv</code>.</p>
<ul>
<li>Write a <code>simplify_once</code> function that performs a single
step of simplification.</li>
<li>Wrap it using a general <code>fixpoint</code> function that performs
an operation until a <strong>fixed point</strong> is reached: given
<span class="math inline">f</span> and <span
class="math inline">x</span>, it computes <span
class="math inline">f^n(x)</span> such that <span
class="math inline">f^n(x) = f^{n+1}(x)</span>.</li>
</ul>
<p><strong>Exercise 5:</strong> Write two sorting algorithms working on
lists: merge sort and quicksort.</p>
<ol type="1">
<li><p><strong>Merge sort</strong> splits the list roughly in half,
sorts the parts recursively, and merges the sorted parts into the sorted
result.</p></li>
<li><p><strong>Quicksort</strong> splits the list into elements smaller
than and greater than (or equal to) the first element, sorts the parts
recursively, and concatenates them.</p></li>
</ol>
<h2 id="chapter-4-functions">Chapter 4: Functions</h2>
<p><em>Programming in untyped lambda-calculus</em></p>
<p>This chapter explores the theoretical foundations of functional
programming through the untyped lambda-calculus. We begin with a review
of computation by hand using our reduction semantics, then introduce the
lambda-calculus notation and show how to encode fundamental data
types—booleans, pairs, and natural numbers—using only functions. The
chapter concludes with an examination of recursion through fixpoint
combinators and practical considerations for avoiding infinite loops in
eager evaluation.</p>
<p><strong>References:</strong> - “Introduction to Lambda Calculus” by
Henk Barendregt and Erik Barendsen - “Lecture Notes on the Lambda
Calculus” by Peter Selinger</p>
<h3 id="review-computation-by-hand">4.1 Review: Computation by Hand</h3>
<p>Before diving into the lambda-calculus, let us work through a
complete example of evaluation using the reduction rules from Chapter 3.
This exercise reinforces our understanding of how computation proceeds
and prepares us for the more abstract setting of lambda-calculus.</p>
<p>Recall that we use <code>fix</code> instead of <code>let rec</code>
to simplify rules for recursion. Also remember our syntactic
conventions: <code>fun x y -&gt; e</code> stands for
<code>fun x -&gt; (fun y -&gt; e)</code>, and so forth.</p>
<p>Consider the following recursive <code>length</code> function applied
to a two-element list:</p>
<pre><code>let rec fix f x = f (fix f) x

type int_list = Nil | Cons of int * int_list

let length =
  fix (fun f l -&gt;
    match l with
      | Nil -&gt; 0
      | Cons (x, xs) -&gt; 1 + f xs) in
length (Cons (1, (Cons (2, Nil))))</code></pre>
<p>Let us trace through this computation step by step. First, we
eliminate the <code>let</code> binding:</p>
<p><span class="math display">\texttt{let } x = v \texttt{ in } a
\Downarrow a[x := v]</span></p>
<p>This gives us:</p>
<pre><code>fix (fun f l -&gt;
    match l with
      | Nil -&gt; 0
      | Cons (x, xs) -&gt; 1 + f xs) (Cons (1, (Cons (2, Nil))))</code></pre>
<p>Next, we apply the <code>fix</code> rule:</p>
<p><span class="math display">\texttt{fix}^2 \; v_1 \; v_2 \Downarrow
v_1 \; (\texttt{fix}^2 \; v_1) \; v_2</span></p>
<p>This unfolds to:</p>
<pre><code>(fun f l -&gt;
    match l with
      | Nil -&gt; 0
      | Cons (x, xs) -&gt; 1 + f xs)
    (fix (fun f l -&gt;
      match l with
        | Nil -&gt; 0
        | Cons (x, xs) -&gt; 1 + f xs))
    (Cons (1, (Cons (2, Nil))))</code></pre>
<p>Function application reduces according to:</p>
<p><span class="math display">(\texttt{fun } x \texttt{ -&gt; } a) \; v
\rightsquigarrow a[x := v]</span></p>
<p>After substituting both <code>f</code> and <code>l</code>, we
get:</p>
<pre><code>(match Cons (1, (Cons (2, Nil))) with
    | Nil -&gt; 0
    | Cons (x, xs) -&gt; 1 + (fix (fun f l -&gt;
      match l with
        | Nil -&gt; 0
        | Cons (x, xs) -&gt; 1 + f xs)) xs)</code></pre>
<p>Pattern matching against a non-matching constructor moves to the next
branch:</p>
<p><span class="math display">
\begin{aligned}
&amp; \texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{ with} \\
&amp; C_2^n(p_1, \ldots, p_k) \texttt{ -&gt; } a \texttt{ | } pm
\Downarrow \texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{ with } pm
\end{aligned}
</span></p>
<p>Pattern matching against a matching constructor performs
substitution:</p>
<p><span class="math display">
\begin{aligned}
&amp; \texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{ with} \\
&amp; C_1^n(x_1, \ldots, x_n) \texttt{ -&gt; } a \texttt{ | } \ldots
\Downarrow a[x_1 := v_1; \ldots; x_n := v_n]
\end{aligned}
</span></p>
<p>After matching and substitution:</p>
<pre><code>1 + (fix (fun f l -&gt;
      match l with
        | Nil -&gt; 0
        | Cons (x, xs) -&gt; 1 + f xs)) (Cons (2, Nil))</code></pre>
<p>Continuing the evaluation, we apply <code>fix</code> again and work
through the pattern match for <code>Cons (2, Nil)</code>, eventually
reaching:</p>
<pre><code>1 + (1 + (fix (fun f l -&gt;
             match l with
               | Nil -&gt; 0
               | Cons (x, xs) -&gt; 1 + f xs)) Nil)</code></pre>
<p>One more unfolding and pattern match against <code>Nil</code>
gives:</p>
<pre><code>1 + (1 + 0)</code></pre>
<p>Finally, applying the built-in addition:</p>
<p><span class="math display">f^n \; v_1 \; \ldots \; v_n \Downarrow
f(v_1, \ldots, v_n)</span></p>
<p>We obtain the result: <code>2</code>.</p>
<h3 id="language-and-rules-of-the-untyped-lambda-calculus">4.2 Language
and Rules of the Untyped Lambda-Calculus</h3>
<p>The lambda-calculus, introduced by Alonzo Church in the 1930s, is a
minimal formal system for expressing computation. To work with it, we
first simplify our language:</p>
<ol type="1">
<li><p><strong>Forget about types.</strong> In pure lambda-calculus,
there is no type system constraining which terms can be
combined.</p></li>
<li><p><strong>Introduce notation.</strong> We write <span
class="math inline">\lambda x.a</span> for <code>fun x -&gt; a</code>,
and <span class="math inline">\lambda xy.a</span> for
<code>fun x y -&gt; a</code>, and so forth.</p></li>
<li><p><strong>Reduce to essentials.</strong> We keep only functions
(lambda abstractions) and variables—no constructors, no built-in
primitives.</p></li>
</ol>
<p>The core reduction rule of lambda-calculus is called <strong><span
class="math inline">\beta</span>-reduction</strong>:</p>
<p><span class="math display">(\texttt{fun } x \texttt{ -&gt; } a_1) \;
a_2 \rightsquigarrow a_1[x := a_2]</span></p>
<p>Note that this rule is more general than the one we use for OCaml
evaluation. In our OCaml semantics, we require the argument to be a
value: <span class="math inline">(\texttt{fun } x \texttt{ -&gt; } a) \;
v \rightsquigarrow a[x := v]</span>. The general <span
class="math inline">\beta</span>-reduction rule allows substituting any
expression, not just values.</p>
<p>Lambda-calculus also uses <strong><span
class="math inline">\alpha</span>-conversion</strong> (bound variable
renaming), or equivalent techniques, to avoid <strong>variable
capture</strong>—the unintended binding of free variables during
substitution. We will explore <span
class="math inline">\beta</span>-reduction further in the chapter on
laziness.</p>
<p>Why is <span class="math inline">\beta</span>-reduction more general
than our evaluation rule? Consider the expression <span
class="math inline">(\lambda x. x) \; ((\lambda y. y) \; z)</span>. With
<span class="math inline">\beta</span>-reduction, we could reduce the
outer application first, obtaining <span class="math inline">((\lambda
y. y) \; z)</span>. Our evaluation rule would require first reducing the
argument to a value.</p>
<h3 id="booleans">4.3 Booleans</h3>
<p>Alonzo Church introduced lambda-calculus to encode logic. There are
multiple ways to encode various sorts of data in lambda-calculus, though
not all of them work well in a typed setting—the straightforward
encode/decode functions may not type-check.</p>
<p>The <strong>Church encoding</strong> of booleans represents truth
values as selector functions:</p>
<ul>
<li><strong>True</strong> selects the first argument:
<code>c_true</code> <span class="math inline">= \lambda xy.x</span></li>
<li><strong>False</strong> selects the second argument:
<code>c_false</code> <span class="math inline">= \lambda
xy.y</span></li>
</ul>
<p>In OCaml syntax:</p>
<div class="sourceCode" id="cb76"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c_true = <span class="kw">fun</span> x y -&gt; x   <span class="co">(* &quot;True&quot; is projection on the first argument *)</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c_false = <span class="kw">fun</span> x y -&gt; y  <span class="co">(* And &quot;false&quot; on the second argument *)</span></span></code></pre></div>
<p>Logical conjunction can be defined as:</p>
<p><span class="math display">\texttt{c\_and} = \lambda xy. x \; y \;
\texttt{c\_false}</span></p>
<p>The logic is: if <code>x</code> is true, return <code>y</code> (so
the result is true only if both are true); if <code>x</code> is false,
return false immediately.</p>
<div class="sourceCode" id="cb77"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c_and = <span class="kw">fun</span> x y -&gt; x y c_false  <span class="co">(* If one is false, then return false *)</span></span></code></pre></div>
<p>Let us verify this works. For <code>c_and c_true c_true</code>:</p>
<p><span class="math display">(\lambda xy. x \; y \; \texttt{c\_false})
\; (\lambda xy.x) \; (\lambda xy.x)</span></p>
<p>reduces to:</p>
<p><span class="math display">(\lambda xy.x) \; (\lambda xy.x) \;
\texttt{c\_false}</span></p>
<p>which gives us <span class="math inline">\lambda xy.x</span> =
<code>c_true</code>. For any other combination involving
<code>c_false</code>, the result is <code>c_false</code>.</p>
<p>To verify our encodings in OCaml, we need encode and decode
functions:</p>
<div class="sourceCode" id="cb78"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> encode_bool b = <span class="kw">if</span> b <span class="kw">then</span> c_true <span class="kw">else</span> c_false</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> decode_bool c = c <span class="kw">true</span> <span class="kw">false</span>  <span class="co">(* Test the functions in the toplevel *)</span></span></code></pre></div>
<p><strong>Exercise:</strong> Define <code>c_or</code> and
<code>c_not</code> yourself!</p>
<h3 id="if-then-else-and-pairs">4.4 If-then-else and Pairs</h3>
<p>From now on, we will use OCaml syntax for our lambda-calculus
programs. An important observation is that our encoded booleans already
implement conditional selection:</p>
<div class="sourceCode" id="cb79"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> if_then_else = <span class="kw">fun</span> b -&gt; b  <span class="co">(* Booleans select the argument! *)</span></span></code></pre></div>
<p>Since <code>c_true</code> returns its first argument and
<code>c_false</code> returns its second,
<code>if_then_else b then_branch else_branch</code> simply applies
<code>b</code> to the two branches. Remember to play with these
functions in the toplevel to build intuition.</p>
<h4 id="pairs">Pairs</h4>
<p>Pairs (ordered tuples of two elements) can be encoded similarly:</p>
<div class="sourceCode" id="cb80"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c_pair m n = <span class="kw">fun</span> x -&gt; x m n  <span class="co">(* We couple things *)</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c_first = <span class="kw">fun</span> p -&gt; p c_true  <span class="co">(* by passing them together *)</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c_second = <span class="kw">fun</span> p -&gt; p c_false  <span class="co">(* Check that it works! *)</span></span></code></pre></div>
<p>A pair is a function that, when given a selector, applies that
selector to both components. To extract the first component, we pass
<code>c_true</code> (which selects the first argument); to extract the
second, we pass <code>c_false</code>.</p>
<p>For verification:</p>
<div class="sourceCode" id="cb81"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> encode_pair enc_fst enc_snd (a, b) =</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>  c_pair (enc_fst a) (enc_snd b)</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> decode_pair de_fst de_snd c = c (<span class="kw">fun</span> x y -&gt; de_fst x, de_snd y)</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> decode_bool_pair c = decode_pair decode_bool decode_bool c</span></code></pre></div>
<p>We can define larger tuples in the same manner:</p>
<div class="sourceCode" id="cb82"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c_triple l m n = <span class="kw">fun</span> x -&gt; x l m n</span></code></pre></div>
<h3 id="pair-encoded-natural-numbers">4.5 Pair-Encoded Natural
Numbers</h3>
<p>Our first encoding of natural numbers uses nested pairs. The
representation is based on the depth of nested pairs whose rightmost
leaf is the identity function <span class="math inline">\lambda
x.x</span> and whose left elements are <code>c_false</code>.</p>
<div class="sourceCode" id="cb83"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pn0 = <span class="kw">fun</span> x -&gt; x           <span class="co">(* Start with the identity function *)</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pn_succ n = c_pair c_false n  <span class="co">(* Stack another pair *)</span></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pn_pred = <span class="kw">fun</span> x -&gt; x c_false  <span class="co">(* Extract the nested number *)</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pn_is_zero = <span class="kw">fun</span> x -&gt; x c_true  <span class="co">(* Check if it&#39;s the base case *)</span></span></code></pre></div>
<p>The number 0 is represented as the identity function. The number 1 is
<code>c_pair c_false pn0</code>, the number 2 is
<code>c_pair c_false (c_pair c_false pn0)</code>, and so on. The
<code>pn_is_zero</code> function works because: - For <code>pn0</code>,
applying it to <code>c_true</code> gives <code>c_true</code> (since
<code>pn0</code> is the identity). - For any successor, applying
<code>c_pair c_false n</code> to <code>c_true</code> applies the pair to
<code>c_true</code>, which selects <code>c_false</code>.</p>
<p>We program in untyped lambda-calculus as an exercise, and we need
encoding/decoding to verify our exercises. Using <code>Obj.magic</code>
to bypass the type system for encoding/decoding is “fair game”:</p>
<div class="sourceCode" id="cb84"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> encode_pnat n =                <span class="co">(* We use Obj.magic to forget types *)</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> <span class="dt">Obj</span>.magic pn0</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> pn_succ (<span class="dt">Obj</span>.magic (encode_pnat (n<span class="dv">-1</span>)))  <span class="co">(* Disregarding types, *)</span></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> decode_pnat pn =               <span class="co">(* these functions are straightforward! *)</span></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> decode_bool (pn_is_zero pn) <span class="kw">then</span> <span class="dv">0</span></span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> <span class="dv">1</span> + decode_pnat (pn_pred (<span class="dt">Obj</span>.magic pn))</span></code></pre></div>
<h3 id="church-numerals">4.6 Church Numerals</h3>
<p>Do you remember our function <code>power f n</code> from Chapter 3?
We will use a similar idea for a different representation of numbers.
<strong>Church numerals</strong> represent a natural number <span
class="math inline">n</span> as a function that applies its first
argument <span class="math inline">n</span> times to its second
argument:</p>
<div class="sourceCode" id="cb85"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn0 = <span class="kw">fun</span> f x -&gt; x        <span class="co">(* The same as c_false *)</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn1 = <span class="kw">fun</span> f x -&gt; f x      <span class="co">(* Behaves like identity when f = id *)</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn2 = <span class="kw">fun</span> f x -&gt; f (f x)</span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn3 = <span class="kw">fun</span> f x -&gt; f (f (f x))</span></code></pre></div>
<p>This is the original Alonzo Church encoding. The number <span
class="math inline">n</span> is represented as <span
class="math inline">\lambda fx. f^n(x)</span>, where <span
class="math inline">f^n</span> denotes <span
class="math inline">n</span>-fold composition.</p>
<p>The successor function adds one more application of
<code>f</code>:</p>
<div class="sourceCode" id="cb86"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn_succ = <span class="kw">fun</span> n f x -&gt; f (n f x)</span></code></pre></div>
<p><strong>Exercise:</strong> Define addition, multiplication, comparing
to zero, and the predecessor function “-1” for Church numerals.</p>
<p>It turns out even Alonzo Church could not define predecessor right
away! His student Stephen Kleene eventually found it. Try to make some
progress before looking at the solution below.</p>
<div class="sourceCode" id="cb87"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (-|) f g x = f (g x)  <span class="co">(* Backward composition operator *)</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> encode_cnat n f =</span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> (<span class="kw">fun</span> x -&gt; x) <span class="kw">else</span> f -| encode_cnat (n<span class="dv">-1</span>) f</span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> decode_cnat n = n ((+) <span class="dv">1</span>) <span class="dv">0</span></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn7 f x = encode_cnat <span class="dv">7</span> f x   <span class="co">(* We need to eta-expand these definitions *)</span></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn13 f x = encode_cnat <span class="dv">13</span> f x  <span class="co">(* for type-system reasons *)</span></span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a>                                   <span class="co">(* (because OCaml allows side-effects) *)</span></span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn_add = <span class="kw">fun</span> n m f x -&gt; n f (m f x)  <span class="co">(* Put n of f in front *)</span></span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn_mult = <span class="kw">fun</span> n m f -&gt; n (m f)       <span class="co">(* Repeat n times *)</span></span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a>                                          <span class="co">(* putting m of f in front *)</span></span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn_prev n =</span>
<span id="cb87-13"><a href="#cb87-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fun</span> f x -&gt;                  <span class="co">(* This is the &quot;Church numeral signature&quot; *)</span></span>
<span id="cb87-14"><a href="#cb87-14" aria-hidden="true" tabindex="-1"></a>    n                         <span class="co">(* The only thing we have is an n-step loop *)</span></span>
<span id="cb87-15"><a href="#cb87-15" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">fun</span> g v -&gt; v (g f))    <span class="co">(* We need sth that operates on f *)</span></span>
<span id="cb87-16"><a href="#cb87-16" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">fun</span> z -&gt; x)            <span class="co">(* We need to ignore the innermost step *)</span></span>
<span id="cb87-17"><a href="#cb87-17" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">fun</span> z -&gt; z)            <span class="co">(* We&#39;ve built a &quot;machine&quot; not results -- start the machine *)</span></span></code></pre></div>
<p>The predecessor function is ingenious. It builds up a chain of
functions that, when “started” with the identity, yields <span
class="math inline">n-1</span> applications of <code>f</code>. The key
insight is to delay the actual application of <code>f</code> and skip
the first one.</p>
<p><code>cn_is_zero</code> is left as an exercise.</p>
<h4 id="tracing-cn_prev-cn3">Tracing <code>cn_prev cn3</code></h4>
<p>Let us trace through <code>decode_cnat (cn_prev cn3)</code>:</p>
<p><span class="math display">\Downarrow</span></p>
<pre><code>(cn_prev cn3) ((+) 1) 0</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>(fun f x -&gt;
    cn3
      (fun g v -&gt; v (g f))
      (fun z -&gt; x)
      (fun z -&gt; z)) ((+) 1) 0</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>((fun f x -&gt; f (f (f x)))
      (fun g v -&gt; v (g ((+) 1)))
      (fun z -&gt; 0)
      (fun z -&gt; z))</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>((fun g v -&gt; v (g ((+) 1)))
  ((fun g v -&gt; v (g ((+) 1)))
    ((fun g v -&gt; v (g ((+) 1)))
      (fun z -&gt; 0))))
  (fun z -&gt; z))</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>((fun z -&gt; z)
  (((fun g v -&gt; v (g ((+) 1)))
    ((fun g v -&gt; v (g ((+) 1)))
      (fun z -&gt; 0)))) ((+) 1)))</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>(fun g v -&gt; v (g ((+) 1)))
  ((fun g v -&gt; v (g ((+) 1)))
    (fun z -&gt; 0)) ((+) 1)</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>((+) 1) ((fun g v -&gt; v (g ((+) 1)))
          (fun z -&gt; 0) ((+) 1))</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>((+) 1) (((+) 1) ((fun z -&gt; 0) ((+) 1)))</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>((+) 1) (((+) 1) (0))</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>((+) 1) 1</code></pre>
<p><span class="math display">\Downarrow</span></p>
<pre><code>2</code></pre>
<h3 id="recursion-fixpoint-combinators">4.7 Recursion: Fixpoint
Combinators</h3>
<p>In lambda-calculus, recursion is achieved through <strong>fixpoint
combinators</strong>—lambda terms that compute fixed points of
functions.</p>
<h4 id="turings-fixpoint-combinator">Turing’s Fixpoint Combinator</h4>
<p><span class="math display">\Theta = (\lambda xy. y \; (x \; x \; y))
\; (\lambda xy. y \; (x \; x \; y))</span></p>
<p>Let us verify it computes fixed points. Define <span
class="math inline">N = \Theta F</span>:</p>
<p><span class="math display">
\begin{aligned}
N &amp;= \Theta F \\
&amp;= (\lambda xy. y \; (x \; x \; y)) \; (\lambda xy. y \; (x \; x \;
y)) \; F \\
&amp;=_{\rightarrow\rightarrow} F \; ((\lambda xy. y \; (x \; x \; y))
\; (\lambda xy. y \; (x \; x \; y)) \; F) \\
&amp;= F \; (\Theta F) = F \; N
\end{aligned}
</span></p>
<p>So <span class="math inline">N = F \; N</span>, meaning <span
class="math inline">N</span> is a fixed point of <span
class="math inline">F</span>.</p>
<h4 id="currys-fixpoint-combinator-y-combinator">Curry’s Fixpoint
Combinator (Y Combinator)</h4>
<p><span class="math display">\mathbf{Y} = \lambda f. (\lambda x. f \;
(x \; x)) \; (\lambda x. f \; (x \; x))</span></p>
<p><span class="math display">
\begin{aligned}
N &amp;= \mathbf{Y} F \\
&amp;= (\lambda f. (\lambda x. f \; (x \; x)) \; (\lambda x. f \; (x \;
x))) \; F \\
&amp;=_{\rightarrow} (\lambda x. F \; (x \; x)) \; (\lambda x. F \; (x
\; x)) \\
&amp;=_{\rightarrow} F \; ((\lambda x. F \; (x \; x)) \; (\lambda x. F
\; (x \; x))) \\
&amp;=_{\leftarrow} F \; ((\lambda f. (\lambda x. f \; (x \; x)) \;
(\lambda x. f \; (x \; x))) \; F) \\
&amp;= F \; (\mathbf{Y} F) = F \; N
\end{aligned}
</span></p>
<h4 id="call-by-value-fixpoint-combinator">Call-by-Value Fixpoint
Combinator</h4>
<p><span class="math display">\texttt{fix} = \lambda f&#39;. (\lambda
fx. f&#39; \; (f \; f) \; x) \; (\lambda fx. f&#39; \; (f \; f) \;
x)</span></p>
<p><span class="math display">
\begin{aligned}
N &amp;= \texttt{fix} \; F \\
&amp;= (\lambda f&#39;. (\lambda fx. f&#39; \; (f \; f) \; x) \;
(\lambda fx. f&#39; \; (f \; f) \; x)) \; F \\
&amp;=_{\rightarrow} (\lambda fx. F \; (f \; f) \; x) \; (\lambda fx. F
\; (f \; f) \; x) \\
&amp;=_{\rightarrow} \lambda x. F \; ((\lambda fx. F \; (f \; f) \; x)
\; (\lambda fx. F \; (f \; f) \; x)) \; x \\
&amp;=_{\leftarrow} \lambda x. F \; ((\lambda f&#39;. (\lambda fx.
f&#39; \; (f \; f) \; x) \; (\lambda fx. f&#39; \; (f \; f) \; x)) \; F)
\; x \\
&amp;= \lambda x. F \; (\texttt{fix} \; F) \; x = \lambda x. F \; N \; x
\\
&amp;=_{\eta} F \; N
\end{aligned}
</span></p>
<h4 id="the-problem-with-the-first-two-combinators">The Problem with the
First Two Combinators</h4>
<p>What is the problem with Turing’s and Curry’s combinators? Consider
what happens when we try to evaluate <span class="math inline">\Theta
F</span>:</p>
<p><span class="math display">
\begin{aligned}
\Theta F &amp;\rightsquigarrow\rightsquigarrow F \; ((\lambda xy. y \;
(x \; x \; y)) \; (\lambda xy. y \; (x \; x \; y)) \; F) \\
&amp;\rightsquigarrow\rightsquigarrow F \; (F \; ((\lambda xy. y \; (x
\; x \; y)) \; (\lambda xy. y \; (x \; x \; y)) \; F)) \\
&amp;\rightsquigarrow\rightsquigarrow F \; (F \; (F \; ((\lambda xy. y
\; (x \; x \; y)) \; (\lambda xy. y \; (x \; x \; y)) \; F))) \\
&amp;\rightsquigarrow\rightsquigarrow \ldots
\end{aligned}
</span></p>
<p>Recall the distinction between <em>expressions</em> and
<em>values</em> from Chapter 3 on Computation. The reduction rule for
lambda-calculus is meant to determine which expressions are considered
“equal”—it is highly <em>non-deterministic</em>, while on a computer,
computation needs to go one way or another.</p>
<p>Using the general reduction rule of lambda-calculus, for a recursive
definition, it is always possible to find an infinite reduction
sequence. This means a naive lambda-calculus compiler could legitimately
generate infinite loops for all recursive definitions!</p>
<p>Therefore, we need more specific rules. Most languages use
<strong>call-by-value</strong> (also called <strong>eager</strong>
evaluation):</p>
<p><span class="math display">(\texttt{fun } x \texttt{ -&gt; } a) \; v
\rightsquigarrow a[x := v]</span></p>
<p>The program <em>eagerly</em> computes arguments before starting to
compute the function body. This is exactly the rule we introduced in the
Computation chapter.</p>
<h4 id="call-by-value-fixpoint-combinator-in-action">Call-by-Value
Fixpoint Combinator in Action</h4>
<p>What happens with the call-by-value fixpoint combinator?</p>
<p><span class="math display">
\begin{aligned}
\texttt{fix} \; F &amp;\rightsquigarrow (\lambda fx. F \; (f \; f) \; x)
\; (\lambda fx. F \; (f \; f) \; x) \\
&amp;\rightsquigarrow \lambda x. F \; ((\lambda fx. F \; (f \; f) \; x)
\; (\lambda fx. F \; (f \; f) \; x)) \; x
\end{aligned}
</span></p>
<p>The computation stops because we use the rule <span
class="math inline">(\texttt{fun } x \texttt{ -&gt; } a) \; v
\rightsquigarrow a[x := v]</span> rather than <span
class="math inline">(\texttt{fun } x \texttt{ -&gt; } a_1) \; a_2
\rightsquigarrow a_1[x := a_2]</span>. The expression inside the lambda
is not evaluated until the function is applied.</p>
<p>Let us compute the function on some input:</p>
<p><span class="math display">
\begin{aligned}
\texttt{fix} \; F \; v &amp;\rightsquigarrow (\lambda fx. F \; (f \; f)
\; x) \; (\lambda fx. F \; (f \; f) \; x) \; v \\
&amp;\rightsquigarrow (\lambda x. F \; ((\lambda fx. F \; (f \; f) \; x)
\; (\lambda fx. F \; (f \; f) \; x)) \; x) \; v \\
&amp;\rightsquigarrow F \; ((\lambda fx. F \; (f \; f) \; x) \; (\lambda
fx. F \; (f \; f) \; x)) \; v \\
&amp;\rightsquigarrow F \; (\lambda x. F \; ((\lambda fx. F \; (f \; f)
\; x) \; (\lambda fx. F \; (f \; f) \; x)) \; x) \; v \\
&amp;\rightsquigarrow \text{depends on } F
\end{aligned}
</span></p>
<h4 id="why-fixpoint">Why “Fixpoint”?</h4>
<p>If you examine our derivations, you will see they establish <span
class="math inline">x = f(x)</span>. Such values <span
class="math inline">x</span> are called <strong>fixpoints</strong> of
<span class="math inline">f</span>. An arithmetic function can have
several fixpoints—for example, <span class="math inline">f(x) =
x^2</span> has fixpoints 0 and 1—or no fixpoints, such as <span
class="math inline">f(x) = x + 1</span>.</p>
<p>When you define a function (or another object) by recursion, it has
similar meaning: the name appears on both sides of the equality. In
lambda-calculus, functions like <span class="math inline">\Theta</span>
and <span class="math inline">\mathbf{Y}</span> take <em>any</em>
function as an argument and return its fixpoint.</p>
<p>We turn a specification of a recursive object into a definition by
solving it with respect to the recurring name: deriving <span
class="math inline">x = f(x)</span> where <span
class="math inline">x</span> is the recurring name. We then have <span
class="math inline">x = \texttt{fix}(f)</span>.</p>
<h4 id="deriving-factorial">Deriving Factorial</h4>
<p>Let us walk through this for the factorial function. We omit the
prefix <code>cn_</code> (could be <code>pn_</code> if using pair-encoded
numbers) and shorten <code>if_then_else</code> to
<code>if_t_e</code>:</p>
<p><span class="math display">
\begin{aligned}
\texttt{fact} \; n &amp;= \texttt{if\_t\_e} \; (\texttt{is\_zero} \; n)
\; \texttt{cn1} \; (\texttt{mult} \; n \; (\texttt{fact} \;
(\texttt{pred} \; n))) \\
\texttt{fact} &amp;= \lambda n. \texttt{if\_t\_e} \; (\texttt{is\_zero}
\; n) \; \texttt{cn1} \; (\texttt{mult} \; n \; (\texttt{fact} \;
(\texttt{pred} \; n))) \\
\texttt{fact} &amp;= (\lambda fn. \texttt{if\_t\_e} \;
(\texttt{is\_zero} \; n) \; \texttt{cn1} \; (\texttt{mult} \; n \; (f \;
(\texttt{pred} \; n)))) \; \texttt{fact} \\
\texttt{fact} &amp;= \texttt{fix} \; (\lambda fn. \texttt{if\_t\_e} \;
(\texttt{is\_zero} \; n) \; \texttt{cn1} \; (\texttt{mult} \; n \; (f \;
(\texttt{pred} \; n))))
\end{aligned}
</span></p>
<p>The last line is a valid definition: we simply give a name to a
<em>ground</em> (also called <em>closed</em>) expression—one with no
free variables.</p>
<p><strong>Exercise:</strong> Compute <code>fact cn2</code>.</p>
<p><strong>Exercise:</strong> What does
<code>fix (fun x -&gt; cn_succ x)</code> mean?</p>
<h3 id="encoding-lists-and-trees">4.8 Encoding Lists and Trees</h3>
<p>A <strong>list</strong> is either empty (often called
<code>Empty</code> or <code>Nil</code>) or consists of an element
followed by another list (the “tail”), called <code>Cons</code>.</p>
<p>Define: - <code>nil</code> <span class="math inline">= \lambda
xy.y</span> - <code>cons</code> <span class="math inline">H \; T =
\lambda xy. x \; H \; T</span></p>
<p>To add numbers stored inside a list:</p>
<p><span class="math display">\texttt{addlist} \; l = l \; (\lambda ht.
\texttt{cn\_add} \; h \; (\texttt{addlist} \; t)) \;
\texttt{cn0}</span></p>
<p>To make a proper definition, we apply <span
class="math inline">\texttt{fix}</span> to the solution of the above
equation:</p>
<p><span class="math display">\texttt{addlist} = \texttt{fix} \;
(\lambda fl. l \; (\lambda ht. \texttt{cn\_add} \; h \; (f \; t)) \;
\texttt{cn0})</span></p>
<p>For <strong>trees</strong>, let us use a different form of binary
trees: instead of keeping elements in inner nodes, we keep elements in
leaves.</p>
<p>Define: - <code>leaf</code> <span class="math inline">n = \lambda xy.
x \; n</span> - <code>node</code> <span class="math inline">L \; R =
\lambda xy. y \; L \; R</span></p>
<p>To add numbers stored inside a tree:</p>
<p><span class="math display">\texttt{addtree} \; t = t \; (\lambda n.n)
\; (\lambda lr. \texttt{cn\_add} \; (\texttt{addtree} \; l) \;
(\texttt{addtree} \; r))</span></p>
<p>And in solved form:</p>
<p><span class="math display">\texttt{addtree} = \texttt{fix} \;
(\lambda ft. t \; (\lambda n.n) \; (\lambda lr. \texttt{cn\_add} \; (f
\; l) \; (f \; r)))</span></p>
<pre><code>let rec fix f x = f (fix f) x
let nil = fun x y -&gt; y
let cons h t = fun x y -&gt; x h t
let addlist l =
  fix (fun f l -&gt; l (fun h t -&gt; cn_add h (f t)) cn0) l
;;
decode_cnat
  (addlist (cons cn1 (cons cn2 (cons cn7 nil))));;
let leaf n = fun x y -&gt; x n
let node l r = fun x y -&gt; y l r
let addtree t =
  fix (fun f t -&gt;
    t (fun n -&gt; n) (fun l r -&gt; cn_add (f l) (f r))
  ) t
;;
decode_cnat
  (addtree (node (node (leaf cn3) (leaf cn7))
              (leaf cn1)));;</code></pre>
<h4 id="the-general-pattern">The General Pattern</h4>
<p>Observe a regularity: when we encode a variant type with <span
class="math inline">n</span> variants, for each variant we define a
function that takes <span class="math inline">n</span> arguments.</p>
<p>If the <span class="math inline">k</span>th variant <span
class="math inline">C_k</span> has <span class="math inline">m_k</span>
parameters, then the function <span class="math inline">c_k</span> that
encodes it has the form:</p>
<p><span class="math display">C_k(v_1, \ldots, v_{m_k}) \sim c_k \; v_1
\; \ldots \; v_{m_k} = \lambda x_1 \ldots x_n. x_k \; v_1 \; \ldots \;
v_{m_k}</span></p>
<p>The encoded variants serve as shallow pattern matching with
guaranteed exhaustiveness: the <span class="math inline">k</span>th
argument corresponds to the <span class="math inline">k</span>th branch
of pattern matching.</p>
<h3 id="looping-recursion">4.9 Looping Recursion</h3>
<p>Let us return to pair-encoded numbers and define addition:</p>
<pre><code>let pn_add m n =
  fix (fun f m n -&gt;
    if_then_else (pn_is_zero m)
      n (pn_succ (f (pn_pred m) n))
  ) m n;;
decode_pnat (pn_add pn3 pn3);;</code></pre>
<p>Oops… OCaml says:
<code>Stack overflow during evaluation (looping recursion?).</code></p>
<p>What went wrong? Nothing as far as lambda-calculus is concerned. But
OCaml (and F#) always compute arguments before calling a function. By
definition of <code>fix</code>, <code>f</code> corresponds to
recursively calling <code>pn_add</code>. Therefore,
<code>(pn_succ (f (pn_pred m) n))</code> will be evaluated regardless of
what <code>(pn_is_zero m)</code> returns!</p>
<p>Why do <code>addlist</code> and <code>addtree</code> work? Because
their recursive calls are “guarded” by corresponding <code>fun</code>.
What is inside of <code>fun</code> is not computed immediately—only when
the function is applied to argument(s).</p>
<p>To avoid looping recursion, you need to guard all recursive calls.
Besides putting them inside <code>fun</code>, in OCaml or F# you can
also put them in branches of a <code>match</code> clause, as long as one
of the branches does not have unguarded recursive calls.</p>
<p>The trick for functions like <code>if_then_else</code> is to guard
their arguments with <code>fun x -&gt;</code>, where <code>x</code> is
not used, and apply the <em>result</em> of <code>if_then_else</code> to
some dummy value:</p>
<pre><code>let id x = x
let rec fix f x = f (fix f) x
let pn1 x = pn_succ pn0 x
let pn2 x = pn_succ pn1 x
let pn3 x = pn_succ pn2 x
let pn7 x = encode_pnat 7 x
let pn_add m n =
  fix (fun f m n -&gt;
    (if_then_else (pn_is_zero m)
       (fun x -&gt; n) (fun x -&gt; pn_succ (f (pn_pred m) n)))
      id
  ) m n;;
decode_pnat (pn_add pn3 pn3);;
decode_pnat (pn_add pn3 pn7);;</code></pre>
<p>In OCaml or F# we would typically guard by <code>fun () -&gt;</code>
and then apply to <code>()</code>, but we do not have datatypes like
<code>unit</code> in pure lambda-calculus.</p>
<h3 id="exercises-3">4.10 Exercises</h3>
<p><strong>Exercise 1:</strong> Define (implement) and test on a couple
of examples functions corresponding to or computing:</p>
<ol type="1">
<li><code>c_or</code> and <code>c_not</code>;</li>
<li>exponentiation for Church numerals;</li>
<li>is-zero predicate for Church numerals;</li>
<li>even-number predicate for Church numerals;</li>
<li>multiplication for pair-encoded natural numbers;</li>
<li>factorial <span class="math inline">n!</span> for pair-encoded
natural numbers;</li>
<li>the length of a list (in Church numerals);</li>
<li><code>cn_max</code> – maximum of two Church numerals;</li>
<li>the depth of a tree (in Church numerals).</li>
</ol>
<p><strong>Exercise 2:</strong> Construct lambda-terms <span
class="math inline">m_0, m_1, \ldots</span> such that for all <span
class="math inline">n</span> one has:</p>
<p><span class="math display">
\begin{aligned}
m_0 &amp;= x \\
m_{n+1} &amp;= m_{n+2} \; m_n
\end{aligned}
</span></p>
<p>(where equality is after performing <span
class="math inline">\beta</span>-reductions).</p>
<p><strong>Exercise 3:</strong> Representing side-effects as an
explicitly “passed around” state value, write (higher-order) functions
that represent the imperative constructs:</p>
<ol type="1">
<li><code>for</code>…<code>to</code>…</li>
<li><code>for</code>…<code>downto</code>…</li>
<li><code>while</code>…<code>do</code>…</li>
<li><code>do</code>…<code>while</code>…</li>
<li><code>repeat</code>…<code>until</code>…</li>
</ol>
<p>Rather than writing a lambda-term using the encodings that we have
learnt, just implement the functions in OCaml / F#, using built-in
<code>int</code> and <code>bool</code> types. You can use
<code>let rec</code> instead of <code>fix</code>.</p>
<ul>
<li>For example, in exercise (a), write a function
<code>let rec for_to f beg_i end_i s = ...</code> where <code>f</code>
takes arguments <code>i</code> ranging from <code>beg_i</code> to
<code>end_i</code>, state <code>s</code> at given step, and returns
state <code>s</code> at next step; the <code>for_to</code> function
returns the state after the last step.</li>
<li>And in exercise (c), write a function
<code>let rec while_do p f s = ...</code> where both <code>p</code> and
<code>f</code> take state <code>s</code> at given step, and if
<code>p s</code> returns true, then <code>f s</code> is computed to
obtain state at next step; the <code>while_do</code> function returns
the state after the last step.</li>
</ul>
<p>Do not use the imperative features of OCaml and F#!</p>
<p>Although we will not cover imperative features in this course, it is
instructive to see the implementation using them, to better understand
what is actually required of a solution to Exercise 3:</p>
<div class="sourceCode" id="cb102"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* (a) *)</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> for_to f beg_i end_i s =</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s = <span class="dt">ref</span> s <span class="kw">in</span></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">for</span> i = beg_i <span class="kw">to</span> end_i <span class="kw">do</span></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a>    s := f i !s</span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span>;</span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true" tabindex="-1"></a>  !s</span>
<span id="cb102-8"><a href="#cb102-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-9"><a href="#cb102-9" aria-hidden="true" tabindex="-1"></a><span class="co">(* (b) *)</span></span>
<span id="cb102-10"><a href="#cb102-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> for_downto f beg_i end_i s =</span>
<span id="cb102-11"><a href="#cb102-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s = <span class="dt">ref</span> s <span class="kw">in</span></span>
<span id="cb102-12"><a href="#cb102-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">for</span> i = beg_i <span class="kw">downto</span> end_i <span class="kw">do</span></span>
<span id="cb102-13"><a href="#cb102-13" aria-hidden="true" tabindex="-1"></a>    s := f i !s</span>
<span id="cb102-14"><a href="#cb102-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span>;</span>
<span id="cb102-15"><a href="#cb102-15" aria-hidden="true" tabindex="-1"></a>  !s</span>
<span id="cb102-16"><a href="#cb102-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-17"><a href="#cb102-17" aria-hidden="true" tabindex="-1"></a><span class="co">(* (c) *)</span></span>
<span id="cb102-18"><a href="#cb102-18" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> while_do p f s =</span>
<span id="cb102-19"><a href="#cb102-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s = <span class="dt">ref</span> s <span class="kw">in</span></span>
<span id="cb102-20"><a href="#cb102-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">while</span> p !s <span class="kw">do</span></span>
<span id="cb102-21"><a href="#cb102-21" aria-hidden="true" tabindex="-1"></a>    s := f !s</span>
<span id="cb102-22"><a href="#cb102-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span>;</span>
<span id="cb102-23"><a href="#cb102-23" aria-hidden="true" tabindex="-1"></a>  !s</span>
<span id="cb102-24"><a href="#cb102-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-25"><a href="#cb102-25" aria-hidden="true" tabindex="-1"></a><span class="co">(* (d) *)</span></span>
<span id="cb102-26"><a href="#cb102-26" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> do_while p f s =</span>
<span id="cb102-27"><a href="#cb102-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s = <span class="dt">ref</span> (f s) <span class="kw">in</span></span>
<span id="cb102-28"><a href="#cb102-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">while</span> p !s <span class="kw">do</span></span>
<span id="cb102-29"><a href="#cb102-29" aria-hidden="true" tabindex="-1"></a>    s := f !s</span>
<span id="cb102-30"><a href="#cb102-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span>;</span>
<span id="cb102-31"><a href="#cb102-31" aria-hidden="true" tabindex="-1"></a>  !s</span>
<span id="cb102-32"><a href="#cb102-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-33"><a href="#cb102-33" aria-hidden="true" tabindex="-1"></a><span class="co">(* (e) *)</span></span>
<span id="cb102-34"><a href="#cb102-34" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> repeat_until p f s =</span>
<span id="cb102-35"><a href="#cb102-35" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s = <span class="dt">ref</span> (f s) <span class="kw">in</span></span>
<span id="cb102-36"><a href="#cb102-36" aria-hidden="true" tabindex="-1"></a>  <span class="kw">while</span> <span class="dt">not</span> (p !s) <span class="kw">do</span></span>
<span id="cb102-37"><a href="#cb102-37" aria-hidden="true" tabindex="-1"></a>    s := f !s</span>
<span id="cb102-38"><a href="#cb102-38" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span>;</span>
<span id="cb102-39"><a href="#cb102-39" aria-hidden="true" tabindex="-1"></a>  !s</span></code></pre></div>
<h2 id="chapter-5-polymorphism-and-abstract-data-types">Chapter 5:
Polymorphism and Abstract Data Types</h2>
<p>This chapter explores how OCaml’s type system supports generic
programming through parametric polymorphism, and how abstract data types
provide clean interfaces for data structures. We examine the formal
mechanics of type inference and then apply these concepts to build
progressively more sophisticated implementations of the map (dictionary)
data structure, culminating in red-black trees.</p>
<h3 id="type-inference">5.1 Type Inference</h3>
<p>We have seen the rules that govern the assignment of types to
expressions, but how does OCaml guess what types to use, and when no
correct types exist? The answer is that it solves equations.</p>
<h4 id="variables-unknowns-and-parameters">5.1.1 Variables: Unknowns and
Parameters</h4>
<p>Variables in type inference play two distinct roles: they can be
<em>unknowns</em> (standing for a specific but not-yet-determined type)
or <em>parameters</em> (standing for any type whatsoever).</p>
<p>Consider the following example:</p>
<div class="sourceCode" id="cb103"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> f = <span class="dt">List</span>.hd;;</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : &#39;a <span class="dt">list</span> -&gt; &#39;a</span></code></pre></div>
<p>Here <code>'a</code> is a parameter: it can become any type.
Mathematically we write: <span class="math inline">f : \forall \alpha .
\alpha \ \text{list} \rightarrow \alpha</span> – the quantified type is
called a <em>type scheme</em>.</p>
<p>In contrast:</p>
<div class="sourceCode" id="cb104"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> x = <span class="dt">ref</span> [];;</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> x : &#39;_a <span class="dt">list</span> <span class="dt">ref</span></span></code></pre></div>
<p>Here <code>'_a</code> is an unknown. It stands for a particular type
like <code>float</code> or <code>int -&gt; int</code>, but OCaml just
does not yet know which type. OCaml only reports unknowns like
<code>'_a</code> in inferred types for reasons related to mutable state
(the “value restriction”), which are not central to functional
programming.</p>
<p>When unknowns appear in inferred types against our expectations,
<em><span class="math inline">\eta</span>-expansion</em> may help:
writing <code>let f x = expr x</code> instead of
<code>let f = expr</code>. For example:</p>
<div class="sourceCode" id="cb105"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> f = <span class="dt">List</span>.append [];;</span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : &#39;_a <span class="dt">list</span> -&gt; &#39;_a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> f l = <span class="dt">List</span>.append [] l;;</span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
<p>In the second definition, the eta-expanded form allows full
generalization.</p>
<h4 id="type-environments">5.1.2 Type Environments</h4>
<p>A <em>type environment</em> specifies what names (corresponding to
parameters and definitions) are available for an expression because they
were introduced above it, and it specifies their types.</p>
<h4 id="solving-type-equations">5.1.3 Solving Type Equations</h4>
<p>Type inference solves equations over unknowns. The central question
is: “What has to hold so that <span class="math inline">e : \tau</span>
in type environment <span class="math inline">\Gamma</span>?”</p>
<p>The process works as follows:</p>
<ul>
<li><p>If, for example, <span class="math inline">f : \forall \alpha .
\alpha \ \text{list} \rightarrow \alpha \in \Gamma</span>, then for
<span class="math inline">f : \tau</span> we introduce <span
class="math inline">\gamma \ \text{list} \rightarrow \gamma =
\tau</span> for some fresh unknown <span
class="math inline">\gamma</span>.</p></li>
<li><p>For function application <span class="math inline">e_1 \ e_2 :
\tau</span>, we introduce <span class="math inline">\beta = \tau</span>
and ask for <span class="math inline">e_1 : \gamma \rightarrow
\beta</span> and <span class="math inline">e_2 : \gamma</span>, for some
fresh unknowns <span class="math inline">\beta, \gamma</span>.</p></li>
<li><p>For a function <span class="math inline">\text{fun} \ x
\rightarrow e : \tau</span>, we introduce <span
class="math inline">\beta \rightarrow \gamma = \tau</span> and ask for
<span class="math inline">e : \gamma</span> in environment <span
class="math inline">\{x : \beta\} \cup \Gamma</span>, for some fresh
unknowns <span class="math inline">\beta, \gamma</span>.</p></li>
<li><p>The case <span class="math inline">\text{let} \ x = e_1 \
\text{in} \ e_2 : \tau</span> is different. One approach is to
<em>first</em> solve the equations that we get by asking for <span
class="math inline">e_1 : \beta</span>, for some fresh unknown <span
class="math inline">\beta</span>. Let us say a solution <span
class="math inline">\beta = \tau_\beta</span> has been found, <span
class="math inline">\alpha_1 \ldots \alpha_n \beta_1 \ldots
\beta_m</span> are the remaining unknowns in <span
class="math inline">\tau_\beta</span>, and <span
class="math inline">\alpha_1 \ldots \alpha_n</span> are all that do not
appear in <span class="math inline">\Gamma</span>. Then we ask for <span
class="math inline">e_2 : \tau</span> in environment <span
class="math inline">\{x : \forall \alpha_1 \ldots \alpha_n .
\tau_\beta\} \cup \Gamma</span>.</p></li>
<li><p>Remember that whenever we establish a solution <span
class="math inline">\beta = \tau_\beta</span> to an unknown <span
class="math inline">\beta</span>, it takes effect everywhere!</p></li>
<li><p>To find a type for <span class="math inline">e</span> (in
environment <span class="math inline">\Gamma</span>), we pick a fresh
unknown <span class="math inline">\beta</span> and ask for <span
class="math inline">e : \beta</span> (in <span
class="math inline">\Gamma</span>).</p></li>
</ul>
<h4 id="polymorphism">5.1.4 Polymorphism</h4>
<p>The “top-level” definitions for which the system infers types with
variables are called <em>polymorphic</em>, which informally means
“working with different shapes of data”. This kind of polymorphism is
called <em>parametric polymorphism</em>, since the types have
parameters. A different kind of polymorphism is provided by
object-oriented programming languages (sometimes called <em>subtype
polymorphism</em> or <em>ad-hoc polymorphism</em>).</p>
<h3 id="parametric-types">5.2 Parametric Types</h3>
<p>Polymorphic functions shine when used with polymorphic data types.
Consider:</p>
<div class="sourceCode" id="cb106"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a my_list = Empty | Cons <span class="kw">of</span> &#39;a * &#39;a my_list</span></code></pre></div>
<p>We define lists that can store elements of any type <code>'a</code>.
Now:</p>
<div class="sourceCode" id="cb107"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> tail l =</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="dt">invalid_arg</span> <span class="st">&quot;tail&quot;</span></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a>    | Cons (_, tl) -&gt; tl;;</span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> tail : &#39;a my_list -&gt; &#39;a my_list</span></code></pre></div>
<p>This is a polymorphic function: it works for lists with elements of
any type.</p>
<p>A <em>parametric type</em> like <code>'a my_list</code> <em>is
not</em> itself a data type but a family of data types:
<code>bool my_list</code>, <code>int my_list</code>, etc. <em>are</em>
different types. We say that the type <code>int my_list</code>
<em>instantiates</em> the parametric type <code>'a my_list</code>.</p>
<h4 id="multiple-type-parameters">5.2.1 Multiple Type Parameters</h4>
<p>In OCaml, the syntax is a bit confusing: type parameters precede the
type name. For example:</p>
<div class="sourceCode" id="cb108"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (&#39;a, &#39;b) choice = Left <span class="kw">of</span> &#39;a | Right <span class="kw">of</span> &#39;b</span></code></pre></div>
<p>This type has two parameters. Mathematically we would write <span
class="math inline">\text{choice}(\alpha, \beta)</span>.</p>
<p>Functions do not have to be polymorphic:</p>
<div class="sourceCode" id="cb109"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> get_int c =</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> c <span class="kw">with</span></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a>    | Left i -&gt; i</span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a>    | Right b -&gt; <span class="kw">if</span> b <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>;;</span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> get_int : (<span class="dt">int</span>, <span class="dt">bool</span>) choice -&gt; <span class="dt">int</span></span></code></pre></div>
<h4 id="syntax-in-other-languages">5.2.2 Syntax in Other Languages</h4>
<p>In F#, we provide parameters (when more than one) after the type
name:</p>
<div class="sourceCode" id="cb110"><pre
class="sourceCode fsharp"><code class="sourceCode fsharp"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> choice&lt;&#39;a,&#39;b&gt; = Left <span class="kw">of</span> &#39;a | Right <span class="kw">of</span> &#39;b</span></code></pre></div>
<p>In Haskell, we provide type parameters similarly to function
arguments:</p>
<div class="sourceCode" id="cb111"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Choice</span> a b <span class="ot">=</span> <span class="dt">Left</span> a <span class="op">|</span> <span class="dt">Right</span> b</span></code></pre></div>
<h3 id="type-inference-formally">5.3 Type Inference, Formally</h3>
<p>A statement that an expression has a type in an environment is called
a <em>type judgement</em>. For environment <span
class="math inline">\Gamma = \{x : \forall \alpha_1 \ldots \alpha_n .
\tau_x ; \ldots\}</span>, expression <span class="math inline">e</span>
and type <span class="math inline">\tau</span> we write:</p>
<p><span class="math display">\Gamma \vdash e : \tau</span></p>
<p>We will derive the equations in one go using <span
class="math inline">\llbracket \cdot \rrbracket</span>, to be solved
later. Besides equations we will need to manage introduced variables,
using existential quantification.</p>
<p>For local definitions we require remembering what constraints should
hold when the definition is used. Therefore we extend <em>type
schemes</em> in the environment to: <span class="math inline">\Gamma =
\{x : \forall \beta_1 \ldots \beta_m [\exists \alpha_1 \ldots \alpha_n .
D] . \tau_x ; \ldots\}</span> where <span class="math inline">D</span>
are equations – keeping the variables <span class="math inline">\alpha_1
\ldots \alpha_n</span> introduced while deriving <span
class="math inline">D</span> in front. A simpler form would be enough:
<span class="math inline">\Gamma = \{x : \forall \beta [\exists \alpha_1
\ldots \alpha_n . D] . \beta ; \ldots\}</span></p>
<p>The formal constraint generation rules are:</p>
<p><span class="math display">\llbracket \Gamma \vdash x : \tau
\rrbracket = \exists \overline{\beta&#39;} \overline{\alpha&#39;} .
(D[\overline{\beta} \overline{\alpha} := \overline{\beta&#39;}
\overline{\alpha&#39;}] \wedge \tau_x[\overline{\beta} \overline{\alpha}
:= \overline{\beta&#39;} \overline{\alpha&#39;}] \doteq \tau)</span></p>
<p>where <span class="math inline">\Gamma(x) = \forall \overline{\beta}
[\exists \overline{\alpha} . D] . \tau_x</span>, <span
class="math inline">\overline{\beta&#39;} \overline{\alpha&#39;} \#
\text{FV}(\Gamma, \tau)</span></p>
<p><span class="math display">\llbracket \Gamma \vdash \mathbf{fun} \ x
\texttt{-&gt;} e : \tau \rrbracket = \exists \alpha_1 \alpha_2 .
(\llbracket \Gamma \{x : \alpha_1\} \vdash e : \alpha_2 \rrbracket
\wedge \alpha_1 \rightarrow \alpha_2 \doteq \tau)</span></p>
<p>where <span class="math inline">\alpha_1 \alpha_2 \#
\text{FV}(\Gamma, \tau)</span></p>
<p><span class="math display">\llbracket \Gamma \vdash e_1 \ e_2 : \tau
\rrbracket = \exists \alpha . (\llbracket \Gamma \vdash e_1 : \alpha
\rightarrow \tau \rrbracket \wedge \llbracket \Gamma \vdash e_2 : \alpha
\rrbracket), \alpha \# \text{FV}(\Gamma, \tau)</span></p>
<p><span class="math display">\llbracket \Gamma \vdash K \ e_1 \ldots
e_n : \tau \rrbracket = \exists \overline{\alpha&#39;} . (\bigwedge_i
\llbracket \Gamma \vdash e_i : \tau_i[\overline{\alpha} :=
\overline{\alpha&#39;}] \rrbracket \wedge
\varepsilon(\overline{\alpha&#39;}) \doteq \tau)</span></p>
<p>where <span class="math inline">K : \forall \overline{\alpha} .
\tau_1 \times \ldots \times \tau_n \rightarrow
\varepsilon(\overline{\alpha})</span>, <span
class="math inline">\overline{\alpha&#39;} \# \text{FV}(\Gamma,
\tau)</span></p>
<p>For let-expressions:</p>
<p><span class="math display">\llbracket \Gamma \vdash \mathbf{let} \ x
= e_1 \ \mathbf{in} \ e_2 : \tau \rrbracket = (\exists \beta . C) \wedge
\llbracket \Gamma \{x : \forall \beta [C] . \beta\} \vdash e_2 : \tau
\rrbracket</span></p>
<p>where <span class="math inline">C = \llbracket \Gamma \vdash e_1 :
\beta \rrbracket</span></p>
<p>For recursive let-expressions:</p>
<p><span class="math display">\llbracket \Gamma \vdash \mathbf{letrec} \
x = e_1 \ \mathbf{in} \ e_2 : \tau \rrbracket = (\exists \beta . C)
\wedge \llbracket \Gamma \{x : \forall \beta [C] . \beta\} \vdash e_2 :
\tau \rrbracket</span></p>
<p>where <span class="math inline">C = \llbracket \Gamma \{x : \beta\}
\vdash e_1 : \beta \rrbracket</span></p>
<p>For match expressions:</p>
<p><span class="math display">\llbracket \Gamma \vdash \mathbf{match} \
e_v \ \mathbf{with} \ \overline{c} : \tau \rrbracket = \exists \alpha_v
. \llbracket \Gamma \vdash e_v : \alpha_v \rrbracket \bigwedge_i
\llbracket \Gamma \vdash p_i . e_i : \alpha_v \rightarrow \tau
\rrbracket</span></p>
<p>where <span class="math inline">\overline{c} = p_1 . e_1 | \ldots |
p_n . e_n</span>, <span class="math inline">\alpha_v \#
\text{FV}(\Gamma, \tau)</span></p>
<p>For pattern clauses:</p>
<p><span class="math display">\llbracket \Gamma, \Sigma \vdash p.e :
\tau_1 \rightarrow \tau_2 \rrbracket = \llbracket \Sigma \vdash p
\downarrow \tau_1 \rrbracket \wedge \exists \overline{\beta} .
\llbracket \Gamma \Gamma&#39; \vdash e : \tau_2 \rrbracket</span></p>
<p>where <span class="math inline">\exists \overline{\beta}
\Gamma&#39;</span> is <span class="math inline">\llbracket \Sigma \vdash
p \uparrow \tau_1 \rrbracket</span>, <span
class="math inline">\overline{\beta} \# \text{FV}(\Gamma,
\tau_2)</span></p>
<p>The notation <span class="math inline">\llbracket \Sigma \vdash p
\downarrow \tau_1 \rrbracket</span> derives constraints on the type of
the matched value, while <span class="math inline">\llbracket \Sigma
\vdash p \uparrow \tau_1 \rrbracket</span> derives the environment for
pattern variables.</p>
<p>By <span class="math inline">\overline{\alpha}</span> or <span
class="math inline">\overline{\alpha_i}</span> we denote a sequence of
some length: <span class="math inline">\alpha_1 \ldots \alpha_n</span>.
By <span class="math inline">\bigwedge_i \varphi_i</span> we denote a
conjunction of <span class="math inline">\overline{\varphi_i}</span>:
<span class="math inline">\varphi_1 \wedge \ldots \wedge
\varphi_n</span>.</p>
<h4 id="polymorphic-recursion">5.3.1 Polymorphic Recursion</h4>
<p>Note the limited polymorphism of <code>let rec f = ...</code> – we
cannot use <code>f</code> polymorphically in its definition. In modern
OCaml we can bypass the problem if we provide the type of <code>f</code>
upfront:</p>
<div class="sourceCode" id="cb112"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> f : &#39;a. &#39;a -&gt; &#39;a <span class="dt">list</span> = ...</span></code></pre></div>
<p>where <code>'a. 'a -&gt; 'a list</code> stands for <span
class="math inline">\forall \alpha . \alpha \rightarrow \alpha \
\text{list}</span>.</p>
<p>Using the recursively defined function with different types in its
definition is called <em>polymorphic recursion</em>. It is most useful
together with <em>irregular recursive datatypes</em> where the recursive
use has different type arguments than the actual parameters.</p>
<h5
id="example-a-list-alternating-between-two-types-of-elements">Example: A
List Alternating Between Two Types of Elements</h5>
<div class="sourceCode" id="cb113"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (&#39;x, &#39;o) alterning =</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>  | Stop</span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>  | One <span class="kw">of</span> &#39;x * (&#39;o, &#39;x) alterning</span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> to_list :</span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a>    &#39;x &#39;o &#39;a. (&#39;x -&gt; &#39;a) -&gt; (&#39;o -&gt; &#39;a) -&gt;</span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a>              (&#39;x, &#39;o) alterning -&gt; &#39;a <span class="dt">list</span> =</span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fun</span> x2a o2a -&gt;</span>
<span id="cb113-9"><a href="#cb113-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">function</span></span>
<span id="cb113-10"><a href="#cb113-10" aria-hidden="true" tabindex="-1"></a>    | Stop -&gt; []</span>
<span id="cb113-11"><a href="#cb113-11" aria-hidden="true" tabindex="-1"></a>    | One (x, rest) -&gt; x2a x :: to_list o2a x2a rest</span>
<span id="cb113-12"><a href="#cb113-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-13"><a href="#cb113-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> to_choice_list alt =</span>
<span id="cb113-14"><a href="#cb113-14" aria-hidden="true" tabindex="-1"></a>  to_list (<span class="kw">fun</span> x -&gt; Left x) (<span class="kw">fun</span> o -&gt; Right o) alt</span>
<span id="cb113-15"><a href="#cb113-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-16"><a href="#cb113-16" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> it = to_choice_list</span>
<span id="cb113-17"><a href="#cb113-17" aria-hidden="true" tabindex="-1"></a>  (One (<span class="dv">1</span>, One (<span class="st">&quot;o&quot;</span>, One (<span class="dv">2</span>, One (<span class="st">&quot;oo&quot;</span>, Stop)))))</span></code></pre></div>
<p>Notice how the recursive call to <code>to_list</code> swaps
<code>o2a</code> and <code>x2a</code> – this is necessary because the
alternating structure swaps the type parameters at each level.</p>
<h5 id="example-data-structural-bootstrapping">Example: Data-Structural
Bootstrapping</h5>
<div class="sourceCode" id="cb114"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a seq =</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>  | Nil</span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>  | Zero <span class="kw">of</span> (&#39;a * &#39;a) seq</span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>  | One <span class="kw">of</span> &#39;a * (&#39;a * &#39;a) seq</span></code></pre></div>
<p>We store a list of elements in exponentially increasing chunks:</p>
<div class="sourceCode" id="cb115"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> example =</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>  One (<span class="dv">0</span>, One ((<span class="dv">1</span>,<span class="dv">2</span>), Zero (One ((((<span class="dv">3</span>,<span class="dv">4</span>),(<span class="dv">5</span>,<span class="dv">6</span>)), ((<span class="dv">7</span>,<span class="dv">8</span>),(<span class="dv">9</span>,<span class="dv">10</span>))), Nil))))</span></code></pre></div>
<div class="sourceCode" id="cb116"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> cons : &#39;a. &#39;a -&gt; &#39;a seq -&gt; &#39;a seq =  <span class="co">(* Appending an element to the *)</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fun</span> x -&gt; <span class="kw">function</span>                           <span class="co">(* datastructure is like *)</span></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>  | Nil -&gt; One (x, Nil)                       <span class="co">(* adding one to a binary number: 1+0=1 *)</span></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a>  | Zero ps -&gt; One (x, ps)                    <span class="co">(* 1+...0=...1 *)</span></span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a>  | One (y, ps) -&gt; Zero (cons (x,y) ps)       <span class="co">(* 1+...1=[...+1]0 *)</span></span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> lookup : &#39;a. <span class="dt">int</span> -&gt; &#39;a seq -&gt; &#39;a =</span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fun</span> i s -&gt; <span class="kw">match</span> i, s <span class="kw">with</span></span>
<span id="cb116-9"><a href="#cb116-9" aria-hidden="true" tabindex="-1"></a>  | _, Nil -&gt; <span class="dt">raise</span> <span class="dt">Not_found</span>                 <span class="co">(* Rather than returning None : &#39;a option *)</span></span>
<span id="cb116-10"><a href="#cb116-10" aria-hidden="true" tabindex="-1"></a>  | <span class="dv">0</span>, One (x, _) -&gt; x                        <span class="co">(* we raise exception, for convenience. *)</span></span>
<span id="cb116-11"><a href="#cb116-11" aria-hidden="true" tabindex="-1"></a>  | i, One (_, ps) -&gt; lookup (i<span class="dv">-1</span>) (Zero ps)</span>
<span id="cb116-12"><a href="#cb116-12" aria-hidden="true" tabindex="-1"></a>  | i, Zero ps -&gt;                             <span class="co">(* Random-Access lookup works *)</span></span>
<span id="cb116-13"><a href="#cb116-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> x, y = lookup (i / <span class="dv">2</span>) ps <span class="kw">in</span>         <span class="co">(* in logarithmic time -- much faster than *)</span></span>
<span id="cb116-14"><a href="#cb116-14" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> i <span class="kw">mod</span> <span class="dv">2</span> = <span class="dv">0</span> <span class="kw">then</span> x <span class="kw">else</span> y            <span class="co">(* in standard lists. *)</span></span></code></pre></div>
<h3 id="algebraic-specification">5.4 Algebraic Specification</h3>
<p>The way we introduce a data structure, like complex numbers or
strings, in mathematics is by specifying an <em>algebraic
structure</em>.</p>
<p>Algebraic structures consist of a set (or several sets, for so-called
<em>multisorted</em> algebras) and a bunch of functions (also known as
operations) over this set (or sets).</p>
<p>A <em>signature</em> is a rough description of an algebraic
structure: it provides <em>sorts</em> – names for the sets (in the
multisorted case) – and names of the functions-operations together with
their arity (and what sorts of arguments they take).</p>
<p>We select a class of algebraic structures by providing axioms that
have to hold. We will call such classes <em>algebraic
specifications</em>. In mathematics, a rusty name for some algebraic
specifications is a <em>variety</em>; a more modern name is
<em>algebraic category</em>.</p>
<p>Algebraic structures correspond to “implementations” and signatures
to “interfaces” in programming languages. We will say that an algebraic
structure <em>implements</em> an algebraic specification when all axioms
of the specification hold in the structure. All algebraic specifications
are implemented by multiple structures!</p>
<p>We say that an algebraic structure does not have <em>junk</em> when
all its elements (i.e., elements in the sets corresponding to sorts) can
be built using operations in its signature.</p>
<p>We allow parametric types as sorts. In that case, strictly speaking,
we define a family of algebraic specifications (a different
specification for each instantiation of the parametric type).</p>
<h4 id="algebraic-specifications-examples">5.4.1 Algebraic
Specifications: Examples</h4>
<p>An algebraic specification can also use an earlier specification. In
“impure” languages like OCaml and F# we allow that the result of any
operation be an <span class="math inline">\text{error}</span>. In
Haskell we could use <code>Maybe</code>.</p>
<p><strong>Specification <span class="math inline">\text{nat}_p</span>
(bounded natural numbers):</strong></p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr>
<th><span class="math inline">\text{nat}_p</span></th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">0 : \text{nat}_p</span></td>
</tr>
<tr>
<td><span class="math inline">\text{succ} : \text{nat}_p \rightarrow
\text{nat}_p</span></td>
</tr>
<tr>
<td><span class="math inline">+ : \text{nat}_p \rightarrow \text{nat}_p
\rightarrow \text{nat}_p</span></td>
</tr>
<tr>
<td><span class="math inline">* : \text{nat}_p \rightarrow \text{nat}_p
\rightarrow \text{nat}_p</span></td>
</tr>
<tr>
<td>Variables: <span class="math inline">n, m : \text{nat}_p</span></td>
</tr>
<tr>
<td>Axioms:</td>
</tr>
<tr>
<td><span class="math inline">0 + n = n</span>, <span
class="math inline">n + 0 = n</span></td>
</tr>
<tr>
<td><span class="math inline">m + \text{succ}(n) = \text{succ}(m +
n)</span></td>
</tr>
<tr>
<td><span class="math inline">0 * n = 0</span>, <span
class="math inline">n * 0 = 0</span></td>
</tr>
<tr>
<td><span class="math inline">m * \text{succ}(n) = m + (m *
n)</span></td>
</tr>
<tr>
<td><span
class="math inline">\underbrace{\text{succ}(\ldots\text{succ}(0))}_{\text{less
than } p \text{ times}} \neq 0</span></td>
</tr>
<tr>
<td><span
class="math inline">\underbrace{\text{succ}(\ldots\text{succ}(0))}_{p
\text{ times}} = 0</span></td>
</tr>
</tbody>
</table>
<p><strong>Specification <span
class="math inline">\text{string}_p</span> (bounded
strings):</strong></p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr>
<th><span class="math inline">\text{string}_p</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>uses <span class="math inline">\text{char}</span>, <span
class="math inline">\text{nat}_p</span></td>
</tr>
<tr>
<td><code>""</code> <span class="math inline">:
\text{string}_p</span></td>
</tr>
<tr>
<td><code>"c"</code> <span class="math inline">: \text{char} \rightarrow
\text{string}_p</span></td>
</tr>
<tr>
<td><span class="math inline">\hat{\ } : \text{string}_p \rightarrow
\text{string}_p \rightarrow \text{string}_p</span></td>
</tr>
<tr>
<td><span class="math inline">\cdot[\cdot] : \text{string}_p \rightarrow
\text{nat}_p \rightarrow \text{char}</span></td>
</tr>
<tr>
<td>Variables: <span class="math inline">s : \text{string}_p</span>,
<span class="math inline">c, c_1, \ldots, c_p : \text{char}</span>,
<span class="math inline">n : \text{nat}_p</span></td>
</tr>
<tr>
<td>Axioms:</td>
</tr>
<tr>
<td><code>""</code> <span class="math inline">\hat{\ } s = s</span>,
<span class="math inline">s \hat{\ }</span> <code>""</code> <span
class="math inline">= s</span></td>
</tr>
<tr>
<td><span class="math inline">\underbrace{\text{``}c_1\text{&#39;&#39;}
\hat{\ } (\ldots \hat{\ } \text{``}c_p\text{&#39;&#39;})}_{p \text{
times}} = \text{error}</span></td>
</tr>
<tr>
<td><span class="math inline">r \hat{\ } (s \hat{\ } t) = (r \hat{\ } s)
\hat{\ } t</span></td>
</tr>
<tr>
<td><span class="math inline">(\text{``}c\text{&#39;&#39;} \hat{\ }
s)[0] = c</span></td>
</tr>
<tr>
<td><span class="math inline">(\text{``}c\text{&#39;&#39;} \hat{\ }
s)[\text{succ}(n)] = s[n]</span></td>
</tr>
<tr>
<td><code>""</code><span class="math inline">[n] =
\text{error}</span></td>
</tr>
</tbody>
</table>
<h3 id="homomorphisms">5.5 Homomorphisms</h3>
<p>Homomorphisms are mappings between algebraic structures with the same
signature that preserve operations.</p>
<p>A <em>homomorphism</em> from algebraic structure <span
class="math inline">(A, \{f^A, g^A, \ldots\})</span> to <span
class="math inline">(B, \{f^B, g^B, \ldots\})</span> is a function <span
class="math inline">h : A \rightarrow B</span> such that: - <span
class="math inline">h(f^A(a_1, \ldots, a_{n_f})) = f^B(h(a_1), \ldots,
h(a_{n_f}))</span> for all <span class="math inline">(a_1, \ldots,
a_{n_f})</span> - <span class="math inline">h(g^A(a_1, \ldots, a_{n_g}))
= g^B(h(a_1), \ldots, h(a_{n_g}))</span> for all <span
class="math inline">(a_1, \ldots, a_{n_g})</span> - and so on for all
operations.</p>
<p>Two algebraic structures are <em>isomorphic</em> if there are
homomorphisms <span class="math inline">h_1 : A \rightarrow B</span>,
<span class="math inline">h_2 : B \rightarrow A</span> from one to the
other and back, that when composed in any order form identity: <span
class="math inline">\forall (b \in B) \ h_1(h_2(b)) = b</span> and <span
class="math inline">\forall (a \in A) \ h_2(h_1(a)) = a</span>.</p>
<p>An algebraic specification whose all implementations without junk are
isomorphic is called “<em>monomorphic</em>”. We usually only add axioms
that really matter to us to the specification, so that the
implementations have room for optimization. For this reason, the
resulting specifications will often not be monomorphic in the above
sense.</p>
<h3 id="example-maps">5.6 Example: Maps</h3>
<p>A <em>map</em> (also called dictionary or associative array)
associates keys with values. Here is an algebraic specification:</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr>
<th><span class="math inline">(\alpha, \beta) \ \text{map}</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>uses <span class="math inline">\text{bool}</span>, type parameters
<span class="math inline">\alpha, \beta</span></td>
</tr>
<tr>
<td><span class="math inline">\text{empty} : (\alpha, \beta) \
\text{map}</span></td>
</tr>
<tr>
<td><span class="math inline">\text{member} : \alpha \rightarrow
(\alpha, \beta) \ \text{map} \rightarrow \text{bool}</span></td>
</tr>
<tr>
<td><span class="math inline">\text{add} : \alpha \rightarrow \beta
\rightarrow (\alpha, \beta) \ \text{map} \rightarrow (\alpha, \beta) \
\text{map}</span></td>
</tr>
<tr>
<td><span class="math inline">\text{remove} : \alpha \rightarrow
(\alpha, \beta) \ \text{map} \rightarrow (\alpha, \beta) \
\text{map}</span></td>
</tr>
<tr>
<td><span class="math inline">\text{find} : \alpha \rightarrow (\alpha,
\beta) \ \text{map} \rightarrow \beta</span></td>
</tr>
<tr>
<td>Variables: <span class="math inline">k, k_2 : \alpha</span>, <span
class="math inline">v, v_2 : \beta</span>, <span class="math inline">m :
(\alpha, \beta) \ \text{map}</span></td>
</tr>
<tr>
<td>Axioms:</td>
</tr>
<tr>
<td><span class="math inline">\text{member}(k, \text{add}(k, v, m)) =
\text{true}</span></td>
</tr>
<tr>
<td><span class="math inline">\text{member}(k, \text{remove}(k, m)) =
\text{false}</span></td>
</tr>
<tr>
<td><span class="math inline">\text{member}(k, \text{add}(k_2, v, m)) =
\text{true} \wedge k \neq k_2 \Leftrightarrow \text{member}(k, m) =
\text{true} \wedge k \neq k_2</span></td>
</tr>
<tr>
<td><span class="math inline">\text{member}(k, \text{remove}(k_2, m)) =
\text{true} \wedge k \neq k_2 \Leftrightarrow \text{member}(k, m) =
\text{true} \wedge k \neq k_2</span></td>
</tr>
<tr>
<td><span class="math inline">\text{find}(k, \text{add}(k, v, m)) =
v</span></td>
</tr>
<tr>
<td><span class="math inline">\text{find}(k, \text{remove}(k, m)) =
\text{error}</span>, <span class="math inline">\text{find}(k,
\text{empty}) = \text{error}</span></td>
</tr>
<tr>
<td><span class="math inline">\text{find}(k, \text{add}(k_2, v_2, m)) =
v \wedge k \neq k_2 \Leftrightarrow \text{find}(k, m) = v \wedge k \neq
k_2</span></td>
</tr>
<tr>
<td><span class="math inline">\text{find}(k, \text{remove}(k_2, m)) = v
\wedge k \neq k_2 \Leftrightarrow \text{find}(k, m) = v \wedge k \neq
k_2</span></td>
</tr>
<tr>
<td><span class="math inline">\text{remove}(k, \text{empty}) =
\text{empty}</span></td>
</tr>
</tbody>
</table>
<h3 id="modules-and-interfaces-signatures-syntax">5.7 Modules and
Interfaces (Signatures): Syntax</h3>
<p>In the ML family of languages, structures are given names by
<strong>module</strong> bindings, and signatures are types of modules.
From outside of a structure or signature, we refer to the values or
types it provides with a dot notation: <code>Module.value</code>.</p>
<p>Module (and module type) names have to start with a capital letter
(in ML languages). Since modules and module types have names, there is a
tradition to name the central type of a signature (the one that is
“specified” by the signature), for brevity, <code>t</code>. Module types
are often named with “all-caps” (all letters upper case).</p>
<div class="sourceCode" id="cb117"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">type</span> MAP = <span class="kw">sig</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> (&#39;a, &#39;b) t</span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> empty : (&#39;a, &#39;b) t</span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> member : &#39;a -&gt; (&#39;a, &#39;b) t -&gt; <span class="dt">bool</span></span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> add : &#39;a -&gt; &#39;b -&gt; (&#39;a, &#39;b) t -&gt; (&#39;a, &#39;b) t</span>
<span id="cb117-6"><a href="#cb117-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> remove : &#39;a -&gt; (&#39;a, &#39;b) t -&gt; (&#39;a, &#39;b) t</span>
<span id="cb117-7"><a href="#cb117-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> find : &#39;a -&gt; (&#39;a, &#39;b) t -&gt; &#39;b</span>
<span id="cb117-8"><a href="#cb117-8" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb117-9"><a href="#cb117-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-10"><a href="#cb117-10" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> ListMap : MAP = <span class="kw">struct</span></span>
<span id="cb117-11"><a href="#cb117-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> (&#39;a, &#39;b) t = (&#39;a * &#39;b) <span class="dt">list</span></span>
<span id="cb117-12"><a href="#cb117-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> empty = []</span>
<span id="cb117-13"><a href="#cb117-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> member = <span class="dt">List</span>.mem_assoc</span>
<span id="cb117-14"><a href="#cb117-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> add k v m = (k, v)::m</span>
<span id="cb117-15"><a href="#cb117-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> remove = <span class="dt">List</span>.remove_assoc</span>
<span id="cb117-16"><a href="#cb117-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> find = <span class="dt">List</span>.assoc</span>
<span id="cb117-17"><a href="#cb117-17" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<h3 id="implementing-maps-association-lists">5.8 Implementing Maps:
Association Lists</h3>
<p>Let us now build an implementation of maps from the ground up. The
most straightforward implementation… might not be what you expected:</p>
<div class="sourceCode" id="cb118"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> TrivialMap : MAP = <span class="kw">struct</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> (&#39;a, &#39;b) t =</span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>    | Empty</span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a>    | Add <span class="kw">of</span> &#39;a * &#39;b * (&#39;a, &#39;b) t</span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a>    | Remove <span class="kw">of</span> &#39;a * (&#39;a, &#39;b) t</span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> empty = Empty</span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-9"><a href="#cb118-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> member k m =</span>
<span id="cb118-10"><a href="#cb118-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb118-11"><a href="#cb118-11" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="kw">false</span></span>
<span id="cb118-12"><a href="#cb118-12" aria-hidden="true" tabindex="-1"></a>    | Add (k2, _, _) <span class="kw">when</span> k = k2 -&gt; <span class="kw">true</span></span>
<span id="cb118-13"><a href="#cb118-13" aria-hidden="true" tabindex="-1"></a>    | Remove (k2, _) <span class="kw">when</span> k = k2 -&gt; <span class="kw">false</span></span>
<span id="cb118-14"><a href="#cb118-14" aria-hidden="true" tabindex="-1"></a>    | Add (_, _, m2) -&gt; member k m2</span>
<span id="cb118-15"><a href="#cb118-15" aria-hidden="true" tabindex="-1"></a>    | Remove (_, m2) -&gt; member k m2</span>
<span id="cb118-16"><a href="#cb118-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-17"><a href="#cb118-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> add k v m = Add (k, v, m)</span>
<span id="cb118-18"><a href="#cb118-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> remove k m = Remove (k, m)</span>
<span id="cb118-19"><a href="#cb118-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-20"><a href="#cb118-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> find k m =</span>
<span id="cb118-21"><a href="#cb118-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb118-22"><a href="#cb118-22" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="dt">raise</span> <span class="dt">Not_found</span></span>
<span id="cb118-23"><a href="#cb118-23" aria-hidden="true" tabindex="-1"></a>    | Add (k2, v, _) <span class="kw">when</span> k = k2 -&gt; v</span>
<span id="cb118-24"><a href="#cb118-24" aria-hidden="true" tabindex="-1"></a>    | Remove (k2, _) <span class="kw">when</span> k = k2 -&gt; <span class="dt">raise</span> <span class="dt">Not_found</span></span>
<span id="cb118-25"><a href="#cb118-25" aria-hidden="true" tabindex="-1"></a>    | Add (_, _, m2) -&gt; find k m2</span>
<span id="cb118-26"><a href="#cb118-26" aria-hidden="true" tabindex="-1"></a>    | Remove (_, m2) -&gt; find k m2</span>
<span id="cb118-27"><a href="#cb118-27" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>This “trivial” implementation simply records all operations as a log.
The <code>add</code> and <code>remove</code> operations are <span
class="math inline">O(1)</span>, but <code>member</code> and
<code>find</code> must traverse the entire history.</p>
<p>Here is an implementation based on association lists, i.e., on lists
of key-value pairs:</p>
<div class="sourceCode" id="cb119"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> MyListMap : MAP = <span class="kw">struct</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> (&#39;a, &#39;b) t = Empty | Add <span class="kw">of</span> &#39;a * &#39;b * (&#39;a, &#39;b) t</span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> empty = Empty</span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> member k m =</span>
<span id="cb119-7"><a href="#cb119-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb119-8"><a href="#cb119-8" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="kw">false</span></span>
<span id="cb119-9"><a href="#cb119-9" aria-hidden="true" tabindex="-1"></a>    | Add (k2, _, _) <span class="kw">when</span> k = k2 -&gt; <span class="kw">true</span></span>
<span id="cb119-10"><a href="#cb119-10" aria-hidden="true" tabindex="-1"></a>    | Add (_, _, m2) -&gt; member k m2</span>
<span id="cb119-11"><a href="#cb119-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-12"><a href="#cb119-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> add k v m =</span>
<span id="cb119-13"><a href="#cb119-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb119-14"><a href="#cb119-14" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; Add (k, v, Empty)</span>
<span id="cb119-15"><a href="#cb119-15" aria-hidden="true" tabindex="-1"></a>    | Add (k2, _, m) <span class="kw">when</span> k = k2 -&gt; Add (k, v, m)</span>
<span id="cb119-16"><a href="#cb119-16" aria-hidden="true" tabindex="-1"></a>    | Add (k2, v2, m) -&gt; Add (k2, v2, add k v m)</span>
<span id="cb119-17"><a href="#cb119-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-18"><a href="#cb119-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> remove k m =</span>
<span id="cb119-19"><a href="#cb119-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb119-20"><a href="#cb119-20" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; Empty</span>
<span id="cb119-21"><a href="#cb119-21" aria-hidden="true" tabindex="-1"></a>    | Add (k2, _, m) <span class="kw">when</span> k = k2 -&gt; m</span>
<span id="cb119-22"><a href="#cb119-22" aria-hidden="true" tabindex="-1"></a>    | Add (k2, v, m) -&gt; Add (k2, v, remove k m)</span>
<span id="cb119-23"><a href="#cb119-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-24"><a href="#cb119-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> find k m =</span>
<span id="cb119-25"><a href="#cb119-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb119-26"><a href="#cb119-26" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="dt">raise</span> <span class="dt">Not_found</span></span>
<span id="cb119-27"><a href="#cb119-27" aria-hidden="true" tabindex="-1"></a>    | Add (k2, v, _) <span class="kw">when</span> k = k2 -&gt; v</span>
<span id="cb119-28"><a href="#cb119-28" aria-hidden="true" tabindex="-1"></a>    | Add (_, _, m2) -&gt; find k m2</span>
<span id="cb119-29"><a href="#cb119-29" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<h3 id="implementing-maps-binary-search-trees">5.9 Implementing Maps:
Binary Search Trees</h3>
<p>Binary search trees are binary trees with elements stored at the
interior nodes, such that elements to the left of a node are smaller
than, and elements to the right bigger than, elements within a node.</p>
<p>For maps, we store key-value pairs as elements in binary search
trees, and compare the elements by keys alone.</p>
<p>On average, binary search trees are fast because they use
“divide-and-conquer” to search for the value associated with a key
(<span class="math inline">O(\log n)</span> complexity). In the worst
case, however, they reduce to association lists.</p>
<p>The simple polymorphic signature for maps is only possible with
implementations based on some total order of keys because OCaml has
polymorphic comparison (and equality) operators. These operators work on
elements of most types, but not on functions. They may not work in a way
you would want though! Our signature for polymorphic maps is not the
standard approach because of the problem of needing the order of keys;
it is just to keep things simple.</p>
<div class="sourceCode" id="cb120"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> BTreeMap : MAP = <span class="kw">struct</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> (&#39;a, &#39;b) t = Empty | T <span class="kw">of</span> (&#39;a, &#39;b) t * &#39;a * &#39;b * (&#39;a, &#39;b) t</span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> empty = Empty</span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> member k m =                           <span class="co">(* &quot;Divide and conquer&quot; search through the tree. *)</span></span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="kw">false</span></span>
<span id="cb120-9"><a href="#cb120-9" aria-hidden="true" tabindex="-1"></a>    | T (_, k2, _, _) <span class="kw">when</span> k = k2 -&gt; <span class="kw">true</span></span>
<span id="cb120-10"><a href="#cb120-10" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, _, _) <span class="kw">when</span> k &lt; k2 -&gt; member k m1</span>
<span id="cb120-11"><a href="#cb120-11" aria-hidden="true" tabindex="-1"></a>    | T (_, _, _, m2) -&gt; member k m2</span>
<span id="cb120-12"><a href="#cb120-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-13"><a href="#cb120-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> add k v m =                            <span class="co">(* Searches the tree in the same way as member *)</span></span>
<span id="cb120-14"><a href="#cb120-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span>                                 <span class="co">(* but copies every node along the way. *)</span></span>
<span id="cb120-15"><a href="#cb120-15" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; T (Empty, k, v, Empty)</span>
<span id="cb120-16"><a href="#cb120-16" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, _, m2) <span class="kw">when</span> k = k2 -&gt; T (m1, k, v, m2)</span>
<span id="cb120-17"><a href="#cb120-17" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, v2, m2) <span class="kw">when</span> k &lt; k2 -&gt; T (add k v m1, k2, v2, m2)</span>
<span id="cb120-18"><a href="#cb120-18" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, v2, m2) -&gt; T (m1, k2, v2, add k v m2)</span>
<span id="cb120-19"><a href="#cb120-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-20"><a href="#cb120-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> split_rightmost m =                    <span class="co">(* A helper function, it does not belong *)</span></span>
<span id="cb120-21"><a href="#cb120-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span>                                 <span class="co">(* to the &quot;exported&quot; signature. *)</span></span>
<span id="cb120-22"><a href="#cb120-22" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="dt">raise</span> <span class="dt">Not_found</span></span>
<span id="cb120-23"><a href="#cb120-23" aria-hidden="true" tabindex="-1"></a>    | T (Empty, k, v, Empty) -&gt; k, v, Empty      <span class="co">(* We remove one element, *)</span></span>
<span id="cb120-24"><a href="#cb120-24" aria-hidden="true" tabindex="-1"></a>    | T (m1, k, v, m2) -&gt;                        <span class="co">(* the one that is on the bottom right. *)</span></span>
<span id="cb120-25"><a href="#cb120-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> rk, rv, rm = split_rightmost m2 <span class="kw">in</span></span>
<span id="cb120-26"><a href="#cb120-26" aria-hidden="true" tabindex="-1"></a>        rk, rv, T (m1, k, v, rm)</span>
<span id="cb120-27"><a href="#cb120-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-28"><a href="#cb120-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> remove k m =</span>
<span id="cb120-29"><a href="#cb120-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb120-30"><a href="#cb120-30" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; Empty</span>
<span id="cb120-31"><a href="#cb120-31" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, _, Empty) <span class="kw">when</span> k = k2 -&gt; m1</span>
<span id="cb120-32"><a href="#cb120-32" aria-hidden="true" tabindex="-1"></a>    | T (Empty, k2, _, m2) <span class="kw">when</span> k = k2 -&gt; m2</span>
<span id="cb120-33"><a href="#cb120-33" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, _, m2) <span class="kw">when</span> k = k2 -&gt;</span>
<span id="cb120-34"><a href="#cb120-34" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> rk, rv, rm = split_rightmost m1 <span class="kw">in</span></span>
<span id="cb120-35"><a href="#cb120-35" aria-hidden="true" tabindex="-1"></a>        T (rm, rk, rv, m2)</span>
<span id="cb120-36"><a href="#cb120-36" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, v, m2) <span class="kw">when</span> k &lt; k2 -&gt; T (remove k m1, k2, v, m2)</span>
<span id="cb120-37"><a href="#cb120-37" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, v, m2) -&gt; T (m1, k2, v, remove k m2)</span>
<span id="cb120-38"><a href="#cb120-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-39"><a href="#cb120-39" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> find k m =</span>
<span id="cb120-40"><a href="#cb120-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb120-41"><a href="#cb120-41" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="dt">raise</span> <span class="dt">Not_found</span></span>
<span id="cb120-42"><a href="#cb120-42" aria-hidden="true" tabindex="-1"></a>    | T (_, k2, v, _) <span class="kw">when</span> k = k2 -&gt; v</span>
<span id="cb120-43"><a href="#cb120-43" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, _, _) <span class="kw">when</span> k &lt; k2 -&gt; find k m1</span>
<span id="cb120-44"><a href="#cb120-44" aria-hidden="true" tabindex="-1"></a>    | T (_, _, _, m2) -&gt; find k m2</span>
<span id="cb120-45"><a href="#cb120-45" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<h3 id="implementing-maps-red-black-trees">5.10 Implementing Maps:
Red-Black Trees</h3>
<p>This section is based on Wikipedia’s <a
href="http://en.wikipedia.org/wiki/Red-black_tree">Red-black tree
article</a>, Chris Okasaki’s “Purely Functional Data Structures” and
Matt Might’s excellent blog post on <a
href="http://matt.might.net/articles/red-black-delete/">red-black tree
deletion</a>.</p>
<p>Binary search trees are good when we encounter keys in random order,
because the cost of operations is limited by the depth of the tree which
is small relative to the number of nodes… unless the tree grows
unbalanced achieving large depth (which means there are sibling subtrees
of vastly different sizes on some path).</p>
<p>To remedy this, we <em>rebalance</em> the tree while building it –
i.e., while adding elements.</p>
<p>In <em>red-black trees</em> we achieve balance by: 1. Remembering one
of two colors with each node 2. Keeping the same length of each
root-to-leaf path if only black nodes are counted 3. Not allowing a red
node to have a red child</p>
<p>This way the depth is at most twice the depth of a perfectly balanced
tree with the same number of nodes.</p>
<h4 id="b-trees-of-order-4-2-3-4-trees">5.10.1 B-trees of Order 4 (2-3-4
Trees)</h4>
<p>How can we have perfectly balanced trees without worrying about
having <span class="math inline">2^k - 1</span> elements? <strong>2-3-4
trees</strong> can store from 1 to 3 elements in each node and have 2 to
4 subtrees correspondingly. Lots of freedom!</p>
<p>A 2-node contains one element and has two children. A 3-node contains
two elements and has three children. A 4-node contains three elements
and has four children.</p>
<p>To insert “25” into a 2-3-4 tree, we descend right, but if we
encounter a full node (4-node), we move the middle element up and split
the remaining elements. This maintains balance at all times.</p>
<p>To represent a 2-3-4 tree as a binary tree with one element per node,
we color the middle element of a 4-node, or the first element of a
2-/3-node, black and make it the parent of its neighbor elements, and
make them parents of the original subtrees. This correspondence provides
the intuition behind red-black trees.</p>
<h4 id="red-black-trees-without-deletion">5.10.2 Red-Black Trees,
Without Deletion</h4>
<p>Red-black trees maintain two invariants:</p>
<p><strong>Invariant 1.</strong> No red node has a red child.</p>
<p><strong>Invariant 2.</strong> Every path from the root to an empty
node contains the same number of black nodes.</p>
<p>First we implement red-black tree based sets without deletion. The
implementation proceeds almost exactly like for unbalanced binary search
trees; we only need to restore invariants.</p>
<p>By keeping balance at each step of constructing a node, it is enough
to check locally (around the root of the subtree). For an understandable
implementation of deletion, we need to introduce more colors – see Matt
Might’s post.</p>
<div class="sourceCode" id="cb121"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> color = R | B</span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a t = E | T <span class="kw">of</span> color * &#39;a t * &#39;a * &#39;a t</span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> empty = E</span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> member x m =                           <span class="co">(* Like in unbalanced binary search tree. *)</span></span>
<span id="cb121-7"><a href="#cb121-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb121-8"><a href="#cb121-8" aria-hidden="true" tabindex="-1"></a>  | E -&gt; <span class="kw">false</span></span>
<span id="cb121-9"><a href="#cb121-9" aria-hidden="true" tabindex="-1"></a>  | T (_, _, y, _) <span class="kw">when</span> x = y -&gt; <span class="kw">true</span></span>
<span id="cb121-10"><a href="#cb121-10" aria-hidden="true" tabindex="-1"></a>  | T (_, a, y, _) <span class="kw">when</span> x &lt; y -&gt; member x a</span>
<span id="cb121-11"><a href="#cb121-11" aria-hidden="true" tabindex="-1"></a>  | T (_, _, _, b) -&gt; member x b</span>
<span id="cb121-12"><a href="#cb121-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-13"><a href="#cb121-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> balance = <span class="kw">function</span>                         <span class="co">(* Restoring the invariants. *)</span></span>
<span id="cb121-14"><a href="#cb121-14" aria-hidden="true" tabindex="-1"></a>  | B, T (R, T (R,a,x,b), y, c), z, d          <span class="co">(* On next figure: left, *)</span></span>
<span id="cb121-15"><a href="#cb121-15" aria-hidden="true" tabindex="-1"></a>  | B, T (R, a, x, T (R,b,y,c)), z, d          <span class="co">(* top, *)</span></span>
<span id="cb121-16"><a href="#cb121-16" aria-hidden="true" tabindex="-1"></a>  | B, a, x, T (R, T (R,b,y,c), z, d)          <span class="co">(* bottom, *)</span></span>
<span id="cb121-17"><a href="#cb121-17" aria-hidden="true" tabindex="-1"></a>  | B, a, x, T (R, b, y, T (R,c,z,d))          <span class="co">(* right, *)</span></span>
<span id="cb121-18"><a href="#cb121-18" aria-hidden="true" tabindex="-1"></a>      -&gt; T (R, T (B,a,x,b), y, T (B,c,z,d))    <span class="co">(* center tree. *)</span></span>
<span id="cb121-19"><a href="#cb121-19" aria-hidden="true" tabindex="-1"></a>  | color, a, x, b -&gt; T (color, a, x, b)       <span class="co">(* We allow red-red violation for now. *)</span></span>
<span id="cb121-20"><a href="#cb121-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-21"><a href="#cb121-21" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> insert x s =</span>
<span id="cb121-22"><a href="#cb121-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> ins = <span class="kw">function</span>                       <span class="co">(* Like in unbalanced binary search tree, *)</span></span>
<span id="cb121-23"><a href="#cb121-23" aria-hidden="true" tabindex="-1"></a>    | E -&gt; T (R, E, x, E)                      <span class="co">(* but fix violation above created node. *)</span></span>
<span id="cb121-24"><a href="#cb121-24" aria-hidden="true" tabindex="-1"></a>    | T (color, a, y, b) <span class="kw">as</span> s -&gt;</span>
<span id="cb121-25"><a href="#cb121-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> x &lt; y <span class="kw">then</span> balance (color, ins a, y, b)</span>
<span id="cb121-26"><a href="#cb121-26" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="kw">if</span> x &gt; y <span class="kw">then</span> balance (color, a, y, ins b)</span>
<span id="cb121-27"><a href="#cb121-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> s</span>
<span id="cb121-28"><a href="#cb121-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb121-29"><a href="#cb121-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> ins s <span class="kw">with</span>                             <span class="co">(* We could still have red-red violation at root, *)</span></span>
<span id="cb121-30"><a href="#cb121-30" aria-hidden="true" tabindex="-1"></a>  | T (_, a, y, b) -&gt; T (B, a, y, b)           <span class="co">(* fixed by coloring it black. *)</span></span>
<span id="cb121-31"><a href="#cb121-31" aria-hidden="true" tabindex="-1"></a>  | E -&gt; <span class="dt">failwith</span> <span class="st">&quot;insert: impossible&quot;</span></span></code></pre></div>
<p>The <code>balance</code> function handles four cases where a red-red
violation occurs (a red node with a red child). In each case, we
restructure the tree to eliminate the violation while maintaining the
binary search tree property. All four cases produce the same balanced
result: a red root with two black children.</p>
<h3 id="exercises-4">Exercises</h3>
<p><strong>Exercise 1.</strong> Derive the equations and solve them to
find the type for:</p>
<div class="sourceCode" id="cb122"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cadr l = <span class="dt">List</span>.hd (<span class="dt">List</span>.tl l) <span class="kw">in</span> cadr (<span class="dv">1</span>::<span class="dv">2</span>::[]), cadr (<span class="kw">true</span>::<span class="kw">false</span>::[])</span></code></pre></div>
<p>in environment <span class="math inline">\Gamma = \{ \text{List.hd} :
\forall \alpha . \alpha \ \text{list} \rightarrow \alpha ;
\text{List.tl} : \forall \alpha . \alpha \ \text{list} \rightarrow
\alpha \ \text{list} \}</span>. You can take “shortcuts” if it is too
many equations to write down.</p>
<p><strong>Exercise 2.</strong> <em>Terms</em> <span
class="math inline">t_1, t_2, \ldots \in T(\Sigma, X)</span> are built
out of variables <span class="math inline">x, y, \ldots \in X</span> and
function symbols <span class="math inline">f, g, \ldots \in
\Sigma</span> the way you build values out of functions:</p>
<ul>
<li><span class="math inline">X \subset T(\Sigma, X)</span> – variables
are terms; usually an infinite set,</li>
<li>for terms <span class="math inline">t_1, \ldots, t_n \in T(\Sigma,
X)</span> and a function symbol <span class="math inline">f \in
\Sigma_n</span> of arity <span class="math inline">n</span>, <span
class="math inline">f(t_1, \ldots, t_n) \in T(\Sigma, X)</span> – bigger
terms arise from applying function symbols to smaller terms; <span
class="math inline">\Sigma = \dot{\cup}_n \Sigma_n</span> is called a
signature.</li>
</ul>
<p>In OCaml, we can define terms as:
<code>type term = V of string | T of string * term list</code>, where
for example <code>V("x")</code> is a variable <span
class="math inline">x</span> and <code>T("f", [V("x"); V("y")])</code>
is the term <span class="math inline">f(x, y)</span>.</p>
<p>By <em>substitutions</em> <span class="math inline">\sigma, \rho,
\ldots</span> we mean finite sets of variable-term pairs which we can
write as <span class="math inline">\{x_1 \mapsto t_1, \ldots, x_k
\mapsto t_k\}</span> or <span class="math inline">[x_1 := t_1; \ldots;
x_k := t_k]</span>, but also functions from terms to terms <span
class="math inline">\sigma : T(\Sigma, X) \rightarrow T(\Sigma,
X)</span> related to the pairs as follows: if <span
class="math inline">\sigma = \{x_1 \mapsto t_1, \ldots, x_k \mapsto
t_k\}</span>, then</p>
<ul>
<li><span class="math inline">\sigma(x_i) = t_i</span> for <span
class="math inline">x_i \in \{x_1, \ldots, x_k\}</span>,</li>
<li><span class="math inline">\sigma(x) = x</span> for <span
class="math inline">x \in X \setminus \{x_1, \ldots, x_k\}</span>,</li>
<li><span class="math inline">\sigma(f(t_1, \ldots, t_n)) =
f(\sigma(t_1), \ldots, \sigma(t_n))</span>.</li>
</ul>
<p>In OCaml, we can define substitutions <span
class="math inline">\sigma</span> as:
<code>type subst = (string * term) list</code>, together with a function
<code>apply : subst -&gt; term -&gt; term</code> which computes <span
class="math inline">\sigma(\cdot)</span>.</p>
<p>We say that a substitution <span class="math inline">\sigma</span> is
<em>more general</em> than all substitutions <span
class="math inline">\rho \circ \sigma</span>, where <span
class="math inline">(\rho \circ \sigma)(x) = \rho(\sigma(x))</span>. In
type inference, we are interested in most general solutions.</p>
<p>A <em>unification problem</em> is a finite set of equations <span
class="math inline">S = \{s_1 =^? t_1, \ldots, s_n =^? t_n\}</span>. A
solution, or <em>unifier</em> of <span class="math inline">S</span>, is
a substitution <span class="math inline">\sigma</span> such that <span
class="math inline">\sigma(s_i) = \sigma(t_i)</span> for <span
class="math inline">i = 1, \ldots, n</span>. A <em>most general
unifier</em>, or <em>MGU</em>, is a most general such substitution.</p>
<ol type="1">
<li><p>Implement an algorithm that, given a set of equations represented
as a list of pairs of terms, computes an idempotent most general unifier
of the equations.</p></li>
<li><p>(Ex. 4.22 in Franz Baader and Tobias Nipkow “Term Rewriting and
All That”, p. 82.) Modify the implementation of unification to achieve
linear space complexity by working with what could be called iterated
substitutions.</p></li>
</ol>
<p><strong>Exercise 3.</strong></p>
<ol type="1">
<li>What does it mean that an implementation has junk (as an algebraic
structure for a given signature)? Is it bad?</li>
<li>Define a monomorphic algebraic specification (other than, but
similar to, <span class="math inline">\text{nat}_p</span> or <span
class="math inline">\text{string}_p</span>, some useful data type).</li>
<li>Discuss an example of a (monomorphic) algebraic specification where
it would be useful to drop some axioms (giving up monomorphicity) to
allow more efficient implementations.</li>
</ol>
<p><strong>Exercise 4.</strong></p>
<ol type="1">
<li><p>Does the example <code>ListMap</code> meet the requirements of
the algebraic specification for maps? Hint: here is the definition of
<code>List.remove_assoc</code>; <code>compare a x</code> equals
<code>0</code> if and only if <code>a = x</code>.</p>
<div class="sourceCode" id="cb123"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> remove_assoc x = <span class="kw">function</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; []</span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>  | (a, b <span class="kw">as</span> pair) :: l -&gt;</span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> <span class="dt">compare</span> a x = <span class="dv">0</span> <span class="kw">then</span> l <span class="kw">else</span> pair :: remove_assoc x l</span></code></pre></div></li>
<li><p>Trick question: what is the computational complexity of
<code>ListMap</code> or <code>TrivialMap</code>?</p></li>
<li><p>(*) The implementation <code>MyListMap</code> is inefficient: it
performs a lot of copying and is not tail-recursive. Optimize it
(without changing the type definition).</p></li>
<li><p>Add (and specify) <span class="math inline">\text{isEmpty} :
(\alpha, \beta) \ \text{map} \rightarrow \text{bool}</span> to the
example algebraic specification of maps without increasing the burden on
its implementations. Hint: equational reasoning might be not enough;
consider an equivalence relation <span
class="math inline">\approx</span> meaning “have the same
keys”.</p></li>
</ol>
<p><strong>Exercise 5.</strong> Design an algebraic specification and
write a signature for first-in-first-out queues. Provide two
implementations: one straightforward using a list, and another one using
two lists: one for freshly added elements providing efficient queueing
of new elements, and “reversed” one for efficient popping of old
elements.</p>
<p><strong>Exercise 6.</strong> Design an algebraic specification and
write a signature for sets. Provide two implementations: one
straightforward using a list, and another one using a map into the unit
type.</p>
<p><strong>Exercise 7.</strong></p>
<ol type="1">
<li><p>(Ex. 2.2 in Chris Okasaki “Purely Functional Data Structures”) In
the worst case, <code>member</code> performs approximately <span
class="math inline">2d</span> comparisons, where <span
class="math inline">d</span> is the depth of the tree. Rewrite
<code>member</code> to take no more than <span class="math inline">d +
1</span> comparisons by keeping track of a candidate element that
<em>might</em> be equal to the query element (say, the last element for
which <span class="math inline">&lt;</span> returned false) and checking
for equality only when you hit the bottom of the tree.</p></li>
<li><p>(Ex. 3.10 in Chris Okasaki “Purely Functional Data Structures”)
The <code>balance</code> function currently performs several unnecessary
tests: when e.g. <code>ins</code> recurses on the left child, there are
no violations on the right child.</p>
<ul>
<li>Split <code>balance</code> into <code>lbalance</code> and
<code>rbalance</code> that test for violations of left resp. right child
only. Replace calls to <code>balance</code> appropriately.</li>
<li>One of the remaining tests on grandchildren is also unnecessary.
Rewrite <code>ins</code> so that it never tests the color of nodes not
on the search path.</li>
</ul></li>
</ol>
<p><strong>Exercise 8.</strong> (*) Implement maps (i.e. write a module
for the map signature) based on AVL trees. See
<code>http://en.wikipedia.org/wiki/AVL_tree</code>.</p>
</body>
</html>
