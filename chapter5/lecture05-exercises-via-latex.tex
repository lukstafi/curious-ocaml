\documentclass{article}
\usepackage[english]{babel}
\usepackage{geometry,amsmath,amssymb,theorem}
\geometry{letterpaper}

%%%%%%%%%% Start TeXmacs macros
\catcode`\>=\active \def>{
\fontencoding{T1}\selectfont\symbol{62}\fontencoding{\encodingdefault}}
\newcommand{\assign}{:=}
\newcommand{\tmdummy}{$\mbox{}$}
\newcommand{\tmem}[1]{{\em #1\/}}
\newcommand{\tmop}[1]{\ensuremath{\operatorname{#1}}}
\newcommand{\tmverbatim}[1]{\text{{\ttfamily{#1}}}}
{\theorembodyfont{\rmfamily\small}\newtheorem{exercise}{Exercise}}
%%%%%%%%%% End TeXmacs macros

\begin{document}

{\class{Functional Programming}}

{\title{Type Inference

Abstract Data Types}}

\begin{exercise}
  Derive the equations and solve them to find the type for:
  
  {\hlkwa{let }}{\hlstd{cadr l }}{\hlopt{=
  }}{\hlkwc{List}}{\hlopt{.}}{\hlstd{hd
  }}{\hlopt{(}}{\hlkwc{List}}{\hlopt{.}}{\hlstd{tl l}}{\hlopt{) }}{\hlkwa{in
  }}{\hlstd{cadr }}{\hlopt{(}}{\hlnum{1}}{\hlopt{::}}{\hlnum{2}}{\hlopt{::[]),
  }}{\hlstd{cadr
  }}{\hlopt{(}}{\hlkwa{true}}{\hlopt{::}}{\hlkwa{false}}{\hlopt{::[])}}
  
  in environment $\Gamma = \left\{
  \text{{\hlkwc{List}}{\hlopt{.}}{\hlstd{hd}}} : \forall \alpha . \alpha
  \tmop{list} \rightarrow \alpha ;
  \text{{\hlkwc{List}}{\hlopt{.}}{\hlstd{tl}}} : \forall \alpha . \alpha
  \tmop{list} \rightarrow \alpha \tmop{list} \right\}$. You can take
  ``shortcuts'' if it is too many equations to write down.
\end{exercise}

\begin{exercise}
  {\tmem{Terms}} $t_1, t_2, \ldots \in T (\Sigma, X)$ are built out of
  variables $x, y, \ldots \in X$ and function symbols $f, g, \ldots \in
  \Sigma$ the way you build values out of functions:
  \begin{itemize}
    \item $X \subset T (\Sigma, X)$ -- variables are terms; usually an
    infinite set,
    
    \item for terms $t_1, \ldots, t_n \in T (\Sigma, X)$ and a function symbol
    $f \in \Sigma_n$ of arity $n$, $f (t_1, \ldots, t_n) \in T (\Sigma, X)$ --
    bigger terms arise from applying function symbols to smaller terms;
    $\Sigma = \dot{\cup}_n \Sigma_n$ is called a signature.
  \end{itemize}
  In OCaml, we can define terms as: {\hlkwa{type }}{\hlstd{term }}{\hlopt{=
  }}{\hlkwd{V }}{\hlkwa{of }}{\hlkwb{string }}{\hlopt{\textbar }}{\hlkwd{T
  }}{\hlkwa{of }}{\hlkwb{string }}{\hlopt{* }}{\hlstd{term
  list}}{\hspace*{\fill}}, where for example
  {\hlkwd{V}}{\hlopt{(}}{\hlstr{"x"}}{\hlopt{)}} is a variable $x$ and
  {\hlkwd{T}}{\hlopt{(}}{\hlstr{"f"}}{\hlopt{,
  [}}{\hlkwd{V}}{\hlopt{(}}{\hlstr{"x"}}{\hlopt{);
  }}{\hlkwd{V}}{\hlopt{(}}{\hlstr{"y"}}{\hlopt{)])}} is the term $f (x, y)$.
  
  By {\tmem{substitutions}} $\sigma, \rho, \ldots$ we mean finite sets of
  variable, term pairs which we can write as $\{ x_1 \mapsto t_1, \ldots, x_k
  \mapsto t_k \}$ or $[x_1 \assign t_1 ; \ldots ; x_k \assign t_k]$, but also
  functions from terms to terms $\sigma : T (\Sigma, X) \rightarrow T (\Sigma,
  X)$ related to the pairs as follows: if $\sigma = \{ x_1 \mapsto t_1,
  \ldots, x_k \mapsto t_k \}$, then
  \begin{itemize}
    \item $\sigma (x_i) = t_i$ for $x_i \in \{ x_1, \ldots, x_k \}$,
    
    \item $\sigma (x) = x$ for $x \in X\backslash \{ x_1, \ldots, x_k \}$,
    
    \item $\sigma (f (t_1, \ldots, t_n)) = f (\sigma (t_1), \ldots, \sigma
    (t_n))$.
  \end{itemize}
  In OCaml, we can define substitutions $\sigma$ as: {\hlkwa{type
  }}{\hlstd{subst }}{\hlopt{= (}}{\hlkwb{string }}{\hlopt{*
  }}{\hlstd{term}}{\hlopt{) }}{\hlstd{list}}, together with a function
  {\hlstd{apply }}{\hlopt{: }}{\hlstd{subst }}{\hlopt{-> }}{\hlstd{term
  }}{\hlopt{-> }}{\hlstd{term}} which computes $\sigma (\cdot)$.
  
  We say that a substitution $\sigma$ is {\tmem{more general}} than all
  substitutions $\rho \circ \sigma$, where $(\rho \circ \sigma) (x) = \rho
  (\sigma (x))$. In type inference, we are interested in most general
  solutions: the less general type judgement
  $\text{{\hlkwc{List}}{\hlopt{.}}{\hlstd{hd}}} : \tmop{int} \tmop{list}
  \rightarrow \tmop{int}$, although valid, is less useful than
  $\text{{\hlkwc{List}}{\hlopt{.}}{\hlstd{hd}}} : \forall \alpha . \alpha
  \tmop{list} \rightarrow \alpha$ because it limits the usage of
  {\hlkwc{List}}{\hlopt{.}}{\hlstd{hd}}.
  
  A {\tmem{unification problem}} is a finite set of equations $S = \{ s_1 =^?
  t_1, \ldots, s_n =^? t_n \}$ which we can also write as $s_1 \dot{=} t_1
  \wedge \ldots \wedge s_n \dot{=} t_n$. A solution, or {\tmem{unifier}} of
  $S$, is a substitution $\sigma$ such that $\sigma (s_i) = \sigma (t_i)$ for
  $i = 1, \ldots, n$. A {\tmem{most general unifier}}, for short {\tmem{MGU}},
  is a most general such substitution.
  
  A substitution is {\tmem{idempotent}} when $\sigma = \sigma \circ \sigma$.
  If $\sigma = \{ x_1 \mapsto t_1, \ldots, x_k \mapsto t_k \}$, then $\sigma$
  is idempotent exactly when no $t_i$ contains any of the variables $\{ x_1,
  \ldots, x_n \}$; i.e. $\{ x_1, \ldots, x_n \} \cap \tmop{Vars} (t_1, \ldots,
  t_n) = \varnothing$.
  \begin{enumerate}
    \item Implement an algorithm that, given a set of equations represented as
    a list of pairs of terms, computes an idempotent most general unifier of
    the equations.
    
    \item * (Ex. 4.22 in {\tmem{Franz Baader and Tobias Nipkov ``Term
    Rewriting and All That''}}, p. 82.) Modify the implementation of
    unification to achieve linear space complexity by working with what could
    be called iterated substitutions. For example, the solution to $\{ x =^? f
    (y), y =^? g (z), z =^? a \}$ should be represented as variable, term
    pairs $(x, f (y)), (y, g (z)), (z, a)$. (Hint: iterated substitutions
    should be unfolded lazily, i.e. only so far that either a non-variable
    term or the end of the instantiation chain is found.)
  \end{enumerate}
\end{exercise}

\begin{exercise}
  {\tmdummy}
  
  \begin{enumerate}
    \item What does it mean that an implementation has junk (as an algebraic
    structure for a given signature)? Is it bad?
    
    \item Define a monomorphic algebraic specification (other than, but
    similar to, $\tmop{nat}_p$ or $\tmop{string}_p$, some useful data type).
    
    \item Discuss an example of a (monomorphic) algebraic specification where
    it would be useful to drop some axioms (giving up monomorphicity) to allow
    more efficient implementations.
  \end{enumerate}
\end{exercise}

\begin{exercise}
  {\tmdummy}
  
  \begin{enumerate}
    \item Does the example {\hlkwc{ListMap}} meet the requirements of the
    algebraic specification for maps? Hint: here is the definition of
    {\hlkwc{List}}{\hlopt{.}}{\hlstd{remove{\textunderscore}assoc}};
    \tmverbatim{compare a x} equals {\hlnum{0}} if and only if
    \tmverbatim{a}{\hlopt{ = }}\tmverbatim{x}.
    
    {\small{{\hlkwa{let rec }}{\hlstd{remove{\textunderscore}assoc x
    }}{\hlopt{= }}{\hlkwa{function}}{\hlendline{}}\\
    {\hlstd{ \ }}{\hlopt{\textbar  [] -> []}}{\hlendline{}}\\
    {\hlstd{ \ }}{\hlopt{\textbar  (}}{\hlstd{a}}{\hlopt{, }}{\hlstd{b
    }}{\hlkwa{as }}{\hlstd{pair}}{\hlopt{) :: }}{\hlstd{l
    }}{\hlopt{->}}{\hlendline{}}\\
    {\hlstd{ \ \ \ \ \ }}{\hlkwa{if }}{\hlstd{compare a x }}{\hlopt{=
    }}{\hlnum{0 }}{\hlkwa{then }}{\hlstd{l }}{\hlkwa{else }}{\hlstd{pair
    }}{\hlopt{:: }}{\hlstd{remove{\textunderscore}assoc x l}}{\hlendline{}}}}
    
    \item Trick question: what is the computational complexity of
    {\hlkwc{ListMap}} or {\hlkwc{TrivialMap}}?
    
    \item * The implementation {\hlkwc{MyListMap}} is inefficient: it performs
    a lot of copying and is not tail-recursive. Optimize it (without changing
    the type definition).
    
    \item Add (and specify) $\tmop{isEmpty} : (\alpha, \beta) \tmop{map}
    \rightarrow \tmop{bool}$ to the example algebraic specification of maps
    without increasing the burden on its implementations (i.e. without
    affecting implementations of other operations). Hint: equational reasoning
    might be not enough; consider an equivalence relation $\approx$ meaning
    ``have the same keys'', defined and used just in the axioms of the
    specification.
  \end{enumerate}
\end{exercise}

\begin{exercise}
  Design an algebraic specification and write a signature for
  first-in-first-out queues. Provide two implementations: one straightforward
  using a list, and another one using two lists: one for freshly added
  elements providing efficient queueing of new elements, and ``reversed'' one
  for efficient popping of old elements.
\end{exercise}

\begin{exercise}
  Design an algebraic specification and write a signature for sets. Provide
  two implementations: one straightforward using a list, and another one using
  a map into the unit type.
  \begin{itemize}
    \item To allow for a more complete specification of sets here, augment the
    maps ADT with generally useful operations that you find necessary or
    convenient for map-based implementation of sets.
  \end{itemize}
\end{exercise}

\begin{exercise}
  {\tmdummy}
  
  \begin{enumerate}
    \item (Ex. 2.2 in {\tmem{Chris Okasaki ``Purely Functional Data
    Structures''}}) In the worst case, \tmverbatim{member} performs
    approximately $2 d$ comparisons, where $d$ is the depth of the tree.
    Rewrite \tmverbatim{member} to take no mare than $d + 1$ comparisons by
    keeping track of a candidate element that {\tmem{might}} be equal to the
    query element (say, the last element for which $<$ returned false) and
    checking for equality only when you hit the bottom of the tree.
    
    \item (Ex. 3.10 in {\tmem{Chris Okasaki ``Purely Functional Data
    Structures''}}) The \tmverbatim{balance} function currently performs
    several unnecessary tests: when e.g. \tmverbatim{ins} recurses on the left
    child, there are no violations on the right child.
    \begin{enumerate}
      \item Split \tmverbatim{balance} into \tmverbatim{lbalance} and
      \tmverbatim{rbalance} that test for violations of left resp. right child
      only. Replace calls to \tmverbatim{balance} appropriately.
      
      \item One of the remaining tests on grandchildren is also unnecessary.
      Rewrite \tmverbatim{ins} so that it never tests the color of nodes not
      on the search path.
    \end{enumerate}
  \end{enumerate}
\end{exercise}

\end{document}
