<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Lukasz Stafiniak" />
  <meta name="author" content="Claude Opus 4.5" />
  <meta name="author" content="GPT-5.2" />
  <title>Curious OCaml</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {  background-color: #f8f8f8; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ef2929; } /* Alert */
    code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #204a87; } /* Attribute */
    code span.bn { color: #0000cf; } /* BaseN */
    code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4e9a06; } /* Char */
    code span.cn { color: #8f5902; } /* Constant */
    code span.co { color: #8f5902; font-style: italic; } /* Comment */
    code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
    code span.dt { color: #204a87; } /* DataType */
    code span.dv { color: #0000cf; } /* DecVal */
    code span.er { color: #a40000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #0000cf; } /* Float */
    code span.fu { color: #204a87; font-weight: bold; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
    code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
    code span.ot { color: #8f5902; } /* Other */
    code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
    code span.sc { color: #ce5c00; font-weight: bold; } /* SpecialChar */
    code span.ss { color: #4e9a06; } /* SpecialString */
    code span.st { color: #4e9a06; } /* String */
    code span.va { color: #000000; } /* Variable */
    code span.vs { color: #4e9a06; } /* VerbatimString */
    code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Curious OCaml</h1>
<p class="author">Lukasz Stafiniak</p>
<p class="author">Claude Opus 4.5</p>
<p class="author">GPT-5.2</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#chapter-1-logic" id="toc-chapter-1-logic">Chapter 1:
Logic</a>
<ul>
<li><a href="#in-the-beginning-there-was-logos"
id="toc-in-the-beginning-there-was-logos">1.1 In the Beginning there was
Logos</a></li>
<li><a href="#rules-for-logical-connectives"
id="toc-rules-for-logical-connectives">1.2 Rules for Logical
Connectives</a>
<ul>
<li><a href="#notation-for-hypothetical-derivations"
id="toc-notation-for-hypothetical-derivations">Notation for Hypothetical
Derivations</a></li>
<li><a href="#reasoning-by-cases" id="toc-reasoning-by-cases">Reasoning
by Cases</a></li>
<li><a href="#reasoning-by-induction"
id="toc-reasoning-by-induction">Reasoning by Induction</a></li>
</ul></li>
<li><a href="#logos-was-programmed-in-ocaml"
id="toc-logos-was-programmed-in-ocaml">1.3 Logos was Programmed in
OCaml</a>
<ul>
<li><a href="#definitions" id="toc-definitions">Definitions</a></li>
<li><a href="#expression-definitions"
id="toc-expression-definitions">Expression Definitions</a></li>
<li><a href="#scoping-rules" id="toc-scoping-rules">Scoping
Rules</a></li>
<li><a href="#operators" id="toc-operators">Operators</a></li>
</ul></li>
<li><a href="#exercises" id="toc-exercises">1.4 Exercises</a></li>
</ul></li>
<li><a href="#chapter-2-algebra" id="toc-chapter-2-algebra">Chapter 2:
Algebra</a>
<ul>
<li><a href="#a-glimpse-at-type-inference"
id="toc-a-glimpse-at-type-inference">2.1 A Glimpse at Type Inference</a>
<ul>
<li><a href="#a-more-complex-example" id="toc-a-more-complex-example">A
More Complex Example</a></li>
<li><a href="#curried-form" id="toc-curried-form">Curried Form</a></li>
</ul></li>
<li><a href="#algebraic-data-types" id="toc-algebraic-data-types">2.2
Algebraic Data Types</a>
<ul>
<li><a href="#variants-without-arguments"
id="toc-variants-without-arguments">Variants Without Arguments</a></li>
<li><a href="#recursive-type-definitions"
id="toc-recursive-type-definitions">Recursive Type Definitions</a></li>
<li><a href="#parametric-type-definitions"
id="toc-parametric-type-definitions">Parametric Type
Definitions</a></li>
</ul></li>
<li><a href="#syntactic-bread-and-sugar"
id="toc-syntactic-bread-and-sugar">2.3 Syntactic Bread and Sugar</a>
<ul>
<li><a href="#constructor-naming"
id="toc-constructor-naming">Constructor Naming</a></li>
<li><a href="#accessing-record-fields"
id="toc-accessing-record-fields">Accessing Record Fields</a></li>
<li><a href="#function-definition-shortcuts"
id="toc-function-definition-shortcuts">Function Definition
Shortcuts</a></li>
</ul></li>
<li><a href="#pattern-matching" id="toc-pattern-matching">2.4 Pattern
Matching</a>
<ul>
<li><a href="#matching-on-records" id="toc-matching-on-records">Matching
on Records</a></li>
<li><a href="#understanding-patterns"
id="toc-understanding-patterns">Understanding Patterns</a></li>
<li><a href="#simple-patterns-and-wildcards"
id="toc-simple-patterns-and-wildcards">Simple Patterns and
Wildcards</a></li>
<li><a href="#pattern-linearity" id="toc-pattern-linearity">Pattern
Linearity</a></li>
<li><a href="#partial-record-patterns"
id="toc-partial-record-patterns">Partial Record Patterns</a></li>
<li><a href="#or-patterns" id="toc-or-patterns">Or-Patterns</a></li>
<li><a href="#named-patterns-with-as"
id="toc-named-patterns-with-as">Named Patterns with
<code>as</code></a></li>
</ul></li>
<li><a href="#interpreting-algebraic-data-types-as-polynomials"
id="toc-interpreting-algebraic-data-types-as-polynomials">2.5
Interpreting Algebraic Data Types as Polynomials</a>
<ul>
<li><a href="#example-date-type" id="toc-example-date-type">Example:
Date Type</a></li>
<li><a href="#example-option-type" id="toc-example-option-type">Example:
Option Type</a></li>
<li><a href="#example-list-type" id="toc-example-list-type">Example:
List Type</a></li>
<li><a href="#example-binary-tree-type"
id="toc-example-binary-tree-type">Example: Binary Tree Type</a></li>
<li><a href="#type-isomorphisms" id="toc-type-isomorphisms">Type
Isomorphisms</a></li>
<li><a href="#my-first-failed-attempt"
id="toc-my-first-failed-attempt">My First (Failed) Attempt</a></li>
<li><a href="#breaking-down-the-problem"
id="toc-breaking-down-the-problem">Breaking Down the Problem</a></li>
<li><a href="#take-home-lessons" id="toc-take-home-lessons">Take-Home
Lessons</a></li>
</ul></li>
<li><a href="#differentiating-algebraic-data-types"
id="toc-differentiating-algebraic-data-types">2.6 Differentiating
Algebraic Data Types</a>
<ul>
<li><a href="#example-differentiating-a-simple-record"
id="toc-example-differentiating-a-simple-record">Example:
Differentiating a Simple Record</a></li>
<li><a href="#example-differentiating-binary-trees"
id="toc-example-differentiating-binary-trees">Example: Differentiating
Binary Trees</a></li>
</ul></li>
<li><a href="#exercises-1" id="toc-exercises-1">2.7 Exercises</a>
<ul>
<li><a href="#exercise-1-designing-valid-data-structures"
id="toc-exercise-1-designing-valid-data-structures">Exercise 1:
Designing Valid Data Structures</a></li>
<li><a href="#exercise-2-labeled-and-optional-arguments"
id="toc-exercise-2-labeled-and-optional-arguments">Exercise 2: Labeled
and Optional Arguments</a></li>
<li><a href="#exercise-3-type-inference-practice"
id="toc-exercise-3-type-inference-practice">Exercise 3: Type Inference
Practice</a></li>
<li><a href="#exercise-4-types-as-exponents"
id="toc-exercise-4-types-as-exponents">Exercise 4: Types as
Exponents</a></li>
<li><a href="#exercise-5-homework-finding-contexts"
id="toc-exercise-5-homework-finding-contexts">Exercise 5 (Homework):
Finding Contexts</a></li>
</ul></li>
</ul></li>
<li><a href="#chapter-3-computation"
id="toc-chapter-3-computation">Chapter 3: Computation</a>
<ul>
<li><a href="#function-composition" id="toc-function-composition">3.1
Function Composition</a>
<ul>
<li><a href="#partial-application" id="toc-partial-application">Partial
Application</a></li>
<li><a href="#power-function" id="toc-power-function">Power
Function</a></li>
<li><a href="#numerical-derivative"
id="toc-numerical-derivative">Numerical Derivative</a></li>
<li><a href="#computing-higher-order-derivatives"
id="toc-computing-higher-order-derivatives">Computing Higher-Order
Derivatives</a></li>
</ul></li>
<li><a href="#evaluation-rules-reduction-semantics"
id="toc-evaluation-rules-reduction-semantics">3.2 Evaluation Rules
(Reduction Semantics)</a>
<ul>
<li><a href="#expressions" id="toc-expressions">Expressions</a></li>
<li><a href="#the-fix-primitive" id="toc-the-fix-primitive">The
<code>fix</code> Primitive</a></li>
<li><a href="#values" id="toc-values">Values</a></li>
<li><a href="#substitution" id="toc-substitution">Substitution</a></li>
<li><a href="#reduction-rules-redexes"
id="toc-reduction-rules-redexes">Reduction Rules (Redexes)</a></li>
<li><a href="#rule-variables" id="toc-rule-variables">Rule
Variables</a></li>
<li><a href="#evaluation-context-rules"
id="toc-evaluation-context-rules">Evaluation Context Rules</a></li>
<li><a href="#the-fix-rule" id="toc-the-fix-rule">The <code>fix</code>
Rule</a></li>
<li><a href="#practice" id="toc-practice">Practice</a></li>
</ul></li>
<li><a href="#symbolic-derivation-example"
id="toc-symbolic-derivation-example">3.3 Symbolic Derivation
Example</a></li>
<li><a href="#tail-calls-and-tail-recursion"
id="toc-tail-calls-and-tail-recursion">3.4 Tail Calls and Tail
Recursion</a>
<ul>
<li><a href="#what-is-a-tail-call" id="toc-what-is-a-tail-call">What is
a Tail Call?</a></li>
<li><a href="#tail-call-optimization"
id="toc-tail-call-optimization">Tail Call Optimization</a></li>
<li><a href="#tail-recursive-functions"
id="toc-tail-recursive-functions">Tail Recursive Functions</a></li>
<li><a href="#example-counting" id="toc-example-counting">Example:
Counting</a></li>
<li><a href="#example-building-lists"
id="toc-example-building-lists">Example: Building Lists</a></li>
<li><a href="#a-challenge-tree-depth" id="toc-a-challenge-tree-depth">A
Challenge: Tree Depth</a></li>
<li><a href="#note-on-lazy-languages"
id="toc-note-on-lazy-languages">Note on Lazy Languages</a></li>
</ul></li>
<li><a href="#first-encounter-of-continuation-passing-style"
id="toc-first-encounter-of-continuation-passing-style">3.5 First
Encounter of Continuation Passing Style</a></li>
<li><a href="#exercises-2" id="toc-exercises-2">3.6 Exercises</a></li>
</ul></li>
<li><a href="#chapter-4-functions" id="toc-chapter-4-functions">Chapter
4: Functions</a>
<ul>
<li><a href="#review-computation-by-hand"
id="toc-review-computation-by-hand">4.1 Review: Computation by
Hand</a></li>
<li><a href="#language-and-rules-of-the-untyped-lambda-calculus"
id="toc-language-and-rules-of-the-untyped-lambda-calculus">4.2 Language
and Rules of the Untyped Lambda-Calculus</a></li>
<li><a href="#booleans" id="toc-booleans">4.3 Booleans</a></li>
<li><a href="#if-then-else-and-pairs"
id="toc-if-then-else-and-pairs">4.4 If-then-else and Pairs</a>
<ul>
<li><a href="#pairs" id="toc-pairs">Pairs</a></li>
</ul></li>
<li><a href="#pair-encoded-natural-numbers"
id="toc-pair-encoded-natural-numbers">4.5 Pair-Encoded Natural
Numbers</a></li>
<li><a href="#church-numerals" id="toc-church-numerals">4.6 Church
Numerals</a>
<ul>
<li><a href="#tracing-cn_prev-cn3" id="toc-tracing-cn_prev-cn3">Tracing
<code>cn_prev cn3</code></a></li>
</ul></li>
<li><a href="#recursion-fixpoint-combinators"
id="toc-recursion-fixpoint-combinators">4.7 Recursion: Fixpoint
Combinators</a>
<ul>
<li><a href="#turings-fixpoint-combinator"
id="toc-turings-fixpoint-combinator">Turing’s Fixpoint
Combinator</a></li>
<li><a href="#currys-fixpoint-combinator-y-combinator"
id="toc-currys-fixpoint-combinator-y-combinator">Curry’s Fixpoint
Combinator (Y Combinator)</a></li>
<li><a href="#call-by-value-fixpoint-combinator"
id="toc-call-by-value-fixpoint-combinator">Call-by-Value Fixpoint
Combinator</a></li>
<li><a href="#the-problem-with-the-first-two-combinators"
id="toc-the-problem-with-the-first-two-combinators">The Problem with the
First Two Combinators</a></li>
<li><a href="#call-by-value-fixpoint-combinator-in-action"
id="toc-call-by-value-fixpoint-combinator-in-action">Call-by-Value
Fixpoint Combinator in Action</a></li>
<li><a href="#why-fixpoint" id="toc-why-fixpoint">Why
“Fixpoint”?</a></li>
<li><a href="#deriving-factorial" id="toc-deriving-factorial">Deriving
Factorial</a></li>
</ul></li>
<li><a href="#encoding-lists-and-trees"
id="toc-encoding-lists-and-trees">4.8 Encoding Lists and Trees</a>
<ul>
<li><a href="#the-general-pattern" id="toc-the-general-pattern">The
General Pattern</a></li>
</ul></li>
<li><a href="#looping-recursion" id="toc-looping-recursion">4.9 Looping
Recursion</a></li>
<li><a href="#exercises-3" id="toc-exercises-3">4.10 Exercises</a></li>
</ul></li>
<li><a href="#chapter-5-polymorphism-and-abstract-data-types"
id="toc-chapter-5-polymorphism-and-abstract-data-types">Chapter 5:
Polymorphism and Abstract Data Types</a>
<ul>
<li><a href="#type-inference" id="toc-type-inference">5.1 Type
Inference</a>
<ul>
<li><a href="#variables-unknowns-and-parameters"
id="toc-variables-unknowns-and-parameters">Variables: Unknowns and
Parameters</a></li>
<li><a href="#type-environments" id="toc-type-environments">Type
Environments</a></li>
<li><a href="#solving-type-equations"
id="toc-solving-type-equations">Solving Type Equations</a></li>
<li><a href="#polymorphism" id="toc-polymorphism">Polymorphism</a></li>
</ul></li>
<li><a href="#parametric-types" id="toc-parametric-types">5.2 Parametric
Types</a>
<ul>
<li><a href="#multiple-type-parameters"
id="toc-multiple-type-parameters">Multiple Type Parameters</a></li>
<li><a href="#syntax-in-other-languages"
id="toc-syntax-in-other-languages">Syntax in Other Languages</a></li>
</ul></li>
<li><a href="#type-inference-formally"
id="toc-type-inference-formally">5.3 Type Inference, Formally</a>
<ul>
<li><a href="#polymorphic-recursion"
id="toc-polymorphic-recursion">Polymorphic Recursion</a></li>
</ul></li>
<li><a href="#algebraic-specification"
id="toc-algebraic-specification">5.4 Algebraic Specification</a>
<ul>
<li><a href="#algebraic-specifications-examples"
id="toc-algebraic-specifications-examples">Algebraic Specifications:
Examples</a></li>
</ul></li>
<li><a href="#homomorphisms" id="toc-homomorphisms">5.5
Homomorphisms</a></li>
<li><a href="#example-maps" id="toc-example-maps">5.6 Example:
Maps</a></li>
<li><a href="#modules-and-interfaces-signatures-syntax"
id="toc-modules-and-interfaces-signatures-syntax">5.7 Modules and
Interfaces (Signatures): Syntax</a></li>
<li><a href="#implementing-maps-association-lists"
id="toc-implementing-maps-association-lists">5.8 Implementing Maps:
Association Lists</a></li>
<li><a href="#implementing-maps-binary-search-trees"
id="toc-implementing-maps-binary-search-trees">5.9 Implementing Maps:
Binary Search Trees</a></li>
<li><a href="#implementing-maps-red-black-trees"
id="toc-implementing-maps-red-black-trees">5.10 Implementing Maps:
Red-Black Trees</a>
<ul>
<li><a href="#b-trees-of-order-4-2-3-4-trees"
id="toc-b-trees-of-order-4-2-3-4-trees">B-trees of Order 4 (2-3-4
Trees)</a></li>
<li><a href="#red-black-trees-without-deletion"
id="toc-red-black-trees-without-deletion">Red-Black Trees, Without
Deletion</a></li>
</ul></li>
<li><a href="#exercises-4" id="toc-exercises-4">Exercises</a></li>
</ul></li>
<li><a href="#chapter-6-folding-and-backtracking"
id="toc-chapter-6-folding-and-backtracking">Chapter 6: Folding and
Backtracking</a>
<ul>
<li><a href="#basic-generic-list-operations"
id="toc-basic-generic-list-operations">6.1 Basic Generic List
Operations</a>
<ul>
<li><a href="#the-map-function" id="toc-the-map-function">The
<code>map</code> Function</a></li>
<li><a href="#the-fold-function" id="toc-the-fold-function">The
<code>fold</code> Function</a></li>
</ul></li>
<li><a href="#making-fold-tail-recursive"
id="toc-making-fold-tail-recursive">6.2 Making Fold Tail-Recursive</a>
<ul>
<li><a href="#useful-derived-functions"
id="toc-useful-derived-functions">Useful Derived Functions</a></li>
</ul></li>
<li><a href="#map-and-fold-for-trees-and-other-structures"
id="toc-map-and-fold-for-trees-and-other-structures">6.3 Map and Fold
for Trees and Other Structures</a>
<ul>
<li><a href="#binary-trees" id="toc-binary-trees">Binary Trees</a></li>
<li><a href="#more-complex-structures-expressions"
id="toc-more-complex-structures-expressions">More Complex Structures:
Expressions</a></li>
</ul></li>
<li><a href="#point-free-programming"
id="toc-point-free-programming">6.4 Point-Free Programming</a></li>
<li><a href="#reductions-and-more-higher-order-functions"
id="toc-reductions-and-more-higher-order-functions">6.5 Reductions and
More Higher-Order Functions</a>
<ul>
<li><a href="#collecting-results-concat_map"
id="toc-collecting-results-concat_map">Collecting Results:
concat_map</a></li>
<li><a href="#all-subsequences-of-a-list"
id="toc-all-subsequences-of-a-list">All Subsequences of a List</a></li>
<li><a href="#permutations-and-choices"
id="toc-permutations-and-choices">Permutations and Choices</a></li>
</ul></li>
<li><a href="#grouping-and-map-reduce"
id="toc-grouping-and-map-reduce">6.6 Grouping and Map-Reduce</a>
<ul>
<li><a href="#collecting-by-key" id="toc-collecting-by-key">Collecting
by Key</a></li>
<li><a href="#reduction-aggregation"
id="toc-reduction-aggregation">Reduction (Aggregation)</a></li>
<li><a href="#map-reduce-examples"
id="toc-map-reduce-examples">Map-Reduce Examples</a></li>
</ul></li>
<li><a href="#higher-order-functions-for-the-option-type"
id="toc-higher-order-functions-for-the-option-type">6.7 Higher-Order
Functions for the Option Type</a></li>
<li><a href="#the-countdown-problem-puzzle"
id="toc-the-countdown-problem-puzzle">6.8 The Countdown Problem
Puzzle</a>
<ul>
<li><a href="#data-types" id="toc-data-types">Data Types</a></li>
<li><a href="#brute-force-solution" id="toc-brute-force-solution">Brute
Force Solution</a></li>
<li><a href="#optimization-fuse-generation-with-testing"
id="toc-optimization-fuse-generation-with-testing">Optimization: Fuse
Generation with Testing</a></li>
<li><a href="#eliminating-symmetric-cases"
id="toc-eliminating-symmetric-cases">Eliminating Symmetric
Cases</a></li>
</ul></li>
<li><a href="#the-honey-islands-puzzle"
id="toc-the-honey-islands-puzzle">6.9 The Honey Islands Puzzle</a>
<ul>
<li><a href="#representing-the-honeycomb"
id="toc-representing-the-honeycomb">Representing the Honeycomb</a></li>
<li><a href="#drawing-honeycombs" id="toc-drawing-honeycombs">Drawing
Honeycombs</a></li>
<li><a href="#testing-correctness" id="toc-testing-correctness">Testing
Correctness</a></li>
<li><a href="#multiple-results-per-step-concat_fold"
id="toc-multiple-results-per-step-concat_fold">Multiple Results per
Step: concat_fold</a></li>
<li><a href="#generating-solutions"
id="toc-generating-solutions">Generating Solutions</a></li>
<li><a href="#optimizations"
id="toc-optimizations">Optimizations</a></li>
</ul></li>
<li><a href="#constraint-based-puzzles"
id="toc-constraint-based-puzzles">6.10 Constraint-Based Puzzles</a>
<ul>
<li><a href="#finite-domain-constraint-programming"
id="toc-finite-domain-constraint-programming">Finite Domain Constraint
Programming</a></li>
</ul></li>
<li><a href="#exercises-5" id="toc-exercises-5">6.11 Exercises</a></li>
</ul></li>
<li><a href="#chapter-7-laziness" id="toc-chapter-7-laziness">Chapter 7:
Laziness</a>
<ul>
<li><a href="#evaluation-strategies-and-parameter-passing"
id="toc-evaluation-strategies-and-parameter-passing">7.1 Evaluation
Strategies and Parameter Passing</a></li>
<li><a href="#call-by-name-streams" id="toc-call-by-name-streams">7.2
Call-by-name: Streams</a>
<ul>
<li><a href="#stream-operations" id="toc-stream-operations">Stream
Operations</a></li>
<li><a href="#streams-and-input-output"
id="toc-streams-and-input-output">Streams and Input-Output</a></li>
</ul></li>
<li><a href="#lazy-values" id="toc-lazy-values">7.3 Lazy Values</a>
<ul>
<li><a href="#lazy-lists" id="toc-lazy-lists">Lazy Lists</a></li>
<li><a href="#lazy-list-operations" id="toc-lazy-list-operations">Lazy
List Operations</a></li>
</ul></li>
<li><a href="#power-series-and-differential-equations"
id="toc-power-series-and-differential-equations">7.4 Power Series and
Differential Equations</a>
<ul>
<li><a href="#power-series-polynomial-operations"
id="toc-power-series-polynomial-operations">Power Series / Polynomial
Operations</a></li>
<li><a href="#differential-equations"
id="toc-differential-equations">Differential Equations</a></li>
</ul></li>
<li><a href="#arbitrary-precision-computation"
id="toc-arbitrary-precision-computation">7.5 Arbitrary Precision
Computation</a>
<ul>
<li><a href="#example-nuclear-chain-reaction"
id="toc-example-nuclear-chain-reaction">Example: Nuclear Chain
Reaction</a></li>
</ul></li>
<li><a href="#circular-data-structures-double-linked-lists"
id="toc-circular-data-structures-double-linked-lists">7.6 Circular Data
Structures: Double-Linked Lists</a></li>
<li><a href="#input-output-streams" id="toc-input-output-streams">7.7
Input-Output Streams</a></li>
<li><a href="#pipes" id="toc-pipes">7.8 Pipes</a>
<ul>
<li><a href="#pipe-composition" id="toc-pipe-composition">Pipe
Composition</a></li>
</ul></li>
<li><a href="#example-pretty-printing"
id="toc-example-pretty-printing">7.9 Example: Pretty-Printing</a>
<ul>
<li><a href="#straightforward-solution"
id="toc-straightforward-solution">Straightforward Solution</a></li>
<li><a href="#stream-based-solution"
id="toc-stream-based-solution">Stream-Based Solution</a></li>
<li><a href="#factored-solution" id="toc-factored-solution">Factored
Solution</a></li>
</ul></li>
<li><a href="#exercises-6" id="toc-exercises-6">7.10 Exercises</a></li>
</ul></li>
<li><a href="#chapter-8-monads" id="toc-chapter-8-monads">Chapter 8:
Monads</a>
<ul>
<li><a href="#list-comprehensions" id="toc-list-comprehensions">8.1 List
Comprehensions</a>
<ul>
<li><a href="#revisiting-countdown-with-list-comprehensions"
id="toc-revisiting-countdown-with-list-comprehensions">Revisiting
Countdown with List Comprehensions</a></li>
<li><a href="#more-list-comprehension-examples"
id="toc-more-list-comprehension-examples">More List Comprehension
Examples</a></li>
</ul></li>
<li><a href="#generalized-comprehensions-binding-operators"
id="toc-generalized-comprehensions-binding-operators">8.2 Generalized
Comprehensions: Binding Operators</a></li>
<li><a href="#monads" id="toc-monads">8.3 Monads</a>
<ul>
<li><a href="#the-binding-operator-syntax"
id="toc-the-binding-operator-syntax">The Binding Operator
Syntax</a></li>
</ul></li>
<li><a href="#monad-laws" id="toc-monad-laws">8.4 Monad Laws</a></li>
<li><a href="#monoid-laws-and-monad-plus"
id="toc-monoid-laws-and-monad-plus">8.5 Monoid Laws and
Monad-Plus</a></li>
<li><a href="#backtracking-computation-with-choice"
id="toc-backtracking-computation-with-choice">8.6 Backtracking:
Computation with Choice</a></li>
<li><a href="#monad-flavors" id="toc-monad-flavors">8.7 Monad
Flavors</a></li>
<li><a href="#interlude-the-module-system"
id="toc-interlude-the-module-system">8.8 Interlude: The Module
System</a></li>
<li><a href="#the-two-metaphors" id="toc-the-two-metaphors">8.9 The Two
Metaphors</a>
<ul>
<li><a href="#monads-as-containers" id="toc-monads-as-containers">Monads
as Containers</a></li>
<li><a href="#monads-as-computation"
id="toc-monads-as-computation">Monads as Computation</a></li>
</ul></li>
<li><a href="#monad-classes-and-instances"
id="toc-monad-classes-and-instances">8.10 Monad Classes and
Instances</a>
<ul>
<li><a href="#monad-plus-classes" id="toc-monad-plus-classes">Monad-Plus
Classes</a></li>
</ul></li>
<li><a href="#monad-instances" id="toc-monad-instances">8.11 Monad
Instances</a>
<ul>
<li><a href="#the-lazy-monad" id="toc-the-lazy-monad">The Lazy
Monad</a></li>
<li><a href="#the-list-monad" id="toc-the-list-monad">The List
Monad</a></li>
<li><a href="#backtracking-parameterized-by-monad-plus"
id="toc-backtracking-parameterized-by-monad-plus">Backtracking
Parameterized by Monad-Plus</a></li>
<li><a href="#understanding-laziness"
id="toc-understanding-laziness">Understanding Laziness</a></li>
<li><a href="#the-exception-monad" id="toc-the-exception-monad">The
Exception Monad</a></li>
<li><a href="#the-state-monad" id="toc-the-state-monad">The State
Monad</a></li>
</ul></li>
<li><a href="#monad-transformers" id="toc-monad-transformers">8.12 Monad
Transformers</a>
<ul>
<li><a href="#state-transformer-implementation"
id="toc-state-transformer-implementation">State Transformer
Implementation</a></li>
<li><a href="#backtracking-with-state"
id="toc-backtracking-with-state">Backtracking with State</a></li>
</ul></li>
<li><a href="#probabilistic-programming"
id="toc-probabilistic-programming">8.13 Probabilistic Programming</a>
<ul>
<li><a href="#the-probability-monad" id="toc-the-probability-monad">The
Probability Monad</a></li>
<li><a href="#exact-distribution-monad"
id="toc-exact-distribution-monad">Exact Distribution Monad</a></li>
<li><a href="#sampling-monad" id="toc-sampling-monad">Sampling
Monad</a></li>
<li><a href="#example-the-monty-hall-problem"
id="toc-example-the-monty-hall-problem">Example: The Monty Hall
Problem</a></li>
<li><a href="#conditional-probabilities"
id="toc-conditional-probabilities">Conditional Probabilities</a></li>
<li><a href="#burglary-example-encoding-a-bayes-net"
id="toc-burglary-example-encoding-a-bayes-net">Burglary Example:
Encoding a Bayes Net</a></li>
</ul></li>
<li><a href="#lightweight-cooperative-threads"
id="toc-lightweight-cooperative-threads">8.14 Lightweight Cooperative
Threads</a>
<ul>
<li><a href="#fine-grained-vs.-coarse-grained-concurrency"
id="toc-fine-grained-vs.-coarse-grained-concurrency">Fine-Grained
vs. Coarse-Grained Concurrency</a></li>
<li><a href="#thread-monad-signatures"
id="toc-thread-monad-signatures">Thread Monad Signatures</a></li>
<li><a href="#cooperative-thread-implementation"
id="toc-cooperative-thread-implementation">Cooperative Thread
Implementation</a></li>
<li><a href="#testing-the-thread-implementation"
id="toc-testing-the-thread-implementation">Testing the Thread
Implementation</a></li>
</ul></li>
<li><a href="#exercises-7" id="toc-exercises-7">8.15 Exercises</a></li>
</ul></li>
<li><a href="#chapter-9-algebraic-effects"
id="toc-chapter-9-algebraic-effects">Chapter 9: Algebraic Effects</a>
<ul>
<li><a href="#generalized-algebraic-data-types"
id="toc-generalized-algebraic-data-types">9.1 Generalized Algebraic Data
Types</a>
<ul>
<li><a href="#basic-gadt-syntax" id="toc-basic-gadt-syntax">Basic GADT
Syntax</a></li>
<li><a href="#type-refinement-in-pattern-matching"
id="toc-type-refinement-in-pattern-matching">Type Refinement in Pattern
Matching</a></li>
<li><a href="#existential-types-in-gadts"
id="toc-existential-types-in-gadts">Existential Types in GADTs</a></li>
<li><a href="#connection-to-type-inference"
id="toc-connection-to-type-inference">Connection to Type
Inference</a></li>
<li><a href="#gadts-and-effects" id="toc-gadts-and-effects">GADTs and
Effects</a></li>
</ul></li>
<li><a href="#from-monads-to-effects"
id="toc-from-monads-to-effects">9.2 From Monads to Effects</a>
<ul>
<li><a href="#a-first-example" id="toc-a-first-example">A First
Example</a></li>
<li><a href="#declaring-effects" id="toc-declaring-effects">Declaring
Effects</a></li>
<li><a href="#performing-effects" id="toc-performing-effects">Performing
Effects</a></li>
<li><a href="#handling-effects" id="toc-handling-effects">Handling
Effects</a></li>
<li><a href="#deep-vs-shallow-handlers"
id="toc-deep-vs-shallow-handlers">Deep vs Shallow Handlers</a></li>
</ul></li>
<li><a href="#lightweight-threads-with-effects"
id="toc-lightweight-threads-with-effects">9.3 Lightweight Threads with
Effects</a>
<ul>
<li><a href="#the-thread-interface" id="toc-the-thread-interface">The
Thread Interface</a></li>
<li><a href="#declaring-the-effects"
id="toc-declaring-the-effects">Declaring the Effects</a></li>
<li><a href="#the-scheduler" id="toc-the-scheduler">The
Scheduler</a></li>
<li><a href="#testing-the-implementation"
id="toc-testing-the-implementation">Testing the Implementation</a></li>
</ul></li>
<li><a href="#state-with-effects" id="toc-state-with-effects">9.4 State
with Effects</a></li>
<li><a href="#probabilistic-programming-with-effects"
id="toc-probabilistic-programming-with-effects">9.5 Probabilistic
Programming with Effects</a>
<ul>
<li><a href="#the-key-idea" id="toc-the-key-idea">The Key Idea</a></li>
<li><a href="#declaring-probability-effects"
id="toc-declaring-probability-effects">Declaring Probability
Effects</a></li>
<li><a href="#example-monty-hall" id="toc-example-monty-hall">Example:
Monty Hall</a></li>
<li><a href="#example-burglary-network"
id="toc-example-burglary-network">Example: Burglary Network</a></li>
</ul></li>
<li><a href="#rejection-sampling-interpreter"
id="toc-rejection-sampling-interpreter">9.6 Rejection Sampling
Interpreter</a>
<ul>
<li><a href="#limitations-of-rejection-sampling"
id="toc-limitations-of-rejection-sampling">Limitations of Rejection
Sampling</a></li>
</ul></li>
<li><a href="#importance-sampling" id="toc-importance-sampling">9.7
Importance Sampling</a></li>
<li><a href="#soft-conditioning-with-observe"
id="toc-soft-conditioning-with-observe">9.8 Soft Conditioning with
Observe</a></li>
<li><a href="#particle-filter-with-replay"
id="toc-particle-filter-with-replay">9.9 Particle Filter with
Replay</a></li>
<li><a href="#comparing-inference-methods"
id="toc-comparing-inference-methods">9.10 Comparing Inference
Methods</a></li>
<li><a href="#summary" id="toc-summary">9.11 Summary</a></li>
<li><a href="#a-typed-sampling-interface-with-gadts"
id="toc-a-typed-sampling-interface-with-gadts">9.12 A Typed Sampling
Interface with GADTs</a>
<ul>
<li><a href="#a-gadt-typed-sampling-api"
id="toc-a-gadt-typed-sampling-api">A GADT-Typed Sampling API</a></li>
<li><a href="#importance-sampling-for-choose-gaussian"
id="toc-importance-sampling-for-choose-gaussian">Importance Sampling for
Choose + Gaussian</a></li>
<li><a href="#particle-filtering-with-replay-for-choose-gaussian"
id="toc-particle-filtering-with-replay-for-choose-gaussian">Particle
Filtering with Replay for Choose + Gaussian</a></li>
<li><a href="#example-sensor-fusion"
id="toc-example-sensor-fusion">Example: Sensor Fusion</a></li>
<li><a href="#testing-with-monty-hall"
id="toc-testing-with-monty-hall">Testing with Monty Hall</a></li>
</ul></li>
<li><a href="#exercises-8" id="toc-exercises-8">9.13 Exercises</a></li>
</ul></li>
<li><a href="#chapter-10-functional-reactive-programming"
id="toc-chapter-10-functional-reactive-programming">Chapter 10:
Functional Reactive Programming</a>
<ul>
<li><a href="#zippers" id="toc-zippers">10.1 Zippers</a>
<ul>
<li><a href="#revisiting-the-equations"
id="toc-revisiting-the-equations">Revisiting the Equations</a></li>
<li><a href="#moving-around" id="toc-moving-around">Moving
Around</a></li>
<li><a href="#trees-with-arbitrary-branching"
id="toc-trees-with-arbitrary-branching">Trees with Arbitrary
Branching</a></li>
</ul></li>
<li><a href="#example-context-rewriting"
id="toc-example-context-rewriting">10.2 Example: Context
Rewriting</a></li>
<li><a href="#adaptive-programming-incremental-computing"
id="toc-adaptive-programming-incremental-computing">10.3 Adaptive
Programming (Incremental Computing)</a>
<ul>
<li><a href="#a-mental-model-traces-and-change-propagation"
id="toc-a-mental-model-traces-and-change-propagation">A Mental Model:
Traces and Change Propagation</a></li>
<li><a href="#the-core-idea-write-normal-code-get-a-dag"
id="toc-the-core-idea-write-normal-code-get-a-dag">The Core Idea: Write
Normal Code, Get a DAG</a></li>
<li><a href="#a-worked-picture-how-froc-works"
id="toc-a-worked-picture-how-froc-works">A Worked Picture: <em>How
<code>froc</code> Works</em></a></li>
<li><a href="#conditional-dependencies-dynamic-graphs"
id="toc-conditional-dependencies-dynamic-graphs">Conditional
Dependencies (Dynamic Graphs)</a></li>
<li><a href="#two-modern-ocaml-libraries-lwd-and-incremental"
id="toc-two-modern-ocaml-libraries-lwd-and-incremental">Two Modern OCaml
Libraries: <code>lwd</code> and <code>incremental</code></a></li>
<li><a href="#when-incremental-computing-wins-and-when-it-doesnt"
id="toc-when-incremental-computing-wins-and-when-it-doesnt">When
Incremental Computing Wins (and When It Doesn’t)</a></li>
</ul></li>
<li><a href="#functional-reactive-programming"
id="toc-functional-reactive-programming">10.4 Functional Reactive
Programming</a>
<ul>
<li><a
href="#idealized-definitions-and-why-we-dont-implement-them-directly"
id="toc-idealized-definitions-and-why-we-dont-implement-them-directly">Idealized
Definitions (and Why We Don’t Implement Them Directly)</a></li>
<li><a href="#behaviors-as-applicative-static-wiring"
id="toc-behaviors-as-applicative-static-wiring">Behaviors as Applicative
(Static Wiring)</a></li>
<li><a href="#converting-between-events-and-behaviors"
id="toc-converting-between-events-and-behaviors">Converting Between
Events and Behaviors</a></li>
<li><a href="#a-concrete-input-model" id="toc-a-concrete-input-model">A
Concrete Input Model</a></li>
</ul></li>
<li><a href="#reactivity-by-stream-processing"
id="toc-reactivity-by-stream-processing">10.5 Reactivity by Stream
Processing</a>
<ul>
<li><a href="#building-complex-behaviors"
id="toc-building-complex-behaviors">Building Complex Behaviors</a></li>
<li><a href="#the-paddle-game-example"
id="toc-the-paddle-game-example">The Paddle Game Example</a></li>
</ul></li>
<li><a href="#frp-by-incremental-computing-lwd"
id="toc-frp-by-incremental-computing-lwd">10.6 FRP by Incremental
Computing (Lwd)</a>
<ul>
<li><a href="#mapping-frp-concepts-to-lwd"
id="toc-mapping-frp-concepts-to-lwd">Mapping FRP Concepts to
Lwd</a></li>
<li><a href="#events-as-pulses-and-a-caveat"
id="toc-events-as-pulses-and-a-caveat">Events as Pulses (and a
Caveat)</a></li>
<li><a href="#stateful-signal-combinators-one-step-memory"
id="toc-stateful-signal-combinators-one-step-memory">Stateful Signal
Combinators (One-Step Memory)</a></li>
<li><a href="#integration-discrete-time"
id="toc-integration-discrete-time">Integration (Discrete Time)</a></li>
<li><a href="#example-reimplementing-the-paddle-scene-with-lwd"
id="toc-example-reimplementing-the-paddle-scene-with-lwd">Example:
Reimplementing the Paddle Scene with Lwd</a></li>
<li><a href="#stream-frp-vs.-lwd-frp-a-practical-contrast"
id="toc-stream-frp-vs.-lwd-frp-a-practical-contrast">Stream FRP vs. Lwd
FRP (A Practical Contrast)</a></li>
</ul></li>
<li><a href="#direct-control-effects"
id="toc-direct-control-effects">10.7 Direct Control (Effects)</a>
<ul>
<li><a href="#an-effect-interface-await-inputs-render-scenes"
id="toc-an-effect-interface-await-inputs-render-scenes">An Effect
Interface: Await Inputs, Render Scenes</a></li>
<li><a href="#a-driver-step-until-you-need-input"
id="toc-a-driver-step-until-you-need-input">A Driver: “Step Until You
Need Input”</a></li>
<li><a href="#a-handler-replay-a-script-of-inputs-headless"
id="toc-a-handler-replay-a-script-of-inputs-headless">A Handler: Replay
a Script of Inputs (Headless)</a></li>
<li><a href="#example-the-paddle-game-in-direct-style"
id="toc-example-the-paddle-game-in-direct-style">Example: The Paddle
Game in Direct Style</a></li>
<li><a href="#a-bogue-interpreter-for-the-effects"
id="toc-a-bogue-interpreter-for-the-effects">A Bogue Interpreter for the
Effects</a></li>
</ul></li>
<li><a href="#summary-1" id="toc-summary-1">10.8 Summary</a></li>
<li><a href="#exercises-9" id="toc-exercises-9">10.9 Exercises</a></li>
</ul></li>
<li><a href="#chapter-11-the-expression-problem"
id="toc-chapter-11-the-expression-problem">Chapter 11: The Expression
Problem</a>
<ul>
<li><a href="#the-expression-problem-definition"
id="toc-the-expression-problem-definition">11.1 The Expression Problem:
Definition</a>
<ul>
<li><a href="#references" id="toc-references">References</a></li>
</ul></li>
<li><a
href="#functional-programming-non-solution-ordinary-algebraic-datatypes"
id="toc-functional-programming-non-solution-ordinary-algebraic-datatypes">11.2
Functional Programming Non-Solution: Ordinary Algebraic
Datatypes</a></li>
<li><a href="#lightweight-fp-non-solution-extensible-variant-types"
id="toc-lightweight-fp-non-solution-extensible-variant-types">11.3
Lightweight FP Non-Solution: Extensible Variant Types</a></li>
<li><a href="#object-oriented-programming-subtyping"
id="toc-object-oriented-programming-subtyping">11.4 Object-Oriented
Programming: Subtyping</a>
<ul>
<li><a href="#object-oriented-programming-inheritance"
id="toc-object-oriented-programming-inheritance">Object-Oriented
Programming: Inheritance</a></li>
</ul></li>
<li><a href="#direct-object-oriented-non-solution"
id="toc-direct-object-oriented-non-solution">11.5 Direct Object-Oriented
Non-Solution</a></li>
<li><a href="#oop-non-solution-the-visitor-pattern"
id="toc-oop-non-solution-the-visitor-pattern">11.6 OOP Non-Solution: The
Visitor Pattern</a></li>
<li><a href="#polymorphic-variants" id="toc-polymorphic-variants">11.7
Polymorphic Variants</a></li>
<li><a href="#polymorphic-variants-with-recursive-modules"
id="toc-polymorphic-variants-with-recursive-modules">11.8 Polymorphic
Variants with Recursive Modules</a></li>
<li><a href="#parser-combinators" id="toc-parser-combinators">11.9
Parser Combinators</a></li>
<li><a href="#parser-combinators-implementation"
id="toc-parser-combinators-implementation">11.10 Parser Combinators:
Implementation</a>
<ul>
<li><a href="#implementation-of-lazy-monad-plus"
id="toc-implementation-of-lazy-monad-plus">Implementation of
lazy-monad-plus</a></li>
<li><a href="#the-parsec-monad" id="toc-the-parsec-monad">The Parsec
Monad</a></li>
<li><a href="#additional-parser-operations"
id="toc-additional-parser-operations">Additional Parser
Operations</a></li>
</ul></li>
<li><a href="#parser-combinators-tying-the-recursive-knot"
id="toc-parser-combinators-tying-the-recursive-knot">11.11 Parser
Combinators: Tying the Recursive Knot</a></li>
<li><a href="#parser-combinators-dynamic-code-loading"
id="toc-parser-combinators-dynamic-code-loading">11.12 Parser
Combinators: Dynamic Code Loading</a></li>
<li><a href="#parser-combinators-toy-example"
id="toc-parser-combinators-toy-example">11.13 Parser Combinators: Toy
Example</a>
<ul>
<li><a href="#chapter-summary-what-to-remember"
id="toc-chapter-summary-what-to-remember">Chapter Summary (What to
Remember)</a></li>
</ul></li>
<li><a href="#exercises-10" id="toc-exercises-10">11.14
Exercises</a></li>
</ul></li>
</ul>
</nav>
<!-- Do NOT modify this file, it is automatically generated -->
<p>Curious OCaml</p>
<p><em>Curious OCaml</em> invites you to explore programming through the
lens of types, logic, and algebra. OCaml is a language that rewards
curiosity—its type system catches errors before your code runs, its
functional style encourages clear thinking about data transformations,
and its mathematical foundations reveal deep connections between
programming and logic. Whether you’re new to programming, experienced
with OCaml, or a seasoned developer discovering functional programming
for the first time, this book aims to spark that “aha!” moment when
abstract concepts click into place.</p>
<p>This book is intended for three audiences:</p>
<ul>
<li>New to programming: ambitious students in areas with formal rigor –
math, computer science, philosophy, linguistics, etc.</li>
<li>Intermediate: OCaml programmers.</li>
<li>Advanced: programmers who are new to functional programming.</li>
</ul>
<h1 id="chapter-1-logic">Chapter 1: Logic</h1>
<p><em>From logic rules to programming constructs</em></p>
<p><strong>In this chapter, you will:</strong></p>
<ul>
<li>Learn natural-deduction rules for the core connectives (<span
class="math inline">\top, \bot, \wedge, \vee, \rightarrow</span>)</li>
<li>Practice reading and building derivation trees (including
hypothetical derivations)</li>
<li>See the Curry–Howard correspondence emerge in OCaml typing
rules</li>
<li>Connect logical reasoning patterns (cases, induction) to programming
patterns (pattern matching, recursion)</li>
</ul>
<p><strong>Conventions.</strong> OCaml code blocks are intended to be
runnable unless marked with <code>ocaml skip</code> (used for
illustrative or partial snippets).</p>
<p>Throughout this chapter we use <em>natural deduction</em> in the
style of intuitionistic (constructive) logic. This choice is not
accidental: it is exactly the fragment of logic that lines up with the
“pure” core of functional programming via the Curry–Howard
correspondence.</p>
<h2 id="in-the-beginning-there-was-logos">1.1 In the Beginning there was
Logos</h2>
<p>What logical connectives do you know? Before we write any code, let
us take a step back and think about logic itself. The connectives listed
below form the foundation of reasoning, and as we will discover, they
also form the foundation of programming.</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th><span class="math inline">\top</span></th>
<th><span class="math inline">\bot</span></th>
<th><span class="math inline">\wedge</span></th>
<th><span class="math inline">\vee</span></th>
<th><span class="math inline">\rightarrow</span></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td><span class="math inline">a \wedge b</span></td>
<td><span class="math inline">a \vee b</span></td>
<td><span class="math inline">a \rightarrow b</span></td>
</tr>
<tr>
<td>truth</td>
<td>falsehood</td>
<td>conjunction</td>
<td>disjunction</td>
<td>implication</td>
</tr>
<tr>
<td>“trivial”</td>
<td>“impossible”</td>
<td><span class="math inline">a</span> and <span
class="math inline">b</span></td>
<td><span class="math inline">a</span> or <span
class="math inline">b</span></td>
<td><span class="math inline">a</span> gives <span
class="math inline">b</span></td>
</tr>
<tr>
<td></td>
<td>shouldn’t get</td>
<td>got both</td>
<td>got at least one</td>
<td>given <span class="math inline">a</span>, we get <span
class="math inline">b</span></td>
</tr>
</tbody>
</table>
<p>How can we define these connectives precisely? The key insight is to
think in terms of <em>derivation trees</em>. A derivation tree shows how
we arrive at conclusions from premises, building up knowledge step by
step:</p>
<p><span class="math display">
\frac{
\frac{\frac{\,}{\text{a premise}} \; \frac{\,}{\text{another
premise}}}{\text{some fact}} \;
\frac{\frac{\,}{\text{this we have by default}}}{\text{another fact}}}
{\text{final conclusion}}
</span></p>
<p>We define connectives by providing rules for using them. For example,
a rule <span class="math inline">\frac{a \; b}{c}</span> matches parts
of the tree that have two premises, represented by variables <span
class="math inline">a</span> and <span class="math inline">b</span>, and
have any conclusion, represented by variable <span
class="math inline">c</span>. These variables act as placeholders that
can match any proposition.</p>
<p><strong>Design principle:</strong> When defining a connective, we try
to use only that connective in its definition. This keeps definitions
self-contained and avoids circular dependencies between connectives.</p>
<h2 id="rules-for-logical-connectives">1.2 Rules for Logical
Connectives</h2>
<p>Each logical connective comes with two kinds of rules:</p>
<p><strong>Introduction rules</strong> tell us how to <em>produce</em>
or <em>construct</em> a connective. If you want to prove “A and B”, the
introduction rule tells you what you need: proofs of both A and B.</p>
<p><strong>Elimination rules</strong> tell us how to <em>use</em> or
<em>consume</em> a connective. If you already have “A and B”, the
elimination rules tell you what you can get from it: either A or B (your
choice).</p>
<p>In the table below, text in parentheses provides informal commentary.
Letters like <span class="math inline">a</span>, <span
class="math inline">b</span>, and <span class="math inline">c</span> are
variables that can stand for any proposition.</p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 38%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr>
<th>Connective</th>
<th>Introduction Rules</th>
<th>Elimination Rules</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\top</span></td>
<td><span class="math inline">\frac{}{\top}</span></td>
<td>doesn’t have</td>
</tr>
<tr>
<td><span class="math inline">\bot</span></td>
<td>doesn’t have</td>
<td><span class="math inline">\frac{\bot}{a}</span> (i.e.,
anything)</td>
</tr>
<tr>
<td><span class="math inline">\wedge</span></td>
<td><span class="math inline">\frac{a \quad b}{a \wedge b}</span></td>
<td><span class="math inline">\frac{a \wedge b}{a}</span> (take first)  
<span class="math inline">\frac{a \wedge b}{b}</span> (take second)</td>
</tr>
<tr>
<td><span class="math inline">\vee</span></td>
<td><span class="math inline">\frac{a}{a \vee b}</span> (put first)  
<span class="math inline">\frac{b}{a \vee b}</span> (put second)</td>
<td><span class="math inline">\frac{a \vee b \quad
\genfrac{}{}{0pt}{}{[a]^x}{\vdots \; c} \quad
\genfrac{}{}{0pt}{}{[b]^y}{\vdots \; c}}{c}</span> using <span
class="math inline">x, y</span></td>
</tr>
<tr>
<td><span class="math inline">\rightarrow</span></td>
<td><span class="math inline">\frac{\genfrac{}{}{0pt}{}{[a]^x}{\vdots \;
b}}{a \rightarrow b}</span> using <span
class="math inline">x</span></td>
<td><span class="math inline">\frac{a \rightarrow b \quad
a}{b}</span></td>
</tr>
</tbody>
</table>
<h3 id="notation-for-hypothetical-derivations">Notation for Hypothetical
Derivations</h3>
<p>The notation <span
class="math inline">\genfrac{}{}{0pt}{}{[a]^x}{\vdots \; b}</span>
(sometimes written as a tree) matches any subtree that derives <span
class="math inline">b</span> and can use <span
class="math inline">a</span> as an assumption (marked with label <span
class="math inline">x</span>), even though <span
class="math inline">a</span> might not otherwise be warranted. The
square brackets around <span class="math inline">a</span> indicate that
this is a <em>hypothetical</em> assumption, not something we have
actually established. The superscript <span class="math inline">x</span>
is a label that helps us track which assumption gets “discharged” when
we complete the derivation.</p>
<p>This is the key to proving implications: to prove “if A then B”, we
temporarily assume A and show we can derive B. For example, we can
derive “sunny <span class="math inline">\rightarrow</span> happy” by
showing that <em>assuming</em> it is sunny, we can derive happiness:</p>
<p><span class="math display">
\frac{\frac{\frac{\frac{\frac{\,}{\text{sunny}}^x}{\text{go
outdoor}}}{\text{playing}}}{\text{happy}}}{\text{sunny} \rightarrow
\text{happy}} \text{ using } x
</span></p>
<p>Notice how the assumption “sunny” (marked with <span
class="math inline">x</span>) appears at the top of the derivation tree.
We use this assumption to derive “go outdoor”, then “playing”, and
finally “happy”. Once we complete the derivation, the assumption is
<em>discharged</em>: we no longer need to assume it is sunny because we
have established the conditional “sunny <span
class="math inline">\rightarrow</span> happy”.</p>
<p>A crucial point: such assumptions can only be used within the matched
subtree! However, they can be used <em>multiple times</em> within that
subtree. For example, if someone’s mood is more difficult to influence
and requires multiple sunny conditions:</p>
<p><span class="math display">
\frac{\frac{
  \frac{\frac{\frac{\,}{\text{sunny}}^x}{\text{go
outdoor}}}{\text{playing}} \quad
  \frac{\frac{\,}{\text{sunny}}^x \quad
\frac{\frac{\,}{\text{sunny}}^x}{\text{go outdoor}}}{\text{nice view}}
}{\text{happy}}}{\text{sunny} \rightarrow \text{happy}} \text{ using } x
</span></p>
<p>In this more complex derivation, the assumption “sunny” (labeled
<span class="math inline">x</span>) is used three times: once to derive
“go outdoor”, and twice more in deriving “nice view”. All three uses are
valid because they occur within the same hypothetical subtree.</p>
<h3 id="reasoning-by-cases">Reasoning by Cases</h3>
<p>The elimination rule for disjunction deserves special attention
because it represents <strong>reasoning by cases</strong>, one of the
most fundamental proof techniques.</p>
<p>Suppose we know “A or B” is true, but we do not know which one. How
can we still derive a conclusion C? We must show that C follows
<em>regardless</em> of which alternative holds. In other words, we need
to prove: (1) assuming A, we can derive C, and (2) assuming B, we can
derive C. Since one of A or B must be true, and both lead to C, we can
conclude C.</p>
<p>Here is a concrete example: How can we use the fact that it is sunny
<span class="math inline">\vee</span> cloudy (but not rainy)?</p>
<p><span class="math display">
\frac{
  \frac{\,}{\text{sunny} \vee \text{cloudy}}^{\text{forecast}} \quad
  \frac{\frac{\,}{\text{sunny}}^x}{\text{no-umbrella}} \quad
  \frac{\frac{\,}{\text{cloudy}}^y}{\text{no-umbrella}}
}{\text{no-umbrella}} \text{ using } x, y
</span></p>
<p>We know that it will be sunny or cloudy (by watching the weather
forecast). Now we reason by cases: <em>If</em> it will be sunny, we will
not need an umbrella. <em>If</em> it will be cloudy, we will not need an
umbrella. Since one of these must be the case, and both lead to the same
conclusion, we can confidently say: we will not need an umbrella.</p>
<h3 id="reasoning-by-induction">Reasoning by Induction</h3>
<p>We need one more kind of rule to do serious math: <strong>reasoning
by induction</strong>. This rule is somewhat similar to reasoning by
cases, but instead of considering a finite number of alternatives, it
allows us to prove properties that hold for infinitely many cases, such
as all natural numbers.</p>
<p>Here is the example rule for induction on natural numbers:</p>
<p><span class="math display">
\frac{p(0) \quad \genfrac{}{}{0pt}{}{[p(x)]^x}{\vdots \; p(x+1)}}{p(n)}
\text{ by induction, using } x
</span></p>
<p>This rule says: we get property <span class="math inline">p</span>
for <em>any</em> natural number <span class="math inline">n</span>,
provided we can do two things:</p>
<ol type="1">
<li><strong>Base case:</strong> Establish <span
class="math inline">p(0)</span>, that is, prove the property holds for
zero.</li>
<li><strong>Inductive step:</strong> Show that <em>assuming</em> <span
class="math inline">p(x)</span> holds for some arbitrary <span
class="math inline">x</span>, we can derive <span
class="math inline">p(x+1)</span>. This assumption <span
class="math inline">p(x)</span> is called the <em>induction
hypothesis</em>.</li>
</ol>
<p>Here <span class="math inline">x</span> is a unique variable
representing an arbitrary natural number. We cannot substitute a
particular number for it because we write “using <span
class="math inline">x</span>” on the side, indicating that the
derivation works for any choice of <span
class="math inline">x</span>.</p>
<p>The power of induction lies in this: once we have the base case and
the inductive step, we have implicitly covered <em>all</em> natural
numbers. Starting from <span class="math inline">p(0)</span>, we can
derive <span class="math inline">p(1)</span>, then <span
class="math inline">p(2)</span>, then <span
class="math inline">p(3)</span>, and so on, reaching any natural number
<span class="math inline">n</span> we wish.</p>
<h2 id="logos-was-programmed-in-ocaml">1.3 Logos was Programmed in
OCaml</h2>
<p>We now arrive at one of the most remarkable discoveries in the
foundations of computer science: the <strong>Curry–Howard
correspondence</strong>, also known as “propositions as types” or the
“proofs-as-programs” interpretation. In a pure, intuitionistic setting,
this correspondence is not just a metaphor: proof rules and typing rules
are the same kind of object.</p>
<p>Under this correspondence:</p>
<ul>
<li><strong>Propositions</strong> (logical statements) correspond to
<strong>types</strong></li>
<li><strong>Proofs</strong> (derivations showing a proposition is true)
correspond to <strong>programs</strong> (expressions of a given
type)</li>
<li><strong>Introduction rules</strong> correspond to
<strong>constructors</strong> (ways to build values)</li>
<li><strong>Elimination rules</strong> correspond to
<strong>destructors</strong> (ways to use values)</li>
</ul>
<p>When you write a well-typed program, you are (implicitly)
constructing a derivation tree that proves a typing judgement.</p>
<p>The following table shows how each logical connective corresponds to
a programming construct in OCaml:</p>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 16%" />
<col style="width: 33%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr>
<th>Logic</th>
<th>OCaml type (example)</th>
<th>Example program</th>
<th>Intuition</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\top</span></td>
<td><code>unit</code></td>
<td><code>()</code></td>
<td>The trivially true proposition; the type with exactly one value</td>
</tr>
<tr>
<td><span class="math inline">\bot</span></td>
<td><code>void</code> (an empty type)</td>
<td><code>match v with _ -&gt; .</code></td>
<td>Falsehood; a type with no values</td>
</tr>
<tr>
<td><span class="math inline">\wedge</span></td>
<td><code>*</code></td>
<td><code>(,)</code></td>
<td>Conjunction corresponds to pairs: having both A and B</td>
</tr>
<tr>
<td><span class="math inline">\vee</span></td>
<td>a variant type</td>
<td><code>Left x</code> / <code>Right y</code></td>
<td>Disjunction corresponds to sums: having either A or B</td>
</tr>
<tr>
<td><span class="math inline">\rightarrow</span></td>
<td><code>-&gt;</code></td>
<td><code>fun</code></td>
<td>Implication corresponds to functions: given A, produce B</td>
</tr>
<tr>
<td>induction</td>
<td>-</td>
<td><code>let rec</code></td>
<td>Inductive proofs correspond to recursive definitions</td>
</tr>
</tbody>
</table>
<p>For example, the identity function corresponds to the tautology <span
class="math inline">a \rightarrow a</span>:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">fun</span> x -&gt; x;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>- : &#39;a -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
<p>Let us now see the precise typing rules for each OCaml construct,
presented in the same style as our logical rules:</p>
<p><strong>Typing rules for OCaml constructs:</strong></p>
<ul>
<li><p><strong>Unit (truth):</strong> <span
class="math inline">\frac{}{\texttt{()} : \texttt{unit}}</span></p>
<p>The unit value <code>()</code> always has type <code>unit</code>.
This is like <span class="math inline">\top</span> in logic: we can
always produce it without any premises.</p></li>
<li><p><strong>Empty type (falsehood):</strong> in OCaml we can
<em>define</em> an empty type (a type with no constructors):</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> void = |</span></code></pre></div>
<p>There is no way to construct a value of type <code>void</code> using
ordinary, terminating code. But if we somehow have a
<code>v : void</code>, then we can derive anything from it (falsity
elimination):</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> absurd (v : void) : &#39;a =</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> v <span class="kw">with</span> _ -&gt; .</span></code></pre></div>
<p>This corresponds closely to the logical rule <span
class="math inline">\frac{\bot}{a}</span>.</p>
<p>OCaml also has <em>effects</em> (notably exceptions). Because
<code>raise e</code> never returns normally, the type checker allows it
to have any result type: <span class="math display">
\frac{e : \texttt{exn}}{\texttt{raise } e : a}
</span> This is useful in practice, but it is also a good reminder that
effects complicate the neat “proofs-as-programs” story.</p></li>
<li><p><strong>Pair (conjunction):</strong></p>
<ul>
<li>Introduction: <span class="math inline">\frac{s : a \quad t : b}{(s,
t) : a * b}</span></li>
<li>Elimination: from <code>p : a * b</code> we can extract either
component (e.g. by pattern matching, or via
<code>fst</code>/<code>snd</code>)</li>
</ul>
<p>To construct a pair, you need both components. To use a pair, you can
extract either component. This mirrors conjunction perfectly: to prove
“A and B”, you need proofs of both; given “A and B”, you can conclude
either A or B.</p></li>
<li><p><strong>Variant (disjunction):</strong> first, we define a sum
type (a two-way choice):</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (&#39;a, &#39;b) either = Left <span class="kw">of</span> &#39;a | Right <span class="kw">of</span> &#39;b</span></code></pre></div>
<ul>
<li>Introduction: from <code>x : a</code> we get
<code>Left x : (a, b) either</code>, and from <code>y : b</code> we get
<code>Right y : (a, b) either</code></li>
<li>Elimination: given <code>t : (a, b) either</code> and a branch for
each case, produce a result <code>c</code> (pattern matching)</li>
</ul>
<p>The shape of the elimination rule is exactly “reasoning by cases”: to
use an <code>either</code>, you must handle both <code>Left</code> and
<code>Right</code>.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> either f g = <span class="kw">function</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  | Left x -&gt; f x</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  | Right y -&gt; g y</span></code></pre></div>
<p>A built-in example is <code>bool</code>, which you can think of as a
two-constructor variant; the <code>if ... then ... else ...</code>
expression is just a specialized form of case analysis on a boolean.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> choose b x y =</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> b <span class="kw">then</span> x <span class="kw">else</span> y</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> choose&#39; b x y =</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> b <span class="kw">with</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  | <span class="kw">true</span> -&gt; x</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  | <span class="kw">false</span> -&gt; y</span></code></pre></div>
<p>To construct a variant, you only need one of the alternatives. To use
a variant, you must handle <em>all</em> possible cases (pattern
matching). This mirrors disjunction: to prove “A or B”, you only need
one; to use “A or B”, you must consider both possibilities.</p></li>
<li><p><strong>Function (implication):</strong></p>
<ul>
<li>Introduction: <span class="math inline">\frac{\genfrac{}{}{0pt}{}{[x
: a]}{\vdots \; e : b}}{\texttt{fun}~x \to e : a \to b}</span></li>
<li>Elimination (application): <span class="math inline">\frac{f : a \to
b \quad t : a}{f~t : b}</span></li>
</ul>
<p>To construct a function, you assume you have an input of type <span
class="math inline">a</span> (the parameter <span
class="math inline">x</span>) and show how to produce a result of type
<span class="math inline">b</span>. To use a function, you apply it to
an argument. This mirrors implication: to prove “A implies B”, assume A
and derive B; given “A implies B” and A, conclude B.</p></li>
<li><p><strong>Recursion (induction):</strong> recursion is not a
connective, but it matches the <em>shape</em> of induction: in a
recursive definition you are allowed to assume the function being
defined (the “induction hypothesis”) when defining its body.</p>
<p>In OCaml, recursion is introduced with <code>let rec</code> (there is
no standalone <code>rec</code> expression).</p></li>
</ul>
<h3 id="definitions">Definitions</h3>
<p>Writing out expressions and types repetitively quickly becomes
tedious. More importantly, without definitions we cannot give names to
our concepts, making code harder to understand and maintain. This is why
we need definitions.</p>
<p><strong>Type definitions</strong> are written: <code>type ty =</code>
some type.</p>
<ul>
<li><p>In OCaml, disjunction-like types are not written as something
like <code>a | b</code> directly; instead, you define a <em>variant
type</em> and then use its constructors. For example:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> int_string_choice = A <span class="kw">of</span> <span class="dt">int</span> | B <span class="kw">of</span> <span class="dt">string</span></span></code></pre></div>
<p>This allows us to write <code>A x : int_string_choice</code> for any
<code>x : int</code>, and <code>B y : int_string_choice</code> for any
<code>y : string</code>.</p></li>
<li><p>Why do we need to define variant types? The reasons are:
exhaustiveness checks, performance of generated code, and ease of type
inference. When OCaml sees <code>A 5</code>, it needs to figure out (or
“infer”) the type. Without a type definition, how would OCaml know
whether this is <code>A of int | B of string</code> or
<code>A of int | B of float | C of bool</code>? The definition tells
OCaml exactly what variants exist. When you match
<code>| A i -&gt; ...</code>, the compiler will warn you if you forgot
to also cover <code>C b</code> in your match patterns.</p></li>
<li><p>OCaml does provide an alternative: <em>polymorphic variants</em>,
written with a backtick. We can write
<code>`A x : [ `A of a | `B of b ]</code>. With <code>`</code> variants,
OCaml does infer what other variants might exist based on usage. These
types are powerful and flexible; we will discuss them in chapter
11.</p></li>
<li><p>Tuple elements do not need labels because we always know at which
position a tuple element stands: the first element is first, the second
is second, and so on. However, having labels makes code much clearer,
especially when tuples have many components or components of the same
type. For this reason, we can define a <em>record type</em>:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> int_string_record = { a : <span class="dt">int</span>; b : <span class="dt">string</span> }</span></code></pre></div>
<p>and create its values: <code>{a = 7; b = "Mary"}</code>. OCaml 5.4
and newer also support labeled tuples, we will not discuss
these.</p></li>
<li><p>We access the <em>fields</em> of records using the dot notation:
<code>{a = 7; b = "Mary"}.b = "Mary"</code>. Unlike tuples where you
must remember “the second element is the name”, with records you can
write <code>.b</code> to get the field named <code>b</code>.</p></li>
</ul>
<h3 id="expression-definitions">Expression Definitions</h3>
<p>In many presentations of the Curry–Howard correspondence (and in
programming language theory), recursion is introduced via a standalone
operator often called <code>fix</code>. OCaml does not have a standalone
<code>fix</code> expression: recursion is introduced only as part of a
<code>let rec</code> definition.</p>
<p>This brings us to <strong>expression definitions</strong>, which let
us give names to values. The typing rules for definitions are a bit more
complex than what we have seen so far:</p>
<p><span class="math display">
\frac{e_1 : a \quad \genfrac{}{}{0pt}{}{[x : a]}{\vdots \; e_2 :
b}}{\texttt{let } x = e_1 \texttt{ in } e_2 : b}
</span></p>
<p>This rule says: if <span class="math inline">e_1</span> has type
<span class="math inline">a</span>, and assuming <span
class="math inline">x</span> has type <span class="math inline">a</span>
we can show that <span class="math inline">e_2</span> has type <span
class="math inline">b</span>, then the whole <code>let</code> expression
has type <span class="math inline">b</span>. Interestingly, this rule is
equivalent to introducing a function and immediately applying it:
<code>let x = e1 in e2</code> behaves the same as
<code>(fun x -&gt; e2) e1</code>. This equivalence reflects a deep
connection in the Curry–Howard correspondence.</p>
<p>For recursive definitions, we need an additional rule:</p>
<p><span class="math display">
\frac{\genfrac{}{}{0pt}{}{[x : a]}{\vdots \; e_1 : a} \quad
\genfrac{}{}{0pt}{}{[x : a]}{\vdots \; e_2 : b}}{\texttt{let rec } x =
e_1 \texttt{ in } e_2 : b}
</span></p>
<p>Notice the crucial difference: in the recursive case, <span
class="math inline">x</span> can appear in <span
class="math inline">e_1</span> itself! This is what allows functions to
call themselves. The name <span class="math inline">x</span> is visible
both in its own definition (<span class="math inline">e_1</span>) and in
the body that uses the definition (<span
class="math inline">e_2</span>).</p>
<p>These rules are slightly simplified. The full rules involve a concept
called <strong>polymorphism</strong>, which we will cover in a later
chapter. Polymorphism explains how the same function can work with
different types.</p>
<h3 id="scoping-rules">Scoping Rules</h3>
<p>Understanding <em>scope</em>—where names are visible—is essential for
reading and writing OCaml programs.</p>
<ul>
<li><p><strong>Type definitions</strong> we have seen above are
<em>global</em>: they need to be at the top-level (not nested in
expressions), and they extend from the point they occur till the end of
the source file or interactive session. You cannot define a type inside
a function.</p></li>
<li><p><strong><code>let</code>-<code>in</code> definitions</strong> for
expressions: <code>let x = e1 in e2</code> are <em>local</em>—the name
<span class="math inline">x</span> is only visible within <span
class="math inline">e_2</span>. Once you exit the <code>in</code> part,
<span class="math inline">x</span> no longer exists. This is useful for
temporary values that should not pollute the global namespace.</p></li>
<li><p><strong><code>let</code> definitions</strong> without
<code>in</code> are global: placing <code>let x = e1</code> at the
top-level makes <span class="math inline">x</span> visible from after
<span class="math inline">e_1</span> till the end of the source file or
interactive session. This is how you define functions and values that
the rest of your program can use.</p></li>
<li><p>In the interactive session (toplevel/REPL), we mark the end of a
top-level “sentence” with <code>;;</code>. This tells OCaml “I am done
typing, please evaluate this.” In source files compiled by the build
system, <code>;;</code> is unnecessary because the end of each
definition is clear from context.</p></li>
</ul>
<h3 id="operators">Operators</h3>
<p>Operators like <code>+</code>, <code>*</code>, <code>&lt;</code>,
<code>=</code> are simply names of functions. In OCaml, there is nothing
magical about operators; they are ordinary functions that happen to have
special characters in their names and can be used in infix position
(between their arguments).</p>
<p>Just like other names, you can define your own operators:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> (+:) a b = <span class="dt">String</span>.concat <span class="st">&quot;&quot;</span> [a; b];;</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> ( +: ) : <span class="dt">string</span> -&gt; <span class="dt">string</span> -&gt; <span class="dt">string</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a># <span class="st">&quot;Alpha&quot;</span> +: <span class="st">&quot;Beta&quot;</span>;;</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">string</span> = <span class="st">&quot;AlphaBeta&quot;</span></span></code></pre></div>
<p>Notice the asymmetry here: when <em>defining</em> an operator, we
wrap it in parentheses to tell OCaml “this is the name I am defining”.
When <em>using</em> the operator, we write it in the normal infix
position between its arguments. This asymmetry exists because the
definition syntax needs to distinguish between “the name
<code>+:</code>” and “the expression <code>a +: b</code>”.</p>
<p>An important feature of OCaml is that operators are <strong>not
overloaded</strong>. This means that a single operator cannot work for
multiple types. Each type needs its own set of operators: -
<code>+</code>, <code>*</code>, <code>/</code> work for integers -
<code>+.</code>, <code>*.</code>, <code>/.</code> work for floating
point numbers</p>
<p>This design choice makes type inference simpler and more predictable.
When you see <code>x + y</code>, OCaml knows immediately that
<code>x</code> and <code>y</code> must be integers.</p>
<p><strong>Exception:</strong> The comparison operators
<code>&lt;</code>, <code>=</code>, <code>&lt;=</code>,
<code>&gt;=</code>, <code>&lt;&gt;</code> do work for all values other
than functions. These are called <em>polymorphic comparisons</em>.</p>
<h2 id="exercises">1.4 Exercises</h2>
<p>The following exercises are adapted from <em>Think OCaml: How to
Think Like a Computer Scientist</em> by Nicholas Monje and Allen Downey.
They will help you get comfortable with OCaml’s syntax and type
system.</p>
<ol type="1">
<li><p>Assume that we execute the following assignment statements:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> width = <span class="dv">17</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> height = <span class="fl">12.0</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> delimiter = <span class="ch">&#39;.&#39;</span></span></code></pre></div>
<p>For each of the following expressions, write the value of the
expression and the type (of the value of the expression), or the
resulting type error.</p>
<ol type="1">
<li><code>width/2</code></li>
<li><code>width/.2.0</code></li>
<li><code>height/3</code></li>
<li><code>1 + 2 * 5</code></li>
<li><code>delimiter * 5</code></li>
</ol></li>
<li><p>Practice using the OCaml interpreter as a calculator:</p>
<ol type="1">
<li>The volume of a sphere with radius <span
class="math inline">r</span> is <span class="math inline">\frac{4}{3}
\pi r^3</span>. What is the volume of a sphere with radius 5?
(<em>Hint:</em> 392.6 is wrong!)</li>
<li>Suppose the cover price of a book is $24.95, but bookstores get a
40% discount. Shipping costs $3 for the first copy and 75 cents for each
additional copy. What is the total wholesale cost for 60 copies?</li>
<li>If I leave my house at 6:52 am and run 1 mile at an easy pace (8:15
per mile), then 3 miles at tempo (7:12 per mile) and 1 mile at easy pace
again, what time do I get home for breakfast?</li>
</ol></li>
<li><p>You’ve probably heard of the Fibonacci numbers before, but in
case you haven’t, they’re defined by the following recursive
relationship: <span class="math display">
\begin{cases}
f(0) = 0 \\
f(1) = 1 \\
f(n+1) = f(n) + f(n-1) &amp; \text{for } n = 2, 3, \ldots
\end{cases}
</span> Write a recursive function to calculate these numbers.</p></li>
<li><p>A palindrome is a word that is spelled the same backward and
forward, like “noon” and “redivider”. Recursively, a word is a
palindrome if the first and last letters are the same and the middle is
a palindrome.</p>
<p>The following are functions that take a string argument and return
the first, last, and middle letters:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> first_char word = word.[<span class="dv">0</span>]</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> last_char word =</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> len = <span class="dt">String</span>.length word - <span class="dv">1</span> <span class="kw">in</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  word.[len]</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> middle word =</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> len = <span class="dt">String</span>.length word - <span class="dv">2</span> <span class="kw">in</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">String</span>.sub word <span class="dv">1</span> len</span></code></pre></div>
<ol type="1">
<li>Enter these functions into the toplevel and test them out. What
happens if you call <code>middle</code> with a string with two letters?
One letter? What about the empty string <code>""</code>?</li>
<li>Write a function called <code>is_palindrome</code> that takes a
string argument and returns <code>true</code> if it is a palindrome and
<code>false</code> otherwise.</li>
</ol></li>
<li><p>The greatest common divisor (GCD) of <span
class="math inline">a</span> and <span class="math inline">b</span> is
the largest number that divides both of them with no remainder.</p>
<p>One way to find the GCD of two numbers is Euclid’s algorithm, which
is based on the observation that if <span class="math inline">r</span>
is the remainder when <span class="math inline">a</span> is divided by
<span class="math inline">b</span>, then <span
class="math inline">\gcd(a, b) = \gcd(b, r)</span>. As a base case, we
can consider <span class="math inline">\gcd(a, 0) = a</span>.</p>
<p>Write a function called <code>gcd</code> that takes parameters
<code>a</code> and <code>b</code> and returns their greatest common
divisor.</p>
<p>If you need help, see <a
href="http://en.wikipedia.org/wiki/Euclidean_algorithm">http://en.wikipedia.org/wiki/Euclidean_algorithm</a>.</p></li>
</ol>
<h1 id="chapter-2-algebra">Chapter 2: Algebra</h1>
<p><em>Algebraic data types and some curious analogies</em></p>
<p>In this chapter, we will deepen our understanding of OCaml’s type
system by working through type inference examples by hand. Then we will
explore algebraic data types—a cornerstone of functional programming
that allows us to define rich, structured data. Along the way, we will
discover a surprising and beautiful connection between these types and
ordinary polynomials from high-school algebra.</p>
<p><strong>In this chapter, you will:</strong></p>
<ul>
<li>Practice type inference by hand (constraints, unification
intuition)</li>
<li>Define and manipulate algebraic data types (variants, records,
recursion, parameters)</li>
<li>Interpret types as polynomials (and learn what this analogy buys
you)</li>
<li>Differentiate types to compute “one-hole contexts” (derivatives of
data structures)</li>
</ul>
<h2 id="a-glimpse-at-type-inference">2.1 A Glimpse at Type
Inference</h2>
<p>For a refresher, let us apply the type inference rules introduced in
Chapter 1 to some simple examples. We will start with the identity
function <code>fun x -&gt; x</code>—perhaps the simplest possible
function, yet one that reveals important aspects of polymorphism. In the
derivations below, <span class="math inline">[?]</span> means “unknown
(to be inferred)”.</p>
<p>We begin with an incomplete derivation:</p>
<p><span class="math display">
\frac{[?]}{\texttt{fun x -&gt; x} : [?]}
</span></p>
<p>Using the <span class="math inline">\rightarrow</span> introduction
rule, we need to derive the body <code>x</code> assuming <code>x</code>
has some type <span class="math inline">a</span>:</p>
<p><span class="math display">
\frac{\genfrac{}{}{0pt}{}{[x : a]^x}{\vdots \; \texttt{x} :
a}}{\texttt{fun x -&gt; x} : [?] \rightarrow [?]}
</span></p>
<p>The premise is a hypothetical derivation: inside the body we are
allowed to use the assumption <code>x : a</code>. Since the body is just
<code>x</code>, the result type is also <span
class="math inline">a</span>, and we conclude:</p>
<p><span class="math display">
\frac{\genfrac{}{}{0pt}{}{[x : a]^x}{\vdots \; \texttt{x} :
a}}{\texttt{fun x -&gt; x} : a \rightarrow a}
</span></p>
<p>Because <span class="math inline">a</span> is arbitrary (we made no
assumptions constraining it), OCaml introduces a <em>type variable</em>
<code>'a</code> to represent it. This is how polymorphism emerges
naturally from the inference process—the identity function can work with
values of any type:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">fun</span> x -&gt; x;;</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>- : &#39;a -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
<h3 id="a-more-complex-example">A More Complex Example</h3>
<p>Now let us try something that will constrain the types more:
<code>fun x -&gt; x+1</code>. This is the same as
<code>fun x -&gt; ((+) x) 1</code> (try it in OCaml to verify!). The
addition operator forces specific types upon us.</p>
<p>We will use the notation <span class="math inline">[?\alpha]</span>
to mean “type unknown yet, but the same as in other places marked <span
class="math inline">[?\alpha]</span>.” This notation helps us track how
constraints propagate through the derivation.</p>
<p>Starting the derivation and applying <span
class="math inline">\rightarrow</span> introduction:</p>
<p><span class="math display">
\frac{\frac{[?]}{\texttt{((+) x) 1} : [?\alpha]}}{\texttt{fun x -&gt;
((+) x) 1} : [?] \rightarrow [?\alpha]}
</span></p>
<p>Applying <span class="math inline">\rightarrow</span> elimination
(function application) to <code>((+) x) 1</code>:</p>
<p><span class="math display">
\frac{\frac{\frac{[?]}{\texttt{(+) x} : [?\beta] \rightarrow [?\alpha]}
\quad \frac{[?]}{\texttt{1} : [?\beta]}}{\texttt{((+) x) 1} :
[?\alpha]}}{\texttt{fun x -&gt; ((+) x) 1} : [?] \rightarrow [?\alpha]}
</span></p>
<p>We know that <code>1 : int</code>, so <span
class="math inline">[?\beta] = \texttt{int}</span>:</p>
<p><span class="math display">
\frac{\frac{\frac{[?]}{\texttt{(+) x} : \texttt{int} \rightarrow
[?\alpha]} \quad \frac{\,}{\texttt{1} :
\texttt{int}}^{\text{(constant)}}}{\texttt{((+) x) 1} :
[?\alpha]}}{\texttt{fun x -&gt; ((+) x) 1} : [?] \rightarrow [?\alpha]}
</span></p>
<p>Applying function application again to <code>(+) x</code>:</p>
<p><span class="math display">
\frac{\frac{\frac{\frac{[?]}{\texttt{(+)} : [?\gamma] \rightarrow
\texttt{int} \rightarrow [?\alpha]} \quad \frac{[?]}{\texttt{x} :
[?\gamma]}}{\texttt{(+) x} : \texttt{int} \rightarrow [?\alpha]} \quad
\frac{\,}{\texttt{1} : \texttt{int}}^{\text{(constant)}}}{\texttt{((+)
x) 1} : [?\alpha]}}{\texttt{fun x -&gt; ((+) x) 1} : [?\gamma]
\rightarrow [?\alpha]}
</span></p>
<p>Since <code>(+) : int -&gt; int -&gt; int</code>, we have <span
class="math inline">[?\gamma] = \texttt{int}</span> and <span
class="math inline">[?\alpha] = \texttt{int}</span>:</p>
<p><span class="math display">
\frac{\frac{\frac{\frac{\,}{\texttt{(+)} : \texttt{int} \rightarrow
\texttt{int} \rightarrow \texttt{int}}^{\text{(constant)}} \quad
\frac{\,}{\texttt{x} : \texttt{int}}^x}{\texttt{(+) x} : \texttt{int}
\rightarrow \texttt{int}} \quad \frac{\,}{\texttt{1} :
\texttt{int}}^{\text{(constant)}}}{\texttt{((+) x) 1} :
\texttt{int}}}{\texttt{fun x -&gt; ((+) x) 1} : \texttt{int} \rightarrow
\texttt{int}}
</span></p>
<h3 id="curried-form">Curried Form</h3>
<p>When there are several arrows “on the same depth” in a function type,
it means that the function returns a function. For example,
<code>(+) : int -&gt; int -&gt; int</code> is just a shorthand for
<code>(+) : int -&gt; (int -&gt; int)</code>. The arrow associates to
the right, so we can omit the parentheses.</p>
<p>This is very different from:</p>
<p><span class="math display">
\texttt{fun f -&gt; (f 1) + 1} : (\texttt{int} \rightarrow \texttt{int})
\rightarrow \texttt{int}
</span></p>
<p>In the first case, <code>(+)</code> is a function that takes an
integer and returns a function from integers to integers. In the second
case, we have a function that takes a function as an argument—a
<em>higher-order function</em>. The parentheses around
<code>int -&gt; int</code> are essential here; without them, the meaning
would be completely different.</p>
<p>This style of defining multi-argument functions, where each function
takes one argument and returns another function expecting the remaining
arguments, is called <em>curried form</em> (named after logician Haskell
Curry). It enables a powerful technique called <em>partial
application</em>.</p>
<p>For example, instead of writing <code>(fun x -&gt; x+1)</code>, we
can simply write <code>((+) 1)</code>. Here we apply <code>(+)</code> to
just one argument, getting back a function that adds 1 to its input.
What expanded form does <code>((+) 1)</code> correspond to exactly
(computationally)?</p>
<p><em>Think about it before reading on…</em></p>
<p>It corresponds to <code>fun y -&gt; 1 + y</code>. We have “baked in”
the first argument, and the resulting function waits for the second.</p>
<p>We will become more familiar with functions returning functions when
we study the <em>lambda calculus</em> in a later chapter.</p>
<h2 id="algebraic-data-types">2.2 Algebraic Data Types</h2>
<p>In Chapter 1, we learned about the <code>unit</code> type and variant
types like:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> int_string_choice = A <span class="kw">of</span> <span class="dt">int</span> | B <span class="kw">of</span> <span class="dt">string</span></span></code></pre></div>
<p>We also covered tuple types, record types, and type definitions. Now
let us explore these concepts more deeply, building up to the powerful
notion of <em>algebraic data types</em>.</p>
<h3 id="variants-without-arguments">Variants Without Arguments</h3>
<p>Variants do not have to carry arguments. Instead of writing
<code>A of unit</code>, we can simply use <code>A</code>. This is more
convenient and idiomatic:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> color = Red | Green | Blue</span></code></pre></div>
<p>This defines a type with exactly three possible values—no more, no
less. The compiler knows this, which enables exhaustive pattern matching
checks.</p>
<p><strong>A subtle point about OCaml:</strong> In OCaml, variants take
multiple arguments rather than taking tuples as arguments. This means
<code>A of int * string</code> is different from
<code>A of (int * string)</code>. The first takes two separate
arguments, while the second takes a single tuple argument. This
distinction is usually not important—until you get bitten by it in some
corner case! For most purposes, you can ignore it.</p>
<h3 id="recursive-type-definitions">Recursive Type Definitions</h3>
<p>Here is where things get really interesting: type definitions can be
recursive! This allows us to define data structures of arbitrary size
using a finite definition:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> int_list = Empty | Cons <span class="kw">of</span> <span class="dt">int</span> * int_list</span></code></pre></div>
<p>Let us see what values inhabit <code>int_list</code>. The definition
tells us there are two ways to build an <code>int_list</code>: -
<code>Empty</code> represents the empty list—a list with no elements -
<code>Cons (5, Empty)</code> is a list containing just 5 -
<code>Cons (5, Cons (7, Cons (13, Empty)))</code> is a list containing
5, 7, and 13</p>
<p>Notice how <code>Cons</code> takes an integer and another
<code>int_list</code>, allowing us to chain together as many elements as
we like. This recursive structure is the essence of how functional
languages represent unbounded data.</p>
<p>The built-in type <code>bool</code> really does behave like a
two-constructor variant with values <code>true</code> and
<code>false</code>—but note a small OCaml wrinkle: user-defined
constructors must start with a capital letter, while a few built-in
constructors like <code>true</code>, <code>false</code>,
<code>[]</code>, and <code>(::)</code> are special-cased.</p>
<p>Similarly, <code>int</code> can be <em>thought of</em> as a very
large finite variant (“one constructor per integer”), even though the
compiler implements it as an efficient machine integer rather than as a
gigantic sum type.</p>
<h3 id="parametric-type-definitions">Parametric Type Definitions</h3>
<p>Our <code>int_list</code> type only works with integers. But what if
we want a list of strings? Or a list of booleans? We would have to
define separate types for each, duplicating the same structure.</p>
<p>Type definitions can be <em>parametric</em> with respect to the types
of their components. This allows us to define generic data structures
that work with any element type. OCaml already has a built-in parametric
list type, so to avoid shadowing it we will define our own simplified
list type:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a my_list = Empty | Cons <span class="kw">of</span> &#39;a * &#39;a my_list</span></code></pre></div>
<p>The <code>'a</code> is a <em>type parameter</em>—a placeholder that
gets filled in when we use the type. We can have a
<code>string my_list</code>, an <code>int my_list</code>, or even an
<code>(int my_list) my_list</code> (a list of lists of integers).</p>
<p>Several conventions and syntax rules apply to parametric types:</p>
<ul>
<li><p>Type variables must start with <code>'</code>. When printing
inferred types, OCaml may rename these variables, so it is customary to
stick to the standard names <code>'a</code>, <code>'b</code>,
<code>'c</code>, <code>'d</code>, etc.</p></li>
<li><p>The OCaml syntax places the type parameter before the type name,
mimicking English word order. A silly example that reads almost like
English:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;white_color dog = Dog <span class="kw">of</span> &#39;white_color</span></code></pre></div>
<p>This defines a “white-color dog” type—the syntax reads
naturally!</p></li>
<li><p>With multiple parameters, OCaml uses parentheses:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (&#39;a, &#39;b) choice = Left <span class="kw">of</span> &#39;a | Right <span class="kw">of</span> &#39;b</span></code></pre></div>
<p>Compare this to F# syntax:
<code>type choice&lt;'a,'b&gt; = Left of 'a | Right of 'b</code></p>
<p>And Haskell syntax:
<code>data Choice a b = Left a | Right b</code></p>
<p>Different languages have different conventions, but the underlying
concept is the same.</p></li>
</ul>
<h2 id="syntactic-bread-and-sugar">2.3 Syntactic Bread and Sugar</h2>
<p>OCaml provides various syntactic conveniences—sometimes called
<em>syntactic sugar</em>—that make code more pleasant to write and read.
Let us survey the most important ones.</p>
<h3 id="constructor-naming">Constructor Naming</h3>
<p>Names of variants, called <em>constructors</em>, must start with a
capital letter. If we wanted to define our own booleans, we would
write:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> my_bool = True | False</span></code></pre></div>
<p>Only constructors and module names can start with capital letters in
OCaml. Everything else (values, functions, type names) must start with a
lowercase letter. This convention makes it easy to distinguish
constructors at a glance.</p>
<p>(As noted above, a few built-in constructors like <code>true</code>,
<code>false</code>, <code>[]</code>, and <code>(::)</code> are special
exceptions to the capitalization rule.)</p>
<p><em>Modules</em> are organizational units (like “shelves”) containing
related values. For example, the <code>List</code> module provides
operations on lists, including <code>List.map</code> and
<code>List.filter</code>. We will learn more about modules in later
chapters.</p>
<h3 id="accessing-record-fields">Accessing Record Fields</h3>
<p>Did we mention that we can use dot notation to access record fields?
The syntax <code>record.field</code> extracts a field value. For
example, if we have <code>let person = {name="Alice"; age=30}</code>, we
can write <code>person.name</code> to get <code>"Alice"</code>.</p>
<h3 id="function-definition-shortcuts">Function Definition
Shortcuts</h3>
<p>Several syntactic shortcuts make function definitions more concise.
These are worth memorizing, as you will see them constantly in OCaml
code:</p>
<ul>
<li><p><code>fun x y -&gt; e</code> stands for
<code>fun x -&gt; fun y -&gt; e</code>. Note that
<code>fun x -&gt; fun y -&gt; e</code> parses as
<code>fun x -&gt; (fun y -&gt; e)</code>. This shorthand aligns with
curried form—we can write multi-argument functions without nesting
<code>fun</code> expressions.</p></li>
<li><p><code>function A x -&gt; e1 | B y -&gt; e2</code> stands for
<code>fun p -&gt; match p with A x -&gt; e1 | B y -&gt; e2</code>. The
general form is: <code>function PATTERN-MATCHING</code> stands for
<code>fun v -&gt; match v with PATTERN-MATCHING</code>. This is handy
when you want to immediately pattern-match on a function’s
argument.</p></li>
<li><p><code>let f ARGS = e</code> is a shorthand for
<code>let f = fun ARGS -&gt; e</code>. This is probably the most common
way to define functions in practice.</p></li>
</ul>
<h2 id="pattern-matching">2.4 Pattern Matching</h2>
<p>Pattern matching is one of the most powerful features of OCaml and
similar languages. It lets us examine the structure of data and extract
components in a single, elegant construct.</p>
<p>Recall that we introduced <code>fst</code> and <code>snd</code> as
means to access elements of a pair. But what about larger tuples? There
is no built-in <code>thd</code> for the third element. The fundamental
way to access any tuple—or any algebraic data type—uses the
<code>match</code> construct. In fact, <code>fst</code> and
<code>snd</code> can easily be defined using pattern matching:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">fst</span> p = <span class="kw">match</span> p <span class="kw">with</span> (a, b) -&gt; a</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">snd</span> p = <span class="kw">match</span> p <span class="kw">with</span> (a, b) -&gt; b</span></code></pre></div>
<p>The pattern <code>(a, b)</code> <em>destructures</em> the pair,
binding its first component to <code>a</code> and its second to
<code>b</code>. We then return whichever component we want.</p>
<h3 id="matching-on-records">Matching on Records</h3>
<p>Pattern matching also works with records, letting us extract multiple
fields at once:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> person = { name : <span class="dt">string</span>; surname : <span class="dt">string</span>; age : <span class="dt">int</span> }</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> greet_person () =</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> { name = <span class="st">&quot;Walker&quot;</span>; surname = <span class="st">&quot;Johnnie&quot;</span>; age = <span class="dv">207</span> } <span class="kw">with</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  | { name = _; surname = sn; age = _ } -&gt; <span class="st">&quot;Hi &quot;</span> ^ sn ^ <span class="st">&quot;!&quot;</span></span></code></pre></div>
<p>Here we match against a record pattern, binding each field to a
variable. Note that we bind <code>name</code> to <code>n</code>,
<code>surname</code> to <code>sn</code>, and <code>age</code> to
<code>a</code>—then use <code>sn</code> in the greeting.</p>
<h3 id="understanding-patterns">Understanding Patterns</h3>
<p>The left-hand sides of <code>-&gt;</code> in <code>match</code>
expressions are called <strong>patterns</strong>. Patterns describe the
structure of values we want to match against. They can include: -
Constants (like <code>1</code>, <code>"hello"</code>, or
<code>true</code>) - Variables (which bind to the matched value) -
Constructors (like <code>None</code>, <code>Some x</code>, or
<code>Cons (h, t)</code>) - Tuples and records - Nested combinations of
all the above</p>
<p>Patterns can be nested to arbitrary depth, allowing us to match
complex structures in one go:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> <span class="dt">Some</span> (<span class="dv">5</span>, <span class="dv">7</span>) <span class="kw">with</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>| <span class="dt">None</span> -&gt; <span class="st">&quot;sum: nothing&quot;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>| <span class="dt">Some</span> (x, y) -&gt; <span class="st">&quot;sum: &quot;</span> ^ <span class="dt">string_of_int</span> (x + y)</span></code></pre></div>
<p>Here <code>Some (x, y)</code> is a nested pattern: we match
<code>Some</code> of <em>something</em>, and that something must be a
pair, whose components we bind to <code>x</code> and <code>y</code>.</p>
<h3 id="simple-patterns-and-wildcards">Simple Patterns and
Wildcards</h3>
<p>A pattern can simply bind the entire value without destructuring.
Writing <code>match f x with v -&gt; ...</code> is the same as
<code>let v = f x in ...</code>. This is occasionally useful when you
want the syntax of <code>match</code> but do not need to take the value
apart.</p>
<p>When we do not need a value in a pattern, it is good practice to use
the underscore <code>_</code>, which is a <em>wildcard</em>. The
wildcard matches anything but does not bind it to a name. This signals
to the reader (and the compiler) that we are intentionally ignoring that
part:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">fst</span> (a, _) = a</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">snd</span> (_, b) = b</span></code></pre></div>
<p>Using <code>_</code> instead of an unused variable name avoids
compiler warnings about unused bindings.</p>
<h3 id="pattern-linearity">Pattern Linearity</h3>
<p>A variable can only appear once in a pattern. This property is called
<em>linearity</em>. You might think this is a limitation—what if we want
to check that two parts of a structure are equal? We cannot write
<code>(x, x)</code> to match pairs with equal components.</p>
<p>However, we can add conditions to patterns using <code>when</code>,
so linearity is not really a limitation in practice:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> describe_point p =</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> p <span class="kw">with</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  | (x, y) <span class="kw">when</span> x = y -&gt; <span class="st">&quot;diag&quot;</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; <span class="st">&quot;off-diag&quot;</span></span></code></pre></div>
<p>The <code>when</code> clause acts as a guard: the pattern matches
only if both the structure matches <em>and</em> the condition is
true.</p>
<p>Here is a more elaborate example showing how to implement a
comparison function (without shadowing the standard
<code>compare</code>):</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> compare_int a b =</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> a, b <span class="kw">with</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  | (x, y) <span class="kw">when</span> x &lt; y -&gt; <span class="dv">-1</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  | (x, y) <span class="kw">when</span> x = y -&gt; <span class="dv">0</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; <span class="dv">1</span></span></code></pre></div>
<p>Notice how we match against the tuple <code>(a, b)</code> in
different ways, using guards to distinguish the cases.</p>
<h3 id="partial-record-patterns">Partial Record Patterns</h3>
<p>We can skip unused fields of a record in a pattern. Only the fields
we care about need to be mentioned. This keeps patterns concise and
means we do not have to update every pattern when we add a new field to
a record type.</p>
<h3 id="or-patterns">Or-Patterns</h3>
<p>We can compress patterns by using <code>|</code> inside a single
pattern to match multiple alternatives. This is different from having
multiple pattern clauses—it lets us share a single right-hand side for
several patterns:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> month =</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>  | Jan | Feb | Mar | Apr | May | Jun</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  | Jul | Aug | Sep | Oct | Nov | Dec</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> weekday = Mon | Tue | Wed | Thu | Fri | Sat | Sun</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> calendar_date =</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>  { year : <span class="dt">int</span>; month : month; day : <span class="dt">int</span>; weekday : weekday }</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> day =</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>  { year = <span class="dv">2012</span>; month = Feb; day = <span class="dv">14</span>; weekday = Wed }</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> day_kind =</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> day <span class="kw">with</span></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>  | { weekday = Sat | Sun; _ } -&gt; <span class="st">&quot;Weekend!&quot;</span></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; <span class="st">&quot;Work day&quot;</span></span></code></pre></div>
<p>The pattern <code>Sat | Sun</code> matches either <code>Sat</code> or
<code>Sun</code>. This is much cleaner than writing two separate clauses
with the same right-hand side.</p>
<h3 id="named-patterns-with-as">Named Patterns with <code>as</code></h3>
<p>Sometimes we want to both destructure a value <em>and</em> keep a
reference to the whole thing (or some intermediate part). We use
<code>(pattern as v)</code> to name a nested pattern, binding the
matched value to <code>v</code>:</p>
<pre><code>match day with
  | {weekday = (Mon | Tue | Wed | Thu | Fri as wday); _}
      when not (day.month = Dec &amp;&amp; day.day = 24) -&gt;
    Some (work (get_plan wday))
  | _ -&gt; None</code></pre>
<p>This example demonstrates several features working together:</p>
<ul>
<li>An or-pattern matches any weekday from Monday to Friday</li>
<li>The <code>as wday</code> clause binds the matched weekday to the
variable <code>wday</code></li>
<li>A <code>when</code> guard checks that it is not Christmas Eve</li>
<li>The bound variable <code>wday</code> is then used in the expression
<code>get_plan wday</code></li>
</ul>
<p>This combination of features makes OCaml’s pattern matching
remarkably expressive.</p>
<h2 id="interpreting-algebraic-data-types-as-polynomials">2.5
Interpreting Algebraic Data Types as Polynomials</h2>
<p>Now we come to one of the most delightful aspects of algebraic data
types: they really are <em>algebraic</em> in a precise mathematical
sense. Let us explore a curious analogy between types and polynomials
that turns out to be surprisingly deep.</p>
<p>The translation from types to mathematical expressions works as
follows:</p>
<ul>
<li>Replace <code>|</code> (variant choice) with <span
class="math inline">+</span> (addition)</li>
<li>Replace <code>*</code> (tuple product) with <span
class="math inline">\times</span> (multiplication)</li>
<li>Treat record types as tuple types (erasing field names and
translating <code>;</code> as <span
class="math inline">\times</span>)</li>
</ul>
<p>We also need translations for some special types:</p>
<ul>
<li><p>The <strong>void type</strong> (a type with no constructors,
hence no values):</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> void = |</span></code></pre></div>
<p>Since no values can be constructed, it represents emptiness—translate
it as <span class="math inline">0</span>.</p></li>
<li><p>The <strong>unit type</strong> has exactly one value, so
translate it as <span class="math inline">1</span>. Since variants
without arguments behave like variants <code>of unit</code>, translate
them as <span class="math inline">1</span> as well.</p></li>
<li><p>The <strong>bool type</strong> has exactly two values
(<code>true</code> and <code>false</code>), so translate it as <span
class="math inline">2</span>.</p></li>
<li><p>Types like <code>int</code>, <code>string</code>,
<code>float</code>, and type parameters are treated as variables. We do
not care about their exact number of values; we just give them symbolic
names like <span class="math inline">x</span>, <span
class="math inline">y</span>, etc.</p></li>
<li><p>Defined types translate according to their definitions
(substituting variables as necessary).</p></li>
</ul>
<p>Give a name to the type being defined (representing a function of the
introduced variables). Now interpret the result as an ordinary numeric
polynomial! (Or a “rational function” if recursively defined.)</p>
<p>This might seem like a mere curiosity, but it leads to real insights.
Let us have some fun with it!</p>
<h3 id="example-date-type">Example: Date Type</h3>
<div class="sourceCode" id="cb29"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> ymd = { year : <span class="dt">int</span>; month : <span class="dt">int</span>; day : <span class="dt">int</span> }</span></code></pre></div>
<p>A simple “year-month-day” record is a product of three
<code>int</code> fields. Translating to a polynomial (using <span
class="math inline">x</span> for <code>int</code>):</p>
<p><span class="math display">D = x \times x \times x = x^3</span></p>
<p>The cube makes sense: this record is essentially a triple of
integers.</p>
<h3 id="example-option-type">Example: Option Type</h3>
<p>The built-in option type is defined as:</p>
<pre><code>type &#39;a option = None | Some of &#39;a</code></pre>
<p>Translating (using <span class="math inline">x</span> for the type
parameter <code>'a</code>):</p>
<p><span class="math display">O = 1 + x</span></p>
<p>This reads as: an option is either nothing (1) or something of type
<span class="math inline">x</span>. The polynomial <span
class="math inline">1 + x</span> is beautifully simple!</p>
<h3 id="example-list-type">Example: List Type</h3>
<div class="sourceCode" id="cb31"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a my_list = Empty | Cons <span class="kw">of</span> &#39;a * &#39;a my_list</span></code></pre></div>
<p>Translating (where <span class="math inline">L</span> represents the
list type itself, and <span class="math inline">x</span> represents the
element type):</p>
<p><span class="math display">L = 1 + x \cdot L</span></p>
<p>This is a recursive equation! A list is either empty (<span
class="math inline">1</span>) or an element times another list (<span
class="math inline">x \cdot L</span>). If you solve this equation
algebraically, you get <span class="math inline">L = \frac{1}{1-x} = 1 +
x + x^2 + x^3 + \ldots</span>, which corresponds to: a list is either
empty, or has one element, or has two elements, etc.</p>
<h3 id="example-binary-tree-type">Example: Binary Tree Type</h3>
<div class="sourceCode" id="cb32"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree = Tip | Node <span class="kw">of</span> <span class="dt">int</span> * btree * btree</span></code></pre></div>
<p>Translating:</p>
<p><span class="math display">T = 1 + x \cdot T \cdot T = 1 + x \cdot
T^2</span></p>
<p>A binary tree is either a tip (<span class="math inline">1</span>) or
a node containing a value and two subtrees (<span class="math inline">x
\cdot T^2</span>).</p>
<h3 id="type-isomorphisms">Type Isomorphisms</h3>
<p>Here is the remarkable payoff: when translations of two types are
equal according to the laws of high-school algebra, the types are
<em>isomorphic</em>. This means there exist bijective (one-to-one and
onto) functions between them—you can convert from one type to the other
and back without losing any information.</p>
<p>Let us play with the binary tree polynomial and see where algebra
takes us:</p>
<p><span class="math display">
\begin{aligned}
T &amp;= 1 + x \cdot T^2 \\
  &amp;= 1 + x \cdot T + x^2 \cdot T^3 \\
  &amp;= 1 + x + x^2 \cdot T^2 + x^2 \cdot T^3 \\
  &amp;= 1 + x + x^2 \cdot T^2 \cdot (1 + T) \\
  &amp;= 1 + x \cdot (1 + x \cdot T^2 \cdot (1 + T))
\end{aligned}
</span></p>
<p>Each step uses standard algebraic manipulations: substituting <span
class="math inline">T = 1 + xT^2</span>, expanding, factoring, and
rearranging. The result is a different but algebraically equivalent
expression.</p>
<p>Now let us translate this resulting expression back to a type:</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> repr =</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">int</span> * (<span class="dt">int</span> * btree * btree * btree <span class="dt">option</span>) <span class="dt">option</span>) <span class="dt">option</span></span></code></pre></div>
<p>Reading the polynomial <span class="math inline">1 + x \cdot (1 + x
\cdot T^2 \cdot (1 + T))</span> from outside in: we have an option (the
outermost <span class="math inline">1 + \ldots</span>), whose
<code>Some</code> case contains an <code>int</code> times another
option, and so on.</p>
<p>The challenge is to find isomorphism functions with signatures:</p>
<pre><code>val iso1 : btree -&gt; repr
val iso2 : repr -&gt; btree</code></pre>
<p>These functions should satisfy: for all trees <code>t</code>,
<code>iso2 (iso1 t) = t</code>, and for all representations
<code>r</code>, <code>iso1 (iso2 r) = r</code>. Can you write them?</p>
<h3 id="my-first-failed-attempt">My First (Failed) Attempt</h3>
<p>Here is my first attempt, trying to guess the pattern directly:</p>
<pre><code># let iso1 (t : btree) : repr =
  match t with
    | Tip -&gt; None
    | Node (x, Tip, Tip) -&gt; Some (x, None)
    | Node (x, Node (y, t1, t2), Tip) -&gt;
      Some (x, Some (y, t1, t2, None))
    | Node (x, Node (y, t1, t2), t3) -&gt;
      Some (x, Some (y, t1, t2, Some t3));;

Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Node (_, Tip, Node (_, _, _))</code></pre>
<p>I forgot about one case! The case
<code>Node (_, Tip, Node (_, _, _))</code>—a node with an empty left
subtree and non-empty right subtree—was not covered. It seems difficult
to guess the solution directly when trying to map the complex final form
all at once.</p>
<p>Have you found it on your first try? If so, congratulations! Most
people do not. This illustrates an important principle: complex
transformations are easier to get right when broken into smaller
steps.</p>
<h3 id="breaking-down-the-problem">Breaking Down the Problem</h3>
<p>Let us divide the task into smaller steps corresponding to
intermediate points in the polynomial transformation. Instead of jumping
from <span class="math inline">T = 1 + xT^2</span> directly to the final
form, we will introduce intermediate types for each algebraic step:</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (&#39;a, &#39;b) choice = Left <span class="kw">of</span> &#39;a | Right <span class="kw">of</span> &#39;b</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> interm1 =</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>  ((<span class="dt">int</span> * btree, <span class="dt">int</span> * <span class="dt">int</span> * btree * btree * btree) choice)</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">option</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> interm2 =</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>  ((<span class="dt">int</span>, <span class="dt">int</span> * <span class="dt">int</span> * btree * btree * btree <span class="dt">option</span>) choice)</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">option</span></span></code></pre></div>
<p>Now we can define each step:</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> step1r (t : btree) : interm1 =</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> t <span class="kw">with</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    | Tip -&gt; <span class="dt">None</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    | Node (x, t1, Tip) -&gt; <span class="dt">Some</span> (Left (x, t1))</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>    | Node (x, t1, Node (y, t2, t3)) -&gt;</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Some</span> (Right (x, y, t1, t2, t3))</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> step2r (r : interm1) : interm2 =</span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> r <span class="kw">with</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">None</span> -&gt; <span class="dt">None</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (Left (x, Tip)) -&gt; <span class="dt">Some</span> (Left x)</span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (Left (x, Node (y, t1, t2))) -&gt;</span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Some</span> (Right (x, y, t1, t2, <span class="dt">None</span>))</span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (Right (x, y, t1, t2, t3)) -&gt;</span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Some</span> (Right (x, y, t1, t2, <span class="dt">Some</span> t3))</span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> step3r (r : interm2) : repr =</span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> r <span class="kw">with</span></span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">None</span> -&gt; <span class="dt">None</span></span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (Left x) -&gt; <span class="dt">Some</span> (x, <span class="dt">None</span>)</span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (Right (x, y, t1, t2, t3opt)) -&gt;</span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Some</span> (x, <span class="dt">Some</span> (y, t1, t2, t3opt))</span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> iso1 (t : btree) : repr =</span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true" tabindex="-1"></a>  step3r (step2r (step1r t))</span></code></pre></div>
<p>Each step function handles one small transformation, and the compiler
verifies that our pattern matching is exhaustive. No more missed
cases!</p>
<p><strong>Exercise:</strong> Define <code>step1l</code>,
<code>step2l</code>, <code>step3l</code>, and <code>iso2</code>.</p>
<p><em>Hint:</em> Now it is straightforward—each step is simply the
inverse of its corresponding forward step. The left-going functions undo
what the right-going functions do.</p>
<h3 id="take-home-lessons">Take-Home Lessons</h3>
<p>This exploration of type isomorphisms teaches us two valuable
principles:</p>
<ol type="1">
<li><p><strong>Design for validity:</strong> Try to define data
structures so that only meaningful information can be represented—as
long as it does not overcomplicate the data structures. Avoid catch-all
clauses when defining functions. The compiler will then tell you if you
have forgotten about a case. The exhaustiveness checker is your
friend.</p></li>
<li><p><strong>Divide and conquer:</strong> Break solutions into small
steps so that each step can be easily understood and verified. When I
tried to write <code>iso1</code> directly, I made a mistake. When I
broke it into three simple steps, each step was obviously correct, and
composing them gave the right answer.</p></li>
</ol>
<h2 id="differentiating-algebraic-data-types">2.6 Differentiating
Algebraic Data Types</h2>
<p>Of course, you might object that the pompous title is wrong—we will
differentiate the translated polynomials, not the types themselves. Fair
enough! But what sense does differentiating a type’s polynomial
make?</p>
<p>It turns out that taking the partial derivative of a polynomial
(translated from a data type), when translated back, gives a type
representing a “one-hole context”—a data structure with one piece
missing. This missing piece corresponds to the variable with respect to
which we differentiated. The derivative tells us: “Here are all the ways
to point at one element of this type.”</p>
<h3 id="example-differentiating-a-simple-record">Example:
Differentiating a Simple Record</h3>
<p>Let us start with a simple record type:</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> ymd = { year : <span class="dt">int</span>; month : <span class="dt">int</span>; day : <span class="dt">int</span> }</span></code></pre></div>
<p>The translation and its derivative:</p>
<p><span class="math display">
\begin{aligned}
D &amp;= x \cdot x \cdot x = x^3 \\
\frac{\partial D}{\partial x} &amp;= 3x^2 = x \cdot x + x \cdot x + x
\cdot x
\end{aligned}
</span></p>
<p>We could have left it as <span class="math inline">3 \cdot x \cdot
x</span>, but expanding it as a sum shows the structure more clearly.
The derivative <span class="math inline">3x^2</span> says: there are
three ways to “point at” an <code>int</code> in a <code>ymd</code>, and
each way leaves two other <code>int</code>s behind.</p>
<p>Translating the expanded form back to a type:</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> ymd_ctx =</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>  Year <span class="kw">of</span> <span class="dt">int</span> * <span class="dt">int</span> | Month <span class="kw">of</span> <span class="dt">int</span> * <span class="dt">int</span> | Day <span class="kw">of</span> <span class="dt">int</span> * <span class="dt">int</span></span></code></pre></div>
<p>Each variant represents a “hole” at a different position: -
<code>Year (m, d)</code> means the year field is the hole (and we have
the month <code>m</code> and day <code>d</code>) -
<code>Month (y, d)</code> means the month field is the hole (and we have
year <code>y</code> and day <code>d</code>) - <code>Day (y, m)</code>
means the day field is the hole</p>
<p>Now we can define functions to introduce and eliminate this
derivative type:</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ymd_deriv ({ year = y; month = m; day = d } : ymd) =</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>  [ Year (m, d); Month (y, d); Day (y, m) ]</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ymd_integr n = <span class="kw">function</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>  | Year (m, d) -&gt; { year = n; month = m; day = d }</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>  | Month (y, d) -&gt; { year = y; month = n; day = d }</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>  | Day (y, m) -&gt; { year = y; month = m; day = n }</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> example =</span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.map (ymd_integr <span class="dv">7</span>) (ymd_deriv { year = <span class="dv">2012</span>; month = <span class="dv">2</span>; day = <span class="dv">14</span> })</span></code></pre></div>
<p>The <code>ymd_deriv</code> function produces all contexts (one for
each field)—it “differentiates” a record into a list of one-hole
contexts. The <code>ymd_integr</code> function fills in a hole with a
new value—it “integrates” by putting a value back into the context.
Notice how the naming follows the calculus analogy!</p>
<p>The example above takes the date February 14, 2012, produces three
contexts (one for each field), and then fills each hole with the number
7, producing three modified dates.</p>
<h3 id="example-differentiating-binary-trees">Example: Differentiating
Binary Trees</h3>
<p>Now let us tackle the more challenging case of binary trees (using
the same <code>btree</code> type as above):</p>
<pre><code>type btree = Tip | Node of int * btree * btree</code></pre>
<p>The translation and differentiation:</p>
<p><span class="math display">
\begin{aligned}
T &amp;= 1 + x \cdot T^2 \\
\frac{\partial T}{\partial x} &amp;= 0 + T^2 + 2 \cdot x \cdot T \cdot
\frac{\partial T}{\partial x} = T \cdot T + 2 \cdot x \cdot T \cdot
\frac{\partial T}{\partial x}
\end{aligned}
</span></p>
<p>Something interesting happened: the derivative is recursive! It
refers to itself via <span class="math inline">\frac{\partial
T}{\partial x}</span>. This makes perfect sense when you think about
it:</p>
<ul>
<li><span class="math inline">T \cdot T</span> represents pointing at
the root: the hole is at the current node, and we have the two
subtrees.</li>
<li><span class="math inline">2 \cdot x \cdot T \cdot \frac{\partial
T}{\partial x}</span> represents pointing deeper in the tree: we choose
left or right (the factor of 2), remember the current node’s value
(<span class="math inline">x</span>), keep the other subtree (<span
class="math inline">T</span>), and then have a context in the chosen
subtree (<span class="math inline">\frac{\partial T}{\partial
x}</span>).</li>
</ul>
<p>Instead of translating <span class="math inline">2</span> as
<code>bool</code>, we introduce a more descriptive type to make the code
clearer:</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree_dir = LeftBranch | RightBranch</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree_deriv =</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>  | Here <span class="kw">of</span> btree * btree</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>  | Below <span class="kw">of</span> btree_dir * <span class="dt">int</span> * btree * btree_deriv</span></code></pre></div>
<p>The <code>Here</code> constructor means the hole is at the current
position, and we have the left and right subtrees. The
<code>Below</code> constructor means we go down one level, remembering
which direction we went, the value at the node we passed, and the
subtree we did not enter.</p>
<p>(You might someday hear about <em>zippers</em>—they are “inverted”
relative to our type. In a zipper, the hole comes first, and the context
trails behind. Both representations are useful in different
situations.)</p>
<p><strong>Exercise:</strong> Write a function that takes a number and a
<code>btree_deriv</code>, and builds a <code>btree</code> by putting the
number into the “hole” in <code>btree_deriv</code>.</p>
<details>
<summary>
Solution
</summary>
<p>The integration function fills the hole with a value. It must be
recursive because the derivative type is recursive—we may need to
descend through multiple <code>Below</code> constructors before reaching
the <code>Here</code> where the hole actually is:</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> btree_integr n = <span class="kw">function</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>  | Here (ltree, rtree) -&gt; Node (n, ltree, rtree)</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>  | Below (LeftBranch, m, rtree, deriv) -&gt;</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    Node (m, btree_integr n deriv, rtree)</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>  | Below (RightBranch, m, ltree, deriv) -&gt;</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>    Node (m, ltree, btree_integr n deriv)</span></code></pre></div>
<p>When we reach <code>Here</code>, we create a node with the new value
<code>n</code> and the two subtrees. When we see <code>Below</code>, we
reconstruct the node we passed through and recursively integrate into
the appropriate subtree.</p>
</details>
<h2 id="exercises-1">2.7 Exercises</h2>
<h3 id="exercise-1-designing-valid-data-structures">Exercise 1:
Designing Valid Data Structures</h3>
<p><em>Due to Yaron Minsky.</em></p>
<p>This exercise practices the principle of “making invalid states
unrepresentable.” Consider a datatype to store internet connection
information. The time <code>when_initiated</code> marks the start of
connecting and is not needed after the connection is established (it is
only used to decide whether to give up trying to connect). The ping
information is available for established connections but not straight
away.</p>
<pre><code>type connectionstate = Connecting | Connected | Disconnected

type connectioninfo = {
  state : connectionstate;
  server : Inetaddr.t;
  lastpingtime : Time.t option;
  lastpingid : int option;
  sessionid : string option;
  wheninitiated : Time.t option;
  whendisconnected : Time.t option;
}</code></pre>
<p>(The types <code>Time.t</code> and <code>Inetaddr.t</code> come from
the <em>Core</em> library. You can replace them with <code>float</code>
and <code>Unix.inet_addr</code>. Load the Unix library in the
interactive toplevel with <code>#load "unix.cma";;</code>.)</p>
<p>The problem with this design is that it allows many nonsensical
combinations: a <code>Connecting</code> state with ping information, a
<code>Disconnected</code> state with a session ID, etc. The optional
fields (all those <code>option</code> types) make it unclear which
fields are valid in which states.</p>
<p>Rewrite the type definitions so that the datatype will contain only
reasonable combinations of information. Use separate record types for
each connection state, with only the fields that make sense for that
state.</p>
<h3 id="exercise-2-labeled-and-optional-arguments">Exercise 2: Labeled
and Optional Arguments</h3>
<p>In OCaml, functions can have labeled arguments and optional arguments
(parameters with default values that can be omitted). This exercise
explores these features.</p>
<p>Labels can differ from the names of argument values:</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f ~meaningfulname:n = n + <span class="dv">1</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> _ = f ~meaningfulname:<span class="dv">5</span>  <span class="co">(* We do not need the result so we ignore it. *)</span></span></code></pre></div>
<p>When the label and value names are the same, the syntax is
shorter:</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> g ~pos ~len =</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">StringLabels</span>.sub <span class="st">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span> ~pos ~len</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () =  <span class="co">(* A nicer way to mark computations that return unit. *)</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> pos = <span class="dt">Random</span>.<span class="dt">int</span> <span class="dv">26</span> <span class="kw">in</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> len = <span class="dt">Random</span>.<span class="dt">int</span> <span class="dv">10</span> <span class="kw">in</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">print_string</span> (g ~pos ~len)</span></code></pre></div>
<p>When some function arguments are optional, the function must take
non-optional arguments after the last optional argument. Optional
parameters with default values:</p>
<div class="sourceCode" id="cb47"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> h ?(len=<span class="dv">1</span>) pos = g ~pos ~len</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () = <span class="dt">print_string</span> (h <span class="dv">10</span>)</span></code></pre></div>
<p>Optional arguments are implemented as parameters of an option type.
This allows checking whether the argument was provided:</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo ?bar n =</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> bar <span class="kw">with</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">None</span> -&gt; <span class="st">&quot;Argument = &quot;</span> ^ <span class="dt">string_of_int</span> n</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> m -&gt; <span class="st">&quot;Sum = &quot;</span> ^ <span class="dt">string_of_int</span> (m + n)</span></code></pre></div>
<p>We can use it in various ways:</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> _ = foo <span class="dv">5</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> _ = foo ~bar:<span class="dv">5</span> <span class="dv">7</span></span></code></pre></div>
<p>We can also provide the option value directly:</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> test_foo () =</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> bar = <span class="kw">if</span> <span class="dt">Random</span>.<span class="dt">int</span> <span class="dv">10</span> &lt; <span class="dv">5</span> <span class="kw">then</span> <span class="dt">None</span> <span class="kw">else</span> <span class="dt">Some</span> <span class="dv">7</span> <span class="kw">in</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>  foo ?bar <span class="dv">7</span></span></code></pre></div>
<ol type="1">
<li><p>Observe the types that functions with labeled and optional
arguments have. Come up with coding style guidelines for when to use
labeled arguments. When might they improve readability? When might they
be overkill?</p></li>
<li><p>Write a rectangle-drawing procedure that takes three optional
arguments: left-upper corner, right-lower corner, and a width-height
pair. It should draw a correct rectangle whenever two of the three
arguments are given (since any two determine the third), and raise an
exception otherwise. Use the <em>Bogue</em> library.</p></li>
<li><p>Write a function that takes an optional argument of arbitrary
type and a function argument, and passes the optional argument to the
function without inspecting it. This tests your understanding of how
optional arguments work at the type level.</p></li>
</ol>
<h3 id="exercise-3-type-inference-practice">Exercise 3: Type Inference
Practice</h3>
<p><em>From a past exam.</em></p>
<p>These exercises help you internalize how type inference works. Try to
work them out by hand before checking with the OCaml toplevel.</p>
<ol type="1">
<li>Give the (most general) types of the following expressions, either
by guessing or by inferring by hand:
<ol type="1">
<li><code>let double f y = f (f y) in fun g x -&gt; double (g x)</code></li>
<li><code>let rec tails l = match l with [] -&gt; [] | x::xs -&gt; xs::tails xs in fun l -&gt; List.combine l (tails l)</code></li>
</ol></li>
<li>Give example expressions that have the following types (without
using type constraints). There are many possible answers for each:
<ol type="1">
<li><code>(int -&gt; int) -&gt; bool</code></li>
<li><code>'a option -&gt; 'a list</code></li>
</ol></li>
</ol>
<h3 id="exercise-4-types-as-exponents">Exercise 4: Types as
Exponents</h3>
<p>We have seen that algebraic data types can be related to analytic
functions (the subset definable from polynomials via recursion)—by
literally interpreting sum types (variant types) as sums and product
types (tuple and record types) as products. We can extend this
interpretation to function types by interpreting <span
class="math inline">a \rightarrow b</span> as <span
class="math inline">b^a</span> (i.e., <span class="math inline">b</span>
to the power of <span class="math inline">a</span>). Note that the <span
class="math inline">b^a</span> notation is actually used to denote
functions in set theory.</p>
<p>This interpretation makes sense: a function from a set with <span
class="math inline">a</span> elements to a set with <span
class="math inline">b</span> elements is choosing, for each of the <span
class="math inline">a</span> inputs, one of <span
class="math inline">b</span> outputs—giving <span
class="math inline">b^a</span> possible functions.</p>
<ol type="1">
<li><p>Translate <span class="math inline">a^{b + cd}</span> and <span
class="math inline">a^b \cdot (a^c)^d</span> into OCaml types, using any
distinct types for <span class="math inline">a, b, c, d</span>, and
using <code>type ('a,'b) choice = Left of 'a | Right of 'b</code> for
<span class="math inline">+</span>. Write the bijection functions in
both directions. Verify algebraically that <span
class="math inline">a^{b + cd} = a^b \cdot (a^c)^d</span> using the laws
of exponents.</p></li>
<li><p>Come up with a type <code>'t exp</code> that shares with the
exponential function the following property: <span
class="math inline">\frac{\partial \exp(t)}{\partial t} =
\exp(t)</span>, where we translate a derivative of a type as a context
(i.e., the type with a “hole”), as in this chapter. In other words, the
derivative of the type should be isomorphic to the type itself! Explain
why your answer is correct. <em>Hint:</em> in computer science, our
logarithms are mostly base 2.</p></li>
</ol>
<p><em>Further reading:</em> <a
href="http://bababadalgharaghtakamminarronnkonnbro.blogspot.com/2012/10/algebraic-type-systems-combinatorial.html">Algebraic
Type Systems - Combinatorial Species</a></p>
<h3 id="exercise-5-homework-finding-contexts">Exercise 5 (Homework):
Finding Contexts</h3>
<p>Write a function <code>btree_deriv_at</code> that takes a predicate
over integers (i.e., a function <code>f: int -&gt; bool</code>) and a
<code>btree</code>, and builds a <code>btree_deriv</code> whose “hole”
is in the first position for which the predicate returns true. It should
return a <code>btree_deriv option</code>, with <code>None</code> if the
predicate does not hold for any node.</p>
<p>This function lets you “search” a tree and get back a context
pointing to the found element. Think about what order you want to search
in (pre-order, in-order, or post-order) and what “first” means in that
context.</p>
<h1 id="chapter-3-computation">Chapter 3: Computation</h1>
<p><em>Reduction semantics and operational reasoning</em></p>
<p><strong>In this chapter, you will:</strong></p>
<ul>
<li>Use function composition to build reusable “pipelines”</li>
<li>Learn reduction semantics to reason about evaluation step by
step</li>
<li>Recognize and write tail-recursive programs (and understand what TCO
buys you)</li>
<li>Get a first working intuition for continuation-passing style
(CPS)</li>
</ul>
<p><strong>References:</strong></p>
<ul>
<li>“Using, Understanding and Unraveling the OCaml Language” by Didier
Remy, Chapter 1</li>
<li>“The OCaml system” manual, the tutorial part, Chapter 1</li>
</ul>
<p>In this chapter, we explore how functional programs actually execute.
We will learn how to reason about computation step by step using
<em>reduction semantics</em>, and discover important optimization
techniques like <em>tail call optimization</em> that make functional
programming practical. Along the way, we will encounter our first taste
of <em>continuation passing style</em>, a powerful programming technique
that will reappear throughout this book.</p>
<h2 id="function-composition">3.1 Function Composition</h2>
<p>Function composition is one of the most fundamental operations in
functional programming. It allows us to build complex transformations by
combining simpler functions. The usual way function composition is
defined in mathematics is “backward”—the notation follows the convention
of mathematical function application:</p>
<p><span class="math display">
(f \circ g)(x) = f(g(x))
</span></p>
<p>This means that when we write <span class="math inline">f \circ
g</span>, we first apply <span class="math inline">g</span> and then
apply <span class="math inline">f</span> to the result. The function
written on the left is applied last—hence the term “backward”
composition. Here is how this is expressed in different functional
programming languages:</p>
<table>
<thead>
<tr>
<th>Language</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td>Math</td>
<td><span class="math inline">(f \circ g)(x) = f(g(x))</span></td>
</tr>
<tr>
<td>OCaml</td>
<td><code>let (-|) f g x = f (g x)</code></td>
</tr>
<tr>
<td>F#</td>
<td><code>let (&lt;&lt;) f g x = f (g x)</code></td>
</tr>
<tr>
<td>Haskell</td>
<td><code>(.) f g = \x -&gt; f (g x)</code></td>
</tr>
</tbody>
</table>
<p>This backward composition looks like function application but needs
fewer parentheses. Do you recall the functions <code>iso1</code> and
<code>iso2</code> from the previous chapter on type isomorphisms? Using
backward composition, we could write:</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> iso2 = step1l -| step2l -| step3l</span></code></pre></div>
<p>While backward composition matches traditional mathematical notation,
many programmers find a “forward” composition more intuitive. Forward
composition follows the order in which computation actually
proceeds—data flows from left to right, matching how we typically read
code in most programming languages:</p>
<table>
<thead>
<tr>
<th>Language</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td>OCaml</td>
<td><code>let (\|-) f g x = g (f x)</code></td>
</tr>
<tr>
<td>F#</td>
<td><code>let (&gt;&gt;) f g x = g (f x)</code></td>
</tr>
</tbody>
</table>
<p>With forward composition, you can read a pipeline of transformations
in the natural order:</p>
<div class="sourceCode" id="cb52"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> iso1 = step1r |- step2r |- step3r</span></code></pre></div>
<p>Here, the data first passes through <code>step1r</code>, then the
result goes to <code>step2r</code>, and finally to <code>step3r</code>.
This “pipeline” style of programming is particularly popular in
languages like F# and has influenced the design of many modern
programming languages.</p>
<p>In the table above, the operator is written as <code>\|-</code>
because Markdown tables use <code>|</code> to separate columns. In
actual OCaml code, the operator name is <code>(|-)</code>.</p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (|-) f g x = g (f x)</span></code></pre></div>
<p>Two related (but distinct) tools are also worth knowing:</p>
<ul>
<li>The standard library provides backward composition as
<code>Fun.compose</code>, where
<code>Fun.compose f g x = f (g x)</code>.</li>
<li>OCaml also provides the forward <em>application</em> operator
<code>(|&gt;)</code> (a pipeline): <code>x |&gt; f |&gt; g</code> means
<code>g (f x)</code>. Unlike <code>(|-)</code>, this is not composition
of functions but immediate application to a value.</li>
</ul>
<h3 id="partial-application">Partial Application</h3>
<p>Both composition examples above rely on <strong>partial
application</strong>, a technique we introduced in the previous chapter.
Recall that <code>((+) 1)</code> is a function that adds 1 to its
argument—we have provided only one of the two arguments that
<code>(+)</code> requires. Partial application occurs whenever we supply
fewer arguments than a function expects; the result is a new function
that waits for the remaining arguments.</p>
<p>Consider the composition <code>step1r |- step2r |- step3r</code>. How
exactly does partial application come into play here? The composition
operator <code>(|-)</code> is defined as
<code>let (|-) f g x = g (f x)</code>, which means it takes
<em>three</em> arguments: two functions <code>f</code> and
<code>g</code>, and a value <code>x</code>. When we write
<code>step1r |- step2r</code>, we are partially applying
<code>(|-)</code> with just two arguments. The result is a function that
still needs the final argument <code>x</code>.</p>
<p><em>Exercise:</em> Think about the types involved. If
<code>step1r</code> has type <code>'a -&gt; 'b</code> and
<code>step2r</code> has type <code>'b -&gt; 'c</code>, what is the type
of <code>step1r |- step2r</code>?</p>
<p><em>Check:</em> <code>step1r |- step2r</code> has type
<code>'a -&gt; 'c</code>. (Composition “cancels” the middle type
<code>'b</code>.)</p>
<h3 id="power-function">Power Function</h3>
<p>Now we define iterated function composition—applying a function to
itself repeatedly. This is written mathematically as:</p>
<p><span class="math display">
f^n(x) := \underbrace{(f \circ \cdots \circ f)}_{n \text{ times}}(x)
</span></p>
<p>In other words, <span class="math inline">f^0</span> is the identity
function, <span class="math inline">f^1 = f</span>, <span
class="math inline">f^2 = f \circ f</span>, and so on. In OCaml, we
first define the backward composition operator, then use it to implement
<code>power</code>:</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (-|) f g x = f (g x)</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> power f n =</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> (<span class="kw">fun</span> x -&gt; x) <span class="kw">else</span> f -| power f (n<span class="dv">-1</span>)</span></code></pre></div>
<p>When <code>n &lt;= 0</code>, we return the identity function
<code>fun x -&gt; x</code>. Otherwise, we compose <code>f</code> with
<code>power f (n-1)</code>, which gives us one more application of
<code>f</code>. Notice how elegantly this definition expresses the
mathematical concept—we are literally composing <code>f</code> with
itself <code>n</code> times.</p>
<p>This <code>power</code> function is surprisingly versatile. For
example, we can use it to define addition in terms of the successor
function:</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> add n = power ((+) <span class="dv">1</span>) n</span></code></pre></div>
<p>Here <code>add 5 7</code> would compute <span class="math inline">7 +
1 + 1 + 1 + 1 + 1 = 12</span>. We could even define multiplication:</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> mult k n = power ((+) k) n <span class="dv">0</span></span></code></pre></div>
<p>This computes <span class="math inline">0 + k + k + \ldots + k</span>
(adding <span class="math inline">k</span> a total of <span
class="math inline">n</span> times), giving us <span
class="math inline">k \times n</span>. While not the most efficient
implementation, these examples show how higher-order functions like
<code>power</code> can express fundamental mathematical operations.</p>
<h3 id="numerical-derivative">Numerical Derivative</h3>
<p>A beautiful application of <code>power</code> is computing
higher-order derivatives. First, let us define a numerical approximation
of the derivative using the standard finite difference formula:</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> derivative dx f = <span class="kw">fun</span> x -&gt; (f (x +. dx) -. f x) /. dx</span></code></pre></div>
<p>This definition computes <span class="math inline">\frac{f(x + dx) -
f(x)}{dx}</span>, which approximates <span
class="math inline">f&#39;(x)</span> when <code>dx</code> is small.
Notice the explicit <code>fun x -&gt; ...</code> syntax, which
emphasizes that <code>derivative dx f</code> is itself a function—we are
transforming a function <code>f</code> into its derivative function.</p>
<p>We can write the same definition more concisely using OCaml’s curried
function syntax:</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> derivative dx f x = (f (x +. dx) -. f x) /. dx</span></code></pre></div>
<p>Both definitions are equivalent, but the first makes the “function
returning a function” structure more explicit, while the second is more
compact.</p>
<p><strong>A note on OCaml’s numeric operators:</strong> OCaml uses
different operators for floating-point arithmetic than for integers. The
type of <code>(+)</code> is <code>int -&gt; int -&gt; int</code>, so we
cannot use <code>+</code> with <code>float</code> values. Instead,
operators followed by a dot work on <code>float</code> numbers:
<code>+.</code>, <code>-.</code>, <code>*.</code>, and <code>/.</code>.
This might seem inconvenient at first, but it catches type errors at
compile time and avoids the implicit conversions that cause subtle bugs
in other languages.</p>
<h3 id="computing-higher-order-derivatives">Computing Higher-Order
Derivatives</h3>
<p>Now comes the payoff. With <code>power</code> and
<code>derivative</code>, we can elegantly compute higher-order
derivatives:</p>
<div class="sourceCode" id="cb59"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pi = <span class="fl">4.0</span> *. <span class="dt">atan</span> <span class="fl">1.0</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> sin&#39;&#39;&#39; = (power (derivative <span class="fl">1e-5</span>) <span class="dv">3</span>) <span class="dt">sin</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> _approx = sin&#39;&#39;&#39; pi</span></code></pre></div>
<p>Here <code>sin'''</code> is the third derivative of sine. The
expression <code>(power (derivative 1e-5) 3)</code> creates a function
that applies the derivative operation three times—exactly what we need
for the third derivative.</p>
<p>Mathematically, the third derivative of <span
class="math inline">\sin(x)</span> is <span
class="math inline">-\cos(x)</span>, so <code>sin''' pi</code> should
give us <span class="math inline">-\cos(\pi) = 1</span>. The actual
result will be close to 1, with some numerical error due to the finite
difference approximation (the error compounds with each derivative we
take).</p>
<p>This example demonstrates the power of treating functions as
first-class values. We have built a general-purpose derivative operator
and combined it with our <code>power</code> function to create an <span
class="math inline">n</span>th-derivative calculator—all in just a few
lines of code.</p>
<h2 id="evaluation-rules-reduction-semantics">3.2 Evaluation Rules
(Reduction Semantics)</h2>
<p>So far, we have written OCaml programs and observed their results,
but we have not precisely described <em>how</em> those results are
computed. To understand how OCaml programs execute, we need to formalize
the evaluation process. This section presents <strong>reduction
semantics</strong> (also called <em>operational semantics</em>), which
describes computation as a series of rewriting steps that transform
expressions until we reach a final value.</p>
<p>Understanding reduction semantics is valuable for several reasons. It
helps us predict what our programs will do, reason about their
efficiency, and understand subtle behaviors like infinite loops and
non-termination. The ideas here also form the foundation for
understanding more advanced topics like type systems and program
verification.</p>
<h3 id="expressions">Expressions</h3>
<p>Programs consist of <strong>expressions</strong>. Here is the grammar
of expressions for a simplified version of OCaml (we omit some features
for clarity):</p>
<p><span class="math display">
\begin{aligned}
a \; &amp;{:=} \; x &amp;&amp; \text{variables} \\
  &amp;\mid \; \texttt{fun } x \texttt{ -&gt; } a &amp;&amp;
\text{(defined) functions} \\
  &amp;\mid \; a \; a &amp;&amp; \text{applications} \\
  &amp;\mid \; C^0 &amp;&amp; \text{value constructors of arity } 0 \\
  &amp;\mid \; C^n(a, \ldots, a) &amp;&amp; \text{value constructors of
arity } n \\
  &amp;\mid \; f^n &amp;&amp; \text{built-in values (primitives) of
arity } n \\
  &amp;\mid \; \texttt{let } x = a \texttt{ in } a &amp;&amp; \text{name
bindings (local definitions)} \\
  &amp;\mid \; \texttt{match } a \texttt{ with} &amp;&amp; \\
  &amp; \quad p \texttt{ -&gt; } a \texttt{ | } \cdots \texttt{ | } p
\texttt{ -&gt; } a &amp;&amp; \text{pattern matching} \\[1em]
p \; &amp;{:=} \; x &amp;&amp; \text{pattern variables} \\
  &amp;\mid \; (p, \ldots, p) &amp;&amp; \text{tuple patterns} \\
  &amp;\mid \; C^0 &amp;&amp; \text{variant patterns of arity } 0 \\
  &amp;\mid \; C^n(p, \ldots, p) &amp;&amp; \text{variant patterns of
arity } n
\end{aligned}
</span></p>
<p><strong>Arity</strong> means how many arguments something requires.
For constructors, arity tells us how many components the constructor
holds; for functions (primitives), it tells us how many arguments they
need before they can compute a result. For tuple patterns, arity is
simply the length of the tuple.</p>
<p><strong>Meta-syntax note.</strong> In the grammar and rules below, we
write constructors as if they were truly <span
class="math inline">n</span>-ary, e.g. <span
class="math inline">C^3(a_1,a_2,a_3)</span>. In actual OCaml syntax,
constructors take exactly one argument; “multiple arguments” are
represented by a tuple, e.g. <code>Node (v1, v2, v3)</code>. The <span
class="math inline">n</span>-ary presentation is a convenient
mathematical shorthand.</p>
<p><strong>Evaluation-order note.</strong> The small-step rules below
are intentionally simplified. In particular, the “context” rules allow
reducing subexpressions in more than one place. Real OCaml is
<em>strict</em> (call-by-value) and evaluates subexpressions in a
deterministic order (in current OCaml implementations this is often
right-to-left); the details matter when you have effects (exceptions,
printing, mutation), but are usually irrelevant for purely functional
code.</p>
<h3 id="the-fix-primitive">The <code>fix</code> Primitive</h3>
<p>Our grammar above includes functions defined with <code>fun</code>,
but what about recursive functions defined with <code>let rec</code>? To
keep our semantics simple, we introduce a primitive <code>fix</code>
that captures the essence of recursion:</p>
<p><span class="math display">
\texttt{let rec } f \; x = e_1 \texttt{ in } e_2 \equiv \texttt{let } f
= \texttt{fix (fun } f \; x \texttt{ -&gt; } e_1 \texttt{) in } e_2
</span></p>
<p>The <code>fix</code> primitive is a <em>fixpoint combinator</em>. It
takes a function that expects to receive “itself” as its first argument
and produces a function that, when called, behaves as if it has access
to itself for recursive calls. This might seem mysterious now, but we
will see exactly how it works when we examine its reduction rule
below.</p>
<h3 id="values">Values</h3>
<p>Expressions evaluate (i.e., compute) to <strong>values</strong>.
Values are expressions that cannot be reduced further—they are the
“final answers” of computation:</p>
<p><span class="math display">
\begin{array}{lcll}
v &amp; := &amp; \texttt{fun } x \texttt{ -&gt; } a &amp;
\text{(defined) functions} \\
  &amp; |  &amp; C^n(v_1, \ldots, v_n) &amp; \text{constructed values}
\\
  &amp; |  &amp; f^n \; v_1 \; \cdots \; v_k &amp; k &lt; n \text{
(partially applied primitives)}
\end{array}
</span></p>
<p>Note that functions are values: <code>fun x -&gt; x + 1</code> is
already fully evaluated—there is nothing more to compute until the
function is applied to an argument. Similarly, constructed values like
<code>Some 42</code> or <code>(1, 2, 3)</code> are values when all their
components are values.</p>
<p>Partially applied primitives like <code>(+) 3</code> are also values.
The expression <code>(+) 3</code> has received one argument but needs
another before it can compute a sum. Until that second argument arrives,
there is nothing more to do, so <code>(+) 3</code> is a value.</p>
<h3 id="substitution">Substitution</h3>
<p>The heart of evaluation is <strong>substitution</strong>. To
substitute a value <span class="math inline">v</span> for a variable
<span class="math inline">x</span> in expression <span
class="math inline">a</span>, we write <span class="math inline">a[x :=
v]</span>. This notation means that every occurrence of <span
class="math inline">x</span> in <span class="math inline">a</span> is
replaced by <span class="math inline">v</span>.</p>
<p>For example, if <span class="math inline">a</span> is the expression
<code>x + x * y</code> and we substitute 3 for <code>x</code>, we get
<code>3 + 3 * y</code>. In our notation:
<code>(x + x * y)[x := 3] = 3 + 3 * y</code>.</p>
<p>In the presence of binders like <code>fun x -&gt; ...</code> (and
pattern-bound variables), substitution must be
<strong>capture-avoiding</strong>: we are allowed to rename bound
variables so we do not accidentally change which occurrence refers to
which binder.</p>
<p><strong>Implementation note:</strong> Although we describe
substitution as “replacing” variables with values, the actual
implementation in OCaml does not duplicate the value <span
class="math inline">v</span> in memory each time it appears. Instead,
OCaml uses closures and sharing to ensure that values are stored once
and referenced wherever needed. This is both more efficient and
essential for handling recursive data structures.</p>
<h3 id="reduction-rules-redexes">Reduction Rules (Redexes)</h3>
<p>Now we can describe how computation actually proceeds. Reduction
works by finding reducible expressions called <strong>redexes</strong>
(short for “reducible expressions”) and applying reduction rules that
rewrite them into simpler forms. We write <span class="math inline">e_1
\rightsquigarrow e_2</span> to mean “expression <span
class="math inline">e_1</span> reduces to expression <span
class="math inline">e_2</span> in one step.”</p>
<p>Here are the fundamental reduction rules:</p>
<p><strong>Function application (beta reduction):</strong> <span
class="math display">
(\texttt{fun } x \texttt{ -&gt; } a) \; v \rightsquigarrow a[x := v]
</span></p>
<p>This is the most important rule. When we apply a function
<code>fun x -&gt; a</code> to a value <span
class="math inline">v</span>, we substitute <span
class="math inline">v</span> for the parameter <span
class="math inline">x</span> throughout the function body <span
class="math inline">a</span>. This rule is traditionally called “beta
reduction” in the lambda calculus literature.</p>
<p>For example: <code>(fun x -&gt; x + 1) 5</code> <span
class="math inline">\rightsquigarrow</span> <code>5 + 1</code> <span
class="math inline">\rightsquigarrow</span> <code>6</code>.</p>
<p><strong>Let binding:</strong> <span class="math display">
\texttt{let } x = v \texttt{ in } a \rightsquigarrow a[x := v]
</span></p>
<p>A let binding works similarly: once the bound expression has been
evaluated to a value <span class="math inline">v</span>, we substitute
it into the body. Notice that <code>let x = e in a</code> is essentially
equivalent to <code>(fun x -&gt; a) e</code>—both bind <span
class="math inline">x</span> to the result of evaluating <span
class="math inline">e</span> within the expression <span
class="math inline">a</span>.</p>
<p><strong>Primitive application:</strong> <span class="math display">
f^n \; v_1 \; \cdots \; v_n \rightsquigarrow f(v_1, \ldots, v_n)
</span></p>
<p>When a primitive (like <code>+</code> or <code>*</code>) receives all
the arguments it needs (determined by its arity <span
class="math inline">n</span>), it computes the result. Here <span
class="math inline">f(v_1, \ldots, v_n)</span> denotes the actual result
of the primitive operation—for example, <code>(+) 2 3</code> <span
class="math inline">\rightsquigarrow</span> <code>5</code>.</p>
<p><strong>Pattern matching with a variable pattern:</strong> <span
class="math display">
\texttt{match } v \texttt{ with } x \texttt{ -&gt; } a \texttt{ | }
\cdots \rightsquigarrow a[x := v]
</span></p>
<p>A variable pattern always matches, binding the entire value to the
variable.</p>
<p><strong>Pattern matching with a non-matching constructor:</strong>
<span class="math display">
\frac{C_1 \neq C_2}{\texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{
with } C_2^k(p_1, \ldots, p_k) \texttt{ -&gt; } a \texttt{ | } pm
\rightsquigarrow \texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{ with }
pm}
</span></p>
<p>If the constructor in the value (<span
class="math inline">C_1</span>) does not match the constructor in the
pattern (<span class="math inline">C_2</span>), we skip this branch and
try the remaining patterns (<span class="math inline">pm</span>). This
is how OCaml searches through pattern match cases from top to
bottom.</p>
<p><strong>Pattern matching with a matching constructor:</strong> <span
class="math display">
\texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{ with } C_1^n(x_1,
\ldots, x_n) \texttt{ -&gt; } a \texttt{ | } \cdots \rightsquigarrow
a[x_1 := v_1; \ldots; x_n := v_n]
</span></p>
<p>If the constructor matches, we substitute all the values from inside
the constructor for the corresponding pattern variables. For example,
<code>match Some 42 with Some x -&gt; x + 1 | None -&gt; 0</code>
reduces to <code>42 + 1</code> because <code>Some</code> matches
<code>Some</code> and we substitute 42 for <code>x</code>.</p>
<p>If <span class="math inline">n = 0</span>, then <span
class="math inline">C_1^n(v_1, \ldots, v_n)</span> stands for simply
<span class="math inline">C_1^0</span>, a constructor with no arguments
(like <code>None</code> or <code>[]</code>). We omit the more complex
cases of nested pattern matching for brevity.</p>
<h3 id="rule-variables">Rule Variables</h3>
<p>In these rules, we use <em>metavariables</em>—placeholders that can
be replaced with actual expressions. Understanding them is key to
applying the rules:</p>
<ul>
<li><span class="math inline">x</span> matches any variable name (like
<code>foo</code>, <code>n</code>, or <code>result</code>)</li>
<li><span class="math inline">a, a_1, \ldots, a_n</span> match any
expression (not necessarily a value)</li>
<li><span class="math inline">v, v_1, \ldots, v_n</span> match any
<em>value</em> (expressions that are fully evaluated)</li>
</ul>
<p>To apply a rule, find substitutions for these metavariables that make
the left-hand side of the rule match your expression. Then the
right-hand side (with the same substitutions applied) gives you the
reduced expression.</p>
<p>For example, to apply the beta reduction rule to
<code>(fun n -&gt; n * 2) 5</code>: 1. Match <code>fun x -&gt; a</code>
with <code>fun n -&gt; n * 2</code>, giving us <span
class="math inline">x = \texttt{n}</span> and <span
class="math inline">a = \texttt{n * 2}</span> 2. Match <span
class="math inline">v</span> with <code>5</code> 3. The right-hand side
<span class="math inline">a[x := v]</span> becomes
<code>(n * 2)[n := 5]</code> which equals <code>5 * 2</code></p>
<h3 id="evaluation-context-rules">Evaluation Context Rules</h3>
<p>The reduction rules above only apply when the arguments are already
values. But what if we have <code>(fun x -&gt; x + 1) (2 + 3)</code>?
The argument <code>2 + 3</code> is not a value, so we cannot directly
apply beta reduction. We need rules that tell us evaluation can proceed
inside subexpressions.</p>
<p>If <span class="math inline">a_i \rightsquigarrow a_i&#39;</span>
(meaning <span class="math inline">a_i</span> can take a reduction
step), then:</p>
<p><span class="math display">
\begin{array}{lcl}
a_1 \; a_2 &amp; \rightsquigarrow &amp; a_1&#39; \; a_2 \\
a_1 \; a_2 &amp; \rightsquigarrow &amp; a_1 \; a_2&#39; \\
C^n(a_1, \ldots, a_i, \ldots, a_n) &amp; \rightsquigarrow &amp; C^n(a_1,
\ldots, a_i&#39;, \ldots, a_n) \\
\texttt{let } x = a_1 \texttt{ in } a_2 &amp; \rightsquigarrow &amp;
\texttt{let } x = a_1&#39; \texttt{ in } a_2 \\
\texttt{match } a_1 \texttt{ with } pm &amp; \rightsquigarrow &amp;
\texttt{match } a_1&#39; \texttt{ with } pm
\end{array}
</span></p>
<p>These rules describe <em>where</em> reduction can happen: - In a
function application <span class="math inline">a_1 \; a_2</span>, the
rules allow reducing either the function (<span
class="math inline">a_1</span>) or the argument (<span
class="math inline">a_2</span>). This is a common simplification in
textbook semantics; OCaml itself uses a fixed evaluation order. - In a
constructor application, any argument can be evaluated. - In a let
binding <code>let x = a1 in a2</code>, the bound expression <span
class="math inline">a_1</span> must be evaluated to a value before we
can proceed. Notice there is no rule for evaluating <span
class="math inline">a_2</span> directly—the body is only evaluated after
the substitution happens. - In a match expression, the scrutinee (the
expression being matched) must be evaluated before pattern matching can
proceed.</p>
<h3 id="the-fix-rule">The <code>fix</code> Rule</h3>
<p>Finally, the rule for the <code>fix</code> primitive, which enables
recursion:</p>
<p><span class="math display">
\texttt{fix}^2 \; v_1 \; v_2 \rightsquigarrow v_1 \; (\texttt{fix}^2 \;
v_1) \; v_2
</span></p>
<p>This rule is subtle but powerful. Let us unpack it:</p>
<ol type="1">
<li><code>fix</code> is a binary primitive (arity 2), meaning it needs
two arguments before it computes.</li>
<li>When we apply <code>fix</code> to two values <span
class="math inline">v_1</span> and <span class="math inline">v_2</span>,
it “unrolls” one level of recursion by calling <span
class="math inline">v_1</span> with two arguments: <code>(fix v1)</code>
(which represents “the recursive function itself”) and <span
class="math inline">v_2</span> (the actual argument to the recursive
call).</li>
<li>Because <code>fix</code> has arity 2, the expression
<code>(fix v1)</code> is a <em>partially applied primitive</em>—and
partially applied primitives are values! This is crucial: it means
<code>(fix v1)</code> will not be evaluated further until it is applied
to another argument inside <span class="math inline">v_1</span>.</li>
</ol>
<p>This delayed evaluation is what prevents infinite loops. If
<code>(fix v1)</code> were evaluated immediately, we would get an
infinite chain of expansions. Instead, evaluation only continues when
the recursive function actually makes a recursive call.</p>
<p><code>fix</code> is not an OCaml primitive; it is a pedagogical
device. If you <em>did</em> want to define it directly in OCaml, you
could (ironically) do so using <code>let rec</code>:</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fix f =</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> self x = f self x <span class="kw">in</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>  self</span></code></pre></div>
<h3 id="practice">Practice</h3>
<p>The best way to understand reduction semantics is to work through
examples by hand. Trace the evaluation of these expressions step by
step:</p>
<p><strong>Exercise 1:</strong> Evaluate
<code>let double x = x + x in double 3</code></p>
<p><strong>Exercise 2:</strong> Evaluate
<code>(fun f -&gt; fun x -&gt; f (f x)) (fun y -&gt; y + 1) 0</code></p>
<p><strong>Exercise 3:</strong> Define the factorial function using
<code>fix</code> and trace the evaluation of
<code>factorial 3</code></p>
<h2 id="symbolic-derivation-example">3.3 Symbolic Derivation
Example</h2>
<p>Let us see the reduction rules in action with a more substantial
example. We will build a small computer algebra system that can
represent mathematical expressions symbolically, evaluate them, and even
compute their derivatives symbolically.</p>
<p>Consider the symbolic expression type from <code>Lec3.ml</code>:</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> expression =</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>  | Const <span class="kw">of</span> <span class="dt">float</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>  | Var <span class="kw">of</span> <span class="dt">string</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>  | Sum <span class="kw">of</span> expression * expression    <span class="co">(* e1 + e2 *)</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>  | Diff <span class="kw">of</span> expression * expression   <span class="co">(* e1 - e2 *)</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>  | Prod <span class="kw">of</span> expression * expression   <span class="co">(* e1 * e2 *)</span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>  | Quot <span class="kw">of</span> expression * expression   <span class="co">(* e1 / e2 *)</span></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a><span class="kw">exception</span> Unbound_variable <span class="kw">of</span> <span class="dt">string</span></span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> eval env <span class="dt">exp</span> =</span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> <span class="dt">exp</span> <span class="kw">with</span></span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a>  | Const c -&gt; c</span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a>  | Var v -&gt;</span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">try</span> <span class="dt">List</span>.assoc v env <span class="kw">with</span> <span class="dt">Not_found</span> -&gt; <span class="dt">raise</span> (Unbound_variable v))</span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a>  | Sum(f, g) -&gt; eval env f +. eval env g</span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a>  | Diff(f, g) -&gt; eval env f -. eval env g</span>
<span id="cb61-18"><a href="#cb61-18" aria-hidden="true" tabindex="-1"></a>  | Prod(f, g) -&gt; eval env f *. eval env g</span>
<span id="cb61-19"><a href="#cb61-19" aria-hidden="true" tabindex="-1"></a>  | Quot(f, g) -&gt; eval env f /. eval env g</span></code></pre></div>
<p>The <code>expression</code> type represents mathematical expressions
as a tree structure. Each constructor corresponds to a different kind of
expression: constants, variables, and the four basic arithmetic
operations. The <code>eval</code> function takes an environment
<code>env</code> (a list of variable-value pairs) and recursively
evaluates an expression to a floating-point number.</p>
<p>We can also define <em>symbolic differentiation</em>—computing the
derivative of an expression without evaluating it numerically:</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> deriv <span class="dt">exp</span> dv =</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> <span class="dt">exp</span> <span class="kw">with</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>  | Const _ -&gt; Const <span class="fl">0.0</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>  | Var v -&gt; <span class="kw">if</span> v = dv <span class="kw">then</span> Const <span class="fl">1.0</span> <span class="kw">else</span> Const <span class="fl">0.0</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>  | Sum(f, g) -&gt; Sum(deriv f dv, deriv g dv)</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>  | Diff(f, g) -&gt; Diff(deriv f dv, deriv g dv)</span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>  | Prod(f, g) -&gt; Sum(Prod(f, deriv g dv), Prod(deriv f dv, g))</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>  | Quot(f, g) -&gt; Quot(Diff(Prod(deriv f dv, g), Prod(f, deriv g dv)),</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>                       Prod(g, g))</span></code></pre></div>
<p>The <code>deriv</code> function implements the standard rules of
calculus: - The derivative of a constant is 0. - The derivative of the
variable we are differentiating with respect to is 1; any other variable
is treated as a constant (derivative 0). - The sum and difference rules:
<span class="math inline">(f + g)&#39; = f&#39; + g&#39;</span> and
<span class="math inline">(f - g)&#39; = f&#39; - g&#39;</span>. - The
product rule: <span class="math inline">(f \cdot g)&#39; = f \cdot
g&#39; + f&#39; \cdot g</span>. - The quotient rule: <span
class="math inline">(f / g)&#39; = (f&#39; \cdot g - f \cdot g&#39;) /
g^2</span>.</p>
<p>For convenience, let us define some operators and variables so we can
write expressions more naturally:</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = Var <span class="st">&quot;x&quot;</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> y = Var <span class="st">&quot;y&quot;</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> z = Var <span class="st">&quot;z&quot;</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (+:) f g = Sum (f, g)</span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (-:) f g = Diff (f, g)</span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ( *: ) f g = Prod (f, g)</span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (/:) f g = Quot (f, g)</span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (!:) i = Const i</span></code></pre></div>
<p>These custom operators (ending in <code>:</code>) let us write
symbolic expressions that look almost like regular mathematical
notation.</p>
<p>Now let us evaluate the expression <span class="math inline">3x + 2y
+ x^2 y</span> at <span class="math inline">x = 1, y = 2</span>:</p>
<div class="sourceCode" id="cb64"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> example = !:<span class="fl">3.0</span> *: x +: !:<span class="fl">2.0</span> *: y +: x *: x *: y</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> env = [<span class="st">&quot;x&quot;</span>, <span class="fl">1.0</span>; <span class="st">&quot;y&quot;</span>, <span class="fl">2.0</span>]</span></code></pre></div>
<p>For nicer output, it is helpful to define a pretty-printer that
displays expressions in infix notation (this is adapted from
<code>Lec3.ml</code>):</p>
<div class="sourceCode" id="cb65"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> print_expr ppf <span class="dt">exp</span> =</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> open_paren prec op_prec =</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> prec &gt; op_prec <span class="kw">then</span> <span class="dt">Format</span>.fprintf ppf <span class="st">&quot;(@[&quot;</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="dt">Format</span>.fprintf ppf <span class="st">&quot;@[&quot;</span> <span class="kw">in</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> close_paren prec op_prec =</span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> prec &gt; op_prec <span class="kw">then</span> <span class="dt">Format</span>.fprintf ppf <span class="st">&quot;@])&quot;</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="dt">Format</span>.fprintf ppf <span class="st">&quot;@]&quot;</span> <span class="kw">in</span></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> print prec <span class="dt">exp</span> =</span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> <span class="dt">exp</span> <span class="kw">with</span></span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>    | Const c -&gt; <span class="dt">Format</span>.fprintf ppf <span class="st">&quot;%.2f&quot;</span> c</span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>    | Var v -&gt; <span class="dt">Format</span>.fprintf ppf <span class="st">&quot;%s&quot;</span> v</span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>    | Sum(f, g) -&gt;</span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>      open_paren prec <span class="dv">0</span>;</span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>      print <span class="dv">0</span> f; <span class="dt">Format</span>.fprintf ppf <span class="st">&quot;@ +@ &quot;</span>; print <span class="dv">0</span> g;</span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true" tabindex="-1"></a>      close_paren prec <span class="dv">0</span></span>
<span id="cb65-16"><a href="#cb65-16" aria-hidden="true" tabindex="-1"></a>    | Diff(f, g) -&gt;</span>
<span id="cb65-17"><a href="#cb65-17" aria-hidden="true" tabindex="-1"></a>      open_paren prec <span class="dv">0</span>;</span>
<span id="cb65-18"><a href="#cb65-18" aria-hidden="true" tabindex="-1"></a>      print <span class="dv">0</span> f; <span class="dt">Format</span>.fprintf ppf <span class="st">&quot;@ -@ &quot;</span>; print <span class="dv">1</span> g;</span>
<span id="cb65-19"><a href="#cb65-19" aria-hidden="true" tabindex="-1"></a>      close_paren prec <span class="dv">0</span></span>
<span id="cb65-20"><a href="#cb65-20" aria-hidden="true" tabindex="-1"></a>    | Prod(f, g) -&gt;</span>
<span id="cb65-21"><a href="#cb65-21" aria-hidden="true" tabindex="-1"></a>      open_paren prec <span class="dv">2</span>;</span>
<span id="cb65-22"><a href="#cb65-22" aria-hidden="true" tabindex="-1"></a>      print <span class="dv">2</span> f; <span class="dt">Format</span>.fprintf ppf <span class="st">&quot;@ *@ &quot;</span>; print <span class="dv">2</span> g;</span>
<span id="cb65-23"><a href="#cb65-23" aria-hidden="true" tabindex="-1"></a>      close_paren prec <span class="dv">2</span></span>
<span id="cb65-24"><a href="#cb65-24" aria-hidden="true" tabindex="-1"></a>    | Quot(f, g) -&gt;</span>
<span id="cb65-25"><a href="#cb65-25" aria-hidden="true" tabindex="-1"></a>      open_paren prec <span class="dv">2</span>;</span>
<span id="cb65-26"><a href="#cb65-26" aria-hidden="true" tabindex="-1"></a>      print <span class="dv">2</span> f; <span class="dt">Format</span>.fprintf ppf <span class="st">&quot;@ /@ &quot;</span>; print <span class="dv">3</span> g;</span>
<span id="cb65-27"><a href="#cb65-27" aria-hidden="true" tabindex="-1"></a>      close_paren prec <span class="dv">2</span></span>
<span id="cb65-28"><a href="#cb65-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb65-29"><a href="#cb65-29" aria-hidden="true" tabindex="-1"></a>  print <span class="dv">0</span> <span class="dt">exp</span></span></code></pre></div>
<p>And for tracing, we define a specialized evaluator
<code>eval_1_2</code> with the environment baked in (so the trace
focuses on the expression structure):</p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> eval_1_2 <span class="dt">exp</span> =</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> <span class="dt">exp</span> <span class="kw">with</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>  | Const c -&gt; c</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>  | Var v -&gt;</span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">try</span> <span class="dt">List</span>.assoc v env <span class="kw">with</span> <span class="dt">Not_found</span> -&gt; <span class="dt">raise</span> (Unbound_variable v))</span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>  | Sum(f, g) -&gt; eval_1_2 f +. eval_1_2 g</span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>  | Diff(f, g) -&gt; eval_1_2 f -. eval_1_2 g</span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>  | Prod(f, g) -&gt; eval_1_2 f *. eval_1_2 g</span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a>  | Quot(f, g) -&gt; eval_1_2 f /. eval_1_2 g</span></code></pre></div>
<p>In the toplevel, you can now install the printer and trace the
evaluation:</p>
<div class="sourceCode" id="cb67"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a># #install_printer print_expr;;</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a># #trace eval_1_2;;</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a># eval_1_2 example;;</span></code></pre></div>
<p>The trace output makes the recursive structure of the computation
very concrete:</p>
<pre><code>eval_1_2 &lt;-- 3.00 * x + 2.00 * y + x * x * y
  eval_1_2 &lt;-- x * x * y
    eval_1_2 &lt;-- y
    eval_1_2 --&gt; 2.
    eval_1_2 &lt;-- x * x
      eval_1_2 &lt;-- x
      eval_1_2 --&gt; 1.
      eval_1_2 &lt;-- x
      eval_1_2 --&gt; 1.
    eval_1_2 --&gt; 1.
  eval_1_2 --&gt; 2.
  eval_1_2 &lt;-- 3.00 * x + 2.00 * y
    eval_1_2 &lt;-- 2.00 * y
      eval_1_2 &lt;-- y
      eval_1_2 --&gt; 2.
      eval_1_2 &lt;-- 2.00
      eval_1_2 --&gt; 2.
    eval_1_2 --&gt; 4.
    eval_1_2 &lt;-- 3.00 * x
      eval_1_2 &lt;-- x
      eval_1_2 --&gt; 1.
      eval_1_2 &lt;-- 3.00
      eval_1_2 --&gt; 3.
    eval_1_2 --&gt; 3.
  eval_1_2 --&gt; 7.
eval_1_2 --&gt; 9.
- : float = 9.</code></pre>
<p>The arrows <code>&lt;--</code> and <code>--&gt;</code> show function
calls and returns, respectively. Each level of indentation represents a
nested function call. These indentation levels correspond to
<strong>stack frames</strong>—the runtime structures that store the
state of each function call. Each time <code>eval_1_2</code> is called
recursively, a new stack frame is created to remember where to return
and what computation remains.</p>
<p>The final result is <span class="math inline">3 \cdot 1 + 2 \cdot 2 +
1 \cdot 1 \cdot 2 = 3 + 4 + 2 = 9</span>, as expected.</p>
<p>This trace visualization brings us to an important question: what
happens when we have very deep recursion? This leads us to our next
topic.</p>
<h2 id="tail-calls-and-tail-recursion">3.4 Tail Calls and Tail
Recursion</h2>
<p>The call stack is finite, and each recursive call typically adds a
new frame to it. This means that deeply recursive functions can exhaust
the stack and crash—a notorious problem known as “stack overflow.”
Fortunately, functional language implementations have a trick to avoid
this problem in many cases.</p>
<p>Excuse me for not formally defining what a <em>function call</em> is…
Computers normally evaluate programs by creating <strong>stack
frames</strong> on the call stack for each function call. A stack frame
stores the local variables, the return address (where to continue after
the function returns), and other bookkeeping information. The trace in
the previous section illustrates this: each level of indentation
represents a new stack frame.</p>
<h3 id="what-is-a-tail-call">What is a Tail Call?</h3>
<p>The key insight is that not all function calls require a new stack
frame. A <strong>tail call</strong> is a function call that is performed
as the very last action when computing a function—there is nothing more
to do after the call returns except to return that value. For
example:</p>
<div class="sourceCode" id="cb69"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x = g (x + <span class="dv">1</span>)</span></code></pre></div>
<p>The call to <code>g</code> is a tail call. Once <code>g</code>
returns some value, <code>f</code> simply returns that same value—no
further computation is needed.</p>
<p>In contrast:</p>
<div class="sourceCode" id="cb70"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x = <span class="dv">1</span> + g x</span></code></pre></div>
<p>The call to <code>g</code> is <em>not</em> a tail call. After
<code>g</code> returns, we still need to add 1 to the result before
<code>f</code> can return. This means we need to remember to do the
addition, which requires keeping the stack frame around.</p>
<h3 id="tail-call-optimization">Tail Call Optimization</h3>
<p>Functional language compilers (including OCaml’s) recognize tail
calls and optimize them by performing <strong>tail call
optimization</strong> (TCO). Instead of creating a new stack frame, the
compiler generates code that reuses the current frame by performing a
“jump” to the called function. This means tail calls use constant stack
space, no matter how deep the call chain goes.</p>
<p>This optimization is not just a nice-to-have; it is
<em>essential</em> for functional programming. Without TCO, many natural
recursive algorithms would be impractical because they would overflow
the stack on moderately large inputs.</p>
<h3 id="tail-recursive-functions">Tail Recursive Functions</h3>
<p>A function is <strong>tail recursive</strong> if all of its recursive
calls (including calls to mutually recursive functions it depends on)
are tail calls.</p>
<p>Writing tail recursive functions requires a shift in thinking.
Instead of building up the result as recursive calls return, we build it
up as we <em>make</em> the calls. This typically requires an extra
<strong>accumulator</strong> argument that carries the partial result
through the recursion.</p>
<p>The key insight is that with an accumulator, results are computed in
“reverse order”—we do the work while climbing <em>into</em> the
recursion (making calls) rather than while climbing <em>out</em>
(returning from calls).</p>
<h3 id="example-counting">Example: Counting</h3>
<p>Let us see this in action with a simple counting function. Compare
these two versions:</p>
<div class="sourceCode" id="cb71"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> count n =</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> <span class="dv">1</span> + (count (n<span class="dv">-1</span>))</span></code></pre></div>
<p>This version is <em>not</em> tail recursive. Look at the recursive
case: after <code>count (n-1)</code> returns, we still need to add 1 to
the result. Each recursive call must remember to do this addition,
consuming a stack frame.</p>
<p>Now compare with the tail recursive version:</p>
<div class="sourceCode" id="cb72"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> count_tcall acc n =</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> acc <span class="kw">else</span> count_tcall (acc+<span class="dv">1</span>) (n<span class="dv">-1</span>)</span></code></pre></div>
<p>Here, the recursive call <code>count_tcall (acc+1) (n-1)</code> is
the very last thing the function does—its result becomes our result
directly. The accumulator <code>acc</code> carries the running count: we
add 1 to it <em>before</em> the recursive call rather than
<em>after</em> it returns. To count to 1000000, we call
<code>count_tcall 0 1000000</code>.</p>
<h3 id="example-building-lists">Example: Building Lists</h3>
<p>The counting example does not really show the practical impact
because the numbers are so small. Let us see a more dramatic example
with lists:</p>
<div class="sourceCode" id="cb73"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> unfold n = <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> [] <span class="kw">else</span> n :: unfold (n<span class="dv">-1</span>)</span></code></pre></div>
<p>This function builds a list counting down from <code>n</code> to 1.
It is not tail recursive because after the recursive call
<code>unfold (n-1)</code> returns, we must cons <code>n</code> onto the
front of the result.</p>
<div class="sourceCode" id="cb74"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a># unfold <span class="dv">100000</span>;;</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">100000</span>; <span class="dv">99999</span>; <span class="dv">99998</span>; <span class="dv">99997</span>; ...]</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a># unfold <span class="dv">1000000</span>;;</span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Stack</span> overflow during evaluation (looping recursion?).</span></code></pre></div>
<p>With 100,000 elements, it works. But with a million elements, we run
out of stack space and the program crashes! This is a serious problem
for practical programming.</p>
<p>Now consider the tail-recursive version:</p>
<div class="sourceCode" id="cb75"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> unfold_tcall acc n =</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> acc <span class="kw">else</span> unfold_tcall (n::acc) (n<span class="dv">-1</span>)</span></code></pre></div>
<p>The accumulator <code>acc</code> collects the list as we go. We cons
each element onto the accumulator <em>before</em> the recursive call.
However, there is a catch: because we are building the list as we
descend into the recursion (rather than as we return), the list comes
out in reverse order:</p>
<div class="sourceCode" id="cb76"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a># unfold_tcall [] <span class="dv">100000</span>;;</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">5</span>; <span class="dv">6</span>; <span class="dv">7</span>; <span class="dv">8</span>; <span class="dv">9</span>; <span class="dv">10</span>; <span class="dv">11</span>; <span class="dv">12</span>; ...]</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a># unfold_tcall [] <span class="dv">1000000</span>;;</span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">5</span>; <span class="dv">6</span>; <span class="dv">7</span>; <span class="dv">8</span>; <span class="dv">9</span>; <span class="dv">10</span>; <span class="dv">11</span>; <span class="dv">12</span>; ...]</span></code></pre></div>
<p>The tail-recursive version handles a million elements effortlessly.
The trade-off is that we get <code>[1; 2; 3; ...]</code> instead of
<code>[1000000; 999999; ...]</code>. If we need the original order, we
could reverse the result at the end (which is an O(n) operation but uses
only constant stack space).</p>
<h3 id="a-challenge-tree-depth">A Challenge: Tree Depth</h3>
<p>Not all recursive functions can be easily converted to tail recursive
form. Consider this problem: can we find the depth of a binary tree
using a tail-recursive function?</p>
<div class="sourceCode" id="cb77"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree = Tip | Node <span class="kw">of</span> <span class="dt">int</span> * btree * btree</span></code></pre></div>
<p>Here is the natural recursive approach:</p>
<div class="sourceCode" id="cb78"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> depth tree = <span class="kw">match</span> tree <span class="kw">with</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>  | Tip -&gt; <span class="dv">0</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>  | Node(_, left, right) -&gt; <span class="dv">1</span> + <span class="dt">max</span> (depth left) (depth right)</span></code></pre></div>
<p>This is not tail recursive: after both recursive calls return, we
still need to compute <code>1 + max ...</code>. The fundamental
challenge is that we have <em>two</em> recursive calls that we need to
make. A simple accumulator will not work—we cannot proceed with one
subtree until we know the result of the other.</p>
<p>This seems like an impossible situation. How can we make a function
tail recursive when it inherently needs to explore two branches? The
answer involves a technique called <em>continuation passing style</em>,
which we explore in the next section.</p>
<h3 id="note-on-lazy-languages">Note on Lazy Languages</h3>
<p>The issue of tail recursion is more nuanced for <strong>lazy</strong>
programming languages like Haskell. In a lazy language, expressions are
only evaluated when their values are actually needed. The cons operation
<code>(:)</code> does not immediately evaluate its arguments—it just
builds a “promise” to compute them later.</p>
<p>This means that building a list with <code>n : unfold (n-1)</code>
does not consume stack space in the same way as in OCaml. The
<code>unfold (n-1)</code> is not evaluated immediately; it is just
stored as an unevaluated expression (called a “thunk”). Stack space is
only consumed later, when you actually traverse the list. This gives
lazy languages different performance characteristics and trade-offs.</p>
<h2 id="first-encounter-of-continuation-passing-style">3.5 First
Encounter of Continuation Passing Style</h2>
<p>We can solve the tree depth problem using <strong>Continuation
Passing Style (CPS)</strong>. This is a powerful technique that
transforms programs in a surprising way: instead of returning values,
functions receive an extra argument—a <em>continuation</em>—that tells
them what to do with their result.</p>
<p>The key idea is to postpone doing actual work until the very last
moment by passing around a continuation—a function that represents “what
to do next with this result.”</p>
<div class="sourceCode" id="cb79"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> depth_cps tree k = <span class="kw">match</span> tree <span class="kw">with</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>  | Tip -&gt; k <span class="dv">0</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>  | Node(_, left, right) -&gt;</span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>    depth_cps left (<span class="kw">fun</span> dleft -&gt;</span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>      depth_cps right (<span class="kw">fun</span> dright -&gt;</span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>        k (<span class="dv">1</span> + (<span class="dt">max</span> dleft dright))))</span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> depth tree = depth_cps tree (<span class="kw">fun</span> d -&gt; d)</span></code></pre></div>
<p>Let us understand how this works step by step:</p>
<ol type="1">
<li><p><strong>The continuation parameter:</strong> The function takes
an extra parameter <code>k</code>, called the
<strong>continuation</strong>. Instead of returning a value directly,
<code>depth_cps</code> will call <code>k</code> with its result. You can
think of <code>k</code> as meaning “and then do this with the
answer.”</p></li>
<li><p><strong>The base case (<code>Tip</code>):</strong> When we reach
a leaf, the depth is 0. Instead of returning 0, we call
<code>k 0</code>—“give 0 to whoever is waiting for our answer.”</p></li>
<li><p><strong>The recursive case (<code>Node</code>):</strong> This is
where CPS shines. We need to compute depths of both subtrees and combine
them. Here is how we do it:</p>
<ul>
<li>First, recursively compute the depth of the left subtree. But
instead of waiting for the result, we pass a continuation:
<code>fun dleft -&gt; ...</code></li>
<li>This continuation says “when you have the left depth (call it
<code>dleft</code>), then…”</li>
<li>…compute the depth of the right subtree, passing another
continuation: <code>fun dright -&gt; ...</code></li>
<li>This inner continuation says “when you have the right depth (call it
<code>dright</code>), then…”</li>
<li>…finally call the original continuation <code>k</code> with the
combined result <code>1 + max dleft dright</code></li>
</ul></li>
<li><p><strong>The wrapper function:</strong> To use
<code>depth_cps</code>, we need to provide an initial continuation. We
pass the identity function <code>fun d -&gt; d</code>, which just
returns whatever it receives. This is the “final consumer” of the
result.</p></li>
</ol>
<p>The magic is that <em>every recursive call is now a tail call</em>!
Look carefully: <code>depth_cps left (...)</code> is the last thing the
function does in that branch—everything else is inside the continuation,
which will be called later.</p>
<p>Where does the “pending work” go? Instead of being stored on the call
stack, it is captured in the continuation closures. These closures are
allocated on the heap. We have traded stack space for heap space.</p>
<p><strong>Important caveat:</strong> This does not completely solve the
stack overflow problem—we are just moving the problem from the stack to
the heap. For very deep trees, the continuation closures can grow very
large, potentially exhausting memory. True solutions for extreme cases
involve techniques like <em>trampolining</em> (returning control to a
loop) or using explicit data structures to represent the pending work.
Nevertheless, CPS is often more space-efficient than direct recursion,
and it is a fundamental technique that appears throughout functional
programming.</p>
<p>We will encounter CPS again when studying monads and advanced control
flow, where it provides the foundation for powerful abstractions.</p>
<h2 id="exercises-2">3.6 Exercises</h2>
<p>These exercises will help you practice the concepts from this
chapter: function composition, reduction semantics, tail recursion, and
continuation passing style.</p>
<p><strong>Exercise 1: Tree Traversals</strong></p>
<p>By “traverse a tree” below we mean: write a function that takes a
tree and returns a list of values in the nodes of the tree. Use the
<code>btree</code> type defined earlier.</p>
<ol type="1">
<li><p>Write a function (of type <code>btree -&gt; int list</code>) that
traverses a binary tree in <strong>prefix order</strong> (also called
<em>preorder</em>)—first the value stored in a node, then values in all
nodes to the left, then values in all nodes to the right.</p></li>
<li><p>Write a traversal in <strong>infix order</strong> (also called
<em>inorder</em>)—first values in all nodes to the left, then the value
stored in the node, then values in all nodes to the right. For a binary
search tree, this would give you the elements in sorted order.</p></li>
<li><p>Write a traversal in <strong>breadth-first order</strong> (also
called <em>level order</em>)—visit all nodes at depth 0, then all nodes
at depth 1, and so on. Hint: you will need an auxiliary data structure
(a queue) to keep track of nodes to visit.</p></li>
</ol>
<p><strong>Exercise 2: CPS Transformation</strong></p>
<p>Turn the function from Exercise 1 (prefix or infix traversal) into
continuation passing style. Compare the structure of your CPS version to
the original. What are the trade-offs?</p>
<p><strong>Exercise 3: Tree Derivatives Revisited</strong></p>
<p>Do the homework from the end of Chapter 2: write
<code>btree_deriv_at</code> that takes a predicate over integers and a
<code>btree</code>, and builds a <code>btree_deriv</code> whose “hole”
is in the first position (using your chosen traversal order) for which
the predicate returns true.</p>
<p><strong>Exercise 4: Expression Simplification</strong></p>
<p>Write a function <code>simplify: expression -&gt; expression</code>
that simplifies symbolic expressions, so that for example the result of
<code>simplify (deriv exp dv)</code> looks more like what a human would
get computing the derivative of <code>exp</code> with respect to
<code>dv</code>.</p>
<p>Some simplifications to consider: - <span class="math inline">0 + x =
x</span> and <span class="math inline">x + 0 = x</span> - <span
class="math inline">0 \cdot x = 0</span> and <span class="math inline">x
\cdot 0 = 0</span> - <span class="math inline">1 \cdot x = x</span> and
<span class="math inline">x \cdot 1 = x</span> - <span
class="math inline">x - 0 = x</span> - <span class="math inline">x / 1 =
x</span></p>
<p>Approach this in two steps: 1. Write a <code>simplify_once</code>
function that performs a single “pass” of simplification over the
expression tree. 2. Wrap it using a general <code>fixpoint</code>
function that performs an operation until a <strong>fixed point</strong>
is reached: given <span class="math inline">f</span> and <span
class="math inline">x</span>, it computes <span
class="math inline">f^n(x)</span> such that <span
class="math inline">f^n(x) = f^{n+1}(x)</span> (i.e., applying <span
class="math inline">f</span> one more time does not change the
result).</p>
<p>Why do we need iteration to a fixed point rather than a single
pass?</p>
<p><strong>Exercise 5: Sorting Algorithms</strong></p>
<p>Write two sorting algorithms working on lists: merge sort and
quicksort.</p>
<ol type="1">
<li><p><strong>Merge sort</strong> splits the list roughly in half,
sorts the parts recursively, and merges the sorted parts into the sorted
result. You will need a helper function to merge two sorted
lists.</p></li>
<li><p><strong>Quicksort</strong> splits the list into elements smaller
than and greater-than-or-equal-to the first element (the “pivot”), sorts
the parts recursively, and concatenates them.</p></li>
</ol>
<p>Which of these algorithms can be implemented in a tail-recursive
manner? What about the helper functions (merge, partition)?</p>
<h1 id="chapter-4-functions">Chapter 4: Functions</h1>
<p><em>Programming in untyped lambda-calculus</em></p>
<p><strong>In this chapter, you will:</strong></p>
<ul>
<li>Rehearse reduction-by-hand on a non-trivial recursive program</li>
<li>Learn the syntax and <span
class="math inline">\beta</span>-reduction rules of the untyped
lambda-calculus</li>
<li>Encode booleans, pairs, naturals, lists, and trees using functions
alone</li>
<li>Understand recursion via fixpoint combinators (and how evaluation
order matters)</li>
</ul>
<p>This chapter explores the theoretical foundations of functional
programming through the untyped lambda-calculus. We embark on a
fascinating journey that reveals a surprising truth: every computation
can be expressed using nothing but functions. No numbers, no booleans,
no data structures—just functions all the way down.</p>
<p>We begin with a review of computation by hand using our reduction
semantics, then introduce the lambda-calculus notation and show how to
encode fundamental data types—booleans, pairs, and natural numbers—using
only functions. The chapter concludes with an examination of recursion
through fixpoint combinators and practical considerations for avoiding
infinite loops in eager evaluation.</p>
<p><strong>References:</strong></p>
<ul>
<li>“Introduction to Lambda Calculus” by Henk Barendregt and Erik
Barendsen</li>
<li>“Lecture Notes on the Lambda Calculus” by Peter Selinger</li>
</ul>
<h2 id="review-computation-by-hand">4.1 Review: Computation by Hand</h2>
<p>Before diving into the lambda-calculus, let us work through a
complete example of evaluation using the reduction rules from Chapter 3.
Computing a larger, recursive program by hand will solidify our
understanding of how computation proceeds step by step and prepare us
for the more abstract setting of lambda-calculus.</p>
<p>Recall that we use <code>fix</code> instead of <code>let rec</code>
to simplify our rules for recursion. Also remember our syntactic
conventions: <code>fun x y -&gt; e</code> stands for
<code>fun x -&gt; (fun y -&gt; e)</code>, and so forth.</p>
<p>Consider the following recursive <code>length</code> function applied
to a two-element list:</p>
<div class="sourceCode" id="cb80"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fix f x = f (fix f) x</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> int_list = Nil | Cons <span class="kw">of</span> <span class="dt">int</span> * int_list</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> length =</span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a>  fix (<span class="kw">fun</span> f l -&gt;</span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a>    | Nil -&gt; <span class="dv">0</span></span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a>    | Cons (_x, xs) -&gt; <span class="dv">1</span> + f xs)</span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb80-11"><a href="#cb80-11" aria-hidden="true" tabindex="-1"></a>length (Cons (<span class="dv">1</span>, (Cons (<span class="dv">2</span>, Nil))))</span></code></pre></div>
<p>Let us trace through this computation step by step. First, we
eliminate the <code>let ... in ...</code> binding for
<code>length</code>:</p>
<p><span class="math display">\texttt{let } x = v \texttt{ in } a
\rightsquigarrow a[x := v]</span></p>
<p>This gives us:</p>
<pre><code>fix (fun f l -&gt;
    match l with
      | Nil -&gt; 0
      | Cons (x, xs) -&gt; 1 + f xs) (Cons (1, (Cons (2, Nil))))</code></pre>
<p>Next, we apply the <code>fix</code> rule:</p>
<p><span class="math display">\texttt{fix}^2 \; v_1 \; v_2
\rightsquigarrow v_1 \; (\texttt{fix}^2 \; v_1) \; v_2</span></p>
<p>This unfolds to:</p>
<pre><code>(fun f l -&gt;
    match l with
      | Nil -&gt; 0
      | Cons (x, xs) -&gt; 1 + f xs)
    (fix (fun f l -&gt;
      match l with
        | Nil -&gt; 0
        | Cons (x, xs) -&gt; 1 + f xs))
    (Cons (1, (Cons (2, Nil))))</code></pre>
<p>Function application reduces according to:</p>
<p><span class="math display">(\texttt{fun } x \texttt{ -&gt; } a) \; v
\rightsquigarrow a[x := v]</span></p>
<p>After substituting both <code>f</code> and <code>l</code>, we
get:</p>
<pre><code>(match Cons (1, (Cons (2, Nil))) with
    | Nil -&gt; 0
    | Cons (x, xs) -&gt; 1 + (fix (fun f l -&gt;
      match l with
        | Nil -&gt; 0
        | Cons (x, xs) -&gt; 1 + f xs)) xs)</code></pre>
<p>Pattern matching against a non-matching constructor moves to the next
branch:</p>
<p><span class="math display">
\begin{aligned}
&amp; \texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{ with} \\
&amp; C_2^n(p_1, \ldots, p_k) \texttt{ -&gt; } a \texttt{ | } pm
\rightsquigarrow \texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{ with }
pm
\end{aligned}
</span></p>
<p>Pattern matching against a matching constructor performs
substitution:</p>
<p><span class="math display">
\begin{aligned}
&amp; \texttt{match } C_1^n(v_1, \ldots, v_n) \texttt{ with} \\
&amp; C_1^n(x_1, \ldots, x_n) \texttt{ -&gt; } a \texttt{ | } \ldots
\rightsquigarrow a[x_1 := v_1; \ldots; x_n := v_n]
\end{aligned}
</span></p>
<p>After matching and substitution:</p>
<pre><code>1 + (fix (fun f l -&gt;
      match l with
        | Nil -&gt; 0
        | Cons (x, xs) -&gt; 1 + f xs)) (Cons (2, Nil))</code></pre>
<p>Continuing the evaluation, we apply <code>fix</code> again and work
through the pattern match for <code>Cons (2, Nil)</code>, eventually
reaching:</p>
<pre><code>1 + (1 + (fix (fun f l -&gt;
             match l with
               | Nil -&gt; 0
               | Cons (x, xs) -&gt; 1 + f xs)) Nil)</code></pre>
<p>One more unfolding and pattern match against <code>Nil</code>
gives:</p>
<pre><code>1 + (1 + 0)</code></pre>
<p>Finally, applying the built-in addition:</p>
<p><span class="math display">f^n \; v_1 \; \ldots \; v_n
\rightsquigarrow f(v_1, \ldots, v_n)</span></p>
<p>We obtain the result: <code>2</code>.</p>
<h2 id="language-and-rules-of-the-untyped-lambda-calculus">4.2 Language
and Rules of the Untyped Lambda-Calculus</h2>
<p>The lambda-calculus, introduced by Alonzo Church in the 1930s, is a
minimal formal system for expressing computation. It may seem surprising
that such a stripped-down language can be computationally complete, but
that is precisely what we will demonstrate in this chapter. To work with
lambda-calculus, we first simplify our language in several ways:</p>
<ol type="1">
<li><p><strong>Forget about types.</strong> In pure lambda-calculus,
there is no type system constraining which terms can be combined. Any
function can be applied to any argument—including itself!</p></li>
<li><p><strong>Introduce notation.</strong> We write <span
class="math inline">\lambda x.a</span> for <code>fun x -&gt; a</code>,
and <span class="math inline">\lambda xy.a</span> for
<code>fun x y -&gt; a</code>, and so forth. This notation is more
compact and traditional in the literature.</p></li>
<li><p><strong>Reduce to essentials.</strong> We keep only functions
(lambda abstractions) and variables—no constructors, no built-in
primitives. Everything else will be <em>encoded</em> using
functions.</p></li>
</ol>
<p>The core reduction rule of lambda-calculus is called <strong><span
class="math inline">\beta</span>-reduction</strong>:</p>
<p><span class="math display">(\texttt{fun } x \texttt{ -&gt; } a_1) \;
a_2 \rightsquigarrow a_1[x := a_2]</span></p>
<p>Note that this rule is more general than the one we use for OCaml
evaluation. In our OCaml semantics, we require the argument to be a
value: <span class="math inline">(\texttt{fun } x \texttt{ -&gt; } a) \;
v \rightsquigarrow a[x := v]</span>. The general <span
class="math inline">\beta</span>-reduction rule allows substituting any
expression, not just values.</p>
<p>Lambda-calculus also uses <strong><span
class="math inline">\alpha</span>-conversion</strong> (bound variable
renaming), or equivalent techniques, to avoid <strong>variable
capture</strong>—the unintended binding of free variables during
substitution. We will explore the implications of <span
class="math inline">\beta</span>-reduction more deeply in the chapter on
laziness.</p>
<p>Why is <span class="math inline">\beta</span>-reduction more general
than our evaluation rule? Consider the expression <span
class="math inline">(\lambda x. x) \; ((\lambda y. y) \; z)</span>. With
<span class="math inline">\beta</span>-reduction, we could reduce the
outer application first, obtaining <span class="math inline">((\lambda
y. y) \; z)</span>. Our evaluation rule would require first reducing the
argument to a value—but here <code>z</code> is a free variable, not a
value, so we would be stuck!</p>
<p>This example is intentionally an <em>open term</em> (it has a free
variable <code>z</code>): in lambda-calculus we often reason about open
terms up to <span class="math inline">\beta</span>-equivalence, while
programming-language evaluation is usually defined for <em>closed</em>
programs.</p>
<h2 id="booleans">4.3 Booleans</h2>
<p>Alonzo Church originally introduced lambda-calculus as a foundation
for logic, seeking to encode logical reasoning in a purely computational
form. There are multiple ways to encode various sorts of data in
lambda-calculus, though not all of them work well in a typed setting—the
straightforward encode/decode functions may not type-check for some
encodings.</p>
<p>The key insight behind the <strong>Church encoding</strong> of
booleans is to represent truth values as <em>selector functions</em>.
Think about what a boolean fundamentally does: it chooses between two
alternatives. So we define:</p>
<ul>
<li><strong>True</strong> selects the first argument:
<code>c_true</code> <span class="math inline">= \lambda xy.x</span></li>
<li><strong>False</strong> selects the second argument:
<code>c_false</code> <span class="math inline">= \lambda
xy.y</span></li>
</ul>
<p>In OCaml syntax:</p>
<div class="sourceCode" id="cb87"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c_true = <span class="kw">fun</span> x y -&gt; x   <span class="co">(* &quot;True&quot; is projection on the first argument *)</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c_false = <span class="kw">fun</span> x y -&gt; y  <span class="co">(* And &quot;false&quot; on the second argument *)</span></span></code></pre></div>
<p>Once we have booleans as selectors, logical operations become
elegant. Logical conjunction can be defined as:</p>
<p><span class="math display">\texttt{c\_and} = \lambda xy. x \; y \;
\texttt{c\_false}</span></p>
<p>The logic behind this definition is beautifully simple: we apply
<code>x</code> (which is a selector) to two arguments. If <code>x</code>
is true, it selects its first argument, which is <code>y</code>—so the
result is true only if both <code>x</code> and <code>y</code> are true.
If <code>x</code> is false, it selects its second argument,
<code>c_false</code>, and returns false immediately without even looking
at <code>y</code>.</p>
<div class="sourceCode" id="cb88"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c_and = <span class="kw">fun</span> x y -&gt; x y c_false  <span class="co">(* If one is false, then return false *)</span></span></code></pre></div>
<p>Let us verify this works. For <code>c_and c_true c_true</code>:</p>
<p><span class="math display">(\lambda xy. x \; y \; \texttt{c\_false})
\; (\lambda xy.x) \; (\lambda xy.x)</span></p>
<p>reduces to:</p>
<p><span class="math display">(\lambda xy.x) \; (\lambda xy.x) \;
\texttt{c\_false}</span></p>
<p>which gives us <span class="math inline">\lambda xy.x</span> =
<code>c_true</code>. You can verify that for any other combination
involving <code>c_false</code>, the result is <code>c_false</code>.</p>
<p>To verify our encodings in OCaml, we need encode and decode
functions. The decoder works by applying our Church boolean to the
actual OCaml values <code>true</code> and <code>false</code>:</p>
<div class="sourceCode" id="cb89"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> encode_bool b = <span class="kw">if</span> b <span class="kw">then</span> c_true <span class="kw">else</span> c_false</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> decode_bool c = (<span class="dt">Obj</span>.magic c) <span class="kw">true</span> <span class="kw">false</span>  <span class="co">(* Don&#39;t enforce type on c *)</span></span></code></pre></div>
<p><strong>Exercise:</strong> Define <code>c_or</code> and
<code>c_not</code> yourself! Hint: think about what <code>c_or</code>
should return when the first argument is true, and when it is false. For
<code>c_not</code>, consider that a boolean is a function that selects
between two arguments.</p>
<h2 id="if-then-else-and-pairs">4.4 If-then-else and Pairs</h2>
<p>From now on, we will use OCaml syntax for our lambda-calculus
programs. This makes it easier to experiment with our encodings in the
toplevel.</p>
<p>An important observation is that our encoded booleans already
implement conditional selection:</p>
<div class="sourceCode" id="cb90"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> if_then_else b t e = b t e  <span class="co">(* Booleans select the branch! *)</span></span></code></pre></div>
<p>Wait—is <code>if_then_else</code> “just” the identity function? Up to
<span class="math inline">\eta</span>-equivalence, yes:
<code>fun b -&gt; b</code> and <code>fun b t e -&gt; b t e</code> are
the same function. Since <code>c_true</code> returns its first argument
and <code>c_false</code> returns its second,
<code>if_then_else b t e</code> simply applies <code>b</code> to the two
branches. The boolean <em>is</em> the conditional.</p>
<p>Remember to play with these functions in the toplevel to build
intuition. Try expressions like
<code>if_then_else c_true "yes" "no"</code> and see what happens.</p>
<h3 id="pairs">Pairs</h3>
<p>Pairs (ordered tuples of two elements) can be encoded using a similar
idea. The key insight is that a pair needs to “remember” two values and
provide them when asked. We can achieve this by creating a function that
holds onto both values and waits for a selector to choose between
them:</p>
<div class="sourceCode" id="cb91"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c_pair m n = <span class="kw">fun</span> x -&gt; x m n  <span class="co">(* We couple things *)</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c_first = <span class="kw">fun</span> p -&gt; p c_true  <span class="co">(* by passing them together *)</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c_second = <span class="kw">fun</span> p -&gt; p c_false  <span class="co">(* Check that it works! *)</span></span></code></pre></div>
<p>A pair is a function that, when given a selector, applies that
selector to both components. To extract the first component, we pass
<code>c_true</code> (which selects the first argument); to extract the
second, we pass <code>c_false</code>. Verify for yourself that
<code>c_first (c_pair a b)</code> reduces to <code>a</code>!</p>
<p>For verification:</p>
<div class="sourceCode" id="cb92"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> encode_pair enc_fst enc_snd (a, b) =</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>  c_pair (enc_fst a) (enc_snd b)</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> decode_pair de_fst de_snd c = c (<span class="kw">fun</span> x y -&gt; de_fst x, de_snd y)</span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> decode_bool_pair c = decode_pair decode_bool decode_bool c</span></code></pre></div>
<p>We can define larger tuples in the same manner:
<code>let c_triple l m n = fun x -&gt; x l m n</code></p>
<h2 id="pair-encoded-natural-numbers">4.5 Pair-Encoded Natural
Numbers</h2>
<p>Now we come to encoding numbers—a crucial test of whether functions
alone can represent all data. Our first encoding of natural numbers uses
nested pairs. The representation is based on the depth of nested pairs
whose rightmost leaf is the identity function <span
class="math inline">\lambda x.x</span> and whose left elements are
<code>c_false</code>.</p>
<div class="sourceCode" id="cb93"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pn0 = <span class="kw">fun</span> x -&gt; x           <span class="co">(* Start with the identity function *)</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pn_succ n = c_pair c_false n  <span class="co">(* Stack another pair *)</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pn_pred = <span class="kw">fun</span> x -&gt; x c_false  <span class="co">(* Extract the nested number *)</span></span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pn_is_zero = <span class="kw">fun</span> x -&gt; x c_true  <span class="co">(* Check if it&#39;s the base case *)</span></span></code></pre></div>
<p>The number 0 is represented as the identity function. The number 1 is
<code>c_pair c_false pn0</code>, the number 2 is
<code>c_pair c_false (c_pair c_false pn0)</code>, and so on. Think of it
as a stack of pairs, where the height of the stack represents the
number.</p>
<p>How do <code>pn_pred</code> and <code>pn_is_zero</code> work? Let us
think through this carefully: - The identity function <code>pn0</code>,
when applied to any argument, returns that argument. - A successor
<code>c_pair c_false n</code> is a function waiting for a selector;
applying it to <code>c_false</code> selects the second component (the
predecessor), while applying it to <code>c_true</code> selects the first
component (<code>c_false</code>).</p>
<p>So <code>pn_is_zero</code> applies the number to <code>c_true</code>:
- For <code>pn0</code>, we get <code>c_true</code> back (since
<code>pn0</code> is the identity)—the number is zero! - For any
successor, we get <code>c_false</code> back (the first component of the
pair)—the number is not zero!</p>
<p>We program in untyped lambda-calculus as an exercise, and we need
encoding/decoding to verify our work. Since these encodings do not
type-check cleanly in OCaml, using <code>Obj.magic</code> to bypass the
type system for encoding/decoding is “fair game”:</p>
<div class="sourceCode" id="cb94"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> encode_pnat n =                <span class="co">(* We use Obj.magic to forget types *)</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> <span class="dt">Obj</span>.magic pn0</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> pn_succ (<span class="dt">Obj</span>.magic (encode_pnat (n<span class="dv">-1</span>)))  <span class="co">(* Disregarding types, *)</span></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> decode_pnat pn =               <span class="co">(* these functions are straightforward! *)</span></span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> decode_bool (pn_is_zero pn) <span class="kw">then</span> <span class="dv">0</span></span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> <span class="dv">1</span> + decode_pnat (pn_pred (<span class="dt">Obj</span>.magic pn))</span></code></pre></div>
<p>Needless to say, <code>Obj.magic</code> is unsafe and should not be
used in real code; here it is only a convenient bridge from untyped
lambda-terms to OCaml so we can test our encodings.</p>
<h2 id="church-numerals">4.6 Church Numerals</h2>
<p>Do you remember our function <code>power f n</code> from Chapter 3
that composed a function with itself <code>n</code> times? We will use a
similar idea for a different, and historically important, representation
of numbers.</p>
<p><strong>Church numerals</strong> represent a natural number <span
class="math inline">n</span> as a function that applies its first
argument <span class="math inline">n</span> times to its second
argument:</p>
<div class="sourceCode" id="cb95"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn0 = <span class="kw">fun</span> f x -&gt; x        <span class="co">(* The same as c_false *)</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn1 = <span class="kw">fun</span> f x -&gt; f x      <span class="co">(* Behaves like identity when f = id *)</span></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn2 = <span class="kw">fun</span> f x -&gt; f (f x)</span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn3 = <span class="kw">fun</span> f x -&gt; f (f (f x))</span></code></pre></div>
<p>This is the original Alonzo Church encoding, and it is remarkably
elegant. The number <span class="math inline">n</span> is represented as
<span class="math inline">\lambda fx. f^n(x)</span>, where <span
class="math inline">f^n</span> denotes <span
class="math inline">n</span>-fold composition. A number literally
<em>is</em> the act of doing something <span
class="math inline">n</span> times!</p>
<p>Notice that <code>cn0</code> is the same as <code>c_false</code>—zero
applications of <code>f</code> just returns <code>x</code>.</p>
<p>The successor function adds one more application of
<code>f</code>:</p>
<div class="sourceCode" id="cb96"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn_succ = <span class="kw">fun</span> n f x -&gt; f (n f x)</span></code></pre></div>
<p><strong>Exercise:</strong> Define addition, multiplication, and
comparing to zero for Church numerals. Also try to define the
predecessor function “-1”.</p>
<p>It turns out even Alonzo Church could not define predecessor right
away! The story goes that his student Stephen Kleene figured it out
while at the dentist. Try to make some progress on addition and
multiplication first (they are not too hard), and then attempt
predecessor before looking at the solution below.</p>
<div class="sourceCode" id="cb97"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (-|) f g x = f (g x)  <span class="co">(* Backward composition operator *)</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> encode_cnat n f =</span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n &lt;= <span class="dv">0</span> <span class="kw">then</span> (<span class="kw">fun</span> x -&gt; x) <span class="kw">else</span> f -| encode_cnat (n<span class="dv">-1</span>) f</span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> decode_cnat n = n ((+) <span class="dv">1</span>) <span class="dv">0</span></span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn7 f x = encode_cnat <span class="dv">7</span> f x   <span class="co">(* We need to eta-expand these definitions *)</span></span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn13 f x = encode_cnat <span class="dv">13</span> f x  <span class="co">(* for type-system reasons *)</span></span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a>                                   <span class="co">(* (because OCaml allows side-effects) *)</span></span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn_add = <span class="kw">fun</span> n m f x -&gt; n f (m f x)  <span class="co">(* Put n of f in front *)</span></span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn_mult = <span class="kw">fun</span> n m f -&gt; n (m f)       <span class="co">(* Repeat n times *)</span></span>
<span id="cb97-11"><a href="#cb97-11" aria-hidden="true" tabindex="-1"></a>                                          <span class="co">(* putting m of f in front *)</span></span>
<span id="cb97-12"><a href="#cb97-12" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cn_prev n =</span>
<span id="cb97-13"><a href="#cb97-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fun</span> f x -&gt;</span>
<span id="cb97-14"><a href="#cb97-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* A Church numeral is an n-step iterator. Predecessor is tricky because</span></span>
<span id="cb97-15"><a href="#cb97-15" aria-hidden="true" tabindex="-1"></a><span class="co">       we cannot “subtract an iteration”; instead we build a small state</span></span>
<span id="cb97-16"><a href="#cb97-16" aria-hidden="true" tabindex="-1"></a><span class="co">       transformer that delays the use of [f] and then skips the first step. *)</span></span>
<span id="cb97-17"><a href="#cb97-17" aria-hidden="true" tabindex="-1"></a>    n</span>
<span id="cb97-18"><a href="#cb97-18" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">fun</span> g h -&gt; h (g f))</span>
<span id="cb97-19"><a href="#cb97-19" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">fun</span> _z -&gt; x)</span>
<span id="cb97-20"><a href="#cb97-20" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">fun</span> z -&gt; z)</span></code></pre></div>
<p>Addition is intuitive: to add <span class="math inline">n</span> and
<span class="math inline">m</span>, we first apply <code>f</code> <span
class="math inline">m</span> times (giving us <code>m f x</code>), then
apply <code>f</code> <span class="math inline">n</span> more times.
Multiplication is even more clever: we apply the operation “apply
<code>f</code> <span class="math inline">m</span> times” <span
class="math inline">n</span> times, which computes <span
class="math inline">m \times n</span> applications of
<code>f</code>.</p>
<p>The predecessor function is ingenious and worth studying carefully.
The challenge is that Church numerals only know how to apply
<code>f</code> more times, not fewer. Kleene’s insight was to build up a
chain of functions that, when “started” with the identity, yields <span
class="math inline">n-1</span> applications of <code>f</code>. The key
is to delay the actual application of <code>f</code> and skip the first
one.</p>
<p><code>cn_is_zero</code> is left as an exercise. Hint: what happens
when you apply zero to a function that always returns
<code>c_false</code> and start with <code>c_true</code>?</p>
<h3 id="tracing-cn_prev-cn3">Tracing <code>cn_prev cn3</code></h3>
<p>The predecessor function is tricky enough that it is worth tracing
through a complete example. Let us trace through
<code>decode_cnat (cn_prev cn3)</code> to see how it computes 2 from
3:</p>
<p><span class="math display">\rightsquigarrow^*</span></p>
<pre><code>(cn_prev cn3) ((+) 1) 0</code></pre>
<p><span class="math display">\rightsquigarrow^*</span></p>
<pre><code>(fun f x -&gt;
    cn3
      (fun g h -&gt; h (g f))
      (fun _z -&gt; x)
      (fun z -&gt; z)) ((+) 1) 0</code></pre>
<p><span class="math display">\rightsquigarrow^*</span></p>
<pre><code>((fun f x -&gt; f (f (f x)))
      (fun g h -&gt; h (g ((+) 1)))
      (fun z -&gt; 0)
      (fun z -&gt; z))</code></pre>
<p><span class="math display">\rightsquigarrow^*</span></p>
<pre><code>((fun g h -&gt; h (g ((+) 1)))
  ((fun g h -&gt; h (g ((+) 1)))
    ((fun g h -&gt; h (g ((+) 1)))
      (fun z -&gt; 0))))
  (fun z -&gt; z))</code></pre>
<p><span class="math display">\rightsquigarrow^*</span></p>
<pre><code>((fun z -&gt; z)
  (((fun g h -&gt; h (g ((+) 1)))
    ((fun g h -&gt; h (g ((+) 1)))
      (fun z -&gt; 0)))) ((+) 1)))</code></pre>
<p><span class="math display">\rightsquigarrow^*</span></p>
<pre><code>(fun g h -&gt; h (g ((+) 1)))
  ((fun g h -&gt; h (g ((+) 1)))
    (fun z -&gt; 0)) ((+) 1)</code></pre>
<p><span class="math display">\rightsquigarrow^*</span></p>
<pre><code>((+) 1) ((fun g h -&gt; h (g ((+) 1)))
          (fun z -&gt; 0) ((+) 1))</code></pre>
<p><span class="math display">\rightsquigarrow^*</span></p>
<pre><code>((+) 1) (((+) 1) ((fun z -&gt; 0) ((+) 1)))</code></pre>
<p><span class="math display">\rightsquigarrow^*</span></p>
<pre><code>((+) 1) (((+) 1) (0))</code></pre>
<p><span class="math display">\rightsquigarrow^*</span></p>
<pre><code>((+) 1) 1</code></pre>
<p><span class="math inline">\rightsquigarrow^*</span>
<code>2</code></p>
<h2 id="recursion-fixpoint-combinators">4.7 Recursion: Fixpoint
Combinators</h2>
<p>We have seen how to encode data in lambda-calculus, but how do we
encode <em>computation</em>, especially recursive computation? In
lambda-calculus, there is no <code>let rec</code> or any built-in notion
of a function referring to itself. Instead, recursion is achieved
through <strong>fixpoint combinators</strong>—remarkable lambda terms
that compute fixed points of functions.</p>
<h3 id="turings-fixpoint-combinator">Turing’s Fixpoint Combinator</h3>
<p><span class="math display">\Theta = (\lambda xy. y \; (x \; x \; y))
\; (\lambda xy. y \; (x \; x \; y))</span></p>
<p>Let us verify it computes fixed points. Define <span
class="math inline">N = \Theta F</span>:</p>
<p><span class="math display">
\begin{aligned}
N &amp;= \Theta F \\
&amp;= (\lambda xy. y \; (x \; x \; y)) \; (\lambda xy. y \; (x \; x \;
y)) \; F \\
&amp;=_{\rightarrow\rightarrow} F \; ((\lambda xy. y \; (x \; x \; y))
\; (\lambda xy. y \; (x \; x \; y)) \; F) \\
&amp;= F \; (\Theta F) = F \; N
\end{aligned}
</span></p>
<p>So <span class="math inline">N = F \; N</span>, meaning <span
class="math inline">N</span> is a fixed point of <span
class="math inline">F</span>.</p>
<h3 id="currys-fixpoint-combinator-y-combinator">Curry’s Fixpoint
Combinator (Y Combinator)</h3>
<p><span class="math display">\mathbf{Y} = \lambda f. (\lambda x. f \;
(x \; x)) \; (\lambda x. f \; (x \; x))</span></p>
<p><span class="math display">
\begin{aligned}
N &amp;= \mathbf{Y} F \\
&amp;= (\lambda f. (\lambda x. f \; (x \; x)) \; (\lambda x. f \; (x \;
x))) \; F \\
&amp;=_{\rightarrow} (\lambda x. F \; (x \; x)) \; (\lambda x. F \; (x
\; x)) \\
&amp;=_{\rightarrow} F \; ((\lambda x. F \; (x \; x)) \; (\lambda x. F
\; (x \; x))) \\
&amp;=_{\leftarrow} F \; ((\lambda f. (\lambda x. f \; (x \; x)) \;
(\lambda x. f \; (x \; x))) \; F) \\
&amp;= F \; (\mathbf{Y} F) = F \; N
\end{aligned}
</span></p>
<h3 id="call-by-value-fixpoint-combinator">Call-by-Value Fixpoint
Combinator</h3>
<p><span class="math display">\texttt{fix} = \lambda f&#39;. (\lambda
fx. f&#39; \; (f \; f) \; x) \; (\lambda fx. f&#39; \; (f \; f) \;
x)</span></p>
<p><span class="math display">
\begin{aligned}
N &amp;= \texttt{fix} \; F \\
&amp;= (\lambda f&#39;. (\lambda fx. f&#39; \; (f \; f) \; x) \;
(\lambda fx. f&#39; \; (f \; f) \; x)) \; F \\
&amp;=_{\rightarrow} (\lambda fx. F \; (f \; f) \; x) \; (\lambda fx. F
\; (f \; f) \; x) \\
&amp;=_{\rightarrow} \lambda x. F \; ((\lambda fx. F \; (f \; f) \; x)
\; (\lambda fx. F \; (f \; f) \; x)) \; x \\
&amp;=_{\leftarrow} \lambda x. F \; ((\lambda f&#39;. (\lambda fx.
f&#39; \; (f \; f) \; x) \; (\lambda fx. f&#39; \; (f \; f) \; x)) \; F)
\; x \\
&amp;= \lambda x. F \; (\texttt{fix} \; F) \; x = \lambda x. F \; N \; x
\\
&amp;=_{\eta} F \; N
\end{aligned}
</span></p>
<p>The lambda-terms we have seen above are <strong>fixpoint
combinators</strong>—the means within lambda-calculus to perform
recursion without any special recursive binding constructs.</p>
<h3 id="the-problem-with-the-first-two-combinators">The Problem with the
First Two Combinators</h3>
<p>What is the problem with Turing’s and Curry’s combinators in a
practical programming language? Consider what happens when we try to
evaluate <span class="math inline">\Theta F</span>:</p>
<p><span class="math display">
\begin{aligned}
\Theta F &amp;\rightsquigarrow\rightsquigarrow F \; ((\lambda xy. y \;
(x \; x \; y)) \; (\lambda xy. y \; (x \; x \; y)) \; F) \\
&amp;\rightsquigarrow\rightsquigarrow F \; (F \; ((\lambda xy. y \; (x
\; x \; y)) \; (\lambda xy. y \; (x \; x \; y)) \; F)) \\
&amp;\rightsquigarrow\rightsquigarrow F \; (F \; (F \; ((\lambda xy. y
\; (x \; x \; y)) \; (\lambda xy. y \; (x \; x \; y)) \; F))) \\
&amp;\rightsquigarrow\rightsquigarrow \ldots
\end{aligned}
</span></p>
<p>Recall the distinction between <em>expressions</em> and
<em>values</em> from Chapter 3 on Computation. The reduction rule for
lambda-calculus is meant to determine which expressions are considered
“equal”—it is highly <em>non-deterministic</em>, while on a computer,
computation needs to go one way or another.</p>
<p>Using the general reduction rule of lambda-calculus, for a recursive
definition, it is always possible to find an infinite reduction
sequence. Why? Because we can always choose to reduce the recursive call
first, which generates another recursive call, and so on forever. This
means a naive lambda-calculus compiler could legitimately generate
infinite loops for all recursive definitions—which would not be very
useful!</p>
<p>Therefore, we need more specific rules. Most languages use
<strong>call-by-value</strong> (also called <strong>eager</strong>
evaluation):</p>
<p><span class="math display">(\texttt{fun } x \texttt{ -&gt; } a) \; v
\rightsquigarrow a[x := v]</span></p>
<p>The program <em>eagerly</em> computes arguments before starting to
compute the function body. This is exactly the rule we introduced in the
Computation chapter.</p>
<h3 id="call-by-value-fixpoint-combinator-in-action">Call-by-Value
Fixpoint Combinator in Action</h3>
<p>What happens with the call-by-value fixpoint combinator?</p>
<p><span class="math display">
\begin{aligned}
\texttt{fix} \; F &amp;\rightsquigarrow (\lambda fx. F \; (f \; f) \; x)
\; (\lambda fx. F \; (f \; f) \; x) \\
&amp;\rightsquigarrow \lambda x. F \; ((\lambda fx. F \; (f \; f) \; x)
\; (\lambda fx. F \; (f \; f) \; x)) \; x
\end{aligned}
</span></p>
<p>The computation stops because we use the rule <span
class="math inline">(\texttt{fun } x \texttt{ -&gt; } a) \; v
\rightsquigarrow a[x := v]</span> rather than <span
class="math inline">(\texttt{fun } x \texttt{ -&gt; } a_1) \; a_2
\rightsquigarrow a_1[x := a_2]</span>. The expression inside the lambda
is not evaluated until the function is applied.</p>
<p>Let us compute the function on some input:</p>
<p><span class="math display">
\begin{aligned}
\texttt{fix} \; F \; v &amp;\rightsquigarrow (\lambda fx. F \; (f \; f)
\; x) \; (\lambda fx. F \; (f \; f) \; x) \; v \\
&amp;\rightsquigarrow (\lambda x. F \; ((\lambda fx. F \; (f \; f) \; x)
\; (\lambda fx. F \; (f \; f) \; x)) \; x) \; v \\
&amp;\rightsquigarrow F \; ((\lambda fx. F \; (f \; f) \; x) \; (\lambda
fx. F \; (f \; f) \; x)) \; v \\
&amp;\rightsquigarrow F \; (\lambda x. F \; ((\lambda fx. F \; (f \; f)
\; x) \; (\lambda fx. F \; (f \; f) \; x)) \; x) \; v \\
&amp;\rightsquigarrow \text{depends on } F
\end{aligned}
</span></p>
<h3 id="why-fixpoint">Why “Fixpoint”?</h3>
<p>If you examine our derivations, you will see they establish <span
class="math inline">x = f(x)</span>. Such values <span
class="math inline">x</span> are called <strong>fixpoints</strong> of
<span class="math inline">f</span>. An arithmetic function can have
several fixpoints—for example, <span class="math inline">f(x) =
x^2</span> has fixpoints 0 and 1 (since <span class="math inline">0^2 =
0</span> and <span class="math inline">1^2 = 1</span>)—or no fixpoints,
such as <span class="math inline">f(x) = x + 1</span> (since <span
class="math inline">x + 1 \neq x</span> for all <span
class="math inline">x</span>).</p>
<p>When you define a function (or another object) by recursion, it has a
similar meaning: the name appears on both sides of the equality. For
example, <code>fact n = if n = 0 then 1 else n * fact (n-1)</code> has
<code>fact</code> on both sides. In lambda-calculus, functions like
<span class="math inline">\Theta</span> and <span
class="math inline">\mathbf{Y}</span> take <em>any</em> function as an
argument and return its fixpoint.</p>
<p>We turn a specification of a recursive object into a definition by
solving it with respect to the recurring name: deriving <span
class="math inline">x = f(x)</span> where <span
class="math inline">x</span> is the recurring name. We then have <span
class="math inline">x = \texttt{fix}(f)</span>.</p>
<h3 id="deriving-factorial">Deriving Factorial</h3>
<p>Let us walk through this process step by step for the factorial
function. This will show how to transform a recursive specification into
a proper definition using <code>fix</code>. We omit the prefix
<code>cn_</code> (could be <code>pn_</code> if using pair-encoded
numbers) and shorten <code>if_then_else</code> to
<code>if_t_e</code>:</p>
<p><span class="math display">
\begin{aligned}
\texttt{fact} \; n &amp;= \texttt{if\_t\_e} \; (\texttt{is\_zero} \; n)
\; \texttt{cn1} \; (\texttt{mult} \; n \; (\texttt{fact} \;
(\texttt{pred} \; n))) \\
\texttt{fact} &amp;= \lambda n. \texttt{if\_t\_e} \; (\texttt{is\_zero}
\; n) \; \texttt{cn1} \; (\texttt{mult} \; n \; (\texttt{fact} \;
(\texttt{pred} \; n))) \\
\texttt{fact} &amp;= (\lambda fn. \texttt{if\_t\_e} \;
(\texttt{is\_zero} \; n) \; \texttt{cn1} \; (\texttt{mult} \; n \; (f \;
(\texttt{pred} \; n)))) \; \texttt{fact} \\
\texttt{fact} &amp;= \texttt{fix} \; (\lambda fn. \texttt{if\_t\_e} \;
(\texttt{is\_zero} \; n) \; \texttt{cn1} \; (\texttt{mult} \; n \; (f \;
(\texttt{pred} \; n))))
\end{aligned}
</span></p>
<p>The last line is a valid definition: we simply give a name to a
<em>ground</em> (also called <em>closed</em>) expression—one with no
free variables. We have already seen how <code>fix</code> works in the
reduction semantics.</p>
<p><strong>Exercise:</strong> Compute <code>fact cn2</code> by hand,
tracing through the reduction steps.</p>
<p><strong>Exercise:</strong> What does
<code>fix (fun x -&gt; cn_succ x)</code> mean? What happens if you try
to evaluate it? Think about whether there is any value <code>x</code>
such that <code>x = cn_succ x</code>.</p>
<h2 id="encoding-lists-and-trees">4.8 Encoding Lists and Trees</h2>
<p>Now that we have numbers and recursion, we can encode more complex
data structures. The pattern we have seen with booleans and pairs
extends naturally to algebraic data types like lists and trees.</p>
<p>A <strong>list</strong> is either empty (often called
<code>Empty</code> or <code>Nil</code>) or consists of an element
followed by another list (the “tail”), called <code>Cons</code>. Since
lists have two variants, we encode them with two-argument selector
functions:</p>
<ul>
<li><code>nil</code> <span class="math inline">= \lambda xy.y</span>
(select the second argument, like <code>c_false</code>)</li>
<li><code>cons</code> <span class="math inline">H \; T = \lambda xy. x
\; H \; T</span> (apply the first argument to head and tail)</li>
</ul>
<p>With these definitions, we can write a function to add all numbers
stored inside a list:</p>
<p><span class="math display">\texttt{addlist} \; l = l \; (\lambda h t.
\texttt{cn\_add} \; h \; (\texttt{addlist} \; t)) \;
\texttt{cn0}</span></p>
<p>To make a proper definition, we apply <span
class="math inline">\texttt{fix}</span> to the solution of the above
equation:</p>
<p><span class="math display">\texttt{addlist} = \texttt{fix} \;
(\lambda f l. l \; (\lambda h t. \texttt{cn\_add} \; h \; (f \; t)) \;
\texttt{cn0})</span></p>
<p>For <strong>trees</strong>, let us use a different form of binary
trees than we have seen before: instead of keeping elements in inner
nodes, we will keep elements in leaves. This is sometimes called an
“external” tree structure.</p>
<p>Again, we have two variants, so we use two-argument selector
functions:</p>
<ul>
<li><code>leaf</code> <span class="math inline">n = \lambda xy. x \;
n</span> (apply first argument to the element)</li>
<li><code>node</code> <span class="math inline">L \; R = \lambda xy. y
\; L \; R</span> (apply second argument to left and right subtrees)</li>
</ul>
<p>To add numbers stored inside a tree:</p>
<p><span class="math display">\texttt{addtree} \; t = t \; (\lambda n.n)
\; (\lambda l r. \texttt{cn\_add} \; (\texttt{addtree} \; l) \;
(\texttt{addtree} \; r))</span></p>
<p>And in solved form:</p>
<p><span class="math display">\texttt{addtree} = \texttt{fix} \;
(\lambda f t. t \; (\lambda n.n) \; (\lambda l r. \texttt{cn\_add} \; (f
\; l) \; (f \; r)))</span></p>
<div class="sourceCode" id="cb108"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fix f x = f (fix f) x</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> nil = <span class="kw">fun</span> x y -&gt; y</span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cons h t = <span class="kw">fun</span> x y -&gt; x h t</span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> addlist l =</span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a>  fix (<span class="kw">fun</span> f l -&gt; l (<span class="kw">fun</span> h t -&gt; cn_add h (f t)) cn0) l</span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a>;;</span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a>decode_cnat</span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a>  (addlist (cons cn1 (cons cn2 (cons cn7 nil))));;</span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> leaf n = <span class="kw">fun</span> x y -&gt; x n</span>
<span id="cb108-10"><a href="#cb108-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> node l r = <span class="kw">fun</span> x y -&gt; y l r</span>
<span id="cb108-11"><a href="#cb108-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> addtree t =</span>
<span id="cb108-12"><a href="#cb108-12" aria-hidden="true" tabindex="-1"></a>  fix (<span class="kw">fun</span> f t -&gt;</span>
<span id="cb108-13"><a href="#cb108-13" aria-hidden="true" tabindex="-1"></a>    t (<span class="kw">fun</span> n -&gt; n) (<span class="kw">fun</span> l r -&gt; cn_add (f l) (f r))</span>
<span id="cb108-14"><a href="#cb108-14" aria-hidden="true" tabindex="-1"></a>  ) t</span>
<span id="cb108-15"><a href="#cb108-15" aria-hidden="true" tabindex="-1"></a>;;</span>
<span id="cb108-16"><a href="#cb108-16" aria-hidden="true" tabindex="-1"></a>decode_cnat</span>
<span id="cb108-17"><a href="#cb108-17" aria-hidden="true" tabindex="-1"></a>  (addtree (node (node (leaf cn3) (leaf cn7))</span>
<span id="cb108-18"><a href="#cb108-18" aria-hidden="true" tabindex="-1"></a>              (leaf cn1)));;</span></code></pre></div>
<h3 id="the-general-pattern">The General Pattern</h3>
<p>If you look back at our encodings, you will observe a consistent
pattern: when we encode a variant type with <span
class="math inline">n</span> variants, for each variant we define a
function that takes <span class="math inline">n</span> arguments.</p>
<p>If the <span class="math inline">k</span>th variant <span
class="math inline">C_k</span> has <span class="math inline">m_k</span>
parameters, then the function <span class="math inline">c_k</span> that
encodes it has the form:</p>
<p><span class="math display">C_k(v_1, \ldots, v_{m_k}) \sim c_k \; v_1
\; \ldots \; v_{m_k} = \lambda x_1 \ldots x_n. x_k \; v_1 \; \ldots \;
v_{m_k}</span></p>
<p>The encoded variants serve as shallow pattern matching with
guaranteed exhaustiveness: the <span class="math inline">k</span>th
argument corresponds to the <span class="math inline">k</span>th branch
of pattern matching. This is exactly how <code>match</code> works in
OCaml, but encoded purely with functions!</p>
<h2 id="looping-recursion">4.9 Looping Recursion</h2>
<p>We have been coding in untyped lambda-calculus and verifying our code
works in OCaml. But there is a subtle trap we must be aware of when
combining lambda-calculus encodings with OCaml’s eager evaluation.</p>
<p>Let us return to pair-encoded numbers and define addition:</p>
<div class="sourceCode" id="cb109"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pn_add m n =</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>  fix (<span class="kw">fun</span> f m n -&gt;</span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a>    if_then_else (pn_is_zero m)</span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a>      n (pn_succ (f (pn_pred m) n))</span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a>  ) m n;;</span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a>decode_pnat (pn_add pn3 pn3);;</span></code></pre></div>
<p>Oops… OCaml says:
<code>Stack overflow during evaluation (looping recursion?).</code></p>
<p>What went wrong? Nothing as far as lambda-calculus is concerned—the
definition is mathematically correct. But OCaml (and F#) always compute
arguments before calling a function. This is the <em>eager</em>
evaluation strategy we discussed earlier. By definition of
<code>fix</code>, <code>f</code> corresponds to recursively calling
<code>pn_add</code>. Therefore, <code>(pn_succ (f (pn_pred m) n))</code>
will be evaluated regardless of what <code>(pn_is_zero m)</code>
returns!</p>
<p>In other words, even when <code>m</code> is zero and we should return
<code>n</code>, OCaml first tries to compute the “else” branch, which
makes a recursive call, which computes its “else” branch, and so on
forever.</p>
<p>Why do <code>addlist</code> and <code>addtree</code> work? Look at
them carefully: their recursive calls are “guarded” by corresponding
<code>fun</code>. The expression
<code>(fun h t -&gt; cn_add h (f t))</code> does not immediately call
<code>f</code>—it creates a function that will call <code>f</code> only
when that function is applied to arguments. What is inside of
<code>fun</code> is not computed immediately—only when the function is
applied to argument(s).</p>
<p>To avoid looping recursion, you need to guard all recursive calls.
Besides putting them inside <code>fun</code>, in OCaml or F# you can
also put them in branches of a <code>match</code> clause, as long as one
of the branches does not have unguarded recursive calls.</p>
<p>The trick for functions like <code>if_then_else</code> is to guard
their arguments with <code>fun x -&gt;</code>, where <code>x</code> is
not used, and apply the <em>result</em> of <code>if_then_else</code> to
some dummy value. This delays the evaluation of both branches until the
boolean has selected one of them:</p>
<div class="sourceCode" id="cb110"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> id x = x</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fix f x = f (fix f) x</span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pn1 x = pn_succ pn0 x</span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pn2 x = pn_succ pn1 x</span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pn3 x = pn_succ pn2 x</span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pn7 x = encode_pnat <span class="dv">7</span> x</span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pn_add m n =</span>
<span id="cb110-8"><a href="#cb110-8" aria-hidden="true" tabindex="-1"></a>  fix (<span class="kw">fun</span> f m n -&gt;</span>
<span id="cb110-9"><a href="#cb110-9" aria-hidden="true" tabindex="-1"></a>    (if_then_else (pn_is_zero m)</span>
<span id="cb110-10"><a href="#cb110-10" aria-hidden="true" tabindex="-1"></a>       (<span class="kw">fun</span> x -&gt; n) (<span class="kw">fun</span> x -&gt; pn_succ (f (pn_pred m) n)))</span>
<span id="cb110-11"><a href="#cb110-11" aria-hidden="true" tabindex="-1"></a>      id</span>
<span id="cb110-12"><a href="#cb110-12" aria-hidden="true" tabindex="-1"></a>  ) m n;;</span>
<span id="cb110-13"><a href="#cb110-13" aria-hidden="true" tabindex="-1"></a>decode_pnat (pn_add pn3 pn3);;</span>
<span id="cb110-14"><a href="#cb110-14" aria-hidden="true" tabindex="-1"></a>decode_pnat (pn_add pn3 pn7);;</span></code></pre></div>
<p>Now the recursive call is wrapped in <code>fun x -&gt;</code>, so it
is not evaluated until <code>if_then_else</code> selects the second
branch and applies it to <code>id</code>. When <code>m</code> is zero,
the first branch <code>(fun x -&gt; n)</code> is selected and applied to
<code>id</code>, giving us <code>n</code> without ever touching the
recursive call.</p>
<p>In OCaml or F# we would typically guard by <code>fun () -&gt;</code>
and then apply to <code>()</code>, but we do not have datatypes like
<code>unit</code> in pure lambda-calculus, so we use <code>id</code> as
our dummy value.</p>
<h2 id="exercises-3">4.10 Exercises</h2>
<p>The following exercises will help solidify your understanding of
lambda-calculus encodings. For each exercise involving lambda-calculus,
test your implementation by encoding some inputs, applying your
function, and decoding the result.</p>
<p><strong>Exercise 1:</strong> Define (implement) and test on a couple
of examples functions corresponding to or computing:</p>
<ol type="1">
<li><code>c_or</code> and <code>c_not</code>;</li>
<li>exponentiation for Church numerals;</li>
<li>is-zero predicate for Church numerals;</li>
<li>even-number predicate for Church numerals;</li>
<li>multiplication for pair-encoded natural numbers;</li>
<li>factorial <span class="math inline">n!</span> for pair-encoded
natural numbers;</li>
<li>the length of a list (in Church numerals);</li>
<li><code>cn_max</code> – maximum of two Church numerals;</li>
<li>the depth of a tree (in Church numerals).</li>
</ol>
<p><strong>Exercise 2:</strong> Construct lambda-terms <span
class="math inline">m_0, m_1, \ldots</span> such that for all <span
class="math inline">n</span> one has:</p>
<p><span class="math display">
\begin{aligned}
m_0 &amp;= x \\
m_{n+1} &amp;= m_{n+2} \; m_n
\end{aligned}
</span></p>
<p>(where equality is after performing <span
class="math inline">\beta</span>-reductions).</p>
<p><strong>Exercise 3:</strong> Representing side-effects as an
explicitly “passed around” state value, write (higher-order) functions
that represent the imperative constructs:</p>
<ol type="1">
<li><code>for</code>…<code>to</code>…</li>
<li><code>for</code>…<code>downto</code>…</li>
<li><code>while</code>…<code>do</code>…</li>
<li><code>do</code>…<code>while</code>…</li>
<li><code>repeat</code>…<code>until</code>…</li>
</ol>
<p>Rather than writing a lambda-term using the encodings that we have
learnt, just implement the functions in OCaml / F#, using built-in
<code>int</code> and <code>bool</code> types. You can use
<code>let rec</code> instead of <code>fix</code>.</p>
<ul>
<li>For example, in exercise (a), write a function
<code>let rec for_to f beg_i end_i s = ...</code> where <code>f</code>
takes arguments <code>i</code> ranging from <code>beg_i</code> to
<code>end_i</code>, state <code>s</code> at given step, and returns
state <code>s</code> at next step; the <code>for_to</code> function
returns the state after the last step.</li>
<li>And in exercise (c), write a function
<code>let rec while_do p f s = ...</code> where both <code>p</code> and
<code>f</code> take state <code>s</code> at given step, and if
<code>p s</code> returns true, then <code>f s</code> is computed to
obtain state at next step; the <code>while_do</code> function returns
the state after the last step.</li>
</ul>
<p>Do not use the imperative features of OCaml and F#! This exercise
demonstrates that imperative control flow can be encoded purely
functionally by threading state through function calls.</p>
<p>Although we will not cover imperative features in this course, it is
instructive to see the implementation using them, to better understand
what is actually required of a solution to Exercise 3:</p>
<div class="sourceCode" id="cb111"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* (a) *)</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> for_to f beg_i end_i s =</span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s = <span class="dt">ref</span> s <span class="kw">in</span></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">for</span> i = beg_i <span class="kw">to</span> end_i <span class="kw">do</span></span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a>    s := f i !s</span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span>;</span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a>  !s</span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-9"><a href="#cb111-9" aria-hidden="true" tabindex="-1"></a><span class="co">(* (b) *)</span></span>
<span id="cb111-10"><a href="#cb111-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> for_downto f beg_i end_i s =</span>
<span id="cb111-11"><a href="#cb111-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s = <span class="dt">ref</span> s <span class="kw">in</span></span>
<span id="cb111-12"><a href="#cb111-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">for</span> i = beg_i <span class="kw">downto</span> end_i <span class="kw">do</span></span>
<span id="cb111-13"><a href="#cb111-13" aria-hidden="true" tabindex="-1"></a>    s := f i !s</span>
<span id="cb111-14"><a href="#cb111-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span>;</span>
<span id="cb111-15"><a href="#cb111-15" aria-hidden="true" tabindex="-1"></a>  !s</span>
<span id="cb111-16"><a href="#cb111-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-17"><a href="#cb111-17" aria-hidden="true" tabindex="-1"></a><span class="co">(* (c) *)</span></span>
<span id="cb111-18"><a href="#cb111-18" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> while_do p f s =</span>
<span id="cb111-19"><a href="#cb111-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s = <span class="dt">ref</span> s <span class="kw">in</span></span>
<span id="cb111-20"><a href="#cb111-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">while</span> p !s <span class="kw">do</span></span>
<span id="cb111-21"><a href="#cb111-21" aria-hidden="true" tabindex="-1"></a>    s := f !s</span>
<span id="cb111-22"><a href="#cb111-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span>;</span>
<span id="cb111-23"><a href="#cb111-23" aria-hidden="true" tabindex="-1"></a>  !s</span>
<span id="cb111-24"><a href="#cb111-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-25"><a href="#cb111-25" aria-hidden="true" tabindex="-1"></a><span class="co">(* (d) *)</span></span>
<span id="cb111-26"><a href="#cb111-26" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> do_while p f s =</span>
<span id="cb111-27"><a href="#cb111-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s = <span class="dt">ref</span> (f s) <span class="kw">in</span></span>
<span id="cb111-28"><a href="#cb111-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">while</span> p !s <span class="kw">do</span></span>
<span id="cb111-29"><a href="#cb111-29" aria-hidden="true" tabindex="-1"></a>    s := f !s</span>
<span id="cb111-30"><a href="#cb111-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span>;</span>
<span id="cb111-31"><a href="#cb111-31" aria-hidden="true" tabindex="-1"></a>  !s</span>
<span id="cb111-32"><a href="#cb111-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-33"><a href="#cb111-33" aria-hidden="true" tabindex="-1"></a><span class="co">(* (e) *)</span></span>
<span id="cb111-34"><a href="#cb111-34" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> repeat_until p f s =</span>
<span id="cb111-35"><a href="#cb111-35" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s = <span class="dt">ref</span> (f s) <span class="kw">in</span></span>
<span id="cb111-36"><a href="#cb111-36" aria-hidden="true" tabindex="-1"></a>  <span class="kw">while</span> <span class="dt">not</span> (p !s) <span class="kw">do</span></span>
<span id="cb111-37"><a href="#cb111-37" aria-hidden="true" tabindex="-1"></a>    s := f !s</span>
<span id="cb111-38"><a href="#cb111-38" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span>;</span>
<span id="cb111-39"><a href="#cb111-39" aria-hidden="true" tabindex="-1"></a>  !s</span></code></pre></div>
<h1 id="chapter-5-polymorphism-and-abstract-data-types">Chapter 5:
Polymorphism and Abstract Data Types</h1>
<p><strong>In this chapter, you will:</strong></p>
<ul>
<li>Understand “unknowns vs parameters” in OCaml’s inferred types (and
why the value restriction exists)</li>
<li>Connect type inference to solving constraint systems (unification
intuition)</li>
<li>Use parametric types to design reusable, type-safe data
structures</li>
<li>Specify ADTs algebraically and implement maps with increasing
efficiency (lists → BSTs → red-black trees)</li>
</ul>
<p>This chapter explores how OCaml’s type system supports generic
programming through parametric polymorphism, and how abstract data types
provide clean interfaces for data structures. We begin by examining how
type inference actually works – the process by which OCaml determines
types for your code. Then we explore parametric types and show how they
enable polymorphic functions to work with data of any shape. The second
half of the chapter introduces algebraic specifications, the
mathematical foundation for describing data structures, and applies
these concepts to build progressively more sophisticated implementations
of the map (dictionary) data structure, culminating in the elegant
red-black tree.</p>
<p><em>Reader feedback welcome: if you spot an error or unclear passage,
please report it.</em></p>
<h2 id="type-inference">5.1 Type Inference</h2>
<p>We have seen the rules that govern the assignment of types to
expressions, but how does OCaml actually guess what types to use? And
how does it know when no correct types exist? The answer lies in a
beautiful algorithm: OCaml solves equations. When you write code, the
type checker generates a set of equations that must hold for the program
to be well-typed, and then it solves those equations to discover the
types.</p>
<h3 id="variables-unknowns-and-parameters">Variables: Unknowns and
Parameters</h3>
<p>Variables in type inference play two distinct roles, and
understanding this distinction is crucial for mastering OCaml’s type
system. A type variable can be either an <em>unknown</em> (standing for
a specific but not-yet-determined type) or a <em>parameter</em>
(standing for any type whatsoever).</p>
<p>Consider this example:</p>
<div class="sourceCode" id="cb112"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> f = <span class="dt">List</span>.hd;;</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : &#39;a <span class="dt">list</span> -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
<p>Here <code>'a</code> is a <em>parameter</em>: it can become any type.
When you use <code>f</code> with a list of integers, <code>'a</code>
becomes <code>int</code>; when you use it with a list of strings,
<code>'a</code> becomes <code>string</code>. Mathematically we write:
<span class="math inline">f : \forall \alpha . \alpha \ \text{list}
\rightarrow \alpha</span> – the quantified type is called a <em>type
scheme</em>. The <span class="math inline">\forall</span> symbol
indicates that this type works “for all” choices of <span
class="math inline">\alpha</span>.</p>
<p>In contrast, consider this example:</p>
<div class="sourceCode" id="cb113"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> x = <span class="dt">ref</span> [];;</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> x : &#39;_weak1 <span class="dt">list</span> <span class="dt">ref</span> = {contents = []}</span></code></pre></div>
<p>Here <code>'_a</code> (displayed as <code>'_weak1</code> in recent
OCaml versions) is an <em>unknown</em>. Unlike a parameter, it stands
for a <em>particular</em> type – perhaps <code>float</code> or
<code>int -&gt; int</code> – but OCaml simply doesn’t know which type
yet. The underscore prefix signals this distinction. OCaml reports
unknowns like <code>'_a</code> in inferred types for reasons related to
mutable state (the “value restriction”), which are not relevant to
purely functional programming.</p>
<p>More precisely: the <em>value restriction</em> prevents unsoundness
that would otherwise arise from generalizing type variables in effectful
(mutable) expressions. When you see <code>'_weak...</code>, treat it as
“this will become one specific type later”.</p>
<p>When unknowns appear in inferred types against our expectations,
<em><span class="math inline">\eta</span>-expansion</em> may help. This
technique involves writing <code>let f x = expr x</code> instead of
<code>let f = expr</code>, essentially adding an extra parameter that
gets immediately applied. For example:</p>
<div class="sourceCode" id="cb114"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> f = <span class="dt">List</span>.append [];;</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : &#39;_weak2 <span class="dt">list</span> -&gt; &#39;_weak2 <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> f l = <span class="dt">List</span>.append [] l;;</span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
<p>In the second definition, the eta-expanded form
<code>let f l = List.append [] l</code> allows full generalization,
giving us a truly polymorphic function that can work with lists of any
type.</p>
<h3 id="type-environments">Type Environments</h3>
<p>Before diving into the equation-solving process, we need to
understand how the type checker keeps track of what names are available.
A <em>type environment</em> specifies what names (corresponding to
parameters and definitions) are available for an expression because they
were introduced above it, and it specifies their types. Think of it as a
dictionary that maps variable names to their types at any given point in
your program.</p>
<h3 id="solving-type-equations">Solving Type Equations</h3>
<p>Type inference works by solving equations over unknowns. The central
question the algorithm asks is: “What has to hold so that <span
class="math inline">e : \tau</span> in type environment <span
class="math inline">\Gamma</span>?” The answer takes the form of
equations that constrain the possible types.</p>
<p>Let us walk through how the algorithm handles different expression
forms:</p>
<ul>
<li><p>If, for example, <span class="math inline">f : \forall \alpha .
\alpha \ \text{list} \rightarrow \alpha \in \Gamma</span>, then for
<span class="math inline">f : \tau</span> we introduce <span
class="math inline">\gamma \ \text{list} \rightarrow \gamma =
\tau</span> for some fresh unknown <span
class="math inline">\gamma</span>.</p></li>
<li><p>For function application <span class="math inline">e_1 \ e_2 :
\tau</span>, we introduce <span class="math inline">\beta = \tau</span>
and ask for <span class="math inline">e_1 : \gamma \rightarrow
\beta</span> and <span class="math inline">e_2 : \gamma</span>, for some
fresh unknowns <span class="math inline">\beta, \gamma</span>.</p></li>
<li><p>For a function <span class="math inline">\text{fun} \ x
\rightarrow e : \tau</span>, we introduce <span
class="math inline">\beta \rightarrow \gamma = \tau</span> and ask for
<span class="math inline">e : \gamma</span> in environment <span
class="math inline">\{x : \beta\} \cup \Gamma</span>, for some fresh
unknowns <span class="math inline">\beta, \gamma</span>.</p></li>
<li><p>The case <span class="math inline">\text{let} \ x = e_1 \
\text{in} \ e_2 : \tau</span> is different. One approach is to
<em>first</em> solve the equations that we get by asking for <span
class="math inline">e_1 : \beta</span>, for some fresh unknown <span
class="math inline">\beta</span>. Let us say a solution <span
class="math inline">\beta = \tau_\beta</span> has been found, <span
class="math inline">\alpha_1 \ldots \alpha_n \beta_1 \ldots
\beta_m</span> are the remaining unknowns in <span
class="math inline">\tau_\beta</span>, and <span
class="math inline">\alpha_1 \ldots \alpha_n</span> are all that do not
appear in <span class="math inline">\Gamma</span>. Then we ask for <span
class="math inline">e_2 : \tau</span> in environment <span
class="math inline">\{x : \forall \alpha_1 \ldots \alpha_n .
\tau_\beta\} \cup \Gamma</span>.</p></li>
<li><p>Remember that whenever we establish a solution <span
class="math inline">\beta = \tau_\beta</span> to an unknown <span
class="math inline">\beta</span>, it takes effect everywhere! The
substitution propagates through all the equations, potentially
triggering further unifications.</p></li>
<li><p>To find a type for <span class="math inline">e</span> (in
environment <span class="math inline">\Gamma</span>), we pick a fresh
unknown <span class="math inline">\beta</span> and ask for <span
class="math inline">e : \beta</span> (in <span
class="math inline">\Gamma</span>). The algorithm then generates and
solves equations until either a solution is found or a contradiction
reveals a type error.</p></li>
</ul>
<h3 id="polymorphism">Polymorphism</h3>
<p>The “top-level” definitions for which the system infers types with
variables are called <em>polymorphic</em>, which informally means
“working with different shapes of data.” A polymorphic function like
<code>List.hd</code> can operate on lists containing any type of element
– the function itself doesn’t care what the elements are, only that it’s
working with a list.</p>
<p>This kind of polymorphism is called <em>parametric polymorphism</em>,
since the types have parameters. The term “parametric” emphasizes that
the same code works uniformly for all type instantiations. A different
kind of polymorphism is provided by object-oriented programming
languages (sometimes called <em>subtype polymorphism</em> or <em>ad-hoc
polymorphism</em>), where different code may execute depending on the
runtime type of objects.</p>
<h2 id="parametric-types">5.2 Parametric Types</h2>
<p>Polymorphic functions truly shine when used with polymorphic data
types. The combination of the two is what makes ML-family languages so
expressive. Consider this definition of our own list type:</p>
<div class="sourceCode" id="cb115"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a my_list = Empty | Cons <span class="kw">of</span> &#39;a * &#39;a my_list</span></code></pre></div>
<p>We define lists that can store elements of any type <code>'a</code>.
The type parameter <code>'a</code> acts as a placeholder that gets
filled in when we create actual lists. Now we can write functions that
work on these lists:</p>
<div class="sourceCode" id="cb116"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> tail l =</span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="dt">invalid_arg</span> <span class="st">&quot;tail&quot;</span></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a>    | Cons (_, tl) -&gt; tl;;</span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> tail : &#39;a my_list -&gt; &#39;a my_list = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
<p>This is a polymorphic function: it works for lists with elements of
any type. Whether we have a list of integers, strings, or even lists of
lists, the same <code>tail</code> function handles them all.</p>
<p>A crucial point to understand: a <em>parametric type</em> like
<code>'a my_list</code> <em>is not</em> itself a data type but rather a
<em>family</em> of data types. The types <code>bool my_list</code>,
<code>int my_list</code>, etc. <em>are</em> different types – you cannot
mix elements of different types in a single list. We say that the type
<code>int my_list</code> <em>instantiates</em> the parametric type
<code>'a my_list</code>.</p>
<h3 id="multiple-type-parameters">Multiple Type Parameters</h3>
<p>Types can have multiple type parameters. In OCaml, the syntax might
seem a bit unusual at first: type parameters precede the type name,
enclosed in parentheses. For example:</p>
<div class="sourceCode" id="cb117"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (&#39;a, &#39;b) choice = Left <span class="kw">of</span> &#39;a | Right <span class="kw">of</span> &#39;b</span></code></pre></div>
<p>This type has two parameters and represents a value that is either
something of type <code>'a</code> (wrapped in <code>Left</code>) or
something of type <code>'b</code> (wrapped in <code>Right</code>).
Mathematically we would write <span
class="math inline">\text{choice}(\alpha, \beta)</span>.</p>
<p>Not all functions that use parametric types need to be polymorphic. A
function may constrain the type parameters to specific types:</p>
<div class="sourceCode" id="cb118"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a># <span class="kw">let</span> get_int c =</span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> c <span class="kw">with</span></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>    | Left i -&gt; i</span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a>    | Right b -&gt; <span class="kw">if</span> b <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>;;</span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> get_int : (<span class="dt">int</span>, <span class="dt">bool</span>) choice -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
<p>Here, the pattern matching on <code>Left i</code> and
<code>Right b</code> with arithmetic operations constrains the type to
<code>(int, bool) choice</code>.</p>
<h3 id="syntax-in-other-languages">Syntax in Other Languages</h3>
<p>Different functional languages have different syntactic conventions
for type parameters. In F#, we provide parameters (when more than one)
after the type name, using angle brackets:</p>
<div class="sourceCode" id="cb119"><pre
class="sourceCode fsharp"><code class="sourceCode fsharp"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> choice&lt;&#39;a,&#39;b&gt; = Left <span class="kw">of</span> &#39;a | Right <span class="kw">of</span> &#39;b</span></code></pre></div>
<p>In Haskell, the syntax is arguably the cleanest – we provide type
parameters similarly to function arguments, separated by spaces:</p>
<div class="sourceCode" id="cb120"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Choice</span> a b <span class="ot">=</span> <span class="dt">Left</span> a <span class="op">|</span> <span class="dt">Right</span> b</span></code></pre></div>
<p>Despite the syntactic differences, the underlying concept of
parametric polymorphism is the same across all these languages.</p>
<h2 id="type-inference-formally">5.3 Type Inference, Formally</h2>
<p>Now we present a more formal treatment of type inference. A statement
that an expression has a type in an environment is called a <em>type
judgement</em>. For environment <span class="math inline">\Gamma = \{x :
\forall \alpha_1 \ldots \alpha_n . \tau_x ; \ldots\}</span>, expression
<span class="math inline">e</span> and type <span
class="math inline">\tau</span> we write:</p>
<p><span class="math display">\Gamma \vdash e : \tau</span></p>
<p>This notation reads: “In environment <span
class="math inline">\Gamma</span>, expression <span
class="math inline">e</span> has type <span
class="math inline">\tau</span>.” The turnstile symbol <span
class="math inline">\vdash</span> can be thought of as “entails” or
“proves.”</p>
<p>We will derive all the constraint equations in one go using the
notation <span class="math inline">[\![ \cdot ]\!]</span>, to be solved
later by unification. Besides equations we will need to manage
introduced variables, using existential quantification to express that
“there exists some type variable satisfying these constraints.”</p>
<p>For local definitions we require remembering what constraints should
hold when the definition is used. Therefore we extend <em>type
schemes</em> in the environment to: <span class="math inline">\Gamma =
\{x : \forall \beta_1 \ldots \beta_m [\exists \alpha_1 \ldots \alpha_n .
D] . \tau_x ; \ldots\}</span> where <span class="math inline">D</span>
are equations – keeping the variables <span class="math inline">\alpha_1
\ldots \alpha_n</span> introduced while deriving <span
class="math inline">D</span> in front. A simpler form would be
sufficient: <span class="math inline">\Gamma = \{x : \forall \beta
[\exists \alpha_1 \ldots \alpha_n . D] . \beta ; \ldots\}</span></p>
<p>The formal constraint generation rules are:</p>
<p><span class="math display">[\![ \Gamma \vdash x : \tau ]\!] = \exists
\overline{\beta&#39;} \overline{\alpha&#39;} . (D[\overline{\beta}
\overline{\alpha} := \overline{\beta&#39;} \overline{\alpha&#39;}]
\wedge \tau_x[\overline{\beta} \overline{\alpha} :=
\overline{\beta&#39;} \overline{\alpha&#39;}] \doteq \tau)</span></p>
<p>where <span class="math inline">\Gamma(x) = \forall \overline{\beta}
[\exists \overline{\alpha} . D] . \tau_x</span>, <span
class="math inline">\overline{\beta&#39;} \overline{\alpha&#39;} \#
\text{FV}(\Gamma, \tau)</span></p>
<p><span class="math display">[\![ \Gamma \vdash \mathbf{fun} \ x
\texttt{-&gt;} e : \tau ]\!] = \exists \alpha_1 \alpha_2 . ([\![ \Gamma
\{x : \alpha_1\} \vdash e : \alpha_2 ]\!] \wedge \alpha_1 \rightarrow
\alpha_2 \doteq \tau)</span></p>
<p>where <span class="math inline">\alpha_1 \alpha_2 \#
\text{FV}(\Gamma, \tau)</span></p>
<p><span class="math display">[\![ \Gamma \vdash e_1 \ e_2 : \tau ]\!] =
\exists \alpha . ([\![ \Gamma \vdash e_1 : \alpha \rightarrow \tau ]\!]
\wedge [\![ \Gamma \vdash e_2 : \alpha ]\!]), \alpha \#
\text{FV}(\Gamma, \tau)</span></p>
<p><span class="math display">[\![ \Gamma \vdash K \ e_1 \ldots e_n :
\tau ]\!] = \exists \overline{\alpha&#39;} . (\bigwedge_i [\![ \Gamma
\vdash e_i : \tau_i[\overline{\alpha} := \overline{\alpha&#39;}] ]\!]
\wedge \varepsilon(\overline{\alpha&#39;}) \doteq \tau)</span></p>
<p>where <span class="math inline">K : \forall \overline{\alpha} .
\tau_1 \times \ldots \times \tau_n \rightarrow
\varepsilon(\overline{\alpha})</span>, <span
class="math inline">\overline{\alpha&#39;} \# \text{FV}(\Gamma,
\tau)</span></p>
<p>For let-expressions:</p>
<p><span class="math display">[\![ \Gamma \vdash \mathbf{let} \ x = e_1
\ \mathbf{in} \ e_2 : \tau ]\!] = (\exists \beta . C) \wedge [\![ \Gamma
\{x : \forall \beta [C] . \beta\} \vdash e_2 : \tau ]\!]</span></p>
<p>where <span class="math inline">C = [\![ \Gamma \vdash e_1 : \beta
]\!]</span></p>
<p>For recursive let-expressions:</p>
<p><span class="math display">[\![ \Gamma \vdash \mathbf{letrec} \ x =
e_1 \ \mathbf{in} \ e_2 : \tau ]\!] = (\exists \beta . C) \wedge [\![
\Gamma \{x : \forall \beta [C] . \beta\} \vdash e_2 : \tau
]\!]</span></p>
<p>where <span class="math inline">C = [\![ \Gamma \{x : \beta\} \vdash
e_1 : \beta ]\!]</span></p>
<p>For match expressions:</p>
<p><span class="math display">[\![ \Gamma \vdash \mathbf{match} \ e_v \
\mathbf{with} \ \overline{c} : \tau ]\!] = \exists \alpha_v . [\![
\Gamma \vdash e_v : \alpha_v ]\!] \bigwedge_i [\![ \Gamma \vdash p_i .
e_i : \alpha_v \rightarrow \tau ]\!]</span></p>
<p>where <span class="math inline">\overline{c} = p_1 . e_1 | \ldots |
p_n . e_n</span>, <span class="math inline">\alpha_v \#
\text{FV}(\Gamma, \tau)</span></p>
<p>For pattern clauses:</p>
<p><span class="math display">[\![ \Gamma, \Sigma \vdash p.e : \tau_1
\rightarrow \tau_2 ]\!] = [\![ \Sigma \vdash p \downarrow \tau_1 ]\!]
\wedge \forall \overline{\beta} . [\![ \Gamma \Gamma&#39; \vdash e :
\tau_2 ]\!]</span></p>
<p>where <span class="math inline">\exists \overline{\beta}
\Gamma&#39;</span> is <span class="math inline">[\![ \Sigma \vdash p
\uparrow \tau_1 ]\!]</span>, <span class="math inline">\overline{\beta}
\# \text{FV}(\Gamma, \tau_2)</span></p>
<p>The notation <span class="math inline">[\![ \Sigma \vdash p
\downarrow \tau_1 ]\!]</span> derives constraints on the type of the
matched value, while <span class="math inline">[\![ \Sigma \vdash p
\uparrow \tau_1 ]\!]</span> derives the environment for pattern
variables.</p>
<p>By <span class="math inline">\overline{\alpha}</span> or <span
class="math inline">\overline{\alpha_i}</span> we denote a sequence of
some length: <span class="math inline">\alpha_1 \ldots \alpha_n</span>.
By <span class="math inline">\bigwedge_i \varphi_i</span> we denote a
conjunction of <span class="math inline">\overline{\varphi_i}</span>:
<span class="math inline">\varphi_1 \wedge \ldots \wedge
\varphi_n</span>.</p>
<h3 id="polymorphic-recursion">Polymorphic Recursion</h3>
<p>There is an interesting limitation in standard type inference for
recursive functions. Note the limited polymorphism of
<code>let rec f = ...</code> – we cannot use <code>f</code>
polymorphically within its own definition. Why? Because when
type-checking the body of a recursive definition, we don’t yet know the
final type of <code>f</code>, so we must treat it as having a single,
unknown type.</p>
<p>In modern OCaml we can bypass this limitation if we provide the type
of <code>f</code> upfront:</p>
<pre><code>let rec f : &#39;a. &#39;a -&gt; &#39;a list = ...</code></pre>
<p>where <code>'a. 'a -&gt; 'a list</code> stands for <span
class="math inline">\forall \alpha . \alpha \rightarrow \alpha \
\text{list}</span>.</p>
<p>Using the recursively defined function with different types in its
definition is called <em>polymorphic recursion</em>. It is most useful
together with <em>irregular recursive datatypes</em> – data structures
where the recursive use has different type arguments than the actual
parameters. These “nested” or “non-uniform” datatypes enable some
remarkably elegant data structures.</p>
<h4
id="example-a-list-alternating-between-two-types-of-elements">Example: A
List Alternating Between Two Types of Elements</h4>
<p>Here is a fascinating example: a list that alternates between two
different types of elements. Notice how the recursive occurrence swaps
the type parameters:</p>
<div class="sourceCode" id="cb122"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (&#39;x, &#39;o) alternating =</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>  | Stop</span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a>  | One <span class="kw">of</span> &#39;x * (&#39;o, &#39;x) alternating</span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> to_list :</span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a>    &#39;x &#39;o &#39;a. (&#39;x -&gt; &#39;a) -&gt; (&#39;o -&gt; &#39;a) -&gt;</span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true" tabindex="-1"></a>              (&#39;x, &#39;o) alternating -&gt; &#39;a <span class="dt">list</span> =</span>
<span id="cb122-8"><a href="#cb122-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fun</span> x2a o2a -&gt;</span>
<span id="cb122-9"><a href="#cb122-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">function</span></span>
<span id="cb122-10"><a href="#cb122-10" aria-hidden="true" tabindex="-1"></a>    | Stop -&gt; []</span>
<span id="cb122-11"><a href="#cb122-11" aria-hidden="true" tabindex="-1"></a>    | One (x, rest) -&gt; x2a x :: to_list o2a x2a rest</span>
<span id="cb122-12"><a href="#cb122-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-13"><a href="#cb122-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> to_choice_list alt =</span>
<span id="cb122-14"><a href="#cb122-14" aria-hidden="true" tabindex="-1"></a>  to_list (<span class="kw">fun</span> x -&gt; Left x) (<span class="kw">fun</span> o -&gt; Right o) alt</span>
<span id="cb122-15"><a href="#cb122-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-16"><a href="#cb122-16" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> it = to_choice_list</span>
<span id="cb122-17"><a href="#cb122-17" aria-hidden="true" tabindex="-1"></a>  (One (<span class="dv">1</span>, One (<span class="st">&quot;o&quot;</span>, One (<span class="dv">2</span>, One (<span class="st">&quot;oo&quot;</span>, Stop)))))</span></code></pre></div>
<p>Notice how the recursive call to <code>to_list</code> swaps
<code>o2a</code> and <code>x2a</code> – this is necessary because the
alternating structure swaps the type parameters at each level. The
polymorphic recursion annotation <code>'x 'o 'a.</code> tells OCaml that
we need to use <code>to_list</code> at different type instantiations
within its own definition.</p>
<h4 id="example-data-structural-bootstrapping">Example: Data-Structural
Bootstrapping</h4>
<p>Here is another powerful example of polymorphic recursion: a sequence
data structure that stores elements in exponentially increasing chunks.
This technique, known as <em>data-structural bootstrapping</em>,
achieves logarithmic-time random access – much faster than standard
lists which require linear time.</p>
<div class="sourceCode" id="cb123"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a seq =</span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>  | Nil</span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>  | Zero <span class="kw">of</span> (&#39;a * &#39;a) seq</span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>  | One <span class="kw">of</span> &#39;a * (&#39;a * &#39;a) seq</span></code></pre></div>
<p>The key insight is that this type is <em>non-uniform</em>: the
recursive occurrences use <code>('a * 'a) seq</code> rather than
<code>'a seq</code>. This means that as we go deeper into the structure,
elements get paired together, effectively doubling the “width” at each
level. We store a list of elements in exponentially increasing
chunks:</p>
<div class="sourceCode" id="cb124"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> example =</span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a>  One (<span class="dv">0</span>, One ((<span class="dv">1</span>,<span class="dv">2</span>), Zero (One ((((<span class="dv">3</span>,<span class="dv">4</span>),(<span class="dv">5</span>,<span class="dv">6</span>)), ((<span class="dv">7</span>,<span class="dv">8</span>),(<span class="dv">9</span>,<span class="dv">10</span>))), Nil))))</span></code></pre></div>
<p>The <code>cons</code> operation adds an element to the front.
Remarkably, appending an element to this data structure works exactly
like adding one to a binary number:</p>
<div class="sourceCode" id="cb125"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> cons : &#39;a. &#39;a -&gt; &#39;a seq -&gt; &#39;a seq =</span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fun</span> x -&gt; <span class="kw">function</span></span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a>  | Nil -&gt; One (x, Nil)                       <span class="co">(* 1+0=1 *)</span></span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a>  | Zero ps -&gt; One (x, ps)                    <span class="co">(* 1+...0=...1 *)</span></span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true" tabindex="-1"></a>  | One (y, ps) -&gt; Zero (cons (x,y) ps)       <span class="co">(* 1+...1=[...+1]0 *)</span></span>
<span id="cb125-6"><a href="#cb125-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-7"><a href="#cb125-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> lookup : &#39;a. <span class="dt">int</span> -&gt; &#39;a seq -&gt; &#39;a =</span>
<span id="cb125-8"><a href="#cb125-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fun</span> i s -&gt; <span class="kw">match</span> i, s <span class="kw">with</span></span>
<span id="cb125-9"><a href="#cb125-9" aria-hidden="true" tabindex="-1"></a>  | _, Nil -&gt; <span class="dt">raise</span> <span class="dt">Not_found</span>              <span class="co">(* Rather than returning None : &#39;a option *)</span></span>
<span id="cb125-10"><a href="#cb125-10" aria-hidden="true" tabindex="-1"></a>  | <span class="dv">0</span>, One (x, _) -&gt; x                     <span class="co">(* we raise exception, for convenience. *)</span></span>
<span id="cb125-11"><a href="#cb125-11" aria-hidden="true" tabindex="-1"></a>  | i, One (_, ps) -&gt; lookup (i<span class="dv">-1</span>) (Zero ps)</span>
<span id="cb125-12"><a href="#cb125-12" aria-hidden="true" tabindex="-1"></a>  | i, Zero ps -&gt;                          <span class="co">(* Random-access lookup works *)</span></span>
<span id="cb125-13"><a href="#cb125-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> x, y = lookup (i / <span class="dv">2</span>) ps <span class="kw">in</span>      <span class="co">(* in logarithmic time -- much faster *)</span></span>
<span id="cb125-14"><a href="#cb125-14" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> i <span class="kw">mod</span> <span class="dv">2</span> = <span class="dv">0</span> <span class="kw">then</span> x <span class="kw">else</span> y         <span class="co">(* than in standard lists. *)</span></span></code></pre></div>
<p>The <code>Zero</code> and <code>One</code> constructors correspond to
binary digits. A <code>Zero</code> means “no singleton element at this
level,” while <code>One</code> carries a singleton (or pair, or quad,
etc.) before recursing. The <code>lookup</code> function exploits this
structure: when looking up index <code>i</code> in a
<code>Zero ps</code>, it divides by 2 and looks in the paired structure,
then extracts the appropriate half of the pair.</p>
<h2 id="algebraic-specification">5.4 Algebraic Specification</h2>
<p>Now we turn to a fundamental question in computer science: how do we
formally describe what a data structure <em>is</em> and what it should
<em>do</em>? The mathematical answer is <em>algebraic
specification</em>.</p>
<p>The way we introduce a data structure, like complex numbers or
strings, in mathematics is by specifying an <em>algebraic
structure</em>. This approach gives us a precise language for describing
data structures independent of any particular implementation.</p>
<p>Algebraic structures consist of a set (or several sets, for so-called
<em>multisorted</em> algebras) and a bunch of functions (also known as
operations) over this set (or sets). Think of integers with addition and
multiplication, or strings with concatenation and character access.</p>
<p>A <em>signature</em> is a rough description of an algebraic
structure: it provides <em>sorts</em> – names for the sets (in the
multisorted case) – and names of the functions-operations together with
their arity (and what sorts of arguments they take). A signature tells
us what operations exist, but not how they behave.</p>
<p>We select a class of algebraic structures by providing axioms that
have to hold. We will call such classes <em>algebraic
specifications</em>. In mathematics, a rusty name for some algebraic
specifications is a <em>variety</em>; a more modern name is
<em>algebraic category</em>.</p>
<p>Here is the key connection to programming: algebraic structures
correspond to “implementations” and signatures to “interfaces” in
programming languages. We will say that an algebraic structure
<em>implements</em> an algebraic specification when all axioms of the
specification hold in the structure. An important point: all algebraic
specifications are implemented by multiple structures! This is precisely
what we want – it gives us the freedom to choose different
implementations with different performance characteristics while
maintaining the same interface.</p>
<p>We say that an algebraic structure does not have <em>junk</em> when
all its elements (i.e., elements in the sets corresponding to sorts) can
be built using operations in its signature. Junk-free structures are
“minimal” in some sense – they contain only the values that can be
constructed using the provided operations.</p>
<p>We allow parametric types as sorts. In that case, strictly speaking,
we define a family of algebraic specifications (a different
specification for each instantiation of the parametric type).</p>
<h3 id="algebraic-specifications-examples">Algebraic Specifications:
Examples</h3>
<p>Let us look at some concrete examples to make these abstract ideas
tangible. An algebraic specification can also use an earlier
specification, building up complexity layer by layer. In “impure”
languages like OCaml and F# we allow that the result of any operation be
an <span class="math inline">\text{error}</span>. In Haskell we would
use <code>Maybe</code> to explicitly model potential failure.</p>
<p><strong>Specification <span class="math inline">\text{nat}_p</span>
(bounded natural numbers):</strong></p>
<p>This specification describes natural numbers that wrap around at some
bound <span class="math inline">p</span> (like machine integers):</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr>
<th><span class="math inline">\text{nat}_p</span></th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">0 : \text{nat}_p</span></td>
</tr>
<tr>
<td><span class="math inline">\text{succ} : \text{nat}_p \rightarrow
\text{nat}_p</span></td>
</tr>
<tr>
<td><span class="math inline">+ : \text{nat}_p \rightarrow \text{nat}_p
\rightarrow \text{nat}_p</span></td>
</tr>
<tr>
<td><span class="math inline">* : \text{nat}_p \rightarrow \text{nat}_p
\rightarrow \text{nat}_p</span></td>
</tr>
<tr>
<td>Variables: <span class="math inline">n, m : \text{nat}_p</span></td>
</tr>
<tr>
<td>Axioms:</td>
</tr>
<tr>
<td><span class="math inline">0 + n = n</span>, <span
class="math inline">n + 0 = n</span></td>
</tr>
<tr>
<td><span class="math inline">m + \text{succ}(n) = \text{succ}(m +
n)</span></td>
</tr>
<tr>
<td><span class="math inline">0 * n = 0</span>, <span
class="math inline">n * 0 = 0</span></td>
</tr>
<tr>
<td><span class="math inline">m * \text{succ}(n) = m + (m *
n)</span></td>
</tr>
<tr>
<td><span
class="math inline">\underbrace{\text{succ}(\ldots\text{succ}(0))}_{\text{less
than } p \text{ times}} \neq 0</span></td>
</tr>
<tr>
<td><span
class="math inline">\underbrace{\text{succ}(\ldots\text{succ}(0))}_{p
\text{ times}} = 0</span></td>
</tr>
</tbody>
</table>
<p>The axioms define how addition and multiplication work recursively,
and the last two axioms capture the bounded nature: applying <span
class="math inline">\text{succ}</span> less than <span
class="math inline">p</span> times never gives zero, but exactly <span
class="math inline">p</span> times wraps around to zero.</p>
<p><strong>Specification <span
class="math inline">\text{string}_p</span> (bounded
strings):</strong></p>
<p>This specification describes strings with a maximum length <span
class="math inline">p</span>:</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr>
<th><span class="math inline">\text{string}_p</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>uses <span class="math inline">\text{char}</span>, <span
class="math inline">\text{nat}_p</span></td>
</tr>
<tr>
<td><code>""</code> <span class="math inline">:
\text{string}_p</span></td>
</tr>
<tr>
<td><code>"c"</code> <span class="math inline">: \text{char} \rightarrow
\text{string}_p</span></td>
</tr>
<tr>
<td><span class="math inline">\hat{\ } : \text{string}_p \rightarrow
\text{string}_p \rightarrow \text{string}_p</span></td>
</tr>
<tr>
<td><span class="math inline">\cdot[\cdot] : \text{string}_p \rightarrow
\text{nat}_p \rightarrow \text{char}</span></td>
</tr>
<tr>
<td>Variables: <span class="math inline">s : \text{string}_p</span>,
<span class="math inline">c, c_1, \ldots, c_p : \text{char}</span>,
<span class="math inline">n : \text{nat}_p</span></td>
</tr>
<tr>
<td>Axioms:</td>
</tr>
<tr>
<td><code>""</code> <span class="math inline">\hat{\ } s = s</span>,
<span class="math inline">s \hat{\ }</span> <code>""</code> <span
class="math inline">= s</span></td>
</tr>
<tr>
<td><span class="math inline">\underbrace{\text{``}c_1\text{&#39;&#39;}
\hat{\ } (\ldots \hat{\ } \text{``}c_p\text{&#39;&#39;})}_{p \text{
times}} = \text{error}</span></td>
</tr>
<tr>
<td><span class="math inline">r \hat{\ } (s \hat{\ } t) = (r \hat{\ } s)
\hat{\ } t</span></td>
</tr>
<tr>
<td><span class="math inline">(\text{``}c\text{&#39;&#39;} \hat{\ }
s)[0] = c</span></td>
</tr>
<tr>
<td><span class="math inline">(\text{``}c\text{&#39;&#39;} \hat{\ }
s)[\text{succ}(n)] = s[n]</span></td>
</tr>
<tr>
<td><code>""</code><span class="math inline">[n] =
\text{error}</span></td>
</tr>
</tbody>
</table>
<p>The axioms specify that concatenation is associative, that the empty
string is an identity for concatenation, that exceeding the length limit
produces an error, and that indexing works by stripping characters from
the front.</p>
<h2 id="homomorphisms">5.5 Homomorphisms</h2>
<p>When do two implementations of the same specification “behave the
same”? The mathematical answer involves <em>homomorphisms</em> –
structure-preserving mappings between algebraic structures.</p>
<p>Homomorphisms are mappings between algebraic structures with the same
signature that preserve operations. Intuitively, if you apply an
operation and then map, you get the same result as mapping first and
then applying the corresponding operation.</p>
<p>A <em>homomorphism</em> from algebraic structure <span
class="math inline">(A, \{f^A, g^A, \ldots\})</span> to <span
class="math inline">(B, \{f^B, g^B, \ldots\})</span> is a function <span
class="math inline">h : A \rightarrow B</span> such that: - <span
class="math inline">h(f^A(a_1, \ldots, a_{n_f})) = f^B(h(a_1), \ldots,
h(a_{n_f}))</span> for all <span class="math inline">(a_1, \ldots,
a_{n_f})</span> - <span class="math inline">h(g^A(a_1, \ldots, a_{n_g}))
= g^B(h(a_1), \ldots, h(a_{n_g}))</span> for all <span
class="math inline">(a_1, \ldots, a_{n_g})</span> - and so on for all
operations.</p>
<p>Two algebraic structures are <em>isomorphic</em> if there are
homomorphisms <span class="math inline">h_1 : A \rightarrow B</span>,
<span class="math inline">h_2 : B \rightarrow A</span> from one to the
other and back, that when composed in any order form identity: <span
class="math inline">\forall (b \in B) \ h_1(h_2(b)) = b</span> and <span
class="math inline">\forall (a \in A) \ h_2(h_1(a)) = a</span>.</p>
<p>An algebraic specification whose all implementations without junk are
isomorphic is called “<em>monomorphic</em>”. This means the
specification pins down the structure so precisely that there’s
essentially only one way to implement it (up to isomorphism).</p>
<p>We usually only add axioms that really matter to us to the
specification, so that the implementations have room for optimization.
For this reason, the resulting specifications will often not be
monomorphic in the above sense – and that’s intentional! A
non-monomorphic specification allows for multiple genuinely different
implementations, which may have different performance
characteristics.</p>
<h2 id="example-maps">5.6 Example: Maps</h2>
<p>Now let us look at a practical example that will guide the rest of
this chapter. A <em>map</em> (also called dictionary or associative
array) associates keys with values. This is one of the most fundamental
data structures in programming – think of Python’s dictionaries, Java’s
<code>HashMap</code>, or OCaml’s <code>Map</code> module.</p>
<p>Here is an algebraic specification that captures the essential
behavior of maps:</p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr>
<th><span class="math inline">(\alpha, \beta) \ \text{map}</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>uses <span class="math inline">\text{bool}</span>, type parameters
<span class="math inline">\alpha, \beta</span></td>
</tr>
<tr>
<td><span class="math inline">\text{empty} : (\alpha, \beta) \
\text{map}</span></td>
</tr>
<tr>
<td><span class="math inline">\text{member} : \alpha \rightarrow
(\alpha, \beta) \ \text{map} \rightarrow \text{bool}</span></td>
</tr>
<tr>
<td><span class="math inline">\text{add} : \alpha \rightarrow \beta
\rightarrow (\alpha, \beta) \ \text{map} \rightarrow (\alpha, \beta) \
\text{map}</span></td>
</tr>
<tr>
<td><span class="math inline">\text{remove} : \alpha \rightarrow
(\alpha, \beta) \ \text{map} \rightarrow (\alpha, \beta) \
\text{map}</span></td>
</tr>
<tr>
<td><span class="math inline">\text{find} : \alpha \rightarrow (\alpha,
\beta) \ \text{map} \rightarrow \beta</span></td>
</tr>
<tr>
<td>Variables: <span class="math inline">k, k_2 : \alpha</span>, <span
class="math inline">v, v_2 : \beta</span>, <span class="math inline">m :
(\alpha, \beta) \ \text{map}</span></td>
</tr>
<tr>
<td>Axioms:</td>
</tr>
<tr>
<td><span class="math inline">\text{member}(k, \text{add}(k, v, m)) =
\text{true}</span></td>
</tr>
<tr>
<td><span class="math inline">\text{member}(k, \text{remove}(k, m)) =
\text{false}</span></td>
</tr>
<tr>
<td><span class="math inline">\text{member}(k, \text{add}(k_2, v, m)) =
\text{true} \wedge k \neq k_2 \Leftrightarrow \text{member}(k, m) =
\text{true} \wedge k \neq k_2</span></td>
</tr>
<tr>
<td><span class="math inline">\text{member}(k, \text{remove}(k_2, m)) =
\text{true} \wedge k \neq k_2 \Leftrightarrow \text{member}(k, m) =
\text{true} \wedge k \neq k_2</span></td>
</tr>
<tr>
<td><span class="math inline">\text{find}(k, \text{add}(k, v, m)) =
v</span></td>
</tr>
<tr>
<td><span class="math inline">\text{find}(k, \text{remove}(k, m)) =
\text{error}</span>, <span class="math inline">\text{find}(k,
\text{empty}) = \text{error}</span></td>
</tr>
<tr>
<td><span class="math inline">\text{find}(k, \text{add}(k_2, v_2, m)) =
v \wedge k \neq k_2 \Leftrightarrow \text{find}(k, m) = v \wedge k \neq
k_2</span></td>
</tr>
<tr>
<td><span class="math inline">\text{find}(k, \text{remove}(k_2, m)) = v
\wedge k \neq k_2 \Leftrightarrow \text{find}(k, m) = v \wedge k \neq
k_2</span></td>
</tr>
<tr>
<td><span class="math inline">\text{remove}(k, \text{empty}) =
\text{empty}</span></td>
</tr>
</tbody>
</table>
<p>The axioms capture the intuitive behavior: adding a key-value pair
makes that key findable, removing a key makes it unfindable, and
operations on different keys don’t interfere with each other. Notice how
the specification says nothing about <em>how</em> the map is implemented
– only about <em>what</em> behavior it must exhibit.</p>
<h2 id="modules-and-interfaces-signatures-syntax">5.7 Modules and
Interfaces (Signatures): Syntax</h2>
<p>How do we express algebraic specifications in OCaml? The answer is
the <em>module system</em>. In the ML family of languages, structures
are given names by <strong>module</strong> bindings, and signatures are
types of modules. From outside of a structure or signature, we refer to
the values or types it provides with a dot notation:
<code>Module.value</code>.</p>
<p>Module (and module type) names have to start with a capital letter
(in ML languages). Since modules and module types have names, there is a
convention to name the central type of a signature (the one that is
“specified” by the signature), for brevity, <code>t</code>. Module types
are often named with “all-caps” (all letters upper case).</p>
<p>Here is how we translate our map specification into an OCaml module
signature:</p>
<div class="sourceCode" id="cb126"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">type</span> MAP = <span class="kw">sig</span></span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> (&#39;a, &#39;b) t</span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> empty : (&#39;a, &#39;b) t</span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> member : &#39;a -&gt; (&#39;a, &#39;b) t -&gt; <span class="dt">bool</span></span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> add : &#39;a -&gt; &#39;b -&gt; (&#39;a, &#39;b) t -&gt; (&#39;a, &#39;b) t</span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> remove : &#39;a -&gt; (&#39;a, &#39;b) t -&gt; (&#39;a, &#39;b) t</span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> find : &#39;a -&gt; (&#39;a, &#39;b) t -&gt; &#39;b</span>
<span id="cb126-8"><a href="#cb126-8" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb126-9"><a href="#cb126-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-10"><a href="#cb126-10" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> ListMap : MAP = <span class="kw">struct</span></span>
<span id="cb126-11"><a href="#cb126-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> (&#39;a, &#39;b) t = (&#39;a * &#39;b) <span class="dt">list</span></span>
<span id="cb126-12"><a href="#cb126-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> empty = []</span>
<span id="cb126-13"><a href="#cb126-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> member = <span class="dt">List</span>.mem_assoc</span>
<span id="cb126-14"><a href="#cb126-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> add k v m = (k, v)::m</span>
<span id="cb126-15"><a href="#cb126-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> remove = <span class="dt">List</span>.remove_assoc</span>
<span id="cb126-16"><a href="#cb126-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> find = <span class="dt">List</span>.assoc</span>
<span id="cb126-17"><a href="#cb126-17" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>The <code>ListMap</code> module implements <code>MAP</code> using
OCaml’s built-in list functions for association lists. The type
annotation <code>: MAP</code> after the module name tells OCaml to check
that the implementation provides everything the signature requires, and
hides any additional details.</p>
<h2 id="implementing-maps-association-lists">5.8 Implementing Maps:
Association Lists</h2>
<p>Let us now build an implementation of maps from the ground up,
exploring different approaches and their trade-offs. The most
straightforward implementation… might not be what you expected:</p>
<div class="sourceCode" id="cb127"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> TrivialMap : MAP = <span class="kw">struct</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> (&#39;a, &#39;b) t =</span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a>    | Empty</span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a>    | Add <span class="kw">of</span> &#39;a * &#39;b * (&#39;a, &#39;b) t</span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a>    | Remove <span class="kw">of</span> &#39;a * (&#39;a, &#39;b) t</span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> empty = Empty</span>
<span id="cb127-8"><a href="#cb127-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-9"><a href="#cb127-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> member k m =</span>
<span id="cb127-10"><a href="#cb127-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb127-11"><a href="#cb127-11" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="kw">false</span></span>
<span id="cb127-12"><a href="#cb127-12" aria-hidden="true" tabindex="-1"></a>    | Add (k2, _, _) <span class="kw">when</span> k = k2 -&gt; <span class="kw">true</span></span>
<span id="cb127-13"><a href="#cb127-13" aria-hidden="true" tabindex="-1"></a>    | Remove (k2, _) <span class="kw">when</span> k = k2 -&gt; <span class="kw">false</span></span>
<span id="cb127-14"><a href="#cb127-14" aria-hidden="true" tabindex="-1"></a>    | Add (_, _, m2) -&gt; member k m2</span>
<span id="cb127-15"><a href="#cb127-15" aria-hidden="true" tabindex="-1"></a>    | Remove (_, m2) -&gt; member k m2</span>
<span id="cb127-16"><a href="#cb127-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-17"><a href="#cb127-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> add k v m = Add (k, v, m)</span>
<span id="cb127-18"><a href="#cb127-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> remove k m = Remove (k, m)</span>
<span id="cb127-19"><a href="#cb127-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-20"><a href="#cb127-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> find k m =</span>
<span id="cb127-21"><a href="#cb127-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb127-22"><a href="#cb127-22" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="dt">raise</span> <span class="dt">Not_found</span></span>
<span id="cb127-23"><a href="#cb127-23" aria-hidden="true" tabindex="-1"></a>    | Add (k2, v, _) <span class="kw">when</span> k = k2 -&gt; v</span>
<span id="cb127-24"><a href="#cb127-24" aria-hidden="true" tabindex="-1"></a>    | Remove (k2, _) <span class="kw">when</span> k = k2 -&gt; <span class="dt">raise</span> <span class="dt">Not_found</span></span>
<span id="cb127-25"><a href="#cb127-25" aria-hidden="true" tabindex="-1"></a>    | Add (_, _, m2) -&gt; find k m2</span>
<span id="cb127-26"><a href="#cb127-26" aria-hidden="true" tabindex="-1"></a>    | Remove (_, m2) -&gt; find k m2</span>
<span id="cb127-27"><a href="#cb127-27" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>This “trivial” implementation is quite clever in its own way: it
simply records all operations as a log! The data structure itself is a
history of everything that has been done to it. The <code>add</code> and
<code>remove</code> operations are <span class="math inline">O(1)</span>
– they just prepend a new node. However, <code>member</code> and
<code>find</code> must traverse the entire history to determine the
current state, giving them <span class="math inline">O(n)</span>
complexity where <span class="math inline">n</span> is the number of
operations performed.</p>
<p>This implementation illustrates an important point: there are many
ways to satisfy the same specification, with very different performance
characteristics.</p>
<p>Here is a more conventional implementation based on association
lists, i.e., on lists of key-value pairs without the <code>Remove</code>
constructor:</p>
<div class="sourceCode" id="cb128"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> MyListMap : MAP = <span class="kw">struct</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> (&#39;a, &#39;b) t = Empty | Add <span class="kw">of</span> &#39;a * &#39;b * (&#39;a, &#39;b) t</span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> empty = Empty</span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> member k m =</span>
<span id="cb128-7"><a href="#cb128-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb128-8"><a href="#cb128-8" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="kw">false</span></span>
<span id="cb128-9"><a href="#cb128-9" aria-hidden="true" tabindex="-1"></a>    | Add (k2, _, _) <span class="kw">when</span> k = k2 -&gt; <span class="kw">true</span></span>
<span id="cb128-10"><a href="#cb128-10" aria-hidden="true" tabindex="-1"></a>    | Add (_, _, m2) -&gt; member k m2</span>
<span id="cb128-11"><a href="#cb128-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-12"><a href="#cb128-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> add k v m =</span>
<span id="cb128-13"><a href="#cb128-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb128-14"><a href="#cb128-14" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; Add (k, v, Empty)</span>
<span id="cb128-15"><a href="#cb128-15" aria-hidden="true" tabindex="-1"></a>    | Add (k2, _, m) <span class="kw">when</span> k = k2 -&gt; Add (k, v, m)</span>
<span id="cb128-16"><a href="#cb128-16" aria-hidden="true" tabindex="-1"></a>    | Add (k2, v2, m) -&gt; Add (k2, v2, add k v m)</span>
<span id="cb128-17"><a href="#cb128-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-18"><a href="#cb128-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> remove k m =</span>
<span id="cb128-19"><a href="#cb128-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb128-20"><a href="#cb128-20" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; Empty</span>
<span id="cb128-21"><a href="#cb128-21" aria-hidden="true" tabindex="-1"></a>    | Add (k2, _, m) <span class="kw">when</span> k = k2 -&gt; m</span>
<span id="cb128-22"><a href="#cb128-22" aria-hidden="true" tabindex="-1"></a>    | Add (k2, v, m) -&gt; Add (k2, v, remove k m)</span>
<span id="cb128-23"><a href="#cb128-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-24"><a href="#cb128-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> find k m =</span>
<span id="cb128-25"><a href="#cb128-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb128-26"><a href="#cb128-26" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="dt">raise</span> <span class="dt">Not_found</span></span>
<span id="cb128-27"><a href="#cb128-27" aria-hidden="true" tabindex="-1"></a>    | Add (k2, v, _) <span class="kw">when</span> k = k2 -&gt; v</span>
<span id="cb128-28"><a href="#cb128-28" aria-hidden="true" tabindex="-1"></a>    | Add (_, _, m2) -&gt; find k m2</span>
<span id="cb128-29"><a href="#cb128-29" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>This implementation maintains the invariant that each key appears at
most once in the structure. The <code>add</code> function replaces an
existing key’s value rather than creating a duplicate, and
<code>remove</code> actually removes the key-value pair. All operations
are still <span class="math inline">O(n)</span> in the worst case, but
the structure stays cleaner.</p>
<h2 id="implementing-maps-binary-search-trees">5.9 Implementing Maps:
Binary Search Trees</h2>
<p>Can we do better than linear time? Yes, by using a smarter data
structure. Binary search trees are binary trees with elements stored at
the interior nodes, such that elements to the left of a node are smaller
than, and elements to the right bigger than, elements within a node.
This ordering property is what makes them efficient.</p>
<p>For maps, we store key-value pairs as elements in binary search
trees, and compare the elements by keys alone. The tree structure allows
us to use “divide-and-conquer” to search for the value associated with a
key.</p>
<p>On average, binary search trees are fast – <span
class="math inline">O(\log n)</span> complexity for all operations. At
each node, we can eliminate half the remaining elements from
consideration. However, in the worst case (when keys are inserted in
sorted order), the tree degenerates into a linked list and operations
become <span class="math inline">O(n)</span>.</p>
<p>A note on our design: the simple polymorphic signature for maps is
only possible because OCaml provides polymorphic comparison (and
equality) operators that work on elements of most types (but not on
functions). These operators may not behave as you expect for all types!
Our signature for polymorphic maps is not the standard approach because
of this limitation; it is just to keep things simple for pedagogical
purposes.</p>
<div class="sourceCode" id="cb129"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> BTreeMap : MAP = <span class="kw">struct</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> (&#39;a, &#39;b) t = Empty | T <span class="kw">of</span> (&#39;a, &#39;b) t * &#39;a * &#39;b * (&#39;a, &#39;b) t</span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> empty = Empty</span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-6"><a href="#cb129-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> member k m =              <span class="co">(* &quot;Divide and conquer&quot; search through the tree. *)</span></span>
<span id="cb129-7"><a href="#cb129-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb129-8"><a href="#cb129-8" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="kw">false</span></span>
<span id="cb129-9"><a href="#cb129-9" aria-hidden="true" tabindex="-1"></a>    | T (_, k2, _, _) <span class="kw">when</span> k = k2 -&gt; <span class="kw">true</span></span>
<span id="cb129-10"><a href="#cb129-10" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, _, _) <span class="kw">when</span> k &lt; k2 -&gt; member k m1</span>
<span id="cb129-11"><a href="#cb129-11" aria-hidden="true" tabindex="-1"></a>    | T (_, _, _, m2) -&gt; member k m2</span>
<span id="cb129-12"><a href="#cb129-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-13"><a href="#cb129-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> add k v m =               <span class="co">(* Searches the tree in the same way as member *)</span></span>
<span id="cb129-14"><a href="#cb129-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span>                    <span class="co">(* but copies every node along the way. *)</span></span>
<span id="cb129-15"><a href="#cb129-15" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; T (Empty, k, v, Empty)</span>
<span id="cb129-16"><a href="#cb129-16" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, _, m2) <span class="kw">when</span> k = k2 -&gt; T (m1, k, v, m2)</span>
<span id="cb129-17"><a href="#cb129-17" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, v2, m2) <span class="kw">when</span> k &lt; k2 -&gt; T (add k v m1, k2, v2, m2)</span>
<span id="cb129-18"><a href="#cb129-18" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, v2, m2) -&gt; T (m1, k2, v2, add k v m2)</span>
<span id="cb129-19"><a href="#cb129-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-20"><a href="#cb129-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> split_rightmost m =       <span class="co">(* A helper function, it does not belong *)</span></span>
<span id="cb129-21"><a href="#cb129-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span>                    <span class="co">(* to the &quot;exported&quot; signature. *)</span></span>
<span id="cb129-22"><a href="#cb129-22" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="dt">raise</span> <span class="dt">Not_found</span></span>
<span id="cb129-23"><a href="#cb129-23" aria-hidden="true" tabindex="-1"></a>    | T (Empty, k, v, Empty) -&gt; k, v, Empty   <span class="co">(* We remove one element, *)</span></span>
<span id="cb129-24"><a href="#cb129-24" aria-hidden="true" tabindex="-1"></a>    | T (m1, k, v, m2) -&gt;           <span class="co">(* the one that is on the bottom right. *)</span></span>
<span id="cb129-25"><a href="#cb129-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> rk, rv, rm = split_rightmost m2 <span class="kw">in</span></span>
<span id="cb129-26"><a href="#cb129-26" aria-hidden="true" tabindex="-1"></a>        rk, rv, T (m1, k, v, rm)</span>
<span id="cb129-27"><a href="#cb129-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-28"><a href="#cb129-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> remove k m =</span>
<span id="cb129-29"><a href="#cb129-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb129-30"><a href="#cb129-30" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; Empty</span>
<span id="cb129-31"><a href="#cb129-31" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, _, Empty) <span class="kw">when</span> k = k2 -&gt; m1</span>
<span id="cb129-32"><a href="#cb129-32" aria-hidden="true" tabindex="-1"></a>    | T (Empty, k2, _, m2) <span class="kw">when</span> k = k2 -&gt; m2</span>
<span id="cb129-33"><a href="#cb129-33" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, _, m2) <span class="kw">when</span> k = k2 -&gt;</span>
<span id="cb129-34"><a href="#cb129-34" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> rk, rv, rm = split_rightmost m1 <span class="kw">in</span></span>
<span id="cb129-35"><a href="#cb129-35" aria-hidden="true" tabindex="-1"></a>        T (rm, rk, rv, m2)</span>
<span id="cb129-36"><a href="#cb129-36" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, v, m2) <span class="kw">when</span> k &lt; k2 -&gt; T (remove k m1, k2, v, m2)</span>
<span id="cb129-37"><a href="#cb129-37" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, v, m2) -&gt; T (m1, k2, v, remove k m2)</span>
<span id="cb129-38"><a href="#cb129-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-39"><a href="#cb129-39" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> find k m =</span>
<span id="cb129-40"><a href="#cb129-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb129-41"><a href="#cb129-41" aria-hidden="true" tabindex="-1"></a>    | Empty -&gt; <span class="dt">raise</span> <span class="dt">Not_found</span></span>
<span id="cb129-42"><a href="#cb129-42" aria-hidden="true" tabindex="-1"></a>    | T (_, k2, v, _) <span class="kw">when</span> k = k2 -&gt; v</span>
<span id="cb129-43"><a href="#cb129-43" aria-hidden="true" tabindex="-1"></a>    | T (m1, k2, _, _) <span class="kw">when</span> k &lt; k2 -&gt; find k m1</span>
<span id="cb129-44"><a href="#cb129-44" aria-hidden="true" tabindex="-1"></a>    | T (_, _, _, m2) -&gt; find k m2</span>
<span id="cb129-45"><a href="#cb129-45" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>The <code>member</code> and <code>find</code> functions use the
“divide-and-conquer” strategy: compare the target key with the key at
the current node, and recursively search in the appropriate subtree. The
<code>add</code> function searches the tree in the same way but copies
every node along the path to create the new tree (since we’re using
immutable data structures).</p>
<p>The <code>remove</code> function is trickier. When removing a node
with two children, we need to replace it with another value that
maintains the ordering property. The <code>split_rightmost</code> helper
function finds and removes the rightmost (largest) element from a
subtree – this element is guaranteed to be smaller than everything in
the right subtree and larger than everything remaining in the left
subtree, making it the perfect replacement.</p>
<h2 id="implementing-maps-red-black-trees">5.10 Implementing Maps:
Red-Black Trees</h2>
<p>The fatal weakness of ordinary binary search trees is that they can
become unbalanced. If keys arrive in sorted order, each insertion adds a
node at the bottom of a long chain, and we lose the logarithmic
performance guarantee. How can we maintain balance automatically?</p>
<p>This section is based on Wikipedia’s <a
href="http://en.wikipedia.org/wiki/Red-black_tree">Red-black tree
article</a>, Chris Okasaki’s “Purely Functional Data Structures” and
Matt Might’s excellent blog post on <a
href="http://matt.might.net/articles/red-black-delete/">red-black tree
deletion</a>.</p>
<p>Binary search trees are good when we encounter keys in random order,
because the cost of operations is limited by the depth of the tree which
is small relative to the number of nodes… unless the tree grows
unbalanced achieving large depth (which means there are sibling subtrees
of vastly different sizes on some path).</p>
<p>To remedy this, we <em>rebalance</em> the tree while building it –
i.e., while adding elements. The key insight is to detect when the tree
is becoming unbalanced and perform local rotations to restore
balance.</p>
<p>In <em>red-black trees</em> we achieve balance by: 1. Remembering one
of two colors (red or black) with each node 2. Keeping the same number
of black nodes on every path from the root to a leaf 3. Not allowing a
red node to have a red child</p>
<p>These invariants together guarantee that the tree cannot become too
unbalanced: the depth is at most twice the depth of a perfectly balanced
tree with the same number of nodes. Why? The “black height” (number of
black nodes on any root-to-leaf path) is the same everywhere, and red
nodes can only appear between black nodes, so the longest path can have
at most twice as many nodes as the shortest.</p>
<h3 id="b-trees-of-order-4-2-3-4-trees">B-trees of Order 4 (2-3-4
Trees)</h3>
<p>To understand where red-black trees come from, it helps to first
understand 2-3-4 trees (also known as B-trees of order 4).</p>
<p>How can we have perfectly balanced trees without worrying about
having exactly <span class="math inline">2^k - 1</span> elements? The
answer is to allow variable-width nodes. <strong>2-3-4 trees</strong>
can store from 1 to 3 elements in each node and have 2 to 4 subtrees
correspondingly. This flexibility lets us maintain perfect balance!</p>
<ul>
<li>A <strong>2-node</strong> contains one element and has two
children</li>
<li>A <strong>3-node</strong> contains two elements and has three
children</li>
<li>A <strong>4-node</strong> contains three elements and has four
children</li>
</ul>
<p>To insert into a 2-3-4 tree, we descend toward the appropriate leaf
position. But if we encounter a full node (4-node) along the way, we
“split” it: move the middle element up to the parent and split the
remaining two elements into separate 2-nodes. This maintains perfect
balance at all times – all leaves are at the same depth.</p>
<p>The remarkable fact is that red-black trees are just a clever way to
represent 2-3-4 trees as binary trees! To represent a 2-3-4 tree as a
binary tree with one element per node, we color the “primary” element of
each node black (the middle element of a 4-node, or the first element of
a 2-/3-node) and make it the parent of its neighbor elements colored
red. The red elements then become parents of the original subtrees. This
correspondence provides the deep intuition behind red-black trees: the
colors encode the structure of the underlying 2-3-4 tree.</p>
<h3 id="red-black-trees-without-deletion">Red-Black Trees, Without
Deletion</h3>
<p>Now let us implement red-black trees in OCaml. Red-black trees
maintain two invariants:</p>
<p><strong>Invariant 1.</strong> No red node has a red child. (No two
consecutive red nodes on any path.)</p>
<p><strong>Invariant 2.</strong> Every path from the root to an empty
node contains the same number of black nodes. (The “black height” is
uniform.)</p>
<p>For simplicity, we first implement red-black tree based <em>sets</em>
(not maps) without deletion. The implementation proceeds almost exactly
like for unbalanced binary search trees; we only need to add code to
restore the invariants after each insertion.</p>
<p>The beautiful insight of Okasaki’s approach is that by keeping
balance at each step of constructing a node, it is enough to check
<em>locally</em> (around the root of the subtree) whether a violation
has occurred. We never need to examine the entire tree. For an
understandable implementation of deletion, we need to introduce more
colors – see Matt Might’s post for details.</p>
<div class="sourceCode" id="cb130"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> color = R | B</span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a t = E | T <span class="kw">of</span> color * &#39;a t * &#39;a * &#39;a t</span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> empty = E</span>
<span id="cb130-5"><a href="#cb130-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-6"><a href="#cb130-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> member x m =                     <span class="co">(* Like in unbalanced binary search tree. *)</span></span>
<span id="cb130-7"><a href="#cb130-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb130-8"><a href="#cb130-8" aria-hidden="true" tabindex="-1"></a>  | E -&gt; <span class="kw">false</span></span>
<span id="cb130-9"><a href="#cb130-9" aria-hidden="true" tabindex="-1"></a>  | T (_, _, y, _) <span class="kw">when</span> x = y -&gt; <span class="kw">true</span></span>
<span id="cb130-10"><a href="#cb130-10" aria-hidden="true" tabindex="-1"></a>  | T (_, a, y, _) <span class="kw">when</span> x &lt; y -&gt; member x a</span>
<span id="cb130-11"><a href="#cb130-11" aria-hidden="true" tabindex="-1"></a>  | T (_, _, _, b) -&gt; member x b</span>
<span id="cb130-12"><a href="#cb130-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-13"><a href="#cb130-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> balance = <span class="kw">function</span>                   <span class="co">(* Restoring the invariants. *)</span></span>
<span id="cb130-14"><a href="#cb130-14" aria-hidden="true" tabindex="-1"></a>  | B, T (R, T (R,a,x,b), y, c), z, d    <span class="co">(* On next figure: left, *)</span></span>
<span id="cb130-15"><a href="#cb130-15" aria-hidden="true" tabindex="-1"></a>  | B, T (R, a, x, T (R,b,y,c)), z, d    <span class="co">(* top, *)</span></span>
<span id="cb130-16"><a href="#cb130-16" aria-hidden="true" tabindex="-1"></a>  | B, a, x, T (R, T (R,b,y,c), z, d)    <span class="co">(* bottom, *)</span></span>
<span id="cb130-17"><a href="#cb130-17" aria-hidden="true" tabindex="-1"></a>  | B, a, x, T (R, b, y, T (R,c,z,d))    <span class="co">(* right, *)</span></span>
<span id="cb130-18"><a href="#cb130-18" aria-hidden="true" tabindex="-1"></a>      -&gt; T (R, T (B,a,x,b), y, T (B,c,z,d))    <span class="co">(* center tree. *)</span></span>
<span id="cb130-19"><a href="#cb130-19" aria-hidden="true" tabindex="-1"></a>  | color, a, x, b -&gt; T (color, a, x, b)   <span class="co">(* We allow red-red violation for now. *)</span></span>
<span id="cb130-20"><a href="#cb130-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-21"><a href="#cb130-21" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> insert x s =</span>
<span id="cb130-22"><a href="#cb130-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> ins = <span class="kw">function</span>                 <span class="co">(* Like in unbalanced binary search tree, *)</span></span>
<span id="cb130-23"><a href="#cb130-23" aria-hidden="true" tabindex="-1"></a>    | E -&gt; T (R, E, x, E)                <span class="co">(* but fix violation above created node. *)</span></span>
<span id="cb130-24"><a href="#cb130-24" aria-hidden="true" tabindex="-1"></a>    | T (color, a, y, b) <span class="kw">as</span> s -&gt;</span>
<span id="cb130-25"><a href="#cb130-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> x &lt; y <span class="kw">then</span> balance (color, ins a, y, b)</span>
<span id="cb130-26"><a href="#cb130-26" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="kw">if</span> x &gt; y <span class="kw">then</span> balance (color, a, y, ins b)</span>
<span id="cb130-27"><a href="#cb130-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> s</span>
<span id="cb130-28"><a href="#cb130-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb130-29"><a href="#cb130-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> ins s <span class="kw">with</span>                       <span class="co">(* We could still have red-red violation *)</span></span>
<span id="cb130-30"><a href="#cb130-30" aria-hidden="true" tabindex="-1"></a>  | T (_, a, y, b) -&gt; T (B, a, y, b)     <span class="co">(* at root, fixed by coloring it black. *)</span></span>
<span id="cb130-31"><a href="#cb130-31" aria-hidden="true" tabindex="-1"></a>  | E -&gt; <span class="dt">failwith</span> <span class="st">&quot;insert: impossible&quot;</span></span></code></pre></div>
<p>The <code>balance</code> function is the heart of the algorithm. It
handles four cases where a red-red violation occurs (a red node with a
red child). The four cases correspond to different positions of the
violation:</p>
<ul>
<li>A red left child with a red left grandchild</li>
<li>A red left child with a red right grandchild</li>
<li>A red right child with a red left grandchild</li>
<li>A red right child with a red right grandchild</li>
</ul>
<p>In each case, we perform a “rotation” that restructures the tree to
eliminate the violation while maintaining the binary search tree
property. Remarkably, all four cases produce the same balanced result: a
red root with two black children, with the subtrees <code>a</code>,
<code>b</code>, <code>c</code>, <code>d</code> properly distributed.</p>
<p>The <code>insert</code> function works like insertion into an
ordinary binary search tree, but calls <code>balance</code> after each
recursive step to fix any violations that may have been introduced. New
nodes are always created red (which might create a red-red violation
that <code>balance</code> will fix). At the very end, we color the root
black – this can never create a violation and ensures the root is always
black.</p>
<h2 id="exercises-4">Exercises</h2>
<p><strong>Exercise 1.</strong> Derive the equations and solve them to
find the type for:</p>
<div class="sourceCode" id="cb131"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cadr l = <span class="dt">List</span>.hd (<span class="dt">List</span>.tl l) <span class="kw">in</span> cadr (<span class="dv">1</span>::<span class="dv">2</span>::[]), cadr (<span class="kw">true</span>::<span class="kw">false</span>::[])</span></code></pre></div>
<p>in environment <span class="math inline">\Gamma = \{ \text{List.hd} :
\forall \alpha . \alpha \ \text{list} \rightarrow \alpha ;
\text{List.tl} : \forall \alpha . \alpha \ \text{list} \rightarrow
\alpha \ \text{list} \}</span>. You can take “shortcuts” if it is too
many equations to write down.</p>
<p><strong>Exercise 2.</strong> <em>Terms</em> <span
class="math inline">t_1, t_2, \ldots \in T(\Sigma, X)</span> are built
out of variables <span class="math inline">x, y, \ldots \in X</span> and
function symbols <span class="math inline">f, g, \ldots \in
\Sigma</span> the way you build values out of functions:</p>
<ul>
<li><span class="math inline">X \subset T(\Sigma, X)</span> – variables
are terms; usually an infinite set,</li>
<li>for terms <span class="math inline">t_1, \ldots, t_n \in T(\Sigma,
X)</span> and a function symbol <span class="math inline">f \in
\Sigma_n</span> of arity <span class="math inline">n</span>, <span
class="math inline">f(t_1, \ldots, t_n) \in T(\Sigma, X)</span> – bigger
terms arise from applying function symbols to smaller terms; <span
class="math inline">\Sigma = \dot{\cup}_n \Sigma_n</span> is called a
signature.</li>
</ul>
<p>In OCaml, we can define terms as:
<code>type term = V of string | T of string * term list</code>, where
for example <code>V("x")</code> is a variable <span
class="math inline">x</span> and <code>T("f", [V("x"); V("y")])</code>
is the term <span class="math inline">f(x, y)</span>.</p>
<p>By <em>substitutions</em> <span class="math inline">\sigma, \rho,
\ldots</span> we mean finite sets of variable-term pairs which we can
write as <span class="math inline">\{x_1 \mapsto t_1, \ldots, x_k
\mapsto t_k\}</span> or <span class="math inline">[x_1 := t_1; \ldots;
x_k := t_k]</span>, but also functions from terms to terms <span
class="math inline">\sigma : T(\Sigma, X) \rightarrow T(\Sigma,
X)</span> related to the pairs as follows: if <span
class="math inline">\sigma = \{x_1 \mapsto t_1, \ldots, x_k \mapsto
t_k\}</span>, then</p>
<ul>
<li><span class="math inline">\sigma(x_i) = t_i</span> for <span
class="math inline">x_i \in \{x_1, \ldots, x_k\}</span>,</li>
<li><span class="math inline">\sigma(x) = x</span> for <span
class="math inline">x \in X \setminus \{x_1, \ldots, x_k\}</span>,</li>
<li><span class="math inline">\sigma(f(t_1, \ldots, t_n)) =
f(\sigma(t_1), \ldots, \sigma(t_n))</span>.</li>
</ul>
<p>In OCaml, we can define substitutions <span
class="math inline">\sigma</span> as:
<code>type subst = (string * term) list</code>, together with a function
<code>apply : subst -&gt; term -&gt; term</code> which computes <span
class="math inline">\sigma(\cdot)</span>.</p>
<p>We say that a substitution <span class="math inline">\sigma</span> is
<em>more general</em> than all substitutions <span
class="math inline">\rho \circ \sigma</span>, where <span
class="math inline">(\rho \circ \sigma)(x) = \rho(\sigma(x))</span>. In
type inference, we are interested in most general solutions.</p>
<p>A <em>unification problem</em> is a finite set of equations <span
class="math inline">S = \{s_1 =^? t_1, \ldots, s_n =^? t_n\}</span>. A
solution, or <em>unifier</em> of <span class="math inline">S</span>, is
a substitution <span class="math inline">\sigma</span> such that <span
class="math inline">\sigma(s_i) = \sigma(t_i)</span> for <span
class="math inline">i = 1, \ldots, n</span>. A <em>most general
unifier</em>, or <em>MGU</em>, is a most general such substitution.</p>
<ol type="1">
<li><p>Implement an algorithm that, given a set of equations represented
as a list of pairs of terms, computes an idempotent most general unifier
of the equations.</p></li>
<li><p>(Ex. 4.22 in Franz Baader and Tobias Nipkow “Term Rewriting and
All That”, p. 82.) Modify the implementation of unification to achieve
linear space complexity by working with what could be called iterated
substitutions.</p></li>
</ol>
<p><strong>Exercise 3.</strong></p>
<ol type="1">
<li>What does it mean that an implementation has junk (as an algebraic
structure for a given signature)? Is it bad?</li>
<li>Define a monomorphic algebraic specification (other than, but
similar to, <span class="math inline">\text{nat}_p</span> or <span
class="math inline">\text{string}_p</span>, some useful data type).</li>
<li>Discuss an example of a (monomorphic) algebraic specification where
it would be useful to drop some axioms (giving up monomorphicity) to
allow more efficient implementations.</li>
</ol>
<p><strong>Exercise 4.</strong></p>
<ol type="1">
<li><p>Does the example <code>ListMap</code> meet the requirements of
the algebraic specification for maps? Hint: here is the definition of
<code>List.remove_assoc</code>; <code>compare a x</code> equals
<code>0</code> if and only if <code>a = x</code>.</p>
<div class="sourceCode" id="cb132"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> remove_assoc x = <span class="kw">function</span></span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; []</span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a>  | (a, b <span class="kw">as</span> pair) :: l -&gt;</span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> <span class="dt">compare</span> a x = <span class="dv">0</span> <span class="kw">then</span> l <span class="kw">else</span> pair :: remove_assoc x l</span></code></pre></div></li>
<li><p>Trick question: what is the computational complexity of
<code>ListMap</code> or <code>TrivialMap</code>?</p></li>
<li><p>(*) The implementation <code>MyListMap</code> is inefficient: it
performs a lot of copying and is not tail-recursive. Optimize it
(without changing the type definition).</p></li>
<li><p>Add (and specify) <span class="math inline">\text{isEmpty} :
(\alpha, \beta) \ \text{map} \rightarrow \text{bool}</span> to the
example algebraic specification of maps without increasing the burden on
its implementations. Hint: equational reasoning might be not enough;
consider an equivalence relation <span
class="math inline">\approx</span> meaning “have the same
keys”.</p></li>
</ol>
<p><strong>Exercise 5.</strong> Design an algebraic specification and
write a signature for first-in-first-out queues. Provide two
implementations: one straightforward using a list, and another one using
two lists: one for freshly added elements providing efficient queueing
of new elements, and “reversed” one for efficient popping of old
elements.</p>
<p><strong>Exercise 6.</strong> Design an algebraic specification and
write a signature for sets. Provide two implementations: one
straightforward using a list, and another one using a map into the unit
type.</p>
<p><strong>Exercise 7.</strong></p>
<ol type="1">
<li><p>(Ex. 2.2 in Chris Okasaki “Purely Functional Data Structures”) In
the worst case, <code>member</code> performs approximately <span
class="math inline">2d</span> comparisons, where <span
class="math inline">d</span> is the depth of the tree. Rewrite
<code>member</code> to take no more than <span class="math inline">d +
1</span> comparisons by keeping track of a candidate element that
<em>might</em> be equal to the query element (say, the last element for
which <span class="math inline">&lt;</span> returned false) and checking
for equality only when you hit the bottom of the tree.</p></li>
<li><p>(Ex. 3.10 in Chris Okasaki “Purely Functional Data Structures”)
The <code>balance</code> function currently performs several unnecessary
tests: when e.g. <code>ins</code> recurses on the left child, there are
no violations on the right child.</p>
<ul>
<li>Split <code>balance</code> into <code>lbalance</code> and
<code>rbalance</code> that test for violations of left resp. right child
only. Replace calls to <code>balance</code> appropriately.</li>
<li>One of the remaining tests on grandchildren is also unnecessary.
Rewrite <code>ins</code> so that it never tests the color of nodes not
on the search path.</li>
</ul></li>
</ol>
<p><strong>Exercise 8.</strong> (*) Implement maps (i.e. write a module
for the map signature) based on AVL trees. See
<code>http://en.wikipedia.org/wiki/AVL_tree</code>.</p>
<h1 id="chapter-6-folding-and-backtracking">Chapter 6: Folding and
Backtracking</h1>
<p><strong>In this chapter, you will:</strong></p>
<ul>
<li>Identify common recursion patterns and refactor them into
<code>map</code>/<code>fold</code> abstractions</li>
<li>Make folds tail-recursive using accumulators (and understand the
trade-offs)</li>
<li>Generalize <code>map</code>/<code>fold</code> beyond lists to trees
and expression grammars</li>
<li>Use backtracking (via lists) to solve search problems and
puzzles</li>
</ul>
<p>This chapter explores two fundamental programming paradigms in
functional programming: <strong>folding</strong> (also known as
reduction) and <strong>backtracking</strong>. We begin with the classic
<code>map</code> and <code>fold</code> higher-order functions, examine
how they generalize to trees and other data structures, then move on to
solving puzzles using backtracking with lists.</p>
<p>The material in this chapter draws from Martin Odersky’s “Functional
Programming Fundamentals,” Ralf Laemmel’s “Going Bananas,” Graham
Hutton’s “Programming in Haskell” (Chapter 11 on the Countdown Problem),
and Tomasz Wierzbicki’s Honey Islands Puzzle Solver.</p>
<h2 id="basic-generic-list-operations">6.1 Basic Generic List
Operations</h2>
<p>Functional programming emphasizes identifying common patterns and
abstracting them into reusable higher-order functions. Rather than
writing similar code repeatedly, we extract the common structure into a
single generic function. Let us see how this principle works in practice
through two motivating examples.</p>
<h3 id="the-map-function">The <code>map</code> Function</h3>
<p>How do we print a comma-separated list of integers? The
<code>String</code> module provides a function that joins strings with a
separator:</p>
<pre><code>val concat : string -&gt; string list -&gt; string</code></pre>
<p>But <code>String.concat</code> works on strings, not integers. So
first, we need to convert numbers into strings:</p>
<div class="sourceCode" id="cb134"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> strings_of_ints = <span class="kw">function</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; []</span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>  | hd::tl -&gt; <span class="dt">string_of_int</span> hd :: strings_of_ints tl</span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> comma_sep_ints = <span class="dt">String</span>.concat <span class="st">&quot;, &quot;</span> -| strings_of_ints</span></code></pre></div>
<p>Here is another common task: how do we sort strings from shortest to
longest? We can pair each string with its length and then sort by the
first component. First, let us compute the lengths:</p>
<div class="sourceCode" id="cb135"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> strings_lengths = <span class="kw">function</span></span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; []</span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a>  | hd::tl -&gt; (<span class="dt">String</span>.length hd, hd) :: strings_lengths tl</span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> by_size = <span class="dt">List</span>.sort <span class="dt">compare</span> -| strings_lengths</span></code></pre></div>
<p>Now, look carefully at <code>strings_of_ints</code> and
<code>strings_lengths</code>. Do you notice the common structure? Both
functions traverse a list and transform each element independently – one
applies <code>string_of_int</code>, the other applies a function that
pairs a string with its length. The recursive structure is identical;
only the transformation differs.</p>
<p>This is our cue to <em>extract the common pattern</em> into a generic
higher-order function. We call it <code>map</code>:</p>
<div class="sourceCode" id="cb136"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> list_map f = <span class="kw">function</span></span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; []</span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a>  | hd::tl -&gt; f hd :: list_map f tl</span></code></pre></div>
<p>Now we can rewrite our functions more concisely:</p>
<div class="sourceCode" id="cb137"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> comma_sep_ints =</span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">String</span>.concat <span class="st">&quot;, &quot;</span> -| list_map <span class="dt">string_of_int</span></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> by_size =</span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.sort <span class="dt">compare</span> -| list_map (<span class="kw">fun</span> s -&gt; <span class="dt">String</span>.length s, s)</span></code></pre></div>
<h3 id="the-fold-function">The <code>fold</code> Function</h3>
<p>Now let us consider a different kind of pattern. How do we sum all
the elements of a list?</p>
<div class="sourceCode" id="cb138"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> balance = <span class="kw">function</span></span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; <span class="dv">0</span></span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a>  | hd::tl -&gt; hd + balance tl</span></code></pre></div>
<p>And how do we multiply all the elements together (perhaps to compute
a cumulative ratio)?</p>
<div class="sourceCode" id="cb139"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> total_ratio = <span class="kw">function</span></span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; <span class="dv">1</span>.</span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true" tabindex="-1"></a>  | hd::tl -&gt; hd *. total_ratio tl</span></code></pre></div>
<p>Again, the recursive structure is the same. In both cases, we combine
each element with the result of processing the rest of the list. The
differences are: (1) what we return for the empty list (the “base case”
or “identity element”), and (2) how we combine the head with the
recursive result. This pattern is called <strong>folding</strong>:</p>
<div class="sourceCode" id="cb140"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> list_fold f base = <span class="kw">function</span></span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; base</span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a>  | hd::tl -&gt; f hd (list_fold f base tl)</span></code></pre></div>
<p><strong>Important:</strong> Note that <code>list_fold f base l</code>
equals <code>List.fold_right f l base</code>. The OCaml standard library
uses a different argument order, so be careful when using
<code>List.fold_right</code>.</p>
<p>The key insight is understanding the fundamental difference between
<code>map</code> and <code>fold</code>:</p>
<ul>
<li><strong><code>map</code></strong> alters the <em>contents</em> of a
data structure without changing its shape. The output list has the same
length as the input; we merely transform each element.</li>
<li><strong><code>fold</code></strong> <em>collapses</em> a data
structure down to a single value, using the structure itself as
scaffolding for the computation.</li>
</ul>
<p>Visually, consider what happens to the list
<code>[a; b; c; d]</code>:</p>
<ul>
<li><code>map f</code> transforms: <code>[a; b; c; d]</code> becomes
<code>[f a; f b; f c; f d]</code> – same structure, different
contents</li>
<li><code>fold f accu</code> collapses: <code>[a; b; c; d]</code>
becomes <code>f a (f b (f c (f d accu)))</code> – structure disappears,
single value remains</li>
</ul>
<h2 id="making-fold-tail-recursive">6.2 Making Fold Tail-Recursive</h2>
<p>Our <code>list_fold</code> function above is not tail-recursive: it
builds up a chain of deferred <code>f</code> applications on the call
stack. For very long lists, this can cause stack overflow. Can we make
folding tail-recursive?</p>
<p>Let us investigate some tail-recursive list functions to find a
pattern. Consider reversing a list:</p>
<div class="sourceCode" id="cb141"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> list_rev acc = <span class="kw">function</span></span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; acc</span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a>  | hd::tl -&gt; list_rev (hd::acc) tl</span></code></pre></div>
<p>The key technique here is the <em>accumulator</em> parameter
<code>acc</code>. Instead of building up work to do after the recursive
call returns, we do the work <em>before</em> the recursive call and pass
the intermediate result along.</p>
<p>Here is another example – computing an average by tracking both the
running sum and the count:</p>
<div class="sourceCode" id="cb142"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> average (sum, tot) = <span class="kw">function</span></span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a>  | [] <span class="kw">when</span> tot = <span class="dv">0</span>. -&gt; <span class="dv">0</span>.</span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; sum /. tot</span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a>  | hd::tl -&gt; average (hd +. sum, <span class="dv">1</span>. +. tot) tl</span></code></pre></div>
<p>Notice how these functions process elements from left to right,
threading an accumulator through the computation. This is the pattern of
<code>fold_left</code>:</p>
<div class="sourceCode" id="cb143"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fold_left f accu = <span class="kw">function</span></span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; accu</span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true" tabindex="-1"></a>  | a::l -&gt; fold_left f (f accu a) l</span></code></pre></div>
<p>With <code>fold_left</code>, expressing our earlier functions becomes
straightforward – we hide the accumulator inside the initial value:</p>
<div class="sourceCode" id="cb144"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> list_rev l =</span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a>  fold_left (<span class="kw">fun</span> t h -&gt; h::t) [] l</span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> average =</span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a>  fold_left (<span class="kw">fun</span> (sum, tot) e -&gt; sum +. e, <span class="dv">1</span>. +. tot) (<span class="dv">0</span>., <span class="dv">0</span>.)</span></code></pre></div>
<p>Note that the <code>average</code> example is slightly trickier than
<code>list_rev</code> because we need to track two values (sum and
count) rather than one.</p>
<p><strong>Why the names <code>fold_right</code> and
<code>fold_left</code>?</strong> The names reflect the associativity of
the combining operation:</p>
<ul>
<li><p><code>fold_right f</code> makes <code>f</code> <strong>right
associative</strong>, like the list constructor <code>::</code>:
<code>List.fold_right f [a1; ...; an] b</code> is
<code>f a1 (f a2 (... (f an b) ...))</code></p></li>
<li><p><code>fold_left f</code> makes <code>f</code> <strong>left
associative</strong>, like function application:
<code>List.fold_left f a [b1; ...; bn]</code> is
<code>f (... (f (f a b1) b2) ...) bn</code></p></li>
</ul>
<p>This “backward” structure of <code>fold_left</code> can be visualized
by comparing the shape of the input list with the shape of the
computation tree. The input list has a right-leaning spine (because
<code>::</code> associates to the right), while <code>fold_left</code>
produces a computation tree with a left-leaning spine:</p>
<div class="figure">
<pre><code>    Input list              Result computation

        ::                         f
       /  \                       / \
      a    ::                    f   d
          /  \                  / \
         b    ::               f   c
             /  \             / \
            c    ::          f   b
                /  \        / \
               d    []  accu   a</code></pre>
<p><strong>Figure: List spine vs. fold_left computation
tree</strong></p>
</div>
<p>This reversal of structure is why <code>fold_left</code> naturally
reverses lists when the combining operation is <code>cons</code>.</p>
<h3 id="useful-derived-functions">Useful Derived Functions</h3>
<p>Many common list operations can be expressed elegantly using folds.
List filtering selects elements satisfying a predicate – naturally
expressed using <code>fold_right</code> to preserve order:</p>
<div class="sourceCode" id="cb146"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> list_filter p l =</span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.fold_right (<span class="kw">fun</span> h t -&gt; <span class="kw">if</span> p h <span class="kw">then</span> h::t <span class="kw">else</span> t) l []</span></code></pre></div>
<p>When we need a tail-recursive map and can tolerate reversed output,
<code>fold_left</code> gives us <code>rev_map</code>:</p>
<div class="sourceCode" id="cb147"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> list_rev_map f l =</span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.fold_left (<span class="kw">fun</span> t h -&gt; f h :: t) [] l</span></code></pre></div>
<h2 id="map-and-fold-for-trees-and-other-structures">6.3 Map and Fold
for Trees and Other Structures</h2>
<p>The <code>map</code> and <code>fold</code> patterns are not limited
to lists. They apply to any recursive data structure. The key insight is
that <code>map</code> preserves structure while transforming contents,
and <code>fold</code> collapses structure into a single value.</p>
<h3 id="binary-trees">Binary Trees</h3>
<p>Mapping binary trees is straightforward:</p>
<div class="sourceCode" id="cb148"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a btree = Empty | Node <span class="kw">of</span> &#39;a * &#39;a btree * &#39;a btree</span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb148-3"><a href="#cb148-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> bt_map f = <span class="kw">function</span></span>
<span id="cb148-4"><a href="#cb148-4" aria-hidden="true" tabindex="-1"></a>  | Empty -&gt; Empty</span>
<span id="cb148-5"><a href="#cb148-5" aria-hidden="true" tabindex="-1"></a>  | Node (e, l, r) -&gt; Node (f e, bt_map f l, bt_map f r)</span>
<span id="cb148-6"><a href="#cb148-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb148-7"><a href="#cb148-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> test = Node</span>
<span id="cb148-8"><a href="#cb148-8" aria-hidden="true" tabindex="-1"></a>  (<span class="dv">3</span>, Node (<span class="dv">5</span>, Empty, Empty), Node (<span class="dv">7</span>, Empty, Empty))</span>
<span id="cb148-9"><a href="#cb148-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> _ = bt_map ((+) <span class="dv">1</span>) test</span></code></pre></div>
<p><strong>A note on terminology:</strong> The <code>map</code> and
<code>fold</code> functions we define here preserve and respect the
structure of data. They are different from the <code>map</code> and
<code>fold</code> operations you might find in abstract data type
container libraries, which often behave more like
<code>List.rev_map</code> and <code>List.fold_left</code> over container
elements in arbitrary order. Here we are generalizing
<code>List.map</code> and <code>List.fold_right</code> to other
structures.</p>
<p>For binary trees, the most general form of <code>fold</code>
processes each element together with the partial results already
computed for its subtrees:</p>
<div class="sourceCode" id="cb149"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> bt_fold f base = <span class="kw">function</span></span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true" tabindex="-1"></a>  | Empty -&gt; base</span>
<span id="cb149-3"><a href="#cb149-3" aria-hidden="true" tabindex="-1"></a>  | Node (e, l, r) -&gt;</span>
<span id="cb149-4"><a href="#cb149-4" aria-hidden="true" tabindex="-1"></a>    f e (bt_fold f base l) (bt_fold f base r)</span></code></pre></div>
<p>Here are two examples showing how <code>bt_fold</code> can compute
different properties of a tree:</p>
<div class="sourceCode" id="cb150"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> sum_els = bt_fold (<span class="kw">fun</span> i l r -&gt; i + l + r) <span class="dv">0</span></span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> depth t = bt_fold (<span class="kw">fun</span> _ l r -&gt; <span class="dv">1</span> + <span class="dt">max</span> l r) <span class="dv">1</span> t</span></code></pre></div>
<p>The first computes the sum of all elements (the combining function
adds the current element to the sums of both subtrees). The second
computes the depth – we ignore the element value and take the maximum
depth of the subtrees, adding 1 for the current level.</p>
<h3 id="more-complex-structures-expressions">More Complex Structures:
Expressions</h3>
<p>Real-world data types often have more than two cases. To demonstrate
map and fold for more complex structures, let us recall the expression
type from Chapter 3:</p>
<div class="sourceCode" id="cb151"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> expression =</span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a>    Const <span class="kw">of</span> <span class="dt">float</span></span>
<span id="cb151-3"><a href="#cb151-3" aria-hidden="true" tabindex="-1"></a>  | Var <span class="kw">of</span> <span class="dt">string</span></span>
<span id="cb151-4"><a href="#cb151-4" aria-hidden="true" tabindex="-1"></a>  | Sum <span class="kw">of</span> expression * expression    <span class="co">(* e1 + e2 *)</span></span>
<span id="cb151-5"><a href="#cb151-5" aria-hidden="true" tabindex="-1"></a>  | Diff <span class="kw">of</span> expression * expression   <span class="co">(* e1 - e2 *)</span></span>
<span id="cb151-6"><a href="#cb151-6" aria-hidden="true" tabindex="-1"></a>  | Prod <span class="kw">of</span> expression * expression   <span class="co">(* e1 * e2 *)</span></span>
<span id="cb151-7"><a href="#cb151-7" aria-hidden="true" tabindex="-1"></a>  | Quot <span class="kw">of</span> expression * expression   <span class="co">(* e1 / e2 *)</span></span></code></pre></div>
<p>The multitude of cases makes this datatype harder to work with than
binary trees. Fortunately, OCaml’s <em>or-patterns</em> help us handle
multiple similar cases together:</p>
<div class="sourceCode" id="cb152"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> vars = <span class="kw">function</span></span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a>  | Const _ -&gt; []</span>
<span id="cb152-3"><a href="#cb152-3" aria-hidden="true" tabindex="-1"></a>  | Var x -&gt; [x]</span>
<span id="cb152-4"><a href="#cb152-4" aria-hidden="true" tabindex="-1"></a>  | Sum (a,b) | Diff (a,b) | Prod (a,b) | Quot (a,b) -&gt;</span>
<span id="cb152-5"><a href="#cb152-5" aria-hidden="true" tabindex="-1"></a>    vars a @ vars b</span></code></pre></div>
<p>For a generic <code>map</code> and <code>fold</code> over
expressions, we need to specify behavior for each case. Since there are
many cases, we pack all the behaviors into records. This way, we can
define default behaviors and then override just the cases we care
about:</p>
<div class="sourceCode" id="cb153"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> expression_map = {</span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a>  map_const : <span class="dt">float</span> -&gt; expression;</span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a>  map_var : <span class="dt">string</span> -&gt; expression;</span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true" tabindex="-1"></a>  map_sum : expression -&gt; expression -&gt; expression;</span>
<span id="cb153-5"><a href="#cb153-5" aria-hidden="true" tabindex="-1"></a>  map_diff : expression -&gt; expression -&gt; expression;</span>
<span id="cb153-6"><a href="#cb153-6" aria-hidden="true" tabindex="-1"></a>  map_prod : expression -&gt; expression -&gt; expression;</span>
<span id="cb153-7"><a href="#cb153-7" aria-hidden="true" tabindex="-1"></a>  map_quot : expression -&gt; expression -&gt; expression;</span>
<span id="cb153-8"><a href="#cb153-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb153-9"><a href="#cb153-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-10"><a href="#cb153-10" aria-hidden="true" tabindex="-1"></a><span class="co">(*</span></span>
<span id="cb153-11"><a href="#cb153-11" aria-hidden="true" tabindex="-1"></a><span class="co">   Note: In expression_fold, we use &#39;a instead of expression because</span></span>
<span id="cb153-12"><a href="#cb153-12" aria-hidden="true" tabindex="-1"></a><span class="co">   fold produces values of arbitrary type, not necessarily expressions.</span></span>
<span id="cb153-13"><a href="#cb153-13" aria-hidden="true" tabindex="-1"></a><span class="co">*)</span></span>
<span id="cb153-14"><a href="#cb153-14" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a expression_fold = {</span>
<span id="cb153-15"><a href="#cb153-15" aria-hidden="true" tabindex="-1"></a>  fold_const : <span class="dt">float</span> -&gt; &#39;a;</span>
<span id="cb153-16"><a href="#cb153-16" aria-hidden="true" tabindex="-1"></a>  fold_var : <span class="dt">string</span> -&gt; &#39;a;</span>
<span id="cb153-17"><a href="#cb153-17" aria-hidden="true" tabindex="-1"></a>  fold_sum : &#39;a -&gt; &#39;a -&gt; &#39;a;</span>
<span id="cb153-18"><a href="#cb153-18" aria-hidden="true" tabindex="-1"></a>  fold_diff : &#39;a -&gt; &#39;a -&gt; &#39;a;</span>
<span id="cb153-19"><a href="#cb153-19" aria-hidden="true" tabindex="-1"></a>  fold_prod : &#39;a -&gt; &#39;a -&gt; &#39;a;</span>
<span id="cb153-20"><a href="#cb153-20" aria-hidden="true" tabindex="-1"></a>  fold_quot : &#39;a -&gt; &#39;a -&gt; &#39;a;</span>
<span id="cb153-21"><a href="#cb153-21" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Now we define standard “default” behaviors. The
<code>identity_map</code> reconstructs the same expression (useful as a
starting point when we only want to change one case), and
<code>make_fold</code> creates a fold where all binary operators behave
the same:</p>
<div class="sourceCode" id="cb154"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> identity_map = {</span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a>  map_const = (<span class="kw">fun</span> c -&gt; Const c);</span>
<span id="cb154-3"><a href="#cb154-3" aria-hidden="true" tabindex="-1"></a>  map_var = (<span class="kw">fun</span> x -&gt; Var x);</span>
<span id="cb154-4"><a href="#cb154-4" aria-hidden="true" tabindex="-1"></a>  map_sum = (<span class="kw">fun</span> a b -&gt; Sum (a, b));</span>
<span id="cb154-5"><a href="#cb154-5" aria-hidden="true" tabindex="-1"></a>  map_diff = (<span class="kw">fun</span> a b -&gt; Diff (a, b));</span>
<span id="cb154-6"><a href="#cb154-6" aria-hidden="true" tabindex="-1"></a>  map_prod = (<span class="kw">fun</span> a b -&gt; Prod (a, b));</span>
<span id="cb154-7"><a href="#cb154-7" aria-hidden="true" tabindex="-1"></a>  map_quot = (<span class="kw">fun</span> a b -&gt; Quot (a, b));</span>
<span id="cb154-8"><a href="#cb154-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb154-9"><a href="#cb154-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-10"><a href="#cb154-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> make_fold op base = {</span>
<span id="cb154-11"><a href="#cb154-11" aria-hidden="true" tabindex="-1"></a>  fold_const = (<span class="kw">fun</span> _ -&gt; base);</span>
<span id="cb154-12"><a href="#cb154-12" aria-hidden="true" tabindex="-1"></a>  fold_var = (<span class="kw">fun</span> _ -&gt; base);</span>
<span id="cb154-13"><a href="#cb154-13" aria-hidden="true" tabindex="-1"></a>  fold_sum = op; fold_diff = op;</span>
<span id="cb154-14"><a href="#cb154-14" aria-hidden="true" tabindex="-1"></a>  fold_prod = op; fold_quot = op;</span>
<span id="cb154-15"><a href="#cb154-15" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The actual <code>map</code> and <code>fold</code> functions:</p>
<div class="sourceCode" id="cb155"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> expr_map emap = <span class="kw">function</span></span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a>  | Const c -&gt; emap.map_const c</span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true" tabindex="-1"></a>  | Var x -&gt; emap.map_var x</span>
<span id="cb155-4"><a href="#cb155-4" aria-hidden="true" tabindex="-1"></a>  | Sum (a,b) -&gt; emap.map_sum (expr_map emap a) (expr_map emap b)</span>
<span id="cb155-5"><a href="#cb155-5" aria-hidden="true" tabindex="-1"></a>  | Diff (a,b) -&gt; emap.map_diff (expr_map emap a) (expr_map emap b)</span>
<span id="cb155-6"><a href="#cb155-6" aria-hidden="true" tabindex="-1"></a>  | Prod (a,b) -&gt; emap.map_prod (expr_map emap a) (expr_map emap b)</span>
<span id="cb155-7"><a href="#cb155-7" aria-hidden="true" tabindex="-1"></a>  | Quot (a,b) -&gt; emap.map_quot (expr_map emap a) (expr_map emap b)</span>
<span id="cb155-8"><a href="#cb155-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb155-9"><a href="#cb155-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> expr_fold efold = <span class="kw">function</span></span>
<span id="cb155-10"><a href="#cb155-10" aria-hidden="true" tabindex="-1"></a>  | Const c -&gt; efold.fold_const c</span>
<span id="cb155-11"><a href="#cb155-11" aria-hidden="true" tabindex="-1"></a>  | Var x -&gt; efold.fold_var x</span>
<span id="cb155-12"><a href="#cb155-12" aria-hidden="true" tabindex="-1"></a>  | Sum (a,b) -&gt; efold.fold_sum (expr_fold efold a) (expr_fold efold b)</span>
<span id="cb155-13"><a href="#cb155-13" aria-hidden="true" tabindex="-1"></a>  | Diff (a,b) -&gt; efold.fold_diff (expr_fold efold a) (expr_fold efold b)</span>
<span id="cb155-14"><a href="#cb155-14" aria-hidden="true" tabindex="-1"></a>  | Prod (a,b) -&gt; efold.fold_prod (expr_fold efold a) (expr_fold efold b)</span>
<span id="cb155-15"><a href="#cb155-15" aria-hidden="true" tabindex="-1"></a>  | Quot (a,b) -&gt; efold.fold_quot (expr_fold efold a) (expr_fold efold b)</span></code></pre></div>
<p>Now here is the payoff. Using OCaml’s
<code>{record with field = value}</code> syntax, we can easily customize
behaviors for specific uses by starting from the defaults and overriding
just what we need:</p>
<div class="sourceCode" id="cb156"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> prime_vars = expr_map</span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a>  {identity_map <span class="kw">with</span> map_var = <span class="kw">fun</span> x -&gt; Var (x ^ <span class="st">&quot;&#39;&quot;</span>)}</span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-4"><a href="#cb156-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> subst s =</span>
<span id="cb156-5"><a href="#cb156-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> apply x = <span class="kw">try</span> <span class="dt">List</span>.assoc x s <span class="kw">with</span> <span class="dt">Not_found</span> -&gt; Var x <span class="kw">in</span></span>
<span id="cb156-6"><a href="#cb156-6" aria-hidden="true" tabindex="-1"></a>  expr_map {identity_map <span class="kw">with</span> map_var = apply}</span>
<span id="cb156-7"><a href="#cb156-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-8"><a href="#cb156-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> vars =</span>
<span id="cb156-9"><a href="#cb156-9" aria-hidden="true" tabindex="-1"></a>  expr_fold {(make_fold (@) []) <span class="kw">with</span> fold_var = <span class="kw">fun</span> x -&gt; [x]}</span>
<span id="cb156-10"><a href="#cb156-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-11"><a href="#cb156-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> size = expr_fold (make_fold (<span class="kw">fun</span> a b -&gt; <span class="dv">1</span> + a + b) <span class="dv">1</span>)</span>
<span id="cb156-12"><a href="#cb156-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-13"><a href="#cb156-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> eval env = expr_fold {</span>
<span id="cb156-14"><a href="#cb156-14" aria-hidden="true" tabindex="-1"></a>  fold_const = id;</span>
<span id="cb156-15"><a href="#cb156-15" aria-hidden="true" tabindex="-1"></a>  fold_var = (<span class="kw">fun</span> x -&gt; <span class="dt">List</span>.assoc x env);</span>
<span id="cb156-16"><a href="#cb156-16" aria-hidden="true" tabindex="-1"></a>  fold_sum = (+.); fold_diff = (-.);</span>
<span id="cb156-17"><a href="#cb156-17" aria-hidden="true" tabindex="-1"></a>  fold_prod = ( *.); fold_quot = (/.);</span>
<span id="cb156-18"><a href="#cb156-18" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h2 id="point-free-programming">6.4 Point-Free Programming</h2>
<p>In 1977/78, John Backus – the designer of FORTRAN and BNF notation –
introduced <strong>FP</strong>, the first <em>function-level
programming</em> language. This was a radical departure from the
prevailing style: rather than manipulating variables and values,
programs were built entirely by combining functions. Over the next
decade, FP evolved into the <strong>FL</strong> language.</p>
<p>The philosophy behind function-level programming is captured in this
quote:</p>
<blockquote>
<p>“Clarity is achieved when programs are written at the function level
– that is, by putting together existing programs to form new ones,
rather than by manipulating objects and then abstracting from those
objects to produce programs.” – <em>The FL Project: The Design of a
Functional Language</em></p>
</blockquote>
<p>This style is sometimes called <strong>point-free</strong> or
<strong>tacit</strong> programming, because we never mention the
“points” (values) that functions operate on – we only talk about the
functions themselves and how they combine.</p>
<p>To write in this style, we need a toolkit of
<strong>combinators</strong> – higher-order functions that combine other
functions. Here are some common ones, similar to what you will find in
the <em>OCaml Batteries</em> library:</p>
<div class="sourceCode" id="cb157"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> const x _ = x</span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ( |- ) f g x = g (f x)          <span class="co">(* forward composition *)</span></span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ( -| ) f g x = f (g x)          <span class="co">(* backward composition *)</span></span>
<span id="cb157-4"><a href="#cb157-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> flip f x y = f y x</span>
<span id="cb157-5"><a href="#cb157-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ( *** ) f g = <span class="kw">fun</span> (x,y) -&gt; (f x, g y)</span>
<span id="cb157-6"><a href="#cb157-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ( &amp;&amp;&amp; ) f g = <span class="kw">fun</span> x -&gt; (f x, g x)</span>
<span id="cb157-7"><a href="#cb157-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> first f x = <span class="dt">fst</span> (f x)</span>
<span id="cb157-8"><a href="#cb157-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> second f x = <span class="dt">snd</span> (f x)</span>
<span id="cb157-9"><a href="#cb157-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> curry f x y = f (x,y)</span>
<span id="cb157-10"><a href="#cb157-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> uncurry f (x,y) = f x y</span></code></pre></div>
<p>One way to understand point-free programming is to visualize the flow
of computation as a circuit. Values flow through the circuit, being
transformed by functions at each node. Cross-sections of the circuit can
be represented as tuples of intermediate values.</p>
<p>Consider this simple function that converts a character and an
integer to a string:</p>
<div class="sourceCode" id="cb158"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> print2 c i =</span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> a = <span class="dt">Char</span>.escaped c <span class="kw">in</span></span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> b = <span class="dt">string_of_int</span> i <span class="kw">in</span></span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true" tabindex="-1"></a>  a ^ b</span></code></pre></div>
<p>We can visualize this as a circuit: <code>(c, i)</code> enters,
<code>c</code> flows through <code>Char.escaped</code>, <code>i</code>
flows through <code>string_of_int</code>, and the results meet at
<code>(^)</code>. In point-free style, we express this directly:</p>
<div class="sourceCode" id="cb159"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> print2 = curry</span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a>  ((<span class="dt">Char</span>.escaped *** <span class="dt">string_of_int</span>) |- uncurry (^))</span></code></pre></div>
<p>Here <code>***</code> applies two functions in parallel to the
components of a pair, <code>|-</code> is forward composition,
<code>uncurry</code> converts a curried function to take a pair, and
<code>curry</code> converts back.</p>
<p><strong>Why the name “currying”?</strong> Converting a C/Pascal-style
function (that takes all arguments as a tuple) into one that takes
arguments one at a time is called <em>currying</em>, after the logician
Haskell Brooks Curry. Since OCaml functions naturally take arguments one
at a time, we often need <code>uncurry</code> to interface with
tuple-based operations, and <code>curry</code> to convert back.</p>
<p>Another approach to point-free style avoids tuples entirely, using
function composition, <code>flip</code>, and the <strong>S</strong>
combinator:</p>
<div class="sourceCode" id="cb160"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> s x y z = x z (y z)</span></code></pre></div>
<p>The S combinator allows us to pass one argument to two different
functions and combine their results. This can bring a particular
argument of a function to the “front” and pass it to another
function.</p>
<p>Here is an extended example showing step-by-step transformation of a
filter-map function into point-free style:</p>
<div class="sourceCode" id="cb161"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> func2 f g l = <span class="dt">List</span>.filter f (<span class="dt">List</span>.map g l)</span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a><span class="co">(* Step 1: Recognize that filter-after-map is composition *)</span></span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> func2 f g = (-|) (<span class="dt">List</span>.filter f) (<span class="dt">List</span>.map g)</span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a><span class="co">(* Step 2: Eliminate l by composing with List.map *)</span></span>
<span id="cb161-5"><a href="#cb161-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> func2 f = (-|) (<span class="dt">List</span>.filter f) -| <span class="dt">List</span>.map</span>
<span id="cb161-6"><a href="#cb161-6" aria-hidden="true" tabindex="-1"></a><span class="co">(* Step 3: Rewrite without infix notation to see the structure *)</span></span>
<span id="cb161-7"><a href="#cb161-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> func2 f = (-|) ((-|) (<span class="dt">List</span>.filter f)) <span class="dt">List</span>.map</span>
<span id="cb161-8"><a href="#cb161-8" aria-hidden="true" tabindex="-1"></a><span class="co">(* Step 4: Use flip to rearrange arguments *)</span></span>
<span id="cb161-9"><a href="#cb161-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> func2 f = flip (-|) <span class="dt">List</span>.map ((-|) (<span class="dt">List</span>.filter f))</span>
<span id="cb161-10"><a href="#cb161-10" aria-hidden="true" tabindex="-1"></a><span class="co">(* Step 5: Factor out f using composition *)</span></span>
<span id="cb161-11"><a href="#cb161-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> func2 f = (((|-) <span class="dt">List</span>.map) -| ((-|) -| <span class="dt">List</span>.filter)) f</span>
<span id="cb161-12"><a href="#cb161-12" aria-hidden="true" tabindex="-1"></a><span class="co">(* Step 6: Finally, f disappears (eta-reduction) *)</span></span>
<span id="cb161-13"><a href="#cb161-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> func2 = (|-) <span class="dt">List</span>.map -| ((-|) -| <span class="dt">List</span>.filter)</span></code></pre></div>
<p>While point-free style can be elegant for simple cases, it can
quickly become obscure. Use it judiciously!</p>
<h2 id="reductions-and-more-higher-order-functions">6.5 Reductions and
More Higher-Order Functions</h2>
<p>Mathematics has a convenient notation for sums over intervals: <span
class="math inline">\sum_{n=a}^{b} f(n)</span>.</p>
<p>Can we express this in OCaml? The challenge is that OCaml does not
have a universal addition operator – <code>+</code> works only on
integers, <code>+.</code> only on floats. So we end up writing two
versions:</p>
<div class="sourceCode" id="cb162"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> i_sum_fromto f a b =</span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> a &gt; b <span class="kw">then</span> <span class="dv">0</span></span>
<span id="cb162-3"><a href="#cb162-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> f a + i_sum_fromto f (a+<span class="dv">1</span>) b</span>
<span id="cb162-4"><a href="#cb162-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-5"><a href="#cb162-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> f_sum_fromto f a b =</span>
<span id="cb162-6"><a href="#cb162-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> a &gt; b <span class="kw">then</span> <span class="dv">0</span>.</span>
<span id="cb162-7"><a href="#cb162-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> f a +. f_sum_fromto f (a+<span class="dv">1</span>) b</span>
<span id="cb162-8"><a href="#cb162-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-9"><a href="#cb162-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pi2_over6 =</span>
<span id="cb162-10"><a href="#cb162-10" aria-hidden="true" tabindex="-1"></a>  f_sum_fromto (<span class="kw">fun</span> i -&gt; <span class="dv">1</span>. /. <span class="dt">float_of_int</span> (i*i)) <span class="dv">1</span> <span class="dv">5000</span></span></code></pre></div>
<p>(The last example computes an approximation to <span
class="math inline">\pi^2/6</span> using the Basel series.)</p>
<p>The natural generalization is to make the combining operation a
parameter:</p>
<div class="sourceCode" id="cb163"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> op_fromto op base f a b =</span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> a &gt; b <span class="kw">then</span> base</span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> op (f a) (op_fromto op base f (a+<span class="dv">1</span>) b)</span></code></pre></div>
<h3 id="collecting-results-concat_map">Collecting Results:
concat_map</h3>
<p>Sometimes a function produces not a single result but a
<em>collection</em> of results. In mathematics, such a function is
called a <strong>multifunction</strong> or set-valued function. If we
have a multifunction <span class="math inline">f</span> and want to
apply it to every element of a set <span class="math inline">A</span>,
we take the union of all results:</p>
<p><span class="math display">f(A) = \bigcup_{p \in A} f(p)</span></p>
<p>When we represent sets as lists, “union” becomes “append”. This gives
us the extremely useful <code>concat_map</code> operation:</p>
<div class="sourceCode" id="cb164"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> concat_map f = <span class="kw">function</span></span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; []</span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a>  | a::l -&gt; f a @ concat_map f l</span></code></pre></div>
<p>For better efficiency on long lists, here is a tail-recursive
version:</p>
<div class="sourceCode" id="cb165"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> concat_map f l =</span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> cmap_f accu = <span class="kw">function</span></span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; accu</span>
<span id="cb165-4"><a href="#cb165-4" aria-hidden="true" tabindex="-1"></a>    | a::l -&gt; cmap_f (<span class="dt">List</span>.rev_append (f a) accu) l <span class="kw">in</span></span>
<span id="cb165-5"><a href="#cb165-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.rev (cmap_f [] l)</span></code></pre></div>
<p>The <code>concat_map</code> function is fundamental for backtracking
algorithms. We will use it extensively in the puzzle-solving sections
below.</p>
<h3 id="all-subsequences-of-a-list">All Subsequences of a List</h3>
<p>A classic example of a function that produces multiple results: given
a list, generate all its subsequences (subsets that preserve order). The
idea is simple: for each element, we either include it or exclude
it.</p>
<div class="sourceCode" id="cb166"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> subseqs l =</span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb166-3"><a href="#cb166-3" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; [[]]</span>
<span id="cb166-4"><a href="#cb166-4" aria-hidden="true" tabindex="-1"></a>    | x::xs -&gt;</span>
<span id="cb166-5"><a href="#cb166-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> pxs = subseqs xs <span class="kw">in</span></span>
<span id="cb166-6"><a href="#cb166-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">List</span>.map (<span class="kw">fun</span> px -&gt; x::px) pxs @ pxs</span></code></pre></div>
<p>Tail-recursively:</p>
<div class="sourceCode" id="cb167"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> rmap_append f accu = <span class="kw">function</span></span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; accu</span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true" tabindex="-1"></a>  | a::l -&gt; rmap_append f (f a :: accu) l</span>
<span id="cb167-4"><a href="#cb167-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-5"><a href="#cb167-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> subseqs l =</span>
<span id="cb167-6"><a href="#cb167-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb167-7"><a href="#cb167-7" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; [[]]</span>
<span id="cb167-8"><a href="#cb167-8" aria-hidden="true" tabindex="-1"></a>    | x::xs -&gt;</span>
<span id="cb167-9"><a href="#cb167-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> pxs = subseqs xs <span class="kw">in</span></span>
<span id="cb167-10"><a href="#cb167-10" aria-hidden="true" tabindex="-1"></a>      rmap_append (<span class="kw">fun</span> px -&gt; x::px) pxs pxs</span></code></pre></div>
<h3 id="permutations-and-choices">Permutations and Choices</h3>
<p>Generating all permutations of a list is another classic
combinatorial problem. The key insight is the <code>interleave</code>
function: given an element <code>x</code> and a list, it produces all
ways of inserting <code>x</code> into the list:</p>
<div class="sourceCode" id="cb168"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> interleave x = <span class="kw">function</span></span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; [[x]]                 <span class="co">(* x can only go in one place: by itself *)</span></span>
<span id="cb168-3"><a href="#cb168-3" aria-hidden="true" tabindex="-1"></a>  | y::ys -&gt;</span>
<span id="cb168-4"><a href="#cb168-4" aria-hidden="true" tabindex="-1"></a>    (x::y::ys)                  <span class="co">(* x goes at the front, OR *)</span></span>
<span id="cb168-5"><a href="#cb168-5" aria-hidden="true" tabindex="-1"></a>    :: <span class="dt">List</span>.map (<span class="kw">fun</span> zs -&gt; y::zs) (interleave x ys)  <span class="co">(* x goes somewhere after y *)</span></span>
<span id="cb168-6"><a href="#cb168-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-7"><a href="#cb168-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> perms = <span class="kw">function</span></span>
<span id="cb168-8"><a href="#cb168-8" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; [[]]                  <span class="co">(* one way to permute empty list: empty list *)</span></span>
<span id="cb168-9"><a href="#cb168-9" aria-hidden="true" tabindex="-1"></a>  | x::xs -&gt; concat_map (interleave x) (perms xs)</span></code></pre></div>
<p>For example, <code>interleave 1 [2;3]</code> produces
<code>[[1;2;3]; [2;1;3]; [2;3;1]]</code> – all positions where 1 can be
inserted.</p>
<p>For the Countdown problem below, we will need all non-empty
subsequences with all their permutations – that is, all ways of choosing
and ordering elements from a list:</p>
<div class="sourceCode" id="cb169"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> choices l = concat_map perms (<span class="dt">List</span>.filter ((&lt;&gt;) []) (subseqs l))</span></code></pre></div>
<h2 id="grouping-and-map-reduce">6.6 Grouping and Map-Reduce</h2>
<p>When processing large datasets, it is often useful to organize values
by some property – grouping all items with the same key together, then
processing each group. This pattern is so common it has a name:
<strong>map-reduce</strong> (popularized by Google for distributed
computing).</p>
<h3 id="collecting-by-key">Collecting by Key</h3>
<p>The first step is to collect elements from an association list,
grouping all values that share the same key:</p>
<div class="sourceCode" id="cb170"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> collect l =</span>
<span id="cb170-2"><a href="#cb170-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> <span class="dt">List</span>.sort (<span class="kw">fun</span> x y -&gt; <span class="dt">compare</span> (<span class="dt">fst</span> x) (<span class="dt">fst</span> y)) l <span class="kw">with</span></span>
<span id="cb170-3"><a href="#cb170-3" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; []                           <span class="co">(* Start with associations sorted by key *)</span></span>
<span id="cb170-4"><a href="#cb170-4" aria-hidden="true" tabindex="-1"></a>  | (k0, v0)::tl -&gt;</span>
<span id="cb170-5"><a href="#cb170-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> k0, vs, l = <span class="dt">List</span>.fold_left</span>
<span id="cb170-6"><a href="#cb170-6" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">fun</span> (k0, vs, l) (kn, vn) -&gt;     <span class="co">(* Collect values for current key *)</span></span>
<span id="cb170-7"><a href="#cb170-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> k0 = kn <span class="kw">then</span> k0, vn::vs, l  <span class="co">(* Same key: add value to current group *)</span></span>
<span id="cb170-8"><a href="#cb170-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> kn, [vn], (k0, <span class="dt">List</span>.rev vs)::l) <span class="co">(* New: save current group, start new *)</span></span>
<span id="cb170-9"><a href="#cb170-9" aria-hidden="true" tabindex="-1"></a>      (k0, [v0], []) tl <span class="kw">in</span>             <span class="co">(* Why reverse? To preserve original order *)</span></span>
<span id="cb170-10"><a href="#cb170-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">List</span>.rev ((k0, <span class="dt">List</span>.rev vs)::l)</span></code></pre></div>
<p>Now we can group elements by an arbitrary property – we just need to
extract the property as the key:</p>
<div class="sourceCode" id="cb171"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> group_by p l = collect (<span class="dt">List</span>.map (<span class="kw">fun</span> e -&gt; p e, e) l)</span></code></pre></div>
<h3 id="reduction-aggregation">Reduction (Aggregation)</h3>
<p>Grouping alone is often not enough – we want to <em>aggregate</em>
each group into a summary value, like SQL’s <code>SUM</code>,
<code>COUNT</code>, or <code>AVG</code>. This aggregation step is called
<strong>reduction</strong>:</p>
<div class="sourceCode" id="cb172"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> aggregate_by p red base l =</span>
<span id="cb172-2"><a href="#cb172-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ags = group_by p l <span class="kw">in</span></span>
<span id="cb172-3"><a href="#cb172-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.map (<span class="kw">fun</span> (k, vs) -&gt; k, <span class="dt">List</span>.fold_right red vs base) ags</span></code></pre></div>
<p>Using the <strong>feed-forward</strong> (pipe) operator
<code>let ( |&gt; ) x f = f x</code>:</p>
<div class="sourceCode" id="cb173"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> aggregate_by p redf base l =</span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a>  group_by p l</span>
<span id="cb173-3"><a href="#cb173-3" aria-hidden="true" tabindex="-1"></a>  |&gt; <span class="dt">List</span>.map (<span class="kw">fun</span> (k, vs) -&gt; k, <span class="dt">List</span>.fold_right redf vs base)</span></code></pre></div>
<p>Often it is cleaner to extract both the key and the value we care
about upfront, before grouping. Since we first <strong>map</strong>
elements into key-value pairs, then group and <strong>reduce</strong>,
we call this pattern <code>map_reduce</code>:</p>
<div class="sourceCode" id="cb174"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> map_reduce mapf redf base l =</span>
<span id="cb174-2"><a href="#cb174-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.map mapf l</span>
<span id="cb174-3"><a href="#cb174-3" aria-hidden="true" tabindex="-1"></a>  |&gt; collect</span>
<span id="cb174-4"><a href="#cb174-4" aria-hidden="true" tabindex="-1"></a>  |&gt; <span class="dt">List</span>.map (<span class="kw">fun</span> (k, vs) -&gt; k, <span class="dt">List</span>.fold_right redf vs base)</span></code></pre></div>
<h3 id="map-reduce-examples">Map-Reduce Examples</h3>
<p>Sometimes our mapping function produces multiple key-value pairs per
input (for example, when processing documents word by word). For this we
use <code>concat_reduce</code>, which uses <code>concat_map</code>
instead of <code>map</code>:</p>
<div class="sourceCode" id="cb175"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> concat_reduce mapf redf base l =</span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a>  concat_map mapf l</span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a>  |&gt; collect</span>
<span id="cb175-4"><a href="#cb175-4" aria-hidden="true" tabindex="-1"></a>  |&gt; <span class="dt">List</span>.map (<span class="kw">fun</span> (k, vs) -&gt; k, <span class="dt">List</span>.fold_right redf vs base)</span></code></pre></div>
<p><strong>Example 1: Word histogram.</strong> Count how many times each
word appears across a collection of documents:</p>
<div class="sourceCode" id="cb176"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> histogram documents =</span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> mapf doc =</span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a>    Str.split (Str.regexp <span class="st">&quot;[ </span><span class="ch">\t</span><span class="st">.,;]+&quot;</span>) doc</span>
<span id="cb176-4"><a href="#cb176-4" aria-hidden="true" tabindex="-1"></a>    |&gt; <span class="dt">List</span>.map (<span class="kw">fun</span> word -&gt; word, <span class="dv">1</span>) <span class="kw">in</span></span>
<span id="cb176-5"><a href="#cb176-5" aria-hidden="true" tabindex="-1"></a>  concat_reduce mapf (+) <span class="dv">0</span> documents</span></code></pre></div>
<p><strong>Example 2: Inverted index.</strong> Build an index mapping
each word to the list of documents (identified by address) containing
it:</p>
<div class="sourceCode" id="cb177"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cons hd tl = hd::tl</span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> inverted_index documents =</span>
<span id="cb177-4"><a href="#cb177-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> mapf (addr, doc) =</span>
<span id="cb177-5"><a href="#cb177-5" aria-hidden="true" tabindex="-1"></a>    Str.split (Str.regexp <span class="st">&quot;[ </span><span class="ch">\t</span><span class="st">.,;]+&quot;</span>) doc</span>
<span id="cb177-6"><a href="#cb177-6" aria-hidden="true" tabindex="-1"></a>    |&gt; <span class="dt">List</span>.map (<span class="kw">fun</span> word -&gt; word, addr) <span class="kw">in</span></span>
<span id="cb177-7"><a href="#cb177-7" aria-hidden="true" tabindex="-1"></a>  concat_reduce mapf cons [] documents</span></code></pre></div>
<p><strong>Example 3: Simple search engine.</strong> Once we have an
inverted index, we can search for documents containing all of a given
set of words. We need set intersection – here implemented for sets
represented as sorted lists:</p>
<div class="sourceCode" id="cb178"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> intersect xs ys =                       <span class="co">(* Sets as sorted lists *)</span></span>
<span id="cb178-2"><a href="#cb178-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> aux acc = <span class="kw">function</span></span>
<span id="cb178-3"><a href="#cb178-3" aria-hidden="true" tabindex="-1"></a>    | [], _ | _, [] -&gt; acc</span>
<span id="cb178-4"><a href="#cb178-4" aria-hidden="true" tabindex="-1"></a>    | (x::xs&#39; <span class="kw">as</span> xs), (y::ys&#39; <span class="kw">as</span> ys) -&gt;</span>
<span id="cb178-5"><a href="#cb178-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> c = <span class="dt">compare</span> x y <span class="kw">in</span></span>
<span id="cb178-6"><a href="#cb178-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> c = <span class="dv">0</span> <span class="kw">then</span> aux (x::acc) (xs&#39;, ys&#39;)</span>
<span id="cb178-7"><a href="#cb178-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> <span class="kw">if</span> c &lt; <span class="dv">0</span> <span class="kw">then</span> aux acc (xs&#39;, ys)</span>
<span id="cb178-8"><a href="#cb178-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> aux acc (xs, ys&#39;) <span class="kw">in</span></span>
<span id="cb178-9"><a href="#cb178-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.rev (aux [] (xs, ys))</span></code></pre></div>
<p>Now we can build a simple search function that finds all documents
containing every word in a query:</p>
<div class="sourceCode" id="cb179"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> search index words =</span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> <span class="dt">List</span>.map (flip <span class="dt">List</span>.assoc index) words <span class="kw">with</span></span>
<span id="cb179-3"><a href="#cb179-3" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; []</span>
<span id="cb179-4"><a href="#cb179-4" aria-hidden="true" tabindex="-1"></a>  | idx::idcs -&gt; <span class="dt">List</span>.fold_left intersect idx idcs</span></code></pre></div>
<h2 id="higher-order-functions-for-the-option-type">6.7 Higher-Order
Functions for the Option Type</h2>
<p>The <code>option</code> type is OCaml’s way of representing values
that might be absent. Rather than using null pointers (a common source
of bugs), we explicitly mark possibly-missing values with
<code>Some x</code> or <code>None</code>. Here are some useful
higher-order functions for working with options.</p>
<p>First, applying a function to an optional value:</p>
<div class="sourceCode" id="cb180"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> map_option f = <span class="kw">function</span></span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true" tabindex="-1"></a>  | <span class="dt">None</span> -&gt; <span class="dt">None</span></span>
<span id="cb180-3"><a href="#cb180-3" aria-hidden="true" tabindex="-1"></a>  | <span class="dt">Some</span> e -&gt; f e</span></code></pre></div>
<p>Second, mapping a partial function over a list and keeping only the
successful results:</p>
<div class="sourceCode" id="cb181"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> map_some f = <span class="kw">function</span></span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; []</span>
<span id="cb181-3"><a href="#cb181-3" aria-hidden="true" tabindex="-1"></a>  | e::l -&gt; <span class="kw">match</span> f e <span class="kw">with</span></span>
<span id="cb181-4"><a href="#cb181-4" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">None</span> -&gt; map_some f l</span>
<span id="cb181-5"><a href="#cb181-5" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> r -&gt; r :: map_some f l</span></code></pre></div>
<p>Tail-recursively:</p>
<div class="sourceCode" id="cb182"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> map_some f l =</span>
<span id="cb182-2"><a href="#cb182-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> maps_f accu = <span class="kw">function</span></span>
<span id="cb182-3"><a href="#cb182-3" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; accu</span>
<span id="cb182-4"><a href="#cb182-4" aria-hidden="true" tabindex="-1"></a>    | a::l -&gt; maps_f (<span class="kw">match</span> f a <span class="kw">with</span> <span class="dt">None</span> -&gt; accu</span>
<span id="cb182-5"><a href="#cb182-5" aria-hidden="true" tabindex="-1"></a>      | <span class="dt">Some</span> r -&gt; r::accu) l <span class="kw">in</span></span>
<span id="cb182-6"><a href="#cb182-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.rev (maps_f [] l)</span></code></pre></div>
<h2 id="the-countdown-problem-puzzle">6.8 The Countdown Problem
Puzzle</h2>
<p>Now we turn to solving puzzles, which will showcase the power of
backtracking with lists. The <strong>Countdown Problem</strong> is a
classic puzzle from a British TV game show:</p>
<ul>
<li>Using a given set of numbers and arithmetic operators +, -, *, /,
construct an expression with a given value.</li>
<li>All numbers, including intermediate results, must be positive
integers.</li>
<li>Each source number can be used at most once.</li>
</ul>
<p><strong>Example:</strong> - Source numbers: 1, 3, 7, 10, 25, 50 -
Target: 765 - One possible solution: (25-10) * (50+1) = 15 * 51 =
765</p>
<p>This example has 780 different solutions! Changing the target to 831
gives an example with no solutions at all.</p>
<p>Let us develop a solver step by step, starting with the data
types.</p>
<h3 id="data-types">Data Types</h3>
<div class="sourceCode" id="cb183"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> op = Add | Sub | Mul | Div</span>
<span id="cb183-2"><a href="#cb183-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-3"><a href="#cb183-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> apply op x y =</span>
<span id="cb183-4"><a href="#cb183-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> op <span class="kw">with</span></span>
<span id="cb183-5"><a href="#cb183-5" aria-hidden="true" tabindex="-1"></a>  | Add -&gt; x + y</span>
<span id="cb183-6"><a href="#cb183-6" aria-hidden="true" tabindex="-1"></a>  | Sub -&gt; x - y</span>
<span id="cb183-7"><a href="#cb183-7" aria-hidden="true" tabindex="-1"></a>  | Mul -&gt; x * y</span>
<span id="cb183-8"><a href="#cb183-8" aria-hidden="true" tabindex="-1"></a>  | Div -&gt; x / y</span>
<span id="cb183-9"><a href="#cb183-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-10"><a href="#cb183-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> valid op x y =</span>
<span id="cb183-11"><a href="#cb183-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> op <span class="kw">with</span></span>
<span id="cb183-12"><a href="#cb183-12" aria-hidden="true" tabindex="-1"></a>  | Add -&gt; <span class="kw">true</span></span>
<span id="cb183-13"><a href="#cb183-13" aria-hidden="true" tabindex="-1"></a>  | Sub -&gt; x &gt; y</span>
<span id="cb183-14"><a href="#cb183-14" aria-hidden="true" tabindex="-1"></a>  | Mul -&gt; <span class="kw">true</span></span>
<span id="cb183-15"><a href="#cb183-15" aria-hidden="true" tabindex="-1"></a>  | Div -&gt; x <span class="kw">mod</span> y = <span class="dv">0</span></span>
<span id="cb183-16"><a href="#cb183-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-17"><a href="#cb183-17" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> expr = Val <span class="kw">of</span> <span class="dt">int</span> | App <span class="kw">of</span> op * expr * expr</span>
<span id="cb183-18"><a href="#cb183-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-19"><a href="#cb183-19" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> eval = <span class="kw">function</span></span>
<span id="cb183-20"><a href="#cb183-20" aria-hidden="true" tabindex="-1"></a>  | Val n -&gt; <span class="kw">if</span> n &gt; <span class="dv">0</span> <span class="kw">then</span> <span class="dt">Some</span> n <span class="kw">else</span> <span class="dt">None</span></span>
<span id="cb183-21"><a href="#cb183-21" aria-hidden="true" tabindex="-1"></a>  | App (o, l, r) -&gt;</span>
<span id="cb183-22"><a href="#cb183-22" aria-hidden="true" tabindex="-1"></a>    eval l |&gt; map_option (<span class="kw">fun</span> x -&gt;</span>
<span id="cb183-23"><a href="#cb183-23" aria-hidden="true" tabindex="-1"></a>      eval r |&gt; map_option (<span class="kw">fun</span> y -&gt;</span>
<span id="cb183-24"><a href="#cb183-24" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> valid o x y <span class="kw">then</span> <span class="dt">Some</span> (apply o x y)</span>
<span id="cb183-25"><a href="#cb183-25" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> <span class="dt">None</span>))</span>
<span id="cb183-26"><a href="#cb183-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-27"><a href="#cb183-27" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> values = <span class="kw">function</span></span>
<span id="cb183-28"><a href="#cb183-28" aria-hidden="true" tabindex="-1"></a>  | Val n -&gt; [n]</span>
<span id="cb183-29"><a href="#cb183-29" aria-hidden="true" tabindex="-1"></a>  | App (_, l, r) -&gt; values l @ values r</span>
<span id="cb183-30"><a href="#cb183-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-31"><a href="#cb183-31" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> solution e ns n =</span>
<span id="cb183-32"><a href="#cb183-32" aria-hidden="true" tabindex="-1"></a>  list_diff (values e) ns = [] &amp;&amp; is_unique (values e) &amp;&amp;</span>
<span id="cb183-33"><a href="#cb183-33" aria-hidden="true" tabindex="-1"></a>  eval e = <span class="dt">Some</span> n</span></code></pre></div>
<h3 id="brute-force-solution">Brute Force Solution</h3>
<p>Our strategy is to generate all possible expressions from the source
numbers, then filter for those that evaluate to the target. To build
expressions, we need to split the numbers into two groups (for the left
and right operands of an operator).</p>
<p>First, a helper to split a list into two non-empty parts in all
possible ways:</p>
<div class="sourceCode" id="cb184"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> split l =</span>
<span id="cb184-2"><a href="#cb184-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> aux lhs acc = <span class="kw">function</span></span>
<span id="cb184-3"><a href="#cb184-3" aria-hidden="true" tabindex="-1"></a>    | [] | [_] -&gt; []</span>
<span id="cb184-4"><a href="#cb184-4" aria-hidden="true" tabindex="-1"></a>    | [y; z] -&gt; (<span class="dt">List</span>.rev (y::lhs), [z])::acc</span>
<span id="cb184-5"><a href="#cb184-5" aria-hidden="true" tabindex="-1"></a>    | hd::rhs -&gt;</span>
<span id="cb184-6"><a href="#cb184-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> lhs = hd::lhs <span class="kw">in</span></span>
<span id="cb184-7"><a href="#cb184-7" aria-hidden="true" tabindex="-1"></a>      aux lhs ((<span class="dt">List</span>.rev lhs, rhs)::acc) rhs <span class="kw">in</span></span>
<span id="cb184-8"><a href="#cb184-8" aria-hidden="true" tabindex="-1"></a>  aux [] [] l</span></code></pre></div>
<p>We introduce a convenient operator for working with multiple data
sources. The “bind” operator <code>|-&gt;</code> takes a list of values
and a function that produces a list from each value, then concatenates
all results:</p>
<div class="sourceCode" id="cb185"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ( |-&gt; ) x f = concat_map f x</span></code></pre></div>
<p>Now we can generate all expressions from a list of numbers. The
structure elegantly expresses the backtracking search:</p>
<div class="sourceCode" id="cb186"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> combine l r =                  <span class="co">(* Combine two expressions using each operator *)</span></span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.map (<span class="kw">fun</span> o -&gt; App (o, l, r)) [Add; Sub; Mul; Div]</span>
<span id="cb186-3"><a href="#cb186-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-4"><a href="#cb186-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> exprs = <span class="kw">function</span></span>
<span id="cb186-5"><a href="#cb186-5" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; []                       <span class="co">(* No expressions from empty list *)</span></span>
<span id="cb186-6"><a href="#cb186-6" aria-hidden="true" tabindex="-1"></a>  | [n] -&gt; [Val n]                 <span class="co">(* Single number: just Val n *)</span></span>
<span id="cb186-7"><a href="#cb186-7" aria-hidden="true" tabindex="-1"></a>  | ns -&gt;</span>
<span id="cb186-8"><a href="#cb186-8" aria-hidden="true" tabindex="-1"></a>    split ns |-&gt; (<span class="kw">fun</span> (ls, rs) -&gt;  <span class="co">(* For each way to split numbers... *)</span></span>
<span id="cb186-9"><a href="#cb186-9" aria-hidden="true" tabindex="-1"></a>      exprs ls |-&gt; (<span class="kw">fun</span> l -&gt;       <span class="co">(* ...for each expression l from left half... *)</span></span>
<span id="cb186-10"><a href="#cb186-10" aria-hidden="true" tabindex="-1"></a>        exprs rs |-&gt; (<span class="kw">fun</span> r -&gt;     <span class="co">(* ...for each expression r from right half... *)</span></span>
<span id="cb186-11"><a href="#cb186-11" aria-hidden="true" tabindex="-1"></a>          combine l r)))           <span class="co">(* ...produce all l op r combinations *)</span></span></code></pre></div>
<p>Read the nested <code>|-&gt;</code> as “for each … for each … for
each …”. This is the essence of backtracking: we explore all
combinations systematically.</p>
<p>Finally, to find solutions, we try all choices of source numbers (all
non-empty subsets with all orderings) and filter for expressions that
evaluate to the target:</p>
<div class="sourceCode" id="cb187"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> guard n =</span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.filter (<span class="kw">fun</span> e -&gt; eval e = <span class="dt">Some</span> n)</span>
<span id="cb187-3"><a href="#cb187-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-4"><a href="#cb187-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> solutions ns n =</span>
<span id="cb187-5"><a href="#cb187-5" aria-hidden="true" tabindex="-1"></a>  choices ns |-&gt; (<span class="kw">fun</span> ns&#39; -&gt;</span>
<span id="cb187-6"><a href="#cb187-6" aria-hidden="true" tabindex="-1"></a>    exprs ns&#39; |&gt; guard n)</span></code></pre></div>
<h3 id="optimization-fuse-generation-with-testing">Optimization: Fuse
Generation with Testing</h3>
<p>The brute force approach generates many invalid expressions (like
<code>5 - 7</code> which gives a negative result, or <code>5 / 3</code>
which is not an integer). We can do better by <em>fusing</em> generation
with evaluation: instead of generating an expression and then checking
if it is valid, we track the value alongside the expression and only
generate valid subexpressions.</p>
<p>The key insight is to work with pairs <code>(e, eval e)</code> so
that only valid subexpressions are ever generated:</p>
<div class="sourceCode" id="cb188"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> combine&#39; (l, x) (r, y) =</span>
<span id="cb188-2"><a href="#cb188-2" aria-hidden="true" tabindex="-1"></a>  [Add; Sub; Mul; Div]</span>
<span id="cb188-3"><a href="#cb188-3" aria-hidden="true" tabindex="-1"></a>  |&gt; <span class="dt">List</span>.filter (<span class="kw">fun</span> o -&gt; valid o x y)</span>
<span id="cb188-4"><a href="#cb188-4" aria-hidden="true" tabindex="-1"></a>  |&gt; <span class="dt">List</span>.map (<span class="kw">fun</span> o -&gt; App (o, l, r), apply o x y)</span>
<span id="cb188-5"><a href="#cb188-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb188-6"><a href="#cb188-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> results = <span class="kw">function</span></span>
<span id="cb188-7"><a href="#cb188-7" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; []</span>
<span id="cb188-8"><a href="#cb188-8" aria-hidden="true" tabindex="-1"></a>  | [n] -&gt; <span class="kw">if</span> n &gt; <span class="dv">0</span> <span class="kw">then</span> [Val n, n] <span class="kw">else</span> []</span>
<span id="cb188-9"><a href="#cb188-9" aria-hidden="true" tabindex="-1"></a>  | ns -&gt;</span>
<span id="cb188-10"><a href="#cb188-10" aria-hidden="true" tabindex="-1"></a>    split ns |-&gt; (<span class="kw">fun</span> (ls, rs) -&gt;</span>
<span id="cb188-11"><a href="#cb188-11" aria-hidden="true" tabindex="-1"></a>      results ls |-&gt; (<span class="kw">fun</span> lx -&gt;</span>
<span id="cb188-12"><a href="#cb188-12" aria-hidden="true" tabindex="-1"></a>        results rs |-&gt; (<span class="kw">fun</span> ry -&gt;</span>
<span id="cb188-13"><a href="#cb188-13" aria-hidden="true" tabindex="-1"></a>          combine&#39; lx ry)))</span>
<span id="cb188-14"><a href="#cb188-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb188-15"><a href="#cb188-15" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> solutions&#39; ns n =</span>
<span id="cb188-16"><a href="#cb188-16" aria-hidden="true" tabindex="-1"></a>  choices ns |-&gt; (<span class="kw">fun</span> ns&#39; -&gt;</span>
<span id="cb188-17"><a href="#cb188-17" aria-hidden="true" tabindex="-1"></a>    results ns&#39;</span>
<span id="cb188-18"><a href="#cb188-18" aria-hidden="true" tabindex="-1"></a>    |&gt; <span class="dt">List</span>.filter (<span class="kw">fun</span> (e, m) -&gt; m = n)</span>
<span id="cb188-19"><a href="#cb188-19" aria-hidden="true" tabindex="-1"></a>    |&gt; <span class="dt">List</span>.map <span class="dt">fst</span>)                        <span class="co">(* Discard memorized values *)</span></span></code></pre></div>
<h3 id="eliminating-symmetric-cases">Eliminating Symmetric Cases</h3>
<p>We can further improve performance by observing that addition and
multiplication are commutative: <code>3 + 5</code> and
<code>5 + 3</code> give the same result. Similarly, multiplying by 1 or
adding/subtracting 0 are useless. We can eliminate these redundancies by
strengthening the validity predicate:</p>
<div class="sourceCode" id="cb189"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> valid op x y =</span>
<span id="cb189-2"><a href="#cb189-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> op <span class="kw">with</span></span>
<span id="cb189-3"><a href="#cb189-3" aria-hidden="true" tabindex="-1"></a>  | Add -&gt; x &lt;= y</span>
<span id="cb189-4"><a href="#cb189-4" aria-hidden="true" tabindex="-1"></a>  | Sub -&gt; x &gt; y</span>
<span id="cb189-5"><a href="#cb189-5" aria-hidden="true" tabindex="-1"></a>  | Mul -&gt; x &lt;= y &amp;&amp; x &lt;&gt; <span class="dv">1</span> &amp;&amp; y &lt;&gt; <span class="dv">1</span></span>
<span id="cb189-6"><a href="#cb189-6" aria-hidden="true" tabindex="-1"></a>  | Div -&gt; x <span class="kw">mod</span> y = <span class="dv">0</span> &amp;&amp; y &lt;&gt; <span class="dv">1</span></span></code></pre></div>
<p>This eliminates symmetrical solutions on the <em>semantic</em> level
(based on values) rather than the <em>syntactic</em> level (based on
expression structure). This approach is both easier to implement and
more effective at pruning the search space.</p>
<h2 id="the-honey-islands-puzzle">6.9 The Honey Islands Puzzle</h2>
<p>Now let us tackle a different kind of puzzle that requires more
sophisticated backtracking.</p>
<p><strong>Be a bee!</strong> Imagine a honeycomb where you need to eat
honey from certain cells to prevent the remaining honey from going sour.
Sourness spreads through contact, so you want to divide the honey into
isolated “islands” – each small enough that it will be consumed before
spoiling.</p>
<p>More precisely: given a honeycomb with some cells initially marked
black (empty), mark additional cells as empty so that the remaining
(unmarked) cells form exactly <code>num_islands</code> disconnected
components, each with exactly <code>island_size</code> cells.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Task: 3 islands × 3 cells</th>
<th style="text-align: center;">Solution</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><img src="honey0.png"
style="width:45.0%" alt="Task" /></td>
<td style="text-align: center;"><img src="honey1.png"
style="width:45.0%" alt="Solution" /></td>
</tr>
</tbody>
</table>
<p>In the solution, yellow cells contain honey, black cells were
initially empty, and purple cells are the newly “eaten” cells that
separate the honey into 3 islands of 3 cells each.</p>
<h3 id="representing-the-honeycomb">Representing the Honeycomb</h3>
<p>We represent cells using Cartesian coordinates. The honeycomb
structure means that valid cells satisfy certain parity and boundary
constraints.</p>
<div class="sourceCode" id="cb190"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> cell = <span class="dt">int</span> * <span class="dt">int</span>          <span class="co">(* Cartesian coordinates *)</span></span>
<span id="cb190-2"><a href="#cb190-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-3"><a href="#cb190-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> CellSet =               <span class="co">(* Store cells in sets for efficient membership tests *)</span></span>
<span id="cb190-4"><a href="#cb190-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Set</span>.Make (<span class="kw">struct</span> <span class="kw">type</span> t = cell <span class="kw">let</span> <span class="dt">compare</span> = <span class="dt">compare</span> <span class="kw">end</span>)</span>
<span id="cb190-5"><a href="#cb190-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-6"><a href="#cb190-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> task = {                  <span class="co">(* For board size N, coordinates *)</span></span>
<span id="cb190-7"><a href="#cb190-7" aria-hidden="true" tabindex="-1"></a>  board_size : <span class="dt">int</span>;            <span class="co">(* range from (-2N, -N) to (2N, N) *)</span></span>
<span id="cb190-8"><a href="#cb190-8" aria-hidden="true" tabindex="-1"></a>  num_islands : <span class="dt">int</span>;           <span class="co">(* Required number of islands *)</span></span>
<span id="cb190-9"><a href="#cb190-9" aria-hidden="true" tabindex="-1"></a>  island_size : <span class="dt">int</span>;           <span class="co">(* Required cells per island *)</span></span>
<span id="cb190-10"><a href="#cb190-10" aria-hidden="true" tabindex="-1"></a>  empty_cells : CellSet.t;     <span class="co">(* Initially empty cells *)</span></span>
<span id="cb190-11"><a href="#cb190-11" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb190-12"><a href="#cb190-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-13"><a href="#cb190-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cellset_of_list l =           <span class="co">(* Convert list to set (inverse of CellSet.elements) *)</span></span>
<span id="cb190-14"><a href="#cb190-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.fold_right CellSet.add l CellSet.empty</span></code></pre></div>
<p><strong>Neighborhood:</strong> In a honeycomb, each cell has up to 6
neighbors. We filter out neighbors that are outside the board or already
eaten:</p>
<div class="sourceCode" id="cb191"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> even x = x <span class="kw">mod</span> <span class="dv">2</span> = <span class="dv">0</span></span>
<span id="cb191-2"><a href="#cb191-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-3"><a href="#cb191-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> inside_board n eaten (x, y) =</span>
<span id="cb191-4"><a href="#cb191-4" aria-hidden="true" tabindex="-1"></a>  even x = even y &amp;&amp; <span class="dt">abs</span> y &lt;= n &amp;&amp;</span>
<span id="cb191-5"><a href="#cb191-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">abs</span> x + <span class="dt">abs</span> y &lt;= <span class="dv">2</span>*n &amp;&amp;</span>
<span id="cb191-6"><a href="#cb191-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">not</span> (CellSet.mem (x, y) eaten)</span>
<span id="cb191-7"><a href="#cb191-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-8"><a href="#cb191-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> neighbors n eaten (x, y) =</span>
<span id="cb191-9"><a href="#cb191-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.filter</span>
<span id="cb191-10"><a href="#cb191-10" aria-hidden="true" tabindex="-1"></a>    (inside_board n eaten)</span>
<span id="cb191-11"><a href="#cb191-11" aria-hidden="true" tabindex="-1"></a>    [x<span class="dv">-1</span>,y<span class="dv">-1</span>; x+<span class="dv">1</span>,y<span class="dv">-1</span>; x+<span class="dv">2</span>,y;</span>
<span id="cb191-12"><a href="#cb191-12" aria-hidden="true" tabindex="-1"></a>     x+<span class="dv">1</span>,y+<span class="dv">1</span>; x<span class="dv">-1</span>,y+<span class="dv">1</span>; x<span class="dv">-2</span>,y]</span></code></pre></div>
<p><strong>Building the honeycomb:</strong> We generate all valid honey
cells by iterating over the coordinate range and filtering:</p>
<div class="sourceCode" id="cb192"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> honey_cells n eaten =</span>
<span id="cb192-2"><a href="#cb192-2" aria-hidden="true" tabindex="-1"></a>  fromto (<span class="dv">-2</span>*n) (<span class="dv">2</span>*n) |-&gt; (<span class="kw">fun</span> x -&gt;</span>
<span id="cb192-3"><a href="#cb192-3" aria-hidden="true" tabindex="-1"></a>    fromto (-n) n |-&gt; (<span class="kw">fun</span> y -&gt;</span>
<span id="cb192-4"><a href="#cb192-4" aria-hidden="true" tabindex="-1"></a>     pred_guard (inside_board n eaten)</span>
<span id="cb192-5"><a href="#cb192-5" aria-hidden="true" tabindex="-1"></a>        (x, y)))</span></code></pre></div>
<h3 id="drawing-honeycombs">Drawing Honeycombs</h3>
<p>To visualize the honeycomb, we generate colored polygons. Each cell
is drawn as a hexagon by placing 6 points evenly spaced on a
circumcircle:</p>
<div class="sourceCode" id="cb193"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> draw_honeycomb ~w ~h task eaten =</span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> i2f = <span class="dt">float_of_int</span> <span class="kw">in</span></span>
<span id="cb193-3"><a href="#cb193-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> nx = i2f (<span class="dv">4</span> * task.board_size + <span class="dv">2</span>) <span class="kw">in</span></span>
<span id="cb193-4"><a href="#cb193-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ny = i2f (<span class="dv">2</span> * task.board_size + <span class="dv">2</span>) <span class="kw">in</span></span>
<span id="cb193-5"><a href="#cb193-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> radius = <span class="dt">min</span> (i2f w /. nx) (i2f h /. ny) <span class="kw">in</span></span>
<span id="cb193-6"><a href="#cb193-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> x0 = w / <span class="dv">2</span> <span class="kw">in</span></span>
<span id="cb193-7"><a href="#cb193-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> y0 = h / <span class="dv">2</span> <span class="kw">in</span></span>
<span id="cb193-8"><a href="#cb193-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> dx = (<span class="dt">sqrt</span> <span class="dv">3</span>. /. <span class="dv">2</span>.) *. radius +. <span class="dv">1</span>. <span class="kw">in</span>  <span class="co">(* Distance between *)</span></span>
<span id="cb193-9"><a href="#cb193-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> dy = (<span class="dv">3</span>. /. <span class="dv">2</span>.) *. radius +. <span class="dv">2</span>. <span class="kw">in</span>       <span class="co">(* (x,y) and (x+1,y+1) *)</span></span>
<span id="cb193-10"><a href="#cb193-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> draw_cell (x, y) =</span>
<span id="cb193-11"><a href="#cb193-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Array</span>.init <span class="dv">7</span>                               <span class="co">(* Draw a closed polygon *)</span></span>
<span id="cb193-12"><a href="#cb193-12" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">fun</span> i -&gt;                            <span class="co">(* with 6 points evenly spaced *)</span></span>
<span id="cb193-13"><a href="#cb193-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> phi = <span class="dt">float_of_int</span> i *. Float.pi /. <span class="dv">3</span>. <span class="kw">in</span>   <span class="co">(* on circumcircle *)</span></span>
<span id="cb193-14"><a href="#cb193-14" aria-hidden="true" tabindex="-1"></a>        x0 + <span class="dt">int_of_float</span> (radius *. <span class="dt">sin</span> phi +. <span class="dt">float_of_int</span> x *. dx),</span>
<span id="cb193-15"><a href="#cb193-15" aria-hidden="true" tabindex="-1"></a>        y0 + <span class="dt">int_of_float</span> (radius *. <span class="dt">cos</span> phi +. <span class="dt">float_of_int</span> y *. dy)) <span class="kw">in</span></span>
<span id="cb193-16"><a href="#cb193-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> honey =</span>
<span id="cb193-17"><a href="#cb193-17" aria-hidden="true" tabindex="-1"></a>    honey_cells task.board_size (CellSet.union task.empty_cells</span>
<span id="cb193-18"><a href="#cb193-18" aria-hidden="true" tabindex="-1"></a>                                   (cellset_of_list eaten))</span>
<span id="cb193-19"><a href="#cb193-19" aria-hidden="true" tabindex="-1"></a>    |&gt; <span class="dt">List</span>.map (<span class="kw">fun</span> p -&gt; draw_cell p, (<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">0</span>)) <span class="kw">in</span>   <span class="co">(* Yellow cells *)</span></span>
<span id="cb193-20"><a href="#cb193-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> eaten = <span class="dt">List</span>.map</span>
<span id="cb193-21"><a href="#cb193-21" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">fun</span> p -&gt; draw_cell p, (<span class="dv">50</span>, <span class="dv">0</span>, <span class="dv">50</span>)) eaten <span class="kw">in</span>           <span class="co">(* Purple: eaten *)</span></span>
<span id="cb193-22"><a href="#cb193-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> old_empty = <span class="dt">List</span>.map</span>
<span id="cb193-23"><a href="#cb193-23" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">fun</span> p -&gt; draw_cell p, (<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>))                      <span class="co">(* Black: empty *)</span></span>
<span id="cb193-24"><a href="#cb193-24" aria-hidden="true" tabindex="-1"></a>    (CellSet.elements task.empty_cells) <span class="kw">in</span></span>
<span id="cb193-25"><a href="#cb193-25" aria-hidden="true" tabindex="-1"></a>  honey @ eaten @ old_empty</span></code></pre></div>
<p><strong>Drawing to SVG:</strong> We can render the polygons to an SVG
image file:</p>
<div class="sourceCode" id="cb194"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> draw_to_svg file ~w ~h ?title ?desc curves =</span>
<span id="cb194-2"><a href="#cb194-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> f = <span class="dt">open_out</span> file <span class="kw">in</span></span>
<span id="cb194-3"><a href="#cb194-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Printf</span>.fprintf f <span class="st">&quot;&lt;?xml version=</span><span class="ch">\&quot;</span><span class="st">1.0</span><span class="ch">\&quot;</span><span class="st"> standalone=</span><span class="ch">\&quot;</span><span class="st">no</span><span class="ch">\&quot;</span><span class="st">?&gt;</span></span>
<span id="cb194-4"><a href="#cb194-4" aria-hidden="true" tabindex="-1"></a><span class="st">&lt;!DOCTYPE svg PUBLIC </span><span class="ch">\&quot;</span><span class="st">-//W3C//DTD SVG 1.1//EN</span><span class="ch">\&quot;</span></span>
<span id="cb194-5"><a href="#cb194-5" aria-hidden="true" tabindex="-1"></a><span class="st">  </span><span class="ch">\&quot;</span><span class="st">http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd</span><span class="ch">\&quot;</span><span class="st">&gt;</span></span>
<span id="cb194-6"><a href="#cb194-6" aria-hidden="true" tabindex="-1"></a><span class="st">&lt;svg width=</span><span class="ch">\&quot;</span><span class="st">%d</span><span class="ch">\&quot;</span><span class="st"> height=</span><span class="ch">\&quot;</span><span class="st">%d</span><span class="ch">\&quot;</span><span class="st"> viewBox=</span><span class="ch">\&quot;</span><span class="st">0 0 %d %d</span><span class="ch">\&quot;</span></span>
<span id="cb194-7"><a href="#cb194-7" aria-hidden="true" tabindex="-1"></a><span class="st">    xmlns=</span><span class="ch">\&quot;</span><span class="st">http://www.w3.org/2000/svg</span><span class="ch">\&quot;</span><span class="st"> version=</span><span class="ch">\&quot;</span><span class="st">1.1</span><span class="ch">\&quot;</span><span class="st">&gt;</span></span>
<span id="cb194-8"><a href="#cb194-8" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;</span> w h w h;</span>
<span id="cb194-9"><a href="#cb194-9" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">match</span> title <span class="kw">with</span> <span class="dt">None</span> -&gt; ()</span>
<span id="cb194-10"><a href="#cb194-10" aria-hidden="true" tabindex="-1"></a>  | <span class="dt">Some</span> title -&gt; <span class="dt">Printf</span>.fprintf f <span class="st">&quot;  &lt;title&gt;%s&lt;/title&gt;</span><span class="ch">\n</span><span class="st">&quot;</span> title);</span>
<span id="cb194-11"><a href="#cb194-11" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">match</span> desc <span class="kw">with</span> <span class="dt">None</span> -&gt; ()</span>
<span id="cb194-12"><a href="#cb194-12" aria-hidden="true" tabindex="-1"></a>  | <span class="dt">Some</span> desc -&gt; <span class="dt">Printf</span>.fprintf f <span class="st">&quot;  &lt;desc&gt;%s&lt;/desc&gt;</span><span class="ch">\n</span><span class="st">&quot;</span> desc);</span>
<span id="cb194-13"><a href="#cb194-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> draw_shape (points, (r, g, b)) =</span>
<span id="cb194-14"><a href="#cb194-14" aria-hidden="true" tabindex="-1"></a>    uncurry (<span class="dt">Printf</span>.fprintf f <span class="st">&quot;  &lt;path d=</span><span class="ch">\&quot;</span><span class="st">M %d %d&quot;</span>) points.(<span class="dv">0</span>);</span>
<span id="cb194-15"><a href="#cb194-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Array</span>.iteri (<span class="kw">fun</span> i (x, y) -&gt;</span>
<span id="cb194-16"><a href="#cb194-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> i &gt; <span class="dv">0</span> <span class="kw">then</span> <span class="dt">Printf</span>.fprintf f <span class="st">&quot; L %d %d&quot;</span> x y) points;</span>
<span id="cb194-17"><a href="#cb194-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Printf</span>.fprintf f <span class="st">&quot;</span><span class="ch">\&quot;\n</span><span class="st">       fill=</span><span class="ch">\&quot;</span><span class="st">rgb(%d, %d, %d)</span><span class="ch">\&quot;</span><span class="st"> stroke-width=</span><span class="ch">\&quot;</span><span class="st">3</span><span class="ch">\&quot;</span><span class="st"> /&gt;</span><span class="ch">\n</span><span class="st">&quot;</span></span>
<span id="cb194-18"><a href="#cb194-18" aria-hidden="true" tabindex="-1"></a>      r g b <span class="kw">in</span></span>
<span id="cb194-19"><a href="#cb194-19" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.iter draw_shape curves;</span>
<span id="cb194-20"><a href="#cb194-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Printf</span>.fprintf f <span class="st">&quot;&lt;/svg&gt;%!&quot;</span></span></code></pre></div>
<p><strong>Drawing to screen:</strong> We can also draw interactively
using the <em>Bogue</em> library. Note that Bogue does not directly
support filled polygons, so we draw hexagons as line segments.</p>
<div class="sourceCode" id="cb195"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> draw_to_screen ~w ~h curves =</span>
<span id="cb195-2"><a href="#cb195-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">open</span> Bogue <span class="kw">in</span></span>
<span id="cb195-3"><a href="#cb195-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> area_widget = Widget.sdl_area ~w ~h () <span class="kw">in</span></span>
<span id="cb195-4"><a href="#cb195-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> area = Widget.get_sdl_area area_widget <span class="kw">in</span></span>
<span id="cb195-5"><a href="#cb195-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* Queue drawing commands for when the area is rendered *)</span></span>
<span id="cb195-6"><a href="#cb195-6" aria-hidden="true" tabindex="-1"></a>  Sdl_area.add area (<span class="kw">fun</span> _renderer -&gt;</span>
<span id="cb195-7"><a href="#cb195-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* Draw brown background *)</span></span>
<span id="cb195-8"><a href="#cb195-8" aria-hidden="true" tabindex="-1"></a>    Sdl_area.fill_rectangle area ~color:(Draw.opaque (Draw.find_color <span class="st">&quot;saddlebrown&quot;</span>))</span>
<span id="cb195-9"><a href="#cb195-9" aria-hidden="true" tabindex="-1"></a>      ~w ~h (<span class="dv">0</span>, <span class="dv">0</span>);</span>
<span id="cb195-10"><a href="#cb195-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* Draw each hexagon as connected line segments *)</span></span>
<span id="cb195-11"><a href="#cb195-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">List</span>.iter (<span class="kw">fun</span> (points, (r, g, b)) -&gt;</span>
<span id="cb195-12"><a href="#cb195-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> color = Draw.opaque (r, g, b) <span class="kw">in</span></span>
<span id="cb195-13"><a href="#cb195-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> n = <span class="dt">Array</span>.length points <span class="kw">in</span></span>
<span id="cb195-14"><a href="#cb195-14" aria-hidden="true" tabindex="-1"></a>      <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> n - <span class="dv">2</span> <span class="kw">do</span></span>
<span id="cb195-15"><a href="#cb195-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (x0, y0) = points.(i) <span class="kw">in</span></span>
<span id="cb195-16"><a href="#cb195-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (x1, y1) = points.(i + <span class="dv">1</span>) <span class="kw">in</span></span>
<span id="cb195-17"><a href="#cb195-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">(* Flip y-coordinate: Bogue uses top-left origin *)</span></span>
<span id="cb195-18"><a href="#cb195-18" aria-hidden="true" tabindex="-1"></a>        Sdl_area.draw_line area ~color ~thick:<span class="dv">3</span> (x0, h - y0) (x1, h - y1)</span>
<span id="cb195-19"><a href="#cb195-19" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span>) curves);</span>
<span id="cb195-20"><a href="#cb195-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> layout = Layout.resident area_widget <span class="kw">in</span></span>
<span id="cb195-21"><a href="#cb195-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> board = Main.of_layout layout <span class="kw">in</span></span>
<span id="cb195-22"><a href="#cb195-22" aria-hidden="true" tabindex="-1"></a>  Main.run board</span></code></pre></div>
<h3 id="testing-correctness">Testing Correctness</h3>
<p>Before generating solutions, let us write code to <em>test</em>
whether a proposed solution is correct. We walk through each island
counting its cells using depth-first search: having visited everything
reachable in one direction, we check whether any unvisited cells
remain.</p>
<div class="sourceCode" id="cb196"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> check_correct n island_size num_islands empty_cells =</span>
<span id="cb196-2"><a href="#cb196-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> honey = honey_cells n empty_cells <span class="kw">in</span></span>
<span id="cb196-3"><a href="#cb196-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb196-4"><a href="#cb196-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> check_board been_islands unvisited visited =</span>
<span id="cb196-5"><a href="#cb196-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> unvisited <span class="kw">with</span></span>
<span id="cb196-6"><a href="#cb196-6" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; been_islands = num_islands</span>
<span id="cb196-7"><a href="#cb196-7" aria-hidden="true" tabindex="-1"></a>    | cell::remaining <span class="kw">when</span> CellSet.mem cell visited -&gt;</span>
<span id="cb196-8"><a href="#cb196-8" aria-hidden="true" tabindex="-1"></a>        check_board been_islands remaining visited    <span class="co">(* Keep looking *)</span></span>
<span id="cb196-9"><a href="#cb196-9" aria-hidden="true" tabindex="-1"></a>    | cell::remaining <span class="co">(* when not visited *)</span> -&gt;</span>
<span id="cb196-10"><a href="#cb196-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (been_size, unvisited, visited) =</span>
<span id="cb196-11"><a href="#cb196-11" aria-hidden="true" tabindex="-1"></a>          check_island cell                           <span class="co">(* Visit another island *)</span></span>
<span id="cb196-12"><a href="#cb196-12" aria-hidden="true" tabindex="-1"></a>            (<span class="dv">1</span>, remaining, CellSet.add cell visited) <span class="kw">in</span></span>
<span id="cb196-13"><a href="#cb196-13" aria-hidden="true" tabindex="-1"></a>        been_size = island_size</span>
<span id="cb196-14"><a href="#cb196-14" aria-hidden="true" tabindex="-1"></a>        &amp;&amp; check_board (been_islands+<span class="dv">1</span>) unvisited visited</span>
<span id="cb196-15"><a href="#cb196-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb196-16"><a href="#cb196-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">and</span> check_island current state =</span>
<span id="cb196-17"><a href="#cb196-17" aria-hidden="true" tabindex="-1"></a>    neighbors n empty_cells current</span>
<span id="cb196-18"><a href="#cb196-18" aria-hidden="true" tabindex="-1"></a>    |&gt; <span class="dt">List</span>.fold_left                                 <span class="co">(* Walk into each direction *)</span></span>
<span id="cb196-19"><a href="#cb196-19" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">fun</span> (been_size, unvisited, visited <span class="kw">as</span> state)</span>
<span id="cb196-20"><a href="#cb196-20" aria-hidden="true" tabindex="-1"></a>        neighbor -&gt;</span>
<span id="cb196-21"><a href="#cb196-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> CellSet.mem neighbor visited <span class="kw">then</span> state</span>
<span id="cb196-22"><a href="#cb196-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span></span>
<span id="cb196-23"><a href="#cb196-23" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> unvisited = remove neighbor unvisited <span class="kw">in</span></span>
<span id="cb196-24"><a href="#cb196-24" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> visited = CellSet.add neighbor visited <span class="kw">in</span></span>
<span id="cb196-25"><a href="#cb196-25" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> been_size = been_size + <span class="dv">1</span> <span class="kw">in</span></span>
<span id="cb196-26"><a href="#cb196-26" aria-hidden="true" tabindex="-1"></a>          check_island neighbor</span>
<span id="cb196-27"><a href="#cb196-27" aria-hidden="true" tabindex="-1"></a>            (been_size, unvisited, visited))</span>
<span id="cb196-28"><a href="#cb196-28" aria-hidden="true" tabindex="-1"></a>      state <span class="kw">in</span>                                        <span class="co">(* Initial been_size is 1 *)</span></span>
<span id="cb196-29"><a href="#cb196-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb196-30"><a href="#cb196-30" aria-hidden="true" tabindex="-1"></a>  check_board <span class="dv">0</span> honey empty_cells</span></code></pre></div>
<h3 id="multiple-results-per-step-concat_fold">Multiple Results per
Step: concat_fold</h3>
<p>When processing lists, sometimes each step can produce multiple
results (not just one as in <code>fold_left</code>, or many independent
ones as in <code>concat_map</code>). We need a hybrid: process elements
sequentially like <code>fold_left</code>, but allow multiple results at
each step, collecting all the final states.</p>
<p>This is <code>concat_fold</code>:</p>
<div class="sourceCode" id="cb197"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> concat_fold f a = <span class="kw">function</span></span>
<span id="cb197-2"><a href="#cb197-2" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; [a]</span>
<span id="cb197-3"><a href="#cb197-3" aria-hidden="true" tabindex="-1"></a>  | x::xs -&gt;</span>
<span id="cb197-4"><a href="#cb197-4" aria-hidden="true" tabindex="-1"></a>    f x a |-&gt; (<span class="kw">fun</span> a&#39; -&gt; concat_fold f a&#39; xs)</span></code></pre></div>
<h3 id="generating-solutions">Generating Solutions</h3>
<p>The key insight is that we can transform the <em>testing</em> code
into <em>generation</em> code by:</p>
<ol type="1">
<li>Passing around the current partial solution (the <code>eaten</code>
list)</li>
<li>Returning results in a list (empty list means no solutions from this
path)</li>
<li>At each neighbor cell, exploring <em>both</em> possibilities: eating
it (adding to <code>eaten</code>) or keeping it as honey (continuing to
walk the island)</li>
</ol>
<div class="sourceCode" id="cb198"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> find_to_eat n island_size num_islands empty_cells =</span>
<span id="cb198-2"><a href="#cb198-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> honey = honey_cells n empty_cells <span class="kw">in</span></span>
<span id="cb198-3"><a href="#cb198-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-4"><a href="#cb198-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> find_board been_islands unvisited visited eaten =</span>
<span id="cb198-5"><a href="#cb198-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> unvisited <span class="kw">with</span></span>
<span id="cb198-6"><a href="#cb198-6" aria-hidden="true" tabindex="-1"></a>    | [] -&gt;</span>
<span id="cb198-7"><a href="#cb198-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> been_islands = num_islands <span class="kw">then</span> [eaten] <span class="kw">else</span> []</span>
<span id="cb198-8"><a href="#cb198-8" aria-hidden="true" tabindex="-1"></a>    | cell::remaining <span class="kw">when</span> CellSet.mem cell visited -&gt;</span>
<span id="cb198-9"><a href="#cb198-9" aria-hidden="true" tabindex="-1"></a>      find_board been_islands remaining visited eaten</span>
<span id="cb198-10"><a href="#cb198-10" aria-hidden="true" tabindex="-1"></a>    | cell::remaining <span class="co">(* when not visited *)</span> -&gt;</span>
<span id="cb198-11"><a href="#cb198-11" aria-hidden="true" tabindex="-1"></a>      find_island cell</span>
<span id="cb198-12"><a href="#cb198-12" aria-hidden="true" tabindex="-1"></a>        (<span class="dv">1</span>, remaining, CellSet.add cell visited, eaten)</span>
<span id="cb198-13"><a href="#cb198-13" aria-hidden="true" tabindex="-1"></a>      |-&gt;                                             <span class="co">(* Concatenate solutions *)</span></span>
<span id="cb198-14"><a href="#cb198-14" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">fun</span> (been_size, unvisited, visited, eaten) -&gt;</span>
<span id="cb198-15"><a href="#cb198-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> been_size = island_size</span>
<span id="cb198-16"><a href="#cb198-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> find_board (been_islands+<span class="dv">1</span>)</span>
<span id="cb198-17"><a href="#cb198-17" aria-hidden="true" tabindex="-1"></a>               unvisited visited eaten</span>
<span id="cb198-18"><a href="#cb198-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> [])</span>
<span id="cb198-19"><a href="#cb198-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-20"><a href="#cb198-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">and</span> find_island current state =</span>
<span id="cb198-21"><a href="#cb198-21" aria-hidden="true" tabindex="-1"></a>    neighbors n empty_cells current</span>
<span id="cb198-22"><a href="#cb198-22" aria-hidden="true" tabindex="-1"></a>    |&gt; concat_fold                                    <span class="co">(* Multiple results *)</span></span>
<span id="cb198-23"><a href="#cb198-23" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">fun</span> neighbor</span>
<span id="cb198-24"><a href="#cb198-24" aria-hidden="true" tabindex="-1"></a>          (been_size, unvisited, visited, eaten <span class="kw">as</span> state) -&gt;</span>
<span id="cb198-25"><a href="#cb198-25" aria-hidden="true" tabindex="-1"></a>          <span class="kw">if</span> CellSet.mem neighbor visited <span class="kw">then</span> [state]</span>
<span id="cb198-26"><a href="#cb198-26" aria-hidden="true" tabindex="-1"></a>          <span class="kw">else</span></span>
<span id="cb198-27"><a href="#cb198-27" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> unvisited = remove neighbor unvisited <span class="kw">in</span></span>
<span id="cb198-28"><a href="#cb198-28" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> visited = CellSet.add neighbor visited <span class="kw">in</span></span>
<span id="cb198-29"><a href="#cb198-29" aria-hidden="true" tabindex="-1"></a>            (been_size, unvisited, visited,</span>
<span id="cb198-30"><a href="#cb198-30" aria-hidden="true" tabindex="-1"></a>             neighbor::eaten)::</span>
<span id="cb198-31"><a href="#cb198-31" aria-hidden="true" tabindex="-1"></a>              <span class="co">(* solutions where neighbor is honey *)</span></span>
<span id="cb198-32"><a href="#cb198-32" aria-hidden="true" tabindex="-1"></a>            find_island neighbor</span>
<span id="cb198-33"><a href="#cb198-33" aria-hidden="true" tabindex="-1"></a>              (been_size+<span class="dv">1</span>, unvisited, visited, eaten))</span>
<span id="cb198-34"><a href="#cb198-34" aria-hidden="true" tabindex="-1"></a>        state <span class="kw">in</span></span>
<span id="cb198-35"><a href="#cb198-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-36"><a href="#cb198-36" aria-hidden="true" tabindex="-1"></a>  find_board <span class="dv">0</span> honey empty_cells []</span></code></pre></div>
<h3 id="optimizations">Optimizations</h3>
<p>The brute-force generation explores far too many possibilities. The
key optimization principle is: <strong>fail (drop solution candidates)
as early as possible</strong>.</p>
<p>Instead of blindly exploring all choices, we add guards to prune
branches that cannot lead to solutions:</p>
<ul>
<li>Do not try to eat more cells if we have already eaten enough</li>
<li>Do not add more cells to an island that is already full</li>
<li>Track exactly how many cells still need to be eaten</li>
</ul>
<div class="sourceCode" id="cb199"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> state = {</span>
<span id="cb199-2"><a href="#cb199-2" aria-hidden="true" tabindex="-1"></a>  been_size: <span class="dt">int</span>;                           <span class="co">(* Honey cells in current island *)</span></span>
<span id="cb199-3"><a href="#cb199-3" aria-hidden="true" tabindex="-1"></a>  been_islands: <span class="dt">int</span>;                        <span class="co">(* Islands visited so far *)</span></span>
<span id="cb199-4"><a href="#cb199-4" aria-hidden="true" tabindex="-1"></a>  unvisited: cell <span class="dt">list</span>;                     <span class="co">(* Cells to visit *)</span></span>
<span id="cb199-5"><a href="#cb199-5" aria-hidden="true" tabindex="-1"></a>  visited: CellSet.t;                       <span class="co">(* Already visited *)</span></span>
<span id="cb199-6"><a href="#cb199-6" aria-hidden="true" tabindex="-1"></a>  eaten: cell <span class="dt">list</span>;                         <span class="co">(* Current solution candidate *)</span></span>
<span id="cb199-7"><a href="#cb199-7" aria-hidden="true" tabindex="-1"></a>  more_to_eat: <span class="dt">int</span>;                         <span class="co">(* Remaining cells to eat *)</span></span>
<span id="cb199-8"><a href="#cb199-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb199-9"><a href="#cb199-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-10"><a href="#cb199-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> visit_cell s =</span>
<span id="cb199-11"><a href="#cb199-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> s.unvisited <span class="kw">with</span></span>
<span id="cb199-12"><a href="#cb199-12" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; <span class="dt">None</span></span>
<span id="cb199-13"><a href="#cb199-13" aria-hidden="true" tabindex="-1"></a>  | c::remaining <span class="kw">when</span> CellSet.mem c s.visited -&gt;</span>
<span id="cb199-14"><a href="#cb199-14" aria-hidden="true" tabindex="-1"></a>    visit_cell {s <span class="kw">with</span> unvisited=remaining}</span>
<span id="cb199-15"><a href="#cb199-15" aria-hidden="true" tabindex="-1"></a>  | c::remaining <span class="co">(* when c not visited *)</span> -&gt;</span>
<span id="cb199-16"><a href="#cb199-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Some</span> (c, {s <span class="kw">with</span></span>
<span id="cb199-17"><a href="#cb199-17" aria-hidden="true" tabindex="-1"></a>      unvisited=remaining;</span>
<span id="cb199-18"><a href="#cb199-18" aria-hidden="true" tabindex="-1"></a>      visited = CellSet.add c s.visited})</span>
<span id="cb199-19"><a href="#cb199-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-20"><a href="#cb199-20" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> eat_cell c s =</span>
<span id="cb199-21"><a href="#cb199-21" aria-hidden="true" tabindex="-1"></a>  {s <span class="kw">with</span> eaten = c::s.eaten;</span>
<span id="cb199-22"><a href="#cb199-22" aria-hidden="true" tabindex="-1"></a>    visited = CellSet.add c s.visited;</span>
<span id="cb199-23"><a href="#cb199-23" aria-hidden="true" tabindex="-1"></a>    more_to_eat = s.more_to_eat - <span class="dv">1</span>}</span>
<span id="cb199-24"><a href="#cb199-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-25"><a href="#cb199-25" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> keep_cell c s =                         <span class="co">(* c is actually unused *)</span></span>
<span id="cb199-26"><a href="#cb199-26" aria-hidden="true" tabindex="-1"></a>  {s <span class="kw">with</span> been_size = s.been_size + <span class="dv">1</span>;</span>
<span id="cb199-27"><a href="#cb199-27" aria-hidden="true" tabindex="-1"></a>    visited = CellSet.add c s.visited}</span>
<span id="cb199-28"><a href="#cb199-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-29"><a href="#cb199-29" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fresh_island s =                 <span class="co">(* Increment been_size at start of find_island *)</span></span>
<span id="cb199-30"><a href="#cb199-30" aria-hidden="true" tabindex="-1"></a>  {s <span class="kw">with</span> been_size = <span class="dv">0</span>;</span>
<span id="cb199-31"><a href="#cb199-31" aria-hidden="true" tabindex="-1"></a>    been_islands = s.been_islands + <span class="dv">1</span>}</span>
<span id="cb199-32"><a href="#cb199-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-33"><a href="#cb199-33" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> init_state unvisited more_to_eat = {</span>
<span id="cb199-34"><a href="#cb199-34" aria-hidden="true" tabindex="-1"></a>  been_size = <span class="dv">0</span>; been_islands = <span class="dv">0</span>;</span>
<span id="cb199-35"><a href="#cb199-35" aria-hidden="true" tabindex="-1"></a>  unvisited; visited = CellSet.empty;</span>
<span id="cb199-36"><a href="#cb199-36" aria-hidden="true" tabindex="-1"></a>  eaten = []; more_to_eat;</span>
<span id="cb199-37"><a href="#cb199-37" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The optimized island loop only tries actions that make sense:</p>
<pre><code>  and find_island current s =
    let s = keep_cell current s in
    neighbors n empty_cells current
    |&gt; concat_fold
        (fun neighbor s -&gt;
          if CellSet.mem neighbor s.visited then [s]
          else
            let choose_eat =                (* Guard against failed actions *)
              if s.more_to_eat = 0 then []
              else [eat_cell neighbor s]
            and choose_keep =
              if s.been_size &gt;= island_size then []
              else find_island neighbor s in
            choose_eat @ choose_keep)
        s in
  (* Finally, compute the required eaten cells and start searching *)
  let cells_to_eat =
    List.length honey - island_size * num_islands in
  find_board (init_state honey cells_to_eat)</code></pre>
<h2 id="constraint-based-puzzles">6.10 Constraint-Based Puzzles</h2>
<p>Many puzzles can be understood in terms of <strong>constraint
satisfaction</strong>:</p>
<ol type="1">
<li>The puzzle defines the <em>general form</em> of solutions (what
variables need values)</li>
<li>The puzzle specifies <em>constraints</em> that valid solutions must
satisfy</li>
</ol>
<p>For example, in Sudoku, the variables are the 81 cells, each with
domain {1,…,9}, and the constraints require each row, column, and 3x3
box to contain all digits exactly once.</p>
<p>In the Honey Islands puzzle, we could view each cell as a variable
with domain {Honey, Empty}. The constraints specify which cells must be
empty initially, and the requirement of forming a specific number and
size of connected components.</p>
<h3 id="finite-domain-constraint-programming">Finite Domain Constraint
Programming</h3>
<p><strong>Constraint propagation</strong> is a powerful technique for
solving such puzzles efficiently. The key idea is to track <em>sets of
possible values</em> for each variable and systematically eliminate
impossibilities:</p>
<ol type="1">
<li><p><strong>Initialize:</strong> For each variable, start with the
full set of possible values (its domain). The current “partial solution”
is this collection of sets.</p></li>
<li><p><strong>Propagate and split:</strong> Repeat until all variables
have exactly one value:</p>
<ul>
<li><ol type="a">
<li><strong>Propagate constraints:</strong> If some value for a variable
is inconsistent with <em>all</em> possible values of related variables,
remove it</li>
</ol></li>
<li><ol start="2" type="a">
<li><strong>Prune failures:</strong> If any variable has an empty set of
possible values, this partial solution has no completions – abandon
it</li>
</ol></li>
<li><ol start="3" type="a">
<li><strong>Split:</strong> Select a variable with multiple possible
values. Create new partial solutions by partitioning its possibilities
(simplest: try each value separately, or split into “this value” vs “all
others”)</li>
</ol></li>
</ul></li>
<li><p><strong>Extract solutions:</strong> When all variables have
single values, we have found a solution.</p></li>
</ol>
<p>The efficiency comes from <em>early pruning</em>: constraint
propagation often eliminates many possibilities without explicitly
trying them, dramatically reducing the search space compared to
brute-force enumeration.</p>
<h2 id="exercises-5">6.11 Exercises</h2>
<ol type="1">
<li><p>Recall how we generated all subsequences of a list. Find
(generate) all:</p>
<ul>
<li>permutations of a list</li>
<li>ways of choosing without repetition from a list</li>
<li>combinations of K distinct objects chosen from N elements of a
list</li>
</ul></li>
<li><p>Using folding for the <code>expression</code> data type, compute
the degree of the corresponding polynomial.</p></li>
<li><p>Implement simplification of expressions using mapping for the
<code>expression</code> data type.</p></li>
<li><p>Express in terms of <code>fold_left</code> or
<code>fold_right</code>:</p>
<ul>
<li><code>indexed : 'a list -&gt; (int * 'a) list</code>, which pairs
elements with their indices</li>
<li><code>concat_fold</code> as used in Honey Islands</li>
<li>Run-length encoding of a list:
<code>encode ['a;'a;'a;'a;'b;'c;'c;'a;'a;'d] = [4,'a; 1,'b; 2,'c; 2,'a; 1,'d]</code></li>
</ul></li>
<li><p>Write more efficient variants:</p>
<ul>
<li><code>list_diff</code> computing difference of sets represented as
sorted lists</li>
<li><code>is_unique</code> in constant stack space</li>
</ul></li>
<li><p>Write functions <code>compose</code> and <code>perform</code>
that take a list of functions and return their composition:</p>
<ul>
<li><code>compose [f1; ...; fn] = x -&gt; f1 (... (fn x)...)</code></li>
<li><code>perform [f1; ...; fn] = x -&gt; fn (... (f1 x)...)</code></li>
</ul></li>
<li><p>Write a solver for the <em>Tents Puzzle</em>.</p></li>
<li><p><strong>Robot Squad</strong> (harder): Given a map with walls and
lidar readings (8 directions: E, NE, N, NW, W, SW, S, SE) for multiple
robots, determine possible robot positions.</p></li>
<li><p>Write a solver for the <em>Plinx Puzzle</em> (does not need to
solve all levels, but should handle initial ones).</p></li>
</ol>
<h1 id="chapter-7-laziness">Chapter 7: Laziness</h1>
<p><em>“Today’s lecture is about lazy evaluation. Thank you for coming,
goodbye!”</em></p>
<p>Well, perhaps you have some questions? This chapter explores one of
the most elegant ideas in functional programming: lazy evaluation. By
deferring computation until results are actually needed, we unlock
powerful techniques for working with infinite data structures, solving
differential equations symbolically, and building sophisticated
stream-processing pipelines.</p>
<p>We will examine different evaluation strategies, implement streams
and lazy lists, apply them to power series computation and differential
equations, build circular data structures, and develop a sophisticated
pipe-based pretty-printer. Along the way, we will see how laziness
transforms the way we think about computation itself.</p>
<p><strong>In this chapter, you will:</strong></p>
<ul>
<li>Distinguish evaluation strategies (call-by-value/name/need) and
their consequences</li>
<li>Build infinite data structures safely using streams and lazy
values</li>
<li>Apply laziness to nontrivial examples (power series, differential
equations, pretty-printing)</li>
<li>Learn where laziness interacts poorly with effects (I/O) and how to
reason about it</li>
</ul>
<h2 id="evaluation-strategies-and-parameter-passing">7.1 Evaluation
Strategies and Parameter Passing</h2>
<p><strong>Evaluation strategy</strong> is the order in which
expressions are computed – primarily, when arguments are computed.
Recall our problems with using <em>flow control</em> expressions like
<code>if_then_else</code> in examples from the lambda-calculus lecture.
There are many technical terms describing various evaluation
strategies:</p>
<p><strong>Strict evaluation</strong>: Arguments are always evaluated
completely before the function is applied.</p>
<p><strong>Non-strict evaluation</strong>: Arguments are not evaluated
unless they are actually used in the evaluation of the function
body.</p>
<p><strong>Eager evaluation</strong>: An expression is evaluated as soon
as it gets bound to a variable.</p>
<p><strong>Lazy evaluation</strong>: Non-strict evaluation which avoids
repeating computation.</p>
<p><strong>Call-by-value</strong>: The argument expression is evaluated,
and the resulting value is bound to the corresponding variable in the
function (frequently by copying the value into a new memory region).</p>
<p><strong>Call-by-reference</strong>: A function receives an implicit
reference to a variable used as argument, rather than a copy of its
value. In purely functional languages there is no difference between the
two strategies, so they are typically described as call-by-value even
though implementations use call-by-reference internally for efficiency.
Call-by-value languages like C and OCaml support explicit references
(objects that refer to other objects), and these can be used to simulate
call-by-reference.</p>
<p><strong>Normal order</strong>: Start computing function bodies before
evaluating their arguments. Do not even wait for arguments if they are
not needed.</p>
<p><strong>Call-by-name</strong>: Arguments are substituted directly
into the function body and then left to be evaluated whenever they
appear in the function. This means an argument might be evaluated
multiple times if it appears multiple times in the function body.</p>
<p><strong>Call-by-need</strong>: If the function argument is evaluated,
that value is stored for subsequent uses. This avoids the redundant
recomputation that can occur with call-by-name.</p>
<p>Almost all languages do not compute inside the body of an un-applied
function, but with curried functions you can pre-compute data before all
arguments are provided (recall the <code>search_bible</code> example
from earlier lectures, where preprocessing happened when the first
argument was supplied).</p>
<p>In eager / call-by-value languages we can simulate call-by-name by
taking a function to compute the value as an argument instead of the
value directly. “Our” languages have a <code>unit</code> type with a
single value <code>()</code> specifically for use as throw-away
arguments – we pass <code>fun () -&gt; expensive_computation</code>
instead of <code>expensive_computation</code> directly. Scala has
built-in support for call-by-name (i.e. direct, without the need to
build argument functions).</p>
<p>OCaml (like most ML-family languages) is <em>strict by default</em>
but provides explicit laziness (<code>lazy</code>,
<code>Lazy.force</code>, and <code>Lazy.t</code>) when you want it.
Haskell is <em>lazy by default</em> but provides explicit strictness
(e.g. <code>seq</code>, strict fields, bang patterns) when you need it.
This reflects the different design philosophies: OCaml defaults to
strict evaluation with opt-in laziness, while Haskell defaults to lazy
evaluation with opt-in strictness.</p>
<h2 id="call-by-name-streams">7.2 Call-by-name: Streams</h2>
<p>Call-by-name is useful not only for implementing flow control.
Remember how we struggled to define <code>if_then_else</code> as a
regular function in the lambda calculus lecture? The problem was that
both branches would be evaluated before the function could choose
between them. With call-by-name simulation, we can finally make it
work:</p>
<div class="sourceCode" id="cb201"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> if_then_else cond e1 e2 =</span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> cond <span class="kw">with</span></span>
<span id="cb201-3"><a href="#cb201-3" aria-hidden="true" tabindex="-1"></a>  | <span class="kw">true</span> -&gt; e1 ()</span>
<span id="cb201-4"><a href="#cb201-4" aria-hidden="true" tabindex="-1"></a>  | <span class="kw">false</span> -&gt; e2 ()</span></code></pre></div>
<p>Here <code>e1</code> and <code>e2</code> are functions that compute
their respective branches only when called. But call-by-name is useful
for more than just flow control – it also enables lazy data
structures.</p>
<p><strong>Streams</strong> are lists with call-by-name tails:</p>
<div class="sourceCode" id="cb202"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a stream = SNil | SCons <span class="kw">of</span> &#39;a * (<span class="dt">unit</span> -&gt; &#39;a stream)</span></code></pre></div>
<p>The key insight is that the tail is not a stream directly, but a
<em>function</em> that produces a stream when called. This means the
tail is not computed until we actually need it. Reading from a stream
into a regular list forces evaluation of the requested elements:</p>
<div class="sourceCode" id="cb203"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> stake n = <span class="kw">function</span></span>
<span id="cb203-2"><a href="#cb203-2" aria-hidden="true" tabindex="-1"></a>  | SCons (a, s) <span class="kw">when</span> n &gt; <span class="dv">0</span> -&gt; a :: (stake (n<span class="dv">-1</span>) (s ()))</span>
<span id="cb203-3"><a href="#cb203-3" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; []</span></code></pre></div>
<p>Notice how we call <code>s ()</code> to get the next portion of the
stream. This is where the “lazy” computation happens. Because of this
delayed evaluation, streams can easily be infinite:</p>
<div class="sourceCode" id="cb204"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> s_ones = SCons (<span class="dv">1</span>, <span class="kw">fun</span> () -&gt; s_ones)</span>
<span id="cb204-2"><a href="#cb204-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb204-3"><a href="#cb204-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> s_from n =</span>
<span id="cb204-4"><a href="#cb204-4" aria-hidden="true" tabindex="-1"></a>  SCons (n, <span class="kw">fun</span> () -&gt; s_from (n+<span class="dv">1</span>))</span></code></pre></div>
<p>The stream <code>s_ones</code> is an infinite sequence of 1s – it
refers to itself as its own tail! The stream <code>s_from n</code>
produces all integers starting from <code>n</code>. These definitions
would cause infinite loops in a strict language, but with streams, we
only compute as much as we request.</p>
<h3 id="stream-operations">Stream Operations</h3>
<p>Just as we can define higher-order functions on lists, streams admit
similar operations. The key difference is that we must wrap recursive
calls in functions to maintain laziness:</p>
<div class="sourceCode" id="cb205"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> smap f = <span class="kw">function</span></span>
<span id="cb205-2"><a href="#cb205-2" aria-hidden="true" tabindex="-1"></a>  | SNil -&gt; SNil</span>
<span id="cb205-3"><a href="#cb205-3" aria-hidden="true" tabindex="-1"></a>  | SCons (a, s) -&gt; SCons (f a, <span class="kw">fun</span> () -&gt; smap f (s ()))</span>
<span id="cb205-4"><a href="#cb205-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb205-5"><a href="#cb205-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> szip = <span class="kw">function</span></span>
<span id="cb205-6"><a href="#cb205-6" aria-hidden="true" tabindex="-1"></a>  | SNil, SNil -&gt; SNil</span>
<span id="cb205-7"><a href="#cb205-7" aria-hidden="true" tabindex="-1"></a>  | SCons (a1, s1), SCons (a2, s2) -&gt;</span>
<span id="cb205-8"><a href="#cb205-8" aria-hidden="true" tabindex="-1"></a>      SCons ((a1, a2), <span class="kw">fun</span> () -&gt; szip (s1 (), s2 ()))</span>
<span id="cb205-9"><a href="#cb205-9" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; <span class="dt">raise</span> (<span class="dt">Invalid_argument</span> <span class="st">&quot;szip&quot;</span>)</span></code></pre></div>
<p>Streams can provide scaffolding for recursive algorithms, enabling
elegant definitions that would be impossible with strict data
structures. Consider the Fibonacci sequence:</p>
<div class="sourceCode" id="cb206"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb206-1"><a href="#cb206-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> sfib =</span>
<span id="cb206-2"><a href="#cb206-2" aria-hidden="true" tabindex="-1"></a>  SCons (<span class="dv">1</span>, <span class="kw">fun</span> () -&gt; smap (<span class="kw">fun</span> (a,b) -&gt; a+b)</span>
<span id="cb206-3"><a href="#cb206-3" aria-hidden="true" tabindex="-1"></a>    (szip (sfib, SCons (<span class="dv">1</span>, <span class="kw">fun</span> () -&gt; sfib))))</span></code></pre></div>
<p>This remarkably concise definition creates a stream where each
element is computed by adding pairs from the current stream and itself
shifted by one position. The stream effectively “builds itself” by
referring to its own earlier elements:</p>
<table>
<thead>
<tr>
<th>sfib</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>5</th>
<th>8</th>
<th>13</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr>
<td>sfib</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>8</td>
<td>13</td>
<td>…</td>
</tr>
<tr>
<td>shifted</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>8</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>The <code>+</code> operation between corresponding elements produces
the next values.</p>
<h3 id="streams-and-input-output">Streams and Input-Output</h3>
<p>Streams can be used to read from files lazily, but there is a catch –
they are less functional than one might expect in the context of
input-output effects:</p>
<div class="sourceCode" id="cb207"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> file_stream name =</span>
<span id="cb207-2"><a href="#cb207-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ch = <span class="dt">open_in</span> name <span class="kw">in</span></span>
<span id="cb207-3"><a href="#cb207-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> ch_read_line () =</span>
<span id="cb207-4"><a href="#cb207-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> SCons (<span class="dt">input_line</span> ch, ch_read_line)</span>
<span id="cb207-5"><a href="#cb207-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">with</span> <span class="dt">End_of_file</span> -&gt; SNil <span class="kw">in</span></span>
<span id="cb207-6"><a href="#cb207-6" aria-hidden="true" tabindex="-1"></a>  ch_read_line ()</span></code></pre></div>
<p>The problem is that reading from a file is a side effect. If you
traverse the stream twice, you will not get the same results – the file
handle advances with each read. This is why <em>OCaml Batteries</em>
uses a stream type <code>enum</code> for interfacing between various
sequence-like data types, with careful documentation about when streams
can be safely reused.</p>
<p>The safest way to use streams is in a <em>linear</em> or
<em>ephemeral</em> manner: every value used only once. Streams minimize
space consumption at the expense of time for recomputation – if you need
to traverse the data multiple times, you will recompute it each time.
For data that should be computed once and accessed multiple times, we
need lazy lists.</p>
<h2 id="lazy-values">7.3 Lazy Values</h2>
<p>Lazy evaluation is more general than call-by-need as any value can be
lazy, not only a function parameter. While streams give us call-by-name
semantics (recomputing on each access), lazy values give us call-by-need
semantics (computing once and caching the result).</p>
<p>A <em>lazy value</em> is a value that “holds” an expression until its
result is needed, and from then on it “holds” the result. It is also
called a <em>suspension</em>. If it holds the expression (not yet
evaluated), it is called a <em>thunk</em> – a placeholder waiting to
become a real value.</p>
<p>In OCaml, we build lazy values explicitly using the <code>lazy</code>
keyword. In Haskell, all values are lazy by default, but functions can
have call-by-value parameters which “need” (force evaluation of) the
argument.</p>
<p>To create a lazy value: <code>lazy expr</code> – where
<code>expr</code> is the suspended computation. The expression
<code>expr</code> is not evaluated when the lazy value is created; it is
stored for later.</p>
<p>There are two ways to use a lazy value. Be careful to understand when
the result is computed! - In expressions: <code>Lazy.force l_expr</code>
– explicitly forces evaluation - In patterns:
<code>match l_expr with lazy v -&gt; ...</code> – forces evaluation
during pattern matching - Syntactically <code>lazy</code> behaves like a
data constructor, which is why it can appear in patterns.</p>
<h3 id="lazy-lists">Lazy Lists</h3>
<p>Lazy lists are the “memoizing” version of streams. Instead of a
function that recomputes the tail each time, we use a lazy value that
computes it once:</p>
<div class="sourceCode" id="cb208"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb208-1"><a href="#cb208-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a llist = LNil | LCons <span class="kw">of</span> &#39;a * &#39;a llist <span class="dt">Lazy</span>.t</span></code></pre></div>
<p>The tail is of type <code>'a llist Lazy.t</code> – a lazy value that
will produce the rest of the list when forced. Reading from a lazy list
into a regular list forces evaluation of just the elements we need:</p>
<div class="sourceCode" id="cb209"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb209-1"><a href="#cb209-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> ltake n = <span class="kw">function</span></span>
<span id="cb209-2"><a href="#cb209-2" aria-hidden="true" tabindex="-1"></a>  | LCons (a, <span class="kw">lazy</span> l) <span class="kw">when</span> n &gt; <span class="dv">0</span> -&gt; a :: (ltake (n<span class="dv">-1</span>) l)</span>
<span id="cb209-3"><a href="#cb209-3" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; []</span></code></pre></div>
<p>Notice the <code>lazy l</code> pattern – this forces evaluation of
the lazy tail and binds the result to <code>l</code>. Lazy lists can
easily be infinite, just like streams:</p>
<div class="sourceCode" id="cb210"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> l_ones = LCons (<span class="dv">1</span>, <span class="kw">lazy</span> l_ones)</span>
<span id="cb210-2"><a href="#cb210-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-3"><a href="#cb210-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> l_from n = LCons (n, <span class="kw">lazy</span> (l_from (n+<span class="dv">1</span>)))</span></code></pre></div>
<p>The crucial difference from streams is that lazy lists support “read
once, access multiple times” semantics. Once a portion of the list has
been computed, subsequent accesses return the cached result:</p>
<div class="sourceCode" id="cb211"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb211-1"><a href="#cb211-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> file_llist name =</span>
<span id="cb211-2"><a href="#cb211-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ch = <span class="dt">open_in</span> name <span class="kw">in</span></span>
<span id="cb211-3"><a href="#cb211-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> ch_read_line () =</span>
<span id="cb211-4"><a href="#cb211-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> LCons (<span class="dt">input_line</span> ch, <span class="kw">lazy</span> (ch_read_line ()))</span>
<span id="cb211-5"><a href="#cb211-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">with</span> <span class="dt">End_of_file</span> -&gt; LNil <span class="kw">in</span></span>
<span id="cb211-6"><a href="#cb211-6" aria-hidden="true" tabindex="-1"></a>  ch_read_line ()</span></code></pre></div>
<p>With <code>file_llist</code>, you can traverse the resulting list
multiple times and get the same data each time (as long as you keep a
reference to the head of the list). The file is read lazily, but each
line is cached after being read.</p>
<h3 id="lazy-list-operations">Lazy List Operations</h3>
<p>We can define the familiar higher-order functions on lazy lists.
Notice the subtle but important difference from streams – we must use
<code>Lazy.force</code> to access the lazy tail before passing it to
recursive calls:</p>
<div class="sourceCode" id="cb212"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb212-1"><a href="#cb212-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> lzip = <span class="kw">function</span></span>
<span id="cb212-2"><a href="#cb212-2" aria-hidden="true" tabindex="-1"></a>  | LNil, LNil -&gt; LNil</span>
<span id="cb212-3"><a href="#cb212-3" aria-hidden="true" tabindex="-1"></a>  | LCons (a1, ll1), LCons (a2, ll2) -&gt;</span>
<span id="cb212-4"><a href="#cb212-4" aria-hidden="true" tabindex="-1"></a>      LCons ((a1, a2), <span class="kw">lazy</span> (</span>
<span id="cb212-5"><a href="#cb212-5" aria-hidden="true" tabindex="-1"></a>        lzip (<span class="dt">Lazy</span>.force ll1, <span class="dt">Lazy</span>.force ll2)))</span>
<span id="cb212-6"><a href="#cb212-6" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; <span class="dt">raise</span> (<span class="dt">Invalid_argument</span> <span class="st">&quot;lzip&quot;</span>)</span>
<span id="cb212-7"><a href="#cb212-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb212-8"><a href="#cb212-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> lmap f = <span class="kw">function</span></span>
<span id="cb212-9"><a href="#cb212-9" aria-hidden="true" tabindex="-1"></a>  | LNil -&gt; LNil</span>
<span id="cb212-10"><a href="#cb212-10" aria-hidden="true" tabindex="-1"></a>  | LCons (a, ll) -&gt;</span>
<span id="cb212-11"><a href="#cb212-11" aria-hidden="true" tabindex="-1"></a>    LCons (f a, <span class="kw">lazy</span> (lmap f (<span class="dt">Lazy</span>.force ll)))</span></code></pre></div>
<p>Using these operations, we can define the factorial sequence in a
beautifully self-referential way:</p>
<div class="sourceCode" id="cb213"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> posnums = l_from <span class="dv">1</span></span>
<span id="cb213-2"><a href="#cb213-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-3"><a href="#cb213-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> lfact =</span>
<span id="cb213-4"><a href="#cb213-4" aria-hidden="true" tabindex="-1"></a>  LCons (<span class="dv">1</span>, <span class="kw">lazy</span> (lmap (<span class="kw">fun</span> (a,b) -&gt; a*b)</span>
<span id="cb213-5"><a href="#cb213-5" aria-hidden="true" tabindex="-1"></a>                    (lzip (lfact, posnums))))</span></code></pre></div>
<p>This produces: 1, 1, 2, 6, 24, 120, … The definition is elegant: each
factorial is the product of the previous factorial and the corresponding
positive integer. The lazy list <code>lfact</code> refers to itself to
get the previous factorials!</p>
<table>
<thead>
<tr>
<th>lfact</th>
<th>1</th>
<th>1</th>
<th>2</th>
<th>6</th>
<th>24</th>
<th>120</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr>
<td>lfact</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>6</td>
<td>24</td>
<td>120</td>
<td>…</td>
</tr>
<tr>
<td>posnums</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>The <code>*</code> operation between corresponding elements produces
the next values.</p>
<h2 id="power-series-and-differential-equations">7.4 Power Series and
Differential Equations</h2>
<p>This section presents a fascinating application of lazy lists:
computing power series and solving differential equations symbolically.
The differential equations idea is due to Henning Thielemann, and
demonstrates the expressive power of lazy evaluation.</p>
<p>The expression <span class="math inline">P(x) = \sum_{i=0}^{n} a_i
x^i</span> defines a polynomial when <span class="math inline">n &lt;
\infty</span> and a power series when <span class="math inline">n =
\infty</span>. We can represent both as lazy lists of coefficients <span
class="math inline">[a_0; a_1; a_2; \ldots]</span>.</p>
<p>If we define:</p>
<div class="sourceCode" id="cb214"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> lfold_right f l base =</span>
<span id="cb214-2"><a href="#cb214-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb214-3"><a href="#cb214-3" aria-hidden="true" tabindex="-1"></a>    | LNil -&gt; base</span>
<span id="cb214-4"><a href="#cb214-4" aria-hidden="true" tabindex="-1"></a>    | LCons (a, <span class="kw">lazy</span> l) -&gt; f a (lfold_right f l base)</span></code></pre></div>
<p>then we can compute polynomials using Horner’s method. Horner’s
method evaluates polynomials efficiently by factoring out powers of
<span class="math inline">x</span>: instead of computing <span
class="math inline">a_0 + a_1 x + a_2 x^2 + \ldots</span>, we compute
<span class="math inline">a_0 + x(a_1 + x(a_2 + \ldots))</span>:</p>
<div class="sourceCode" id="cb215"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb215-1"><a href="#cb215-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> horner x l =</span>
<span id="cb215-2"><a href="#cb215-2" aria-hidden="true" tabindex="-1"></a>  lfold_right (<span class="kw">fun</span> c sum -&gt; c +. x *. sum) l <span class="dv">0</span>.</span></code></pre></div>
<p>But this will not work for infinite power series! Two natural
questions arise: - Does it make sense to compute the value at <span
class="math inline">x</span> of a power series? - Does it make sense to
fold an infinite list?</p>
<p>The answer to both is “yes, sometimes.” If the power series converges
for <span class="math inline">x &gt; 1</span>, then when the elements
<span class="math inline">a_n</span> get small, the remaining sum <span
class="math inline">\sum_{i=n}^{\infty} a_i x^i</span> is also small. We
can truncate the computation when the contribution becomes
negligible.</p>
<p>The problem is that <code>lfold_right</code> falls into an infinite
loop on infinite lists – it tries to reach the end before computing
anything. We need call-by-name / call-by-need semantics for the argument
function <code>f</code>, so it can decide to stop early:</p>
<div class="sourceCode" id="cb216"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb216-1"><a href="#cb216-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> lazy_foldr f l base =</span>
<span id="cb216-2"><a href="#cb216-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb216-3"><a href="#cb216-3" aria-hidden="true" tabindex="-1"></a>    | LNil -&gt; base</span>
<span id="cb216-4"><a href="#cb216-4" aria-hidden="true" tabindex="-1"></a>    | LCons (a, ll) -&gt;</span>
<span id="cb216-5"><a href="#cb216-5" aria-hidden="true" tabindex="-1"></a>      f a (<span class="kw">lazy</span> (lazy_foldr f (<span class="dt">Lazy</span>.force ll) base))</span></code></pre></div>
<p>Now we need a stopping condition in the Horner algorithm step. We
stop when the coefficient becomes small enough that further terms are
negligible:</p>
<div class="sourceCode" id="cb217"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb217-1"><a href="#cb217-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> lhorner x l =                    <span class="co">(* This is a bit of a hack: *)</span></span>
<span id="cb217-2"><a href="#cb217-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> upd c sum =                    <span class="co">(* we hope to &quot;hit&quot; the interval (0, epsilon]. *)</span></span>
<span id="cb217-3"><a href="#cb217-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> c = <span class="dv">0</span>. || <span class="dt">abs_float</span> c &gt; <span class="dt">epsilon_float</span></span>
<span id="cb217-4"><a href="#cb217-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> c +. x *. <span class="dt">Lazy</span>.force sum</span>
<span id="cb217-5"><a href="#cb217-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="dv">0</span>. <span class="kw">in</span>                       <span class="co">(* Stop when c is tiny but nonzero. *)</span></span>
<span id="cb217-6"><a href="#cb217-6" aria-hidden="true" tabindex="-1"></a>  lazy_foldr upd l <span class="dv">0</span>.</span>
<span id="cb217-7"><a href="#cb217-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb217-8"><a href="#cb217-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> inv_fact = lmap (<span class="kw">fun</span> n -&gt; <span class="dv">1</span>. /. <span class="dt">float_of_int</span> n) lfact</span>
<span id="cb217-9"><a href="#cb217-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> e = lhorner <span class="dv">1</span>. inv_fact</span></code></pre></div>
<p>The <code>inv_fact</code> list contains <span
class="math inline">[1/0!; 1/1!; 1/2!; \ldots]</span>, which is the
power series for <span class="math inline">e^x</span>. Evaluating
<code>lhorner 1. inv_fact</code> computes <span class="math inline">e^1
= e</span>.</p>
<h3 id="power-series-polynomial-operations">Power Series / Polynomial
Operations</h3>
<p>To work with power series, we need to define arithmetic operations on
lazy lists of coefficients. For floating-point coefficients, we first
need a float-based version of positive numbers:</p>
<div class="sourceCode" id="cb218"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb218-1"><a href="#cb218-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> l_from_f n = LCons (n, <span class="kw">lazy</span> (l_from_f (n +. <span class="dv">1</span>.)))</span>
<span id="cb218-2"><a href="#cb218-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> posnums_f = l_from_f <span class="dv">1</span>.</span>
<span id="cb218-3"><a href="#cb218-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb218-4"><a href="#cb218-4" aria-hidden="true" tabindex="-1"></a><span class="co">(* Unary negation for series *)</span></span>
<span id="cb218-5"><a href="#cb218-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (~-:) = lmap (<span class="kw">fun</span> x -&gt; -.x)</span></code></pre></div>
<p>Now we can define the basic arithmetic operations on power series.
Addition and subtraction work coefficient-wise:</p>
<div class="sourceCode" id="cb219"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> add xs ys =</span>
<span id="cb219-2"><a href="#cb219-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> xs, ys <span class="kw">with</span></span>
<span id="cb219-3"><a href="#cb219-3" aria-hidden="true" tabindex="-1"></a>    | LNil, _ -&gt; ys</span>
<span id="cb219-4"><a href="#cb219-4" aria-hidden="true" tabindex="-1"></a>    | _, LNil -&gt; xs</span>
<span id="cb219-5"><a href="#cb219-5" aria-hidden="true" tabindex="-1"></a>    | LCons (x,xs), LCons (y,ys) -&gt;</span>
<span id="cb219-6"><a href="#cb219-6" aria-hidden="true" tabindex="-1"></a>      LCons (x +. y, <span class="kw">lazy</span> (add (<span class="dt">Lazy</span>.force xs) (<span class="dt">Lazy</span>.force ys)))</span>
<span id="cb219-7"><a href="#cb219-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-8"><a href="#cb219-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> sub xs ys =</span>
<span id="cb219-9"><a href="#cb219-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> xs, ys <span class="kw">with</span></span>
<span id="cb219-10"><a href="#cb219-10" aria-hidden="true" tabindex="-1"></a>    | LNil, _ -&gt; lmap (<span class="kw">fun</span> x -&gt; -.x) ys</span>
<span id="cb219-11"><a href="#cb219-11" aria-hidden="true" tabindex="-1"></a>    | _, LNil -&gt; xs</span>
<span id="cb219-12"><a href="#cb219-12" aria-hidden="true" tabindex="-1"></a>    | LCons (x,xs), LCons (y,ys) -&gt;</span>
<span id="cb219-13"><a href="#cb219-13" aria-hidden="true" tabindex="-1"></a>      LCons (x -. y, <span class="kw">lazy</span> (add (<span class="dt">Lazy</span>.force xs) (<span class="dt">Lazy</span>.force ys)))</span>
<span id="cb219-14"><a href="#cb219-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-15"><a href="#cb219-15" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> scale s = lmap (<span class="kw">fun</span> x -&gt; s *. x)</span>
<span id="cb219-16"><a href="#cb219-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-17"><a href="#cb219-17" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> shift n xs =</span>
<span id="cb219-18"><a href="#cb219-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> xs</span>
<span id="cb219-19"><a href="#cb219-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> <span class="kw">if</span> n &gt; <span class="dv">0</span> <span class="kw">then</span> LCons (<span class="dv">0</span>., <span class="kw">lazy</span> (shift (n<span class="dv">-1</span>) xs))  <span class="co">(* Multiply by x^n *)</span></span>
<span id="cb219-20"><a href="#cb219-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> <span class="kw">match</span> xs <span class="kw">with</span>                                    <span class="co">(* Divide by x^|n| *)</span></span>
<span id="cb219-21"><a href="#cb219-21" aria-hidden="true" tabindex="-1"></a>    | LNil -&gt; LNil</span>
<span id="cb219-22"><a href="#cb219-22" aria-hidden="true" tabindex="-1"></a>    | LCons (<span class="dv">0</span>., <span class="kw">lazy</span> xs) -&gt; shift (n+<span class="dv">1</span>) xs</span>
<span id="cb219-23"><a href="#cb219-23" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; <span class="dt">failwith</span> <span class="st">&quot;shift: fractional division&quot;</span></span>
<span id="cb219-24"><a href="#cb219-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-25"><a href="#cb219-25" aria-hidden="true" tabindex="-1"></a><span class="co">(* Multiplication uses the convolution formula *)</span></span>
<span id="cb219-26"><a href="#cb219-26" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> mul xs = <span class="kw">function</span></span>
<span id="cb219-27"><a href="#cb219-27" aria-hidden="true" tabindex="-1"></a>  | LNil -&gt; LNil</span>
<span id="cb219-28"><a href="#cb219-28" aria-hidden="true" tabindex="-1"></a>  | LCons (y, ys) -&gt;</span>
<span id="cb219-29"><a href="#cb219-29" aria-hidden="true" tabindex="-1"></a>    add (scale y xs) (LCons (<span class="dv">0</span>., <span class="kw">lazy</span> (mul xs (<span class="dt">Lazy</span>.force ys))))</span>
<span id="cb219-30"><a href="#cb219-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-31"><a href="#cb219-31" aria-hidden="true" tabindex="-1"></a><span class="co">(* Division is like long division of polynomials *)</span></span>
<span id="cb219-32"><a href="#cb219-32" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> div xs ys =</span>
<span id="cb219-33"><a href="#cb219-33" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> xs, ys <span class="kw">with</span></span>
<span id="cb219-34"><a href="#cb219-34" aria-hidden="true" tabindex="-1"></a>  | LNil, _ -&gt; LNil</span>
<span id="cb219-35"><a href="#cb219-35" aria-hidden="true" tabindex="-1"></a>  | LCons (<span class="dv">0</span>., xs&#39;), LCons (<span class="dv">0</span>., ys&#39;) -&gt;   <span class="co">(* Both start with zero: cancel x *)</span></span>
<span id="cb219-36"><a href="#cb219-36" aria-hidden="true" tabindex="-1"></a>    div (<span class="dt">Lazy</span>.force xs&#39;) (<span class="dt">Lazy</span>.force ys&#39;)</span>
<span id="cb219-37"><a href="#cb219-37" aria-hidden="true" tabindex="-1"></a>  | LCons (x, xs&#39;), LCons (y, ys&#39;) -&gt;</span>
<span id="cb219-38"><a href="#cb219-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> q = x /. y <span class="kw">in</span>                     <span class="co">(* Leading coefficient of quotient *)</span></span>
<span id="cb219-39"><a href="#cb219-39" aria-hidden="true" tabindex="-1"></a>    LCons (q, <span class="kw">lazy</span> (div (sub (<span class="dt">Lazy</span>.force xs&#39;)</span>
<span id="cb219-40"><a href="#cb219-40" aria-hidden="true" tabindex="-1"></a>                                 (scale q (<span class="dt">Lazy</span>.force ys&#39;))) ys))</span>
<span id="cb219-41"><a href="#cb219-41" aria-hidden="true" tabindex="-1"></a>  | LCons _, LNil -&gt; <span class="dt">failwith</span> <span class="st">&quot;div: division by zero&quot;</span></span>
<span id="cb219-42"><a href="#cb219-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-43"><a href="#cb219-43" aria-hidden="true" tabindex="-1"></a><span class="co">(* Integration: integral of a_0 + a_1*x + a_2*x^2 + ...</span></span>
<span id="cb219-44"><a href="#cb219-44" aria-hidden="true" tabindex="-1"></a><span class="co">   is c + a_0*x + a_1*x^2/2 + a_2*x^3/3 + ... *)</span></span>
<span id="cb219-45"><a href="#cb219-45" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> integrate c xs =</span>
<span id="cb219-46"><a href="#cb219-46" aria-hidden="true" tabindex="-1"></a>  LCons (c, <span class="kw">lazy</span> (lmap (uncurry (/.)) (lzip (xs, posnums_f))))</span>
<span id="cb219-47"><a href="#cb219-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-48"><a href="#cb219-48" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ltail = <span class="kw">function</span></span>
<span id="cb219-49"><a href="#cb219-49" aria-hidden="true" tabindex="-1"></a>  | LNil -&gt; <span class="dt">invalid_arg</span> <span class="st">&quot;ltail&quot;</span></span>
<span id="cb219-50"><a href="#cb219-50" aria-hidden="true" tabindex="-1"></a>  | LCons (_, <span class="kw">lazy</span> tl) -&gt; tl</span>
<span id="cb219-51"><a href="#cb219-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-52"><a href="#cb219-52" aria-hidden="true" tabindex="-1"></a><span class="co">(* Differentiation: derivative of a_0 + a_1*x + a_2*x^2 + ...</span></span>
<span id="cb219-53"><a href="#cb219-53" aria-hidden="true" tabindex="-1"></a><span class="co">   is a_1 + 2*a_2*x + 3*a_3*x^2 + ... *)</span></span>
<span id="cb219-54"><a href="#cb219-54" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> differentiate xs =</span>
<span id="cb219-55"><a href="#cb219-55" aria-hidden="true" tabindex="-1"></a>  lmap (uncurry ( *.)) (lzip (ltail xs, posnums_f))</span></code></pre></div>
<h3 id="differential-equations">Differential Equations</h3>
<p>Now for the remarkable part: we can solve differential equations by
representing the solutions as power series! Consider the differential
equations for sine and cosine:</p>
<p><span class="math display">\frac{d \sin x}{dx} = \cos x, \quad
\frac{d \cos x}{dx} = -\sin x, \quad \sin 0 = 0, \quad \cos 0 =
1</span></p>
<p>We will solve the corresponding integral equations. Why integral
equations rather than differential equations? Because integration gives
us a way to build up the solution coefficient by coefficient, starting
from the initial conditions.</p>
<p>Our first attempt might be to define them by direct recursion:</p>
<pre><code>let (~-:) = lmap (fun x -&gt; -.x)  (* Unary negation for series *)

let rec sin = integrate (of_int 0) cos
and cos = integrate (of_int 1) (~-:sin)</code></pre>
<p>Unfortunately this fails with:
<code>Error: This kind of expression is not allowed as right-hand side of 'let rec'</code></p>
<p>The problem is that OCaml’s <code>let rec</code> requires the
right-hand side to be a “static” value – something like a function or a
data constructor applied to arguments. Even changing the second argument
of <code>integrate</code> to call-by-need does not help, because OCaml
cannot represent the values that <code>sin</code> and <code>cos</code>
refer to at the point of their definition.</p>
<p>The solution is to inline a bit of <code>integrate</code> so that
OCaml knows how to start building the recursive structure. We provide
the first coefficient explicitly:</p>
<div class="sourceCode" id="cb221"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb221-1"><a href="#cb221-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> integ xs = lmap (uncurry (/.)) (lzip (xs, posnums_f))</span>
<span id="cb221-2"><a href="#cb221-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb221-3"><a href="#cb221-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> <span class="dt">sin</span> = LCons (of_int <span class="dv">0</span>, <span class="kw">lazy</span> (integ <span class="dt">cos</span>))</span>
<span id="cb221-4"><a href="#cb221-4" aria-hidden="true" tabindex="-1"></a><span class="kw">and</span> <span class="dt">cos</span> = LCons (of_int <span class="dv">1</span>, <span class="kw">lazy</span> (integ (~-:<span class="dt">sin</span>)))</span></code></pre></div>
<p>Now the <code>let rec</code> works because each right-hand side is
just <code>LCons</code> applied to a value and a lazy expression. The
lazy expressions are not evaluated during the definition, so there is no
problem with the mutual recursion. When we force the lazy tails, the
computation proceeds coefficient by coefficient.</p>
<p>The complete example would look much more elegant in Haskell, where
all values are lazy by default – we would not need the explicit
<code>LCons</code> and <code>lazy</code> wrappers.</p>
<p>Although this approach is not limited to linear equations, equations
like Lotka-Volterra or Lorentz are not “solvable” this way – the
computed coefficients quickly grow instead of quickly falling, so the
series does not converge well.</p>
<p>Drawing functions work like in the previous lecture, but with open
curves:</p>
<div class="sourceCode" id="cb222"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb222-1"><a href="#cb222-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> plot_1D f ~w ~scale ~t_beg ~t_end =</span>
<span id="cb222-2"><a href="#cb222-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> dt = (t_end -. t_beg) /. of_int w <span class="kw">in</span></span>
<span id="cb222-3"><a href="#cb222-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Array</span>.init w (<span class="kw">fun</span> i -&gt;</span>
<span id="cb222-4"><a href="#cb222-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> y = lhorner (dt *. of_int i) f <span class="kw">in</span></span>
<span id="cb222-5"><a href="#cb222-5" aria-hidden="true" tabindex="-1"></a>    i, to_int (scale *. y))</span></code></pre></div>
<h2 id="arbitrary-precision-computation">7.5 Arbitrary Precision
Computation</h2>
<p>Putting together the power series computation with floating-point
numbers reveals drastic numerical errors for large <span
class="math inline">x</span>. There are two problems: 1. Floating-point
numbers have limited precision, so intermediate calculations accumulate
errors. 2. We break out of Horner method computations too quickly – the
stopping condition based on <code>epsilon_float</code> may stop before
we have enough precision.</p>
<figure>
<img src="sin_cos_1.png" style="width:70.0%"
alt="Numerical errors in sine/cosine computation" />
<figcaption aria-hidden="true">Numerical errors in sine/cosine
computation</figcaption>
</figure>
<p>For infinite precision on rational numbers we can use the
<code>nums</code> library, but it does not help by itself – the stopping
condition still causes us to truncate the computation prematurely.</p>
<p>The key insight is that instead of computing a single approximate
value, we should generate a <em>sequence of approximations</em> to the
power series limit at <span class="math inline">x</span>. Then we can
watch the sequence until it converges:</p>
<div class="sourceCode" id="cb223"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb223-1"><a href="#cb223-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> infhorner x l =</span>
<span id="cb223-2"><a href="#cb223-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> upd c sum =</span>
<span id="cb223-3"><a href="#cb223-3" aria-hidden="true" tabindex="-1"></a>    LCons (c, <span class="kw">lazy</span> (lmap (<span class="kw">fun</span> apx -&gt; c +. x *. apx)</span>
<span id="cb223-4"><a href="#cb223-4" aria-hidden="true" tabindex="-1"></a>                      (<span class="dt">Lazy</span>.force sum))) <span class="kw">in</span></span>
<span id="cb223-5"><a href="#cb223-5" aria-hidden="true" tabindex="-1"></a>  lazy_foldr upd l (LCons (of_int <span class="dv">0</span>, <span class="kw">lazy</span> LNil))</span></code></pre></div>
<p>The function <code>infhorner</code> returns a lazy list of partial
sums. Each element is a better approximation than the previous one. Now
we need to find where the series has converged to the precision we
need:</p>
<div class="sourceCode" id="cb224"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb224-1"><a href="#cb224-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> exact f = <span class="kw">function</span>         <span class="co">(* We arbitrarily decide that convergence is *)</span></span>
<span id="cb224-2"><a href="#cb224-2" aria-hidden="true" tabindex="-1"></a>  | LNil -&gt; <span class="kw">assert</span> <span class="kw">false</span>           <span class="co">(* when three consecutive results are the same. *)</span></span>
<span id="cb224-3"><a href="#cb224-3" aria-hidden="true" tabindex="-1"></a>  | LCons (x0, <span class="kw">lazy</span> (LCons (x1, <span class="kw">lazy</span> (LCons (x2, _)))))</span>
<span id="cb224-4"><a href="#cb224-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">when</span> f x0 = f x1 &amp;&amp; f x0 = f x2 -&gt; f x0</span>
<span id="cb224-5"><a href="#cb224-5" aria-hidden="true" tabindex="-1"></a>  | LCons (_, <span class="kw">lazy</span> tl) -&gt; exact f tl</span></code></pre></div>
<p>The function <code>exact</code> applies a test function
<code>f</code> to the approximations and stops when three consecutive
results give the same answer. Why three? Because some power series (like
those for sine and cosine) have alternating terms, and we want to be
sure the result has stabilized.</p>
<p>Draw the pixels of the graph at exact coordinates:</p>
<div class="sourceCode" id="cb225"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb225-1"><a href="#cb225-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> plot_1D f ~w ~h0 ~scale ~t_beg ~t_end =</span>
<span id="cb225-2"><a href="#cb225-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> dt = (t_end -. t_beg) /. of_int w <span class="kw">in</span></span>
<span id="cb225-3"><a href="#cb225-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> eval = exact (<span class="kw">fun</span> y -&gt; to_int (scale *. y)) <span class="kw">in</span></span>
<span id="cb225-4"><a href="#cb225-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Array</span>.init w (<span class="kw">fun</span> i -&gt;</span>
<span id="cb225-5"><a href="#cb225-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> y = infhorner (t_beg +. dt *. of_int i) f <span class="kw">in</span></span>
<span id="cb225-6"><a href="#cb225-6" aria-hidden="true" tabindex="-1"></a>    i, h0 + eval y)</span></code></pre></div>
<p>If a power series had every third term contributing (zeros in a
regular pattern), we would have to check more terms in the function
<code>exact</code>. We could also use a different stopping criterion
like <code>f x0 = f x1 &amp;&amp; not (x0 =. x1)</code> (stop when the
transformed values match but the raw values are still changing), similar
to what we did in <code>lhorner</code>.</p>
<h3 id="example-nuclear-chain-reaction">Example: Nuclear Chain
Reaction</h3>
<p>Consider a nuclear chain reaction where substance A decays into B,
which then decays into C. This is a classic problem in nuclear physics.
The differential equations are:</p>
<p><span class="math display">\frac{dN_A}{dt} = -\lambda_A N_A, \quad
\frac{dN_B}{dt} = \lambda_A N_A - \lambda_B N_B</span></p>
<p>Here <span class="math inline">\lambda_A</span> and <span
class="math inline">\lambda_B</span> are the decay constants, and <span
class="math inline">N_A</span>, <span class="math inline">N_B</span> are
the amounts of each substance. Substance A decays at a rate proportional
to its amount. Substance B is produced by A’s decay and itself decays
into C.</p>
<p>We can solve these equations using the same technique as for sine and
cosine:</p>
<pre><code>let n_chain ~nA0 ~nB0 ~lA ~lB =
  let rec nA =
    LCons (nA0, lazy (integ (~-.lA *:. nA)))
  and nB =
    LCons (nB0, lazy (integ (~-.lB *:. nB +: lA *:. nA))) in
  nA, nB</code></pre>
<figure>
<img src="chain_reaction.png" style="width:70.0%"
alt="Nuclear chain reaction: A decays into B decays into C" />
<figcaption aria-hidden="true">Nuclear chain reaction: A decays into B
decays into C</figcaption>
</figure>
<p>(See <a
href="http://en.wikipedia.org/wiki/Radioactive_decay#Chain-decay_processes">Radioactive
decay chain processes</a> for more information.)</p>
<h2 id="circular-data-structures-double-linked-lists">7.6 Circular Data
Structures: Double-Linked Lists</h2>
<p>Without delayed computation, the ability to define data structures
with referential cycles is very limited. In a strict language, you
cannot create a structure that refers to itself – the reference would
have to exist before the structure is created.</p>
<p>Double-linked lists are a classic example of structures with inherent
cycles. Even if the list itself is not circular (it has a beginning and
an end), each pair of adjacent nodes forms a cycle: node A points
forward to node B, and node B points backward to node A:</p>
<pre><code>+--------+     +--------+     +--------+     +--------+     +--------+
| DLNil  | &lt;-&gt; |   a1   | &lt;-&gt; |   a2   | &lt;-&gt; |   a3   | &lt;-&gt; | DLNil  |
+--------+     +--------+     +--------+     +--------+     +--------+</code></pre>
<p>To represent such structures in OCaml, we need to “break” the cycles
by making some links lazy. The backward links will be lazy, allowing us
to construct the structure one node at a time:</p>
<div class="sourceCode" id="cb228"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb228-1"><a href="#cb228-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a dllist =</span>
<span id="cb228-2"><a href="#cb228-2" aria-hidden="true" tabindex="-1"></a>  DLNil | DLCons <span class="kw">of</span> &#39;a dllist <span class="dt">Lazy</span>.t * &#39;a * &#39;a dllist</span></code></pre></div>
<p>The type has three components: a lazy backward link, the element, and
a (strict) forward link. The backward link is lazy because when we
create a node, its predecessor may not exist yet.</p>
<p>We can navigate forward through the list, dropping elements from the
front:</p>
<div class="sourceCode" id="cb229"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb229-1"><a href="#cb229-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> dldrop n l =</span>
<span id="cb229-2"><a href="#cb229-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb229-3"><a href="#cb229-3" aria-hidden="true" tabindex="-1"></a>    | DLCons (_, x, xs) <span class="kw">when</span> n &gt; <span class="dv">0</span> -&gt;</span>
<span id="cb229-4"><a href="#cb229-4" aria-hidden="true" tabindex="-1"></a>       dldrop (n<span class="dv">-1</span>) xs</span>
<span id="cb229-5"><a href="#cb229-5" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; l</span></code></pre></div>
<p>The tricky part is constructing a double-linked list from a regular
list. Each cell must know its predecessor, but the predecessor is
created first. We use a recursive lazy value to tie the knot:</p>
<div class="sourceCode" id="cb230"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb230-1"><a href="#cb230-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> dllist_of_list l =</span>
<span id="cb230-2"><a href="#cb230-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> dllist prev l =</span>
<span id="cb230-3"><a href="#cb230-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb230-4"><a href="#cb230-4" aria-hidden="true" tabindex="-1"></a>      | [] -&gt; DLNil</span>
<span id="cb230-5"><a href="#cb230-5" aria-hidden="true" tabindex="-1"></a>      | x::xs -&gt;</span>
<span id="cb230-6"><a href="#cb230-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">rec</span> cell =</span>
<span id="cb230-7"><a href="#cb230-7" aria-hidden="true" tabindex="-1"></a>          <span class="kw">lazy</span> (DLCons (prev, x, dllist cell xs)) <span class="kw">in</span></span>
<span id="cb230-8"><a href="#cb230-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Lazy</span>.force cell <span class="kw">in</span></span>
<span id="cb230-9"><a href="#cb230-9" aria-hidden="true" tabindex="-1"></a>  dllist (<span class="kw">lazy</span> DLNil) l</span></code></pre></div>
<p>The key trick is
<code>let rec cell = lazy (DLCons (prev, x, dllist cell xs))</code>. The
lazy value <code>cell</code> refers to itself! When we force
<code>cell</code>, it creates a <code>DLCons</code> node whose forward
link (<code>dllist cell xs</code>) receives <code>cell</code> as the
predecessor for the next node. This is only possible because the
backward link is lazy – when we create the next node, we do not need to
evaluate <code>cell</code>, just store a reference to it.</p>
<p>Taking elements going forward is straightforward:</p>
<div class="sourceCode" id="cb231"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb231-1"><a href="#cb231-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> dltake n l =</span>
<span id="cb231-2"><a href="#cb231-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb231-3"><a href="#cb231-3" aria-hidden="true" tabindex="-1"></a>    | DLCons (_, x, xs) <span class="kw">when</span> n &gt; <span class="dv">0</span> -&gt;</span>
<span id="cb231-4"><a href="#cb231-4" aria-hidden="true" tabindex="-1"></a>       x :: dltake (n<span class="dv">-1</span>) xs</span>
<span id="cb231-5"><a href="#cb231-5" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; []</span></code></pre></div>
<p>Taking elements going backward shows the power of the double-linked
structure – we can traverse in either direction:</p>
<div class="sourceCode" id="cb232"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb232-1"><a href="#cb232-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> dlbackwards n l =</span>
<span id="cb232-2"><a href="#cb232-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb232-3"><a href="#cb232-3" aria-hidden="true" tabindex="-1"></a>    | DLCons (<span class="kw">lazy</span> xs, x, _) <span class="kw">when</span> n &gt; <span class="dv">0</span> -&gt;</span>
<span id="cb232-4"><a href="#cb232-4" aria-hidden="true" tabindex="-1"></a>      x :: dlbackwards (n<span class="dv">-1</span>) xs</span>
<span id="cb232-5"><a href="#cb232-5" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; []</span></code></pre></div>
<h2 id="input-output-streams">7.7 Input-Output Streams</h2>
<p>Let us return to streams and generalize them. The stream type we
defined earlier used a throwaway argument to make a suspension:</p>
<div class="sourceCode" id="cb233"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb233-1"><a href="#cb233-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a stream = SNil | SCons <span class="kw">of</span> &#39;a * (<span class="dt">unit</span> -&gt; &#39;a stream)</span></code></pre></div>
<p>The <code>unit</code> argument serves only to delay computation. But
what if we take a <em>real</em> argument – one that provides input to
the stream? This leads to a more powerful abstraction:</p>
<div class="sourceCode" id="cb234"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb234-1"><a href="#cb234-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (&#39;a, &#39;b) iostream =</span>
<span id="cb234-2"><a href="#cb234-2" aria-hidden="true" tabindex="-1"></a>  EOS | More <span class="kw">of</span> &#39;b * (&#39;a -&gt; (&#39;a, &#39;b) iostream)</span></code></pre></div>
<p>This is an <em>interactive</em> stream: it produces an output value
of type <code>'b</code>, and when given an input value of type
<code>'a</code>, produces the rest of the stream. The stream alternates
between producing output and consuming input.</p>
<div class="sourceCode" id="cb235"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb235-1"><a href="#cb235-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a istream = (<span class="dt">unit</span>, &#39;a) iostream  <span class="co">(* Input stream produces output when &quot;asked&quot;. *)</span></span>
<span id="cb235-2"><a href="#cb235-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a ostream = (&#39;a, <span class="dt">unit</span>) iostream  <span class="co">(* Output stream consumes provided input. *)</span></span></code></pre></div>
<p>The terminology can be confusing. An “input stream”
(<code>istream</code>) is one that produces output when asked (like
reading from a file). An “output stream” (<code>ostream</code>) is one
that consumes input (like writing to a file). The confusion arises from
adapting the <em>input file / output file</em> terminology.</p>
<p>The power of this abstraction is that we can compose streams,
directing the output of one to the input of another:</p>
<div class="sourceCode" id="cb236"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb236-1"><a href="#cb236-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> compose sf sg =</span>
<span id="cb236-2"><a href="#cb236-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> sg <span class="kw">with</span></span>
<span id="cb236-3"><a href="#cb236-3" aria-hidden="true" tabindex="-1"></a>  | EOS -&gt; EOS                              <span class="co">(* No more output from sg. *)</span></span>
<span id="cb236-4"><a href="#cb236-4" aria-hidden="true" tabindex="-1"></a>  | More (z, g) -&gt;</span>
<span id="cb236-5"><a href="#cb236-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> sf <span class="kw">with</span></span>
<span id="cb236-6"><a href="#cb236-6" aria-hidden="true" tabindex="-1"></a>    | EOS -&gt; More (z, <span class="kw">fun</span> _ -&gt; EOS)         <span class="co">(* No more input from sf. *)</span></span>
<span id="cb236-7"><a href="#cb236-7" aria-hidden="true" tabindex="-1"></a>    | More (y, f) -&gt;</span>
<span id="cb236-8"><a href="#cb236-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> update x = compose (f x) (g y) <span class="kw">in</span> <span class="co">(* Feed sf&#39;s output y to sg. *)</span></span>
<span id="cb236-9"><a href="#cb236-9" aria-hidden="true" tabindex="-1"></a>      More (z, update)</span></code></pre></div>
<p>Think of it as connecting boxes with wires: every box has one
incoming wire and one outgoing wire. When composing <code>sf</code> and
<code>sg</code>, the output of <code>sf</code> becomes the input of
<code>sg</code>. Notice that the output stream is “ahead” of the input
stream – <code>sg</code> can produce its first output <code>z</code>
before <code>sf</code> has produced anything.</p>
<h2 id="pipes">7.8 Pipes</h2>
<p>The <code>iostream</code> type has a limitation: it must alternate
strictly between producing output and consuming input. In many
real-world scenarios, we need more flexibility: - A transformation might
consume several inputs before producing a single output (like computing
an average). - A transformation might produce several outputs from a
single input (like splitting a string). - A transformation might produce
output without needing any input (like a constant source).</p>
<p>Following the Haskell tradition, we call this more flexible data
structure a <code>pipe</code>:</p>
<div class="sourceCode" id="cb237"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb237-1"><a href="#cb237-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (&#39;a, &#39;b) pipe =</span>
<span id="cb237-2"><a href="#cb237-2" aria-hidden="true" tabindex="-1"></a>  EOP                                       <span class="co">(* End of pipe -- done processing *)</span></span>
<span id="cb237-3"><a href="#cb237-3" aria-hidden="true" tabindex="-1"></a>| Yield <span class="kw">of</span> &#39;b * (&#39;a, &#39;b) pipe               <span class="co">(* Produce output b, then continue *)</span></span>
<span id="cb237-4"><a href="#cb237-4" aria-hidden="true" tabindex="-1"></a>| Await <span class="kw">of</span> (&#39;a -&gt; (&#39;a, &#39;b) pipe)            <span class="co">(* Wait for input a, then continue *)</span></span></code></pre></div>
<p>A pipe can be in one of three states: finished (<code>EOP</code>),
ready to produce output (<code>Yield</code>), or waiting for input
(<code>Await</code>). The key insight is that <code>Yield</code>
includes the continuation pipe directly (not wrapped in a function), so
multiple outputs can be produced in sequence without requiring input.
For incremental processing where outputs should be lazy, you would
change <code>Yield</code> to hold a lazy pipe instead.</p>
<p>Again, we can specialize to input-only and output-only pipes:</p>
<div class="sourceCode" id="cb238"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb238-1"><a href="#cb238-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a ipipe = (<span class="dt">unit</span>, &#39;a) pipe</span>
<span id="cb238-2"><a href="#cb238-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> void</span>
<span id="cb238-3"><a href="#cb238-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a opipe = (&#39;a, void) pipe</span></code></pre></div>
<p>Why <code>void</code> rather than <code>unit</code>, and why only for
<code>opipe</code>? Because an output pipe never yields values – if it
used <code>unit</code> as the output type, it could still yield
<code>()</code> values. But <code>void</code> is an abstract type with
no values, making it impossible for an <code>opipe</code> to yield
anything. This is a type-level guarantee that output pipes only
consume.</p>
<h3 id="pipe-composition">Pipe Composition</h3>
<p>Composition of pipes is like “concatenating them in space” or
connecting boxes. We plug the output of pipe <code>pf</code> into the
input of pipe <code>pg</code>:</p>
<div class="sourceCode" id="cb239"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb239-1"><a href="#cb239-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> compose pf pg =</span>
<span id="cb239-2"><a href="#cb239-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> pg <span class="kw">with</span></span>
<span id="cb239-3"><a href="#cb239-3" aria-hidden="true" tabindex="-1"></a>  | EOP -&gt; EOP                            <span class="co">(* pg is done -- composition is done. *)</span></span>
<span id="cb239-4"><a href="#cb239-4" aria-hidden="true" tabindex="-1"></a>  | Yield (z, pg&#39;) -&gt; Yield (z, compose pf pg&#39;)  <span class="co">(* pg has output -- pass it through. *)</span></span>
<span id="cb239-5"><a href="#cb239-5" aria-hidden="true" tabindex="-1"></a>  | Await g -&gt;                            <span class="co">(* pg needs input -- try to get it from pf. *)</span></span>
<span id="cb239-6"><a href="#cb239-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> pf <span class="kw">with</span></span>
<span id="cb239-7"><a href="#cb239-7" aria-hidden="true" tabindex="-1"></a>    | EOP -&gt; EOP                          <span class="co">(* pf is done -- no more input for pg. *)</span></span>
<span id="cb239-8"><a href="#cb239-8" aria-hidden="true" tabindex="-1"></a>    | Yield (y, pf&#39;) -&gt; compose pf&#39; (g y)  <span class="co">(* pf has output -- feed it to pg. *)</span></span>
<span id="cb239-9"><a href="#cb239-9" aria-hidden="true" tabindex="-1"></a>    | Await f -&gt;                          <span class="co">(* Both waiting -- wait for external input. *)</span></span>
<span id="cb239-10"><a href="#cb239-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> update x = compose (f x) pg <span class="kw">in</span></span>
<span id="cb239-11"><a href="#cb239-11" aria-hidden="true" tabindex="-1"></a>      Await update</span>
<span id="cb239-12"><a href="#cb239-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb239-13"><a href="#cb239-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (&gt;-&gt;) pf pg = compose pf pg</span></code></pre></div>
<p>The <code>&gt;-&gt;</code> operator lets us chain pipes together like
Unix pipes: <code>source &gt;-&gt; transform &gt;-&gt; sink</code>.</p>
<p>Appending pipes means “concatenating them in time” rather than in
space. When the first pipe finishes, we continue with the second:</p>
<div class="sourceCode" id="cb240"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb240-1"><a href="#cb240-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> append pf pg =</span>
<span id="cb240-2"><a href="#cb240-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> pf <span class="kw">with</span></span>
<span id="cb240-3"><a href="#cb240-3" aria-hidden="true" tabindex="-1"></a>  | EOP -&gt; pg                               <span class="co">(* pf is exhausted -- continue with pg. *)</span></span>
<span id="cb240-4"><a href="#cb240-4" aria-hidden="true" tabindex="-1"></a>  | Yield (z, pf&#39;) -&gt; Yield (z, append pf&#39; pg)  <span class="co">(* pf has output -- pass it through. *)</span></span>
<span id="cb240-5"><a href="#cb240-5" aria-hidden="true" tabindex="-1"></a>  | Await f -&gt;                              <span class="co">(* pf awaits input -- pass it through. *)</span></span>
<span id="cb240-6"><a href="#cb240-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> update x = append (f x) pg <span class="kw">in</span></span>
<span id="cb240-7"><a href="#cb240-7" aria-hidden="true" tabindex="-1"></a>    Await update</span></code></pre></div>
<p>We can also append a list of ready results in front of a pipe. This
is useful for producing multiple outputs at once:</p>
<div class="sourceCode" id="cb241"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb241-1"><a href="#cb241-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> yield_all l tail =</span>
<span id="cb241-2"><a href="#cb241-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb241-3"><a href="#cb241-3" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; tail</span>
<span id="cb241-4"><a href="#cb241-4" aria-hidden="true" tabindex="-1"></a>  | x::xs -&gt; Yield (x, yield_all xs tail)</span></code></pre></div>
<p>Finally, the <code>iterate</code> function creates a pipe that
repeatedly applies a side-effecting function to its inputs. This is
<strong>not functional</strong> (it performs side effects), but it is
useful for output:</p>
<div class="sourceCode" id="cb242"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb242-1"><a href="#cb242-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> iterate f : &#39;a opipe =</span>
<span id="cb242-2"><a href="#cb242-2" aria-hidden="true" tabindex="-1"></a>  Await (<span class="kw">fun</span> x -&gt; <span class="kw">let</span> () = f x <span class="kw">in</span> iterate f)</span></code></pre></div>
<h2 id="example-pretty-printing">7.9 Example: Pretty-Printing</h2>
<p>Now let us apply pipes to a substantial example: pretty-printing. The
goal is to print a hierarchically organized document with a limited line
width. When a group of text fits on the current line, we keep it
together; when it does not fit, we break it across multiple lines.</p>
<div class="sourceCode" id="cb243"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb243-1"><a href="#cb243-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> doc =</span>
<span id="cb243-2"><a href="#cb243-2" aria-hidden="true" tabindex="-1"></a>  Text <span class="kw">of</span> <span class="dt">string</span> | Line | Cat <span class="kw">of</span> doc * doc | Group <span class="kw">of</span> doc</span></code></pre></div>
<p>The document type has four constructors: - <code>Text s</code> –
literal text - <code>Line</code> – a potential line break (rendered as a
space if the group fits, or a newline if it does not) -
<code>Cat (d1, d2)</code> – concatenation - <code>Group d</code> – a
group that should be kept together if possible</p>
<p>Some convenient operators for building documents:</p>
<div class="sourceCode" id="cb244"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb244-1"><a href="#cb244-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (++) d1 d2 = Cat (d1, Cat (Line, d2))</span>
<span id="cb244-2"><a href="#cb244-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (!) s = Text s</span>
<span id="cb244-3"><a href="#cb244-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb244-4"><a href="#cb244-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> test_doc =</span>
<span id="cb244-5"><a href="#cb244-5" aria-hidden="true" tabindex="-1"></a>  Group (!<span class="st">&quot;Document&quot;</span> ++</span>
<span id="cb244-6"><a href="#cb244-6" aria-hidden="true" tabindex="-1"></a>            Group (!<span class="st">&quot;First part&quot;</span> ++ !<span class="st">&quot;Second part&quot;</span>))</span></code></pre></div>
<p>The pretty-printer should produce different outputs depending on the
available width:</p>
<pre><code># let () = print_endline (pretty 30 test_doc);;
Document
First part Second part

# let () = print_endline (pretty 20 test_doc);;
Document
First part
Second part

# let () = print_endline (pretty 60 test_doc);;
Document First part Second part</code></pre>
<h3 id="straightforward-solution">Straightforward Solution</h3>
<p>Before diving into pipes, let us implement a straightforward
recursive solution:</p>
<div class="sourceCode" id="cb246"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb246-1"><a href="#cb246-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pretty w d =               <span class="co">(* Allowed width of line w. *)</span></span>
<span id="cb246-2"><a href="#cb246-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> width = <span class="kw">function</span>     <span class="co">(* Compute total length of subdocument. *)</span></span>
<span id="cb246-3"><a href="#cb246-3" aria-hidden="true" tabindex="-1"></a>    | Text z -&gt; <span class="dt">String</span>.length z</span>
<span id="cb246-4"><a href="#cb246-4" aria-hidden="true" tabindex="-1"></a>    | Line -&gt; <span class="dv">1</span>                <span class="co">(* A line break takes 1 character (space or newline). *)</span></span>
<span id="cb246-5"><a href="#cb246-5" aria-hidden="true" tabindex="-1"></a>    | Cat (d1, d2) -&gt; width d1 + width d2</span>
<span id="cb246-6"><a href="#cb246-6" aria-hidden="true" tabindex="-1"></a>    | Group d -&gt; width d <span class="kw">in</span></span>
<span id="cb246-7"><a href="#cb246-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> <span class="dt">format</span> f r = <span class="kw">function</span>  <span class="co">(* f: flatten (no breaks)? r: remaining space. *)</span></span>
<span id="cb246-8"><a href="#cb246-8" aria-hidden="true" tabindex="-1"></a>    | Text z -&gt; z, r - <span class="dt">String</span>.length z</span>
<span id="cb246-9"><a href="#cb246-9" aria-hidden="true" tabindex="-1"></a>    | Line <span class="kw">when</span> f -&gt; <span class="st">&quot; &quot;</span>, r<span class="dv">-1</span>  <span class="co">(* Flatten mode: render as space. *)</span></span>
<span id="cb246-10"><a href="#cb246-10" aria-hidden="true" tabindex="-1"></a>    | Line -&gt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, w          <span class="co">(* Break mode: newline, reset remaining to full width. *)</span></span>
<span id="cb246-11"><a href="#cb246-11" aria-hidden="true" tabindex="-1"></a>    | Cat (d1, d2) -&gt;</span>
<span id="cb246-12"><a href="#cb246-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> s1, r = <span class="dt">format</span> f r d1 <span class="kw">in</span></span>
<span id="cb246-13"><a href="#cb246-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> s2, r = <span class="dt">format</span> f r d2 <span class="kw">in</span></span>
<span id="cb246-14"><a href="#cb246-14" aria-hidden="true" tabindex="-1"></a>      s1 ^ s2, r</span>
<span id="cb246-15"><a href="#cb246-15" aria-hidden="true" tabindex="-1"></a>    | Group d -&gt; <span class="dt">format</span> (f || width d &lt;= r) r d  <span class="co">(* Flatten if group fits. *)</span></span>
<span id="cb246-16"><a href="#cb246-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb246-17"><a href="#cb246-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">fst</span> (<span class="dt">format</span> <span class="kw">false</span> w d)       <span class="co">(* Start outside any group (not flattening). *)</span></span></code></pre></div>
<p>The <code>format</code> function takes a boolean <code>f</code> (are
we in “flatten” mode?) and the remaining space <code>r</code>. When we
enter a <code>Group</code>, we check if the whole group fits in the
remaining space. If so, we format it in flatten mode (all
<code>Line</code>s become spaces).</p>
<h3 id="stream-based-solution">Stream-Based Solution</h3>
<p>The straightforward solution works, but it has a problem: for each
group, we compute <code>width</code> by traversing the entire subtree,
potentially doing redundant work. The stream-based solution processes
the document incrementally, computing positions as we go.</p>
<p>First, we define a type for document elements that can carry
annotations:</p>
<div class="sourceCode" id="cb247"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb247-1"><a href="#cb247-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (&#39;a, &#39;b) doc_e =          <span class="co">(* Annotated nodes, special for group beginning. *)</span></span>
<span id="cb247-2"><a href="#cb247-2" aria-hidden="true" tabindex="-1"></a>  TE <span class="kw">of</span> &#39;a * <span class="dt">string</span> | LE <span class="kw">of</span> &#39;a | GBeg <span class="kw">of</span> &#39;b | GEnd <span class="kw">of</span> &#39;a</span></code></pre></div>
<p>The type parameters <code>'a</code> and <code>'b</code> allow
different annotations for different elements. <code>GBeg</code> (group
beginning) has a different type because it will eventually carry the end
position of the group.</p>
<p>Normalize a subdocument to remove empty groups:</p>
<div class="sourceCode" id="cb248"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb248-1"><a href="#cb248-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> norm = <span class="kw">function</span></span>
<span id="cb248-2"><a href="#cb248-2" aria-hidden="true" tabindex="-1"></a>  | Group d -&gt; norm d</span>
<span id="cb248-3"><a href="#cb248-3" aria-hidden="true" tabindex="-1"></a>  | Text <span class="st">&quot;&quot;</span> -&gt; <span class="dt">None</span></span>
<span id="cb248-4"><a href="#cb248-4" aria-hidden="true" tabindex="-1"></a>  | Cat (Text <span class="st">&quot;&quot;</span>, d) -&gt; norm d</span>
<span id="cb248-5"><a href="#cb248-5" aria-hidden="true" tabindex="-1"></a>  | d -&gt; <span class="dt">Some</span> d</span></code></pre></div>
<p>Generate the stream of document elements by infix traversal:</p>
<div class="sourceCode" id="cb249"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb249-1"><a href="#cb249-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> gen = <span class="kw">function</span></span>
<span id="cb249-2"><a href="#cb249-2" aria-hidden="true" tabindex="-1"></a>  | Text z -&gt; Yield (TE ((),z), EOP)</span>
<span id="cb249-3"><a href="#cb249-3" aria-hidden="true" tabindex="-1"></a>  | Line -&gt; Yield (LE (), EOP)</span>
<span id="cb249-4"><a href="#cb249-4" aria-hidden="true" tabindex="-1"></a>  | Cat (d1, d2) -&gt; append (gen d1) (gen d2)</span>
<span id="cb249-5"><a href="#cb249-5" aria-hidden="true" tabindex="-1"></a>  | Group d -&gt;</span>
<span id="cb249-6"><a href="#cb249-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> norm d <span class="kw">with</span></span>
<span id="cb249-7"><a href="#cb249-7" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">None</span> -&gt; EOP</span>
<span id="cb249-8"><a href="#cb249-8" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> d -&gt;</span>
<span id="cb249-9"><a href="#cb249-9" aria-hidden="true" tabindex="-1"></a>      Yield (GBeg (),</span>
<span id="cb249-10"><a href="#cb249-10" aria-hidden="true" tabindex="-1"></a>             append (gen d) (Yield (GEnd (), EOP)))</span></code></pre></div>
<p>The next pipe computes the position (character count from the
beginning) of each element:</p>
<div class="sourceCode" id="cb250"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb250-1"><a href="#cb250-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> docpos curpos =</span>
<span id="cb250-2"><a href="#cb250-2" aria-hidden="true" tabindex="-1"></a>  Await (<span class="kw">function</span>                   <span class="co">(* Input from a doc_e pipe, *)</span></span>
<span id="cb250-3"><a href="#cb250-3" aria-hidden="true" tabindex="-1"></a>  | TE (_, z) -&gt;</span>
<span id="cb250-4"><a href="#cb250-4" aria-hidden="true" tabindex="-1"></a>    Yield (TE (curpos, z),          <span class="co">(* output doc_e annotated with position. *)</span></span>
<span id="cb250-5"><a href="#cb250-5" aria-hidden="true" tabindex="-1"></a>           docpos (curpos + <span class="dt">String</span>.length z))</span>
<span id="cb250-6"><a href="#cb250-6" aria-hidden="true" tabindex="-1"></a>  | LE _ -&gt;                         <span class="co">(* Spaces and line breaks: 1 character. *)</span></span>
<span id="cb250-7"><a href="#cb250-7" aria-hidden="true" tabindex="-1"></a>    Yield (LE curpos, docpos (curpos + <span class="dv">1</span>))</span>
<span id="cb250-8"><a href="#cb250-8" aria-hidden="true" tabindex="-1"></a>  | GBeg _ -&gt;                       <span class="co">(* Groups themselves have no width. *)</span></span>
<span id="cb250-9"><a href="#cb250-9" aria-hidden="true" tabindex="-1"></a>    Yield (GBeg curpos, docpos curpos)</span>
<span id="cb250-10"><a href="#cb250-10" aria-hidden="true" tabindex="-1"></a>  | GEnd _ -&gt;</span>
<span id="cb250-11"><a href="#cb250-11" aria-hidden="true" tabindex="-1"></a>    Yield (GEnd curpos, docpos curpos))</span>
<span id="cb250-12"><a href="#cb250-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-13"><a href="#cb250-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> docpos = docpos <span class="dv">0</span>               <span class="co">(* The whole document starts at position 0. *)</span></span></code></pre></div>
<p>Now comes the tricky part. We want to annotate each <code>GBeg</code>
with the position where the group <em>ends</em>, so we can decide
whether the group fits on the line. But we see <code>GBeg</code> before
we see <code>GEnd</code>! We need to buffer elements until we see the
end of each group:</p>
<div class="sourceCode" id="cb251"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb251-1"><a href="#cb251-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> grends grstack =</span>
<span id="cb251-2"><a href="#cb251-2" aria-hidden="true" tabindex="-1"></a>  Await (<span class="kw">function</span></span>
<span id="cb251-3"><a href="#cb251-3" aria-hidden="true" tabindex="-1"></a>  | TE _ | LE _ <span class="kw">as</span> e -&gt;</span>
<span id="cb251-4"><a href="#cb251-4" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">match</span> grstack <span class="kw">with</span></span>
<span id="cb251-5"><a href="#cb251-5" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; Yield (e, grends [])         <span class="co">(* No groups waiting -- yield immediately. *)</span></span>
<span id="cb251-6"><a href="#cb251-6" aria-hidden="true" tabindex="-1"></a>    | gr::grs -&gt; grends ((e::gr)::grs))  <span class="co">(* Inside a group -- buffer the element. *)</span></span>
<span id="cb251-7"><a href="#cb251-7" aria-hidden="true" tabindex="-1"></a>  | GBeg _ -&gt; grends ([]::grstack)       <span class="co">(* Start a new group: push empty buffer. *)</span></span>
<span id="cb251-8"><a href="#cb251-8" aria-hidden="true" tabindex="-1"></a>  | GEnd endp -&gt;</span>
<span id="cb251-9"><a href="#cb251-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> grstack <span class="kw">with</span>                   <span class="co">(* End the group on top of stack. *)</span></span>
<span id="cb251-10"><a href="#cb251-10" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; <span class="dt">failwith</span> <span class="st">&quot;grends: unmatched group end marker&quot;</span></span>
<span id="cb251-11"><a href="#cb251-11" aria-hidden="true" tabindex="-1"></a>    | [gr] -&gt;                          <span class="co">(* Outermost group -- yield everything now. *)</span></span>
<span id="cb251-12"><a href="#cb251-12" aria-hidden="true" tabindex="-1"></a>      yield_all</span>
<span id="cb251-13"><a href="#cb251-13" aria-hidden="true" tabindex="-1"></a>        (GBeg endp::<span class="dt">List</span>.rev (GEnd endp::gr))  <span class="co">(* Annotate GBeg with end position. *)</span></span>
<span id="cb251-14"><a href="#cb251-14" aria-hidden="true" tabindex="-1"></a>        (grends [])</span>
<span id="cb251-15"><a href="#cb251-15" aria-hidden="true" tabindex="-1"></a>    | gr::par::grs -&gt;                    <span class="co">(* Nested group -- add to parent&#39;s buffer. *)</span></span>
<span id="cb251-16"><a href="#cb251-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> par = GEnd endp::gr @ [GBeg endp] @ par <span class="kw">in</span></span>
<span id="cb251-17"><a href="#cb251-17" aria-hidden="true" tabindex="-1"></a>      grends (par::grs))               <span class="co">(* Could use catenable lists for efficiency. *)</span></span></code></pre></div>
<p>This works, but it has a problem: we wait until the entire group is
processed before yielding anything. For large groups (or groups that
exceed the line width), this is wasteful. We can optimize by flushing
the buffer when a group clearly exceeds the line width – if we know a
group will not fit, there is no need to remember where it ends:</p>
<div class="sourceCode" id="cb252"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb252-1"><a href="#cb252-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> grp_pos = Pos <span class="kw">of</span> <span class="dt">int</span> | Too_far</span>
<span id="cb252-2"><a href="#cb252-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb252-3"><a href="#cb252-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> rev_concat_map ~prep f l =</span>
<span id="cb252-4"><a href="#cb252-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> cmap_f accu = <span class="kw">function</span></span>
<span id="cb252-5"><a href="#cb252-5" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; accu</span>
<span id="cb252-6"><a href="#cb252-6" aria-hidden="true" tabindex="-1"></a>    | a::l -&gt; cmap_f (prep::<span class="dt">List</span>.rev_append (f a) accu) l <span class="kw">in</span></span>
<span id="cb252-7"><a href="#cb252-7" aria-hidden="true" tabindex="-1"></a>  cmap_f [] l</span>
<span id="cb252-8"><a href="#cb252-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb252-9"><a href="#cb252-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> grends w grstack =</span>
<span id="cb252-10"><a href="#cb252-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="dt">flush</span> tail =                   <span class="co">(* When a group exceeds width w, *)</span></span>
<span id="cb252-11"><a href="#cb252-11" aria-hidden="true" tabindex="-1"></a>    yield_all                     <span class="co">(* flush the stack -- yield everything buffered. *)</span></span>
<span id="cb252-12"><a href="#cb252-12" aria-hidden="true" tabindex="-1"></a>      (rev_concat_map ~prep:(GBeg Too_far) <span class="dt">snd</span> grstack)</span>
<span id="cb252-13"><a href="#cb252-13" aria-hidden="true" tabindex="-1"></a>      tail <span class="kw">in</span>                        <span class="co">(* Mark flushed groups as Too_far. *)</span></span>
<span id="cb252-14"><a href="#cb252-14" aria-hidden="true" tabindex="-1"></a>  Await (<span class="kw">function</span></span>
<span id="cb252-15"><a href="#cb252-15" aria-hidden="true" tabindex="-1"></a>  | TE (curp, _) | LE curp <span class="kw">as</span> e -&gt;</span>
<span id="cb252-16"><a href="#cb252-16" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">match</span> grstack <span class="kw">with</span>              <span class="co">(* Track beginning position of each group. *)</span></span>
<span id="cb252-17"><a href="#cb252-17" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; Yield (e, grends w [])   <span class="co">(* No groups -- yield immediately. *)</span></span>
<span id="cb252-18"><a href="#cb252-18" aria-hidden="true" tabindex="-1"></a>    | (begp, _)::_ <span class="kw">when</span> curp-begp &gt; w -&gt;</span>
<span id="cb252-19"><a href="#cb252-19" aria-hidden="true" tabindex="-1"></a>      <span class="dt">flush</span> (Yield (e, grends w []))    <span class="co">(* Group too wide -- flush and yield. *)</span></span>
<span id="cb252-20"><a href="#cb252-20" aria-hidden="true" tabindex="-1"></a>    | (begp, gr)::grs -&gt; grends w ((begp, e::gr)::grs))  <span class="co">(* Buffer element. *)</span></span>
<span id="cb252-21"><a href="#cb252-21" aria-hidden="true" tabindex="-1"></a>  | GBeg begp -&gt; grends w ((begp, [])::grstack)  <span class="co">(* New group: remember start pos. *)</span></span>
<span id="cb252-22"><a href="#cb252-22" aria-hidden="true" tabindex="-1"></a>  | GEnd endp <span class="kw">as</span> e -&gt;</span>
<span id="cb252-23"><a href="#cb252-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> grstack <span class="kw">with</span>               <span class="co">(* No longer fail when stack is empty -- *)</span></span>
<span id="cb252-24"><a href="#cb252-24" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; Yield (e, grends w [])   <span class="co">(* could have been flushed earlier. *)</span></span>
<span id="cb252-25"><a href="#cb252-25" aria-hidden="true" tabindex="-1"></a>    | (begp, _)::_ <span class="kw">when</span> endp-begp &gt; w -&gt;</span>
<span id="cb252-26"><a href="#cb252-26" aria-hidden="true" tabindex="-1"></a>      <span class="dt">flush</span> (Yield (e, grends w []))    <span class="co">(* Group exceeded width -- flush. *)</span></span>
<span id="cb252-27"><a href="#cb252-27" aria-hidden="true" tabindex="-1"></a>    | [_, gr] -&gt;                     <span class="co">(* Group fits -- annotate with end position. *)</span></span>
<span id="cb252-28"><a href="#cb252-28" aria-hidden="true" tabindex="-1"></a>      yield_all</span>
<span id="cb252-29"><a href="#cb252-29" aria-hidden="true" tabindex="-1"></a>        (GBeg (Pos endp)::<span class="dt">List</span>.rev (GEnd endp::gr))</span>
<span id="cb252-30"><a href="#cb252-30" aria-hidden="true" tabindex="-1"></a>        (grends w [])</span>
<span id="cb252-31"><a href="#cb252-31" aria-hidden="true" tabindex="-1"></a>    | (_, gr)::(par_begp, par)::grs -&gt;  <span class="co">(* Nested group fits -- add to parent. *)</span></span>
<span id="cb252-32"><a href="#cb252-32" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> par =</span>
<span id="cb252-33"><a href="#cb252-33" aria-hidden="true" tabindex="-1"></a>        GEnd endp::gr @ [GBeg (Pos endp)] @ par <span class="kw">in</span></span>
<span id="cb252-34"><a href="#cb252-34" aria-hidden="true" tabindex="-1"></a>      grends w ((par_begp, par)::grs))</span>
<span id="cb252-35"><a href="#cb252-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb252-36"><a href="#cb252-36" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> grends w = grends w []           <span class="co">(* Initial stack is empty. *)</span></span></code></pre></div>
<p>Finally, the <code>format</code> pipe produces the resulting stream
of strings. It maintains a stack of booleans indicating which groups are
being “flattened” (rendered inline), and the position where the current
line would end:</p>
<div class="sourceCode" id="cb253"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb253-1"><a href="#cb253-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> <span class="dt">format</span> w (inline, endlpos <span class="kw">as</span> st) = <span class="co">(* inline: stack of &quot;flatten this group?&quot; *)</span></span>
<span id="cb253-2"><a href="#cb253-2" aria-hidden="true" tabindex="-1"></a>  Await (<span class="kw">function</span>                          <span class="co">(* endlpos: position where line ends *)</span></span>
<span id="cb253-3"><a href="#cb253-3" aria-hidden="true" tabindex="-1"></a>  | TE (_, z) -&gt; Yield (z, <span class="dt">format</span> w st)    <span class="co">(* Text: output directly. *)</span></span>
<span id="cb253-4"><a href="#cb253-4" aria-hidden="true" tabindex="-1"></a>  | LE p <span class="kw">when</span> <span class="dt">List</span>.hd inline -&gt;</span>
<span id="cb253-5"><a href="#cb253-5" aria-hidden="true" tabindex="-1"></a>    Yield (<span class="st">&quot; &quot;</span>, <span class="dt">format</span> w st)               <span class="co">(* In flatten mode: line break -&gt; space. *)</span></span>
<span id="cb253-6"><a href="#cb253-6" aria-hidden="true" tabindex="-1"></a>  | LE p -&gt; Yield (<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="dt">format</span> w (inline, p+w))  <span class="co">(* Break mode: update endlpos. *)</span></span>
<span id="cb253-7"><a href="#cb253-7" aria-hidden="true" tabindex="-1"></a>  | GBeg Too_far -&gt;                        <span class="co">(* Group too wide -- don&#39;t flatten. *)</span></span>
<span id="cb253-8"><a href="#cb253-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">format</span> w (<span class="kw">false</span>::inline, endlpos)</span>
<span id="cb253-9"><a href="#cb253-9" aria-hidden="true" tabindex="-1"></a>  | GBeg (Pos p) -&gt;                        <span class="co">(* Group fits if it ends before endlpos. *)</span></span>
<span id="cb253-10"><a href="#cb253-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">format</span> w ((p&lt;=endlpos)::inline, endlpos)</span>
<span id="cb253-11"><a href="#cb253-11" aria-hidden="true" tabindex="-1"></a>  | GEnd _ -&gt; <span class="dt">format</span> w (<span class="dt">List</span>.tl inline, endlpos))  <span class="co">(* Pop the inline stack. *)</span></span>
<span id="cb253-12"><a href="#cb253-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb253-13"><a href="#cb253-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">format</span> w = <span class="dt">format</span> w ([<span class="kw">false</span>], w)   <span class="co">(* Start with no flattening, full line width. *)</span></span></code></pre></div>
<p>Put the pipes together into a complete pipeline:</p>
<pre><code>+--------+     +-------+     +---------+     +--------+     +----------------+
| gen doc| --&gt; |docpos | --&gt; |grends w | --&gt; |format w| --&gt; |iterate print_s |
+--------+     +-------+     +---------+     +--------+     +----------------+</code></pre>
<p>The data flows from left to right: <code>gen</code> produces document
elements, <code>docpos</code> annotates them with positions,
<code>grends</code> annotates group beginnings with their end positions,
<code>format</code> decides where to break lines and produces strings,
and <code>iterate print_string</code> prints the strings.</p>
<h3 id="factored-solution">Factored Solution</h3>
<p>For maximum flexibility, we can factorize <code>format</code> into
two parts: one that decides where to break lines (producing annotated
document elements), and one that converts those to strings. This allows
different line breaking strategies to be plugged in:</p>
<div class="sourceCode" id="cb255"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb255-1"><a href="#cb255-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* breaks: decides where to break, outputs annotated doc_e elements *)</span></span>
<span id="cb255-2"><a href="#cb255-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> breaks w (inline, endlpos <span class="kw">as</span> st) =</span>
<span id="cb255-3"><a href="#cb255-3" aria-hidden="true" tabindex="-1"></a>  Await (<span class="kw">function</span></span>
<span id="cb255-4"><a href="#cb255-4" aria-hidden="true" tabindex="-1"></a>  | TE _ <span class="kw">as</span> e -&gt; Yield (e, breaks w st)          <span class="co">(* Pass through text. *)</span></span>
<span id="cb255-5"><a href="#cb255-5" aria-hidden="true" tabindex="-1"></a>  | LE p <span class="kw">when</span> <span class="dt">List</span>.hd inline -&gt;</span>
<span id="cb255-6"><a href="#cb255-6" aria-hidden="true" tabindex="-1"></a>    Yield (TE (p, <span class="st">&quot; &quot;</span>), breaks w st)             <span class="co">(* Flatten: convert to space. *)</span></span>
<span id="cb255-7"><a href="#cb255-7" aria-hidden="true" tabindex="-1"></a>  | LE p <span class="kw">as</span> e -&gt; Yield (e, breaks w (inline, p+w))  <span class="co">(* Break: keep as LE. *)</span></span>
<span id="cb255-8"><a href="#cb255-8" aria-hidden="true" tabindex="-1"></a>  | GBeg Too_far <span class="kw">as</span> e -&gt;</span>
<span id="cb255-9"><a href="#cb255-9" aria-hidden="true" tabindex="-1"></a>    Yield (e, breaks w (<span class="kw">false</span>::inline, endlpos))</span>
<span id="cb255-10"><a href="#cb255-10" aria-hidden="true" tabindex="-1"></a>  | GBeg (Pos p) <span class="kw">as</span> e -&gt;</span>
<span id="cb255-11"><a href="#cb255-11" aria-hidden="true" tabindex="-1"></a>    Yield (e, breaks w ((p&lt;=endlpos)::inline, endlpos))</span>
<span id="cb255-12"><a href="#cb255-12" aria-hidden="true" tabindex="-1"></a>  | GEnd _ <span class="kw">as</span> e -&gt;</span>
<span id="cb255-13"><a href="#cb255-13" aria-hidden="true" tabindex="-1"></a>    Yield (e, breaks w (<span class="dt">List</span>.tl inline, endlpos)))</span>
<span id="cb255-14"><a href="#cb255-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-15"><a href="#cb255-15" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> breaks w = breaks w ([<span class="kw">false</span>], w)</span>
<span id="cb255-16"><a href="#cb255-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-17"><a href="#cb255-17" aria-hidden="true" tabindex="-1"></a><span class="co">(* emit: converts doc_e elements to strings *)</span></span>
<span id="cb255-18"><a href="#cb255-18" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> emit =</span>
<span id="cb255-19"><a href="#cb255-19" aria-hidden="true" tabindex="-1"></a>  Await (<span class="kw">function</span></span>
<span id="cb255-20"><a href="#cb255-20" aria-hidden="true" tabindex="-1"></a>  | TE (_, z) -&gt; Yield (z, emit)                 <span class="co">(* Text: output directly. *)</span></span>
<span id="cb255-21"><a href="#cb255-21" aria-hidden="true" tabindex="-1"></a>  | LE _ -&gt; Yield (<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, emit)                   <span class="co">(* Line break: output newline. *)</span></span>
<span id="cb255-22"><a href="#cb255-22" aria-hidden="true" tabindex="-1"></a>  | GBeg _ | GEnd _ -&gt; emit)                     <span class="co">(* Group markers: skip. *)</span></span>
<span id="cb255-23"><a href="#cb255-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-24"><a href="#cb255-24" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pretty_print w doc =</span>
<span id="cb255-25"><a href="#cb255-25" aria-hidden="true" tabindex="-1"></a>  gen doc &gt;-&gt; docpos &gt;-&gt; grends w &gt;-&gt; breaks w &gt;-&gt;</span>
<span id="cb255-26"><a href="#cb255-26" aria-hidden="true" tabindex="-1"></a>  emit &gt;-&gt; iterate <span class="dt">print_string</span></span></code></pre></div>
<p>Now <code>breaks</code> can be replaced with a different strategy
(for example, one that adds indentation), and <code>emit</code> stays
the same. The full pipeline reads like a description of what happens:
generate elements, compute positions, annotate groups with their ends,
decide where to break, convert to strings, and print.</p>
<h2 id="exercises-6">7.10 Exercises</h2>
<p><strong>Exercise 1:</strong> My first impulse was to define lazy list
functions as follows:</p>
<div class="sourceCode" id="cb256"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb256-1"><a href="#cb256-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> wrong_lzip = <span class="kw">function</span></span>
<span id="cb256-2"><a href="#cb256-2" aria-hidden="true" tabindex="-1"></a>  | LNil, LNil -&gt; LNil</span>
<span id="cb256-3"><a href="#cb256-3" aria-hidden="true" tabindex="-1"></a>  | LCons (a1, <span class="kw">lazy</span> l1), LCons (a2, <span class="kw">lazy</span> l2) -&gt;</span>
<span id="cb256-4"><a href="#cb256-4" aria-hidden="true" tabindex="-1"></a>      LCons ((a1, a2), <span class="kw">lazy</span> (wrong_lzip (l1, l2)))</span>
<span id="cb256-5"><a href="#cb256-5" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; <span class="dt">raise</span> (<span class="dt">Invalid_argument</span> <span class="st">&quot;lzip&quot;</span>)</span>
<span id="cb256-6"><a href="#cb256-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb256-7"><a href="#cb256-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> wrong_lmap f = <span class="kw">function</span></span>
<span id="cb256-8"><a href="#cb256-8" aria-hidden="true" tabindex="-1"></a>  | LNil -&gt; LNil</span>
<span id="cb256-9"><a href="#cb256-9" aria-hidden="true" tabindex="-1"></a>  | LCons (a, <span class="kw">lazy</span> l) -&gt; LCons (f a, <span class="kw">lazy</span> (wrong_lmap f l))</span></code></pre></div>
<p>What is wrong with these definitions – for which edge cases do they
not work as intended?</p>
<p><strong>Exercise 2:</strong> Cyclic lazy lists.</p>
<ol type="1">
<li><p>Implement a function <code>cycle : 'a list -&gt; 'a llist</code>
that creates a lazy list with elements from a standard list, and the
whole list as the tail after the last element from the input list:
<code>[a1; a2; ...; aN]</code> maps to a cyclic structure where
<code>aN</code> points back to <code>a1</code>. Your function
<code>cycle</code> can either return <code>LNil</code> or fail for an
empty list as argument.</p></li>
<li><p>Note that <code>inv_fact</code> from the lecture defines the
power series for the <span class="math inline">\exp(\cdot)</span>
function (<span class="math inline">\exp(x) = e^x</span>). Using
<code>cycle</code> and <code>inv_fact</code>, define the power series
for <span class="math inline">\sin(\cdot)</span> and <span
class="math inline">\cos(\cdot)</span>, and draw their graphs using
helper functions from the lecture script <code>Lec7.ml</code>.</p></li>
</ol>
<p><strong>Exercise 3:</strong> Modify one of the puzzle solving
programs (either from the previous lecture or from your previous
homework) to work with lazy lists. Implement the necessary higher-order
lazy list functions. Check that indeed displaying only the first
solution when there are multiple solutions in the result takes shorter
than computing solutions by the original program.</p>
<p><strong>Exercise 4:</strong> <em>Hamming’s problem</em>. Generate in
increasing order the numbers of the form <span
class="math inline">2^{a_1} 3^{a_2} 5^{a_3} \ldots p_k^{a_k}</span>,
that is numbers not divisible by prime numbers greater than the <span
class="math inline">k</span>th prime number.</p>
<p>In the original Hamming’s problem posed by Dijkstra, <span
class="math inline">k = 3</span>, which is related to <a
href="http://en.wikipedia.org/wiki/Regular_number">regular
numbers</a>.</p>
<p>Starter code is available in the lecture script
<code>Lec7.ml</code>:</p>
<div class="sourceCode" id="cb257"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb257-1"><a href="#cb257-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> lfilter f = <span class="kw">function</span></span>
<span id="cb257-2"><a href="#cb257-2" aria-hidden="true" tabindex="-1"></a>  | LNil -&gt; LNil</span>
<span id="cb257-3"><a href="#cb257-3" aria-hidden="true" tabindex="-1"></a>  | LCons (n, ll) -&gt;</span>
<span id="cb257-4"><a href="#cb257-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> f n <span class="kw">then</span> LCons (n, <span class="kw">lazy</span> (lfilter f (<span class="dt">Lazy</span>.force ll)))</span>
<span id="cb257-5"><a href="#cb257-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> lfilter f (<span class="dt">Lazy</span>.force ll)</span>
<span id="cb257-6"><a href="#cb257-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb257-7"><a href="#cb257-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> primes =</span>
<span id="cb257-8"><a href="#cb257-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> sieve = <span class="kw">function</span></span>
<span id="cb257-9"><a href="#cb257-9" aria-hidden="true" tabindex="-1"></a>    | LCons(p, nf) -&gt;</span>
<span id="cb257-10"><a href="#cb257-10" aria-hidden="true" tabindex="-1"></a>        LCons(p, <span class="kw">lazy</span> (sieve (sift p (<span class="dt">Lazy</span>.force nf))))</span>
<span id="cb257-11"><a href="#cb257-11" aria-hidden="true" tabindex="-1"></a>    | LNil -&gt; <span class="dt">failwith</span> <span class="st">&quot;Impossible! Internal error.&quot;</span></span>
<span id="cb257-12"><a href="#cb257-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">and</span> sift p = lfilter (<span class="kw">fun</span> n -&gt; n <span class="kw">mod</span> p &lt;&gt; <span class="dv">0</span>)</span>
<span id="cb257-13"><a href="#cb257-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> sieve (l_from <span class="dv">2</span>)</span>
<span id="cb257-14"><a href="#cb257-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb257-15"><a href="#cb257-15" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> times ll n = lmap (<span class="kw">fun</span> i -&gt; i * n) ll</span>
<span id="cb257-16"><a href="#cb257-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb257-17"><a href="#cb257-17" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> merge xs ys =</span>
<span id="cb257-18"><a href="#cb257-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> xs, ys <span class="kw">with</span></span>
<span id="cb257-19"><a href="#cb257-19" aria-hidden="true" tabindex="-1"></a>  | LCons (x, <span class="kw">lazy</span> xr), LCons (y, <span class="kw">lazy</span> yr) -&gt;</span>
<span id="cb257-20"><a href="#cb257-20" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> x &lt; y <span class="kw">then</span> LCons (x, <span class="kw">lazy</span> (merge xr ys))</span>
<span id="cb257-21"><a href="#cb257-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> <span class="kw">if</span> x &gt; y <span class="kw">then</span> LCons (y, <span class="kw">lazy</span> (merge xs yr))</span>
<span id="cb257-22"><a href="#cb257-22" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> LCons (x, <span class="kw">lazy</span> (merge xr yr))</span>
<span id="cb257-23"><a href="#cb257-23" aria-hidden="true" tabindex="-1"></a>  | r, LNil | LNil, r -&gt; r</span>
<span id="cb257-24"><a href="#cb257-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb257-25"><a href="#cb257-25" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> hamming k =</span>
<span id="cb257-26"><a href="#cb257-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> _pr = ltake k primes <span class="kw">in</span>  <span class="co">(* </span><span class="al">TODO</span><span class="co">: use primes to generate smooth numbers *)</span></span>
<span id="cb257-27"><a href="#cb257-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> h = LCons (<span class="dv">1</span>, <span class="kw">lazy</span> (</span>
<span id="cb257-28"><a href="#cb257-28" aria-hidden="true" tabindex="-1"></a>     <span class="co">(* </span><span class="al">TODO</span><span class="co">: replace this placeholder with the real generator; `h` keeps the snippet compiling. *)</span> h</span>
<span id="cb257-29"><a href="#cb257-29" aria-hidden="true" tabindex="-1"></a>  )) <span class="kw">in</span> h</span></code></pre></div>
<p><strong>Exercise 5:</strong> Modify <code>format</code> and/or
<code>breaks</code> to use just a single number instead of a stack of
booleans to keep track of what groups should be inlined.</p>
<p><strong>Exercise 6:</strong> Add <strong>indentation</strong> to the
pretty-printer for groups: if a group does not fit in a single line, its
consecutive lines are indented by a given amount <code>tab</code> of
spaces deeper than its parent group lines would be. For comparison,
let’s do several implementations.</p>
<ol type="1">
<li>Modify the straightforward implementation of
<code>pretty</code>.</li>
<li>Modify the first pipe-based implementation of <code>pretty</code> by
modifying the <code>format</code> function.</li>
<li>Modify the second pipe-based implementation of <code>pretty</code>
by modifying the <code>breaks</code> function. Recover the positions of
elements – the number of characters from the beginning of the document –
by keeping track of the growing offset.</li>
<li>(Harder) Modify a pipe-based implementation to provide a different
style of indentation: indent the first line of a group, when the group
starts on a new line, at the same level as the consecutive lines (rather
than at the parent level of indentation).</li>
</ol>
<p><strong>Exercise 7:</strong> Write a pipe that takes document
elements annotated with linear position, and produces document elements
annotated with (line, column) coordinates.</p>
<p>Write another pipe that takes so annotated elements and adds a line
number indicator in front of each line. Do not update the column
coordinate. Test the pipes by plugging them before the <code>emit</code>
pipe.</p>
<pre><code>1: first line
2: second line, etc.</code></pre>
<p><strong>Exercise 8:</strong> Write a pipe that consumes document
elements <code>doc_e</code> and yields the toplevel subdocuments
<code>doc</code> which would generate the corresponding elements.</p>
<p>You can modify the definition of documents to allow annotations, so
that the element annotations are preserved (<code>gen</code> should
ignore annotations to keep things simple):</p>
<div class="sourceCode" id="cb259"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb259-1"><a href="#cb259-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a doc =</span>
<span id="cb259-2"><a href="#cb259-2" aria-hidden="true" tabindex="-1"></a>  Text <span class="kw">of</span> &#39;a * <span class="dt">string</span> | Line <span class="kw">of</span> &#39;a | Cat <span class="kw">of</span> &#39;a doc * &#39;a doc | Group <span class="kw">of</span> &#39;a * &#39;a doc</span></code></pre></div>
<p><strong>Exercise 9:</strong> (Harder) Design and implement a way to
duplicate arrows outgoing from a pipe-box, that would memoize the
stream, i.e. not recompute everything “upstream” for the composition of
pipes. Such duplicated arrows would behave nicely with pipes reading
from files.</p>
<h1 id="chapter-8-monads">Chapter 8: Monads</h1>
<p><strong>In this chapter, you will:</strong></p>
<ul>
<li>Recognize the “bind + return” pattern behind list comprehensions and
other effects</li>
<li>Learn the monad laws (and what they do and do not guarantee)</li>
<li>Use monad-plus for nondeterministic/backtracking computation</li>
<li>Work through several concrete monads (lazy, list, exception, state,
probability)</li>
<li>Combine effects with monad transformers and model cooperative
concurrency</li>
</ul>
<p>This chapter explores one of functional programming’s most powerful
abstractions: monads. We begin with equivalents of list comprehensions
as a motivating example, then introduce monadic concepts and examine the
monad laws. We explore the monad-plus extension that adds
non-determinism, then work through various monad instances including the
lazy, list, state, exception, and probability monads. We conclude with
monad transformers for combining monads and cooperative lightweight
threads for concurrency.</p>
<p>The material draws on several excellent resources: Jeff Newbern’s
“All About Monads,” Martin Erwig and Steve Kollmansberger’s
“Probabilistic Functional Programming in Haskell,” and Jerome Vouillon’s
“Lwt: a Cooperative Thread Library.”</p>
<h2 id="list-comprehensions">8.1 List Comprehensions</h2>
<p>Recall the somewhat awkward syntax we used in the Countdown Problem
example from earlier chapters. The nested callback style, while
functional, is hard to read and understand at a glance. The brute-force
generation of expressions looked like this:</p>
<div class="sourceCode" id="cb260"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb260-1"><a href="#cb260-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> combine l r =</span>
<span id="cb260-2"><a href="#cb260-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.map (<span class="kw">fun</span> o -&gt; App (o, l, r)) [Add; Sub; Mul; Div]</span>
<span id="cb260-3"><a href="#cb260-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb260-4"><a href="#cb260-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> exprs = <span class="kw">function</span></span>
<span id="cb260-5"><a href="#cb260-5" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; []</span>
<span id="cb260-6"><a href="#cb260-6" aria-hidden="true" tabindex="-1"></a>  | [n] -&gt; [Val n]</span>
<span id="cb260-7"><a href="#cb260-7" aria-hidden="true" tabindex="-1"></a>  | ns -&gt;</span>
<span id="cb260-8"><a href="#cb260-8" aria-hidden="true" tabindex="-1"></a>      split ns |-&gt; (<span class="kw">fun</span> (ls, rs) -&gt;</span>
<span id="cb260-9"><a href="#cb260-9" aria-hidden="true" tabindex="-1"></a>      exprs ls |-&gt; (<span class="kw">fun</span> l -&gt;</span>
<span id="cb260-10"><a href="#cb260-10" aria-hidden="true" tabindex="-1"></a>      exprs rs |-&gt; (<span class="kw">fun</span> r -&gt;</span>
<span id="cb260-11"><a href="#cb260-11" aria-hidden="true" tabindex="-1"></a>      combine l r)))</span></code></pre></div>
<p>Notice how the nested callbacks pile up: each <code>|-&gt;</code>
introduces another level of indentation. The generate-and-test scheme
used similar nesting:</p>
<div class="sourceCode" id="cb261"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb261-1"><a href="#cb261-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> guard p e = <span class="kw">if</span> p e <span class="kw">then</span> [e] <span class="kw">else</span> []</span>
<span id="cb261-2"><a href="#cb261-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb261-3"><a href="#cb261-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> solutions ns n =</span>
<span id="cb261-4"><a href="#cb261-4" aria-hidden="true" tabindex="-1"></a>  choices ns |-&gt; (<span class="kw">fun</span> ns&#39; -&gt;</span>
<span id="cb261-5"><a href="#cb261-5" aria-hidden="true" tabindex="-1"></a>  exprs ns&#39; |-&gt;</span>
<span id="cb261-6"><a href="#cb261-6" aria-hidden="true" tabindex="-1"></a>    guard (<span class="kw">fun</span> e -&gt; eval e = <span class="dt">Some</span> n))</span></code></pre></div>
<p>The key insight is that we introduced the operator
<code>|-&gt;</code> defined as:</p>
<div class="sourceCode" id="cb262"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb262-1"><a href="#cb262-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ( |-&gt; ) x f = concat_map f x</span></code></pre></div>
<p>This pattern of “for each element in a list, apply a function that
returns a list, then flatten the results” is so common that many
languages provide special syntax for it. We can express such
computations much more elegantly with <em>list comprehensions</em>, a
syntax that originated in languages like Haskell and Python.</p>
<p>With list comprehensions, we can write expressions that read almost
like set-builder notation in mathematics:</p>
<div class="sourceCode" id="cb263"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb263-1"><a href="#cb263-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> test = [i * <span class="dv">2</span> | i &lt;- from_to <span class="dv">2</span> <span class="dv">22</span>; i <span class="kw">mod</span> <span class="dv">3</span> = <span class="dv">0</span>]</span></code></pre></div>
<p>This reads as: “the list of <code>i * 2</code> for each
<code>i</code> drawn from <code>from_to 2 22</code> where
<code>i mod 3 = 0</code>.” The <code>&lt;-</code> arrow draws elements
from a generator, and conditions filter which elements are kept.</p>
<p>The translation rules that define list comprehension semantics are
straightforward:</p>
<ul>
<li><code>[expr | ]</code> translates to <code>[expr]</code> – the base
case, a singleton list</li>
<li><code>[expr | v &lt;- generator; more]</code> translates to
<code>generator |-&gt; (fun v -&gt; [expr | more])</code> – draw from a
generator, then recurse</li>
<li><code>[expr | condition; more]</code> translates to
<code>if condition then [expr | more] else []</code> – filter by a
condition</li>
</ul>
<p>The list comprehension syntax has not caught on in modern OCaml;
there were a couple syntax extensions providing it, but none gained
popularity. It is a nice syntax to build intuition but the examples in
this section need additional setup to compile, you can treat them as
pseudo-code.</p>
<h3 id="revisiting-countdown-with-list-comprehensions">Revisiting
Countdown with List Comprehensions</h3>
<p>Now let us revisit the Countdown Problem code with list
comprehensions. The brute-force generation becomes dramatically cleaner
– compare this to the deeply nested version above:</p>
<div class="sourceCode" id="cb264"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb264-1"><a href="#cb264-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> exprs = <span class="kw">function</span></span>
<span id="cb264-2"><a href="#cb264-2" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; []</span>
<span id="cb264-3"><a href="#cb264-3" aria-hidden="true" tabindex="-1"></a>  | [n] -&gt; [Val n]</span>
<span id="cb264-4"><a href="#cb264-4" aria-hidden="true" tabindex="-1"></a>  | ns -&gt;</span>
<span id="cb264-5"><a href="#cb264-5" aria-hidden="true" tabindex="-1"></a>      [App (o, l, r) | (ls, rs) &lt;- split ns;</span>
<span id="cb264-6"><a href="#cb264-6" aria-hidden="true" tabindex="-1"></a>       l &lt;- exprs ls; r &lt;- exprs rs;</span>
<span id="cb264-7"><a href="#cb264-7" aria-hidden="true" tabindex="-1"></a>       o &lt;- [Add; Sub; Mul; Div]]</span></code></pre></div>
<p>The intent is immediately clear: we split the numbers, recursively
build expressions for left and right parts, and try each operator. The
generate-and-test scheme becomes equally elegant:</p>
<div class="sourceCode" id="cb265"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb265-1"><a href="#cb265-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> solutions ns n =</span>
<span id="cb265-2"><a href="#cb265-2" aria-hidden="true" tabindex="-1"></a>  [e | ns&#39; &lt;- choices ns;</span>
<span id="cb265-3"><a href="#cb265-3" aria-hidden="true" tabindex="-1"></a>   e &lt;- exprs ns&#39;; eval e = <span class="dt">Some</span> n]</span></code></pre></div>
<p>The guard condition <code>eval e = Some n</code> filters out
expressions that do not evaluate to the target value.</p>
<h3 id="more-list-comprehension-examples">More List Comprehension
Examples</h3>
<p>List comprehensions shine when expressing combinatorial algorithms.
Here is computing all subsequences of a list (note that this generates
some intermediate garbage, but the intent is clear):</p>
<div class="sourceCode" id="cb266"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb266-1"><a href="#cb266-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> subseqs l =</span>
<span id="cb266-2"><a href="#cb266-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb266-3"><a href="#cb266-3" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; [[]]</span>
<span id="cb266-4"><a href="#cb266-4" aria-hidden="true" tabindex="-1"></a>  | x::xs -&gt; [ys | px &lt;- subseqs xs; ys &lt;- [px; x::px]]</span></code></pre></div>
<p>For each element <code>x</code>, we recursively compute subsequences
of the tail, then for each such subsequence we include both the version
without <code>x</code> and the version with <code>x</code>
prepended.</p>
<p>Computing permutations can be done via insertion – inserting an
element at every possible position:</p>
<div class="sourceCode" id="cb267"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb267-1"><a href="#cb267-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> insert x = <span class="kw">function</span></span>
<span id="cb267-2"><a href="#cb267-2" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; [[x]]</span>
<span id="cb267-3"><a href="#cb267-3" aria-hidden="true" tabindex="-1"></a>  | y::ys&#39; <span class="kw">as</span> ys -&gt;</span>
<span id="cb267-4"><a href="#cb267-4" aria-hidden="true" tabindex="-1"></a>      (x::ys) :: [y::zs | zs &lt;- insert x ys&#39;]</span>
<span id="cb267-5"><a href="#cb267-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb267-6"><a href="#cb267-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> ins_perms = <span class="kw">function</span></span>
<span id="cb267-7"><a href="#cb267-7" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; [[]]</span>
<span id="cb267-8"><a href="#cb267-8" aria-hidden="true" tabindex="-1"></a>  | x::xs -&gt; [zs | ys &lt;- ins_perms xs; zs &lt;- insert x ys]</span></code></pre></div>
<p>The <code>insert</code> function generates all ways to insert
<code>x</code> into a list. Then <code>ins_perms</code> recursively
permutes the tail and inserts the head at every position.</p>
<p>Alternatively, we can compute permutations via selection – repeatedly
choosing which element comes first:</p>
<div class="sourceCode" id="cb268"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb268-1"><a href="#cb268-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> select = <span class="kw">function</span></span>
<span id="cb268-2"><a href="#cb268-2" aria-hidden="true" tabindex="-1"></a>  | [x] -&gt; [x, []]</span>
<span id="cb268-3"><a href="#cb268-3" aria-hidden="true" tabindex="-1"></a>  | x::xs -&gt; (x, xs) :: [y, x::ys | y, ys &lt;- select xs]</span>
<span id="cb268-4"><a href="#cb268-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb268-5"><a href="#cb268-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> sel_perms = <span class="kw">function</span></span>
<span id="cb268-6"><a href="#cb268-6" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; [[]]</span>
<span id="cb268-7"><a href="#cb268-7" aria-hidden="true" tabindex="-1"></a>  | xs -&gt; [x::ys | x, xs&#39; &lt;- select xs; ys &lt;- sel_perms xs&#39;]</span></code></pre></div>
<p>The <code>select</code> function returns all ways to pick one element
from a list, along with the remaining elements. Then
<code>sel_perms</code> chooses a first element and recursively permutes
the rest.</p>
<h2 id="generalized-comprehensions-binding-operators">8.2 Generalized
Comprehensions: Binding Operators</h2>
<p>The pattern we saw with list comprehensions is remarkably general. In
fact, the same <code>|-&gt;</code> pattern (applying a function that
returns a container, then flattening) works for many types beyond lists.
This is the essence of monads.</p>
<p>OCaml 4.08 introduced <strong>binding operators</strong>
(<code>let*</code>, <code>let+</code>, <code>and*</code>, …) that
provide a clean, native syntax for such computations. Instead of
external syntax extensions like the old Camlp4-based
<code>pa_monad</code>, we can now define custom operators that integrate
naturally with the language.</p>
<p>For the list monad, we define these binding operators:</p>
<div class="sourceCode" id="cb269"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb269-1"><a href="#cb269-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ( <span class="kw">let</span>* ) x f = concat_map f x      <span class="co">(* bind: sequence computations *)</span></span>
<span id="cb269-2"><a href="#cb269-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ( <span class="kw">let</span>+ ) x f = <span class="dt">List</span>.map f x        <span class="co">(* map: apply pure function *)</span></span>
<span id="cb269-3"><a href="#cb269-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ( <span class="kw">and</span>* ) x y = concat_map (<span class="kw">fun</span> a -&gt; <span class="dt">List</span>.map (<span class="kw">fun</span> b -&gt; (a, b)) y) x</span>
<span id="cb269-4"><a href="#cb269-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ( <span class="kw">and</span>+ ) = ( <span class="kw">and</span>* )                <span class="co">(* parallel binding *)</span></span>
<span id="cb269-5"><a href="#cb269-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> return x = [x]                     <span class="co">(* inject a value into the monad *)</span></span>
<span id="cb269-6"><a href="#cb269-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fail = []                          <span class="co">(* the empty computation *)</span></span></code></pre></div>
<p>The <code>let*</code> operator is the key: it sequences computations
where each step can produce multiple results. The <code>and*</code>
operator allows binding multiple values in parallel. With these
operators, the expression generation code becomes:</p>
<pre><code>let rec exprs = function
  | [] -&gt; []
  | [n] -&gt; [Val n]
  | ns -&gt;
      let* (ls, rs) = split ns in
      let* l = exprs ls in
      let* r = exprs rs in
      let* o = [Add; Sub; Mul; Div] in
      [App (o, l, r)]</code></pre>
<p>Each <code>let*</code> introduces a binding: the variable on the left
is bound to each value produced by the expression on the right, and the
computation continues with <code>in</code>. This is much more readable
than the nested callbacks we started with.</p>
<p>However, the <code>let*</code> syntax does not directly support
guards (conditions that filter results). If we try to write:</p>
<pre><code>let solutions ns n =
  let* ns&#39; = choices ns in
  let* e = exprs ns&#39; in
  eval e = Some n;  (* Error! *)
  e</code></pre>
<p>We get a type error: the expression expects a list, but
<code>eval e = Some n</code> is a boolean. What can we do?</p>
<p>One approach is to explicitly decide whether to return anything:</p>
<pre><code>let solutions ns n =
  let* ns&#39; = choices ns in
  let* e = exprs ns&#39; in
  if eval e = Some n then [e] else []</code></pre>
<p>But what if we want to check a condition earlier in the computation,
or check multiple conditions? We need a general “guard check” function.
The key insight is that we can use the monad itself to represent success
or failure:</p>
<div class="sourceCode" id="cb273"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb273-1"><a href="#cb273-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> guard p = <span class="kw">if</span> p <span class="kw">then</span> [()] <span class="kw">else</span> []</span></code></pre></div>
<p>When the condition <code>p</code> is true, <code>guard</code> returns
<code>[()]</code> – a list with one element (the unit value). When
false, it returns <code>[]</code> – an empty list. Now we can use it in
a binding:</p>
<pre><code>let solutions ns n =
  let* ns&#39; = choices ns in
  let* e = exprs ns&#39; in
  let* () = guard (eval e = Some n) in
  [e]</code></pre>
<p>Why does this work? When the guard succeeds,
<code>let* () = [()]</code> binds unit and continues. When it fails,
<code>let* () = []</code> produces no results – the empty list – so the
rest of the computation is never reached for that branch. This is
exactly the filtering behavior we want!</p>
<h2 id="monads">8.3 Monads</h2>
<p>Now we are ready to define monads properly. A <strong>monad</strong>
is a polymorphic type <code>'a monad</code> (or <code>'a Monad.t</code>)
that supports at least two operations:</p>
<ul>
<li><code>bind : 'a monad -&gt; ('a -&gt; 'b monad) -&gt; 'b monad</code>
– sequence two computations, passing the result of the first to the
second</li>
<li><code>return : 'a -&gt; 'a monad</code> – inject a pure value into
the monad</li>
<li>The infix <code>&gt;&gt;=</code> is commonly used for
<code>bind</code>: <code>let (&gt;&gt;=) a b = bind a b</code></li>
</ul>
<p>The <code>bind</code> operation is the heart of the monad: it takes a
computation that produces an <code>'a</code>, and a function that takes
an <code>'a</code> and produces a new computation yielding
<code>'b</code>. The result is a combined computation that yields
<code>'b</code>.</p>
<p>With OCaml 5’s binding operators, we define <code>let*</code> as an
alias for <code>bind</code>:</p>
<div class="sourceCode" id="cb275"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb275-1"><a href="#cb275-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> bind a b = concat_map b a</span>
<span id="cb275-2"><a href="#cb275-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> return x = [x]</span>
<span id="cb275-3"><a href="#cb275-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ( <span class="kw">let</span>* ) = bind</span>
<span id="cb275-4"><a href="#cb275-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb275-5"><a href="#cb275-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> solutions ns n =</span>
<span id="cb275-6"><a href="#cb275-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span>* ns&#39; = choices ns <span class="kw">in</span></span>
<span id="cb275-7"><a href="#cb275-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span>* e = exprs ns&#39; <span class="kw">in</span></span>
<span id="cb275-8"><a href="#cb275-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span>* () = guard (eval e = <span class="dt">Some</span> n) <span class="kw">in</span></span>
<span id="cb275-9"><a href="#cb275-9" aria-hidden="true" tabindex="-1"></a>  return e</span></code></pre></div>
<p>But why does <code>guard</code> look the way it does? Let us examine
more carefully:</p>
<div class="sourceCode" id="cb276"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb276-1"><a href="#cb276-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fail = []</span>
<span id="cb276-2"><a href="#cb276-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> guard p = <span class="kw">if</span> p <span class="kw">then</span> return () <span class="kw">else</span> fail</span></code></pre></div>
<p>Steps in monadic computation are composed with <code>let*</code> (or
<code>&gt;&gt;=</code>, which is like <code>|-&gt;</code> for lists).
The key insight is understanding what happens when we bind with an empty
list versus a singleton:</p>
<ul>
<li><code>let* _ = [] in ...</code> does not produce anything – the
continuation is never called, so the computation fails (produces no
results)</li>
<li><code>let* _ = [()] in ...</code> calls the continuation once with
<code>()</code>, which simply continues the computation unchanged</li>
</ul>
<p>This is why <code>guard</code> works: returning <code>[()]</code>
means “succeed with unit” and returning <code>[]</code> means “fail with
no results.” The unit value itself is a dummy – we only care whether the
list is empty or not.</p>
<p>Throwing away the binding argument is a common pattern. With binding
operators, we use <code>let* () = ...</code> or
<code>let* _ = ...</code> to indicate we do not need the bound
value:</p>
<div class="sourceCode" id="cb277"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb277-1"><a href="#cb277-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (&gt;&gt;=) a b = bind a b</span>
<span id="cb277-2"><a href="#cb277-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (&gt;&gt;) m f = m &gt;&gt;= (<span class="kw">fun</span> _ -&gt; f)</span></code></pre></div>
<p>The <code>&gt;&gt;</code> operator (called “sequence” or “then”) is
useful when you want to perform a computation for its effect but discard
its result.</p>
<h3 id="the-binding-operator-syntax">The Binding Operator Syntax</h3>
<p>For reference, OCaml 5’s binding operators translate as follows:</p>
<table>
<colgroup>
<col style="width: 38%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr>
<th>Source</th>
<th>Translation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>let* x = exp in body</code></td>
<td><code>bind exp (fun x -&gt; body)</code></td>
</tr>
<tr>
<td><code>let+ x = exp in body</code></td>
<td><code>map (fun x -&gt; body) exp</code></td>
</tr>
<tr>
<td><code>let* () = exp in body</code></td>
<td><code>bind exp (fun () -&gt; body)</code></td>
</tr>
<tr>
<td><code>let* x = e1 and* y = e2 in body</code></td>
<td><code>bind (and* e1 e2) (fun (x, y) -&gt; body)</code></td>
</tr>
</tbody>
</table>
<p>The binding operators <code>let*</code>, <code>let+</code>,
<code>and*</code>, and <code>and+</code> must be defined in scope. These
are regular OCaml operators and require no syntax extensions – a
significant improvement over the old Camlp4 approach.</p>
<p>Note: For pattern matching in bindings, if the pattern is refutable
(can fail to match), the monadic operation should handle the failure
appropriately. For example, <code>let* Some x = e in body</code>
requires a way to handle the <code>None</code> case.</p>
<h2 id="monad-laws">8.4 Monad Laws</h2>
<p>Not every type with <code>bind</code> and <code>return</code>
operations is a proper monad. A parametric data type is a monad only if
its <code>bind</code> and <code>return</code> operations meet three
fundamental axioms:</p>
<p><span class="math display">
\begin{aligned}
\text{bind}\ (\text{return}\ a)\ f &amp;\approx f\ a &amp; \text{(left
identity)} \\
\text{bind}\ a\ (\lambda x.\text{return}\ x) &amp;\approx a &amp;
\text{(right identity)} \\
\text{bind}\ (\text{bind}\ a\ (\lambda x.b))\ (\lambda y.c) &amp;\approx
\text{bind}\ a\ (\lambda x.\text{bind}\ b\ (\lambda y.c)) &amp;
\text{(associativity)}
\end{aligned}
</span></p>
<p>Let us understand what these laws mean:</p>
<ul>
<li><strong>Left identity</strong>: If you inject a value with
<code>return</code> and immediately bind it to a function, you get the
same result as just applying the function. The <code>return</code>
operation should not add any extra “effects.”</li>
<li><strong>Right identity</strong>: If you bind a computation to
<code>return</code>, you get back the same computation. The
<code>return</code> operation is neutral.</li>
<li><strong>Associativity</strong>: Binding is associative – it does not
matter how you group nested binds. This means
<code>let* x = (let* y = a in b) in c</code> is equivalent to
<code>let* y = a in let* x = b in c</code> (when <code>x</code> does not
appear free in <code>b</code>).</li>
</ul>
<p>You should verify that these laws hold for our list monad:</p>
<div class="sourceCode" id="cb278"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb278-1"><a href="#cb278-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> bind a b = concat_map b a</span>
<span id="cb278-2"><a href="#cb278-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> return x = [x]</span></code></pre></div>
<p>For example, to verify left identity: <code>bind (return a) f</code>
= <code>bind [a] f</code> = <code>concat_map f [a]</code> =
<code>f a</code>. The other laws can be verified similarly.</p>
<h2 id="monoid-laws-and-monad-plus">8.5 Monoid Laws and Monad-Plus</h2>
<p>The list monad has an additional structure beyond just
<code>bind</code> and <code>return</code>: it supports combining
multiple computations and representing failure. This leads us to the
concept of a <strong>monoid</strong>.</p>
<p>A monoid is a type with at least two operations:</p>
<ul>
<li><code>mzero : 'a monoid</code> – an identity element (think: zero,
or the empty container)</li>
<li><code>mplus : 'a monoid -&gt; 'a monoid -&gt; 'a monoid</code> – a
combining operation (think: addition, or concatenation)</li>
</ul>
<p>These operations must meet the standard monoid laws:</p>
<p><span class="math display">
\begin{aligned}
\text{mplus}\ \text{mzero}\ a &amp;\approx a &amp; \text{(left
identity)} \\
\text{mplus}\ a\ \text{mzero} &amp;\approx a &amp; \text{(right
identity)} \\
\text{mplus}\ a\ (\text{mplus}\ b\ c) &amp;\approx \text{mplus}\
(\text{mplus}\ a\ b)\ c &amp; \text{(associativity)}
\end{aligned}
</span></p>
<p>We define <code>fail</code> as a synonym for <code>mzero</code> and
infix <code>++</code> for <code>mplus</code>. For lists,
<code>mzero</code> is <code>[]</code> and <code>mplus</code> is
<code>@</code> (append).</p>
<p>Fusing monads and monoids gives the most popular general flavor of
monads, which we call <strong>monad-plus</strong> after Haskell. A
monad-plus is a monad that also has monoid structure, with additional
axioms relating the “addition” (<code>mplus</code>) and “multiplication”
(<code>bind</code>):</p>
<p><span class="math display">
\begin{aligned}
\text{bind}\ \text{mzero}\ f &amp;\approx \text{mzero} \\
\text{bind}\ m\ (\lambda x.\text{mzero}) &amp;\approx \text{mzero}
\end{aligned}
</span></p>
<p>These laws say that <code>mzero</code> acts like a “zero” for
<code>bind</code>: binding from zero produces zero, and binding to a
function that always returns zero also produces zero. This is analogous
to how <span class="math inline">0 \times x = 0</span> and <span
class="math inline">x \times 0 = 0</span> in arithmetic.</p>
<p>Using infix notation with <span class="math inline">\oplus</span> for
<code>mplus</code>, <span class="math inline">\mathbf{0}</span> for
<code>mzero</code>, <span class="math inline">\triangleright</span> for
<code>bind</code>, and <span class="math inline">\mathbf{1}</span> for
<code>return</code>, the complete monad-plus axioms are:</p>
<p><span class="math display">
\begin{aligned}
\mathbf{0} \oplus a &amp;\approx a \\
a \oplus \mathbf{0} &amp;\approx a \\
a \oplus (b \oplus c) &amp;\approx (a \oplus b) \oplus c \\
\mathbf{1}\ x \triangleright f &amp;\approx f\ x \\
a \triangleright \lambda x.\mathbf{1}\ x &amp;\approx a \\
(a \triangleright \lambda x.b) \triangleright \lambda y.c &amp;\approx a
\triangleright (\lambda x.b \triangleright \lambda y.c) \\
\mathbf{0} \triangleright f &amp;\approx \mathbf{0} \\
a \triangleright (\lambda x.\mathbf{0}) &amp;\approx \mathbf{0}
\end{aligned}
</span></p>
<p>The list type has a natural monad and monoid structure:</p>
<div class="sourceCode" id="cb279"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb279-1"><a href="#cb279-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> mzero = []</span>
<span id="cb279-2"><a href="#cb279-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> mplus = (@)</span>
<span id="cb279-3"><a href="#cb279-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> bind a b = concat_map b a</span>
<span id="cb279-4"><a href="#cb279-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> return a = [a]</span></code></pre></div>
<p>Given any monad-plus, we can define useful derived operations:</p>
<div class="sourceCode" id="cb280"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb280-1"><a href="#cb280-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fail = mzero</span>
<span id="cb280-2"><a href="#cb280-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (++) = mplus</span>
<span id="cb280-3"><a href="#cb280-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (&gt;&gt;=) a b = bind a b</span>
<span id="cb280-4"><a href="#cb280-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> guard p = <span class="kw">if</span> p <span class="kw">then</span> return () <span class="kw">else</span> fail</span></code></pre></div>
<p>Now we can see that <code>guard</code> is defined in terms of the
monad-plus structure: it returns the identity element
(<code>return ()</code>) on success, or the zero element
(<code>fail</code>) on failure.</p>
<h2 id="backtracking-computation-with-choice">8.6 Backtracking:
Computation with Choice</h2>
<p>We have seen <code>mzero</code> (i.e., <code>fail</code>) in the
countdown problem – it represents a computation that produces no
results. But what about <code>mplus</code>? The <code>mplus</code>
operation combines two computations, giving us a way to express
<em>choice</em>: try this computation, or try that one.</p>
<p>Here is an example from a puzzle solver where <code>mplus</code>
creates a choice point:</p>
<div class="sourceCode" id="cb281"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb281-1"><a href="#cb281-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> find_to_eat n island_size num_islands empty_cells =</span>
<span id="cb281-2"><a href="#cb281-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> honey = honey_cells n empty_cells <span class="kw">in</span></span>
<span id="cb281-3"><a href="#cb281-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb281-4"><a href="#cb281-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> find_board s =</span>
<span id="cb281-5"><a href="#cb281-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> visit_cell s <span class="kw">with</span></span>
<span id="cb281-6"><a href="#cb281-6" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">None</span> -&gt;</span>
<span id="cb281-7"><a href="#cb281-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span>* () = guard (s.been_islands = num_islands) <span class="kw">in</span></span>
<span id="cb281-8"><a href="#cb281-8" aria-hidden="true" tabindex="-1"></a>        return s.eaten</span>
<span id="cb281-9"><a href="#cb281-9" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (cell, s) -&gt;</span>
<span id="cb281-10"><a href="#cb281-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span>* s = find_island cell (fresh_island s) <span class="kw">in</span></span>
<span id="cb281-11"><a href="#cb281-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span>* () = guard (s.been_size = island_size) <span class="kw">in</span></span>
<span id="cb281-12"><a href="#cb281-12" aria-hidden="true" tabindex="-1"></a>        find_board s</span>
<span id="cb281-13"><a href="#cb281-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb281-14"><a href="#cb281-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">and</span> find_island current s =</span>
<span id="cb281-15"><a href="#cb281-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s = keep_cell current s <span class="kw">in</span></span>
<span id="cb281-16"><a href="#cb281-16" aria-hidden="true" tabindex="-1"></a>    neighbors n empty_cells current</span>
<span id="cb281-17"><a href="#cb281-17" aria-hidden="true" tabindex="-1"></a>    |&gt; foldM</span>
<span id="cb281-18"><a href="#cb281-18" aria-hidden="true" tabindex="-1"></a>         (<span class="kw">fun</span> neighbor s -&gt;</span>
<span id="cb281-19"><a href="#cb281-19" aria-hidden="true" tabindex="-1"></a>           <span class="kw">if</span> CellSet.mem neighbor s.visited <span class="kw">then</span> return s</span>
<span id="cb281-20"><a href="#cb281-20" aria-hidden="true" tabindex="-1"></a>           <span class="kw">else</span></span>
<span id="cb281-21"><a href="#cb281-21" aria-hidden="true" tabindex="-1"></a>             <span class="kw">let</span> choose_eat =</span>
<span id="cb281-22"><a href="#cb281-22" aria-hidden="true" tabindex="-1"></a>               <span class="kw">if</span> s.more_to_eat &lt;= <span class="dv">0</span> <span class="kw">then</span> fail</span>
<span id="cb281-23"><a href="#cb281-23" aria-hidden="true" tabindex="-1"></a>               <span class="kw">else</span> return (eat_cell neighbor s)</span>
<span id="cb281-24"><a href="#cb281-24" aria-hidden="true" tabindex="-1"></a>             <span class="kw">and</span> choose_keep =</span>
<span id="cb281-25"><a href="#cb281-25" aria-hidden="true" tabindex="-1"></a>               <span class="kw">if</span> s.been_size &gt;= island_size <span class="kw">then</span> fail</span>
<span id="cb281-26"><a href="#cb281-26" aria-hidden="true" tabindex="-1"></a>               <span class="kw">else</span> find_island neighbor s <span class="kw">in</span></span>
<span id="cb281-27"><a href="#cb281-27" aria-hidden="true" tabindex="-1"></a>             mplus choose_eat choose_keep)  <span class="co">(* Choice point! *)</span></span>
<span id="cb281-28"><a href="#cb281-28" aria-hidden="true" tabindex="-1"></a>         s <span class="kw">in</span></span>
<span id="cb281-29"><a href="#cb281-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb281-30"><a href="#cb281-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> cells_to_eat =</span>
<span id="cb281-31"><a href="#cb281-31" aria-hidden="true" tabindex="-1"></a>    <span class="dt">List</span>.length honey - island_size * num_islands <span class="kw">in</span></span>
<span id="cb281-32"><a href="#cb281-32" aria-hidden="true" tabindex="-1"></a>  find_board (init_state honey cells_to_eat)</span></code></pre></div>
<p>The line <code>mplus choose_eat choose_keep</code> creates a choice
point: the algorithm can either eat the cell (removing it from
consideration) or keep it as part of the current island. When we use the
list monad as our monad-plus, this explores <em>all</em> possible
choices, collecting all solutions. The monad-plus structure handles the
bookkeeping of backtracking automatically – we just express the choices
declaratively.</p>
<h2 id="monad-flavors">8.7 Monad Flavors</h2>
<p>Monads “wrap around” a type, but some monads need an additional type
parameter. For example, a state monad might be parameterized by the type
of state it carries. Usually the additional type does not change while
within a monad, so we stick to <code>'a monad</code> rather than
<code>('s, 'a) monad</code>.</p>
<p>As monad-plus shows, things get interesting when we add more
operations to a basic monad. Different “flavors” of monads provide
different capabilities. Here are the most common ones:</p>
<p><strong>Monads with access:</strong></p>
<pre><code>access : &#39;a monad -&gt; &#39;a</code></pre>
<p>An <code>access</code> operation lets you extract the value from the
monad. Not all monads support this – some only allow you to “run” the
monad at the top level. Example: the lazy monad, where
<code>access</code> is <code>Lazy.force</code>.</p>
<p><strong>Monad-plus (non-deterministic computation):</strong></p>
<pre><code>mzero : &#39;a monad
mplus : &#39;a monad -&gt; &#39;a monad -&gt; &#39;a monad</code></pre>
<p>We have already seen this. The monad-plus flavor supports failure and
choice, enabling backtracking search.</p>
<p><strong>Monads with state (parameterized by type
<code>store</code>):</strong></p>
<pre><code>get : store monad
put : store -&gt; unit monad</code></pre>
<p>These operations let you read and write a piece of state that is
threaded through the computation. There is a “canonical” state monad we
will examine later. Related monads include: - The <strong>writer
monad</strong>: has <code>tell</code> (append to a log) and
<code>listen</code> (read the log) - The <strong>reader monad</strong>:
has <code>ask</code> (read an environment) and <code>local</code> to
modify the environment for a sub-computation:</p>
<pre><code>local : (store -&gt; store) -&gt; &#39;a monad -&gt; &#39;a monad</code></pre>
<p><strong>Exception/error monads (parameterized by type
<code>excn</code>):</strong></p>
<pre><code>throw : excn -&gt; &#39;a monad
catch : &#39;a monad -&gt; (excn -&gt; &#39;a monad) -&gt; &#39;a monad</code></pre>
<p>These provide structured error handling within the monad. The
<code>throw</code> operation raises an exception; <code>catch</code>
handles it.</p>
<p><strong>Continuation monad:</strong></p>
<pre><code>callCC : ((&#39;a -&gt; &#39;b monad) -&gt; &#39;a monad) -&gt; &#39;a monad</code></pre>
<p>The continuation monad gives you access to the “rest of the
computation” as a first-class value. This is powerful but complex; we
will not cover continuations in detail here.</p>
<p><strong>Probabilistic computation:</strong></p>
<pre><code>choose : float -&gt; &#39;a monad -&gt; &#39;a monad -&gt; &#39;a monad</code></pre>
<p>The <code>choose p a b</code> operation selects <code>a</code> with
probability <code>p</code> and <code>b</code> with probability
<code>1-p</code>. This enables reasoning about probability
distributions. The laws ensure that probability behaves correctly:</p>
<p><span class="math display">
\begin{aligned}
a \oplus_0 b &amp;\approx b \\
a \oplus_p b &amp;\approx b \oplus_{1-p} a \\
a \oplus_p (b \oplus_q c) &amp;\approx (a \oplus_{\frac{p}{p+q-pq}} b)
\oplus_{p+q-pq} c \\
a \oplus_p a &amp;\approx a
\end{aligned}
</span></p>
<p><strong>Parallel computation (monad with access and parallel
bind):</strong></p>
<pre><code>parallel : &#39;a monad -&gt; &#39;b monad -&gt; (&#39;a -&gt; &#39;b -&gt; &#39;c monad) -&gt; &#39;c monad</code></pre>
<p>The <code>parallel</code> operation runs two computations
concurrently and combines their results. Example: lightweight threads
like in the Lwt library.</p>
<h2 id="interlude-the-module-system">8.8 Interlude: The Module
System</h2>
<p>Before we implement various monads, we need to understand OCaml’s
module system, which provides the infrastructure for defining monads in
a reusable, generic way. This section provides a brief overview of the
key concepts.</p>
<p>Modules collect related type definitions and operations together.
Module values are introduced with <code>struct ... end</code> (called
<em>structures</em>), and module types with <code>sig ... end</code>
(called <em>signatures</em>). A structure is a package of definitions; a
signature is an interface that specifies what a structure must
provide.</p>
<p>A source file <code>source.ml</code> defines a module
<code>Source</code>. A file <code>source.mli</code> defines its
type.</p>
<p>In the module level, modules are defined with
<code>module ModuleName = ...</code> or
<code>module ModuleName : MODULE_TYPE = ...</code>, and module types
with <code>module type MODULE_TYPE = ...</code>.</p>
<p>Locally in expressions, modules are defined with
<code>let module M = ... in ...</code>.</p>
<p>The content of a module is made visible with
<code>open Module</code>. Module <code>Pervasives</code> (now
<code>Stdlib</code>) is initially visible.</p>
<p>Content of a module is included into another module with
<code>include Module</code>.</p>
<p><strong>Functors</strong> are module functions – functions from
modules to modules. They are the key to writing generic code that works
with any monad:</p>
<pre><code>module Funct = functor (Arg : sig ... end) -&gt; struct ... end
(* Or equivalently: *)
module Funct (Arg : sig ... end) = struct ... end</code></pre>
<p>Functors can return functors, and modules can be parameterized by
multiple modules. Functor application always uses parentheses:
<code>Funct (struct ... end)</code>.</p>
<p>A signature <code>MODULE_TYPE with type t_name = ...</code> is like
<code>MODULE_TYPE</code> but with <code>t_name</code> made more
specific. This is useful when you want to expose the concrete type after
applying a functor. We can also include signatures with
<code>include MODULE_TYPE</code>.</p>
<p>Finally, we can pass around modules in normal functions using
first-class modules:</p>
<div class="sourceCode" id="cb291"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb291-1"><a href="#cb291-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">type</span> T = <span class="kw">sig</span> <span class="kw">val</span> g : <span class="dt">int</span> -&gt; <span class="dt">int</span> <span class="kw">end</span></span>
<span id="cb291-2"><a href="#cb291-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb291-3"><a href="#cb291-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f mod_v x =</span>
<span id="cb291-4"><a href="#cb291-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">module</span> M = (<span class="kw">val</span> mod_v : T) <span class="kw">in</span></span>
<span id="cb291-5"><a href="#cb291-5" aria-hidden="true" tabindex="-1"></a>  M.g x</span>
<span id="cb291-6"><a href="#cb291-6" aria-hidden="true" tabindex="-1"></a><span class="co">(* val f : (module T) -&gt; int -&gt; int = &lt;fun&gt; *)</span></span>
<span id="cb291-7"><a href="#cb291-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb291-8"><a href="#cb291-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> test = f (<span class="kw">module</span> <span class="kw">struct</span> <span class="kw">let</span> g i = i*i <span class="kw">end</span> : T)</span>
<span id="cb291-9"><a href="#cb291-9" aria-hidden="true" tabindex="-1"></a><span class="co">(* val test : int -&gt; int = &lt;fun&gt; *)</span></span></code></pre></div>
<h2 id="the-two-metaphors">8.9 The Two Metaphors</h2>
<p>Monads are abstract, but two complementary metaphors can help build
intuition for what they are and how they work.</p>
<h3 id="monads-as-containers">Monads as Containers</h3>
<p>The first metaphor views a monad as a <strong>quarantine
container</strong>. Think of it like a sealed box:</p>
<ul>
<li>We can put something into the container with <code>return</code> –
this “seals” a pure value inside the monad</li>
<li>We can operate on the contents, but the result must stay in the
container – we cannot simply extract values</li>
</ul>
<p>The <code>lift</code> function applies a pure function to the
contents of a monad, keeping the result wrapped:</p>
<div class="sourceCode" id="cb292"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb292-1"><a href="#cb292-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> lift f m =</span>
<span id="cb292-2"><a href="#cb292-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span>* x = m <span class="kw">in</span></span>
<span id="cb292-3"><a href="#cb292-3" aria-hidden="true" tabindex="-1"></a>  return (f x)</span>
<span id="cb292-4"><a href="#cb292-4" aria-hidden="true" tabindex="-1"></a><span class="co">(* val lift : (&#39;a -&gt; &#39;b) -&gt; &#39;a monad -&gt; &#39;b monad *)</span></span></code></pre></div>
<p>We can also “flatten” nested containers. If we have a monad
containing another monad, <code>join</code> unwraps one layer – but the
result is still in a monad, so the quarantine is not broken:</p>
<div class="sourceCode" id="cb293"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb293-1"><a href="#cb293-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> join m =</span>
<span id="cb293-2"><a href="#cb293-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span>* x = m <span class="kw">in</span></span>
<span id="cb293-3"><a href="#cb293-3" aria-hidden="true" tabindex="-1"></a>  x</span>
<span id="cb293-4"><a href="#cb293-4" aria-hidden="true" tabindex="-1"></a><span class="co">(* val join : (&#39;a monad) monad -&gt; &#39;a monad *)</span></span></code></pre></div>
<p>The quarantine container for a <strong>monad-plus</strong> is more
like a collection: it can be empty (failure), contain one element
(success), or contain multiple elements (multiple solutions).</p>
<p>Monads with access allow us to extract the resulting element from the
container. Other monads provide a <code>run</code> operation that
exposes “what really happened behind the quarantine” – for example, the
state monad’s <code>run</code> takes an initial state and returns both
the final value and the final state.</p>
<h3 id="monads-as-computation">Monads as Computation</h3>
<p>The second metaphor views a monad as a way to structure computation.
Each <code>let*</code> binding is a step in a sequence, and the monad
controls how steps are connected. The physical metaphor is an
<strong>assembly line</strong>:</p>
<pre><code>let assemblyLine w =
  let* c = makeChopsticks w in    (* Worker makes chopsticks *)
  let* c&#39; = polishChopsticks c in (* Worker polishes them *)
  let* c&#39;&#39; = wrapChopsticks c&#39; in (* Worker wraps them *)
  return c&#39;&#39;                       (* Final product goes out *)</code></pre>
<p>Each worker (operation) takes material from the previous step and
produces something for the next step. The monad defines what happens
between steps – for lists, it means “do this for each element”; for
state, it means “thread the state through”; for exceptions, it means
“propagate errors.”</p>
<p>Any expression can be systematically translated into a monadic form.
For lambda-terms:</p>
<p><span class="math display">
\begin{aligned}
[\![ N ]\!] &amp;= \text{return}\ N &amp; \text{(constant)} \\
[\![ x ]\!] &amp;= \text{return}\ x &amp; \text{(variable)} \\
[\![ \lambda x.a ]\!] &amp;= \text{return}\ (\lambda x.[\![ a ]\!])
&amp; \text{(function)} \\
[\![ \text{let}\ x = a\ \text{in}\ b ]\!] &amp;= \text{bind}\ [\![ a
]\!]\ (\lambda x.[\![ b ]\!]) &amp; \text{(local definition)} \\
[\![ a\ b ]\!] &amp;= \text{bind}\ [\![ a ]\!]\ (\lambda
v_a.\text{bind}\ [\![ b ]\!]\ (\lambda v_b.v_a\ v_b)) &amp;
\text{(application)}
\end{aligned}
</span></p>
<p>This translation inserts <code>bind</code> at every point where
execution flows from one subexpression to another. The beauty of this
approach is that once an expression is spread over a monad, its
computation can be monitored, logged, or affected without modifying the
expression itself. This is the key to implementing effects like state,
exceptions, or non-determinism in a purely functional way.</p>
<h2 id="monad-classes-and-instances">8.10 Monad Classes and
Instances</h2>
<p>Now we will see how to implement monads in OCaml using the module
system. To implement a monad, we need to provide the implementation
type, <code>return</code>, and <code>bind</code> operations. Here is the
minimal signature:</p>
<div class="sourceCode" id="cb295"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb295-1"><a href="#cb295-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">type</span> MONAD = <span class="kw">sig</span></span>
<span id="cb295-2"><a href="#cb295-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a t</span>
<span id="cb295-3"><a href="#cb295-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> return : &#39;a -&gt; &#39;a t</span>
<span id="cb295-4"><a href="#cb295-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> bind : &#39;a t -&gt; (&#39;a -&gt; &#39;b t) -&gt; &#39;b t</span>
<span id="cb295-5"><a href="#cb295-5" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>This is the “class” that all monads must implement. Alternatively, we
could start from <code>return</code>, <code>lift</code>, and
<code>join</code> operations – these are mathematically equivalent
starting points.</p>
<p>The power of functors is that we can define a suite of
general-purpose functions that work for <em>any</em> monad, just based
on these two operations:</p>
<div class="sourceCode" id="cb296"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb296-1"><a href="#cb296-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">type</span> MONAD_OPS = <span class="kw">sig</span></span>
<span id="cb296-2"><a href="#cb296-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a monad</span>
<span id="cb296-3"><a href="#cb296-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> MONAD <span class="kw">with</span> <span class="kw">type</span> &#39;a t := &#39;a monad</span>
<span id="cb296-4"><a href="#cb296-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> ( <span class="kw">let</span>* ) : &#39;a monad -&gt; (&#39;a -&gt; &#39;b monad) -&gt; &#39;b monad</span>
<span id="cb296-5"><a href="#cb296-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> ( <span class="kw">let</span>+ ) : &#39;a monad -&gt; (&#39;a -&gt; &#39;b) -&gt; &#39;b monad</span>
<span id="cb296-6"><a href="#cb296-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> ( &gt;&gt;= ) : &#39;a monad -&gt; (&#39;a -&gt; &#39;b monad) -&gt; &#39;b monad</span>
<span id="cb296-7"><a href="#cb296-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> foldM : (&#39;a -&gt; &#39;b -&gt; &#39;a monad) -&gt; &#39;a -&gt; &#39;b <span class="dt">list</span> -&gt; &#39;a monad</span>
<span id="cb296-8"><a href="#cb296-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> whenM : <span class="dt">bool</span> -&gt; <span class="dt">unit</span> monad -&gt; <span class="dt">unit</span> monad</span>
<span id="cb296-9"><a href="#cb296-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> lift : (&#39;a -&gt; &#39;b) -&gt; &#39;a monad -&gt; &#39;b monad</span>
<span id="cb296-10"><a href="#cb296-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> (&gt;&gt;|) : &#39;a monad -&gt; (&#39;a -&gt; &#39;b) -&gt; &#39;b monad</span>
<span id="cb296-11"><a href="#cb296-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> join : &#39;a monad monad -&gt; &#39;a monad</span>
<span id="cb296-12"><a href="#cb296-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> ( &gt;=&gt;) : (&#39;a -&gt; &#39;b monad) -&gt; (&#39;b -&gt; &#39;c monad) -&gt; &#39;a -&gt; &#39;c monad</span>
<span id="cb296-13"><a href="#cb296-13" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb296-14"><a href="#cb296-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb296-15"><a href="#cb296-15" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> MonadOps (M : MONAD) = <span class="kw">struct</span></span>
<span id="cb296-16"><a href="#cb296-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">open</span> M</span>
<span id="cb296-17"><a href="#cb296-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a monad = &#39;a t</span>
<span id="cb296-18"><a href="#cb296-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> run x = x</span>
<span id="cb296-19"><a href="#cb296-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ( <span class="kw">let</span>* ) a b = bind a b</span>
<span id="cb296-20"><a href="#cb296-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ( <span class="kw">let</span>+ ) a f = bind a (<span class="kw">fun</span> x -&gt; return (f x))</span>
<span id="cb296-21"><a href="#cb296-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (&gt;&gt;=) a b = bind a b</span>
<span id="cb296-22"><a href="#cb296-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> foldM f a = <span class="kw">function</span></span>
<span id="cb296-23"><a href="#cb296-23" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; return a</span>
<span id="cb296-24"><a href="#cb296-24" aria-hidden="true" tabindex="-1"></a>    | x::xs -&gt;</span>
<span id="cb296-25"><a href="#cb296-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span>* a&#39; = f a x <span class="kw">in</span></span>
<span id="cb296-26"><a href="#cb296-26" aria-hidden="true" tabindex="-1"></a>        foldM f a&#39; xs</span>
<span id="cb296-27"><a href="#cb296-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> whenM p s = <span class="kw">if</span> p <span class="kw">then</span> s <span class="kw">else</span> return ()</span>
<span id="cb296-28"><a href="#cb296-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> lift f m =</span>
<span id="cb296-29"><a href="#cb296-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* x = m <span class="kw">in</span></span>
<span id="cb296-30"><a href="#cb296-30" aria-hidden="true" tabindex="-1"></a>    return (f x)</span>
<span id="cb296-31"><a href="#cb296-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (&gt;&gt;|) a b = lift b a</span>
<span id="cb296-32"><a href="#cb296-32" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> join m =</span>
<span id="cb296-33"><a href="#cb296-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* x = m <span class="kw">in</span></span>
<span id="cb296-34"><a href="#cb296-34" aria-hidden="true" tabindex="-1"></a>    x</span>
<span id="cb296-35"><a href="#cb296-35" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (&gt;=&gt;) f g = <span class="kw">fun</span> x -&gt;</span>
<span id="cb296-36"><a href="#cb296-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* y = f x <span class="kw">in</span></span>
<span id="cb296-37"><a href="#cb296-37" aria-hidden="true" tabindex="-1"></a>    g y</span>
<span id="cb296-38"><a href="#cb296-38" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>We make the monad “safe” by keeping its type abstract. The
<code>run</code> function exposes the underlying representation – “what
really happened behind the scenes”:</p>
<div class="sourceCode" id="cb297"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb297-1"><a href="#cb297-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Monad (M : MONAD) : <span class="kw">sig</span></span>
<span id="cb297-2"><a href="#cb297-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> MONAD_OPS</span>
<span id="cb297-3"><a href="#cb297-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> run : &#39;a monad -&gt; &#39;a M.t</span>
<span id="cb297-4"><a href="#cb297-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span> = <span class="kw">struct</span></span>
<span id="cb297-5"><a href="#cb297-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> M</span>
<span id="cb297-6"><a href="#cb297-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> MonadOps(M)</span>
<span id="cb297-7"><a href="#cb297-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>The pattern here is important: we take a minimal implementation
(<code>M : MONAD</code>) and produce a full-featured monad module with
all the derived operations.</p>
<h3 id="monad-plus-classes">Monad-Plus Classes</h3>
<p>The monad-plus class extends the basic monad with failure and choice.
Implementations need to provide <code>mzero</code> and
<code>mplus</code> in addition to <code>return</code> and
<code>bind</code>:</p>
<div class="sourceCode" id="cb298"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb298-1"><a href="#cb298-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">type</span> MONAD_PLUS = <span class="kw">sig</span></span>
<span id="cb298-2"><a href="#cb298-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> MONAD</span>
<span id="cb298-3"><a href="#cb298-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> mzero : &#39;a t</span>
<span id="cb298-4"><a href="#cb298-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> mplus : &#39;a t -&gt; &#39;a t -&gt; &#39;a t</span>
<span id="cb298-5"><a href="#cb298-5" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb298-6"><a href="#cb298-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-7"><a href="#cb298-7" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">type</span> MONAD_PLUS_OPS = <span class="kw">sig</span></span>
<span id="cb298-8"><a href="#cb298-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> MONAD_OPS</span>
<span id="cb298-9"><a href="#cb298-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> mzero : &#39;a monad</span>
<span id="cb298-10"><a href="#cb298-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> mplus : &#39;a monad -&gt; &#39;a monad -&gt; &#39;a monad</span>
<span id="cb298-11"><a href="#cb298-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> fail : &#39;a monad</span>
<span id="cb298-12"><a href="#cb298-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> (++) : &#39;a monad -&gt; &#39;a monad -&gt; &#39;a monad</span>
<span id="cb298-13"><a href="#cb298-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> guard : <span class="dt">bool</span> -&gt; <span class="dt">unit</span> monad</span>
<span id="cb298-14"><a href="#cb298-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> msum_map : (&#39;a -&gt; &#39;b monad) -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;b monad</span>
<span id="cb298-15"><a href="#cb298-15" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb298-16"><a href="#cb298-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-17"><a href="#cb298-17" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> MonadPlusOps (M : MONAD_PLUS) = <span class="kw">struct</span></span>
<span id="cb298-18"><a href="#cb298-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">open</span> M</span>
<span id="cb298-19"><a href="#cb298-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> MonadOps(M)</span>
<span id="cb298-20"><a href="#cb298-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> fail = mzero</span>
<span id="cb298-21"><a href="#cb298-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (++) a b = mplus a b</span>
<span id="cb298-22"><a href="#cb298-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> guard p = <span class="kw">if</span> p <span class="kw">then</span> return () <span class="kw">else</span> fail</span>
<span id="cb298-23"><a href="#cb298-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> msum_map f l = <span class="dt">List</span>.fold_right</span>
<span id="cb298-24"><a href="#cb298-24" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">fun</span> a acc -&gt; mplus (f a) acc) l mzero</span>
<span id="cb298-25"><a href="#cb298-25" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb298-26"><a href="#cb298-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-27"><a href="#cb298-27" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> MonadPlus (M : MONAD_PLUS) : <span class="kw">sig</span></span>
<span id="cb298-28"><a href="#cb298-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> MONAD_PLUS_OPS</span>
<span id="cb298-29"><a href="#cb298-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> run : &#39;a monad -&gt; &#39;a M.t</span>
<span id="cb298-30"><a href="#cb298-30" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span> = <span class="kw">struct</span></span>
<span id="cb298-31"><a href="#cb298-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> M</span>
<span id="cb298-32"><a href="#cb298-32" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> MonadPlusOps(M)</span>
<span id="cb298-33"><a href="#cb298-33" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>We also need a class for computations with state. This signature will
be included in state monads:</p>
<div class="sourceCode" id="cb299"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb299-1"><a href="#cb299-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">type</span> STATE = <span class="kw">sig</span></span>
<span id="cb299-2"><a href="#cb299-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> store</span>
<span id="cb299-3"><a href="#cb299-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a t</span>
<span id="cb299-4"><a href="#cb299-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> get : store t</span>
<span id="cb299-5"><a href="#cb299-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> put : store -&gt; <span class="dt">unit</span> t</span>
<span id="cb299-6"><a href="#cb299-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="monad-instances">8.11 Monad Instances</h2>
<p>Now let us see concrete implementations of various monads.</p>
<h3 id="the-lazy-monad">The Lazy Monad</h3>
<p>If you find OCaml’s laziness notation (with <code>lazy</code> and
<code>Lazy.force</code> everywhere) too heavy, you can use a monad! The
lazy monad wraps lazy computations:</p>
<div class="sourceCode" id="cb300"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb300-1"><a href="#cb300-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> LazyM = Monad (<span class="kw">struct</span></span>
<span id="cb300-2"><a href="#cb300-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a t = &#39;a <span class="dt">Lazy</span>.t</span>
<span id="cb300-3"><a href="#cb300-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> bind a b = <span class="kw">lazy</span> (<span class="dt">Lazy</span>.force (b (<span class="dt">Lazy</span>.force a)))</span>
<span id="cb300-4"><a href="#cb300-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> return a = <span class="kw">lazy</span> a</span>
<span id="cb300-5"><a href="#cb300-5" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>)</span>
<span id="cb300-6"><a href="#cb300-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb300-7"><a href="#cb300-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> laccess m = <span class="dt">Lazy</span>.force (LazyM.run m)</span></code></pre></div>
<p>The <code>bind</code> operation creates a new lazy value that, when
forced, forces <code>a</code>, passes the result to <code>b</code>, and
forces the result. The <code>laccess</code> function forces the final
lazy value to get the result.</p>
<h3 id="the-list-monad">The List Monad</h3>
<p>Our familiar list monad is a monad-plus, supporting non-deterministic
computation:</p>
<div class="sourceCode" id="cb301"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb301-1"><a href="#cb301-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> ListM = MonadPlus (<span class="kw">struct</span></span>
<span id="cb301-2"><a href="#cb301-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a t = &#39;a <span class="dt">list</span></span>
<span id="cb301-3"><a href="#cb301-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> bind a b = concat_map b a</span>
<span id="cb301-4"><a href="#cb301-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> return a = [a]</span>
<span id="cb301-5"><a href="#cb301-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> mzero = []</span>
<span id="cb301-6"><a href="#cb301-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> mplus = <span class="dt">List</span>.append</span>
<span id="cb301-7"><a href="#cb301-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>)</span></code></pre></div>
<h3 id="backtracking-parameterized-by-monad-plus">Backtracking
Parameterized by Monad-Plus</h3>
<p>Here is the power of abstraction: we can write the Countdown solver
parameterized by <em>any</em> monad-plus. The same code works with lists
(exploring all solutions), lazy lists (computing solutions on demand),
or any other monad-plus implementation:</p>
<div class="sourceCode" id="cb302"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb302-1"><a href="#cb302-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Countdown (M : MONAD_PLUS_OPS) = <span class="kw">struct</span></span>
<span id="cb302-2"><a href="#cb302-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">open</span> M  <span class="co">(* Open the module to make monad operations visible *)</span></span>
<span id="cb302-3"><a href="#cb302-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb302-4"><a href="#cb302-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> insert x = <span class="kw">function</span>  <span class="co">(* All choice-introducing operations *)</span></span>
<span id="cb302-5"><a href="#cb302-5" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; return [x]          <span class="co">(* need to happen in the monad *)</span></span>
<span id="cb302-6"><a href="#cb302-6" aria-hidden="true" tabindex="-1"></a>    | y::ys <span class="kw">as</span> xs -&gt;</span>
<span id="cb302-7"><a href="#cb302-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span>* xys = insert x ys <span class="kw">in</span></span>
<span id="cb302-8"><a href="#cb302-8" aria-hidden="true" tabindex="-1"></a>        return (x::xs) ++ return (y::xys)</span>
<span id="cb302-9"><a href="#cb302-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb302-10"><a href="#cb302-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> choices = <span class="kw">function</span></span>
<span id="cb302-11"><a href="#cb302-11" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; return []</span>
<span id="cb302-12"><a href="#cb302-12" aria-hidden="true" tabindex="-1"></a>    | x::xs -&gt;</span>
<span id="cb302-13"><a href="#cb302-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span>* cxs = choices xs <span class="kw">in</span>           <span class="co">(* Choosing which numbers in what order *)</span></span>
<span id="cb302-14"><a href="#cb302-14" aria-hidden="true" tabindex="-1"></a>        return cxs ++ insert x cxs         <span class="co">(* and now whether with or without x *)</span></span>
<span id="cb302-15"><a href="#cb302-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb302-16"><a href="#cb302-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> op = Add | Sub | Mul | Div</span>
<span id="cb302-17"><a href="#cb302-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb302-18"><a href="#cb302-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> apply op x y =</span>
<span id="cb302-19"><a href="#cb302-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> op <span class="kw">with</span></span>
<span id="cb302-20"><a href="#cb302-20" aria-hidden="true" tabindex="-1"></a>    | Add -&gt; x + y</span>
<span id="cb302-21"><a href="#cb302-21" aria-hidden="true" tabindex="-1"></a>    | Sub -&gt; x - y</span>
<span id="cb302-22"><a href="#cb302-22" aria-hidden="true" tabindex="-1"></a>    | Mul -&gt; x * y</span>
<span id="cb302-23"><a href="#cb302-23" aria-hidden="true" tabindex="-1"></a>    | Div -&gt; x / y</span>
<span id="cb302-24"><a href="#cb302-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb302-25"><a href="#cb302-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> valid op x y =</span>
<span id="cb302-26"><a href="#cb302-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> op <span class="kw">with</span></span>
<span id="cb302-27"><a href="#cb302-27" aria-hidden="true" tabindex="-1"></a>    | Add -&gt; x &lt;= y</span>
<span id="cb302-28"><a href="#cb302-28" aria-hidden="true" tabindex="-1"></a>    | Sub -&gt; x &gt; y</span>
<span id="cb302-29"><a href="#cb302-29" aria-hidden="true" tabindex="-1"></a>    | Mul -&gt; x &lt;= y &amp;&amp; x &lt;&gt; <span class="dv">1</span> &amp;&amp; y &lt;&gt; <span class="dv">1</span></span>
<span id="cb302-30"><a href="#cb302-30" aria-hidden="true" tabindex="-1"></a>    | Div -&gt; x <span class="kw">mod</span> y = <span class="dv">0</span> &amp;&amp; y &lt;&gt; <span class="dv">1</span></span>
<span id="cb302-31"><a href="#cb302-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb302-32"><a href="#cb302-32" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> expr = Val <span class="kw">of</span> <span class="dt">int</span> | App <span class="kw">of</span> op * expr * expr</span>
<span id="cb302-33"><a href="#cb302-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb302-34"><a href="#cb302-34" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> op2str = <span class="kw">function</span></span>
<span id="cb302-35"><a href="#cb302-35" aria-hidden="true" tabindex="-1"></a>    | Add -&gt; <span class="st">&quot;+&quot;</span> | Sub -&gt; <span class="st">&quot;-&quot;</span> | Mul -&gt; <span class="st">&quot;*&quot;</span> | Div -&gt; <span class="st">&quot;/&quot;</span></span>
<span id="cb302-36"><a href="#cb302-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb302-37"><a href="#cb302-37" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> expr2str = <span class="kw">function</span>  <span class="co">(* We will provide solutions as strings *)</span></span>
<span id="cb302-38"><a href="#cb302-38" aria-hidden="true" tabindex="-1"></a>    | Val n -&gt; <span class="dt">string_of_int</span> n</span>
<span id="cb302-39"><a href="#cb302-39" aria-hidden="true" tabindex="-1"></a>    | App (op, l, r) -&gt; <span class="st">&quot;(&quot;</span> ^ expr2str l ^ op2str op ^ expr2str r ^ <span class="st">&quot;)&quot;</span></span>
<span id="cb302-40"><a href="#cb302-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb302-41"><a href="#cb302-41" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> combine (l, x) (r, y) o =  <span class="co">(* Try out an operator *)</span></span>
<span id="cb302-42"><a href="#cb302-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* () = guard (valid o x y) <span class="kw">in</span></span>
<span id="cb302-43"><a href="#cb302-43" aria-hidden="true" tabindex="-1"></a>    return (App (o, l, r), apply o x y)</span>
<span id="cb302-44"><a href="#cb302-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb302-45"><a href="#cb302-45" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> split l =  <span class="co">(* Another choice: which numbers go into which argument *)</span></span>
<span id="cb302-46"><a href="#cb302-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">rec</span> aux lhs = <span class="kw">function</span></span>
<span id="cb302-47"><a href="#cb302-47" aria-hidden="true" tabindex="-1"></a>      | [] | [_] -&gt; fail                    <span class="co">(* Both arguments need numbers *)</span></span>
<span id="cb302-48"><a href="#cb302-48" aria-hidden="true" tabindex="-1"></a>      | [y; z] -&gt; return (<span class="dt">List</span>.rev (y::lhs), [z])</span>
<span id="cb302-49"><a href="#cb302-49" aria-hidden="true" tabindex="-1"></a>      | hd::rhs -&gt;</span>
<span id="cb302-50"><a href="#cb302-50" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> lhs = hd::lhs <span class="kw">in</span></span>
<span id="cb302-51"><a href="#cb302-51" aria-hidden="true" tabindex="-1"></a>          return (<span class="dt">List</span>.rev lhs, rhs)</span>
<span id="cb302-52"><a href="#cb302-52" aria-hidden="true" tabindex="-1"></a>            ++ aux lhs rhs <span class="kw">in</span></span>
<span id="cb302-53"><a href="#cb302-53" aria-hidden="true" tabindex="-1"></a>    aux [] l</span>
<span id="cb302-54"><a href="#cb302-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb302-55"><a href="#cb302-55" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> results = <span class="kw">function</span>  <span class="co">(* Build possible expressions once numbers *)</span></span>
<span id="cb302-56"><a href="#cb302-56" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; fail                <span class="co">(* have been picked *)</span></span>
<span id="cb302-57"><a href="#cb302-57" aria-hidden="true" tabindex="-1"></a>    | [n] -&gt;</span>
<span id="cb302-58"><a href="#cb302-58" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span>* () = guard (n &gt; <span class="dv">0</span>) <span class="kw">in</span></span>
<span id="cb302-59"><a href="#cb302-59" aria-hidden="true" tabindex="-1"></a>        return (Val n, n)</span>
<span id="cb302-60"><a href="#cb302-60" aria-hidden="true" tabindex="-1"></a>    | ns -&gt;</span>
<span id="cb302-61"><a href="#cb302-61" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span>* (ls, rs) = split ns <span class="kw">in</span></span>
<span id="cb302-62"><a href="#cb302-62" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span>* lx = results ls <span class="kw">in</span></span>
<span id="cb302-63"><a href="#cb302-63" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span>* ly = results rs <span class="kw">in</span>  <span class="co">(* Collect solutions using each operator *)</span></span>
<span id="cb302-64"><a href="#cb302-64" aria-hidden="true" tabindex="-1"></a>        msum_map (combine lx ly) [Add; Sub; Mul; Div]</span>
<span id="cb302-65"><a href="#cb302-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb302-66"><a href="#cb302-66" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> solutions ns n =  <span class="co">(* Solve the problem: *)</span></span>
<span id="cb302-67"><a href="#cb302-67" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* ns&#39; = choices ns <span class="kw">in</span>         <span class="co">(* pick numbers and their order, *)</span></span>
<span id="cb302-68"><a href="#cb302-68" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* (e, m) = results ns&#39; <span class="kw">in</span>     <span class="co">(* build possible expressions, *)</span></span>
<span id="cb302-69"><a href="#cb302-69" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* () = guard (m = n) <span class="kw">in</span>       <span class="co">(* check if the expression gives target value, *)</span></span>
<span id="cb302-70"><a href="#cb302-70" aria-hidden="true" tabindex="-1"></a>    return (expr2str e)              <span class="co">(* &quot;print&quot; the solution *)</span></span>
<span id="cb302-71"><a href="#cb302-71" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<h3 id="understanding-laziness">Understanding Laziness</h3>
<p>Now let us explore a practical question: what if we only want
<em>one</em> solution, not all of them? With the list monad, we compute
all solutions even if we only look at the first one. Can laziness
help?</p>
<p>Let us sketch how you might measure execution times to find out (the
numbers will vary wildly between machines, and the full Countdown search
is expensive enough that it is better left out of mdx tests):</p>
<div class="sourceCode" id="cb303"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb303-1"><a href="#cb303-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> time f =</span>
<span id="cb303-2"><a href="#cb303-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> tbeg = <span class="dt">Sys</span>.time () <span class="kw">in</span></span>
<span id="cb303-3"><a href="#cb303-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> res = f () <span class="kw">in</span></span>
<span id="cb303-4"><a href="#cb303-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> tend = <span class="dt">Sys</span>.time () <span class="kw">in</span></span>
<span id="cb303-5"><a href="#cb303-5" aria-hidden="true" tabindex="-1"></a>  tend -. tbeg, res</span></code></pre></div>
<p>With the list monad:</p>
<div class="sourceCode" id="cb304"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb304-1"><a href="#cb304-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> ListCountdown = Countdown (ListM)</span>
<span id="cb304-2"><a href="#cb304-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> test1 () = ListM.run (ListCountdown.solutions [<span class="dv">1</span>;<span class="dv">3</span>;<span class="dv">7</span>;<span class="dv">10</span>;<span class="dv">25</span>;<span class="dv">50</span>] <span class="dv">765</span>)</span>
<span id="cb304-3"><a href="#cb304-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> t1, sol1 = time test1</span>
<span id="cb304-4"><a href="#cb304-4" aria-hidden="true" tabindex="-1"></a><span class="co">(* val t1 : float = 2.28... *)</span></span>
<span id="cb304-5"><a href="#cb304-5" aria-hidden="true" tabindex="-1"></a><span class="co">(* val sol1 : string list = [&quot;((25-(3+7))*(1+50))&quot;; &quot;(((25-3)-7)*(1+50))&quot;; ...] *)</span></span></code></pre></div>
<p>Finding all 49 solutions takes about 2.3 seconds. What if we want
only one solution? Laziness to the rescue!</p>
<p>Our first attempt uses an “odd lazy list” – a list where the tail is
lazy but the head is strict:</p>
<div class="sourceCode" id="cb305"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb305-1"><a href="#cb305-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a llist = LNil | LCons <span class="kw">of</span> &#39;a * &#39;a llist <span class="dt">Lazy</span>.t</span>
<span id="cb305-2"><a href="#cb305-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb305-3"><a href="#cb305-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> ltake n = <span class="kw">function</span></span>
<span id="cb305-4"><a href="#cb305-4" aria-hidden="true" tabindex="-1"></a>  | LCons (a, <span class="kw">lazy</span> l) <span class="kw">when</span> n &gt; <span class="dv">0</span> -&gt; a::(ltake (n<span class="dv">-1</span>) l)</span>
<span id="cb305-5"><a href="#cb305-5" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; []</span>
<span id="cb305-6"><a href="#cb305-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb305-7"><a href="#cb305-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> lappend l1 l2 =</span>
<span id="cb305-8"><a href="#cb305-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> l1 <span class="kw">with</span></span>
<span id="cb305-9"><a href="#cb305-9" aria-hidden="true" tabindex="-1"></a>  | LNil -&gt; l2</span>
<span id="cb305-10"><a href="#cb305-10" aria-hidden="true" tabindex="-1"></a>  | LCons (hd, tl) -&gt;</span>
<span id="cb305-11"><a href="#cb305-11" aria-hidden="true" tabindex="-1"></a>      LCons (hd, <span class="kw">lazy</span> (lappend (<span class="dt">Lazy</span>.force tl) l2))</span>
<span id="cb305-12"><a href="#cb305-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb305-13"><a href="#cb305-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> lconcat_map f = <span class="kw">function</span></span>
<span id="cb305-14"><a href="#cb305-14" aria-hidden="true" tabindex="-1"></a>  | LNil -&gt; LNil</span>
<span id="cb305-15"><a href="#cb305-15" aria-hidden="true" tabindex="-1"></a>  | LCons (a, <span class="kw">lazy</span> l) -&gt;</span>
<span id="cb305-16"><a href="#cb305-16" aria-hidden="true" tabindex="-1"></a>      lappend (f a) (lconcat_map f l)</span>
<span id="cb305-17"><a href="#cb305-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb305-18"><a href="#cb305-18" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> LListM = MonadPlus (<span class="kw">struct</span></span>
<span id="cb305-19"><a href="#cb305-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a t = &#39;a llist</span>
<span id="cb305-20"><a href="#cb305-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> bind a b = lconcat_map b a</span>
<span id="cb305-21"><a href="#cb305-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> return a = LCons (a, <span class="kw">lazy</span> LNil)</span>
<span id="cb305-22"><a href="#cb305-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> mzero = LNil</span>
<span id="cb305-23"><a href="#cb305-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> mplus = lappend</span>
<span id="cb305-24"><a href="#cb305-24" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>)</span></code></pre></div>
<p>But testing shows disappointing results: the odd lazy list still
takes about 2.5 seconds just to create the lazy list! The elements are
almost all computed by the time we get the first one.</p>
<p>Why? Because whenever we pattern match on
<code>LCons (hd, tl)</code>, we have already evaluated the head. And
when building lists with <code>mplus</code>, the head of the first list
is computed immediately.</p>
<p>What about using the <strong>option monad</strong> to find just the
first solution?</p>
<div class="sourceCode" id="cb306"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb306-1"><a href="#cb306-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> OptionM = MonadPlus (<span class="kw">struct</span></span>
<span id="cb306-2"><a href="#cb306-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a t = &#39;a <span class="dt">option</span></span>
<span id="cb306-3"><a href="#cb306-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> bind a b =</span>
<span id="cb306-4"><a href="#cb306-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> a <span class="kw">with</span> <span class="dt">None</span> -&gt; <span class="dt">None</span> | <span class="dt">Some</span> x -&gt; b x</span>
<span id="cb306-5"><a href="#cb306-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> return a = <span class="dt">Some</span> a</span>
<span id="cb306-6"><a href="#cb306-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> mzero = <span class="dt">None</span></span>
<span id="cb306-7"><a href="#cb306-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> mplus a b = <span class="kw">match</span> a <span class="kw">with</span> <span class="dt">None</span> -&gt; b | <span class="dt">Some</span> _ -&gt; a</span>
<span id="cb306-8"><a href="#cb306-8" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>)</span></code></pre></div>
<p>This very quickly computes… nothing! The option monad returns
<code>None</code>.</p>
<p>Why? The <code>OptionM</code> monad (Haskell’s <code>Maybe</code>
monad) is good for computations that might fail, but it does not
<em>search</em> – its <code>mplus</code> just picks the first
non-<code>None</code> value. Since our search often needs to backtrack
when a choice leads to failure, option gives up too early.</p>
<p>Our odd lazy list type is not lazy <em>enough</em>. Whenever we
“make” a choice with <code>a ++ b</code> or <code>msum_map</code>, it
computes the first candidate for each choice path immediately. We need
<strong>even lazy lists</strong> – lists where even the outermost
constructor is wrapped in <code>lazy</code>:</p>
<div class="sourceCode" id="cb307"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb307-1"><a href="#cb307-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a lazy_list = &#39;a lazy_list_ <span class="dt">Lazy</span>.t</span>
<span id="cb307-2"><a href="#cb307-2" aria-hidden="true" tabindex="-1"></a><span class="kw">and</span> &#39;a lazy_list_ = LazNil | LazCons <span class="kw">of</span> &#39;a * &#39;a lazy_list</span>
<span id="cb307-3"><a href="#cb307-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb307-4"><a href="#cb307-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> laztake n = <span class="kw">function</span></span>
<span id="cb307-5"><a href="#cb307-5" aria-hidden="true" tabindex="-1"></a>  | <span class="kw">lazy</span> (LazCons (a, l)) <span class="kw">when</span> n &gt; <span class="dv">0</span> -&gt; a::(laztake (n<span class="dv">-1</span>) l)</span>
<span id="cb307-6"><a href="#cb307-6" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; []</span>
<span id="cb307-7"><a href="#cb307-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb307-8"><a href="#cb307-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> append_aux l1 l2 =</span>
<span id="cb307-9"><a href="#cb307-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> l1 <span class="kw">with</span></span>
<span id="cb307-10"><a href="#cb307-10" aria-hidden="true" tabindex="-1"></a>  | <span class="kw">lazy</span> LazNil -&gt; <span class="dt">Lazy</span>.force l2</span>
<span id="cb307-11"><a href="#cb307-11" aria-hidden="true" tabindex="-1"></a>  | <span class="kw">lazy</span> (LazCons (hd, tl)) -&gt;</span>
<span id="cb307-12"><a href="#cb307-12" aria-hidden="true" tabindex="-1"></a>      LazCons (hd, <span class="kw">lazy</span> (append_aux tl l2))</span>
<span id="cb307-13"><a href="#cb307-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb307-14"><a href="#cb307-14" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> lazappend l1 l2 = <span class="kw">lazy</span> (append_aux l1 l2)</span>
<span id="cb307-15"><a href="#cb307-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb307-16"><a href="#cb307-16" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> concat_map_aux f = <span class="kw">function</span></span>
<span id="cb307-17"><a href="#cb307-17" aria-hidden="true" tabindex="-1"></a>  | <span class="kw">lazy</span> LazNil -&gt; LazNil</span>
<span id="cb307-18"><a href="#cb307-18" aria-hidden="true" tabindex="-1"></a>  | <span class="kw">lazy</span> (LazCons (a, l)) -&gt;</span>
<span id="cb307-19"><a href="#cb307-19" aria-hidden="true" tabindex="-1"></a>      append_aux (f a) (<span class="kw">lazy</span> (concat_map_aux f l))</span>
<span id="cb307-20"><a href="#cb307-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb307-21"><a href="#cb307-21" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> lazconcat_map f l = <span class="kw">lazy</span> (concat_map_aux f l)</span>
<span id="cb307-22"><a href="#cb307-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb307-23"><a href="#cb307-23" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> LazyListM = MonadPlus (<span class="kw">struct</span></span>
<span id="cb307-24"><a href="#cb307-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a t = &#39;a lazy_list</span>
<span id="cb307-25"><a href="#cb307-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> bind a b = lazconcat_map b a</span>
<span id="cb307-26"><a href="#cb307-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> return a = <span class="kw">lazy</span> (LazCons (a, <span class="kw">lazy</span> LazNil))</span>
<span id="cb307-27"><a href="#cb307-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> mzero = <span class="kw">lazy</span> LazNil</span>
<span id="cb307-28"><a href="#cb307-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> mplus = lazappend</span>
<span id="cb307-29"><a href="#cb307-29" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>)</span></code></pre></div>
<p>Now the first solution takes only about 0.37 seconds – considerably
less time than the 2.3 seconds for all solutions! The next 9 solutions
are almost computed once the first one is (just 0.23 seconds more). But
computing all 49 solutions takes about 4 seconds – nearly twice as long
as without laziness. This is the price we pay for lazy computation:
overhead when we do need all results.</p>
<p>The lesson: even lazy lists enable true lazy search, but they come
with overhead. Choose the right monad for your use case.</p>
<h3 id="the-exception-monad">The Exception Monad</h3>
<p>OCaml has built-in exceptions that are efficient and flexible.
However, monadic exceptions have advantages in certain situations:</p>
<ul>
<li>They are safer in multi-threading contexts (no risk of unhandled
exceptions escaping)</li>
<li>They compose well with other monads (via monad transformers)</li>
<li>They make the possibility of failure explicit in the type</li>
</ul>
<p>The monadic lightweight-thread library Lwt has <code>throw</code>
(called <code>fail</code> there) and <code>catch</code> operations in
its monad for exactly these reasons.</p>
<div class="sourceCode" id="cb308"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb308-1"><a href="#cb308-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> ExceptionM (Excn : <span class="kw">sig</span> <span class="kw">type</span> t <span class="kw">end</span>) : <span class="kw">sig</span></span>
<span id="cb308-2"><a href="#cb308-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> excn = Excn.t</span>
<span id="cb308-3"><a href="#cb308-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a t = OK <span class="kw">of</span> &#39;a | Bad <span class="kw">of</span> excn</span>
<span id="cb308-4"><a href="#cb308-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> MONAD_OPS</span>
<span id="cb308-5"><a href="#cb308-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> run : &#39;a monad -&gt; &#39;a t</span>
<span id="cb308-6"><a href="#cb308-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> throw : excn -&gt; &#39;a monad</span>
<span id="cb308-7"><a href="#cb308-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> catch : &#39;a monad -&gt; (excn -&gt; &#39;a monad) -&gt; &#39;a monad</span>
<span id="cb308-8"><a href="#cb308-8" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span> = <span class="kw">struct</span></span>
<span id="cb308-9"><a href="#cb308-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> excn = Excn.t</span>
<span id="cb308-10"><a href="#cb308-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">module</span> M = <span class="kw">struct</span></span>
<span id="cb308-11"><a href="#cb308-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> &#39;a t = OK <span class="kw">of</span> &#39;a | Bad <span class="kw">of</span> excn</span>
<span id="cb308-12"><a href="#cb308-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> return a = OK a</span>
<span id="cb308-13"><a href="#cb308-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> bind m b = <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb308-14"><a href="#cb308-14" aria-hidden="true" tabindex="-1"></a>      | OK a -&gt; b a</span>
<span id="cb308-15"><a href="#cb308-15" aria-hidden="true" tabindex="-1"></a>      | Bad e -&gt; Bad e</span>
<span id="cb308-16"><a href="#cb308-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end</span></span>
<span id="cb308-17"><a href="#cb308-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> M</span>
<span id="cb308-18"><a href="#cb308-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> MonadOps(M)</span>
<span id="cb308-19"><a href="#cb308-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> throw e = Bad e</span>
<span id="cb308-20"><a href="#cb308-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> catch m handler = <span class="kw">match</span> m <span class="kw">with</span></span>
<span id="cb308-21"><a href="#cb308-21" aria-hidden="true" tabindex="-1"></a>    | OK _ -&gt; m</span>
<span id="cb308-22"><a href="#cb308-22" aria-hidden="true" tabindex="-1"></a>    | Bad e -&gt; handler e</span>
<span id="cb308-23"><a href="#cb308-23" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<h3 id="the-state-monad">The State Monad</h3>
<p>The state monad threads a piece of mutable state through a
computation without actually using mutation. The key insight is that a
stateful computation can be represented as a <em>function</em> from the
current state to a pair of (result, new state):</p>
<div class="sourceCode" id="cb309"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb309-1"><a href="#cb309-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> StateM (Store : <span class="kw">sig</span> <span class="kw">type</span> t <span class="kw">end</span>) : <span class="kw">sig</span></span>
<span id="cb309-2"><a href="#cb309-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> store = Store.t</span>
<span id="cb309-3"><a href="#cb309-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a t = store -&gt; &#39;a * store  <span class="co">(* A stateful computation *)</span></span>
<span id="cb309-4"><a href="#cb309-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> MONAD_OPS</span>
<span id="cb309-5"><a href="#cb309-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> STATE <span class="kw">with</span> <span class="kw">type</span> &#39;a t := &#39;a monad</span>
<span id="cb309-6"><a href="#cb309-6" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">and</span> <span class="kw">type</span> store := store</span>
<span id="cb309-7"><a href="#cb309-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> run : &#39;a monad -&gt; &#39;a t</span>
<span id="cb309-8"><a href="#cb309-8" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span> = <span class="kw">struct</span></span>
<span id="cb309-9"><a href="#cb309-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> store = Store.t</span>
<span id="cb309-10"><a href="#cb309-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">module</span> M = <span class="kw">struct</span></span>
<span id="cb309-11"><a href="#cb309-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> &#39;a t = store -&gt; &#39;a * store</span>
<span id="cb309-12"><a href="#cb309-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> return a = <span class="kw">fun</span> s -&gt; a, s     <span class="co">(* Return value, keep state unchanged *)</span></span>
<span id="cb309-13"><a href="#cb309-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> bind m b = <span class="kw">fun</span> s -&gt; <span class="kw">let</span> a, s&#39; = m s <span class="kw">in</span> b a s&#39;</span>
<span id="cb309-14"><a href="#cb309-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end</span>                          <span class="co">(* Run m, then pass result and new state to b *)</span></span>
<span id="cb309-15"><a href="#cb309-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> M</span>
<span id="cb309-16"><a href="#cb309-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> MonadOps(M)</span>
<span id="cb309-17"><a href="#cb309-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> get = <span class="kw">fun</span> s -&gt; s, s            <span class="co">(* Return the current state *)</span></span>
<span id="cb309-18"><a href="#cb309-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> put s&#39; = <span class="kw">fun</span> _ -&gt; (), s&#39;       <span class="co">(* Replace the state, return unit *)</span></span>
<span id="cb309-19"><a href="#cb309-19" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>The <code>bind</code> operation sequences two stateful computations:
it runs the first one with the initial state, then passes both the
result and the new state to the second computation.</p>
<p>The state monad is useful to hide the threading of a “current” value
through a computation. Here is an example that renames variables in
lambda-terms to eliminate potential name clashes (alpha-conversion):</p>
<div class="sourceCode" id="cb310"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb310-1"><a href="#cb310-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> term =</span>
<span id="cb310-2"><a href="#cb310-2" aria-hidden="true" tabindex="-1"></a>  | Var <span class="kw">of</span> <span class="dt">string</span></span>
<span id="cb310-3"><a href="#cb310-3" aria-hidden="true" tabindex="-1"></a>  | Lam <span class="kw">of</span> <span class="dt">string</span> * term</span>
<span id="cb310-4"><a href="#cb310-4" aria-hidden="true" tabindex="-1"></a>  | App <span class="kw">of</span> term * term</span>
<span id="cb310-5"><a href="#cb310-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-6"><a href="#cb310-6" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> TermOps = <span class="kw">struct</span></span>
<span id="cb310-7"><a href="#cb310-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (!) x = Var x</span>
<span id="cb310-8"><a href="#cb310-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (|-&gt;) x t = Lam (x, t)</span>
<span id="cb310-9"><a href="#cb310-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (@) t1 t2 = App (t1, t2)</span>
<span id="cb310-10"><a href="#cb310-10" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb310-11"><a href="#cb310-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> test = TermOps.(<span class="st">&quot;x&quot;</span> |-&gt; (<span class="st">&quot;x&quot;</span> |-&gt; !<span class="st">&quot;y&quot;</span> @ !<span class="st">&quot;x&quot;</span>) @ !<span class="st">&quot;x&quot;</span>)</span>
<span id="cb310-12"><a href="#cb310-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-13"><a href="#cb310-13" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> S = StateM (<span class="kw">struct</span> <span class="kw">type</span> t = <span class="dt">int</span> * (<span class="dt">string</span> * <span class="dt">string</span>) <span class="dt">list</span> <span class="kw">end</span>)</span>
<span id="cb310-14"><a href="#cb310-14" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> S</span>
<span id="cb310-15"><a href="#cb310-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-16"><a href="#cb310-16" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> alpha_conv = <span class="kw">function</span></span>
<span id="cb310-17"><a href="#cb310-17" aria-hidden="true" tabindex="-1"></a>  | Var x <span class="kw">as</span> v -&gt;                      <span class="co">(* Function from terms to StateM monad *)</span></span>
<span id="cb310-18"><a href="#cb310-18" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span>* (_, env) = get <span class="kw">in</span>           <span class="co">(* Seeing a variable does not change state *)</span></span>
<span id="cb310-19"><a href="#cb310-19" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> v = <span class="kw">try</span> Var (<span class="dt">List</span>.assoc x env)  <span class="co">(* but we need its new name *)</span></span>
<span id="cb310-20"><a href="#cb310-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">with</span> <span class="dt">Not_found</span> -&gt; v <span class="kw">in</span>         <span class="co">(* Free variables don&#39;t change name *)</span></span>
<span id="cb310-21"><a href="#cb310-21" aria-hidden="true" tabindex="-1"></a>      return v</span>
<span id="cb310-22"><a href="#cb310-22" aria-hidden="true" tabindex="-1"></a>  | Lam (x, t) -&gt;                      <span class="co">(* We rename each bound variable *)</span></span>
<span id="cb310-23"><a href="#cb310-23" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span>* (fresh, env) = get <span class="kw">in</span>       <span class="co">(* We need a fresh number *)</span></span>
<span id="cb310-24"><a href="#cb310-24" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> x&#39; = x ^ <span class="dt">string_of_int</span> fresh <span class="kw">in</span></span>
<span id="cb310-25"><a href="#cb310-25" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span>* () = put (fresh+<span class="dv">1</span>, (x, x&#39;)::env) <span class="kw">in</span>  <span class="co">(* Remember new name, update number *)</span></span>
<span id="cb310-26"><a href="#cb310-26" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span>* t&#39; = alpha_conv t <span class="kw">in</span></span>
<span id="cb310-27"><a href="#cb310-27" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span>* (fresh&#39;, _) = get <span class="kw">in</span>        <span class="co">(* We need to restore names, *)</span></span>
<span id="cb310-28"><a href="#cb310-28" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span>* () = put (fresh&#39;, env) <span class="kw">in</span>   <span class="co">(* but keep the number fresh *)</span></span>
<span id="cb310-29"><a href="#cb310-29" aria-hidden="true" tabindex="-1"></a>      return (Lam (x&#39;, t&#39;))</span>
<span id="cb310-30"><a href="#cb310-30" aria-hidden="true" tabindex="-1"></a>  | App (t1, t2) -&gt;</span>
<span id="cb310-31"><a href="#cb310-31" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span>* t1 = alpha_conv t1 <span class="kw">in</span>       <span class="co">(* Passing around of names *)</span></span>
<span id="cb310-32"><a href="#cb310-32" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span>* t2 = alpha_conv t2 <span class="kw">in</span>       <span class="co">(* and the currently fresh number *)</span></span>
<span id="cb310-33"><a href="#cb310-33" aria-hidden="true" tabindex="-1"></a>      return (App (t1, t2))            <span class="co">(* is done by the monad *)</span></span>
<span id="cb310-34"><a href="#cb310-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-35"><a href="#cb310-35" aria-hidden="true" tabindex="-1"></a><span class="co">(* # StateM.run (alpha_conv test) (5, []);; *)</span></span></code></pre></div>
<p>The state consists of a fresh counter and an environment mapping old
names to new names. The <code>get</code> and <code>put</code> operations
access and modify this state, while <code>let*</code> sequences the
operations. Without the state monad, we would have to explicitly pass
the state through every recursive call – tedious and error-prone.</p>
<p>Note: This alpha-conversion does not make a lambda-term safe for
multiple steps of beta-reduction. Can you find a counter-example?</p>
<h2 id="monad-transformers">8.12 Monad Transformers</h2>
<p>Sometimes we need the capabilities of multiple monads at the same
time. For example, we might want both state (to track information) and
non-determinism (to explore choices). The straightforward idea is to
nest one monad within another: either <code>'a AM.monad BM.monad</code>
or <code>'a BM.monad AM.monad</code>. But this does not work well – we
want a single monad that has operations of <em>both</em> <code>AM</code>
and <code>BM</code>.</p>
<p>The solution is a <strong>monad transformer</strong>. A monad
transformer <code>AT</code> takes a monad <code>BM</code> and produces a
new monad <code>AT(BM)</code> that has operations of both. The
transformed monad wraps around <code>BM</code> in a specific way to make
the operations interact correctly.</p>
<p>We will develop a monad transformer <code>StateT</code> which adds
state to any monad-plus. The resulting monad has all the operations:
<code>return</code>, <code>bind</code>, <code>mzero</code>,
<code>mplus</code>, <code>put</code>, <code>get</code>, and all their
derived functions.</p>
<p>Why do we need monad transformers in OCaml? Because “monads are
contagious”: although we have built-in state and exceptions, we need to
use <em>monadic</em> state and exceptions when we are inside a monad.
For example, using OCaml’s native <code>ref</code> cells inside a list
monad would give the wrong semantics for backtracking. This is also why
Lwt is both a concurrency monad and an exception monad – it needs
monadic exceptions to interact correctly with its concurrency model.</p>
<p>To understand how the transformer works, let us compare the regular
state monad with the transformed version. The regular state monad uses
ordinary OCaml binding:</p>
<div class="sourceCode" id="cb311"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb311-1"><a href="#cb311-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a state = store -&gt; (&#39;a * store)</span>
<span id="cb311-2"><a href="#cb311-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb311-3"><a href="#cb311-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> return (a : &#39;a) : &#39;a state =</span>
<span id="cb311-4"><a href="#cb311-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fun</span> s -&gt; (a, s)</span>
<span id="cb311-5"><a href="#cb311-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb311-6"><a href="#cb311-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> bind (u : &#39;a state) (f : &#39;a -&gt; &#39;b state) : &#39;b state =</span>
<span id="cb311-7"><a href="#cb311-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fun</span> s -&gt; <span class="kw">let</span> (a, s&#39;) = u s <span class="kw">in</span> f a s&#39;</span></code></pre></div>
<p>The transformed version wraps everything in the underlying monad
<code>M</code>:</p>
<div class="sourceCode" id="cb312"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb312-1"><a href="#cb312-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Monad M transformed to add state, in pseudo-code: *)</span></span>
<span id="cb312-2"><a href="#cb312-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a stateT(M) = store -&gt; (&#39;a * store) M</span>
<span id="cb312-3"><a href="#cb312-3" aria-hidden="true" tabindex="-1"></a><span class="co">(* Note: this is store -&gt; (&#39;a * store) M, not (&#39;a M) state *)</span></span>
<span id="cb312-4"><a href="#cb312-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb312-5"><a href="#cb312-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> return (a : &#39;a) : &#39;a stateT(M) =</span>
<span id="cb312-6"><a href="#cb312-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fun</span> s -&gt; M.return (a, s)           <span class="co">(* Use M.return instead of just returning *)</span></span>
<span id="cb312-7"><a href="#cb312-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb312-8"><a href="#cb312-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> bind (u : &#39;a stateT(M)) (f : &#39;a -&gt; &#39;b stateT(M)) : &#39;b stateT(M) =</span>
<span id="cb312-9"><a href="#cb312-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fun</span> s -&gt; M.bind (u s) (<span class="kw">fun</span> (a, s&#39;) -&gt; f a s&#39;)  <span class="co">(* Use M.bind instead of let *)</span></span></code></pre></div>
<p>The key insight is that the result type is
<code>('a * store) M</code> – the result and state are wrapped
<em>together</em> in the underlying monad. This ensures that
backtracking (in a monad-plus) correctly restores the state.</p>
<h3 id="state-transformer-implementation">State Transformer
Implementation</h3>
<div class="sourceCode" id="cb313"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb313-1"><a href="#cb313-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> StateT (MP : MONAD_PLUS_OPS) (Store : <span class="kw">sig</span> <span class="kw">type</span> t <span class="kw">end</span>) : <span class="kw">sig</span></span>
<span id="cb313-2"><a href="#cb313-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> store = Store.t</span>
<span id="cb313-3"><a href="#cb313-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a t = store -&gt; (&#39;a * store) MP.monad</span>
<span id="cb313-4"><a href="#cb313-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> MONAD_PLUS_OPS         <span class="co">(* Exporting all monad-plus operations *)</span></span>
<span id="cb313-5"><a href="#cb313-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> STATE <span class="kw">with</span> <span class="kw">type</span> &#39;a t := &#39;a monad</span>
<span id="cb313-6"><a href="#cb313-6" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">and</span> <span class="kw">type</span> store := store  <span class="co">(* and state operations *)</span></span>
<span id="cb313-7"><a href="#cb313-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> run : &#39;a monad -&gt; &#39;a t     <span class="co">(* Expose &quot;what happened&quot; -- resulting states *)</span></span>
<span id="cb313-8"><a href="#cb313-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> runT : &#39;a monad -&gt; store -&gt; &#39;a MP.monad</span>
<span id="cb313-9"><a href="#cb313-9" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span> = <span class="kw">struct</span>              <span class="co">(* Run the state transformer -- get resulting values *)</span></span>
<span id="cb313-10"><a href="#cb313-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> store = Store.t</span>
<span id="cb313-11"><a href="#cb313-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">module</span> M = <span class="kw">struct</span></span>
<span id="cb313-12"><a href="#cb313-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> &#39;a t = store -&gt; (&#39;a * store) MP.monad</span>
<span id="cb313-13"><a href="#cb313-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> return a = <span class="kw">fun</span> s -&gt; MP.return (a, s)</span>
<span id="cb313-14"><a href="#cb313-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> bind m b = <span class="kw">fun</span> s -&gt;</span>
<span id="cb313-15"><a href="#cb313-15" aria-hidden="true" tabindex="-1"></a>      MP.bind (m s) (<span class="kw">fun</span> (a, s&#39;) -&gt; b a s&#39;)</span>
<span id="cb313-16"><a href="#cb313-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> mzero = <span class="kw">fun</span> _ -&gt; MP.mzero            <span class="co">(* Lift the monad-plus operations *)</span></span>
<span id="cb313-17"><a href="#cb313-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> mplus ma mb = <span class="kw">fun</span> s -&gt; MP.mplus (ma s) (mb s)</span>
<span id="cb313-18"><a href="#cb313-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end</span></span>
<span id="cb313-19"><a href="#cb313-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> M</span>
<span id="cb313-20"><a href="#cb313-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> MonadPlusOps(M)</span>
<span id="cb313-21"><a href="#cb313-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> get = <span class="kw">fun</span> s -&gt; MP.return (s, s)        <span class="co">(* Instead of just returning, *)</span></span>
<span id="cb313-22"><a href="#cb313-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> put s&#39; = <span class="kw">fun</span> _ -&gt; MP.return ((), s&#39;)   <span class="co">(* MP.return *)</span></span>
<span id="cb313-23"><a href="#cb313-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> runT m s = MP.lift <span class="dt">fst</span> (m s)</span>
<span id="cb313-24"><a href="#cb313-24" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<h3 id="backtracking-with-state">Backtracking with State</h3>
<p>Now we can combine backtracking with state for our puzzle solver. The
state tracks which cells have been visited, eaten, and how many islands
we have found. The monad-plus structure handles the backtracking when a
choice leads to a dead end:</p>
<div class="sourceCode" id="cb314"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb314-1"><a href="#cb314-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> HoneyIslands (M : MONAD_PLUS_OPS) = <span class="kw">struct</span></span>
<span id="cb314-2"><a href="#cb314-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> state = {</span>
<span id="cb314-3"><a href="#cb314-3" aria-hidden="true" tabindex="-1"></a>    been_size : <span class="dt">int</span>;</span>
<span id="cb314-4"><a href="#cb314-4" aria-hidden="true" tabindex="-1"></a>    been_islands : <span class="dt">int</span>;</span>
<span id="cb314-5"><a href="#cb314-5" aria-hidden="true" tabindex="-1"></a>    unvisited : cell <span class="dt">list</span>;</span>
<span id="cb314-6"><a href="#cb314-6" aria-hidden="true" tabindex="-1"></a>    visited : CellSet.t;</span>
<span id="cb314-7"><a href="#cb314-7" aria-hidden="true" tabindex="-1"></a>    eaten : cell <span class="dt">list</span>;</span>
<span id="cb314-8"><a href="#cb314-8" aria-hidden="true" tabindex="-1"></a>    more_to_eat : <span class="dt">int</span>;</span>
<span id="cb314-9"><a href="#cb314-9" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb314-10"><a href="#cb314-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb314-11"><a href="#cb314-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> init_state unvisited more_to_eat = {</span>
<span id="cb314-12"><a href="#cb314-12" aria-hidden="true" tabindex="-1"></a>    been_size = <span class="dv">0</span>;</span>
<span id="cb314-13"><a href="#cb314-13" aria-hidden="true" tabindex="-1"></a>    been_islands = <span class="dv">0</span>;</span>
<span id="cb314-14"><a href="#cb314-14" aria-hidden="true" tabindex="-1"></a>    unvisited;</span>
<span id="cb314-15"><a href="#cb314-15" aria-hidden="true" tabindex="-1"></a>    visited = CellSet.empty;</span>
<span id="cb314-16"><a href="#cb314-16" aria-hidden="true" tabindex="-1"></a>    eaten = [];</span>
<span id="cb314-17"><a href="#cb314-17" aria-hidden="true" tabindex="-1"></a>    more_to_eat;</span>
<span id="cb314-18"><a href="#cb314-18" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb314-19"><a href="#cb314-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb314-20"><a href="#cb314-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">module</span> BacktrackingM = StateT (M) (<span class="kw">struct</span> <span class="kw">type</span> t = state <span class="kw">end</span>)</span>
<span id="cb314-21"><a href="#cb314-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">open</span> BacktrackingM</span>
<span id="cb314-22"><a href="#cb314-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb314-23"><a href="#cb314-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> visit_cell () =           <span class="co">(* State update actions *)</span></span>
<span id="cb314-24"><a href="#cb314-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* s = get <span class="kw">in</span></span>
<span id="cb314-25"><a href="#cb314-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> s.unvisited <span class="kw">with</span></span>
<span id="cb314-26"><a href="#cb314-26" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; return <span class="dt">None</span></span>
<span id="cb314-27"><a href="#cb314-27" aria-hidden="true" tabindex="-1"></a>    | c::remaining <span class="kw">when</span> CellSet.mem c s.visited -&gt;</span>
<span id="cb314-28"><a href="#cb314-28" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span>* () = put {s <span class="kw">with</span> unvisited=remaining} <span class="kw">in</span></span>
<span id="cb314-29"><a href="#cb314-29" aria-hidden="true" tabindex="-1"></a>        visit_cell ()               <span class="co">(* Throwaway argument because of recursion *)</span></span>
<span id="cb314-30"><a href="#cb314-30" aria-hidden="true" tabindex="-1"></a>    | c::remaining -&gt;</span>
<span id="cb314-31"><a href="#cb314-31" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span>* () = put {s <span class="kw">with</span></span>
<span id="cb314-32"><a href="#cb314-32" aria-hidden="true" tabindex="-1"></a>          unvisited=remaining;</span>
<span id="cb314-33"><a href="#cb314-33" aria-hidden="true" tabindex="-1"></a>          visited = CellSet.add c s.visited} <span class="kw">in</span></span>
<span id="cb314-34"><a href="#cb314-34" aria-hidden="true" tabindex="-1"></a>        return (<span class="dt">Some</span> c)             <span class="co">(* This action returns a value *)</span></span>
<span id="cb314-35"><a href="#cb314-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb314-36"><a href="#cb314-36" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> eat_cell c =</span>
<span id="cb314-37"><a href="#cb314-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* s = get <span class="kw">in</span></span>
<span id="cb314-38"><a href="#cb314-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* () = put {s <span class="kw">with</span> eaten = c::s.eaten;</span>
<span id="cb314-39"><a href="#cb314-39" aria-hidden="true" tabindex="-1"></a>         visited = CellSet.add c s.visited;</span>
<span id="cb314-40"><a href="#cb314-40" aria-hidden="true" tabindex="-1"></a>         more_to_eat = s.more_to_eat - <span class="dv">1</span>} <span class="kw">in</span></span>
<span id="cb314-41"><a href="#cb314-41" aria-hidden="true" tabindex="-1"></a>    return ()              <span class="co">(* Remaining state update actions just affect the state *)</span></span>
<span id="cb314-42"><a href="#cb314-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb314-43"><a href="#cb314-43" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> keep_cell c =</span>
<span id="cb314-44"><a href="#cb314-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* s = get <span class="kw">in</span></span>
<span id="cb314-45"><a href="#cb314-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* () = put {s <span class="kw">with</span></span>
<span id="cb314-46"><a href="#cb314-46" aria-hidden="true" tabindex="-1"></a>      visited = CellSet.add c s.visited;</span>
<span id="cb314-47"><a href="#cb314-47" aria-hidden="true" tabindex="-1"></a>      been_size = s.been_size + <span class="dv">1</span>} <span class="kw">in</span></span>
<span id="cb314-48"><a href="#cb314-48" aria-hidden="true" tabindex="-1"></a>    return ()</span>
<span id="cb314-49"><a href="#cb314-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb314-50"><a href="#cb314-50" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> fresh_island =</span>
<span id="cb314-51"><a href="#cb314-51" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* s = get <span class="kw">in</span></span>
<span id="cb314-52"><a href="#cb314-52" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* () = put {s <span class="kw">with</span> been_size = <span class="dv">0</span>;</span>
<span id="cb314-53"><a href="#cb314-53" aria-hidden="true" tabindex="-1"></a>         been_islands = s.been_islands + <span class="dv">1</span>} <span class="kw">in</span></span>
<span id="cb314-54"><a href="#cb314-54" aria-hidden="true" tabindex="-1"></a>    return ()</span>
<span id="cb314-55"><a href="#cb314-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb314-56"><a href="#cb314-56" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> find_to_eat n island_size num_islands empty_cells =</span>
<span id="cb314-57"><a href="#cb314-57" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> honey = honey_cells n empty_cells <span class="kw">in</span></span>
<span id="cb314-58"><a href="#cb314-58" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">rec</span> find_board () =</span>
<span id="cb314-59"><a href="#cb314-59" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span>* cell = visit_cell () <span class="kw">in</span></span>
<span id="cb314-60"><a href="#cb314-60" aria-hidden="true" tabindex="-1"></a>      <span class="kw">match</span> cell <span class="kw">with</span></span>
<span id="cb314-61"><a href="#cb314-61" aria-hidden="true" tabindex="-1"></a>      | <span class="dt">None</span> -&gt;</span>
<span id="cb314-62"><a href="#cb314-62" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span>* s = get <span class="kw">in</span></span>
<span id="cb314-63"><a href="#cb314-63" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span>* () = guard (s.been_islands = num_islands) <span class="kw">in</span></span>
<span id="cb314-64"><a href="#cb314-64" aria-hidden="true" tabindex="-1"></a>          return s.eaten</span>
<span id="cb314-65"><a href="#cb314-65" aria-hidden="true" tabindex="-1"></a>      | <span class="dt">Some</span> cell -&gt;</span>
<span id="cb314-66"><a href="#cb314-66" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span>* () = fresh_island <span class="kw">in</span></span>
<span id="cb314-67"><a href="#cb314-67" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span>* () = find_island cell <span class="kw">in</span></span>
<span id="cb314-68"><a href="#cb314-68" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span>* s = get <span class="kw">in</span></span>
<span id="cb314-69"><a href="#cb314-69" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span>* () = guard (s.been_size = island_size) <span class="kw">in</span></span>
<span id="cb314-70"><a href="#cb314-70" aria-hidden="true" tabindex="-1"></a>          find_board ()</span>
<span id="cb314-71"><a href="#cb314-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb314-72"><a href="#cb314-72" aria-hidden="true" tabindex="-1"></a>    <span class="kw">and</span> find_island current =</span>
<span id="cb314-73"><a href="#cb314-73" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span>* () = keep_cell current <span class="kw">in</span></span>
<span id="cb314-74"><a href="#cb314-74" aria-hidden="true" tabindex="-1"></a>      neighbors n empty_cells current</span>
<span id="cb314-75"><a href="#cb314-75" aria-hidden="true" tabindex="-1"></a>      |&gt; foldM</span>
<span id="cb314-76"><a href="#cb314-76" aria-hidden="true" tabindex="-1"></a>           (<span class="kw">fun</span> () neighbor -&gt;</span>
<span id="cb314-77"><a href="#cb314-77" aria-hidden="true" tabindex="-1"></a>              <span class="kw">let</span>* s = get <span class="kw">in</span></span>
<span id="cb314-78"><a href="#cb314-78" aria-hidden="true" tabindex="-1"></a>              whenM (<span class="dt">not</span> (CellSet.mem neighbor s.visited))</span>
<span id="cb314-79"><a href="#cb314-79" aria-hidden="true" tabindex="-1"></a>                (<span class="kw">let</span> choose_eat =</span>
<span id="cb314-80"><a href="#cb314-80" aria-hidden="true" tabindex="-1"></a>                   <span class="kw">let</span>* () = guard (s.more_to_eat &gt; <span class="dv">0</span>) <span class="kw">in</span></span>
<span id="cb314-81"><a href="#cb314-81" aria-hidden="true" tabindex="-1"></a>                   eat_cell neighbor</span>
<span id="cb314-82"><a href="#cb314-82" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">and</span> choose_keep =</span>
<span id="cb314-83"><a href="#cb314-83" aria-hidden="true" tabindex="-1"></a>                   <span class="kw">let</span>* () = guard (s.been_size &lt; island_size) <span class="kw">in</span></span>
<span id="cb314-84"><a href="#cb314-84" aria-hidden="true" tabindex="-1"></a>                   find_island neighbor <span class="kw">in</span></span>
<span id="cb314-85"><a href="#cb314-85" aria-hidden="true" tabindex="-1"></a>                 choose_eat ++ choose_keep)) () <span class="kw">in</span></span>
<span id="cb314-86"><a href="#cb314-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb314-87"><a href="#cb314-87" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> cells_to_eat =</span>
<span id="cb314-88"><a href="#cb314-88" aria-hidden="true" tabindex="-1"></a>      <span class="dt">List</span>.length honey - island_size * num_islands <span class="kw">in</span></span>
<span id="cb314-89"><a href="#cb314-89" aria-hidden="true" tabindex="-1"></a>    init_state honey cells_to_eat</span>
<span id="cb314-90"><a href="#cb314-90" aria-hidden="true" tabindex="-1"></a>    |&gt; runT (find_board ())</span>
<span id="cb314-91"><a href="#cb314-91" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb314-92"><a href="#cb314-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb314-93"><a href="#cb314-93" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> HoneyL = HoneyIslands (ListM)</span>
<span id="cb314-94"><a href="#cb314-94" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> find_to_eat a b c d =</span>
<span id="cb314-95"><a href="#cb314-95" aria-hidden="true" tabindex="-1"></a>  ListM.run (HoneyL.find_to_eat a b c d)</span></code></pre></div>
<h2 id="probabilistic-programming">8.13 Probabilistic Programming</h2>
<p>Using a random number generator, we can define procedures that
produce various outputs. This is <strong>not functional</strong> in the
mathematical sense – mathematical functions have deterministic results
for fixed arguments.</p>
<p>Just as we can “simulate” mutable variables with the state monad and
non-determinism with the list monad, we can “simulate” random
computation with a <strong>probability monad</strong>. But the
probability monad is more than just randomized computation – it lets us
<em>reason</em> about probabilities. We can ask questions like “what is
the probability of this outcome?” or “what is the distribution of
possible results?”</p>
<p>Different monad implementations make different tradeoffs: -
<strong>Exact distribution</strong>: Track all possible outcomes and
their probabilities precisely - <strong>Sampling (Monte Carlo)</strong>:
Approximate probabilities by running many random trials</p>
<h3 id="the-probability-monad">The Probability Monad</h3>
<p>The essential functions for the probability monad class are
<code>choose</code> (for making probabilistic choices) and
<code>distrib</code> (for extracting the probability distribution).
Other operations could be defined in terms of these but are provided by
each instance for efficiency.</p>
<p><strong>Inside-monad operations</strong> (building probabilistic
computations):</p>
<ul>
<li><code>choose : float -&gt; 'a monad -&gt; 'a monad -&gt; 'a monad</code>:
<code>choose p a b</code> represents an event which is <code>a</code>
with probability <span class="math inline">p</span> and <code>b</code>
with probability <span class="math inline">1-p</span>.</li>
<li><code>pick : ('a * float) list -&gt; 'a monad</code>: Draw a result
from a given probability distribution. The argument must be a valid
distribution: positive probabilities summing to 1.</li>
<li><code>uniform : 'a list -&gt; 'a monad</code>: Uniform distribution
– each element equally likely.</li>
<li><code>flip : float -&gt; bool monad</code>: A biased coin:
<code>true</code> with probability <code>p</code>, <code>false</code>
otherwise.</li>
<li><code>coin : bool monad</code>: A fair coin:
<code>flip 0.5</code>.</li>
</ul>
<p><strong>Outside-monad operations</strong> (querying probabilistic
computations):</p>
<ul>
<li><code>prob : ('a -&gt; bool) -&gt; 'a monad -&gt; float</code>:
Returns the probability that a predicate holds.</li>
<li><code>distrib : 'a monad -&gt; ('a * float) list</code>: Returns the
full distribution of probabilities over outcomes.</li>
<li><code>access : 'a monad -&gt; 'a</code>: Samples a random result
from the distribution – this is <strong>non-functional</strong> behavior
(different calls may return different results).</li>
</ul>
<div class="sourceCode" id="cb315"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb315-1"><a href="#cb315-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">type</span> PROBABILITY = <span class="kw">sig</span></span>
<span id="cb315-2"><a href="#cb315-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> MONAD_OPS</span>
<span id="cb315-3"><a href="#cb315-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> choose : <span class="dt">float</span> -&gt; &#39;a monad -&gt; &#39;a monad -&gt; &#39;a monad</span>
<span id="cb315-4"><a href="#cb315-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> pick : (&#39;a * <span class="dt">float</span>) <span class="dt">list</span> -&gt; &#39;a monad</span>
<span id="cb315-5"><a href="#cb315-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> uniform : &#39;a <span class="dt">list</span> -&gt; &#39;a monad</span>
<span id="cb315-6"><a href="#cb315-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> coin : <span class="dt">bool</span> monad</span>
<span id="cb315-7"><a href="#cb315-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> flip : <span class="dt">float</span> -&gt; <span class="dt">bool</span> monad</span>
<span id="cb315-8"><a href="#cb315-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> prob : (&#39;a -&gt; <span class="dt">bool</span>) -&gt; &#39;a monad -&gt; <span class="dt">float</span></span>
<span id="cb315-9"><a href="#cb315-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> distrib : &#39;a monad -&gt; (&#39;a * <span class="dt">float</span>) <span class="dt">list</span></span>
<span id="cb315-10"><a href="#cb315-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> access : &#39;a monad -&gt; &#39;a</span>
<span id="cb315-11"><a href="#cb315-11" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>Helper functions:</p>
<div class="sourceCode" id="cb316"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb316-1"><a href="#cb316-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> total dist =</span>
<span id="cb316-2"><a href="#cb316-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.fold_left (<span class="kw">fun</span> a (_,b) -&gt; a +. b) <span class="dv">0</span>. dist</span>
<span id="cb316-3"><a href="#cb316-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb316-4"><a href="#cb316-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> merge dist = map_reduce (<span class="kw">fun</span> x -&gt; x) (+.) <span class="dv">0</span>. dist  <span class="co">(* Merge repeating elements *)</span></span>
<span id="cb316-5"><a href="#cb316-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb316-6"><a href="#cb316-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> normalize dist =                 <span class="co">(* Normalize a measure into a distribution *)</span></span>
<span id="cb316-7"><a href="#cb316-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> tot = total dist <span class="kw">in</span></span>
<span id="cb316-8"><a href="#cb316-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> tot = <span class="dv">0</span>. <span class="kw">then</span> dist</span>
<span id="cb316-9"><a href="#cb316-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> <span class="dt">List</span>.map (<span class="kw">fun</span> (e,w) -&gt; e, w /. tot) dist</span>
<span id="cb316-10"><a href="#cb316-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb316-11"><a href="#cb316-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> roulette dist =                  <span class="co">(* Roulette wheel from a distribution/measure *)</span></span>
<span id="cb316-12"><a href="#cb316-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> tot = total dist <span class="kw">in</span></span>
<span id="cb316-13"><a href="#cb316-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> aux r = <span class="kw">function</span></span>
<span id="cb316-14"><a href="#cb316-14" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; <span class="kw">assert</span> <span class="kw">false</span></span>
<span id="cb316-15"><a href="#cb316-15" aria-hidden="true" tabindex="-1"></a>    | (e, w)::_ <span class="kw">when</span> w &lt;= r -&gt; e</span>
<span id="cb316-16"><a href="#cb316-16" aria-hidden="true" tabindex="-1"></a>    | (_, w)::tl -&gt; aux (r -. w) tl <span class="kw">in</span></span>
<span id="cb316-17"><a href="#cb316-17" aria-hidden="true" tabindex="-1"></a>  aux (<span class="dt">Random</span>.<span class="dt">float</span> tot) dist</span></code></pre></div>
<h3 id="exact-distribution-monad">Exact Distribution Monad</h3>
<div class="sourceCode" id="cb317"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb317-1"><a href="#cb317-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> DistribM : PROBABILITY = <span class="kw">struct</span></span>
<span id="cb317-2"><a href="#cb317-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">module</span> M = <span class="kw">struct</span>       <span class="co">(* Exact probability distribution -- naive implementation *)</span></span>
<span id="cb317-3"><a href="#cb317-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> &#39;a t = (&#39;a * <span class="dt">float</span>) <span class="dt">list</span></span>
<span id="cb317-4"><a href="#cb317-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> bind a b = merge             <span class="co">(* x w.p. p and then y w.p. q happens = *)</span></span>
<span id="cb317-5"><a href="#cb317-5" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">List</span>.concat_map (<span class="kw">fun</span> (x, p) -&gt;</span>
<span id="cb317-6"><a href="#cb317-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">List</span>.map (<span class="kw">fun</span> (y, q) -&gt; (y, q *. p)) (b x)) a)  <span class="co">(* y results w.p. p*q *)</span></span>
<span id="cb317-7"><a href="#cb317-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> return a = [a, <span class="dv">1</span>.]           <span class="co">(* Certainly a *)</span></span>
<span id="cb317-8"><a href="#cb317-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end</span></span>
<span id="cb317-9"><a href="#cb317-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> M</span>
<span id="cb317-10"><a href="#cb317-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> MonadOps (M)</span>
<span id="cb317-11"><a href="#cb317-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> choose p a b =</span>
<span id="cb317-12"><a href="#cb317-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">List</span>.append</span>
<span id="cb317-13"><a href="#cb317-13" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">List</span>.map (<span class="kw">fun</span> (e,w) -&gt; e, p *. w) a)</span>
<span id="cb317-14"><a href="#cb317-14" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">List</span>.map (<span class="kw">fun</span> (e,w) -&gt; e, (<span class="dv">1</span>. -. p) *. w) b)</span>
<span id="cb317-15"><a href="#cb317-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> pick dist = dist</span>
<span id="cb317-16"><a href="#cb317-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> uniform elems = normalize</span>
<span id="cb317-17"><a href="#cb317-17" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">List</span>.map (<span class="kw">fun</span> e -&gt; e, <span class="dv">1</span>.) elems)</span>
<span id="cb317-18"><a href="#cb317-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> coin = [<span class="kw">true</span>, <span class="fl">0.5</span>; <span class="kw">false</span>, <span class="fl">0.5</span>]</span>
<span id="cb317-19"><a href="#cb317-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> flip p = [<span class="kw">true</span>, p; <span class="kw">false</span>, <span class="dv">1</span>. -. p]</span>
<span id="cb317-20"><a href="#cb317-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> prob p m = m</span>
<span id="cb317-21"><a href="#cb317-21" aria-hidden="true" tabindex="-1"></a>    |&gt; <span class="dt">List</span>.filter (<span class="kw">fun</span> (e,_) -&gt; p e)    <span class="co">(* All cases where p holds, *)</span></span>
<span id="cb317-22"><a href="#cb317-22" aria-hidden="true" tabindex="-1"></a>    |&gt; <span class="dt">List</span>.map <span class="dt">snd</span> |&gt; <span class="dt">List</span>.fold_left (+.) <span class="dv">0</span>.  <span class="co">(* add up *)</span></span>
<span id="cb317-23"><a href="#cb317-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> distrib m = m</span>
<span id="cb317-24"><a href="#cb317-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> access m = roulette m</span>
<span id="cb317-25"><a href="#cb317-25" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<h3 id="sampling-monad">Sampling Monad</h3>
<div class="sourceCode" id="cb318"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb318-1"><a href="#cb318-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> SamplingM (S : <span class="kw">sig</span> <span class="kw">val</span> samples : <span class="dt">int</span> <span class="kw">end</span>) : PROBABILITY = <span class="kw">struct</span></span>
<span id="cb318-2"><a href="#cb318-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">module</span> M = <span class="kw">struct</span>                      <span class="co">(* Parameterized by how many samples *)</span></span>
<span id="cb318-3"><a href="#cb318-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> &#39;a t = <span class="dt">unit</span> -&gt; &#39;a               <span class="co">(* used to approximate prob or distrib *)</span></span>
<span id="cb318-4"><a href="#cb318-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> bind a b () = b (a ()) ()        <span class="co">(* Randomized computation -- each call a() *)</span></span>
<span id="cb318-5"><a href="#cb318-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> return a = <span class="kw">fun</span> () -&gt; a           <span class="co">(* is an independent sample. Always a. *)</span></span>
<span id="cb318-6"><a href="#cb318-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end</span></span>
<span id="cb318-7"><a href="#cb318-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> M</span>
<span id="cb318-8"><a href="#cb318-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> MonadOps (M)</span>
<span id="cb318-9"><a href="#cb318-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> choose p a b () =</span>
<span id="cb318-10"><a href="#cb318-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="dt">Random</span>.<span class="dt">float</span> <span class="dv">1</span>. &lt;= p <span class="kw">then</span> a () <span class="kw">else</span> b ()</span>
<span id="cb318-11"><a href="#cb318-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> pick dist = <span class="kw">fun</span> () -&gt; roulette dist</span>
<span id="cb318-12"><a href="#cb318-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> uniform elems =</span>
<span id="cb318-13"><a href="#cb318-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> n = <span class="dt">List</span>.length elems <span class="kw">in</span></span>
<span id="cb318-14"><a href="#cb318-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fun</span> () -&gt; <span class="dt">List</span>.nth elems (<span class="dt">Random</span>.<span class="dt">int</span> n)</span>
<span id="cb318-15"><a href="#cb318-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> coin = <span class="dt">Random</span>.<span class="dt">bool</span></span>
<span id="cb318-16"><a href="#cb318-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> flip p = choose p (return <span class="kw">true</span>) (return <span class="kw">false</span>)</span>
<span id="cb318-17"><a href="#cb318-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> prob p m =</span>
<span id="cb318-18"><a href="#cb318-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> count = <span class="dt">ref</span> <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb318-19"><a href="#cb318-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> i = <span class="dv">1</span> <span class="kw">to</span> S.samples <span class="kw">do</span></span>
<span id="cb318-20"><a href="#cb318-20" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> p (m ()) <span class="kw">then</span> <span class="dt">incr</span> count</span>
<span id="cb318-21"><a href="#cb318-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span>;</span>
<span id="cb318-22"><a href="#cb318-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float_of_int</span> !count /. <span class="dt">float_of_int</span> S.samples</span>
<span id="cb318-23"><a href="#cb318-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> distrib m =</span>
<span id="cb318-24"><a href="#cb318-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> dist = <span class="dt">ref</span> [] <span class="kw">in</span></span>
<span id="cb318-25"><a href="#cb318-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> i = <span class="dv">1</span> <span class="kw">to</span> S.samples <span class="kw">do</span></span>
<span id="cb318-26"><a href="#cb318-26" aria-hidden="true" tabindex="-1"></a>      dist := (m (), <span class="dv">1</span>.) :: !dist <span class="kw">done</span>;</span>
<span id="cb318-27"><a href="#cb318-27" aria-hidden="true" tabindex="-1"></a>    normalize (merge !dist)</span>
<span id="cb318-28"><a href="#cb318-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> access m = m ()</span>
<span id="cb318-29"><a href="#cb318-29" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<h3 id="example-the-monty-hall-problem">Example: The Monty Hall
Problem</h3>
<p>The Monty Hall problem is a famous probability puzzle. In search of a
new car, the player picks a door, say 1. The game host (who knows what
is behind each door) then opens one of the other doors, say 3, to reveal
a goat and offers to let the player switch to door 2 instead of door 1.
Should the player switch?</p>
<p>Most people’s intuition says it does not matter, but let us compute
the actual probabilities:</p>
<div class="sourceCode" id="cb319"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb319-1"><a href="#cb319-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> MontyHall (P : PROBABILITY) = <span class="kw">struct</span></span>
<span id="cb319-2"><a href="#cb319-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">open</span> P</span>
<span id="cb319-3"><a href="#cb319-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> door = A | B | C</span>
<span id="cb319-4"><a href="#cb319-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> doors = [A; B; C]</span>
<span id="cb319-5"><a href="#cb319-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-6"><a href="#cb319-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> monty_win switch =</span>
<span id="cb319-7"><a href="#cb319-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* prize = uniform doors <span class="kw">in</span></span>
<span id="cb319-8"><a href="#cb319-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* chosen = uniform doors <span class="kw">in</span></span>
<span id="cb319-9"><a href="#cb319-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* opened = uniform (list_diff doors [prize; chosen]) <span class="kw">in</span></span>
<span id="cb319-10"><a href="#cb319-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> final =</span>
<span id="cb319-11"><a href="#cb319-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> switch <span class="kw">then</span> <span class="dt">List</span>.hd (list_diff doors [opened; chosen])</span>
<span id="cb319-12"><a href="#cb319-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> chosen <span class="kw">in</span></span>
<span id="cb319-13"><a href="#cb319-13" aria-hidden="true" tabindex="-1"></a>    return (final = prize)</span>
<span id="cb319-14"><a href="#cb319-14" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb319-15"><a href="#cb319-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-16"><a href="#cb319-16" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> MontyExact = MontyHall (DistribM)</span>
<span id="cb319-17"><a href="#cb319-17" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Sampling1000 =</span>
<span id="cb319-18"><a href="#cb319-18" aria-hidden="true" tabindex="-1"></a>  SamplingM (<span class="kw">struct</span> <span class="kw">let</span> samples = <span class="dv">1000</span> <span class="kw">end</span>)</span>
<span id="cb319-19"><a href="#cb319-19" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> MontySimul = MontyHall (Sampling1000)</span>
<span id="cb319-20"><a href="#cb319-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-21"><a href="#cb319-21" aria-hidden="true" tabindex="-1"></a><span class="co">(* DistribM.distrib (MontyExact.monty_win false);; *)</span></span>
<span id="cb319-22"><a href="#cb319-22" aria-hidden="true" tabindex="-1"></a><span class="co">(* DistribM.distrib (MontyExact.monty_win true);; *)</span></span></code></pre></div>
<p>The famous result: switching doubles your chances of winning!
Counter-intuitively, the host’s choice of which door to open gives you
information – by switching, you are betting that your initial choice was
wrong (which it is 2/3 of the time).</p>
<h3 id="conditional-probabilities">Conditional Probabilities</h3>
<p>So far we have computed unconditional probabilities. But what if we
want to answer questions like “given that X happened, what is the
probability of Y?” This is a conditional probability <span
class="math inline">P(Y|X)</span>.</p>
<p>Wouldn’t it be nice to have a monad-plus rather than just a monad?
Then we could use <code>guard</code> for conditional probabilities!</p>
<p>To compute <span class="math inline">P(A|B)</span>: 1. Compute what
is needed for both <span class="math inline">A</span> and <span
class="math inline">B</span> 2. Guard <span class="math inline">B</span>
3. Return <span class="math inline">A</span></p>
<p>For the exact distribution monad, we allow intermediate distributions
to be <em>unnormalized</em> (probabilities sum to less than 1) and
normalize at the end. For the sampling monad, we use <em>rejection
sampling</em>: generate samples and discard those that do not satisfy
the condition (though <code>mplus</code> has no straightforward correct
implementation in this approach).</p>
<div class="sourceCode" id="cb320"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb320-1"><a href="#cb320-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">type</span> COND_PROBAB = <span class="kw">sig</span></span>
<span id="cb320-2"><a href="#cb320-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> PROBABILITY</span>
<span id="cb320-3"><a href="#cb320-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> MONAD_PLUS_OPS <span class="kw">with</span> <span class="kw">type</span> &#39;a monad := &#39;a monad</span>
<span id="cb320-4"><a href="#cb320-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb320-5"><a href="#cb320-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb320-6"><a href="#cb320-6" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> DistribMP : COND_PROBAB = <span class="kw">struct</span></span>
<span id="cb320-7"><a href="#cb320-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">module</span> MP = <span class="kw">struct</span></span>
<span id="cb320-8"><a href="#cb320-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> &#39;a t = (&#39;a * <span class="dt">float</span>) <span class="dt">list</span>      <span class="co">(* Measures no longer restricted to *)</span></span>
<span id="cb320-9"><a href="#cb320-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> bind a b = merge               <span class="co">(* probability distributions *)</span></span>
<span id="cb320-10"><a href="#cb320-10" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">List</span>.concat_map (<span class="kw">fun</span> (x, p) -&gt;</span>
<span id="cb320-11"><a href="#cb320-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">List</span>.map (<span class="kw">fun</span> (y, q) -&gt; (y, q *. p)) (b x)) a)</span>
<span id="cb320-12"><a href="#cb320-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> return a = [a, <span class="dv">1</span>.]</span>
<span id="cb320-13"><a href="#cb320-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> mzero = []                     <span class="co">(* Measure equal 0 everywhere is OK *)</span></span>
<span id="cb320-14"><a href="#cb320-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> mplus = <span class="dt">List</span>.append</span>
<span id="cb320-15"><a href="#cb320-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end</span></span>
<span id="cb320-16"><a href="#cb320-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> MP</span>
<span id="cb320-17"><a href="#cb320-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> MonadPlusOps (MP)</span>
<span id="cb320-18"><a href="#cb320-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> choose p a b =              <span class="co">(* It isn&#39;t a w.p. p &amp; b w.p. (1-p) since a and b *)</span></span>
<span id="cb320-19"><a href="#cb320-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">List</span>.map (<span class="kw">fun</span> (e,w) -&gt; e, p *. w) a @  <span class="co">(* are not normalized! *)</span></span>
<span id="cb320-20"><a href="#cb320-20" aria-hidden="true" tabindex="-1"></a>      <span class="dt">List</span>.map (<span class="kw">fun</span> (e,w) -&gt; e, (<span class="dv">1</span>. -. p) *. w) b</span>
<span id="cb320-21"><a href="#cb320-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> pick dist = dist</span>
<span id="cb320-22"><a href="#cb320-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> uniform elems = normalize</span>
<span id="cb320-23"><a href="#cb320-23" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">List</span>.map (<span class="kw">fun</span> e -&gt; e, <span class="dv">1</span>.) elems)</span>
<span id="cb320-24"><a href="#cb320-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> coin = [<span class="kw">true</span>, <span class="fl">0.5</span>; <span class="kw">false</span>, <span class="fl">0.5</span>]</span>
<span id="cb320-25"><a href="#cb320-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> flip p = [<span class="kw">true</span>, p; <span class="kw">false</span>, <span class="dv">1</span>. -. p]</span>
<span id="cb320-26"><a href="#cb320-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> prob p m = normalize m           <span class="co">(* Final normalization step *)</span></span>
<span id="cb320-27"><a href="#cb320-27" aria-hidden="true" tabindex="-1"></a>    |&gt; <span class="dt">List</span>.filter (<span class="kw">fun</span> (e,_) -&gt; p e)</span>
<span id="cb320-28"><a href="#cb320-28" aria-hidden="true" tabindex="-1"></a>    |&gt; <span class="dt">List</span>.map <span class="dt">snd</span> |&gt; <span class="dt">List</span>.fold_left (+.) <span class="dv">0</span>.</span>
<span id="cb320-29"><a href="#cb320-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> distrib m = normalize m</span>
<span id="cb320-30"><a href="#cb320-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> access m = roulette m</span>
<span id="cb320-31"><a href="#cb320-31" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb320-32"><a href="#cb320-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb320-33"><a href="#cb320-33" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> SamplingMP (S : <span class="kw">sig</span> <span class="kw">val</span> samples : <span class="dt">int</span> <span class="kw">end</span>) : COND_PROBAB = <span class="kw">struct</span></span>
<span id="cb320-34"><a href="#cb320-34" aria-hidden="true" tabindex="-1"></a>  <span class="kw">exception</span> Rejected              <span class="co">(* For rejecting current sample *)</span></span>
<span id="cb320-35"><a href="#cb320-35" aria-hidden="true" tabindex="-1"></a>  <span class="kw">module</span> MP = <span class="kw">struct</span>              <span class="co">(* Monad operations are exactly as for SamplingM *)</span></span>
<span id="cb320-36"><a href="#cb320-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> &#39;a t = <span class="dt">unit</span> -&gt; &#39;a</span>
<span id="cb320-37"><a href="#cb320-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> bind a b () = b (a ()) ()</span>
<span id="cb320-38"><a href="#cb320-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> return a = <span class="kw">fun</span> () -&gt; a</span>
<span id="cb320-39"><a href="#cb320-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> mzero = <span class="kw">fun</span> () -&gt; <span class="dt">raise</span> Rejected  <span class="co">(* but now we can fail *)</span></span>
<span id="cb320-40"><a href="#cb320-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> mplus a b = <span class="kw">fun</span> () -&gt;</span>
<span id="cb320-41"><a href="#cb320-41" aria-hidden="true" tabindex="-1"></a>      <span class="dt">failwith</span> <span class="st">&quot;SamplingMP.mplus not implemented&quot;</span></span>
<span id="cb320-42"><a href="#cb320-42" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end</span></span>
<span id="cb320-43"><a href="#cb320-43" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> MP</span>
<span id="cb320-44"><a href="#cb320-44" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> MonadPlusOps (MP)</span>
<span id="cb320-45"><a href="#cb320-45" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> choose p a b () =                <span class="co">(* Inside-monad operations don&#39;t change *)</span></span>
<span id="cb320-46"><a href="#cb320-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="dt">Random</span>.<span class="dt">float</span> <span class="dv">1</span>. &lt;= p <span class="kw">then</span> a () <span class="kw">else</span> b ()</span>
<span id="cb320-47"><a href="#cb320-47" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> pick dist = <span class="kw">fun</span> () -&gt; roulette dist</span>
<span id="cb320-48"><a href="#cb320-48" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> uniform elems =</span>
<span id="cb320-49"><a href="#cb320-49" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> n = <span class="dt">List</span>.length elems <span class="kw">in</span></span>
<span id="cb320-50"><a href="#cb320-50" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fun</span> () -&gt; <span class="dt">List</span>.nth elems (<span class="dt">Random</span>.<span class="dt">int</span> n)</span>
<span id="cb320-51"><a href="#cb320-51" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> coin = <span class="dt">Random</span>.<span class="dt">bool</span></span>
<span id="cb320-52"><a href="#cb320-52" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> flip p = choose p (return <span class="kw">true</span>) (return <span class="kw">false</span>)</span>
<span id="cb320-53"><a href="#cb320-53" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> prob p m =                  <span class="co">(* Getting out of monad: handle rejected samples *)</span></span>
<span id="cb320-54"><a href="#cb320-54" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> count = <span class="dt">ref</span> <span class="dv">0</span> <span class="kw">and</span> tot = <span class="dt">ref</span> <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb320-55"><a href="#cb320-55" aria-hidden="true" tabindex="-1"></a>    <span class="kw">while</span> !tot &lt; S.samples <span class="kw">do</span>          <span class="co">(* Count up to the required *)</span></span>
<span id="cb320-56"><a href="#cb320-56" aria-hidden="true" tabindex="-1"></a>      <span class="kw">try</span>                              <span class="co">(* number of samples *)</span></span>
<span id="cb320-57"><a href="#cb320-57" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> p (m ()) <span class="kw">then</span> <span class="dt">incr</span> count;   <span class="co">(* m() can fail *)</span></span>
<span id="cb320-58"><a href="#cb320-58" aria-hidden="true" tabindex="-1"></a>        <span class="dt">incr</span> tot                       <span class="co">(* But if we got here it hasn&#39;t *)</span></span>
<span id="cb320-59"><a href="#cb320-59" aria-hidden="true" tabindex="-1"></a>      <span class="kw">with</span> Rejected -&gt; ()              <span class="co">(* Rejected, keep sampling *)</span></span>
<span id="cb320-60"><a href="#cb320-60" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span>;</span>
<span id="cb320-61"><a href="#cb320-61" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float_of_int</span> !count /. <span class="dt">float_of_int</span> S.samples</span>
<span id="cb320-62"><a href="#cb320-62" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> distrib m =</span>
<span id="cb320-63"><a href="#cb320-63" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> dist = <span class="dt">ref</span> [] <span class="kw">and</span> tot = <span class="dt">ref</span> <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb320-64"><a href="#cb320-64" aria-hidden="true" tabindex="-1"></a>    <span class="kw">while</span> !tot &lt; S.samples <span class="kw">do</span></span>
<span id="cb320-65"><a href="#cb320-65" aria-hidden="true" tabindex="-1"></a>      <span class="kw">try</span></span>
<span id="cb320-66"><a href="#cb320-66" aria-hidden="true" tabindex="-1"></a>        dist := (m (), <span class="dv">1</span>.) :: !dist;</span>
<span id="cb320-67"><a href="#cb320-67" aria-hidden="true" tabindex="-1"></a>        <span class="dt">incr</span> tot</span>
<span id="cb320-68"><a href="#cb320-68" aria-hidden="true" tabindex="-1"></a>      <span class="kw">with</span> Rejected -&gt; ()</span>
<span id="cb320-69"><a href="#cb320-69" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span>;</span>
<span id="cb320-70"><a href="#cb320-70" aria-hidden="true" tabindex="-1"></a>    normalize (merge !dist)</span>
<span id="cb320-71"><a href="#cb320-71" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> access m =</span>
<span id="cb320-72"><a href="#cb320-72" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> m () <span class="kw">with</span> Rejected -&gt; access m</span>
<span id="cb320-73"><a href="#cb320-73" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<h3 id="burglary-example-encoding-a-bayes-net">Burglary Example:
Encoding a Bayes Net</h3>
<p>Consider a problem with this dependency structure:</p>
<ul>
<li>An alarm can be due to either a burglary or an earthquake</li>
<li>You are on vacation and have asked neighbors John and Mary to call
if the alarm rings</li>
<li>Mary only calls when she is really sure about the alarm, but John
has better hearing</li>
<li>Earthquakes are twice as probable as burglaries</li>
<li>The alarm has about 30% chance of going off during an
earthquake</li>
<li>You can check on the radio if there was an earthquake, but you might
miss the news</li>
</ul>
<p>Probability tables:</p>
<ul>
<li><span class="math inline">P(\text{Burglary}) = 0.001</span></li>
<li><span class="math inline">P(\text{Earthquake}) = 0.002</span></li>
<li><span class="math inline">P(\text{Alarm}|\text{B}, \text{E})</span>
varies (0.001 for FF, 0.29 for FT, 0.94 for TF, 0.95 for TT)</li>
<li><span class="math inline">P(\text{John calls}|\text{Alarm})</span>
is 0.9 if alarm, 0.05 otherwise</li>
<li><span class="math inline">P(\text{Mary calls}|\text{Alarm})</span>
is 0.7 if alarm, 0.01 otherwise</li>
</ul>
<div class="sourceCode" id="cb321"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb321-1"><a href="#cb321-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Burglary (P : COND_PROBAB) = <span class="kw">struct</span></span>
<span id="cb321-2"><a href="#cb321-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">open</span> P</span>
<span id="cb321-3"><a href="#cb321-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> what_happened =</span>
<span id="cb321-4"><a href="#cb321-4" aria-hidden="true" tabindex="-1"></a>    | Safe | Burgl | Earthq | Burgl_n_earthq</span>
<span id="cb321-5"><a href="#cb321-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb321-6"><a href="#cb321-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> check ~john_called ~mary_called ~radio =</span>
<span id="cb321-7"><a href="#cb321-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* earthquake = flip <span class="fl">0.002</span> <span class="kw">in</span></span>
<span id="cb321-8"><a href="#cb321-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* () = guard (radio = <span class="dt">None</span> || radio = <span class="dt">Some</span> earthquake) <span class="kw">in</span></span>
<span id="cb321-9"><a href="#cb321-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* burglary = flip <span class="fl">0.001</span> <span class="kw">in</span></span>
<span id="cb321-10"><a href="#cb321-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> alarm_p =</span>
<span id="cb321-11"><a href="#cb321-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">match</span> burglary, earthquake <span class="kw">with</span></span>
<span id="cb321-12"><a href="#cb321-12" aria-hidden="true" tabindex="-1"></a>      | <span class="kw">false</span>, <span class="kw">false</span> -&gt; <span class="fl">0.001</span></span>
<span id="cb321-13"><a href="#cb321-13" aria-hidden="true" tabindex="-1"></a>      | <span class="kw">false</span>, <span class="kw">true</span> -&gt; <span class="fl">0.29</span></span>
<span id="cb321-14"><a href="#cb321-14" aria-hidden="true" tabindex="-1"></a>      | <span class="kw">true</span>, <span class="kw">false</span> -&gt; <span class="fl">0.94</span></span>
<span id="cb321-15"><a href="#cb321-15" aria-hidden="true" tabindex="-1"></a>      | <span class="kw">true</span>, <span class="kw">true</span> -&gt; <span class="fl">0.95</span> <span class="kw">in</span></span>
<span id="cb321-16"><a href="#cb321-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* alarm = flip alarm_p <span class="kw">in</span></span>
<span id="cb321-17"><a href="#cb321-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> john_p = <span class="kw">if</span> alarm <span class="kw">then</span> <span class="fl">0.9</span> <span class="kw">else</span> <span class="fl">0.05</span> <span class="kw">in</span></span>
<span id="cb321-18"><a href="#cb321-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* john_calls = flip john_p <span class="kw">in</span></span>
<span id="cb321-19"><a href="#cb321-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* () = guard (john_calls = john_called) <span class="kw">in</span></span>
<span id="cb321-20"><a href="#cb321-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> mary_p = <span class="kw">if</span> alarm <span class="kw">then</span> <span class="fl">0.7</span> <span class="kw">else</span> <span class="fl">0.01</span> <span class="kw">in</span></span>
<span id="cb321-21"><a href="#cb321-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* mary_calls = flip mary_p <span class="kw">in</span></span>
<span id="cb321-22"><a href="#cb321-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* () = guard (mary_calls = mary_called) <span class="kw">in</span></span>
<span id="cb321-23"><a href="#cb321-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> burglary, earthquake <span class="kw">with</span></span>
<span id="cb321-24"><a href="#cb321-24" aria-hidden="true" tabindex="-1"></a>    | <span class="kw">false</span>, <span class="kw">false</span> -&gt; return Safe</span>
<span id="cb321-25"><a href="#cb321-25" aria-hidden="true" tabindex="-1"></a>    | <span class="kw">true</span>, <span class="kw">false</span> -&gt; return Burgl</span>
<span id="cb321-26"><a href="#cb321-26" aria-hidden="true" tabindex="-1"></a>    | <span class="kw">false</span>, <span class="kw">true</span> -&gt; return Earthq</span>
<span id="cb321-27"><a href="#cb321-27" aria-hidden="true" tabindex="-1"></a>    | <span class="kw">true</span>, <span class="kw">true</span> -&gt; return Burgl_n_earthq</span>
<span id="cb321-28"><a href="#cb321-28" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb321-29"><a href="#cb321-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb321-30"><a href="#cb321-30" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> BurglaryExact = Burglary (DistribMP)</span>
<span id="cb321-31"><a href="#cb321-31" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Sampling2000 =</span>
<span id="cb321-32"><a href="#cb321-32" aria-hidden="true" tabindex="-1"></a>  SamplingMP (<span class="kw">struct</span> <span class="kw">let</span> samples = <span class="dv">2000</span> <span class="kw">end</span>)</span>
<span id="cb321-33"><a href="#cb321-33" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> BurglarySimul = Burglary (Sampling2000)</span></code></pre></div>
<h2 id="lightweight-cooperative-threads">8.14 Lightweight Cooperative
Threads</h2>
<p>Running multiple tasks asynchronously can hide I/O latency and
utilize multi-core architectures. Traditional operating system threads
are “heavyweight” – they have significant overhead for context switching
and memory. <strong>Lightweight threads</strong> are managed by the
application rather than the OS, allowing many concurrent tasks with
lower overhead.</p>
<p>Lightweight threads can be: - <strong>Preemptive</strong>: The
scheduler interrupts running threads to switch between them -
<strong>Cooperative</strong>: Threads voluntarily give up control at
specific points (like I/O operations)</p>
<p><strong>Lwt</strong> is a popular OCaml library for lightweight
cooperative threads, implemented as a monad. The monadic structure
ensures that thread switching happens at well-defined points (whenever
you use <code>let*</code>), making the code easier to reason about.</p>
<p>The <code>bind</code> operation is inherently sequential:
<code>bind a (fun x -&gt; b)</code> computes <code>a</code>, and only
resumes computing <code>b</code> once the result <code>x</code> is
known.</p>
<p>For concurrency, we need to “suppress” this sequentiality. We
introduce a parallel bind:</p>
<pre><code>parallel : &#39;a monad -&gt; &#39;b monad -&gt; (&#39;a -&gt; &#39;b -&gt; &#39;c monad) -&gt; &#39;c monad</code></pre>
<p>With <code>parallel a b (fun x y -&gt; c)</code>, computations
<code>a</code> and <code>b</code> can proceed concurrently. The
continuation <code>c</code> runs once both results are available.</p>
<p>If the monad starts computing right away (as in the Lwt library),
<code>parallel ea eb c</code> is equivalent to:</p>
<pre><code>let a = ea in
let b = eb in
let* x = a in
let* y = b in
c x y</code></pre>
<h3 id="fine-grained-vs.-coarse-grained-concurrency">Fine-Grained
vs. Coarse-Grained Concurrency</h3>
<p>There are two approaches to when threads switch:</p>
<p><strong>Fine-grained</strong> concurrency suspends at every
<code>bind</code>. The scheduler runs other threads and comes back to
complete the <code>bind</code> before running threads created since the
suspension. This gives maximum interleaving but has higher overhead.</p>
<p><strong>Coarse-grained</strong> concurrency only suspends when
explicitly requested via a <code>suspend</code> (often called
<code>yield</code>) operation. Library operations that need to wait for
I/O should call <code>suspend</code> internally. This is more efficient
but requires careful placement of suspension points.</p>
<h3 id="thread-monad-signatures">Thread Monad Signatures</h3>
<p>The thread monad extends the basic monad with parallel
composition:</p>
<div class="sourceCode" id="cb324"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb324-1"><a href="#cb324-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">type</span> THREADS = <span class="kw">sig</span></span>
<span id="cb324-2"><a href="#cb324-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> MONAD</span>
<span id="cb324-3"><a href="#cb324-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> parallel :</span>
<span id="cb324-4"><a href="#cb324-4" aria-hidden="true" tabindex="-1"></a>    &#39;a t -&gt; &#39;b t -&gt; (&#39;a -&gt; &#39;b -&gt; &#39;c t) -&gt; &#39;c t</span>
<span id="cb324-5"><a href="#cb324-5" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb324-6"><a href="#cb324-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb324-7"><a href="#cb324-7" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">type</span> THREAD_OPS = <span class="kw">sig</span></span>
<span id="cb324-8"><a href="#cb324-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> MONAD_OPS</span>
<span id="cb324-9"><a href="#cb324-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> THREADS <span class="kw">with</span> <span class="kw">type</span> &#39;a t := &#39;a monad</span>
<span id="cb324-10"><a href="#cb324-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> parallel_map :</span>
<span id="cb324-11"><a href="#cb324-11" aria-hidden="true" tabindex="-1"></a>    &#39;a <span class="dt">list</span> -&gt; (&#39;a -&gt; &#39;b monad) -&gt; &#39;b <span class="dt">list</span> monad</span>
<span id="cb324-12"><a href="#cb324-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> (&gt;||=) :</span>
<span id="cb324-13"><a href="#cb324-13" aria-hidden="true" tabindex="-1"></a>    &#39;a monad -&gt; &#39;b monad -&gt; (&#39;a -&gt; &#39;b -&gt; &#39;c monad) -&gt; &#39;c monad</span>
<span id="cb324-14"><a href="#cb324-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> (&gt;||) :</span>
<span id="cb324-15"><a href="#cb324-15" aria-hidden="true" tabindex="-1"></a>    &#39;a monad -&gt; &#39;b monad -&gt; (<span class="dt">unit</span> -&gt; &#39;c monad) -&gt; &#39;c monad</span>
<span id="cb324-16"><a href="#cb324-16" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb324-17"><a href="#cb324-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb324-18"><a href="#cb324-18" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">type</span> THREADSYS = <span class="kw">sig</span></span>
<span id="cb324-19"><a href="#cb324-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> THREADS</span>
<span id="cb324-20"><a href="#cb324-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> access : &#39;a t -&gt; &#39;a</span>
<span id="cb324-21"><a href="#cb324-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> kill_threads : <span class="dt">unit</span> -&gt; <span class="dt">unit</span></span>
<span id="cb324-22"><a href="#cb324-22" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb324-23"><a href="#cb324-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb324-24"><a href="#cb324-24" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> ThreadOps (M : THREADS) = <span class="kw">struct</span></span>
<span id="cb324-25"><a href="#cb324-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">open</span> M</span>
<span id="cb324-26"><a href="#cb324-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> MonadOps (M)</span>
<span id="cb324-27"><a href="#cb324-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> parallel_map l f =</span>
<span id="cb324-28"><a href="#cb324-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">List</span>.fold_right (<span class="kw">fun</span> a bs -&gt;</span>
<span id="cb324-29"><a href="#cb324-29" aria-hidden="true" tabindex="-1"></a>      parallel (f a) bs</span>
<span id="cb324-30"><a href="#cb324-30" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">fun</span> a bs -&gt; return (a::bs))) l (return [])</span>
<span id="cb324-31"><a href="#cb324-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (&gt;||=) = parallel</span>
<span id="cb324-32"><a href="#cb324-32" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (&gt;||) a b c = parallel a b (<span class="kw">fun</span> _ _ -&gt; c ())</span>
<span id="cb324-33"><a href="#cb324-33" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb324-34"><a href="#cb324-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb324-35"><a href="#cb324-35" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Threads (M : THREADSYS) : <span class="kw">sig</span></span>
<span id="cb324-36"><a href="#cb324-36" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> THREAD_OPS</span>
<span id="cb324-37"><a href="#cb324-37" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> access : &#39;a monad -&gt; &#39;a</span>
<span id="cb324-38"><a href="#cb324-38" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> kill_threads : <span class="dt">unit</span> -&gt; <span class="dt">unit</span></span>
<span id="cb324-39"><a href="#cb324-39" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span> = <span class="kw">struct</span></span>
<span id="cb324-40"><a href="#cb324-40" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> M</span>
<span id="cb324-41"><a href="#cb324-41" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> ThreadOps(M)</span>
<span id="cb324-42"><a href="#cb324-42" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<h3 id="cooperative-thread-implementation">Cooperative Thread
Implementation</h3>
<p>The implementation uses a mutable state to track thread progress.
Each thread is in one of three states: completed (<code>Return</code>),
waiting (<code>Sleep</code> with a list of callbacks to invoke when
done), or forwarded to another thread (<code>Link</code>):</p>
<div class="sourceCode" id="cb325"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb325-1"><a href="#cb325-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Cooperative = Threads(<span class="kw">struct</span></span>
<span id="cb325-2"><a href="#cb325-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a state =</span>
<span id="cb325-3"><a href="#cb325-3" aria-hidden="true" tabindex="-1"></a>    | Return <span class="kw">of</span> &#39;a                 <span class="co">(* The thread has returned *)</span></span>
<span id="cb325-4"><a href="#cb325-4" aria-hidden="true" tabindex="-1"></a>    | Sleep <span class="kw">of</span> (&#39;a -&gt; <span class="dt">unit</span>) <span class="dt">list</span>   <span class="co">(* When thread returns, wake up waiters *)</span></span>
<span id="cb325-5"><a href="#cb325-5" aria-hidden="true" tabindex="-1"></a>    | Link <span class="kw">of</span> &#39;a t                 <span class="co">(* A link to the actual thread *)</span></span>
<span id="cb325-6"><a href="#cb325-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">and</span> &#39;a t = {<span class="kw">mutable</span> state : &#39;a state}  <span class="co">(* State of the thread can change *)</span></span>
<span id="cb325-7"><a href="#cb325-7" aria-hidden="true" tabindex="-1"></a>                                   <span class="co">(* -- it can return, or more waiters added *)</span></span>
<span id="cb325-8"><a href="#cb325-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> find t =                 <span class="co">(* Union-find style link chasing *)</span></span>
<span id="cb325-9"><a href="#cb325-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> t.state <span class="kw">with</span></span>
<span id="cb325-10"><a href="#cb325-10" aria-hidden="true" tabindex="-1"></a>    | Link t -&gt; find t</span>
<span id="cb325-11"><a href="#cb325-11" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; t</span>
<span id="cb325-12"><a href="#cb325-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb325-13"><a href="#cb325-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> jobs = <span class="dt">Queue</span>.create ()       <span class="co">(* Work queue -- will store unit -&gt; unit procedures *)</span></span>
<span id="cb325-14"><a href="#cb325-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb325-15"><a href="#cb325-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> wakeup m a =                 <span class="co">(* Thread m has actually finished -- *)</span></span>
<span id="cb325-16"><a href="#cb325-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> m = find m <span class="kw">in</span>              <span class="co">(* updating its state *)</span></span>
<span id="cb325-17"><a href="#cb325-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m.state <span class="kw">with</span></span>
<span id="cb325-18"><a href="#cb325-18" aria-hidden="true" tabindex="-1"></a>    | Return _ -&gt; <span class="kw">assert</span> <span class="kw">false</span></span>
<span id="cb325-19"><a href="#cb325-19" aria-hidden="true" tabindex="-1"></a>    | Sleep waiters -&gt;</span>
<span id="cb325-20"><a href="#cb325-20" aria-hidden="true" tabindex="-1"></a>        m.state &lt;- Return a;       <span class="co">(* Set the state, and only then *)</span></span>
<span id="cb325-21"><a href="#cb325-21" aria-hidden="true" tabindex="-1"></a>        <span class="dt">List</span>.iter ((|&gt;) a) waiters <span class="co">(* wake up the waiters *)</span></span>
<span id="cb325-22"><a href="#cb325-22" aria-hidden="true" tabindex="-1"></a>    | Link _ -&gt; <span class="kw">assert</span> <span class="kw">false</span></span>
<span id="cb325-23"><a href="#cb325-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb325-24"><a href="#cb325-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> return a = {state = Return a}</span>
<span id="cb325-25"><a href="#cb325-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb325-26"><a href="#cb325-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> connect t t&#39; =               <span class="co">(* t was a placeholder for t&#39; *)</span></span>
<span id="cb325-27"><a href="#cb325-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> t&#39; = find t&#39; <span class="kw">in</span></span>
<span id="cb325-28"><a href="#cb325-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> t&#39;.state <span class="kw">with</span></span>
<span id="cb325-29"><a href="#cb325-29" aria-hidden="true" tabindex="-1"></a>    | Sleep waiters&#39; -&gt;</span>
<span id="cb325-30"><a href="#cb325-30" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> t = find t <span class="kw">in</span></span>
<span id="cb325-31"><a href="#cb325-31" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">match</span> t.state <span class="kw">with</span></span>
<span id="cb325-32"><a href="#cb325-32" aria-hidden="true" tabindex="-1"></a>        | Sleep waiters -&gt;         <span class="co">(* If both sleep, collect their waiters *)</span></span>
<span id="cb325-33"><a href="#cb325-33" aria-hidden="true" tabindex="-1"></a>            t.state &lt;- Sleep (waiters&#39; @ waiters);</span>
<span id="cb325-34"><a href="#cb325-34" aria-hidden="true" tabindex="-1"></a>            t&#39;.state &lt;- Link t     <span class="co">(* and link one to the other *)</span></span>
<span id="cb325-35"><a href="#cb325-35" aria-hidden="true" tabindex="-1"></a>        | _ -&gt; <span class="kw">assert</span> <span class="kw">false</span>)</span>
<span id="cb325-36"><a href="#cb325-36" aria-hidden="true" tabindex="-1"></a>    | Return x -&gt; wakeup t x       <span class="co">(* If t&#39; returned, wake up the placeholder *)</span></span>
<span id="cb325-37"><a href="#cb325-37" aria-hidden="true" tabindex="-1"></a>    | Link _ -&gt; <span class="kw">assert</span> <span class="kw">false</span></span>
<span id="cb325-38"><a href="#cb325-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb325-39"><a href="#cb325-39" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> bind a b =</span>
<span id="cb325-40"><a href="#cb325-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> a = find a <span class="kw">in</span></span>
<span id="cb325-41"><a href="#cb325-41" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> m = {state = Sleep []} <span class="kw">in</span>  <span class="co">(* The resulting monad *)</span></span>
<span id="cb325-42"><a href="#cb325-42" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">match</span> a.state <span class="kw">with</span></span>
<span id="cb325-43"><a href="#cb325-43" aria-hidden="true" tabindex="-1"></a>    | Return x -&gt;                  <span class="co">(* If a returned, we suspend further work *)</span></span>
<span id="cb325-44"><a href="#cb325-44" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> job () = connect m (b x) <span class="kw">in</span>  <span class="co">(* (In exercise 11, this should *)</span></span>
<span id="cb325-45"><a href="#cb325-45" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Queue</span>.push job jobs        <span class="co">(* only happen after suspend) *)</span></span>
<span id="cb325-46"><a href="#cb325-46" aria-hidden="true" tabindex="-1"></a>    | Sleep waiters -&gt;             <span class="co">(* If a sleeps, we wait for it to return *)</span></span>
<span id="cb325-47"><a href="#cb325-47" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> job x = connect m (b x) <span class="kw">in</span></span>
<span id="cb325-48"><a href="#cb325-48" aria-hidden="true" tabindex="-1"></a>        a.state &lt;- Sleep (job::waiters)</span>
<span id="cb325-49"><a href="#cb325-49" aria-hidden="true" tabindex="-1"></a>    | Link _ -&gt; <span class="kw">assert</span> <span class="kw">false</span>);</span>
<span id="cb325-50"><a href="#cb325-50" aria-hidden="true" tabindex="-1"></a>    m</span>
<span id="cb325-51"><a href="#cb325-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb325-52"><a href="#cb325-52" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> parallel a b c =             <span class="co">(* Since in our implementation *)</span></span>
<span id="cb325-53"><a href="#cb325-53" aria-hidden="true" tabindex="-1"></a>    bind a (<span class="kw">fun</span> x -&gt;               <span class="co">(* the threads run as soon as they are created, *)</span></span>
<span id="cb325-54"><a href="#cb325-54" aria-hidden="true" tabindex="-1"></a>    bind b (<span class="kw">fun</span> y -&gt;               <span class="co">(* parallel is redundant *)</span></span>
<span id="cb325-55"><a href="#cb325-55" aria-hidden="true" tabindex="-1"></a>    c x y))</span>
<span id="cb325-56"><a href="#cb325-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb325-57"><a href="#cb325-57" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> access m =               <span class="co">(* Accessing not only gets the result of m, *)</span></span>
<span id="cb325-58"><a href="#cb325-58" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> m = find m <span class="kw">in</span>              <span class="co">(* but spins the thread loop till m terminates *)</span></span>
<span id="cb325-59"><a href="#cb325-59" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> m.state <span class="kw">with</span></span>
<span id="cb325-60"><a href="#cb325-60" aria-hidden="true" tabindex="-1"></a>    | Return x -&gt; x                <span class="co">(* No further work *)</span></span>
<span id="cb325-61"><a href="#cb325-61" aria-hidden="true" tabindex="-1"></a>    | Sleep _ -&gt;</span>
<span id="cb325-62"><a href="#cb325-62" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">try</span> <span class="dt">Queue</span>.pop jobs ()     <span class="co">(* Perform suspended work *)</span></span>
<span id="cb325-63"><a href="#cb325-63" aria-hidden="true" tabindex="-1"></a>         <span class="kw">with</span> <span class="dt">Queue</span>.Empty -&gt;</span>
<span id="cb325-64"><a href="#cb325-64" aria-hidden="true" tabindex="-1"></a>           <span class="dt">failwith</span> <span class="st">&quot;access: result not available&quot;</span>);</span>
<span id="cb325-65"><a href="#cb325-65" aria-hidden="true" tabindex="-1"></a>        access m</span>
<span id="cb325-66"><a href="#cb325-66" aria-hidden="true" tabindex="-1"></a>    | Link _ -&gt; <span class="kw">assert</span> <span class="kw">false</span></span>
<span id="cb325-67"><a href="#cb325-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb325-68"><a href="#cb325-68" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> kill_threads () = <span class="dt">Queue</span>.clear jobs  <span class="co">(* Remove pending work *)</span></span>
<span id="cb325-69"><a href="#cb325-69" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>)</span></code></pre></div>
<h3 id="testing-the-thread-implementation">Testing the Thread
Implementation</h3>
<p>Let us test the implementation with two threads that each print a
sequence of numbers:</p>
<div class="sourceCode" id="cb326"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb326-1"><a href="#cb326-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> TTest (T : THREAD_OPS) = <span class="kw">struct</span></span>
<span id="cb326-2"><a href="#cb326-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">open</span> T</span>
<span id="cb326-3"><a href="#cb326-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> loop s n =</span>
<span id="cb326-4"><a href="#cb326-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* () = return (<span class="dt">Printf</span>.printf <span class="st">&quot;-- %s(%d)</span><span class="ch">\n</span><span class="st">%!&quot;</span> s n) <span class="kw">in</span></span>
<span id="cb326-5"><a href="#cb326-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n &gt; <span class="dv">0</span> <span class="kw">then</span> loop s (n<span class="dv">-1</span>)     <span class="co">(* We cannot use whenM because the thread *)</span></span>
<span id="cb326-6"><a href="#cb326-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> return ()                 <span class="co">(* would be created regardless of condition *)</span></span>
<span id="cb326-7"><a href="#cb326-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb326-8"><a href="#cb326-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb326-9"><a href="#cb326-9" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> TT = TTest (Cooperative)</span>
<span id="cb326-10"><a href="#cb326-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb326-11"><a href="#cb326-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> test =</span>
<span id="cb326-12"><a href="#cb326-12" aria-hidden="true" tabindex="-1"></a>  Cooperative.kill_threads ();     <span class="co">(* Clean-up after previous tests *)</span></span>
<span id="cb326-13"><a href="#cb326-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> thread1 = TT.loop <span class="st">&quot;A&quot;</span> <span class="dv">5</span> <span class="kw">in</span></span>
<span id="cb326-14"><a href="#cb326-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> thread2 = TT.loop <span class="st">&quot;B&quot;</span> <span class="dv">4</span> <span class="kw">in</span></span>
<span id="cb326-15"><a href="#cb326-15" aria-hidden="true" tabindex="-1"></a>  Cooperative.access thread1;      <span class="co">(* We ensure threads finish computing *)</span></span>
<span id="cb326-16"><a href="#cb326-16" aria-hidden="true" tabindex="-1"></a>  Cooperative.access thread2       <span class="co">(* before we proceed *)</span></span></code></pre></div>
<p>The output shows that the threads interleave their execution
beautifully: A(5), B(4), A(4), B(3), and so on. Each <code>bind</code>
(the <code>let*</code>) causes a context switch to the other thread.
This is fine-grained concurrency in action.</p>
<p>The key insight is that monadic structure gives us precise control
over concurrency. Every <code>let*</code> is a potential suspension
point, making the code’s behavior predictable and debuggable – a
significant advantage over preemptive threading where context switches
can happen anywhere.</p>
<h2 id="exercises-7">8.15 Exercises</h2>
<p><strong>Exercise 1.</strong> (Puzzle via Oleg Kiselyov)</p>
<p>“U2” has a concert that starts in 17 minutes and they must all cross
a bridge to get there. All four men begin on the same side of the
bridge. It is night. There is one flashlight. A maximum of two people
can cross at one time. Any party who crosses, either 1 or 2 people, must
have the flashlight with them. The flashlight must be walked back and
forth, it cannot be thrown, etc. Each band member walks at a different
speed. A pair must walk together at the rate of the slower man’s
pace:</p>
<ul>
<li>Bono: 1 minute to cross</li>
<li>Edge: 2 minutes to cross</li>
<li>Adam: 5 minutes to cross</li>
<li>Larry: 10 minutes to cross</li>
</ul>
<p>For example: if Bono and Larry walk across first, 10 minutes have
elapsed when they get to the other side of the bridge. If Larry then
returns with the flashlight, a total of 20 minutes have passed and you
have failed the mission.</p>
<p>Find all answers to the puzzle using <code>let*</code> notation. The
expression will be a bit long but recursion is not needed.</p>
<p><strong>Exercise 2.</strong> Assume <code>concat_map</code> as
defined in lecture 6 and the binding operators defined above. What will
the following expressions return? Why?</p>
<ol type="1">
<li><code>let* _ = return 5 in return 7</code></li>
<li><code>let guard p = if p then [()] else [] in let* () = guard false in return 7</code></li>
<li><code>let* _ = return 5 in let* () = guard false in return 7</code></li>
</ol>
<p><strong>Exercise 3.</strong> Define <code>bind</code> in terms of
<code>lift</code> and <code>join</code>.</p>
<p><strong>Exercise 4.</strong> Define a monad-plus implementation based
on binary trees, with constant-time <code>mzero</code> and
<code>mplus</code>. Starter code:</p>
<div class="sourceCode" id="cb327"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb327-1"><a href="#cb327-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a tree = Empty | Leaf <span class="kw">of</span> &#39;a | T <span class="kw">of</span> &#39;a tree * &#39;a tree</span>
<span id="cb327-2"><a href="#cb327-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb327-3"><a href="#cb327-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> TreeM = MonadPlus (<span class="kw">struct</span></span>
<span id="cb327-4"><a href="#cb327-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a t = &#39;a tree</span>
<span id="cb327-5"><a href="#cb327-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> bind a b = <span class="co">(* </span><span class="al">TODO</span><span class="co"> *)</span></span>
<span id="cb327-6"><a href="#cb327-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> return a = <span class="co">(* </span><span class="al">TODO</span><span class="co"> *)</span></span>
<span id="cb327-7"><a href="#cb327-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> mzero = <span class="co">(* </span><span class="al">TODO</span><span class="co"> *)</span></span>
<span id="cb327-8"><a href="#cb327-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> mplus a b = <span class="co">(* </span><span class="al">TODO</span><span class="co"> *)</span></span>
<span id="cb327-9"><a href="#cb327-9" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>)</span></code></pre></div>
<p><strong>Exercise 5.</strong> Show the monad-plus laws for one of: 1.
<code>TreeM</code> from your solution of exercise 4 2.
<code>ListM</code> from lecture</p>
<p><strong>Exercise 6.</strong> Why is the following monad-plus not lazy
enough?</p>
<div class="sourceCode" id="cb328"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb328-1"><a href="#cb328-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> badappend l1 l2 =</span>
<span id="cb328-2"><a href="#cb328-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> l1 <span class="kw">with</span> <span class="kw">lazy</span> LazNil -&gt; l2</span>
<span id="cb328-3"><a href="#cb328-3" aria-hidden="true" tabindex="-1"></a>  | <span class="kw">lazy</span> (LazCons (hd, tl)) -&gt;</span>
<span id="cb328-4"><a href="#cb328-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">lazy</span> (LazCons (hd, badappend tl l2))</span>
<span id="cb328-5"><a href="#cb328-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb328-6"><a href="#cb328-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> badconcatmap f = <span class="kw">function</span></span>
<span id="cb328-7"><a href="#cb328-7" aria-hidden="true" tabindex="-1"></a>  | <span class="kw">lazy</span> LazNil -&gt; <span class="kw">lazy</span> LazNil</span>
<span id="cb328-8"><a href="#cb328-8" aria-hidden="true" tabindex="-1"></a>  | <span class="kw">lazy</span> (LazCons (a, l)) -&gt;</span>
<span id="cb328-9"><a href="#cb328-9" aria-hidden="true" tabindex="-1"></a>      badappend (f a) (badconcatmap f l)</span>
<span id="cb328-10"><a href="#cb328-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb328-11"><a href="#cb328-11" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> BadyListM = MonadPlus (<span class="kw">struct</span></span>
<span id="cb328-12"><a href="#cb328-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a t = &#39;a lazylist</span>
<span id="cb328-13"><a href="#cb328-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> bind a b = badconcatmap b a</span>
<span id="cb328-14"><a href="#cb328-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> return a = <span class="kw">lazy</span> (LazCons (a, <span class="kw">lazy</span> LazNil))</span>
<span id="cb328-15"><a href="#cb328-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> mzero = <span class="kw">lazy</span> LazNil</span>
<span id="cb328-16"><a href="#cb328-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> mplus = badappend</span>
<span id="cb328-17"><a href="#cb328-17" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>)</span></code></pre></div>
<p><strong>Exercise 7.</strong> Convert a “rectangular” list of lists of
strings, representing a matrix with inner lists being rows, into a
string, where elements are column-aligned. (Exercise not related to
monads.)</p>
<p><strong>Exercise 8.</strong> Recall the enriched monad signature with
<code>('s, 'a) t</code> type. Design the signatures for the exception
monad operations to provide more flexibility than our exception monad.
Does the implementation need to change?</p>
<p><strong>Exercise 9.</strong> Implement the following constructs for
<em>all</em> monads:</p>
<ol type="1">
<li><code>for...to...</code></li>
<li><code>for...downto...</code></li>
<li><code>while...do...</code></li>
<li><code>do...while...</code></li>
<li><code>repeat...until...</code></li>
</ol>
<p>Explain how, when your implementation is instantiated with the StateM
monad, we get the solution to exercise 2 from lecture 4.</p>
<p><strong>Exercise 10.</strong> A canonical example of a probabilistic
model is that of a lawn whose grass may be wet because it rained,
because the sprinkler was on, or for some other reason. The probability
tables are:</p>
<p><span class="math display">
\begin{aligned}
P(\text{cloudy}) &amp;= 0.5 \\
P(\text{rain}|\text{cloudy}) &amp;= 0.8 \\
P(\text{rain}|\neg\text{cloudy}) &amp;= 0.2 \\
P(\text{sprinkler}|\text{cloudy}) &amp;= 0.1 \\
P(\text{sprinkler}|\neg\text{cloudy}) &amp;= 0.5 \\
P(\text{wet\_roof}|\neg\text{rain}) &amp;= 0 \\
P(\text{wet\_roof}|\text{rain}) &amp;= 0.7 \\
P(\text{wet\_grass}|\text{rain} \land \neg\text{sprinkler}) &amp;= 0.9
\\
P(\text{wet\_grass}|\text{sprinkler} \land \neg\text{rain}) &amp;= 0.9
\end{aligned}
</span></p>
<p>We observe whether the grass is wet and whether the roof is wet. What
is the probability that it rained?</p>
<p><strong>Exercise 11.</strong> Implement the coarse-grained
concurrency model:</p>
<ul>
<li>Modify <code>bind</code> to compute the resulting monad straight
away if the input monad has returned.</li>
<li>Introduce <code>suspend</code> to do what in the fine-grained model
was the effect of <code>bind (return a) b</code>, i.e., suspend the work
although it could already be started.</li>
<li>One possibility is to introduce <code>suspend</code> of type
<code>unit monad</code>, introduce a “dummy” monadic value
<code>Suspend</code> (besides <code>Return</code> and
<code>Sleep</code>), and define <code>bind suspend b</code> to do what
<code>bind (return ()) b</code> would formerly do.</li>
</ul>
<h1 id="chapter-9-algebraic-effects">Chapter 9: Algebraic Effects</h1>
<p><strong>In this chapter, you will:</strong></p>
<ul>
<li>Understand Generalized Algebraic Data Types (GADTs) and how they
enable type-refined pattern matching</li>
<li>Learn about algebraic effects and handlers as a powerful alternative
to monads</li>
<li>Implement lightweight cooperative threads using effects (comparing
with the monad-based version)</li>
<li>Model probabilistic programming with effect handlers</li>
<li>Build interpreters for probabilistic programs: rejection sampling
and particle filtering</li>
<li>Understand the replay-with-fast-forward pattern for efficient
inference</li>
<li>Use GADTs to build a type-safe probabilistic programming
interface</li>
</ul>
<p>OCaml 5 introduced a game-changing feature: algebraic effects with
effect handlers. While monads provide a disciplined way to structure
effectful computations, they require threading computations explicitly
through bind operations. Algebraic effects offer a different approach:
effects can be performed directly, and handlers define how those effects
are interpreted.</p>
<p>This chapter explores algebraic effects through two substantial
examples. First, we will reimplement the cooperative lightweight threads
from the previous chapter, showing how effects simplify the code. Then
we will tackle probabilistic programming, building interpreters that can
answer questions about probability distributions.</p>
<p>Before diving into effects, we need to understand GADTs – they are
the foundation on which OCaml’s effect system is built.</p>
<h2 id="generalized-algebraic-data-types">9.1 Generalized Algebraic Data
Types</h2>
<p>Generalized Algebraic Data Types (GADTs) extend ordinary algebraic
data types by allowing each constructor to specify a <em>more
precise</em> return type. Where regular data types have constructors
that all produce the same type, GADT constructors can refine the type
parameter.</p>
<h3 id="basic-gadt-syntax">Basic GADT Syntax</h3>
<p>Consider a simple expression type. With ordinary data types, we
cannot distinguish integer expressions from boolean expressions at the
type level:</p>
<div class="sourceCode" id="cb329"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb329-1"><a href="#cb329-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> expr =</span>
<span id="cb329-2"><a href="#cb329-2" aria-hidden="true" tabindex="-1"></a>  | <span class="dt">Int</span> <span class="kw">of</span> <span class="dt">int</span></span>
<span id="cb329-3"><a href="#cb329-3" aria-hidden="true" tabindex="-1"></a>  | <span class="dt">Bool</span> <span class="kw">of</span> <span class="dt">bool</span></span>
<span id="cb329-4"><a href="#cb329-4" aria-hidden="true" tabindex="-1"></a>  | Add <span class="kw">of</span> expr * expr</span>
<span id="cb329-5"><a href="#cb329-5" aria-hidden="true" tabindex="-1"></a>  | If <span class="kw">of</span> expr * expr * expr</span></code></pre></div>
<p>The <code>Add</code> constructor should only work with integer
expressions, but the type system cannot enforce this – we can construct
<code>Add (Bool true, Bool false)</code> which is nonsensical.</p>
<p>GADTs solve this problem. The syntax uses explicit return type
annotations:</p>
<div class="sourceCode" id="cb330"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb330-1"><a href="#cb330-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> _ expr =</span>
<span id="cb330-2"><a href="#cb330-2" aria-hidden="true" tabindex="-1"></a>  | <span class="dt">Int</span> : <span class="dt">int</span> -&gt; <span class="dt">int</span> expr</span>
<span id="cb330-3"><a href="#cb330-3" aria-hidden="true" tabindex="-1"></a>  | <span class="dt">Bool</span> : <span class="dt">bool</span> -&gt; <span class="dt">bool</span> expr</span>
<span id="cb330-4"><a href="#cb330-4" aria-hidden="true" tabindex="-1"></a>  | Add : <span class="dt">int</span> expr * <span class="dt">int</span> expr -&gt; <span class="dt">int</span> expr</span>
<span id="cb330-5"><a href="#cb330-5" aria-hidden="true" tabindex="-1"></a>  | If : <span class="dt">bool</span> expr * &#39;a expr * &#39;a expr -&gt; &#39;a expr</span></code></pre></div>
<p>Each constructor now specifies its return type after the colon.
<code>Int</code> constructs an <code>int expr</code>, <code>Bool</code>
constructs a <code>bool expr</code>, and <code>Add</code> requires two
<code>int expr</code> arguments and produces an <code>int expr</code>.
The <code>If</code> constructor is polymorphic: it requires a boolean
condition and two branches of the same type <code>'a</code>, producing
an <code>'a expr</code>.</p>
<p>Now <code>Add (Bool true, Bool false)</code> is a type error – the
type checker rejects it because <code>Bool true</code> has type
<code>bool expr</code>, not <code>int expr</code>.</p>
<h3 id="type-refinement-in-pattern-matching">Type Refinement in Pattern
Matching</h3>
<p>The real power of GADTs emerges in pattern matching. When we match on
a GADT constructor, the type checker <em>learns</em> information about
the type parameter:</p>
<div class="sourceCode" id="cb331"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb331-1"><a href="#cb331-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> eval : <span class="kw">type</span> a. a expr -&gt; a = <span class="kw">function</span></span>
<span id="cb331-2"><a href="#cb331-2" aria-hidden="true" tabindex="-1"></a>  | <span class="dt">Int</span> n -&gt; n          <span class="co">(* Here a = int, so we return int *)</span></span>
<span id="cb331-3"><a href="#cb331-3" aria-hidden="true" tabindex="-1"></a>  | <span class="dt">Bool</span> b -&gt; b         <span class="co">(* Here a = bool, so we return bool *)</span></span>
<span id="cb331-4"><a href="#cb331-4" aria-hidden="true" tabindex="-1"></a>  | Add (e1, e2) -&gt; eval e1 + eval e2   <span class="co">(* Here a = int *)</span></span>
<span id="cb331-5"><a href="#cb331-5" aria-hidden="true" tabindex="-1"></a>  | If (cond, then_, else_) -&gt;</span>
<span id="cb331-6"><a href="#cb331-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> eval cond <span class="kw">then</span> eval then_ <span class="kw">else</span> eval else_</span></code></pre></div>
<p>The annotation <code>type a. a expr -&gt; a</code> declares a
<em>locally abstract type</em> <code>a</code>. This tells OCaml that
<code>a</code> is a type variable that may be refined differently in
each branch. In the <code>Int n</code> branch, the type checker knows
that <code>a = int</code> because we matched the <code>Int</code>
constructor which returns <code>int expr</code>. This allows us to
return <code>n</code> (an <code>int</code>) where the return type is
<code>a</code> – which in this branch <em>is</em> <code>int</code>.</p>
<p>Without the locally abstract type annotation, the code would fail to
type-check. The annotation is necessary because different branches may
assign different concrete types to <code>a</code>.</p>
<h3 id="existential-types-in-gadts">Existential Types in GADTs</h3>
<p>GADT constructors can introduce <em>existential</em> type variables –
types that exist within the constructor but are not exposed in the
result type:</p>
<div class="sourceCode" id="cb332"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb332-1"><a href="#cb332-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> printable =</span>
<span id="cb332-2"><a href="#cb332-2" aria-hidden="true" tabindex="-1"></a>  | Printable : { value : &#39;a; print : &#39;a -&gt; <span class="dt">string</span> } -&gt; printable</span></code></pre></div>
<p>The type variable <code>'a</code> appears in the arguments but not in
the result type <code>printable</code>. This means we can pack any value
together with a function that knows how to print it:</p>
<div class="sourceCode" id="cb333"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb333-1"><a href="#cb333-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> examples = [</span>
<span id="cb333-2"><a href="#cb333-2" aria-hidden="true" tabindex="-1"></a>  Printable { value = <span class="dv">42</span>; print = <span class="dt">string_of_int</span> };</span>
<span id="cb333-3"><a href="#cb333-3" aria-hidden="true" tabindex="-1"></a>  Printable { value = <span class="st">&quot;hello&quot;</span>; print = <span class="dt">Fun</span>.id };</span>
<span id="cb333-4"><a href="#cb333-4" aria-hidden="true" tabindex="-1"></a>  Printable { value = [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>]; print = <span class="kw">fun</span> l -&gt;</span>
<span id="cb333-5"><a href="#cb333-5" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;[&quot;</span> ^ <span class="dt">String</span>.concat <span class="st">&quot;; &quot;</span> (<span class="dt">List</span>.map <span class="dt">string_of_int</span> l) ^ <span class="st">&quot;]&quot;</span> }</span>
<span id="cb333-6"><a href="#cb333-6" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb333-7"><a href="#cb333-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb333-8"><a href="#cb333-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> print_all items =</span>
<span id="cb333-9"><a href="#cb333-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.iter (<span class="kw">fun</span> (Printable { value; print }) -&gt;</span>
<span id="cb333-10"><a href="#cb333-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">print_endline</span> (print value)) items</span>
<span id="cb333-11"><a href="#cb333-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb333-12"><a href="#cb333-12" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () = print_all examples</span></code></pre></div>
<p>Within the pattern match, we can use <code>print value</code> because
both refer to the same existential type <code>'a</code>. But we cannot
extract <code>value</code> and use it outside the pattern – its type is
unknown.</p>
<h3 id="connection-to-type-inference">Connection to Type Inference</h3>
<p>In <a href="#type-inference-formally">Section 5.3</a>, we presented
the formal rules for type constraint generation. The key rule for
pattern clauses was:</p>
<p><span class="math display">[\![ \Gamma, \Sigma \vdash p.e : \tau_1
\rightarrow \tau_2 ]\!] = [\![ \Sigma \vdash p \downarrow \tau_1 ]\!]
\wedge \forall \overline{\beta} . [\![ \Gamma \Gamma&#39; \vdash e :
\tau_2 ]\!]</span></p>
<p>where <span class="math inline">\exists \overline{\beta}
\Gamma&#39;</span> is <span class="math inline">[\![ \Sigma \vdash p
\uparrow \tau_1 ]\!]</span>, <span class="math inline">\overline{\beta}
\# \text{FV}(\Gamma, \tau_2)</span></p>
<p>For ordinary data types, the constraints derived from patterns are
equations. For GADTs, the pattern derivation also produces type
equalities <span class="math inline">D</span>, so we have <span
class="math inline">\exists \overline{\beta} [D] \Gamma&#39;</span> from
<span class="math inline">[\![ \Sigma \vdash p \uparrow \tau_1
]\!]</span>, and the constraint becomes an <em>implication</em>:</p>
<p><span class="math display">[\![ \Gamma, \Sigma \vdash p.e : \tau_1
\rightarrow \tau_2 ]\!] = [\![ \Sigma \vdash p \downarrow \tau_1 ]\!]
\wedge \forall \overline{\beta} . D \Rightarrow [\![ \Gamma \Gamma&#39;
\vdash e : \tau_2 ]\!]</span></p>
<p>The premise <span class="math inline">D</span> is the conjunction of
type equalities that the GADT constructor establishes. The universal
quantification over <span class="math inline">\overline{\beta}</span>
reflects that these equalities hold for <em>all</em> values matching the
pattern.</p>
<p>For example, when type-checking <code>eval</code> and matching the
<code>Int n</code> case:</p>
<ul>
<li>The pattern produces the equality <span class="math inline">D =
(\text{a} \doteq \text{int})</span></li>
<li>The constraint becomes: <span class="math inline">\forall \text{a} .
(\text{a} \doteq \text{int}) \Rightarrow [\![ \text{n} : \text{int}
\vdash \text{n} : \text{a} ]\!]</span></li>
<li>Under the assumption <code>a = int</code>, returning
<code>n : int</code> satisfies the requirement
<code>result : a</code></li>
</ul>
<p>This is why GADT pattern matching can have different types in
different branches – each branch operates under different type
assumptions given by the implication premise. The type checker uses
these <em>local type refinements</em> to verify that each branch is
well-typed.</p>
<p>GADTs also enable the type checker to recognize <em>impossible</em>
cases. If a function takes <code>int expr</code> as input, the
<code>Bool</code> constructor can never match because <code>Bool</code>
produces <code>bool expr</code>, not <code>int expr</code>. The compiler
can use this information for exhaustiveness checking.</p>
<h3 id="gadts-and-effects">GADTs and Effects</h3>
<p>OCaml’s effect system uses GADTs in a fundamental way. The type
<code>Effect.t</code> is defined roughly as:</p>
<div class="sourceCode" id="cb334"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb334-1"><a href="#cb334-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> _ <span class="dt">Effect</span>.t = ..</span></code></pre></div>
<p>This is an <em>extensible</em> GADT – new constructors can be added
anywhere in the program. The type parameter indicates what type of value
the effect produces when handled:</p>
<div class="sourceCode" id="cb335"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb335-1"><a href="#cb335-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> _ <span class="dt">Effect</span>.t +=</span>
<span id="cb335-2"><a href="#cb335-2" aria-hidden="true" tabindex="-1"></a>  | Get : <span class="dt">int</span> <span class="dt">Effect</span>.t           <span class="co">(* Returns an int *)</span></span>
<span id="cb335-3"><a href="#cb335-3" aria-hidden="true" tabindex="-1"></a>  | Put : <span class="dt">int</span> -&gt; <span class="dt">unit</span> <span class="dt">Effect</span>.t   <span class="co">(* Takes an int, returns unit *)</span></span></code></pre></div>
<p>When handling effects, the continuation’s type is refined based on
which effect was performed:</p>
<div class="sourceCode" id="cb336"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb336-1"><a href="#cb336-1" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> f () <span class="kw">with</span></span>
<span id="cb336-2"><a href="#cb336-2" aria-hidden="true" tabindex="-1"></a>| <span class="dt">result</span> -&gt; <span class="dt">result</span></span>
<span id="cb336-3"><a href="#cb336-3" aria-hidden="true" tabindex="-1"></a>| effect Get, k -&gt; <span class="dt">Effect</span>.Deep.continue k <span class="dv">42</span></span>
<span id="cb336-4"><a href="#cb336-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* k : (int, &#39;a) continuation because Get : int Effect.t *)</span></span>
<span id="cb336-5"><a href="#cb336-5" aria-hidden="true" tabindex="-1"></a>| effect (Put n), k -&gt; <span class="dt">Effect</span>.Deep.continue k ()</span>
<span id="cb336-6"><a href="#cb336-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* k : (unit, &#39;a) continuation because Put : unit Effect.t *)</span></span></code></pre></div>
<p>The GADT structure ensures type safety: you cannot
<code>continue k "hello"</code> when handling <code>Get</code> because
the continuation expects an <code>int</code>. This type safety is
crucial for building reliable effect handlers.</p>
<p>With this foundation, we can now explore how effects provide an
elegant alternative to monads.</p>
<h2 id="from-monads-to-effects">9.2 From Monads to Effects</h2>
<p>In the previous chapter, we saw how monads structure effectful
computations. Every monadic operation had to be sequenced with
<code>let*</code>:</p>
<div class="sourceCode" id="cb337"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb337-1"><a href="#cb337-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> loop s n =</span>
<span id="cb337-2"><a href="#cb337-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span>* () = return (<span class="dt">Printf</span>.printf <span class="st">&quot;-- %s(%d)</span><span class="ch">\n</span><span class="st">%!&quot;</span> s n) <span class="kw">in</span></span>
<span id="cb337-3"><a href="#cb337-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span>* () = yield <span class="kw">in</span>  <span class="co">(* yielding could be implicit in the monad&#39;s bind *)</span></span>
<span id="cb337-4"><a href="#cb337-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n &gt; <span class="dv">0</span> <span class="kw">then</span> loop s (n<span class="dv">-1</span>)</span>
<span id="cb337-5"><a href="#cb337-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> return ()</span></code></pre></div>
<p>This works, but it is infectious: once you are inside a monad,
everything must be monadic. You cannot simply call a regular function
that might perform effects – you must lift it into the monad. Even a
simple <code>Printf.printf</code> must be wrapped in
<code>return</code>.</p>
<p>Algebraic effects take a different approach. Effects are
<em>performed</em> as regular function calls, and <em>handled</em> at a
distance:</p>
<div class="sourceCode" id="cb338"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb338-1"><a href="#cb338-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> loop s n =</span>
<span id="cb338-2"><a href="#cb338-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Printf</span>.printf <span class="st">&quot;-- %s(%d)</span><span class="ch">\n</span><span class="st">%!&quot;</span> s n;</span>
<span id="cb338-3"><a href="#cb338-3" aria-hidden="true" tabindex="-1"></a>  yield ();  <span class="co">(* explicit effect, but looks like a normal call *)</span></span>
<span id="cb338-4"><a href="#cb338-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n &gt; <span class="dv">0</span> <span class="kw">then</span> loop s (n<span class="dv">-1</span>)</span></code></pre></div>
<p>The key difference is not that effects happen implicitly – you still
call <code>yield ()</code> explicitly at suspension points. The
difference is that:</p>
<ol type="1">
<li><strong>Direct style</strong>: Effects look like ordinary function
calls, not monadic binds</li>
<li><strong>Non-infectious</strong>: Code that does not perform effects
(like <code>Printf.printf</code>) remains unchanged</li>
<li><strong>Separation of concerns</strong>: The program says
<em>what</em> effects occur; the handler decides <em>how</em> to
interpret them</li>
</ol>
<h3 id="a-first-example">A First Example</h3>
<p>Before diving into the full API, let us see the simplest possible
effect: one that asks for an integer value.</p>
<div class="sourceCode" id="cb339"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb339-1"><a href="#cb339-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> _ <span class="dt">Effect</span>.t += Ask : <span class="dt">int</span> <span class="dt">Effect</span>.t</span>
<span id="cb339-2"><a href="#cb339-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb339-3"><a href="#cb339-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ask () = <span class="dt">Effect</span>.perform Ask</span>
<span id="cb339-4"><a href="#cb339-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb339-5"><a href="#cb339-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> program () =</span>
<span id="cb339-6"><a href="#cb339-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> x = ask () <span class="kw">in</span></span>
<span id="cb339-7"><a href="#cb339-7" aria-hidden="true" tabindex="-1"></a>  x + <span class="dv">1</span></span>
<span id="cb339-8"><a href="#cb339-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb339-9"><a href="#cb339-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> answer_42 () =</span>
<span id="cb339-10"><a href="#cb339-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">try</span> program () <span class="kw">with</span></span>
<span id="cb339-11"><a href="#cb339-11" aria-hidden="true" tabindex="-1"></a>  | effect Ask, k -&gt; <span class="dt">Effect</span>.Deep.continue k <span class="dv">42</span></span>
<span id="cb339-12"><a href="#cb339-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb339-13"><a href="#cb339-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () = <span class="kw">assert</span> (answer_42 () = <span class="dv">43</span>)</span></code></pre></div>
<p>The <code>try ... with | effect Ask, k -&gt; ...</code> syntax
handles effects similarly to how <code>try ... with</code> handles
exceptions. When the <code>Ask</code> effect is performed, the pattern
<code>effect Ask, k</code> matches. The variable <code>k</code> is the
<em>continuation</em>: it represents “the rest of the computation” from
the point where the effect was performed. By calling
<code>Effect.Deep.continue k 42</code>, we resume the computation with
<code>42</code> as the result of <code>ask ()</code>.</p>
<h3 id="declaring-effects">Declaring Effects</h3>
<p>Effects are declared by extending the built-in extensible GADT
<code>Effect.t</code>. The type parameter indicates what the effect
returns:</p>
<div class="sourceCode" id="cb340"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb340-1"><a href="#cb340-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> _ <span class="dt">Effect</span>.t += Yield : <span class="dt">unit</span> <span class="dt">Effect</span>.t</span></code></pre></div>
<p>This declares a <code>Yield</code> effect that returns
<code>unit</code>. The <code>type _ Effect.t +=</code> syntax is similar
to how exceptions extend the <code>exn</code> type.</p>
<p>Effects can carry data and return values:</p>
<div class="sourceCode" id="cb341"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb341-1"><a href="#cb341-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> _ <span class="dt">Effect</span>.t += Get : <span class="dt">int</span> <span class="dt">Effect</span>.t</span>
<span id="cb341-2"><a href="#cb341-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> _ <span class="dt">Effect</span>.t += Put : <span class="dt">int</span> -&gt; <span class="dt">unit</span> <span class="dt">Effect</span>.t</span></code></pre></div>
<p>Here <code>Get</code> is an effect that returns an <code>int</code>,
and <code>Put</code> takes an <code>int</code> argument and returns
<code>unit</code>.</p>
<h3 id="performing-effects">Performing Effects</h3>
<p>To perform an effect, we use <code>Effect.perform</code>:</p>
<div class="sourceCode" id="cb342"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb342-1"><a href="#cb342-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> yield () = <span class="dt">Effect</span>.perform Yield</span>
<span id="cb342-2"><a href="#cb342-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> get () = <span class="dt">Effect</span>.perform Get</span>
<span id="cb342-3"><a href="#cb342-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> put n = <span class="dt">Effect</span>.perform (Put n)</span></code></pre></div>
<p>When <code>Effect.perform</code> is called, control transfers to the
nearest enclosing handler for that effect. If no handler exists, OCaml
raises <code>Effect.Unhandled</code>.</p>
<p><strong>Note:</strong> The effect system API is marked as unstable in
OCaml 5.x and may change in future versions. Effects can only be
performed synchronously – not from signal handlers, finalisers, or C
callbacks.</p>
<h3 id="handling-effects">Handling Effects</h3>
<p>OCaml 5.3+ provides a convenient syntax for handling effects. The
simplest form uses <code>try ... with</code> when you just want to
return the result unchanged. When you need to transform the result, and
especially if you want to pattern match on it,
<code>match ... with</code> is more elegant.</p>
<div class="sourceCode" id="cb343"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb343-1"><a href="#cb343-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () =</span>
<span id="cb343-2"><a href="#cb343-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> state = <span class="dt">ref</span> <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb343-3"><a href="#cb343-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="dt">result</span> =</span>
<span id="cb343-4"><a href="#cb343-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> put <span class="dv">10</span>; get () + get () <span class="kw">with</span></span>
<span id="cb343-5"><a href="#cb343-5" aria-hidden="true" tabindex="-1"></a>    | effect Get, k -&gt; <span class="dt">Effect</span>.Deep.continue k !state</span>
<span id="cb343-6"><a href="#cb343-6" aria-hidden="true" tabindex="-1"></a>    | effect (Put n), k -&gt; state := n; <span class="dt">Effect</span>.Deep.continue k ()</span>
<span id="cb343-7"><a href="#cb343-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb343-8"><a href="#cb343-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assert</span> (<span class="dt">result</span> = <span class="dv">20</span>)</span></code></pre></div>
<p>The <code>effect E, k</code> pattern matches when effect
<code>E</code> is performed. The continuation <code>k</code> captures
everything that would happen after <code>Effect.perform</code> returns.
We can:</p>
<ul>
<li><strong>Continue</strong> by calling
<code>Effect.Deep.continue k value</code>, where <code>value</code>
becomes the return value of <code>perform</code></li>
<li><strong>Discontinue</strong> by calling
<code>Effect.Deep.discontinue k exn</code>, raising an exception at the
effect site</li>
<li><strong>Store</strong> the continuation and resume it later (useful
for schedulers)</li>
</ul>
<p><strong>Important:</strong> OCaml continuations are <em>one-shot</em>
– each continuation must be resumed exactly once with
<code>continue</code> or <code>discontinue</code>. Attempting to resume
a continuation twice raises
<code>Effect.Continuation_already_resumed</code>. Not resuming a
continuation might work in specific cases but risks leaking resources
(e.g. open files).</p>
<p>The three kinds of patterns in a handler correspond to three
cases:</p>
<ul>
<li>Regular patterns handle normal return values</li>
<li><code>exception</code> patterns handle raised exceptions</li>
<li><code>effect</code> patterns handle performed effects</li>
</ul>
<p>This mirrors the explicit handler record form
<code>{ retc; exnc; effc }</code> used by
<code>Effect.Deep.match_with</code>.</p>
<h3 id="deep-vs-shallow-handlers">Deep vs Shallow Handlers</h3>
<p>OCaml provides two kinds of handlers in <code>Effect.Deep</code> and
<code>Effect.Shallow</code>:</p>
<ul>
<li><p><strong>Deep handlers</strong> (which we use throughout this
chapter) automatically re-install themselves when you continue a
computation. Effects performed after resumption are handled by the same
handler.</p></li>
<li><p><strong>Shallow handlers</strong> handle only the first effect
encountered. After continuing, subsequent effects are not automatically
handled. This gives more control but requires more explicit
management.</p></li>
</ul>
<p>For most use cases, deep handlers are simpler and sufficient. We will
use <code>Effect.Deep</code> exclusively in this chapter.</p>
<p>This ability to capture and manipulate continuations is what makes
algebraic effects so powerful. Let us see this in action.</p>
<h2 id="lightweight-threads-with-effects">9.3 Lightweight Threads with
Effects</h2>
<p>In the previous chapter, we implemented cooperative threads using a
monad. The implementation involved mutable state to track thread status,
a work queue, and careful management of continuations encoded as
closures. With effects, we can write a much simpler implementation.</p>
<h3 id="the-thread-interface">The Thread Interface</h3>
<p>Our goal is to support concurrent computations that can yield control
to other threads and eventually produce results. Here is a simple
interface:</p>
<div class="sourceCode" id="cb344"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb344-1"><a href="#cb344-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">type</span> THREADS = <span class="kw">sig</span></span>
<span id="cb344-2"><a href="#cb344-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a promise</span>
<span id="cb344-3"><a href="#cb344-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> async : (<span class="dt">unit</span> -&gt; &#39;a) -&gt; &#39;a promise  <span class="co">(* Start a new thread *)</span></span>
<span id="cb344-4"><a href="#cb344-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> await : &#39;a promise -&gt; &#39;a            <span class="co">(* Wait for a thread to complete *)</span></span>
<span id="cb344-5"><a href="#cb344-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> yield : <span class="dt">unit</span> -&gt; <span class="dt">unit</span>                <span class="co">(* Yield control to other threads *)</span></span>
<span id="cb344-6"><a href="#cb344-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> run : (<span class="dt">unit</span> -&gt; &#39;a) -&gt; &#39;a            <span class="co">(* Run the scheduler *)</span></span>
<span id="cb344-7"><a href="#cb344-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>A <em>promise</em> represents a computation that will eventually
produce a value. We can start new threads with <code>async</code>, wait
for their results with <code>await</code>, and voluntarily give up
control with <code>yield</code>.</p>
<h3 id="declaring-the-effects">Declaring the Effects</h3>
<p>We need three effects:</p>
<div class="sourceCode" id="cb345"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb345-1"><a href="#cb345-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a promise_state =</span>
<span id="cb345-2"><a href="#cb345-2" aria-hidden="true" tabindex="-1"></a>  | Pending <span class="kw">of</span> (&#39;a, <span class="dt">unit</span>) <span class="dt">Effect</span>.Deep.continuation <span class="dt">list</span>  <span class="co">(* Waiting continuations *)</span></span>
<span id="cb345-3"><a href="#cb345-3" aria-hidden="true" tabindex="-1"></a>  | Done <span class="kw">of</span> &#39;a                                           <span class="co">(* Completed with value *)</span></span>
<span id="cb345-4"><a href="#cb345-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb345-5"><a href="#cb345-5" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a promise = &#39;a promise_state <span class="dt">ref</span></span>
<span id="cb345-6"><a href="#cb345-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb345-7"><a href="#cb345-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> _ <span class="dt">Effect</span>.t +=</span>
<span id="cb345-8"><a href="#cb345-8" aria-hidden="true" tabindex="-1"></a>  | Async : (<span class="dt">unit</span> -&gt; &#39;a) -&gt; &#39;a promise <span class="dt">Effect</span>.t  <span class="co">(* Fork a new thread *)</span></span>
<span id="cb345-9"><a href="#cb345-9" aria-hidden="true" tabindex="-1"></a>  | Await : &#39;a promise -&gt; &#39;a <span class="dt">Effect</span>.t            <span class="co">(* Wait for completion *)</span></span>
<span id="cb345-10"><a href="#cb345-10" aria-hidden="true" tabindex="-1"></a>  | TYield : <span class="dt">unit</span> <span class="dt">Effect</span>.t                       <span class="co">(* Give up control *)</span></span></code></pre></div>
<p>The <code>Async</code> effect carries a thunk and returns a promise.
The <code>Await</code> effect takes a promise and returns its value
(potentially blocking). The <code>TYield</code> effect temporarily
suspends the current thread.</p>
<p>A promise is a mutable reference that starts as <code>Pending</code>
(with a list of continuations waiting for the result) and becomes
<code>Done</code> once the computation completes.</p>
<h3 id="the-scheduler">The Scheduler</h3>
<p>The scheduler maintains a queue of ready threads (continuations
waiting to run):</p>
<div class="sourceCode" id="cb346"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb346-1"><a href="#cb346-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Threads : THREADS = <span class="kw">struct</span></span>
<span id="cb346-2"><a href="#cb346-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a promise_state =</span>
<span id="cb346-3"><a href="#cb346-3" aria-hidden="true" tabindex="-1"></a>    | Pending <span class="kw">of</span> (&#39;a, <span class="dt">unit</span>) <span class="dt">Effect</span>.Deep.continuation <span class="dt">list</span></span>
<span id="cb346-4"><a href="#cb346-4" aria-hidden="true" tabindex="-1"></a>    | Done <span class="kw">of</span> &#39;a</span>
<span id="cb346-5"><a href="#cb346-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a promise = &#39;a promise_state <span class="dt">ref</span></span>
<span id="cb346-6"><a href="#cb346-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb346-7"><a href="#cb346-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> _ <span class="dt">Effect</span>.t +=</span>
<span id="cb346-8"><a href="#cb346-8" aria-hidden="true" tabindex="-1"></a>    | Async : (<span class="dt">unit</span> -&gt; &#39;a) -&gt; &#39;a promise <span class="dt">Effect</span>.t</span>
<span id="cb346-9"><a href="#cb346-9" aria-hidden="true" tabindex="-1"></a>    | Await : &#39;a promise -&gt; &#39;a <span class="dt">Effect</span>.t</span>
<span id="cb346-10"><a href="#cb346-10" aria-hidden="true" tabindex="-1"></a>    | TYield : <span class="dt">unit</span> <span class="dt">Effect</span>.t</span>
<span id="cb346-11"><a href="#cb346-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb346-12"><a href="#cb346-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> async f = <span class="dt">Effect</span>.perform (Async f)</span>
<span id="cb346-13"><a href="#cb346-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> await p = <span class="dt">Effect</span>.perform (Await p)</span>
<span id="cb346-14"><a href="#cb346-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> yield () = <span class="dt">Effect</span>.perform TYield</span>
<span id="cb346-15"><a href="#cb346-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb346-16"><a href="#cb346-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> run_queue : (<span class="dt">unit</span> -&gt; <span class="dt">unit</span>) <span class="dt">Queue</span>.t = <span class="dt">Queue</span>.create ()</span>
<span id="cb346-17"><a href="#cb346-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> enqueue f = <span class="dt">Queue</span>.push f run_queue</span>
<span id="cb346-18"><a href="#cb346-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> dequeue () = <span class="kw">if</span> <span class="dt">Queue</span>.is_empty run_queue <span class="kw">then</span> () <span class="kw">else</span> <span class="dt">Queue</span>.pop run_queue ()</span>
<span id="cb346-19"><a href="#cb346-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb346-20"><a href="#cb346-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> fulfill p v =</span>
<span id="cb346-21"><a href="#cb346-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> !p <span class="kw">with</span></span>
<span id="cb346-22"><a href="#cb346-22" aria-hidden="true" tabindex="-1"></a>    | Done _ -&gt; <span class="dt">failwith</span> <span class="st">&quot;Promise already fulfilled&quot;</span></span>
<span id="cb346-23"><a href="#cb346-23" aria-hidden="true" tabindex="-1"></a>    | Pending waiters -&gt;</span>
<span id="cb346-24"><a href="#cb346-24" aria-hidden="true" tabindex="-1"></a>        p := Done v;</span>
<span id="cb346-25"><a href="#cb346-25" aria-hidden="true" tabindex="-1"></a>        <span class="dt">List</span>.iter (<span class="kw">fun</span> k -&gt; enqueue (<span class="kw">fun</span> () -&gt; <span class="dt">Effect</span>.Deep.continue k v)) waiters</span>
<span id="cb346-26"><a href="#cb346-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb346-27"><a href="#cb346-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> run_thread : &#39;a. (<span class="dt">unit</span> -&gt; &#39;a) -&gt; &#39;a promise = <span class="kw">fun</span> f -&gt;</span>
<span id="cb346-28"><a href="#cb346-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> p = <span class="dt">ref</span> (Pending []) <span class="kw">in</span></span>
<span id="cb346-29"><a href="#cb346-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> () = <span class="kw">match</span> f () <span class="kw">with</span></span>
<span id="cb346-30"><a href="#cb346-30" aria-hidden="true" tabindex="-1"></a>      | v -&gt; fulfill p v; dequeue ()</span>
<span id="cb346-31"><a href="#cb346-31" aria-hidden="true" tabindex="-1"></a>      | effect (Async g), k -&gt;</span>
<span id="cb346-32"><a href="#cb346-32" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> p&#39; = run_thread g <span class="kw">in</span></span>
<span id="cb346-33"><a href="#cb346-33" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Effect</span>.Deep.continue k p&#39;</span>
<span id="cb346-34"><a href="#cb346-34" aria-hidden="true" tabindex="-1"></a>      | effect (Await p&#39;), k -&gt;</span>
<span id="cb346-35"><a href="#cb346-35" aria-hidden="true" tabindex="-1"></a>          (<span class="kw">match</span> !p&#39; <span class="kw">with</span></span>
<span id="cb346-36"><a href="#cb346-36" aria-hidden="true" tabindex="-1"></a>           | Done v -&gt; <span class="dt">Effect</span>.Deep.continue k v</span>
<span id="cb346-37"><a href="#cb346-37" aria-hidden="true" tabindex="-1"></a>           | Pending ks -&gt; p&#39; := Pending (k :: ks); dequeue ())</span>
<span id="cb346-38"><a href="#cb346-38" aria-hidden="true" tabindex="-1"></a>      | effect TYield, k -&gt;</span>
<span id="cb346-39"><a href="#cb346-39" aria-hidden="true" tabindex="-1"></a>          enqueue (<span class="kw">fun</span> () -&gt; <span class="dt">Effect</span>.Deep.continue k ());</span>
<span id="cb346-40"><a href="#cb346-40" aria-hidden="true" tabindex="-1"></a>          dequeue ()</span>
<span id="cb346-41"><a href="#cb346-41" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> p</span>
<span id="cb346-42"><a href="#cb346-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb346-43"><a href="#cb346-43" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> run f =</span>
<span id="cb346-44"><a href="#cb346-44" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Queue</span>.clear run_queue;</span>
<span id="cb346-45"><a href="#cb346-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> p = run_thread f <span class="kw">in</span></span>
<span id="cb346-46"><a href="#cb346-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">while</span> <span class="dt">not</span> (<span class="dt">Queue</span>.is_empty run_queue) <span class="kw">do</span> dequeue () <span class="kw">done</span>;</span>
<span id="cb346-47"><a href="#cb346-47" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> !p <span class="kw">with</span></span>
<span id="cb346-48"><a href="#cb346-48" aria-hidden="true" tabindex="-1"></a>    | Done v -&gt; v</span>
<span id="cb346-49"><a href="#cb346-49" aria-hidden="true" tabindex="-1"></a>    | Pending _ -&gt; <span class="dt">failwith</span> <span class="st">&quot;Main thread did not complete&quot;</span></span>
<span id="cb346-50"><a href="#cb346-50" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>Let us understand how each effect is handled:</p>
<p><strong>Async</strong>: When a thread calls <code>async g</code>, we
start a new thread running <code>g</code> by calling
<code>run_thread g</code>. This returns a promise immediately, which we
pass back to the parent thread by continuing its continuation.</p>
<p><strong>Await</strong>: When a thread calls <code>await p</code>, we
check the promise. If it is already <code>Done</code>, we continue
immediately with the value. If it is <code>Pending</code>, we add the
current continuation to the list of waiters and run another thread from
the queue.</p>
<p><strong>TYield</strong>: When a thread calls <code>yield ()</code>,
we add the current continuation to the back of the queue and run the
next thread. This implements round-robin scheduling.</p>
<h3 id="testing-the-implementation">Testing the Implementation</h3>
<p>Let us test with a simple example:</p>
<div class="sourceCode" id="cb347"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb347-1"><a href="#cb347-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> test_threads () =</span>
<span id="cb347-2"><a href="#cb347-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">open</span> Threads <span class="kw">in</span></span>
<span id="cb347-3"><a href="#cb347-3" aria-hidden="true" tabindex="-1"></a>  run (<span class="kw">fun</span> () -&gt;</span>
<span id="cb347-4"><a href="#cb347-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">rec</span> loop s n =</span>
<span id="cb347-5"><a href="#cb347-5" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Printf</span>.printf <span class="st">&quot;-- %s(%d)</span><span class="ch">\n</span><span class="st">%!&quot;</span> s n;</span>
<span id="cb347-6"><a href="#cb347-6" aria-hidden="true" tabindex="-1"></a>      yield ();</span>
<span id="cb347-7"><a href="#cb347-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> n &gt; <span class="dv">0</span> <span class="kw">then</span> loop s (n<span class="dv">-1</span>) <span class="kw">in</span></span>
<span id="cb347-8"><a href="#cb347-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> p1 = async (<span class="kw">fun</span> () -&gt; loop <span class="st">&quot;A&quot;</span> <span class="dv">3</span>) <span class="kw">in</span></span>
<span id="cb347-9"><a href="#cb347-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> p2 = async (<span class="kw">fun</span> () -&gt; loop <span class="st">&quot;B&quot;</span> <span class="dv">2</span>) <span class="kw">in</span></span>
<span id="cb347-10"><a href="#cb347-10" aria-hidden="true" tabindex="-1"></a>    await p1;</span>
<span id="cb347-11"><a href="#cb347-11" aria-hidden="true" tabindex="-1"></a>    await p2;</span>
<span id="cb347-12"><a href="#cb347-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Printf</span>.printf <span class="st">&quot;Done!</span><span class="ch">\n</span><span class="st">%!&quot;</span>)</span>
<span id="cb347-13"><a href="#cb347-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb347-14"><a href="#cb347-14" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () = test_threads ()</span></code></pre></div>
<p>This creates two threads that print messages and yield control. The
output shows interleaving:</p>
<pre><code>-- A(3)
-- B(2)
-- A(2)
-- B(1)
-- A(1)
-- B(0)
-- A(0)
Done!</code></pre>
<p>Compare this to the monadic version from the previous chapter. The
code is more direct: we write <code>yield ()</code> instead of
<code>let* () = suspend in</code>, and <code>Printf.printf</code> is
just a regular function call. The complexity of managing thread state
has moved from the user code into the handler.</p>
<h2 id="state-with-effects">9.4 State with Effects</h2>
<p>Before diving into probabilistic programming, let us see how to
implement mutable state using effects. This demonstrates another common
pattern.</p>
<div class="sourceCode" id="cb349"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb349-1"><a href="#cb349-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> State = <span class="kw">struct</span></span>
<span id="cb349-2"><a href="#cb349-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> _ <span class="dt">Effect</span>.t +=</span>
<span id="cb349-3"><a href="#cb349-3" aria-hidden="true" tabindex="-1"></a>    | SGet : <span class="dt">int</span> <span class="dt">Effect</span>.t</span>
<span id="cb349-4"><a href="#cb349-4" aria-hidden="true" tabindex="-1"></a>    | SPut : <span class="dt">int</span> -&gt; <span class="dt">unit</span> <span class="dt">Effect</span>.t</span>
<span id="cb349-5"><a href="#cb349-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb349-6"><a href="#cb349-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> get () = <span class="dt">Effect</span>.perform SGet</span>
<span id="cb349-7"><a href="#cb349-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> put n = <span class="dt">Effect</span>.perform (SPut n)</span>
<span id="cb349-8"><a href="#cb349-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb349-9"><a href="#cb349-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> run : <span class="kw">type</span> a. <span class="dt">int</span> -&gt; (<span class="dt">unit</span> -&gt; a) -&gt; a = <span class="kw">fun</span> init f -&gt;</span>
<span id="cb349-10"><a href="#cb349-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> state = <span class="dt">ref</span> init <span class="kw">in</span></span>
<span id="cb349-11"><a href="#cb349-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> f () <span class="kw">with</span></span>
<span id="cb349-12"><a href="#cb349-12" aria-hidden="true" tabindex="-1"></a>    | effect SGet, k -&gt; <span class="dt">Effect</span>.Deep.continue k !state</span>
<span id="cb349-13"><a href="#cb349-13" aria-hidden="true" tabindex="-1"></a>    | effect (SPut n), k -&gt; state := n; <span class="dt">Effect</span>.Deep.continue k ()</span>
<span id="cb349-14"><a href="#cb349-14" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>Now we can write stateful computations:</p>
<div class="sourceCode" id="cb350"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb350-1"><a href="#cb350-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> counter () =</span>
<span id="cb350-2"><a href="#cb350-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">open</span> State <span class="kw">in</span></span>
<span id="cb350-3"><a href="#cb350-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">for</span> _ = <span class="dv">1</span> <span class="kw">to</span> <span class="dv">5</span> <span class="kw">do</span></span>
<span id="cb350-4"><a href="#cb350-4" aria-hidden="true" tabindex="-1"></a>    put (get () + <span class="dv">1</span>)</span>
<span id="cb350-5"><a href="#cb350-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span>;</span>
<span id="cb350-6"><a href="#cb350-6" aria-hidden="true" tabindex="-1"></a>  get ()</span>
<span id="cb350-7"><a href="#cb350-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb350-8"><a href="#cb350-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">result</span> = State.run <span class="dv">0</span> counter  <span class="co">(* result = 5 *)</span></span>
<span id="cb350-9"><a href="#cb350-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () = <span class="dt">Printf</span>.printf <span class="st">&quot;Counter result: %d</span><span class="ch">\n</span><span class="st">&quot;</span> <span class="dt">result</span></span></code></pre></div>
<p>The key insight is that effects let us <em>separate the description
of what effects occur</em> from <em>how those effects are
implemented</em>. The <code>counter</code> function describes a
computation that gets and puts state. The <code>State.run</code> handler
interprets those effects using a mutable reference.</p>
<h2 id="probabilistic-programming-with-effects">9.5 Probabilistic
Programming with Effects</h2>
<p>Now we are ready to tackle something more ambitious: probabilistic
programming. In the previous chapter, we implemented probability monads
that could compute exact distributions or approximate them via sampling.
Effect handlers give us a different, more flexible approach.</p>
<h3 id="the-key-idea">The Key Idea</h3>
<p>A probabilistic program is a program with random choices. Instead of
thinking about distributions as data, we think about <em>sampling</em>
and <em>conditioning</em>:</p>
<ul>
<li><strong>Sample</strong>: Draw a value from a probability
distribution</li>
<li><strong>Observe/Condition</strong>: Assert that a certain event
occurred, affecting the posterior probability</li>
</ul>
<p>Effect handlers let us <em>reify</em> these operations. When a
program performs a <code>Sample</code> effect, the handler can decide:
“run this with value X and probability P”. When a program performs an
<code>Observe</code> effect, the handler can adjust weights or reject
samples that do not match the observation.</p>
<h3 id="declaring-probability-effects">Declaring Probability
Effects</h3>
<div class="sourceCode" id="cb351"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb351-1"><a href="#cb351-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> _ <span class="dt">Effect</span>.t +=</span>
<span id="cb351-2"><a href="#cb351-2" aria-hidden="true" tabindex="-1"></a>  | Sample : (<span class="dt">string</span> * <span class="dt">float</span> <span class="dt">array</span>) -&gt; <span class="dt">int</span> <span class="dt">Effect</span>.t  <span class="co">(* name, weights -&gt; index *)</span></span>
<span id="cb351-3"><a href="#cb351-3" aria-hidden="true" tabindex="-1"></a>  | Observe : <span class="dt">float</span> -&gt; <span class="dt">unit</span> <span class="dt">Effect</span>.t                 <span class="co">(* observe with likelihood *)</span></span>
<span id="cb351-4"><a href="#cb351-4" aria-hidden="true" tabindex="-1"></a>  | Fail : &#39;a <span class="dt">Effect</span>.t                               <span class="co">(* reject this execution *)</span></span></code></pre></div>
<p><code>Sample</code> takes a name (for debugging) and an array of
weights, returning the index of the chosen alternative.
<code>Observe</code> records a likelihood weight. <code>Fail</code>
indicates this execution path should be abandoned.</p>
<div class="sourceCode" id="cb352"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb352-1"><a href="#cb352-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> sample name weights = <span class="dt">Effect</span>.perform (Sample (name, weights))</span>
<span id="cb352-2"><a href="#cb352-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> observe likelihood = <span class="dt">Effect</span>.perform (Observe likelihood)</span>
<span id="cb352-3"><a href="#cb352-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fail () = <span class="dt">Effect</span>.perform Fail</span></code></pre></div>
<p>We can build familiar probabilistic primitives:</p>
<div class="sourceCode" id="cb353"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb353-1"><a href="#cb353-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> flip p =</span>
<span id="cb353-2"><a href="#cb353-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> i = sample <span class="st">&quot;flip&quot;</span> [| p; <span class="fl">1.0</span> -. p |] <span class="kw">in</span></span>
<span id="cb353-3"><a href="#cb353-3" aria-hidden="true" tabindex="-1"></a>  i = <span class="dv">0</span></span>
<span id="cb353-4"><a href="#cb353-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb353-5"><a href="#cb353-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> uniform choices =</span>
<span id="cb353-6"><a href="#cb353-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> n = <span class="dt">Array</span>.length choices <span class="kw">in</span></span>
<span id="cb353-7"><a href="#cb353-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> weights = <span class="dt">Array</span>.make n (<span class="fl">1.0</span> /. <span class="dt">float_of_int</span> n) <span class="kw">in</span></span>
<span id="cb353-8"><a href="#cb353-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> i = sample <span class="st">&quot;uniform&quot;</span> weights <span class="kw">in</span></span>
<span id="cb353-9"><a href="#cb353-9" aria-hidden="true" tabindex="-1"></a>  choices.(i)</span>
<span id="cb353-10"><a href="#cb353-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb353-11"><a href="#cb353-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> bernoulli p = flip p</span>
<span id="cb353-12"><a href="#cb353-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb353-13"><a href="#cb353-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> categorical weights =</span>
<span id="cb353-14"><a href="#cb353-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> total = <span class="dt">Array</span>.fold_left (+.) <span class="fl">0.0</span> weights <span class="kw">in</span></span>
<span id="cb353-15"><a href="#cb353-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> normalized = <span class="dt">Array</span>.map (<span class="kw">fun</span> w -&gt; w /. total) weights <span class="kw">in</span></span>
<span id="cb353-16"><a href="#cb353-16" aria-hidden="true" tabindex="-1"></a>  sample <span class="st">&quot;categorical&quot;</span> normalized</span></code></pre></div>
<h3 id="example-monty-hall">Example: Monty Hall</h3>
<p>Let us encode the Monty Hall problem:</p>
<div class="sourceCode" id="cb354"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb354-1"><a href="#cb354-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> door = A | B | C</span>
<span id="cb354-2"><a href="#cb354-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb354-3"><a href="#cb354-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> monty_hall ~switch =</span>
<span id="cb354-4"><a href="#cb354-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> doors = [| A; B; C |] <span class="kw">in</span></span>
<span id="cb354-5"><a href="#cb354-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> prize = uniform doors <span class="kw">in</span></span>
<span id="cb354-6"><a href="#cb354-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> chosen = uniform doors <span class="kw">in</span></span>
<span id="cb354-7"><a href="#cb354-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* Host opens a door that is neither prize nor chosen *)</span></span>
<span id="cb354-8"><a href="#cb354-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> can_open =</span>
<span id="cb354-9"><a href="#cb354-9" aria-hidden="true" tabindex="-1"></a>    doors</span>
<span id="cb354-10"><a href="#cb354-10" aria-hidden="true" tabindex="-1"></a>    |&gt; <span class="dt">Array</span>.to_list</span>
<span id="cb354-11"><a href="#cb354-11" aria-hidden="true" tabindex="-1"></a>    |&gt; <span class="dt">List</span>.filter (<span class="kw">fun</span> d -&gt; d &lt;&gt; prize &amp;&amp; d &lt;&gt; chosen)</span>
<span id="cb354-12"><a href="#cb354-12" aria-hidden="true" tabindex="-1"></a>    |&gt; <span class="dt">Array</span>.of_list</span>
<span id="cb354-13"><a href="#cb354-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb354-14"><a href="#cb354-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> opened = uniform can_open <span class="kw">in</span></span>
<span id="cb354-15"><a href="#cb354-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* Player&#39;s final choice *)</span></span>
<span id="cb354-16"><a href="#cb354-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> final =</span>
<span id="cb354-17"><a href="#cb354-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> switch <span class="kw">then</span></span>
<span id="cb354-18"><a href="#cb354-18" aria-hidden="true" tabindex="-1"></a>      <span class="co">(* Switch to the remaining door *)</span></span>
<span id="cb354-19"><a href="#cb354-19" aria-hidden="true" tabindex="-1"></a>      <span class="dt">List</span>.hd (<span class="dt">List</span>.filter (<span class="kw">fun</span> d -&gt; d &lt;&gt; opened &amp;&amp; d &lt;&gt; chosen) [A; B; C])</span>
<span id="cb354-20"><a href="#cb354-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> chosen <span class="kw">in</span></span>
<span id="cb354-21"><a href="#cb354-21" aria-hidden="true" tabindex="-1"></a>  final = prize</span></code></pre></div>
<p>This is cleaner than the monadic version: we just write the
generative model directly. The <code>uniform</code> calls represent
random choices, and we return whether the player wins.</p>
<h3 id="example-burglary-network">Example: Burglary Network</h3>
<p>Here is the Bayesian network example from the previous chapter:</p>
<div class="sourceCode" id="cb355"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb355-1"><a href="#cb355-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> outcome = Safe | Burglary | Earthquake | Both</span>
<span id="cb355-2"><a href="#cb355-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb355-3"><a href="#cb355-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> burglary ~john_called ~mary_called =</span>
<span id="cb355-4"><a href="#cb355-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> earthquake = flip <span class="fl">0.002</span> <span class="kw">in</span></span>
<span id="cb355-5"><a href="#cb355-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> burglary = flip <span class="fl">0.001</span> <span class="kw">in</span></span>
<span id="cb355-6"><a href="#cb355-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> alarm_prob = <span class="kw">match</span> burglary, earthquake <span class="kw">with</span></span>
<span id="cb355-7"><a href="#cb355-7" aria-hidden="true" tabindex="-1"></a>    | <span class="kw">false</span>, <span class="kw">false</span> -&gt; <span class="fl">0.001</span></span>
<span id="cb355-8"><a href="#cb355-8" aria-hidden="true" tabindex="-1"></a>    | <span class="kw">false</span>, <span class="kw">true</span> -&gt; <span class="fl">0.29</span></span>
<span id="cb355-9"><a href="#cb355-9" aria-hidden="true" tabindex="-1"></a>    | <span class="kw">true</span>, <span class="kw">false</span> -&gt; <span class="fl">0.94</span></span>
<span id="cb355-10"><a href="#cb355-10" aria-hidden="true" tabindex="-1"></a>    | <span class="kw">true</span>, <span class="kw">true</span> -&gt; <span class="fl">0.95</span> <span class="kw">in</span></span>
<span id="cb355-11"><a href="#cb355-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> alarm = flip alarm_prob <span class="kw">in</span></span>
<span id="cb355-12"><a href="#cb355-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> john_prob = <span class="kw">if</span> alarm <span class="kw">then</span> <span class="fl">0.9</span> <span class="kw">else</span> <span class="fl">0.05</span> <span class="kw">in</span></span>
<span id="cb355-13"><a href="#cb355-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> mary_prob = <span class="kw">if</span> alarm <span class="kw">then</span> <span class="fl">0.7</span> <span class="kw">else</span> <span class="fl">0.01</span> <span class="kw">in</span></span>
<span id="cb355-14"><a href="#cb355-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* Condition on observations *)</span></span>
<span id="cb355-15"><a href="#cb355-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> flip john_prob &lt;&gt; john_called <span class="kw">then</span> fail ();</span>
<span id="cb355-16"><a href="#cb355-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> flip mary_prob &lt;&gt; mary_called <span class="kw">then</span> fail ();</span>
<span id="cb355-17"><a href="#cb355-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* Return the outcome *)</span></span>
<span id="cb355-18"><a href="#cb355-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> burglary, earthquake <span class="kw">with</span></span>
<span id="cb355-19"><a href="#cb355-19" aria-hidden="true" tabindex="-1"></a>  | <span class="kw">false</span>, <span class="kw">false</span> -&gt; Safe</span>
<span id="cb355-20"><a href="#cb355-20" aria-hidden="true" tabindex="-1"></a>  | <span class="kw">true</span>, <span class="kw">false</span> -&gt; Burglary</span>
<span id="cb355-21"><a href="#cb355-21" aria-hidden="true" tabindex="-1"></a>  | <span class="kw">false</span>, <span class="kw">true</span> -&gt; Earthquake</span>
<span id="cb355-22"><a href="#cb355-22" aria-hidden="true" tabindex="-1"></a>  | <span class="kw">true</span>, <span class="kw">true</span> -&gt; Both</span></code></pre></div>
<p>The key difference from the monad version: we use
<code>fail ()</code> to reject executions that do not match our
observations. This is <em>rejection sampling</em>: we run the program
many times and keep only the runs where the observations match.</p>
<h2 id="rejection-sampling-interpreter">9.6 Rejection Sampling
Interpreter</h2>
<p>Our first interpreter uses rejection sampling: run the probabilistic
program many times, rejecting executions that fail, and collect
statistics on the successful runs.</p>
<div class="sourceCode" id="cb356"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb356-1"><a href="#cb356-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Rejection = <span class="kw">struct</span></span>
<span id="cb356-2"><a href="#cb356-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">exception</span> Rejected</span>
<span id="cb356-3"><a href="#cb356-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb356-4"><a href="#cb356-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> sample_index weights =</span>
<span id="cb356-5"><a href="#cb356-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> total = <span class="dt">Array</span>.fold_left (+.) <span class="fl">0.0</span> weights <span class="kw">in</span></span>
<span id="cb356-6"><a href="#cb356-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r = <span class="dt">Random</span>.<span class="dt">float</span> total <span class="kw">in</span></span>
<span id="cb356-7"><a href="#cb356-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">rec</span> find i acc =</span>
<span id="cb356-8"><a href="#cb356-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> i &gt;= <span class="dt">Array</span>.length weights <span class="kw">then</span> <span class="dt">Array</span>.length weights - <span class="dv">1</span></span>
<span id="cb356-9"><a href="#cb356-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span></span>
<span id="cb356-10"><a href="#cb356-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> acc&#39; = acc +. weights.(i) <span class="kw">in</span></span>
<span id="cb356-11"><a href="#cb356-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> r &lt; acc&#39; <span class="kw">then</span> i <span class="kw">else</span> find (i + <span class="dv">1</span>) acc&#39;</span>
<span id="cb356-12"><a href="#cb356-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span></span>
<span id="cb356-13"><a href="#cb356-13" aria-hidden="true" tabindex="-1"></a>    find <span class="dv">0</span> <span class="fl">0.0</span></span>
<span id="cb356-14"><a href="#cb356-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb356-15"><a href="#cb356-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> run_once : <span class="kw">type</span> a. (<span class="dt">unit</span> -&gt; a) -&gt; a <span class="dt">option</span> = <span class="kw">fun</span> f -&gt;</span>
<span id="cb356-16"><a href="#cb356-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> f () <span class="kw">with</span></span>
<span id="cb356-17"><a href="#cb356-17" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">result</span> -&gt; <span class="dt">Some</span> <span class="dt">result</span></span>
<span id="cb356-18"><a href="#cb356-18" aria-hidden="true" tabindex="-1"></a>    | effect (Sample (_, weights)), k -&gt;</span>
<span id="cb356-19"><a href="#cb356-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Effect</span>.Deep.continue k (sample_index weights)</span>
<span id="cb356-20"><a href="#cb356-20" aria-hidden="true" tabindex="-1"></a>    | effect (Observe w), k -&gt;</span>
<span id="cb356-21"><a href="#cb356-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> <span class="dt">Random</span>.<span class="dt">float</span> <span class="fl">1.0</span> &lt; w</span>
<span id="cb356-22"><a href="#cb356-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> <span class="dt">Effect</span>.Deep.continue k ()</span>
<span id="cb356-23"><a href="#cb356-23" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="dt">Effect</span>.Deep.discontinue k Rejected</span>
<span id="cb356-24"><a href="#cb356-24" aria-hidden="true" tabindex="-1"></a>    | effect Fail, k -&gt; <span class="dt">Effect</span>.Deep.discontinue k Rejected</span>
<span id="cb356-25"><a href="#cb356-25" aria-hidden="true" tabindex="-1"></a>    | <span class="kw">exception</span> Rejected -&gt; <span class="dt">None</span></span>
<span id="cb356-26"><a href="#cb356-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb356-27"><a href="#cb356-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> infer ?(samples=<span class="dv">10000</span>) f =</span>
<span id="cb356-28"><a href="#cb356-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> results = <span class="dt">Hashtbl</span>.create <span class="dv">16</span> <span class="kw">in</span></span>
<span id="cb356-29"><a href="#cb356-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> successes = <span class="dt">ref</span> <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb356-30"><a href="#cb356-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> _ = <span class="dv">1</span> <span class="kw">to</span> samples <span class="kw">do</span></span>
<span id="cb356-31"><a href="#cb356-31" aria-hidden="true" tabindex="-1"></a>      <span class="kw">match</span> run_once f <span class="kw">with</span></span>
<span id="cb356-32"><a href="#cb356-32" aria-hidden="true" tabindex="-1"></a>      | <span class="dt">None</span> -&gt; ()</span>
<span id="cb356-33"><a href="#cb356-33" aria-hidden="true" tabindex="-1"></a>      | <span class="dt">Some</span> v -&gt;</span>
<span id="cb356-34"><a href="#cb356-34" aria-hidden="true" tabindex="-1"></a>          <span class="dt">incr</span> successes;</span>
<span id="cb356-35"><a href="#cb356-35" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> count = <span class="kw">try</span> <span class="dt">Hashtbl</span>.find results v <span class="kw">with</span> <span class="dt">Not_found</span> -&gt; <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb356-36"><a href="#cb356-36" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Hashtbl</span>.replace results v (count + <span class="dv">1</span>)</span>
<span id="cb356-37"><a href="#cb356-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span>;</span>
<span id="cb356-38"><a href="#cb356-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> n = <span class="dt">float_of_int</span> !successes <span class="kw">in</span></span>
<span id="cb356-39"><a href="#cb356-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n &gt; <span class="fl">0.0</span> <span class="kw">then</span></span>
<span id="cb356-40"><a href="#cb356-40" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Hashtbl</span>.fold (<span class="kw">fun</span> v c acc -&gt;</span>
<span id="cb356-41"><a href="#cb356-41" aria-hidden="true" tabindex="-1"></a>        (v, <span class="dt">float_of_int</span> c /. n) :: acc) results []</span>
<span id="cb356-42"><a href="#cb356-42" aria-hidden="true" tabindex="-1"></a>      |&gt; <span class="dt">List</span>.sort (<span class="kw">fun</span> (_, p1) (_, p2) -&gt; <span class="dt">compare</span> p2 p1)</span>
<span id="cb356-43"><a href="#cb356-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> []</span>
<span id="cb356-44"><a href="#cb356-44" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>Let us test it:</p>
<div class="sourceCode" id="cb357"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb357-1"><a href="#cb357-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () =</span>
<span id="cb357-2"><a href="#cb357-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Printf</span>.printf <span class="st">&quot;</span><span class="ch">\n</span><span class="st">=== Rejection Sampling Tests ===</span><span class="ch">\n</span><span class="st">&quot;</span>;</span>
<span id="cb357-3"><a href="#cb357-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Printf</span>.printf <span class="st">&quot;Monty Hall (no switch): &quot;</span>;</span>
<span id="cb357-4"><a href="#cb357-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> dist = Rejection.infer (<span class="kw">fun</span> () -&gt; monty_hall ~switch:<span class="kw">false</span>) <span class="kw">in</span></span>
<span id="cb357-5"><a href="#cb357-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.iter (<span class="kw">fun</span> (win, p) -&gt;</span>
<span id="cb357-6"><a href="#cb357-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Printf</span>.printf <span class="st">&quot;%s: %.3f  &quot;</span> (<span class="kw">if</span> win <span class="kw">then</span> <span class="st">&quot;win&quot;</span> <span class="kw">else</span> <span class="st">&quot;lose&quot;</span>) p) dist;</span>
<span id="cb357-7"><a href="#cb357-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">print_newline</span> ()</span>
<span id="cb357-8"><a href="#cb357-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb357-9"><a href="#cb357-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () =</span>
<span id="cb357-10"><a href="#cb357-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Printf</span>.printf <span class="st">&quot;Monty Hall (switch): &quot;</span>;</span>
<span id="cb357-11"><a href="#cb357-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> dist = Rejection.infer (<span class="kw">fun</span> () -&gt; monty_hall ~switch:<span class="kw">true</span>) <span class="kw">in</span></span>
<span id="cb357-12"><a href="#cb357-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.iter (<span class="kw">fun</span> (win, p) -&gt;</span>
<span id="cb357-13"><a href="#cb357-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Printf</span>.printf <span class="st">&quot;%s: %.3f  &quot;</span> (<span class="kw">if</span> win <span class="kw">then</span> <span class="st">&quot;win&quot;</span> <span class="kw">else</span> <span class="st">&quot;lose&quot;</span>) p) dist;</span>
<span id="cb357-14"><a href="#cb357-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">print_newline</span> ()</span></code></pre></div>
<p>The famous result: switching doubles your chances of winning!</p>
<h3 id="limitations-of-rejection-sampling">Limitations of Rejection
Sampling</h3>
<p>Rejection sampling is simple but has a major limitation: if the
observations are unlikely, most samples are rejected, making inference
very slow. For example, if we observe both John and Mary called (a rare
event), rejection sampling needs many attempts to find a valid
sample:</p>
<div class="sourceCode" id="cb358"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb358-1"><a href="#cb358-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () =</span>
<span id="cb358-2"><a href="#cb358-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Printf</span>.printf <span class="st">&quot;Burglary (john=true, mary=true):</span><span class="ch">\n</span><span class="st">&quot;</span>;</span>
<span id="cb358-3"><a href="#cb358-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> dist = Rejection.infer ~samples:<span class="dv">100000</span> (<span class="kw">fun</span> () -&gt;</span>
<span id="cb358-4"><a href="#cb358-4" aria-hidden="true" tabindex="-1"></a>    burglary ~john_called:<span class="kw">true</span> ~mary_called:<span class="kw">true</span>) <span class="kw">in</span></span>
<span id="cb358-5"><a href="#cb358-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.iter (<span class="kw">fun</span> (outcome, p) -&gt;</span>
<span id="cb358-6"><a href="#cb358-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s = <span class="kw">match</span> outcome <span class="kw">with</span></span>
<span id="cb358-7"><a href="#cb358-7" aria-hidden="true" tabindex="-1"></a>      | Safe -&gt; <span class="st">&quot;Safe&quot;</span> | Burglary -&gt; <span class="st">&quot;Burglary&quot;</span></span>
<span id="cb358-8"><a href="#cb358-8" aria-hidden="true" tabindex="-1"></a>      | Earthquake -&gt; <span class="st">&quot;Earthquake&quot;</span> | Both -&gt; <span class="st">&quot;Both&quot;</span> <span class="kw">in</span></span>
<span id="cb358-9"><a href="#cb358-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Printf</span>.printf <span class="st">&quot;  %s: %.4f</span><span class="ch">\n</span><span class="st">&quot;</span> s p) dist</span></code></pre></div>
<p>With rare observations, we need many more samples to get accurate
estimates. This is where more sophisticated inference methods help.</p>
<h2 id="importance-sampling">9.7 Importance Sampling</h2>
<p>Rejection sampling throws away information: every rejected sample is
wasted computation. <em>Importance sampling</em> does better by keeping
track of weights. Instead of rejecting unlikely executions, we weight
them by their likelihood.</p>
<p>The idea is simple: run particles and track a weight for each. When
an observation occurs, multiply the particle’s weight by the likelihood
instead of rejecting.</p>
<div class="sourceCode" id="cb359"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb359-1"><a href="#cb359-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Importance = <span class="kw">struct</span></span>
<span id="cb359-2"><a href="#cb359-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">exception</span> HardFail</span>
<span id="cb359-3"><a href="#cb359-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb359-4"><a href="#cb359-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> sample_index weights =</span>
<span id="cb359-5"><a href="#cb359-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> total = <span class="dt">Array</span>.fold_left (+.) <span class="fl">0.0</span> weights <span class="kw">in</span></span>
<span id="cb359-6"><a href="#cb359-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r = <span class="dt">Random</span>.<span class="dt">float</span> total <span class="kw">in</span></span>
<span id="cb359-7"><a href="#cb359-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">rec</span> find i acc =</span>
<span id="cb359-8"><a href="#cb359-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> i &gt;= <span class="dt">Array</span>.length weights <span class="kw">then</span> <span class="dt">Array</span>.length weights - <span class="dv">1</span></span>
<span id="cb359-9"><a href="#cb359-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> <span class="kw">if</span> r &lt; acc +. weights.(i) <span class="kw">then</span> i</span>
<span id="cb359-10"><a href="#cb359-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> find (i + <span class="dv">1</span>) (acc +. weights.(i)) <span class="kw">in</span></span>
<span id="cb359-11"><a href="#cb359-11" aria-hidden="true" tabindex="-1"></a>    find <span class="dv">0</span> <span class="fl">0.0</span></span>
<span id="cb359-12"><a href="#cb359-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb359-13"><a href="#cb359-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> run_once : <span class="kw">type</span> a. (<span class="dt">unit</span> -&gt; a) -&gt; (a * <span class="dt">float</span>) <span class="dt">option</span> = <span class="kw">fun</span> f -&gt;</span>
<span id="cb359-14"><a href="#cb359-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> weight = <span class="dt">ref</span> <span class="fl">1.0</span> <span class="kw">in</span></span>
<span id="cb359-15"><a href="#cb359-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> f () <span class="kw">with</span></span>
<span id="cb359-16"><a href="#cb359-16" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">result</span> -&gt; <span class="dt">Some</span> (<span class="dt">result</span>, !weight)</span>
<span id="cb359-17"><a href="#cb359-17" aria-hidden="true" tabindex="-1"></a>    | effect (Sample (_, weights)), k -&gt;</span>
<span id="cb359-18"><a href="#cb359-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Effect</span>.Deep.continue k (sample_index weights)</span>
<span id="cb359-19"><a href="#cb359-19" aria-hidden="true" tabindex="-1"></a>    | effect (Observe likelihood), k -&gt;</span>
<span id="cb359-20"><a href="#cb359-20" aria-hidden="true" tabindex="-1"></a>        weight := !weight *. likelihood;</span>
<span id="cb359-21"><a href="#cb359-21" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Effect</span>.Deep.continue k ()</span>
<span id="cb359-22"><a href="#cb359-22" aria-hidden="true" tabindex="-1"></a>    | effect Fail, k -&gt; <span class="dt">Effect</span>.Deep.discontinue k HardFail</span>
<span id="cb359-23"><a href="#cb359-23" aria-hidden="true" tabindex="-1"></a>    | <span class="kw">exception</span> HardFail -&gt; <span class="dt">None</span></span>
<span id="cb359-24"><a href="#cb359-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb359-25"><a href="#cb359-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> infer ?(samples=<span class="dv">10000</span>) f =</span>
<span id="cb359-26"><a href="#cb359-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> results = <span class="dt">Hashtbl</span>.create <span class="dv">16</span> <span class="kw">in</span></span>
<span id="cb359-27"><a href="#cb359-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> total_weight = <span class="dt">ref</span> <span class="fl">0.0</span> <span class="kw">in</span></span>
<span id="cb359-28"><a href="#cb359-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> _ = <span class="dv">1</span> <span class="kw">to</span> samples <span class="kw">do</span></span>
<span id="cb359-29"><a href="#cb359-29" aria-hidden="true" tabindex="-1"></a>      <span class="kw">match</span> run_once f <span class="kw">with</span></span>
<span id="cb359-30"><a href="#cb359-30" aria-hidden="true" tabindex="-1"></a>      | <span class="dt">None</span> -&gt; ()</span>
<span id="cb359-31"><a href="#cb359-31" aria-hidden="true" tabindex="-1"></a>      | <span class="dt">Some</span> (v, w) -&gt;</span>
<span id="cb359-32"><a href="#cb359-32" aria-hidden="true" tabindex="-1"></a>          total_weight := !total_weight +. w;</span>
<span id="cb359-33"><a href="#cb359-33" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> prev = <span class="kw">try</span> <span class="dt">Hashtbl</span>.find results v <span class="kw">with</span> <span class="dt">Not_found</span> -&gt; <span class="fl">0.0</span> <span class="kw">in</span></span>
<span id="cb359-34"><a href="#cb359-34" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Hashtbl</span>.replace results v (prev +. w)</span>
<span id="cb359-35"><a href="#cb359-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span>;</span>
<span id="cb359-36"><a href="#cb359-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> !total_weight &gt; <span class="fl">0.0</span> <span class="kw">then</span></span>
<span id="cb359-37"><a href="#cb359-37" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Hashtbl</span>.fold (<span class="kw">fun</span> v w acc -&gt; (v, w /. !total_weight) :: acc) results []</span>
<span id="cb359-38"><a href="#cb359-38" aria-hidden="true" tabindex="-1"></a>      |&gt; <span class="dt">List</span>.sort (<span class="kw">fun</span> (_, p1) (_, p2) -&gt; <span class="dt">compare</span> p2 p1)</span>
<span id="cb359-39"><a href="#cb359-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> []</span>
<span id="cb359-40"><a href="#cb359-40" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="soft-conditioning-with-observe">9.8 Soft Conditioning with
Observe</h2>
<p>So far our burglary example uses hard conditioning with
<code>fail ()</code>. Let us rewrite it to use soft conditioning with
<code>observe</code>:</p>
<div class="sourceCode" id="cb360"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb360-1"><a href="#cb360-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> burglary_soft ~john_called ~mary_called =</span>
<span id="cb360-2"><a href="#cb360-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> earthquake = flip <span class="fl">0.002</span> <span class="kw">in</span></span>
<span id="cb360-3"><a href="#cb360-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> burglary = flip <span class="fl">0.001</span> <span class="kw">in</span></span>
<span id="cb360-4"><a href="#cb360-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> alarm_prob = <span class="kw">match</span> burglary, earthquake <span class="kw">with</span></span>
<span id="cb360-5"><a href="#cb360-5" aria-hidden="true" tabindex="-1"></a>    | <span class="kw">false</span>, <span class="kw">false</span> -&gt; <span class="fl">0.001</span></span>
<span id="cb360-6"><a href="#cb360-6" aria-hidden="true" tabindex="-1"></a>    | <span class="kw">false</span>, <span class="kw">true</span> -&gt; <span class="fl">0.29</span></span>
<span id="cb360-7"><a href="#cb360-7" aria-hidden="true" tabindex="-1"></a>    | <span class="kw">true</span>, <span class="kw">false</span> -&gt; <span class="fl">0.94</span></span>
<span id="cb360-8"><a href="#cb360-8" aria-hidden="true" tabindex="-1"></a>    | <span class="kw">true</span>, <span class="kw">true</span> -&gt; <span class="fl">0.95</span> <span class="kw">in</span></span>
<span id="cb360-9"><a href="#cb360-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> alarm = flip alarm_prob <span class="kw">in</span></span>
<span id="cb360-10"><a href="#cb360-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* Soft conditioning: observe the likelihood of the evidence *)</span></span>
<span id="cb360-11"><a href="#cb360-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> john_prob = <span class="kw">if</span> alarm <span class="kw">then</span> <span class="fl">0.9</span> <span class="kw">else</span> <span class="fl">0.05</span> <span class="kw">in</span></span>
<span id="cb360-12"><a href="#cb360-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> mary_prob = <span class="kw">if</span> alarm <span class="kw">then</span> <span class="fl">0.7</span> <span class="kw">else</span> <span class="fl">0.01</span> <span class="kw">in</span></span>
<span id="cb360-13"><a href="#cb360-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> john_like = <span class="kw">if</span> john_called <span class="kw">then</span> john_prob <span class="kw">else</span> <span class="fl">1.0</span> -. john_prob <span class="kw">in</span></span>
<span id="cb360-14"><a href="#cb360-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> mary_like = <span class="kw">if</span> mary_called <span class="kw">then</span> mary_prob <span class="kw">else</span> <span class="fl">1.0</span> -. mary_prob <span class="kw">in</span></span>
<span id="cb360-15"><a href="#cb360-15" aria-hidden="true" tabindex="-1"></a>  observe john_like;</span>
<span id="cb360-16"><a href="#cb360-16" aria-hidden="true" tabindex="-1"></a>  observe mary_like;</span>
<span id="cb360-17"><a href="#cb360-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* Return the outcome *)</span></span>
<span id="cb360-18"><a href="#cb360-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> burglary, earthquake <span class="kw">with</span></span>
<span id="cb360-19"><a href="#cb360-19" aria-hidden="true" tabindex="-1"></a>  | <span class="kw">false</span>, <span class="kw">false</span> -&gt; Safe</span>
<span id="cb360-20"><a href="#cb360-20" aria-hidden="true" tabindex="-1"></a>  | <span class="kw">true</span>, <span class="kw">false</span> -&gt; Burglary</span>
<span id="cb360-21"><a href="#cb360-21" aria-hidden="true" tabindex="-1"></a>  | <span class="kw">false</span>, <span class="kw">true</span> -&gt; Earthquake</span>
<span id="cb360-22"><a href="#cb360-22" aria-hidden="true" tabindex="-1"></a>  | <span class="kw">true</span>, <span class="kw">true</span> -&gt; Both</span>
<span id="cb360-23"><a href="#cb360-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb360-24"><a href="#cb360-24" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () =</span>
<span id="cb360-25"><a href="#cb360-25" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Printf</span>.printf <span class="st">&quot;</span><span class="ch">\n</span><span class="st">=== Importance Sampling Tests ===</span><span class="ch">\n</span><span class="st">&quot;</span>;</span>
<span id="cb360-26"><a href="#cb360-26" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Printf</span>.printf <span class="st">&quot;Burglary soft (john=true, mary=true):</span><span class="ch">\n</span><span class="st">&quot;</span>;</span>
<span id="cb360-27"><a href="#cb360-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> dist = Importance.infer ~samples:<span class="dv">50000</span> (<span class="kw">fun</span> () -&gt;</span>
<span id="cb360-28"><a href="#cb360-28" aria-hidden="true" tabindex="-1"></a>    burglary_soft ~john_called:<span class="kw">true</span> ~mary_called:<span class="kw">true</span>) <span class="kw">in</span></span>
<span id="cb360-29"><a href="#cb360-29" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.iter (<span class="kw">fun</span> (outcome, p) -&gt;</span>
<span id="cb360-30"><a href="#cb360-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s = <span class="kw">match</span> outcome <span class="kw">with</span></span>
<span id="cb360-31"><a href="#cb360-31" aria-hidden="true" tabindex="-1"></a>      | Safe -&gt; <span class="st">&quot;Safe&quot;</span> | Burglary -&gt; <span class="st">&quot;Burglary&quot;</span></span>
<span id="cb360-32"><a href="#cb360-32" aria-hidden="true" tabindex="-1"></a>      | Earthquake -&gt; <span class="st">&quot;Earthquake&quot;</span> | Both -&gt; <span class="st">&quot;Both&quot;</span> <span class="kw">in</span></span>
<span id="cb360-33"><a href="#cb360-33" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Printf</span>.printf <span class="st">&quot;  %s: %.4f</span><span class="ch">\n</span><span class="st">&quot;</span> s p) dist</span></code></pre></div>
<p>The soft conditioning version is more efficient because every
particle contributes to the estimate, weighted by how well it matches
the observations.</p>
<h2 id="particle-filter-with-replay">9.9 Particle Filter with
Replay</h2>
<p>For models where observations occur at multiple points during
execution, we can do even better with <em>particle filtering</em>. The
key idea is to run multiple particles in parallel, periodically
<em>resampling</em> to focus computation on high-weight particles.</p>
<p>The challenge is that OCaml’s continuations are one-shot, so we
cannot simply “clone” a particle. Instead, we use <strong>replay-based
inference</strong>: store the sequence of sampling choices (a
<em>trace</em>), and when we need to continue a particle, re-run the
program from the beginning but fast-forward through already-recorded
choices. Each <code>Sample</code> effect serves as a natural
synchronization point.</p>
<div class="sourceCode" id="cb361"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb361-1"><a href="#cb361-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> ParticleFilter = <span class="kw">struct</span></span>
<span id="cb361-2"><a href="#cb361-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> trace = <span class="dt">int</span> <span class="dt">list</span></span>
<span id="cb361-3"><a href="#cb361-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">exception</span> HardFail</span>
<span id="cb361-4"><a href="#cb361-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb361-5"><a href="#cb361-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* Result of running one step *)</span></span>
<span id="cb361-6"><a href="#cb361-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a step =</span>
<span id="cb361-7"><a href="#cb361-7" aria-hidden="true" tabindex="-1"></a>    | Done <span class="kw">of</span> &#39;a * trace * <span class="dt">float</span>   <span class="co">(* completed with result, trace, weight *)</span></span>
<span id="cb361-8"><a href="#cb361-8" aria-hidden="true" tabindex="-1"></a>    | Paused <span class="kw">of</span> trace * <span class="dt">float</span>      <span class="co">(* paused at Sample with trace, weight *)</span></span>
<span id="cb361-9"><a href="#cb361-9" aria-hidden="true" tabindex="-1"></a>    | Failed                       <span class="co">(* hard failure *)</span></span>
<span id="cb361-10"><a href="#cb361-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb361-11"><a href="#cb361-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> sample_index weights =</span>
<span id="cb361-12"><a href="#cb361-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> total = <span class="dt">Array</span>.fold_left (+.) <span class="fl">0.0</span> weights <span class="kw">in</span></span>
<span id="cb361-13"><a href="#cb361-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r = <span class="dt">Random</span>.<span class="dt">float</span> total <span class="kw">in</span></span>
<span id="cb361-14"><a href="#cb361-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">rec</span> find i acc =</span>
<span id="cb361-15"><a href="#cb361-15" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> i &gt;= <span class="dt">Array</span>.length weights <span class="kw">then</span> <span class="dt">Array</span>.length weights - <span class="dv">1</span></span>
<span id="cb361-16"><a href="#cb361-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> <span class="kw">if</span> r &lt; acc +. weights.(i) <span class="kw">then</span> i</span>
<span id="cb361-17"><a href="#cb361-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> find (i + <span class="dv">1</span>) (acc +. weights.(i)) <span class="kw">in</span></span>
<span id="cb361-18"><a href="#cb361-18" aria-hidden="true" tabindex="-1"></a>    find <span class="dv">0</span> <span class="fl">0.0</span></span>
<span id="cb361-19"><a href="#cb361-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb361-20"><a href="#cb361-20" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* Run until the next fresh Sample, replaying recorded choices *)</span></span>
<span id="cb361-21"><a href="#cb361-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> run_one_step : <span class="kw">type</span> a. (<span class="dt">unit</span> -&gt; a) -&gt; trace -&gt; a step = <span class="kw">fun</span> f trace -&gt;</span>
<span id="cb361-22"><a href="#cb361-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> remaining = <span class="dt">ref</span> trace <span class="kw">in</span></span>
<span id="cb361-23"><a href="#cb361-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> recorded = <span class="dt">ref</span> [] <span class="kw">in</span></span>
<span id="cb361-24"><a href="#cb361-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> weight = <span class="dt">ref</span> <span class="fl">1.0</span> <span class="kw">in</span></span>
<span id="cb361-25"><a href="#cb361-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> f () <span class="kw">with</span></span>
<span id="cb361-26"><a href="#cb361-26" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">result</span> -&gt; Done (<span class="dt">result</span>, <span class="dt">List</span>.rev !recorded, !weight)</span>
<span id="cb361-27"><a href="#cb361-27" aria-hidden="true" tabindex="-1"></a>    | effect (Sample (_, weights)), k -&gt;</span>
<span id="cb361-28"><a href="#cb361-28" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">match</span> !remaining <span class="kw">with</span></span>
<span id="cb361-29"><a href="#cb361-29" aria-hidden="true" tabindex="-1"></a>         | choice :: rest -&gt;</span>
<span id="cb361-30"><a href="#cb361-30" aria-hidden="true" tabindex="-1"></a>             <span class="co">(* Replay: use recorded choice *)</span></span>
<span id="cb361-31"><a href="#cb361-31" aria-hidden="true" tabindex="-1"></a>             remaining := rest;</span>
<span id="cb361-32"><a href="#cb361-32" aria-hidden="true" tabindex="-1"></a>             recorded := choice :: !recorded;</span>
<span id="cb361-33"><a href="#cb361-33" aria-hidden="true" tabindex="-1"></a>             <span class="dt">Effect</span>.Deep.continue k choice</span>
<span id="cb361-34"><a href="#cb361-34" aria-hidden="true" tabindex="-1"></a>         | [] -&gt;</span>
<span id="cb361-35"><a href="#cb361-35" aria-hidden="true" tabindex="-1"></a>             <span class="co">(* Fresh sample: make choice and pause *)</span></span>
<span id="cb361-36"><a href="#cb361-36" aria-hidden="true" tabindex="-1"></a>             <span class="kw">let</span> choice = sample_index weights <span class="kw">in</span></span>
<span id="cb361-37"><a href="#cb361-37" aria-hidden="true" tabindex="-1"></a>             recorded := choice :: !recorded;</span>
<span id="cb361-38"><a href="#cb361-38" aria-hidden="true" tabindex="-1"></a>             Paused (<span class="dt">List</span>.rev !recorded, !weight))</span>
<span id="cb361-39"><a href="#cb361-39" aria-hidden="true" tabindex="-1"></a>    | effect (Observe likelihood), k -&gt;</span>
<span id="cb361-40"><a href="#cb361-40" aria-hidden="true" tabindex="-1"></a>        weight := !weight *. likelihood;</span>
<span id="cb361-41"><a href="#cb361-41" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Effect</span>.Deep.continue k ()</span>
<span id="cb361-42"><a href="#cb361-42" aria-hidden="true" tabindex="-1"></a>    | effect Fail, k -&gt; <span class="dt">Effect</span>.Deep.discontinue k HardFail</span>
<span id="cb361-43"><a href="#cb361-43" aria-hidden="true" tabindex="-1"></a>    | <span class="kw">exception</span> HardFail -&gt; Failed</span>
<span id="cb361-44"><a href="#cb361-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb361-45"><a href="#cb361-45" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* Resample: select n indices according to weights *)</span></span>
<span id="cb361-46"><a href="#cb361-46" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> resample_indices n weights =</span>
<span id="cb361-47"><a href="#cb361-47" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> total = <span class="dt">Array</span>.fold_left (+.) <span class="fl">0.0</span> weights <span class="kw">in</span></span>
<span id="cb361-48"><a href="#cb361-48" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> total &lt;= <span class="fl">0.0</span> <span class="kw">then</span> <span class="dt">Array</span>.init n (<span class="kw">fun</span> i -&gt; i <span class="kw">mod</span> n)</span>
<span id="cb361-49"><a href="#cb361-49" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="kw">begin</span></span>
<span id="cb361-50"><a href="#cb361-50" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> cumulative = <span class="dt">Array</span>.make n <span class="fl">0.0</span> <span class="kw">in</span></span>
<span id="cb361-51"><a href="#cb361-51" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> acc = <span class="dt">ref</span> <span class="fl">0.0</span> <span class="kw">in</span></span>
<span id="cb361-52"><a href="#cb361-52" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Array</span>.iteri (<span class="kw">fun</span> i w -&gt;</span>
<span id="cb361-53"><a href="#cb361-53" aria-hidden="true" tabindex="-1"></a>        acc := !acc +. w /. total;</span>
<span id="cb361-54"><a href="#cb361-54" aria-hidden="true" tabindex="-1"></a>        cumulative.(i) &lt;- !acc) weights;</span>
<span id="cb361-55"><a href="#cb361-55" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Array</span>.init n (<span class="kw">fun</span> _ -&gt;</span>
<span id="cb361-56"><a href="#cb361-56" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> r = <span class="dt">Random</span>.<span class="dt">float</span> <span class="fl">1.0</span> <span class="kw">in</span></span>
<span id="cb361-57"><a href="#cb361-57" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">rec</span> find i =</span>
<span id="cb361-58"><a href="#cb361-58" aria-hidden="true" tabindex="-1"></a>          <span class="kw">if</span> i &gt;= n - <span class="dv">1</span> || cumulative.(i) &gt;= r <span class="kw">then</span> i</span>
<span id="cb361-59"><a href="#cb361-59" aria-hidden="true" tabindex="-1"></a>          <span class="kw">else</span> find (i + <span class="dv">1</span>) <span class="kw">in</span></span>
<span id="cb361-60"><a href="#cb361-60" aria-hidden="true" tabindex="-1"></a>        find <span class="dv">0</span>)</span>
<span id="cb361-61"><a href="#cb361-61" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb361-62"><a href="#cb361-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb361-63"><a href="#cb361-63" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* Effective sample size relative to n (returns value in [0, 1]) *)</span></span>
<span id="cb361-64"><a href="#cb361-64" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> effective_sample_size weights =</span>
<span id="cb361-65"><a href="#cb361-65" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> n = <span class="dt">float_of_int</span> (<span class="dt">Array</span>.length weights) <span class="kw">in</span></span>
<span id="cb361-66"><a href="#cb361-66" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> total = <span class="dt">Array</span>.fold_left (+.) <span class="fl">0.0</span> weights <span class="kw">in</span></span>
<span id="cb361-67"><a href="#cb361-67" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> total &lt;= <span class="fl">0.0</span> <span class="kw">then</span> <span class="fl">0.0</span></span>
<span id="cb361-68"><a href="#cb361-68" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="kw">begin</span></span>
<span id="cb361-69"><a href="#cb361-69" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> sum_sq = <span class="dt">Array</span>.fold_left (<span class="kw">fun</span> acc w -&gt;</span>
<span id="cb361-70"><a href="#cb361-70" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> nw = w /. total <span class="kw">in</span> acc +. nw *. nw) <span class="fl">0.0</span> weights <span class="kw">in</span></span>
<span id="cb361-71"><a href="#cb361-71" aria-hidden="true" tabindex="-1"></a>      <span class="fl">1.0</span> /. sum_sq /. n</span>
<span id="cb361-72"><a href="#cb361-72" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb361-73"><a href="#cb361-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb361-74"><a href="#cb361-74" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> infer ?(n=<span class="dv">1000</span>) ?(resample_threshold=<span class="fl">0.5</span>) f =</span>
<span id="cb361-75"><a href="#cb361-75" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* Each particle: trace, weight *)</span></span>
<span id="cb361-76"><a href="#cb361-76" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> traces = <span class="dt">Array</span>.make n [] <span class="kw">in</span></span>
<span id="cb361-77"><a href="#cb361-77" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> weights = <span class="dt">Array</span>.make n <span class="fl">1.0</span> <span class="kw">in</span></span>
<span id="cb361-78"><a href="#cb361-78" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> active = <span class="dt">Array</span>.make n <span class="kw">true</span> <span class="kw">in</span></span>
<span id="cb361-79"><a href="#cb361-79" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> final_results = <span class="dt">ref</span> [] <span class="kw">in</span></span>
<span id="cb361-80"><a href="#cb361-80" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> n_active = <span class="dt">ref</span> n <span class="kw">in</span></span>
<span id="cb361-81"><a href="#cb361-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb361-82"><a href="#cb361-82" aria-hidden="true" tabindex="-1"></a>    <span class="kw">while</span> !n_active &gt; <span class="dv">0</span> <span class="kw">do</span></span>
<span id="cb361-83"><a href="#cb361-83" aria-hidden="true" tabindex="-1"></a>      <span class="co">(* Advance each active particle by one Sample *)</span></span>
<span id="cb361-84"><a href="#cb361-84" aria-hidden="true" tabindex="-1"></a>      <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> n - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb361-85"><a href="#cb361-85" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> active.(i) <span class="kw">then</span></span>
<span id="cb361-86"><a href="#cb361-86" aria-hidden="true" tabindex="-1"></a>          <span class="kw">match</span> run_one_step f traces.(i) <span class="kw">with</span></span>
<span id="cb361-87"><a href="#cb361-87" aria-hidden="true" tabindex="-1"></a>          | Done (<span class="dt">result</span>, trace, w) -&gt;</span>
<span id="cb361-88"><a href="#cb361-88" aria-hidden="true" tabindex="-1"></a>              final_results := (<span class="dt">result</span>, weights.(i) *. w) :: !final_results;</span>
<span id="cb361-89"><a href="#cb361-89" aria-hidden="true" tabindex="-1"></a>              active.(i) &lt;- <span class="kw">false</span>;</span>
<span id="cb361-90"><a href="#cb361-90" aria-hidden="true" tabindex="-1"></a>              <span class="dt">decr</span> n_active</span>
<span id="cb361-91"><a href="#cb361-91" aria-hidden="true" tabindex="-1"></a>          | Paused (trace, w) -&gt;</span>
<span id="cb361-92"><a href="#cb361-92" aria-hidden="true" tabindex="-1"></a>              traces.(i) &lt;- trace;</span>
<span id="cb361-93"><a href="#cb361-93" aria-hidden="true" tabindex="-1"></a>              weights.(i) &lt;- weights.(i) *. w</span>
<span id="cb361-94"><a href="#cb361-94" aria-hidden="true" tabindex="-1"></a>          | Failed -&gt;</span>
<span id="cb361-95"><a href="#cb361-95" aria-hidden="true" tabindex="-1"></a>              active.(i) &lt;- <span class="kw">false</span>;</span>
<span id="cb361-96"><a href="#cb361-96" aria-hidden="true" tabindex="-1"></a>              <span class="dt">decr</span> n_active</span>
<span id="cb361-97"><a href="#cb361-97" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span>;</span>
<span id="cb361-98"><a href="#cb361-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb361-99"><a href="#cb361-99" aria-hidden="true" tabindex="-1"></a>      <span class="co">(* Resample if ESS is low and there are still active particles *)</span></span>
<span id="cb361-100"><a href="#cb361-100" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> !n_active &gt; <span class="dv">0</span> <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb361-101"><a href="#cb361-101" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> active_weights = <span class="dt">Array</span>.of_list (</span>
<span id="cb361-102"><a href="#cb361-102" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Array</span>.to_list weights |&gt; <span class="dt">List</span>.filteri (<span class="kw">fun</span> i _ -&gt; active.(i))) <span class="kw">in</span></span>
<span id="cb361-103"><a href="#cb361-103" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> effective_sample_size active_weights &lt; resample_threshold <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb361-104"><a href="#cb361-104" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> active_indices = <span class="dt">Array</span>.of_list (</span>
<span id="cb361-105"><a href="#cb361-105" aria-hidden="true" tabindex="-1"></a>            <span class="dt">List</span>.init n (<span class="kw">fun</span> i -&gt; i) |&gt; <span class="dt">List</span>.filter (<span class="kw">fun</span> i -&gt; active.(i))) <span class="kw">in</span></span>
<span id="cb361-106"><a href="#cb361-106" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> active_n = <span class="dt">Array</span>.length active_indices <span class="kw">in</span></span>
<span id="cb361-107"><a href="#cb361-107" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> indices = resample_indices active_n active_weights <span class="kw">in</span></span>
<span id="cb361-108"><a href="#cb361-108" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> new_traces = <span class="dt">Array</span>.map (<span class="kw">fun</span> j -&gt;</span>
<span id="cb361-109"><a href="#cb361-109" aria-hidden="true" tabindex="-1"></a>            traces.(active_indices.(j))) indices <span class="kw">in</span></span>
<span id="cb361-110"><a href="#cb361-110" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> new_weight = <span class="fl">1.0</span> /. <span class="dt">float_of_int</span> active_n <span class="kw">in</span></span>
<span id="cb361-111"><a href="#cb361-111" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Array</span>.iteri (<span class="kw">fun</span> j _ -&gt;</span>
<span id="cb361-112"><a href="#cb361-112" aria-hidden="true" tabindex="-1"></a>            traces.(active_indices.(j)) &lt;- new_traces.(j);</span>
<span id="cb361-113"><a href="#cb361-113" aria-hidden="true" tabindex="-1"></a>            weights.(active_indices.(j)) &lt;- new_weight) indices</span>
<span id="cb361-114"><a href="#cb361-114" aria-hidden="true" tabindex="-1"></a>        <span class="kw">end</span></span>
<span id="cb361-115"><a href="#cb361-115" aria-hidden="true" tabindex="-1"></a>      <span class="kw">end</span></span>
<span id="cb361-116"><a href="#cb361-116" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span>;</span>
<span id="cb361-117"><a href="#cb361-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb361-118"><a href="#cb361-118" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* Aggregate results *)</span></span>
<span id="cb361-119"><a href="#cb361-119" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> combined = <span class="dt">Hashtbl</span>.create <span class="dv">16</span> <span class="kw">in</span></span>
<span id="cb361-120"><a href="#cb361-120" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> total = <span class="dt">ref</span> <span class="fl">0.0</span> <span class="kw">in</span></span>
<span id="cb361-121"><a href="#cb361-121" aria-hidden="true" tabindex="-1"></a>    <span class="dt">List</span>.iter (<span class="kw">fun</span> (v, w) -&gt;</span>
<span id="cb361-122"><a href="#cb361-122" aria-hidden="true" tabindex="-1"></a>      total := !total +. w;</span>
<span id="cb361-123"><a href="#cb361-123" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> prev = <span class="kw">try</span> <span class="dt">Hashtbl</span>.find combined v <span class="kw">with</span> <span class="dt">Not_found</span> -&gt; <span class="fl">0.0</span> <span class="kw">in</span></span>
<span id="cb361-124"><a href="#cb361-124" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Hashtbl</span>.replace combined v (prev +. w)) !final_results;</span>
<span id="cb361-125"><a href="#cb361-125" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> !total &gt; <span class="fl">0.0</span> <span class="kw">then</span></span>
<span id="cb361-126"><a href="#cb361-126" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Hashtbl</span>.fold (<span class="kw">fun</span> v w acc -&gt; (v, w /. !total) :: acc) combined []</span>
<span id="cb361-127"><a href="#cb361-127" aria-hidden="true" tabindex="-1"></a>      |&gt; <span class="dt">List</span>.sort (<span class="kw">fun</span> (_, p1) (_, p2) -&gt; <span class="dt">compare</span> p2 p1)</span>
<span id="cb361-128"><a href="#cb361-128" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> []</span>
<span id="cb361-129"><a href="#cb361-129" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>The particle filter works by:</p>
<ol type="1">
<li><strong>Initialization</strong>: Start n particles with empty traces
and equal weights</li>
<li><strong>Extension</strong>: Advance each particle to the next
<code>Sample</code>. During replay, recorded choices are reused; at a
fresh <code>Sample</code>, we make a new choice and pause</li>
<li><strong>Weight accumulation</strong>: <code>Observe</code> effects
multiply the particle’s weight</li>
<li><strong>Resampling</strong>: If the effective sample size drops
below the threshold, resample traces proportional to weights</li>
<li><strong>Completion</strong>: When a particle finishes, record its
result weighted by its final weight</li>
</ol>
<p>Let us test the particle filter:</p>
<div class="sourceCode" id="cb362"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb362-1"><a href="#cb362-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () =</span>
<span id="cb362-2"><a href="#cb362-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Printf</span>.printf <span class="st">&quot;</span><span class="ch">\n</span><span class="st">=== Particle Filter Tests ===</span><span class="ch">\n</span><span class="st">&quot;</span>;</span>
<span id="cb362-3"><a href="#cb362-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Printf</span>.printf <span class="st">&quot;Monty Hall (no switch): &quot;</span>;</span>
<span id="cb362-4"><a href="#cb362-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> dist = ParticleFilter.infer ~n:<span class="dv">5000</span> (<span class="kw">fun</span> () -&gt; monty_hall ~switch:<span class="kw">false</span>) <span class="kw">in</span></span>
<span id="cb362-5"><a href="#cb362-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.iter (<span class="kw">fun</span> (win, p) -&gt;</span>
<span id="cb362-6"><a href="#cb362-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Printf</span>.printf <span class="st">&quot;%s: %.3f  &quot;</span> (<span class="kw">if</span> win <span class="kw">then</span> <span class="st">&quot;win&quot;</span> <span class="kw">else</span> <span class="st">&quot;lose&quot;</span>) p) dist;</span>
<span id="cb362-7"><a href="#cb362-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">print_newline</span> ()</span>
<span id="cb362-8"><a href="#cb362-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb362-9"><a href="#cb362-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () =</span>
<span id="cb362-10"><a href="#cb362-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Printf</span>.printf <span class="st">&quot;Monty Hall (switch): &quot;</span>;</span>
<span id="cb362-11"><a href="#cb362-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> dist = ParticleFilter.infer ~n:<span class="dv">5000</span> (<span class="kw">fun</span> () -&gt; monty_hall ~switch:<span class="kw">true</span>) <span class="kw">in</span></span>
<span id="cb362-12"><a href="#cb362-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.iter (<span class="kw">fun</span> (win, p) -&gt;</span>
<span id="cb362-13"><a href="#cb362-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Printf</span>.printf <span class="st">&quot;%s: %.3f  &quot;</span> (<span class="kw">if</span> win <span class="kw">then</span> <span class="st">&quot;win&quot;</span> <span class="kw">else</span> <span class="st">&quot;lose&quot;</span>) p) dist;</span>
<span id="cb362-14"><a href="#cb362-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">print_newline</span> ()</span>
<span id="cb362-15"><a href="#cb362-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb362-16"><a href="#cb362-16" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () =</span>
<span id="cb362-17"><a href="#cb362-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Printf</span>.printf <span class="st">&quot;Burglary soft (particle filter):</span><span class="ch">\n</span><span class="st">&quot;</span>;</span>
<span id="cb362-18"><a href="#cb362-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> dist = ParticleFilter.infer ~n:<span class="dv">10000</span> (<span class="kw">fun</span> () -&gt;</span>
<span id="cb362-19"><a href="#cb362-19" aria-hidden="true" tabindex="-1"></a>    burglary_soft ~john_called:<span class="kw">true</span> ~mary_called:<span class="kw">true</span>) <span class="kw">in</span></span>
<span id="cb362-20"><a href="#cb362-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.iter (<span class="kw">fun</span> (outcome, p) -&gt;</span>
<span id="cb362-21"><a href="#cb362-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s = <span class="kw">match</span> outcome <span class="kw">with</span></span>
<span id="cb362-22"><a href="#cb362-22" aria-hidden="true" tabindex="-1"></a>      | Safe -&gt; <span class="st">&quot;Safe&quot;</span> | Burglary -&gt; <span class="st">&quot;Burglary&quot;</span></span>
<span id="cb362-23"><a href="#cb362-23" aria-hidden="true" tabindex="-1"></a>      | Earthquake -&gt; <span class="st">&quot;Earthquake&quot;</span> | Both -&gt; <span class="st">&quot;Both&quot;</span> <span class="kw">in</span></span>
<span id="cb362-24"><a href="#cb362-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Printf</span>.printf <span class="st">&quot;  %s: %.4f</span><span class="ch">\n</span><span class="st">&quot;</span> s p) dist</span></code></pre></div>
<h2 id="comparing-inference-methods">9.10 Comparing Inference
Methods</h2>
<p>We have seen three approaches to probabilistic inference:</p>
<table>
<colgroup>
<col style="width: 40%" />
<col style="width: 30%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr>
<th>Method</th>
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr>
<td>Rejection Sampling</td>
<td>Simple, exact for accepted samples</td>
<td>Wasteful when observations are rare</td>
</tr>
<tr>
<td>Importance Sampling</td>
<td>Uses all samples</td>
<td>Can suffer from weight degeneracy</td>
</tr>
<tr>
<td>Particle Filtering</td>
<td>Adaptive resampling</td>
<td>More complex, replay overhead</td>
</tr>
</tbody>
</table>
<p>The effect-based approach has a key advantage: the <em>same
probabilistic program</em> can be interpreted by different handlers. We
write <code>monty_hall</code> once and run it with any inference
engine.</p>
<div class="sourceCode" id="cb363"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb363-1"><a href="#cb363-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () =</span>
<span id="cb363-2"><a href="#cb363-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Printf</span>.printf <span class="st">&quot;</span><span class="ch">\n</span><span class="st">=== Comparison ===</span><span class="ch">\n</span><span class="st">&quot;</span>;</span>
<span id="cb363-3"><a href="#cb363-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> test name infer =</span>
<span id="cb363-4"><a href="#cb363-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> dist = infer (<span class="kw">fun</span> () -&gt; monty_hall ~switch:<span class="kw">true</span>) <span class="kw">in</span></span>
<span id="cb363-5"><a href="#cb363-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> win_prob = <span class="kw">try</span> <span class="dt">List</span>.assoc <span class="kw">true</span> dist <span class="kw">with</span> <span class="dt">Not_found</span> -&gt; <span class="fl">0.0</span> <span class="kw">in</span></span>
<span id="cb363-6"><a href="#cb363-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Printf</span>.printf <span class="st">&quot;%s: P(win|switch) = %.4f</span><span class="ch">\n</span><span class="st">&quot;</span> name win_prob</span>
<span id="cb363-7"><a href="#cb363-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb363-8"><a href="#cb363-8" aria-hidden="true" tabindex="-1"></a>  test <span class="st">&quot;Rejection&quot;</span> (Rejection.infer ~samples:<span class="dv">10000</span>);</span>
<span id="cb363-9"><a href="#cb363-9" aria-hidden="true" tabindex="-1"></a>  test <span class="st">&quot;Importance&quot;</span> (Importance.infer ~samples:<span class="dv">10000</span>);</span>
<span id="cb363-10"><a href="#cb363-10" aria-hidden="true" tabindex="-1"></a>  test <span class="st">&quot;Particle Filter&quot;</span> (ParticleFilter.infer ~n:<span class="dv">5000</span>)</span></code></pre></div>
<h2 id="summary">9.11 Summary</h2>
<p>Algebraic effects provide a powerful alternative to monads for
structuring effectful computations:</p>
<ol type="1">
<li><p><strong>Separation of concerns</strong>: Effect declarations
specify <em>what</em> effects can occur. Handlers specify <em>how</em>
effects are interpreted.</p></li>
<li><p><strong>Direct style</strong>: Code performing effects looks like
ordinary code. No <code>let*</code> or bind operators needed.</p></li>
<li><p><strong>Flexibility</strong>: The same effectful code can be
interpreted different ways by different handlers.</p></li>
<li><p><strong>Continuations</strong>: Handlers receive continuations,
enabling sophisticated control flow patterns like coroutines and
particle filtering.</p></li>
</ol>
<p>We saw two substantial applications:</p>
<ul>
<li><p><strong>Lightweight threads</strong>: Effects make cooperative
concurrency straightforward. The <code>Yield</code>, <code>Async</code>,
and <code>Await</code> effects are handled by a scheduler that manages
continuations.</p></li>
<li><p><strong>Probabilistic programming</strong>: <code>Sample</code>,
<code>Observe</code>, and <code>Fail</code> effects describe
probabilistic models. Different handlers implement different inference
strategies.</p></li>
</ul>
<p>The key insight is that effects are a <em>programming interface</em>
that can have multiple <em>implementations</em>. This makes code more
modular and reusable.</p>
<h2 id="a-typed-sampling-interface-with-gadts">9.12 A Typed Sampling
Interface with GADTs</h2>
<p>In Section 9.5, we defined probabilistic effects using indices into
arrays:</p>
<div class="sourceCode" id="cb364"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb364-1"><a href="#cb364-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> _ <span class="dt">Effect</span>.t +=</span>
<span id="cb364-2"><a href="#cb364-2" aria-hidden="true" tabindex="-1"></a>  | Sample : (<span class="dt">string</span> * <span class="dt">float</span> <span class="dt">array</span>) -&gt; <span class="dt">int</span> <span class="dt">Effect</span>.t  <span class="co">(* returns index *)</span></span></code></pre></div>
<p>This works but is somewhat awkward: <code>flip</code> returns an
integer 0 or 1 that we then compare to 0, and <code>uniform</code>
selects from an array by index. Can we define a more direct
<code>Choose : 'a list -&gt; 'a Effect.t</code> effect that returns
elements directly?</p>
<p>The worry is easy to overstate:</p>
<ul>
<li>Defining <code>Choose : 'a list -&gt; 'a Effect.t</code> is
<em>not</em> a type-system problem: <code>Effect.t</code> is already an
extensible GADT, so each effect constructor can refine the return type,
and the handler case <code>effect (Choose xs), k -&gt; ...</code> is
type-checked using the same GADT mechanism as any other GADT match.</li>
<li>What <em>can</em> become problematic is <strong>replay
traces</strong>: if we tried to store the <em>chosen values</em> (of
many different types) in a single list, we would need some form of
dynamic typing.</li>
</ul>
<p>For replay-based inference, we can avoid that entirely: we store a
trace of <strong>type-agnostic random choices</strong> (indices for
<code>Choose</code>, floats for <code>Gaussian</code>). The program
remains fully typed, and replay is straightforward: we use the stored
index to select from the list passed to <code>Choose</code>.</p>
<h3 id="a-gadt-typed-sampling-api">A GADT-Typed Sampling API</h3>
<div class="sourceCode" id="cb365"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb365-1"><a href="#cb365-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> GProb = <span class="kw">struct</span></span>
<span id="cb365-2"><a href="#cb365-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> _ <span class="dt">Effect</span>.t +=</span>
<span id="cb365-3"><a href="#cb365-3" aria-hidden="true" tabindex="-1"></a>    | Choose : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">Effect</span>.t</span>
<span id="cb365-4"><a href="#cb365-4" aria-hidden="true" tabindex="-1"></a>    | Gaussian : <span class="dt">float</span> * <span class="dt">float</span> -&gt; <span class="dt">float</span> <span class="dt">Effect</span>.t</span>
<span id="cb365-5"><a href="#cb365-5" aria-hidden="true" tabindex="-1"></a>    | GObserve : <span class="dt">float</span> -&gt; <span class="dt">unit</span> <span class="dt">Effect</span>.t</span>
<span id="cb365-6"><a href="#cb365-6" aria-hidden="true" tabindex="-1"></a>    | GFail : &#39;a <span class="dt">Effect</span>.t</span>
<span id="cb365-7"><a href="#cb365-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb365-8"><a href="#cb365-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> choose xs =</span>
<span id="cb365-9"><a href="#cb365-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> xs <span class="kw">with</span></span>
<span id="cb365-10"><a href="#cb365-10" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; <span class="dt">invalid_arg</span> <span class="st">&quot;choose: empty list&quot;</span></span>
<span id="cb365-11"><a href="#cb365-11" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; <span class="dt">Effect</span>.perform (Choose xs)</span>
<span id="cb365-12"><a href="#cb365-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb365-13"><a href="#cb365-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> gaussian ~mu ~sigma =</span>
<span id="cb365-14"><a href="#cb365-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> sigma &lt;= <span class="fl">0.0</span> <span class="kw">then</span> <span class="dt">invalid_arg</span> <span class="st">&quot;gaussian: sigma must be positive&quot;</span>;</span>
<span id="cb365-15"><a href="#cb365-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Effect</span>.perform (Gaussian (mu, sigma))</span>
<span id="cb365-16"><a href="#cb365-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb365-17"><a href="#cb365-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> observe w =</span>
<span id="cb365-18"><a href="#cb365-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> w &lt; <span class="fl">0.0</span> <span class="kw">then</span> <span class="dt">invalid_arg</span> <span class="st">&quot;observe: weight must be nonnegative&quot;</span>;</span>
<span id="cb365-19"><a href="#cb365-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Effect</span>.perform (GObserve w)</span>
<span id="cb365-20"><a href="#cb365-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb365-21"><a href="#cb365-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> fail () = <span class="dt">Effect</span>.perform GFail</span>
<span id="cb365-22"><a href="#cb365-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb365-23"><a href="#cb365-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> pi = <span class="fl">4.0</span> *. <span class="dt">atan</span> <span class="fl">1.0</span></span>
<span id="cb365-24"><a href="#cb365-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb365-25"><a href="#cb365-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> normal_pdf x ~mu ~sigma =</span>
<span id="cb365-26"><a href="#cb365-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> z = (x -. mu) /. sigma <span class="kw">in</span></span>
<span id="cb365-27"><a href="#cb365-27" aria-hidden="true" tabindex="-1"></a>    (<span class="fl">1.0</span> /. (sigma *. <span class="dt">sqrt</span> (<span class="fl">2.0</span> *. pi))) *. <span class="dt">exp</span> (<span class="fl">-0.5</span> *. z *. z)</span>
<span id="cb365-28"><a href="#cb365-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb365-29"><a href="#cb365-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> sample_gaussian ~mu ~sigma =</span>
<span id="cb365-30"><a href="#cb365-30" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* Box-Muller transform *)</span></span>
<span id="cb365-31"><a href="#cb365-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> u1 = <span class="dt">max</span> <span class="fl">1e-12</span> (<span class="dt">Random</span>.<span class="dt">float</span> <span class="fl">1.0</span>) <span class="kw">in</span></span>
<span id="cb365-32"><a href="#cb365-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> u2 = <span class="dt">Random</span>.<span class="dt">float</span> <span class="fl">1.0</span> <span class="kw">in</span></span>
<span id="cb365-33"><a href="#cb365-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r = <span class="dt">sqrt</span> (<span class="fl">-2.0</span> *. <span class="dt">log</span> u1) <span class="kw">in</span></span>
<span id="cb365-34"><a href="#cb365-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> theta = <span class="fl">2.0</span> *. pi *. u2 <span class="kw">in</span></span>
<span id="cb365-35"><a href="#cb365-35" aria-hidden="true" tabindex="-1"></a>    mu +. sigma *. (r *. <span class="dt">cos</span> theta)</span>
<span id="cb365-36"><a href="#cb365-36" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>The <code>Choose</code> effect is polymorphic:
<code>Choose : 'a list -&gt; 'a Effect.t</code>. When we perform
<code>Choose ["heads"; "tails"]</code>, the result type is
<code>string</code>. When we perform
<code>Choose [1; 2; 3; 4; 5; 6]</code>, the result type is
<code>int</code>. The GADT ensures type safety at each use site.</p>
<p>The <code>Gaussian</code> effect samples from a normal distribution
using the Box-Muller transform.</p>
<h3 id="importance-sampling-for-choose-gaussian">Importance Sampling for
Choose + Gaussian</h3>
<div class="sourceCode" id="cb366"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb366-1"><a href="#cb366-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> GImportance = <span class="kw">struct</span></span>
<span id="cb366-2"><a href="#cb366-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">exception</span> HardFail</span>
<span id="cb366-3"><a href="#cb366-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb366-4"><a href="#cb366-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> run_once : <span class="kw">type</span> a. (<span class="dt">unit</span> -&gt; a) -&gt; (a * <span class="dt">float</span>) <span class="dt">option</span> = <span class="kw">fun</span> f -&gt;</span>
<span id="cb366-5"><a href="#cb366-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> weight = <span class="dt">ref</span> <span class="fl">1.0</span> <span class="kw">in</span></span>
<span id="cb366-6"><a href="#cb366-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> f () <span class="kw">with</span></span>
<span id="cb366-7"><a href="#cb366-7" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">result</span> -&gt; <span class="dt">Some</span> (<span class="dt">result</span>, !weight)</span>
<span id="cb366-8"><a href="#cb366-8" aria-hidden="true" tabindex="-1"></a>    | effect (GProb.Choose xs), k -&gt;</span>
<span id="cb366-9"><a href="#cb366-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> i = <span class="dt">Random</span>.<span class="dt">int</span> (<span class="dt">List</span>.length xs) <span class="kw">in</span></span>
<span id="cb366-10"><a href="#cb366-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Effect</span>.Deep.continue k (<span class="dt">List</span>.nth xs i)</span>
<span id="cb366-11"><a href="#cb366-11" aria-hidden="true" tabindex="-1"></a>    | effect (GProb.Gaussian (mu, sigma)), k -&gt;</span>
<span id="cb366-12"><a href="#cb366-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Effect</span>.Deep.continue k (GProb.sample_gaussian ~mu ~sigma)</span>
<span id="cb366-13"><a href="#cb366-13" aria-hidden="true" tabindex="-1"></a>    | effect (GProb.GObserve w), k -&gt;</span>
<span id="cb366-14"><a href="#cb366-14" aria-hidden="true" tabindex="-1"></a>        weight := !weight *. w;</span>
<span id="cb366-15"><a href="#cb366-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Effect</span>.Deep.continue k ()</span>
<span id="cb366-16"><a href="#cb366-16" aria-hidden="true" tabindex="-1"></a>    | effect GProb.GFail, k -&gt; <span class="dt">Effect</span>.Deep.discontinue k HardFail</span>
<span id="cb366-17"><a href="#cb366-17" aria-hidden="true" tabindex="-1"></a>    | <span class="kw">exception</span> HardFail -&gt; <span class="dt">None</span></span>
<span id="cb366-18"><a href="#cb366-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb366-19"><a href="#cb366-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> infer ?(samples=<span class="dv">10000</span>) f =</span>
<span id="cb366-20"><a href="#cb366-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> results = <span class="dt">Hashtbl</span>.create <span class="dv">16</span> <span class="kw">in</span></span>
<span id="cb366-21"><a href="#cb366-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> total_weight = <span class="dt">ref</span> <span class="fl">0.0</span> <span class="kw">in</span></span>
<span id="cb366-22"><a href="#cb366-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> _ = <span class="dv">1</span> <span class="kw">to</span> samples <span class="kw">do</span></span>
<span id="cb366-23"><a href="#cb366-23" aria-hidden="true" tabindex="-1"></a>      <span class="kw">match</span> run_once f <span class="kw">with</span></span>
<span id="cb366-24"><a href="#cb366-24" aria-hidden="true" tabindex="-1"></a>      | <span class="dt">None</span> -&gt; ()</span>
<span id="cb366-25"><a href="#cb366-25" aria-hidden="true" tabindex="-1"></a>      | <span class="dt">Some</span> (v, w) -&gt;</span>
<span id="cb366-26"><a href="#cb366-26" aria-hidden="true" tabindex="-1"></a>          total_weight := !total_weight +. w;</span>
<span id="cb366-27"><a href="#cb366-27" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> prev = <span class="kw">try</span> <span class="dt">Hashtbl</span>.find results v <span class="kw">with</span> <span class="dt">Not_found</span> -&gt; <span class="fl">0.0</span> <span class="kw">in</span></span>
<span id="cb366-28"><a href="#cb366-28" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Hashtbl</span>.replace results v (prev +. w)</span>
<span id="cb366-29"><a href="#cb366-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span>;</span>
<span id="cb366-30"><a href="#cb366-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> !total_weight &gt; <span class="fl">0.0</span> <span class="kw">then</span></span>
<span id="cb366-31"><a href="#cb366-31" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Hashtbl</span>.fold (<span class="kw">fun</span> v w acc -&gt; (v, w /. !total_weight) :: acc) results []</span>
<span id="cb366-32"><a href="#cb366-32" aria-hidden="true" tabindex="-1"></a>      |&gt; <span class="dt">List</span>.sort (<span class="kw">fun</span> (_, p1) (_, p2) -&gt; <span class="dt">compare</span> p2 p1)</span>
<span id="cb366-33"><a href="#cb366-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> []</span>
<span id="cb366-34"><a href="#cb366-34" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>The handler matches <code>Choose xs</code> and samples uniformly,
returning the actual value. The GADT ensures that
<code>List.nth xs i</code> has type <code>'a</code> and that
<code>continue k (List.nth xs i)</code> is well-typed because
<code>k</code> expects type <code>'a</code>.</p>
<h3 id="particle-filtering-with-replay-for-choose-gaussian">Particle
Filtering with Replay for Choose + Gaussian</h3>
<p>The key insight for replay is simple: we store only
<strong>type-agnostic random draws</strong> – an index for discrete
choices, a float for Gaussian samples. During replay, we use the stored
index to select from the list that’s passed to <code>Choose</code>:</p>
<div class="sourceCode" id="cb367"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb367-1"><a href="#cb367-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> GParticleFilter = <span class="kw">struct</span></span>
<span id="cb367-2"><a href="#cb367-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">exception</span> HardFail</span>
<span id="cb367-3"><a href="#cb367-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb367-4"><a href="#cb367-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> draw =</span>
<span id="cb367-5"><a href="#cb367-5" aria-hidden="true" tabindex="-1"></a>    | DChoose <span class="kw">of</span> <span class="dt">int</span>      <span class="co">(* index into the list *)</span></span>
<span id="cb367-6"><a href="#cb367-6" aria-hidden="true" tabindex="-1"></a>    | DGaussian <span class="kw">of</span> <span class="dt">float</span>  <span class="co">(* sampled value *)</span></span>
<span id="cb367-7"><a href="#cb367-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb367-8"><a href="#cb367-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> trace = draw <span class="dt">list</span></span>
<span id="cb367-9"><a href="#cb367-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb367-10"><a href="#cb367-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a step =</span>
<span id="cb367-11"><a href="#cb367-11" aria-hidden="true" tabindex="-1"></a>    | Done <span class="kw">of</span> &#39;a * trace * <span class="dt">float</span></span>
<span id="cb367-12"><a href="#cb367-12" aria-hidden="true" tabindex="-1"></a>    | Paused <span class="kw">of</span> trace * <span class="dt">float</span></span>
<span id="cb367-13"><a href="#cb367-13" aria-hidden="true" tabindex="-1"></a>    | Failed</span>
<span id="cb367-14"><a href="#cb367-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb367-15"><a href="#cb367-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> run_one_step : <span class="kw">type</span> a. (<span class="dt">unit</span> -&gt; a) -&gt; trace -&gt; a step = <span class="kw">fun</span> f trace -&gt;</span>
<span id="cb367-16"><a href="#cb367-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> remaining = <span class="dt">ref</span> trace <span class="kw">in</span></span>
<span id="cb367-17"><a href="#cb367-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> recorded = <span class="dt">ref</span> [] <span class="kw">in</span></span>
<span id="cb367-18"><a href="#cb367-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> weight = <span class="dt">ref</span> <span class="fl">1.0</span> <span class="kw">in</span></span>
<span id="cb367-19"><a href="#cb367-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> f () <span class="kw">with</span></span>
<span id="cb367-20"><a href="#cb367-20" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">result</span> -&gt; Done (<span class="dt">result</span>, <span class="dt">List</span>.rev !recorded, !weight)</span>
<span id="cb367-21"><a href="#cb367-21" aria-hidden="true" tabindex="-1"></a>    | effect (GProb.Choose xs), k -&gt;</span>
<span id="cb367-22"><a href="#cb367-22" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">match</span> !remaining <span class="kw">with</span></span>
<span id="cb367-23"><a href="#cb367-23" aria-hidden="true" tabindex="-1"></a>         | DChoose i :: rest -&gt;</span>
<span id="cb367-24"><a href="#cb367-24" aria-hidden="true" tabindex="-1"></a>             <span class="co">(* Replay: use recorded index to select from list *)</span></span>
<span id="cb367-25"><a href="#cb367-25" aria-hidden="true" tabindex="-1"></a>             remaining := rest;</span>
<span id="cb367-26"><a href="#cb367-26" aria-hidden="true" tabindex="-1"></a>             recorded := DChoose i :: !recorded;</span>
<span id="cb367-27"><a href="#cb367-27" aria-hidden="true" tabindex="-1"></a>             <span class="dt">Effect</span>.Deep.continue k (<span class="dt">List</span>.nth xs i)</span>
<span id="cb367-28"><a href="#cb367-28" aria-hidden="true" tabindex="-1"></a>         | [] -&gt;</span>
<span id="cb367-29"><a href="#cb367-29" aria-hidden="true" tabindex="-1"></a>             <span class="co">(* Fresh sample: choose index and pause *)</span></span>
<span id="cb367-30"><a href="#cb367-30" aria-hidden="true" tabindex="-1"></a>             <span class="kw">let</span> i = <span class="dt">Random</span>.<span class="dt">int</span> (<span class="dt">List</span>.length xs) <span class="kw">in</span></span>
<span id="cb367-31"><a href="#cb367-31" aria-hidden="true" tabindex="-1"></a>             recorded := DChoose i :: !recorded;</span>
<span id="cb367-32"><a href="#cb367-32" aria-hidden="true" tabindex="-1"></a>             Paused (<span class="dt">List</span>.rev !recorded, !weight)</span>
<span id="cb367-33"><a href="#cb367-33" aria-hidden="true" tabindex="-1"></a>         | _ :: _ -&gt;</span>
<span id="cb367-34"><a href="#cb367-34" aria-hidden="true" tabindex="-1"></a>             <span class="co">(* Trace mismatch *)</span></span>
<span id="cb367-35"><a href="#cb367-35" aria-hidden="true" tabindex="-1"></a>             <span class="dt">Effect</span>.Deep.discontinue k HardFail)</span>
<span id="cb367-36"><a href="#cb367-36" aria-hidden="true" tabindex="-1"></a>    | effect (GProb.Gaussian (mu, sigma)), k -&gt;</span>
<span id="cb367-37"><a href="#cb367-37" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">match</span> !remaining <span class="kw">with</span></span>
<span id="cb367-38"><a href="#cb367-38" aria-hidden="true" tabindex="-1"></a>         | DGaussian x :: rest -&gt;</span>
<span id="cb367-39"><a href="#cb367-39" aria-hidden="true" tabindex="-1"></a>             <span class="co">(* Replay: use recorded Gaussian sample *)</span></span>
<span id="cb367-40"><a href="#cb367-40" aria-hidden="true" tabindex="-1"></a>             remaining := rest;</span>
<span id="cb367-41"><a href="#cb367-41" aria-hidden="true" tabindex="-1"></a>             recorded := DGaussian x :: !recorded;</span>
<span id="cb367-42"><a href="#cb367-42" aria-hidden="true" tabindex="-1"></a>             <span class="dt">Effect</span>.Deep.continue k x</span>
<span id="cb367-43"><a href="#cb367-43" aria-hidden="true" tabindex="-1"></a>         | [] -&gt;</span>
<span id="cb367-44"><a href="#cb367-44" aria-hidden="true" tabindex="-1"></a>             <span class="co">(* Fresh Gaussian sample *)</span></span>
<span id="cb367-45"><a href="#cb367-45" aria-hidden="true" tabindex="-1"></a>             <span class="kw">let</span> x = GProb.sample_gaussian ~mu ~sigma <span class="kw">in</span></span>
<span id="cb367-46"><a href="#cb367-46" aria-hidden="true" tabindex="-1"></a>             recorded := DGaussian x :: !recorded;</span>
<span id="cb367-47"><a href="#cb367-47" aria-hidden="true" tabindex="-1"></a>             Paused (<span class="dt">List</span>.rev !recorded, !weight)</span>
<span id="cb367-48"><a href="#cb367-48" aria-hidden="true" tabindex="-1"></a>         | _ :: _ -&gt;</span>
<span id="cb367-49"><a href="#cb367-49" aria-hidden="true" tabindex="-1"></a>             <span class="dt">Effect</span>.Deep.discontinue k HardFail)</span>
<span id="cb367-50"><a href="#cb367-50" aria-hidden="true" tabindex="-1"></a>    | effect (GProb.GObserve w), k -&gt;</span>
<span id="cb367-51"><a href="#cb367-51" aria-hidden="true" tabindex="-1"></a>        weight := !weight *. w;</span>
<span id="cb367-52"><a href="#cb367-52" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Effect</span>.Deep.continue k ()</span>
<span id="cb367-53"><a href="#cb367-53" aria-hidden="true" tabindex="-1"></a>    | effect GProb.GFail, k -&gt; <span class="dt">Effect</span>.Deep.discontinue k HardFail</span>
<span id="cb367-54"><a href="#cb367-54" aria-hidden="true" tabindex="-1"></a>    | <span class="kw">exception</span> HardFail -&gt; Failed</span>
<span id="cb367-55"><a href="#cb367-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb367-56"><a href="#cb367-56" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> resample_indices n weights =</span>
<span id="cb367-57"><a href="#cb367-57" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> total = <span class="dt">Array</span>.fold_left (+.) <span class="fl">0.0</span> weights <span class="kw">in</span></span>
<span id="cb367-58"><a href="#cb367-58" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> total &lt;= <span class="fl">0.0</span> <span class="kw">then</span> <span class="dt">Array</span>.init n (<span class="kw">fun</span> i -&gt; i <span class="kw">mod</span> n)</span>
<span id="cb367-59"><a href="#cb367-59" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="kw">begin</span></span>
<span id="cb367-60"><a href="#cb367-60" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> cumulative = <span class="dt">Array</span>.make n <span class="fl">0.0</span> <span class="kw">in</span></span>
<span id="cb367-61"><a href="#cb367-61" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> acc = <span class="dt">ref</span> <span class="fl">0.0</span> <span class="kw">in</span></span>
<span id="cb367-62"><a href="#cb367-62" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Array</span>.iteri (<span class="kw">fun</span> i w -&gt;</span>
<span id="cb367-63"><a href="#cb367-63" aria-hidden="true" tabindex="-1"></a>        acc := !acc +. w /. total;</span>
<span id="cb367-64"><a href="#cb367-64" aria-hidden="true" tabindex="-1"></a>        cumulative.(i) &lt;- !acc) weights;</span>
<span id="cb367-65"><a href="#cb367-65" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Array</span>.init n (<span class="kw">fun</span> _ -&gt;</span>
<span id="cb367-66"><a href="#cb367-66" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> r = <span class="dt">Random</span>.<span class="dt">float</span> <span class="fl">1.0</span> <span class="kw">in</span></span>
<span id="cb367-67"><a href="#cb367-67" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">rec</span> find i =</span>
<span id="cb367-68"><a href="#cb367-68" aria-hidden="true" tabindex="-1"></a>          <span class="kw">if</span> i &gt;= n - <span class="dv">1</span> || cumulative.(i) &gt;= r <span class="kw">then</span> i</span>
<span id="cb367-69"><a href="#cb367-69" aria-hidden="true" tabindex="-1"></a>          <span class="kw">else</span> find (i + <span class="dv">1</span>)</span>
<span id="cb367-70"><a href="#cb367-70" aria-hidden="true" tabindex="-1"></a>        <span class="kw">in</span> find <span class="dv">0</span>)</span>
<span id="cb367-71"><a href="#cb367-71" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb367-72"><a href="#cb367-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb367-73"><a href="#cb367-73" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> effective_sample_size weights =</span>
<span id="cb367-74"><a href="#cb367-74" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> n = <span class="dt">float_of_int</span> (<span class="dt">Array</span>.length weights) <span class="kw">in</span></span>
<span id="cb367-75"><a href="#cb367-75" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> total = <span class="dt">Array</span>.fold_left (+.) <span class="fl">0.0</span> weights <span class="kw">in</span></span>
<span id="cb367-76"><a href="#cb367-76" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> total &lt;= <span class="fl">0.0</span> <span class="kw">then</span> <span class="fl">0.0</span></span>
<span id="cb367-77"><a href="#cb367-77" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="kw">begin</span></span>
<span id="cb367-78"><a href="#cb367-78" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> sum_sq = <span class="dt">Array</span>.fold_left (<span class="kw">fun</span> acc w -&gt;</span>
<span id="cb367-79"><a href="#cb367-79" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> nw = w /. total <span class="kw">in</span> acc +. nw *. nw) <span class="fl">0.0</span> weights <span class="kw">in</span></span>
<span id="cb367-80"><a href="#cb367-80" aria-hidden="true" tabindex="-1"></a>      <span class="fl">1.0</span> /. sum_sq /. n</span>
<span id="cb367-81"><a href="#cb367-81" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb367-82"><a href="#cb367-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb367-83"><a href="#cb367-83" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> infer ?(n=<span class="dv">1000</span>) ?(resample_threshold=<span class="fl">0.5</span>) f =</span>
<span id="cb367-84"><a href="#cb367-84" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> traces = <span class="dt">Array</span>.make n [] <span class="kw">in</span></span>
<span id="cb367-85"><a href="#cb367-85" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> weights = <span class="dt">Array</span>.make n <span class="fl">1.0</span> <span class="kw">in</span></span>
<span id="cb367-86"><a href="#cb367-86" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> active = <span class="dt">Array</span>.make n <span class="kw">true</span> <span class="kw">in</span></span>
<span id="cb367-87"><a href="#cb367-87" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> final_results = <span class="dt">ref</span> [] <span class="kw">in</span></span>
<span id="cb367-88"><a href="#cb367-88" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> n_active = <span class="dt">ref</span> n <span class="kw">in</span></span>
<span id="cb367-89"><a href="#cb367-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb367-90"><a href="#cb367-90" aria-hidden="true" tabindex="-1"></a>    <span class="kw">while</span> !n_active &gt; <span class="dv">0</span> <span class="kw">do</span></span>
<span id="cb367-91"><a href="#cb367-91" aria-hidden="true" tabindex="-1"></a>      <span class="kw">for</span> i = <span class="dv">0</span> <span class="kw">to</span> n - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb367-92"><a href="#cb367-92" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> active.(i) <span class="kw">then</span></span>
<span id="cb367-93"><a href="#cb367-93" aria-hidden="true" tabindex="-1"></a>          <span class="kw">match</span> run_one_step f traces.(i) <span class="kw">with</span></span>
<span id="cb367-94"><a href="#cb367-94" aria-hidden="true" tabindex="-1"></a>          | Done (<span class="dt">result</span>, trace, w) -&gt;</span>
<span id="cb367-95"><a href="#cb367-95" aria-hidden="true" tabindex="-1"></a>              final_results := (<span class="dt">result</span>, weights.(i) *. w) :: !final_results;</span>
<span id="cb367-96"><a href="#cb367-96" aria-hidden="true" tabindex="-1"></a>              active.(i) &lt;- <span class="kw">false</span>;</span>
<span id="cb367-97"><a href="#cb367-97" aria-hidden="true" tabindex="-1"></a>              <span class="dt">decr</span> n_active</span>
<span id="cb367-98"><a href="#cb367-98" aria-hidden="true" tabindex="-1"></a>          | Paused (trace, w) -&gt;</span>
<span id="cb367-99"><a href="#cb367-99" aria-hidden="true" tabindex="-1"></a>              traces.(i) &lt;- trace;</span>
<span id="cb367-100"><a href="#cb367-100" aria-hidden="true" tabindex="-1"></a>              weights.(i) &lt;- weights.(i) *. w</span>
<span id="cb367-101"><a href="#cb367-101" aria-hidden="true" tabindex="-1"></a>          | Failed -&gt;</span>
<span id="cb367-102"><a href="#cb367-102" aria-hidden="true" tabindex="-1"></a>              active.(i) &lt;- <span class="kw">false</span>;</span>
<span id="cb367-103"><a href="#cb367-103" aria-hidden="true" tabindex="-1"></a>              <span class="dt">decr</span> n_active</span>
<span id="cb367-104"><a href="#cb367-104" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span>;</span>
<span id="cb367-105"><a href="#cb367-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb367-106"><a href="#cb367-106" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> !n_active &gt; <span class="dv">0</span> <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb367-107"><a href="#cb367-107" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> active_indices =</span>
<span id="cb367-108"><a href="#cb367-108" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Array</span>.to_list (<span class="dt">Array</span>.init n (<span class="kw">fun</span> i -&gt; i))</span>
<span id="cb367-109"><a href="#cb367-109" aria-hidden="true" tabindex="-1"></a>          |&gt; <span class="dt">List</span>.filter (<span class="kw">fun</span> i -&gt; active.(i))</span>
<span id="cb367-110"><a href="#cb367-110" aria-hidden="true" tabindex="-1"></a>          |&gt; <span class="dt">Array</span>.of_list <span class="kw">in</span></span>
<span id="cb367-111"><a href="#cb367-111" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> active_n = <span class="dt">Array</span>.length active_indices <span class="kw">in</span></span>
<span id="cb367-112"><a href="#cb367-112" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> active_weights =</span>
<span id="cb367-113"><a href="#cb367-113" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Array</span>.init active_n (<span class="kw">fun</span> j -&gt; weights.(active_indices.(j))) <span class="kw">in</span></span>
<span id="cb367-114"><a href="#cb367-114" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> active_n &gt; <span class="dv">0</span> &amp;&amp;</span>
<span id="cb367-115"><a href="#cb367-115" aria-hidden="true" tabindex="-1"></a>            effective_sample_size active_weights &lt; resample_threshold <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb367-116"><a href="#cb367-116" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> indices = resample_indices active_n active_weights <span class="kw">in</span></span>
<span id="cb367-117"><a href="#cb367-117" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> new_traces =</span>
<span id="cb367-118"><a href="#cb367-118" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Array</span>.map (<span class="kw">fun</span> j -&gt; traces.(active_indices.(j))) indices <span class="kw">in</span></span>
<span id="cb367-119"><a href="#cb367-119" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> new_weight = <span class="fl">1.0</span> /. <span class="dt">float_of_int</span> active_n <span class="kw">in</span></span>
<span id="cb367-120"><a href="#cb367-120" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Array</span>.iteri (<span class="kw">fun</span> j _ -&gt;</span>
<span id="cb367-121"><a href="#cb367-121" aria-hidden="true" tabindex="-1"></a>            traces.(active_indices.(j)) &lt;- new_traces.(j);</span>
<span id="cb367-122"><a href="#cb367-122" aria-hidden="true" tabindex="-1"></a>            weights.(active_indices.(j)) &lt;- new_weight) indices</span>
<span id="cb367-123"><a href="#cb367-123" aria-hidden="true" tabindex="-1"></a>        <span class="kw">end</span></span>
<span id="cb367-124"><a href="#cb367-124" aria-hidden="true" tabindex="-1"></a>      <span class="kw">end</span></span>
<span id="cb367-125"><a href="#cb367-125" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span>;</span>
<span id="cb367-126"><a href="#cb367-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb367-127"><a href="#cb367-127" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> combined = <span class="dt">Hashtbl</span>.create <span class="dv">16</span> <span class="kw">in</span></span>
<span id="cb367-128"><a href="#cb367-128" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> total = <span class="dt">ref</span> <span class="fl">0.0</span> <span class="kw">in</span></span>
<span id="cb367-129"><a href="#cb367-129" aria-hidden="true" tabindex="-1"></a>    <span class="dt">List</span>.iter (<span class="kw">fun</span> (v, w) -&gt;</span>
<span id="cb367-130"><a href="#cb367-130" aria-hidden="true" tabindex="-1"></a>      total := !total +. w;</span>
<span id="cb367-131"><a href="#cb367-131" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> prev = <span class="kw">try</span> <span class="dt">Hashtbl</span>.find combined v <span class="kw">with</span> <span class="dt">Not_found</span> -&gt; <span class="fl">0.0</span> <span class="kw">in</span></span>
<span id="cb367-132"><a href="#cb367-132" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Hashtbl</span>.replace combined v (prev +. w)) !final_results;</span>
<span id="cb367-133"><a href="#cb367-133" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> !total &gt; <span class="fl">0.0</span> <span class="kw">then</span></span>
<span id="cb367-134"><a href="#cb367-134" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Hashtbl</span>.fold (<span class="kw">fun</span> v w acc -&gt; (v, w /. !total) :: acc) combined []</span>
<span id="cb367-135"><a href="#cb367-135" aria-hidden="true" tabindex="-1"></a>      |&gt; <span class="dt">List</span>.sort (<span class="kw">fun</span> (_, p1) (_, p2) -&gt; <span class="dt">compare</span> p2 p1)</span>
<span id="cb367-136"><a href="#cb367-136" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> []</span>
<span id="cb367-137"><a href="#cb367-137" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>The trace type <code>draw list</code> is simple and type-safe:
<code>DChoose of int</code> stores only the index,
<code>DGaussian of float</code> stores the sampled value. During replay,
we use the stored index to select from the list passed to
<code>Choose</code>. No existential types, no
<code>Obj.magic</code>.</p>
<h3 id="example-sensor-fusion">Example: Sensor Fusion</h3>
<p>Here is an example using both discrete and continuous distributions.
A robot can be in one of several rooms, and we receive noisy sensor
readings of its position:</p>
<div class="sourceCode" id="cb368"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb368-1"><a href="#cb368-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> room = Kitchen | Living | Bedroom | Bathroom</span>
<span id="cb368-2"><a href="#cb368-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb368-3"><a href="#cb368-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> room_center = <span class="kw">function</span></span>
<span id="cb368-4"><a href="#cb368-4" aria-hidden="true" tabindex="-1"></a>  | Kitchen -&gt; (<span class="fl">0.0</span>, <span class="fl">0.0</span>)</span>
<span id="cb368-5"><a href="#cb368-5" aria-hidden="true" tabindex="-1"></a>  | Living -&gt; (<span class="fl">5.0</span>, <span class="fl">0.0</span>)</span>
<span id="cb368-6"><a href="#cb368-6" aria-hidden="true" tabindex="-1"></a>  | Bedroom -&gt; (<span class="fl">0.0</span>, <span class="fl">5.0</span>)</span>
<span id="cb368-7"><a href="#cb368-7" aria-hidden="true" tabindex="-1"></a>  | Bathroom -&gt; (<span class="fl">5.0</span>, <span class="fl">5.0</span>)</span>
<span id="cb368-8"><a href="#cb368-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb368-9"><a href="#cb368-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> sensor_fusion ~observed_x ~observed_y =</span>
<span id="cb368-10"><a href="#cb368-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">open</span> GProb <span class="kw">in</span></span>
<span id="cb368-11"><a href="#cb368-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* Prior: uniform over rooms *)</span></span>
<span id="cb368-12"><a href="#cb368-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> room = choose [Kitchen; Living; Bedroom; Bathroom] <span class="kw">in</span></span>
<span id="cb368-13"><a href="#cb368-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (cx, cy) = room_center room <span class="kw">in</span></span>
<span id="cb368-14"><a href="#cb368-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* Sensor model: noisy reading centered on true position *)</span></span>
<span id="cb368-15"><a href="#cb368-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> sensor_noise = <span class="fl">1.0</span> <span class="kw">in</span></span>
<span id="cb368-16"><a href="#cb368-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> x = gaussian ~mu:cx ~sigma:sensor_noise <span class="kw">in</span></span>
<span id="cb368-17"><a href="#cb368-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> y = gaussian ~mu:cy ~sigma:sensor_noise <span class="kw">in</span></span>
<span id="cb368-18"><a href="#cb368-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* Observe the sensor readings *)</span></span>
<span id="cb368-19"><a href="#cb368-19" aria-hidden="true" tabindex="-1"></a>  observe (normal_pdf observed_x ~mu:x ~sigma:<span class="fl">0.5</span>);</span>
<span id="cb368-20"><a href="#cb368-20" aria-hidden="true" tabindex="-1"></a>  observe (normal_pdf observed_y ~mu:y ~sigma:<span class="fl">0.5</span>);</span>
<span id="cb368-21"><a href="#cb368-21" aria-hidden="true" tabindex="-1"></a>  room</span>
<span id="cb368-22"><a href="#cb368-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb368-23"><a href="#cb368-23" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () =</span>
<span id="cb368-24"><a href="#cb368-24" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Printf</span>.printf <span class="st">&quot;</span><span class="ch">\n</span><span class="st">=== Typed Probabilistic Effects ===</span><span class="ch">\n</span><span class="st">&quot;</span>;</span>
<span id="cb368-25"><a href="#cb368-25" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Printf</span>.printf <span class="st">&quot;Sensor fusion (observed near Living room at 4.8, 0.2):</span><span class="ch">\n</span><span class="st">&quot;</span>;</span>
<span id="cb368-26"><a href="#cb368-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> dist1 = GImportance.infer ~samples:<span class="dv">50000</span> (<span class="kw">fun</span> () -&gt;</span>
<span id="cb368-27"><a href="#cb368-27" aria-hidden="true" tabindex="-1"></a>    sensor_fusion ~observed_x:<span class="fl">4.8</span> ~observed_y:<span class="fl">0.2</span>) <span class="kw">in</span></span>
<span id="cb368-28"><a href="#cb368-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> dist2 = GParticleFilter.infer ~n:<span class="dv">5000</span> (<span class="kw">fun</span> () -&gt;</span>
<span id="cb368-29"><a href="#cb368-29" aria-hidden="true" tabindex="-1"></a>    sensor_fusion ~observed_x:<span class="fl">4.8</span> ~observed_y:<span class="fl">0.2</span>) <span class="kw">in</span></span>
<span id="cb368-30"><a href="#cb368-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> show_room r = <span class="kw">match</span> r <span class="kw">with</span></span>
<span id="cb368-31"><a href="#cb368-31" aria-hidden="true" tabindex="-1"></a>    | Kitchen -&gt; <span class="st">&quot;Kitchen&quot;</span> | Living -&gt; <span class="st">&quot;Living&quot;</span></span>
<span id="cb368-32"><a href="#cb368-32" aria-hidden="true" tabindex="-1"></a>    | Bedroom -&gt; <span class="st">&quot;Bedroom&quot;</span> | Bathroom -&gt; <span class="st">&quot;Bathroom&quot;</span> <span class="kw">in</span></span>
<span id="cb368-33"><a href="#cb368-33" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Printf</span>.printf <span class="st">&quot;  GImportance:     &quot;</span>;</span>
<span id="cb368-34"><a href="#cb368-34" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.iter (<span class="kw">fun</span> (r, p) -&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;%s: %.3f  &quot;</span> (show_room r) p) dist1;</span>
<span id="cb368-35"><a href="#cb368-35" aria-hidden="true" tabindex="-1"></a>  <span class="dt">print_newline</span> ();</span>
<span id="cb368-36"><a href="#cb368-36" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Printf</span>.printf <span class="st">&quot;  GParticleFilter: &quot;</span>;</span>
<span id="cb368-37"><a href="#cb368-37" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.iter (<span class="kw">fun</span> (r, p) -&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;%s: %.3f  &quot;</span> (show_room r) p) dist2;</span>
<span id="cb368-38"><a href="#cb368-38" aria-hidden="true" tabindex="-1"></a>  <span class="dt">print_newline</span> ()</span></code></pre></div>
<h3 id="testing-with-monty-hall">Testing with Monty Hall</h3>
<p>Let us verify that the typed interface produces correct results:</p>
<div class="sourceCode" id="cb369"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb369-1"><a href="#cb369-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> typed_monty_hall ~switch =</span>
<span id="cb369-2"><a href="#cb369-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">open</span> GProb <span class="kw">in</span></span>
<span id="cb369-3"><a href="#cb369-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> doors = [`A; `B; `C] <span class="kw">in</span></span>
<span id="cb369-4"><a href="#cb369-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> prize = choose doors <span class="kw">in</span></span>
<span id="cb369-5"><a href="#cb369-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> chosen = choose doors <span class="kw">in</span></span>
<span id="cb369-6"><a href="#cb369-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> can_open = <span class="dt">List</span>.filter (<span class="kw">fun</span> d -&gt; d &lt;&gt; prize &amp;&amp; d &lt;&gt; chosen) doors <span class="kw">in</span></span>
<span id="cb369-7"><a href="#cb369-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> opened = choose can_open <span class="kw">in</span></span>
<span id="cb369-8"><a href="#cb369-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> final =</span>
<span id="cb369-9"><a href="#cb369-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> switch <span class="kw">then</span></span>
<span id="cb369-10"><a href="#cb369-10" aria-hidden="true" tabindex="-1"></a>      <span class="dt">List</span>.hd (<span class="dt">List</span>.filter (<span class="kw">fun</span> d -&gt; d &lt;&gt; opened &amp;&amp; d &lt;&gt; chosen) doors)</span>
<span id="cb369-11"><a href="#cb369-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> chosen <span class="kw">in</span></span>
<span id="cb369-12"><a href="#cb369-12" aria-hidden="true" tabindex="-1"></a>  final = prize</span>
<span id="cb369-13"><a href="#cb369-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb369-14"><a href="#cb369-14" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () =</span>
<span id="cb369-15"><a href="#cb369-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Printf</span>.printf <span class="st">&quot;</span><span class="ch">\n</span><span class="st">Typed Monty Hall (no switch): &quot;</span>;</span>
<span id="cb369-16"><a href="#cb369-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> dist = GImportance.infer (<span class="kw">fun</span> () -&gt; typed_monty_hall ~switch:<span class="kw">false</span>) <span class="kw">in</span></span>
<span id="cb369-17"><a href="#cb369-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.iter (<span class="kw">fun</span> (win, p) -&gt;</span>
<span id="cb369-18"><a href="#cb369-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Printf</span>.printf <span class="st">&quot;%s: %.3f  &quot;</span> (<span class="kw">if</span> win <span class="kw">then</span> <span class="st">&quot;win&quot;</span> <span class="kw">else</span> <span class="st">&quot;lose&quot;</span>) p) dist;</span>
<span id="cb369-19"><a href="#cb369-19" aria-hidden="true" tabindex="-1"></a>  <span class="dt">print_newline</span> ()</span>
<span id="cb369-20"><a href="#cb369-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb369-21"><a href="#cb369-21" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () =</span>
<span id="cb369-22"><a href="#cb369-22" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Printf</span>.printf <span class="st">&quot;Typed Monty Hall (switch): &quot;</span>;</span>
<span id="cb369-23"><a href="#cb369-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> dist = GImportance.infer (<span class="kw">fun</span> () -&gt; typed_monty_hall ~switch:<span class="kw">true</span>) <span class="kw">in</span></span>
<span id="cb369-24"><a href="#cb369-24" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.iter (<span class="kw">fun</span> (win, p) -&gt;</span>
<span id="cb369-25"><a href="#cb369-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Printf</span>.printf <span class="st">&quot;%s: %.3f  &quot;</span> (<span class="kw">if</span> win <span class="kw">then</span> <span class="st">&quot;win&quot;</span> <span class="kw">else</span> <span class="st">&quot;lose&quot;</span>) p) dist;</span>
<span id="cb369-26"><a href="#cb369-26" aria-hidden="true" tabindex="-1"></a>  <span class="dt">print_newline</span> ()</span>
<span id="cb369-27"><a href="#cb369-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb369-28"><a href="#cb369-28" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () =</span>
<span id="cb369-29"><a href="#cb369-29" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Printf</span>.printf <span class="st">&quot;Typed Monty Hall with Particle Filter (switch): &quot;</span>;</span>
<span id="cb369-30"><a href="#cb369-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> dist = GParticleFilter.infer ~n:<span class="dv">5000</span> (<span class="kw">fun</span> () -&gt;</span>
<span id="cb369-31"><a href="#cb369-31" aria-hidden="true" tabindex="-1"></a>    typed_monty_hall ~switch:<span class="kw">true</span>) <span class="kw">in</span></span>
<span id="cb369-32"><a href="#cb369-32" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.iter (<span class="kw">fun</span> (win, p) -&gt;</span>
<span id="cb369-33"><a href="#cb369-33" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Printf</span>.printf <span class="st">&quot;%s: %.3f  &quot;</span> (<span class="kw">if</span> win <span class="kw">then</span> <span class="st">&quot;win&quot;</span> <span class="kw">else</span> <span class="st">&quot;lose&quot;</span>) p) dist;</span>
<span id="cb369-34"><a href="#cb369-34" aria-hidden="true" tabindex="-1"></a>  <span class="dt">print_newline</span> ()</span></code></pre></div>
<p>The typed interface makes probabilistic programs cleaner and more
expressive while maintaining full type safety. The GADT structure of
OCaml’s effect system ensures that <code>choose</code> returns the right
type at each call site, and the simple index-based trace representation
keeps replay straightforward.</p>
<h2 id="exercises-8">9.13 Exercises</h2>
<p><strong>Exercise 1.</strong> Extend the <code>Threads</code> module
to support timeouts. Add an effect
<code>Timeout : float -&gt; 'a promise -&gt; 'a option Effect.t</code>
that waits for a promise with a timeout, returning <code>None</code> if
the timeout expires. You will need to track elapsed “time” (perhaps
measured in yields).</p>
<p><strong>Exercise 2.</strong> Implement a simple generator/iterator
pattern using effects. Define a
<code>YieldGen : 'a -&gt; unit Effect.t</code> and write: - A function
<code>generate : (unit -&gt; unit) -&gt; 'a Seq.t</code> that converts a
procedure using <code>YieldGen</code> into a sequence. - Use it to
implement a generator for Fibonacci numbers.</p>
<p><strong>Exercise 3.</strong> The <code>State</code> module above only
handles integer state. Generalize it to handle state of any type using a
functor or first-class modules.</p>
<p><strong>Exercise 4.</strong> Write a probabilistic program for the
following scenario: You have two coins, a fair one (50% heads) and a
biased one (70% heads). You pick a coin uniformly at random, flip it
three times, and observe that all three flips came up heads. What is the
probability that you picked the biased coin? Run inference with both
<code>Rejection</code> and <code>Importance</code> and compare the
results and efficiency.</p>
<p><strong>Exercise 5.</strong> Implement a <em>likelihood
weighting</em> version of inference that is between rejection sampling
and full importance sampling. In likelihood weighting, we sample from
the prior for <code>Sample</code> effects but weight by the likelihood
for <code>Observe</code> effects. Compare with rejection sampling on the
burglary example.</p>
<p><strong>Exercise 6.</strong> The particle filter currently pauses at
every <code>Sample</code>, which may cause excessive resampling
overhead. Modify it to pause more selectively: only pause at a
<code>Sample</code> that occurs after at least one <code>Observe</code>
since the last pause. This focuses resampling on points where weights
have actually changed. (Hint: track whether any <code>Observe</code> has
occurred since the last pause.)</p>
<p><strong>Exercise 7.</strong> Optimize the particle filter by storing
the suspended continuation alongside the trace in <code>Paused</code>.
When advancing a particle, first try to resume the stored continuation
directly. If resampling duplicated the particle (i.e., another particle
already consumed the continuation), the resume will raise
<code>Effect.Continuation_already_resumed</code> – catch this and fall
back to replay. This avoids replay overhead for particles that weren’t
duplicated during resampling.</p>
<h1 id="chapter-10-functional-reactive-programming">Chapter 10:
Functional Reactive Programming</h1>
<p>How do we deal with change and interaction in functional programming?
This is one of the most challenging questions in the field, and over the
years programmers have developed increasingly sophisticated answers.
This chapter explores a progression of techniques: we begin with
<em>zippers</em>, a clever data structure for navigating and modifying
positions within larger structures. We then advance to <em>adaptive
programming</em> (also known as incremental computing), which
automatically propagates changes through computations. Finally, we
arrive at <em>Functional Reactive Programming</em> (FRP), a declarative
approach to handling time-varying values and event streams. We conclude
with practical examples including graphical user interfaces.</p>
<p><strong>Recommended Reading:</strong></p>
<ul>
<li><em>“The Zipper”</em> by Gérard Huet – the original paper
introducing zippers</li>
<li><a href="https://en.wikibooks.org/wiki/Haskell/Zippers">Zippers
(Haskell Wikibook)</a> – visual intuition and examples</li>
<li><a href="how-froc-works-a.png"><em>How <code>froc</code>
works</em></a> – a slide-friendly walk through dependency graphs (this
chapter includes the figures)</li>
<li><a href="https://github.com/let-def/lwd"><code>lwd</code>
documentation</a> – lightweight reactive documents for OCaml</li>
<li><a
href="https://github.com/janestreet/incremental"><code>incremental</code>
documentation</a> – Jane Street’s industrial incremental engine</li>
<li><em>“The Haskell School of Expression”</em> by Paul Hudak – a
classic FRP source</li>
<li><em>“Deprecating the Observer Pattern with
<code>Scala.React</code>”</em> by Ingo Maier and Martin Odersky</li>
<li>If you want background on OCaml 5 effect handlers (used in Section
10.7), see the OCaml manual and OCaml 5 release material.</li>
</ul>
<h2 id="zippers">10.1 Zippers</h2>
<p>Imagine you are editing a document, a tree structure, or navigating
through a file system. You need to keep track of where you are, easily
access and modify the data at that location, and move around
efficiently. This is exactly the problem that zippers solve.</p>
<p>Recall from earlier chapters how we defined <em>context types</em>
for datatypes – types that represent a data structure with one of its
elements missing. We discovered that taking the derivative of an
algebraic datatype gives us exactly this context type. Now we will put
this theory to practical use.</p>
<p>Consider binary trees:</p>
<div class="sourceCode" id="cb370"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb370-1"><a href="#cb370-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree = Tip | Node <span class="kw">of</span> <span class="dt">int</span> * btree * btree</span></code></pre></div>
<p>Using our algebraic datatype calculus, where <span
class="math inline">T</span> represents the tree type:</p>
<p><span class="math display">
\begin{matrix}
T &amp; = &amp; 1 + xT^2 \\
\frac{\partial T}{\partial x} &amp; = &amp; 0 + T^2 + 2xT\frac{\partial
T}{\partial x} = TT + 2xT\frac{\partial T}{\partial x}
\end{matrix}
</span></p>
<p>This derivative gives us the context type:</p>
<div class="sourceCode" id="cb371"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb371-1"><a href="#cb371-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree_dir = LeftBranch | RightBranch</span>
<span id="cb371-2"><a href="#cb371-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> btree_deriv =</span>
<span id="cb371-3"><a href="#cb371-3" aria-hidden="true" tabindex="-1"></a>  | Here <span class="kw">of</span> btree * btree</span>
<span id="cb371-4"><a href="#cb371-4" aria-hidden="true" tabindex="-1"></a>  | Below <span class="kw">of</span> btree_dir * <span class="dt">int</span> * btree * btree_deriv</span></code></pre></div>
<p>The key insight is that <strong>Location = context +
subtree</strong>! A location in a data structure consists of two parts:
the context (everything around the focused element) and the subtree
(what we are currently looking at).</p>
<p>However, there is a problem with the representation above: we cannot
easily move the location if <code>Here</code> is at the bottom of our
context representation. Think about it: if we want to move up from our
current position, we need to access the innermost layer of the context
first. The part closest to the location should be on top, not buried at
the bottom.</p>
<h3 id="revisiting-the-equations">Revisiting the Equations</h3>
<p>Let us revisit the equations for trees and lists:</p>
<p><span class="math display">
\begin{matrix}
T &amp; = &amp; 1 + xT^2 \\
\frac{\partial T}{\partial x} &amp; = &amp; 0 + T^2 + 2xT\frac{\partial
T}{\partial x} \\
\frac{\partial T}{\partial x} &amp; = &amp; \frac{T^2}{1 - 2xT} \\
L(y) &amp; = &amp; 1 + yL(y) \\
L(y) &amp; = &amp; \frac{1}{1 - y} \\
\frac{\partial T}{\partial x} &amp; = &amp; T^2 L(2xT)
\end{matrix}
</span></p>
<p>This algebraic manipulation reveals something beautiful: the context
can be stored as a list with the root as the last node. The <span
class="math inline">L(2xT)</span> factor tells us that we have a list
where each element consists of <span class="math inline">2xT</span> –
that is, a direction indicator (left or right, hence the factor of 2),
the element at that node (<span class="math inline">x</span>), and the
sibling subtree (<span class="math inline">T</span>).</p>
<p>It does not matter whether we use built-in OCaml lists or define a
custom type with <code>Above</code> and <code>Root</code> variants – the
structure is the same.</p>
<p>In practice, contexts of subtrees are more useful than contexts of
single elements. Rather than tracking where a single value lives, we
track the position of an entire subtree within the larger structure:</p>
<div class="sourceCode" id="cb372"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb372-1"><a href="#cb372-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a tree = Tip | Node <span class="kw">of</span> &#39;a tree * &#39;a * &#39;a tree</span>
<span id="cb372-2"><a href="#cb372-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> tree_dir = Left_br | Right_br</span>
<span id="cb372-3"><a href="#cb372-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a context = (tree_dir * &#39;a * &#39;a tree) <span class="dt">list</span></span>
<span id="cb372-4"><a href="#cb372-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a location = {sub: &#39;a tree; ctx: &#39;a context}</span>
<span id="cb372-5"><a href="#cb372-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb372-6"><a href="#cb372-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> access {sub; _} = sub       <span class="co">(* Get the current subtree *)</span></span>
<span id="cb372-7"><a href="#cb372-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> change {ctx; _} sub = {sub; ctx}  <span class="co">(* Replace the subtree, keep context *)</span></span>
<span id="cb372-8"><a href="#cb372-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> modify f {sub; ctx} = {sub = f sub; ctx}  <span class="co">(* Transform the subtree *)</span></span></code></pre></div>
<p>There is a wonderful visual intuition for zippers: imagine taking a
tree and pinning it at one of its nodes, then letting it hang down under
gravity. The pinned node becomes “the current focus,” and all the other
parts of the tree dangle from it. This mental picture helps understand
how movement works: moving to a child means letting a new node become
the pin point, with the old parent now hanging above. For excellent
visualizations, see <a
href="https://en.wikibooks.org/wiki/Haskell/Zippers">Zippers (Haskell
Wikibook)</a>.</p>
<h3 id="moving-around">Moving Around</h3>
<p>Navigation functions allow us to traverse the structure. Each
movement operation restructures the zipper: what was context becomes
part of the subtree, and vice versa. Watch how ascending rebuilds a
parent node from the context, while descending breaks apart a node to
create new context:</p>
<div class="sourceCode" id="cb373"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb373-1"><a href="#cb373-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ascend loc =</span>
<span id="cb373-2"><a href="#cb373-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> loc.ctx <span class="kw">with</span></span>
<span id="cb373-3"><a href="#cb373-3" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; loc  <span class="co">(* At root already, or raise exception *)</span></span>
<span id="cb373-4"><a href="#cb373-4" aria-hidden="true" tabindex="-1"></a>  | (Left_br, n, l) :: up_ctx -&gt;</span>
<span id="cb373-5"><a href="#cb373-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* We were in the right subtree; rebuild the parent node *)</span></span>
<span id="cb373-6"><a href="#cb373-6" aria-hidden="true" tabindex="-1"></a>    {sub = Node (l, n, loc.sub); ctx = up_ctx}</span>
<span id="cb373-7"><a href="#cb373-7" aria-hidden="true" tabindex="-1"></a>  | (Right_br, n, r) :: up_ctx -&gt;</span>
<span id="cb373-8"><a href="#cb373-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* We were in the left subtree; rebuild the parent node *)</span></span>
<span id="cb373-9"><a href="#cb373-9" aria-hidden="true" tabindex="-1"></a>    {sub = Node (loc.sub, n, r); ctx = up_ctx}</span>
<span id="cb373-10"><a href="#cb373-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb373-11"><a href="#cb373-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> desc_left loc =</span>
<span id="cb373-12"><a href="#cb373-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> loc.sub <span class="kw">with</span></span>
<span id="cb373-13"><a href="#cb373-13" aria-hidden="true" tabindex="-1"></a>  | Tip -&gt; loc  <span class="co">(* Cannot descend into a tip, or raise exception *)</span></span>
<span id="cb373-14"><a href="#cb373-14" aria-hidden="true" tabindex="-1"></a>  | Node (l, n, r) -&gt;</span>
<span id="cb373-15"><a href="#cb373-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* Focus on left child; right sibling goes into context *)</span></span>
<span id="cb373-16"><a href="#cb373-16" aria-hidden="true" tabindex="-1"></a>    {sub = l; ctx = (Right_br, n, r) :: loc.ctx}</span>
<span id="cb373-17"><a href="#cb373-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb373-18"><a href="#cb373-18" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> desc_right loc =</span>
<span id="cb373-19"><a href="#cb373-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> loc.sub <span class="kw">with</span></span>
<span id="cb373-20"><a href="#cb373-20" aria-hidden="true" tabindex="-1"></a>  | Tip -&gt; loc  <span class="co">(* Cannot descend into a tip, or raise exception *)</span></span>
<span id="cb373-21"><a href="#cb373-21" aria-hidden="true" tabindex="-1"></a>  | Node (l, n, r) -&gt;</span>
<span id="cb373-22"><a href="#cb373-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* Focus on right child; left sibling goes into context *)</span></span>
<span id="cb373-23"><a href="#cb373-23" aria-hidden="true" tabindex="-1"></a>    {sub = r; ctx = (Left_br, n, l) :: loc.ctx}</span></code></pre></div>
<h3 id="trees-with-arbitrary-branching">Trees with Arbitrary
Branching</h3>
<p>Following <em>The Zipper</em> by Gerard Huet, let us look at a tree
with an arbitrary number of branches. This is particularly useful for
representing document structures where a group can contain any number of
children:</p>
<div class="sourceCode" id="cb374"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb374-1"><a href="#cb374-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> doc = Text <span class="kw">of</span> <span class="dt">string</span> | Line | Group <span class="kw">of</span> doc <span class="dt">list</span></span>
<span id="cb374-2"><a href="#cb374-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> context = (doc <span class="dt">list</span> * doc <span class="dt">list</span>) <span class="dt">list</span>  <span class="co">(* left siblings, right siblings *)</span></span>
<span id="cb374-3"><a href="#cb374-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> location = {sub: doc; ctx: context}</span></code></pre></div>
<p>In this design, the context at each level stores two lists: the
siblings to the left of our current position (in reverse order for
efficient access) and the siblings to the right. This allows us to move
not just up and down, but also left and right among siblings.</p>
<p>The navigation functions for this more complex structure show how we
reconstruct the parent when going up, and how we split the sibling list
when going down:</p>
<div class="sourceCode" id="cb375"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb375-1"><a href="#cb375-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> go_up loc =</span>
<span id="cb375-2"><a href="#cb375-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> loc.ctx <span class="kw">with</span></span>
<span id="cb375-3"><a href="#cb375-3" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; <span class="dt">invalid_arg</span> <span class="st">&quot;go_up: at top&quot;</span></span>
<span id="cb375-4"><a href="#cb375-4" aria-hidden="true" tabindex="-1"></a>  | (left, right) :: up_ctx -&gt;</span>
<span id="cb375-5"><a href="#cb375-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* Reconstruct the Group: reverse left siblings, add current, then right *)</span></span>
<span id="cb375-6"><a href="#cb375-6" aria-hidden="true" tabindex="-1"></a>    {sub = Group (<span class="dt">List</span>.rev left @ loc.sub :: right); ctx = up_ctx}</span>
<span id="cb375-7"><a href="#cb375-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb375-8"><a href="#cb375-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> go_left loc =</span>
<span id="cb375-9"><a href="#cb375-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> loc.ctx <span class="kw">with</span></span>
<span id="cb375-10"><a href="#cb375-10" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; <span class="dt">invalid_arg</span> <span class="st">&quot;go_left: at top&quot;</span></span>
<span id="cb375-11"><a href="#cb375-11" aria-hidden="true" tabindex="-1"></a>  | (l :: left, right) :: up_ctx -&gt;</span>
<span id="cb375-12"><a href="#cb375-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* Move to left sibling; current element moves to right siblings *)</span></span>
<span id="cb375-13"><a href="#cb375-13" aria-hidden="true" tabindex="-1"></a>    {sub = l; ctx = (left, loc.sub :: right) :: up_ctx}</span>
<span id="cb375-14"><a href="#cb375-14" aria-hidden="true" tabindex="-1"></a>  | ([], _) :: _ -&gt; <span class="dt">invalid_arg</span> <span class="st">&quot;go_left: at first&quot;</span></span>
<span id="cb375-15"><a href="#cb375-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb375-16"><a href="#cb375-16" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> go_right loc =</span>
<span id="cb375-17"><a href="#cb375-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> loc.ctx <span class="kw">with</span></span>
<span id="cb375-18"><a href="#cb375-18" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; <span class="dt">invalid_arg</span> <span class="st">&quot;go_right: at top&quot;</span></span>
<span id="cb375-19"><a href="#cb375-19" aria-hidden="true" tabindex="-1"></a>  | (left, r :: right) :: up_ctx -&gt;</span>
<span id="cb375-20"><a href="#cb375-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* Move to right sibling; current element moves to left siblings *)</span></span>
<span id="cb375-21"><a href="#cb375-21" aria-hidden="true" tabindex="-1"></a>    {sub = r; ctx = (loc.sub :: left, right) :: up_ctx}</span>
<span id="cb375-22"><a href="#cb375-22" aria-hidden="true" tabindex="-1"></a>  | (_, []) :: _ -&gt; <span class="dt">invalid_arg</span> <span class="st">&quot;go_right: at last&quot;</span></span>
<span id="cb375-23"><a href="#cb375-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb375-24"><a href="#cb375-24" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> go_down loc =</span>
<span id="cb375-25"><a href="#cb375-25" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* Go to the first (i.e. leftmost) subdocument *)</span></span>
<span id="cb375-26"><a href="#cb375-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> loc.sub <span class="kw">with</span></span>
<span id="cb375-27"><a href="#cb375-27" aria-hidden="true" tabindex="-1"></a>  | Text _ -&gt; <span class="dt">invalid_arg</span> <span class="st">&quot;go_down: at text&quot;</span></span>
<span id="cb375-28"><a href="#cb375-28" aria-hidden="true" tabindex="-1"></a>  | Line -&gt; <span class="dt">invalid_arg</span> <span class="st">&quot;go_down: at line&quot;</span></span>
<span id="cb375-29"><a href="#cb375-29" aria-hidden="true" tabindex="-1"></a>  | Group [] -&gt; <span class="dt">invalid_arg</span> <span class="st">&quot;go_down: at empty&quot;</span></span>
<span id="cb375-30"><a href="#cb375-30" aria-hidden="true" tabindex="-1"></a>  | Group (doc :: docs) -&gt;</span>
<span id="cb375-31"><a href="#cb375-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* First child becomes focus; rest become right siblings *)</span></span>
<span id="cb375-32"><a href="#cb375-32" aria-hidden="true" tabindex="-1"></a>    {sub = doc; ctx = ([], docs) :: loc.ctx}</span></code></pre></div>
<h2 id="example-context-rewriting">10.2 Example: Context Rewriting</h2>
<p>Let us put zippers to work on a real problem. Imagine a friend
working on string theory asks us for help simplifying equations. The
task is to pull out particular subexpressions as far to the left as
possible, while changing the whole expression as little as possible.
This kind of algebraic manipulation is common in symbolic
computation.</p>
<p>We can illustrate our algorithm using mathematical notation. Let: -
<span class="math inline">x</span> be the thing we pull out - <span
class="math inline">C[e]</span> and <span
class="math inline">D[e]</span> be big expressions with subexpression
<span class="math inline">e</span> - operator <span
class="math inline">\circ</span> stand for one of: <span
class="math inline">*, +</span></p>
<p>The rewriting rules are:</p>
<p><span class="math display">
\begin{matrix}
D[(C[x] \circ e_1) \circ e_2] &amp; \Rightarrow &amp; D[C[x] \circ (e_1
\circ e_2)] \\
D[e_2 \circ (C[x] \circ e_1)] &amp; \Rightarrow &amp; D[C[x] \circ (e_1
\circ e_2)] \\
D[(C[x] + e_1) e_2] &amp; \Rightarrow &amp; D[C[x] e_2 + e_1 e_2] \\
D[e_2 (C[x] + e_1)] &amp; \Rightarrow &amp; D[C[x] e_2 + e_1 e_2] \\
D[e \circ C[x]] &amp; \Rightarrow &amp; D[C[x] \circ e]
\end{matrix}
</span></p>
<p>These rules encode the algebraic properties we need: associativity
(first two rules), distributivity of multiplication over addition (third
and fourth rules), and commutativity (last rule, which lets us swap
operands). The key insight is that we can implement these
transformations efficiently using a zipper, since each rule only needs
to look at a small neighborhood of the current position.</p>
<p>First, the groundwork. We define expression types and a zipper for
navigating them:</p>
<div class="sourceCode" id="cb376"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb376-1"><a href="#cb376-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> op = Add | Mul</span>
<span id="cb376-2"><a href="#cb376-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> expr = Val <span class="kw">of</span> <span class="dt">int</span> | Var <span class="kw">of</span> <span class="dt">string</span> | App <span class="kw">of</span> expr * op * expr</span>
<span id="cb376-3"><a href="#cb376-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> expr_dir = Left_arg | Right_arg</span>
<span id="cb376-4"><a href="#cb376-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> context = (expr_dir * op * expr) <span class="dt">list</span></span>
<span id="cb376-5"><a href="#cb376-5" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> location = {sub: expr; ctx: context}</span></code></pre></div>
<p>To locate the subexpression described by predicate <code>p</code>, we
search the expression tree and build up the context as we go. Notice
that we build the context in reverse order during the search, then
reverse it at the end so the innermost context comes first (as required
for efficient navigation):</p>
<div class="sourceCode" id="cb377"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb377-1"><a href="#cb377-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> find_aux p e =</span>
<span id="cb377-2"><a href="#cb377-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> p e <span class="kw">then</span> <span class="dt">Some</span> (e, [])</span>
<span id="cb377-3"><a href="#cb377-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> <span class="kw">match</span> e <span class="kw">with</span></span>
<span id="cb377-4"><a href="#cb377-4" aria-hidden="true" tabindex="-1"></a>  | Val _ | Var _ -&gt; <span class="dt">None</span></span>
<span id="cb377-5"><a href="#cb377-5" aria-hidden="true" tabindex="-1"></a>  | App (l, op, r) -&gt;</span>
<span id="cb377-6"><a href="#cb377-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> find_aux p l <span class="kw">with</span></span>
<span id="cb377-7"><a href="#cb377-7" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (sub, up_ctx) -&gt;</span>
<span id="cb377-8"><a href="#cb377-8" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Some</span> (sub, (Right_arg, op, r) :: up_ctx)</span>
<span id="cb377-9"><a href="#cb377-9" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">None</span> -&gt;</span>
<span id="cb377-10"><a href="#cb377-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">match</span> find_aux p r <span class="kw">with</span></span>
<span id="cb377-11"><a href="#cb377-11" aria-hidden="true" tabindex="-1"></a>      | <span class="dt">Some</span> (sub, up_ctx) -&gt;</span>
<span id="cb377-12"><a href="#cb377-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Some</span> (sub, (Left_arg, op, l) :: up_ctx)</span>
<span id="cb377-13"><a href="#cb377-13" aria-hidden="true" tabindex="-1"></a>      | <span class="dt">None</span> -&gt; <span class="dt">None</span></span>
<span id="cb377-14"><a href="#cb377-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb377-15"><a href="#cb377-15" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> find p e =</span>
<span id="cb377-16"><a href="#cb377-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> find_aux p e <span class="kw">with</span></span>
<span id="cb377-17"><a href="#cb377-17" aria-hidden="true" tabindex="-1"></a>  | <span class="dt">None</span> -&gt; <span class="dt">None</span></span>
<span id="cb377-18"><a href="#cb377-18" aria-hidden="true" tabindex="-1"></a>  | <span class="dt">Some</span> (sub, ctx) -&gt; <span class="dt">Some</span> {sub; ctx = <span class="dt">List</span>.rev ctx}</span></code></pre></div>
<p>Now we can implement the pull-out transformation. This is where the
zipper shines: we pattern match on the context to decide which rewriting
rule to apply, then modify the context directly. The function
recursively moves the target subexpression outward until it reaches the
root:</p>
<div class="sourceCode" id="cb378"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb378-1"><a href="#cb378-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> pull_out loc =</span>
<span id="cb378-2"><a href="#cb378-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> loc.ctx <span class="kw">with</span></span>
<span id="cb378-3"><a href="#cb378-3" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; loc  <span class="co">(* Done: reached the root *)</span></span>
<span id="cb378-4"><a href="#cb378-4" aria-hidden="true" tabindex="-1"></a>  | (Left_arg, op, l) :: up_ctx -&gt;</span>
<span id="cb378-5"><a href="#cb378-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* D[e . C[x]] =&gt; D[C[x] . e] -- use commutativity to swap sides *)</span></span>
<span id="cb378-6"><a href="#cb378-6" aria-hidden="true" tabindex="-1"></a>    pull_out {loc <span class="kw">with</span> ctx = (Right_arg, op, l) :: up_ctx}</span>
<span id="cb378-7"><a href="#cb378-7" aria-hidden="true" tabindex="-1"></a>  | (Right_arg, op1, e1) :: (_, op2, e2) :: up_ctx</span>
<span id="cb378-8"><a href="#cb378-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">when</span> op1 = op2 -&gt;</span>
<span id="cb378-9"><a href="#cb378-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* D[(C[x] . e1) . e2] =&gt; D[C[x] . (e1 . e2)] -- associativity *)</span></span>
<span id="cb378-10"><a href="#cb378-10" aria-hidden="true" tabindex="-1"></a>    pull_out {loc <span class="kw">with</span> ctx = (Right_arg, op1, App(e1, op1, e2)) :: up_ctx}</span>
<span id="cb378-11"><a href="#cb378-11" aria-hidden="true" tabindex="-1"></a>  | (Right_arg, Add, e1) :: (_, Mul, e2) :: up_ctx -&gt;</span>
<span id="cb378-12"><a href="#cb378-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* D[(C[x] + e1) * e2] =&gt; D[C[x] * e2 + e1 * e2] -- distributivity *)</span></span>
<span id="cb378-13"><a href="#cb378-13" aria-hidden="true" tabindex="-1"></a>    pull_out {loc <span class="kw">with</span> ctx =</span>
<span id="cb378-14"><a href="#cb378-14" aria-hidden="true" tabindex="-1"></a>        (Right_arg, Mul, e2) ::</span>
<span id="cb378-15"><a href="#cb378-15" aria-hidden="true" tabindex="-1"></a>          (Right_arg, Add, App(e1, Mul, e2)) :: up_ctx}</span>
<span id="cb378-16"><a href="#cb378-16" aria-hidden="true" tabindex="-1"></a>  | (Right_arg, op, r) :: up_ctx -&gt;</span>
<span id="cb378-17"><a href="#cb378-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* No rule applies: move up by incorporating current context *)</span></span>
<span id="cb378-18"><a href="#cb378-18" aria-hidden="true" tabindex="-1"></a>    pull_out {sub = App(loc.sub, op, r); ctx = up_ctx}</span></code></pre></div>
<p>Since we assume operators are commutative, we can ignore the
direction for the second piece of context above – both
<code>(C[x] . e1) . e2</code> and <code>e2 . (C[x] . e1)</code> are
handled by the same associativity rule.</p>
<p>Let us test the implementation with a concrete example:</p>
<div class="sourceCode" id="cb379"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb379-1"><a href="#cb379-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> expr_to_string = <span class="kw">function</span></span>
<span id="cb379-2"><a href="#cb379-2" aria-hidden="true" tabindex="-1"></a>  | Val n -&gt; <span class="dt">string_of_int</span> n</span>
<span id="cb379-3"><a href="#cb379-3" aria-hidden="true" tabindex="-1"></a>  | Var v -&gt; v</span>
<span id="cb379-4"><a href="#cb379-4" aria-hidden="true" tabindex="-1"></a>  | App (l, Add, r) -&gt; <span class="st">&quot;(&quot;</span> ^ expr_to_string l ^ <span class="st">&quot;+&quot;</span> ^ expr_to_string r ^ <span class="st">&quot;)&quot;</span></span>
<span id="cb379-5"><a href="#cb379-5" aria-hidden="true" tabindex="-1"></a>  | App (l, Mul, r) -&gt; <span class="st">&quot;(&quot;</span> ^ expr_to_string l ^ <span class="st">&quot;*&quot;</span> ^ expr_to_string r ^ <span class="st">&quot;)&quot;</span></span>
<span id="cb379-6"><a href="#cb379-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb379-7"><a href="#cb379-7" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> ExprOps = <span class="kw">struct</span></span>
<span id="cb379-8"><a href="#cb379-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (+) a b = App (a, Add, b)</span>
<span id="cb379-9"><a href="#cb379-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ( * ) a b = App (a, Mul, b)</span>
<span id="cb379-10"><a href="#cb379-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (!) a = Val a</span>
<span id="cb379-11"><a href="#cb379-11" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb379-12"><a href="#cb379-12" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = Var <span class="st">&quot;x&quot;</span></span>
<span id="cb379-13"><a href="#cb379-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> y = Var <span class="st">&quot;y&quot;</span></span>
<span id="cb379-14"><a href="#cb379-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb379-15"><a href="#cb379-15" aria-hidden="true" tabindex="-1"></a><span class="co">(* Original: 5 + y * (7 + x) * (3 + y) -- we want to pull x to the front *)</span></span>
<span id="cb379-16"><a href="#cb379-16" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ex = ExprOps.(!<span class="dv">5</span> + y * (!<span class="dv">7</span> + x) * (!<span class="dv">3</span> + y))</span>
<span id="cb379-17"><a href="#cb379-17" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> loc = find (<span class="kw">fun</span> e -&gt; e = x) ex</span>
<span id="cb379-18"><a href="#cb379-18" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> sol =</span>
<span id="cb379-19"><a href="#cb379-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> loc <span class="kw">with</span></span>
<span id="cb379-20"><a href="#cb379-20" aria-hidden="true" tabindex="-1"></a>  | <span class="dt">None</span> -&gt; <span class="dt">raise</span> <span class="dt">Not_found</span></span>
<span id="cb379-21"><a href="#cb379-21" aria-hidden="true" tabindex="-1"></a>  | <span class="dt">Some</span> loc -&gt; pull_out loc</span>
<span id="cb379-22"><a href="#cb379-22" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">result</span> = expr_to_string sol.sub</span>
<span id="cb379-23"><a href="#cb379-23" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () = <span class="kw">assert</span> (<span class="dt">result</span> = <span class="st">&quot;(((x*y)*(3+y))+(((7*y)*(3+y))+5))&quot;</span>)</span></code></pre></div>
<p>The transformation successfully pulled <code>x</code> from deep
inside the expression to the outermost left position. For best results
on complex expressions, we can iterate the <code>pull_out</code>
function until a fixpoint is reached, ensuring all instances of the
target are pulled out as far as possible.</p>
<h2 id="adaptive-programming-incremental-computing">10.3 Adaptive
Programming (Incremental Computing)</h2>
<p>Zippers gave us a way to make <em>local</em> edits to a large
structure while keeping enough context to put the structure back
together. But they do not, by themselves, solve a more global
problem:</p>
<blockquote>
<p>if we change an input, how do we update <em>all</em> the derived
results efficiently, without rewriting the whole program to “thread the
context around”?</p>
</blockquote>
<p><strong>Incremental computing</strong> (also called
<strong>self-adjusting computation</strong> or <strong>adaptive
programming</strong>) answers this by letting us write code in a direct
style while the runtime system records <em>dependencies</em> between
intermediate results. When an input changes, only the part of the
computation graph that depends on that input is recomputed; everything
else is reused.</p>
<h3 id="a-mental-model-traces-and-change-propagation">A Mental Model:
Traces and Change Propagation</h3>
<p>Think of an incremental program as building a directed acyclic graph
(DAG):</p>
<ul>
<li><strong>Leaves</strong> are <em>changeable inputs</em> (mutable
cells).</li>
<li><strong>Internal nodes</strong> are <em>pure computations</em>
(maps, combinations, binds).</li>
<li><strong>Roots</strong> are <em>observers</em> (the results we care
to keep up-to-date).</li>
</ul>
<p>When a leaf changes, the system does two logically separate
things:</p>
<ol type="1">
<li><strong>Invalidate</strong> cached results that (transitively)
depend on the changed leaf.</li>
<li><strong>Recompute</strong> just enough of the graph to bring the
observed roots back to a consistent state.</li>
</ol>
<p>Different libraries make different choices about <em>when</em>
recomputation happens (eager stabilization vs. lazy sampling),
<em>how</em> they avoid redundant work (timestamps vs. boolean dirty
flags), and <em>what</em> extra guarantees they provide (cutoffs,
resource lifetimes, “no glitches”).</p>
<h3 id="the-core-idea-write-normal-code-get-a-dag">The Core Idea: Write
Normal Code, Get a DAG</h3>
<p>Consider a simple expression:</p>
<pre><code>u = v / w + x * y + z</code></pre>
<p>As ordinary code, this just computes a number. As an
<em>incremental</em> computation, it implicitly defines a dependency
graph:</p>
<ul>
<li><code>n0 = v / w</code></li>
<li><code>n1 = x * y</code></li>
<li><code>n2 = n0 + n1</code></li>
<li><code>u  = n2 + z</code></li>
</ul>
<p>When <code>v</code> changes, we should update <code>n0</code>, then
<code>n2</code>, then <code>u</code>. When <code>z</code> changes, we
should update only <code>u</code>. The point of incremental computing is
that you should not have to maintain this update order yourself.</p>
<p>Most libraries expose a “lifted arithmetic” style: you still write
expressions like <code>v / w + x * y + z</code>, but the operators build
graph nodes rather than eagerly computing.</p>
<h3 id="a-worked-picture-how-froc-works">A Worked Picture: <em>How
<code>froc</code> Works</em></h3>
<p>Jacob Donham’s short note <em>How <code>froc</code> works</em>
explains incremental computation using pictures of a dependency graph
(the <code>froc</code> library is historically important, but in this
book we will use modern OCaml libraries in the same design space).</p>
<p>The expression <code>u = v / w + x * y + z</code> as a dependency
graph:</p>
<p><img src="how-froc-works-a.png" style="width:75.0%" /></p>
<p>The same graph after memoizing intermediate results:</p>
<p><img src="how-froc-works-b.png" style="width:75.0%" /></p>
<p>If multiple inputs change, the engine must update nodes in a safe
order (a topological schedule). The picture uses grey numbers to
indicate a recomputation order:</p>
<p><img src="how-froc-works-c.png" style="width:75.0%" /></p>
<p>The subtle case is <strong>dynamic dependency</strong> (a
<code>bind</code>/<code>join</code> that can choose a different
subgraph). If we recompute “everything that ever depended on
<code>x</code>”, we may attempt to update a branch that is no longer
relevant:</p>
<p><img src="how-froc-works-d.png" style="width:75.0%" /></p>
<p>One approach (as described in the note) is to track not just a single
timestamp but an <em>interval</em> for a node’s computation, detach the
old subgraph interval when a dynamic node is recomputed, and reattach
only what the new branch actually needs:</p>
<p><img src="how-froc-works-e.png" style="width:75.0%" /></p>
<p>Two practical lessons fall out of this:</p>
<ul>
<li><strong>Prefer applicative combinators</strong> (<code>map</code>,
<code>map2</code>, <code>map3</code>, …) for static dependency
structure.</li>
<li>Use <strong>dynamic dependency</strong>
(<code>bind</code>/<code>join</code>) only when the structure truly
depends on values (conditionals, switching, dynamic collections).</li>
</ul>
<h3 id="conditional-dependencies-dynamic-graphs">Conditional
Dependencies (Dynamic Graphs)</h3>
<p>The most interesting case is when the dependency graph itself depends
on data:</p>
<div class="sourceCode" id="cb381"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb381-1"><a href="#cb381-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Pseudocode: the dependencies of [out] depend on [use_fast]. *)</span></span>
<span id="cb381-2"><a href="#cb381-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> out =</span>
<span id="cb381-3"><a href="#cb381-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> use_fast <span class="kw">then</span> fast_path <span class="dt">input</span></span>
<span id="cb381-4"><a href="#cb381-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> slow_path <span class="dt">input</span></span></code></pre></div>
<p>If <code>use_fast</code> flips, we must stop depending on the old
branch and start depending on the new one. Incremental systems support
this with a <em>dynamic dependency</em> operator:</p>
<ul>
<li><code>bind</code> / <code>join</code> / <code>switch</code> (names
vary): pick which subgraph is active <em>based on a value</em>.</li>
</ul>
<p>Operationally, this means: detach edges to the old branch, attach
edges to the new branch, then recompute along the newly relevant
dependencies. This is also where “glitch freedom” matters: we want each
observed root to be updated as if we recomputed in a topological order
on a single, consistent snapshot of inputs.</p>
<p>Here is the classic pitfall:</p>
<div class="sourceCode" id="cb382"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb382-1"><a href="#cb382-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Pseudocode: [x] is a changeable input. *)</span></span>
<span id="cb382-2"><a href="#cb382-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> b  = map x ~f:(<span class="kw">fun</span> x -&gt; x = <span class="dv">0</span>)</span>
<span id="cb382-3"><a href="#cb382-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> n0 = map x ~f:(<span class="kw">fun</span> x -&gt; <span class="dv">100</span> / x)</span>
<span id="cb382-4"><a href="#cb382-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> y  = bind b ~f:(<span class="kw">fun</span> b -&gt; <span class="kw">if</span> b <span class="kw">then</span> return <span class="dv">0</span> <span class="kw">else</span> n0)</span></code></pre></div>
<p>If we naïvely “recompute everything that ever depended on
<code>x</code>”, then changing <code>x</code> to <code>0</code> would
try to compute <code>100 / 0</code> even though the branch containing
<code>n0</code> is no longer relevant. Dynamic dependency operators
solve this by making <em>reachability</em> part of correctness: when the
branch switches, the old subgraph becomes inactive and stops being
demanded by observers.</p>
<h3 id="two-modern-ocaml-libraries-lwd-and-incremental">Two Modern OCaml
Libraries: <code>lwd</code> and <code>incremental</code></h3>
<p>Many ideas above can be packaged behind a small “conceptual API”:</p>
<div class="sourceCode" id="cb383"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb383-1"><a href="#cb383-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">type</span> INCREMENTAL = <span class="kw">sig</span></span>
<span id="cb383-2"><a href="#cb383-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a t</span>
<span id="cb383-3"><a href="#cb383-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a var</span>
<span id="cb383-4"><a href="#cb383-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a obs</span>
<span id="cb383-5"><a href="#cb383-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb383-6"><a href="#cb383-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> var : &#39;a -&gt; &#39;a var</span>
<span id="cb383-7"><a href="#cb383-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> get : &#39;a var -&gt; &#39;a t</span>
<span id="cb383-8"><a href="#cb383-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> set : &#39;a var -&gt; &#39;a -&gt; <span class="dt">unit</span></span>
<span id="cb383-9"><a href="#cb383-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb383-10"><a href="#cb383-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> map : &#39;a t -&gt; f:(&#39;a -&gt; &#39;b) -&gt; &#39;b t</span>
<span id="cb383-11"><a href="#cb383-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> map2 : &#39;a t -&gt; &#39;b t -&gt; f:(&#39;a -&gt; &#39;b -&gt; &#39;c) -&gt; &#39;c t</span>
<span id="cb383-12"><a href="#cb383-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> bind : &#39;a t -&gt; f:(&#39;a -&gt; &#39;b t) -&gt; &#39;b t</span>
<span id="cb383-13"><a href="#cb383-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb383-14"><a href="#cb383-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> observe : &#39;a t -&gt; &#39;a obs</span>
<span id="cb383-15"><a href="#cb383-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> sample : &#39;a obs -&gt; &#39;a</span>
<span id="cb383-16"><a href="#cb383-16" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>OCaml has at least two widely used implementations of this idea, with
different priorities.</p>
<h4 id="lwd-lightweight-reactive-documents"><code>Lwd</code>
(Lightweight Reactive Documents)</h4>
<p><code>Lwd</code> is designed around building <em>reactive trees</em>
(most famously, UI trees). Its model is <strong>invalidate eagerly,
recompute lazily</strong>:</p>
<ul>
<li><code>Lwd.var</code> / <code>Lwd.set</code> mutate leaves and
immediately invalidate dependent nodes.</li>
<li>Values are recomputed on demand when you <code>Lwd.sample</code> a
<strong>root</strong> (an observer).</li>
<li>It tracks <em>liveness</em>: nodes not reachable from any root are
released, and <code>Lwd.prim</code> supports
<code>acquire</code>/<code>release</code> for resource lifetimes
(subscriptions, DOM nodes, etc.).</li>
</ul>
<div class="sourceCode" id="cb384"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb384-1"><a href="#cb384-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Using Lwd as an incremental engine *)</span></span>
<span id="cb384-2"><a href="#cb384-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> a = Lwd.var <span class="dv">10</span></span>
<span id="cb384-3"><a href="#cb384-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> b = Lwd.var <span class="dv">32</span></span>
<span id="cb384-4"><a href="#cb384-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb384-5"><a href="#cb384-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> sum : <span class="dt">int</span> Lwd.t =</span>
<span id="cb384-6"><a href="#cb384-6" aria-hidden="true" tabindex="-1"></a>  Lwd.map2 (Lwd.get a) (Lwd.get b) ~f:( + )</span>
<span id="cb384-7"><a href="#cb384-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb384-8"><a href="#cb384-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> root = Lwd.observe sum</span>
<span id="cb384-9"><a href="#cb384-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> now () = Lwd.quick_sample root</span>
<span id="cb384-10"><a href="#cb384-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb384-11"><a href="#cb384-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () =</span>
<span id="cb384-12"><a href="#cb384-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s0 = now () <span class="kw">in</span>  <span class="co">(* 42 *)</span></span>
<span id="cb384-13"><a href="#cb384-13" aria-hidden="true" tabindex="-1"></a>  Lwd.set a <span class="dv">11</span>;</span>
<span id="cb384-14"><a href="#cb384-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s1 = now () <span class="kw">in</span>  <span class="co">(* 43 *)</span></span>
<span id="cb384-15"><a href="#cb384-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ignore</span> (s0, s1)</span></code></pre></div>
<h4 id="incremental-jane-street"><code>Incremental</code> (Jane
Street)</h4>
<p><code>Incremental</code> is a general-purpose industrial incremental
engine. Its model is <strong>batch updates into a stabilization
pass</strong>:</p>
<ul>
<li><code>Incr.Var.set</code> records changes to leaves.</li>
<li><code>Incr.stabilize</code> recomputes all stale <em>necessary</em>
nodes in an order based on node heights (a topological schedule).</li>
<li>It supports <strong>cutoffs</strong> (don’t propagate if “unchanged
enough”), rich observer hooks, and scoping mechanisms that help manage
dynamic graphs.</li>
</ul>
<div class="sourceCode" id="cb385"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb385-1"><a href="#cb385-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> Incr = Incremental.Make ()</span>
<span id="cb385-2"><a href="#cb385-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb385-3"><a href="#cb385-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> a = Incr.Var.create <span class="dv">10</span></span>
<span id="cb385-4"><a href="#cb385-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> b = Incr.Var.create <span class="dv">32</span></span>
<span id="cb385-5"><a href="#cb385-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> sum = Incr.map2 (Incr.Var.watch a) (Incr.Var.watch b) ~f:( + )</span>
<span id="cb385-6"><a href="#cb385-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb385-7"><a href="#cb385-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> obs = Incr.observe sum</span>
<span id="cb385-8"><a href="#cb385-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> now () =</span>
<span id="cb385-9"><a href="#cb385-9" aria-hidden="true" tabindex="-1"></a>  Incr.stabilize ();</span>
<span id="cb385-10"><a href="#cb385-10" aria-hidden="true" tabindex="-1"></a>  Incr.Observer.value_exn obs</span>
<span id="cb385-11"><a href="#cb385-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb385-12"><a href="#cb385-12" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () =</span>
<span id="cb385-13"><a href="#cb385-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s0 = now () <span class="kw">in</span>  <span class="co">(* 42 *)</span></span>
<span id="cb385-14"><a href="#cb385-14" aria-hidden="true" tabindex="-1"></a>  Incr.Var.set a <span class="dv">11</span>;</span>
<span id="cb385-15"><a href="#cb385-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> s1 = now () <span class="kw">in</span>  <span class="co">(* 43 *)</span></span>
<span id="cb385-16"><a href="#cb385-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ignore</span> (s0, s1)</span></code></pre></div>
<h4 id="comparing-design-choices-why-two-libraries">Comparing Design
Choices (Why Two Libraries?)</h4>
<p>Both libraries implement self-adjusting computation, but they
optimize for different problem shapes. A quick high-level summary:</p>
<ul>
<li><strong>When recomputation happens</strong>
<ul>
<li><code>Lwd</code>: recompute on <code>sample</code> (pull), after
eager invalidation (push).</li>
<li><code>Incremental</code>: recompute during <code>stabilize</code>
(push), sampling is just reading.</li>
</ul></li>
<li><strong>Graph shape expectations</strong>
<ul>
<li><code>Lwd</code>: typically tree-ish with occasional sharing;
optimized to be small.</li>
<li><code>Incremental</code>: arbitrary large DAGs with heavy sharing;
optimized to schedule recomputation precisely.</li>
</ul></li>
<li><strong>Change propagation policy</strong>
<ul>
<li><code>Lwd</code>: simple invalidation flags; minimal
bookkeeping.</li>
<li><code>Incremental</code>: timestamps/heights, recompute heaps,
cutoffs; more bookkeeping, more guarantees and knobs.</li>
</ul></li>
<li><strong>Lifetimes</strong>
<ul>
<li><code>Lwd</code>: explicit <code>acquire</code>/<code>release</code>
on primitives; roots control liveness.</li>
<li><code>Incremental</code>: observers/scopes and finalizers;
“necessary” vs “unnecessary” nodes.</li>
</ul></li>
</ul>
<p>As a rule of thumb:</p>
<ul>
<li>Choose <strong><code>Lwd</code></strong> when your reactive graph is
primarily a <em>view tree</em> (documents/widgets/DOM-ish nodes), and
you care about explicit resource lifetimes and keeping the runtime
lightweight.</li>
<li>Choose <strong><code>Incremental</code></strong> when you have a
large shared DAG, you need cutoffs and richer scheduling/inspection
tools, or you want to build higher-level frameworks (e.g. component
systems) on top.</li>
</ul>
<p>The moral is not “one is better”; it is that incremental computing is
a <em>design space</em>. Your choice should match how you expect your
graph to evolve (tree vs. DAG, dynamic dependencies, scale) and how much
control you need over scheduling and cutoffs.</p>
<h3 id="when-incremental-computing-wins-and-when-it-doesnt">When
Incremental Computing Wins (and When It Doesn’t)</h3>
<p>Incremental computing has overhead: it builds and maintains a
dependency graph and caches intermediate results. It tends to win when
you have:</p>
<ul>
<li>a large computation that you will update <em>many times</em>,</li>
<li>each update changes a <em>small part</em> of the inputs,</li>
<li>and you need outputs after each update.</li>
</ul>
<p>If you build something once and throw it away, plain recomputation
can be faster and simpler.</p>
<h2 id="functional-reactive-programming">10.4 Functional Reactive
Programming</h2>
<p>Incremental computing is about efficiently updating a <em>pure</em>
computation when some inputs change. <strong>Functional Reactive
Programming (FRP)</strong> is about structuring programs that interact
with a changing world—key presses, network packets, sensor readings,
animations—<em>without giving up declarative composition</em>.</p>
<p>FRP revolves around a small vocabulary:</p>
<ul>
<li>A <strong>behavior</strong> is a value that exists “at every time”
(mouse position, window size, current score).</li>
<li>An <strong>event</strong> is a discrete occurrence (a key press, a
click, a timer tick).</li>
<li>A <strong>signal</strong> is a generic name for either kind of thing
(terminology varies across libraries).</li>
</ul>
<p>Two constraints shape every FRP design:</p>
<ol type="1">
<li><strong>Causality</strong>. A signal at time <code>t</code> may
depend on the past and present, but not on the future. Feedback loops
must include a delay (e.g. “previous value”, integration, an explicit
state step).</li>
<li><strong>Efficiency and consistency</strong>. We want to avoid
replaying the entire history of the world on every sample, and we want
to avoid <em>glitches</em>—temporarily observing inconsistent
intermediate states because dependencies update in the wrong order.</li>
</ol>
<p>In practice, FRP systems implement some notion of an <strong>update
step</strong> (also called a tick, a frame, a stabilization pass).
During an update step we incorporate all inputs that “happened
simultaneously” and then recompute derived signals in a schedule that
respects dependencies.</p>
<h3
id="idealized-definitions-and-why-we-dont-implement-them-directly">Idealized
Definitions (and Why We Don’t Implement Them Directly)</h3>
<p>In the most mathematical presentation, we might write:</p>
<div class="sourceCode" id="cb386"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb386-1"><a href="#cb386-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> time = <span class="dt">float</span></span>
<span id="cb386-2"><a href="#cb386-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a behavior = time -&gt; &#39;a</span>
<span id="cb386-3"><a href="#cb386-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a event = (time * &#39;a) stream  <span class="co">(* increasing time stamps *)</span></span></code></pre></div>
<p>This says: a behavior has a value at every time; an event is a
(possibly infinite) stream of timestamped occurrences.</p>
<p>The trouble is that real programs must react to <em>external</em>
events (mouse moves, clicks, window resize). If we define behaviors as
“functions of time”, we still need some representation of “the history
of inputs so far”, and we need to compute behavior values without
rescanning that history from the beginning each time.</p>
<p>The usual move is to turn behaviors into <strong>stream
transformers</strong> that process time and inputs incrementally:</p>
<div class="sourceCode" id="cb387"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb387-1"><a href="#cb387-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a behavior = user_action event -&gt; time -&gt; &#39;a</span>
<span id="cb387-2"><a href="#cb387-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a behavior = user_action event -&gt; time stream -&gt; &#39;a stream</span>
<span id="cb387-3"><a href="#cb387-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a behavior = (user_action <span class="dt">option</span> * time) stream -&gt; &#39;a stream</span></code></pre></div>
<p>This transformation from functions-of-time to stream transformers is
analogous to a classic algorithm optimization. Computing the
intersection of two lists naively checks every pair, giving <span
class="math inline">O(mn)</span> time. If the lists are sorted, the
smart approach walks through both lists simultaneously, giving <span
class="math inline">O(m + n)</span> time. Similarly, our stream-based
behaviors process time and events together in a single pass.</p>
<p>Once behaviors are stream transformers, a very convenient
representation for events is:</p>
<div class="sourceCode" id="cb388"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb388-1"><a href="#cb388-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a event = &#39;a <span class="dt">option</span> behavior</span></code></pre></div>
<p>An event is just a behavior that yields <code>None</code> most of the
time and <code>Some v</code> at the instants where the event occurs.</p>
<h3 id="behaviors-as-applicative-static-wiring">Behaviors as Applicative
(Static Wiring)</h3>
<p>Pointwise behaviors form an applicative functor (and, in idealized
presentations, a monad). For
<code>type 'a behavior = time -&gt; 'a</code> we can define:</p>
<div class="sourceCode" id="cb389"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb389-1"><a href="#cb389-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pure a = <span class="kw">fun</span> _t -&gt; a</span>
<span id="cb389-2"><a href="#cb389-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> map f b = <span class="kw">fun</span> t -&gt; f (b t)</span>
<span id="cb389-3"><a href="#cb389-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ap bf ba = <span class="kw">fun</span> t -&gt; (bf t) (ba t)</span></code></pre></div>
<p>From <code>ap</code> we get the familiar lifting operators:</p>
<div class="sourceCode" id="cb390"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb390-1"><a href="#cb390-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> lift2 f a b = ap (map f a) b</span>
<span id="cb390-2"><a href="#cb390-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> lift3 f a b c = ap (lift2 f a b) c</span></code></pre></div>
<p>In practice, most FRP code is written in this <em>applicative</em>
style: it gives a static “wiring diagram”, which is easier to implement
efficiently and avoids surprising dynamic dependencies.</p>
<h3 id="converting-between-events-and-behaviors">Converting Between
Events and Behaviors</h3>
<p>Four combinators show up again and again:</p>
<ul>
<li><code>step : init:'a -&gt; 'a event -&gt; 'a behavior</code> (hold
last event value)</li>
<li><code>switch : init:'a behavior -&gt; 'a behavior event -&gt; 'a behavior</code>
(switch behaviors over time)</li>
<li><code>until : 'a behavior -&gt; 'a behavior event -&gt; 'a behavior</code>
(switch once)</li>
<li><code>snapshot : 'a event -&gt; 'b behavior -&gt; ('a * 'b) event</code>
(sample a behavior when an event fires)</li>
</ul>
<p>Section 10.5 builds a small stream-based FRP core where these are
concrete functions on lazy streams.</p>
<h3 id="a-concrete-input-model">A Concrete Input Model</h3>
<p>To keep the discussion concrete, we will package external inputs
(user actions) together with sampling times:</p>
<div class="sourceCode" id="cb391"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb391-1"><a href="#cb391-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> time = <span class="dt">float</span></span>
<span id="cb391-2"><a href="#cb391-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb391-3"><a href="#cb391-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> user_action =</span>
<span id="cb391-4"><a href="#cb391-4" aria-hidden="true" tabindex="-1"></a>  | Key <span class="kw">of</span> <span class="dt">char</span> * <span class="dt">bool</span></span>
<span id="cb391-5"><a href="#cb391-5" aria-hidden="true" tabindex="-1"></a>  | Button <span class="kw">of</span> <span class="dt">int</span> * <span class="dt">int</span> * <span class="dt">bool</span> * <span class="dt">bool</span></span>
<span id="cb391-6"><a href="#cb391-6" aria-hidden="true" tabindex="-1"></a>  | MouseMove <span class="kw">of</span> <span class="dt">int</span> * <span class="dt">int</span></span>
<span id="cb391-7"><a href="#cb391-7" aria-hidden="true" tabindex="-1"></a>  | Resize <span class="kw">of</span> <span class="dt">int</span> * <span class="dt">int</span></span></code></pre></div>
<p>We will present two implementations:</p>
<ol type="1">
<li>A <strong>stream-processing</strong> implementation (Section 10.5)
that makes time explicit and computes signals by consuming an input
stream.</li>
<li>An <strong>incremental</strong> implementation (Section 10.6) that
represents signals as nodes in an incremental dependency graph and
updates them by invalidation/stabilization.</li>
</ol>
<p>Conceptually, in the stream-processing interpretation we will
treat:</p>
<div class="sourceCode" id="cb392"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb392-1"><a href="#cb392-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Conceptual types (we refine the representation in Section 10.5). *)</span></span>
<span id="cb392-2"><a href="#cb392-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a behavior = (user_action <span class="dt">option</span> * time) stream -&gt; &#39;a stream</span>
<span id="cb392-3"><a href="#cb392-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a event = &#39;a <span class="dt">option</span> behavior</span></code></pre></div>
<h2 id="reactivity-by-stream-processing">10.5 Reactivity by Stream
Processing</h2>
<p>Now let us implement FRP using the stream processing techniques from
Chapter 7. The infrastructure should be familiar:</p>
<div class="sourceCode" id="cb393"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb393-1"><a href="#cb393-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a stream = &#39;a stream_ <span class="dt">Lazy</span>.t</span>
<span id="cb393-2"><a href="#cb393-2" aria-hidden="true" tabindex="-1"></a><span class="kw">and</span> &#39;a stream_ = Cons <span class="kw">of</span> &#39;a * &#39;a stream</span>
<span id="cb393-3"><a href="#cb393-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb393-4"><a href="#cb393-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> lmap f l = <span class="kw">lazy</span> (</span>
<span id="cb393-5"><a href="#cb393-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> Cons (x, xs) = <span class="dt">Lazy</span>.force l <span class="kw">in</span></span>
<span id="cb393-6"><a href="#cb393-6" aria-hidden="true" tabindex="-1"></a>  Cons (f x, lmap f xs))</span>
<span id="cb393-7"><a href="#cb393-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb393-8"><a href="#cb393-8" aria-hidden="true" tabindex="-1"></a><span class="co">(* Infinite loop: only exits via an exception, either from forcing</span></span>
<span id="cb393-9"><a href="#cb393-9" aria-hidden="true" tabindex="-1"></a><span class="co">   e.g. &quot;end of stream&quot;, or from f e.g. &quot;exit&quot;. *)</span></span>
<span id="cb393-10"><a href="#cb393-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> liter (f : &#39;a -&gt; <span class="dt">unit</span>) (l : &#39;a stream) : <span class="dt">unit</span> =</span>
<span id="cb393-11"><a href="#cb393-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> Cons (x, xs) = <span class="dt">Lazy</span>.force l <span class="kw">in</span></span>
<span id="cb393-12"><a href="#cb393-12" aria-hidden="true" tabindex="-1"></a>  f x; liter f xs</span>
<span id="cb393-13"><a href="#cb393-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb393-14"><a href="#cb393-14" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> lmap2 f xs ys = <span class="kw">lazy</span> (</span>
<span id="cb393-15"><a href="#cb393-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> Cons (x, xs) = <span class="dt">Lazy</span>.force xs <span class="kw">in</span></span>
<span id="cb393-16"><a href="#cb393-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> Cons (y, ys) = <span class="dt">Lazy</span>.force ys <span class="kw">in</span></span>
<span id="cb393-17"><a href="#cb393-17" aria-hidden="true" tabindex="-1"></a>  Cons (f x y, lmap2 f xs ys))</span>
<span id="cb393-18"><a href="#cb393-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb393-19"><a href="#cb393-19" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> lmap3 f xs ys zs = <span class="kw">lazy</span> (</span>
<span id="cb393-20"><a href="#cb393-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> Cons (x, xs) = <span class="dt">Lazy</span>.force xs <span class="kw">in</span></span>
<span id="cb393-21"><a href="#cb393-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> Cons (y, ys) = <span class="dt">Lazy</span>.force ys <span class="kw">in</span></span>
<span id="cb393-22"><a href="#cb393-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> Cons (z, zs) = <span class="dt">Lazy</span>.force zs <span class="kw">in</span></span>
<span id="cb393-23"><a href="#cb393-23" aria-hidden="true" tabindex="-1"></a>  Cons (f x y z, lmap3 f xs ys zs))</span>
<span id="cb393-24"><a href="#cb393-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb393-25"><a href="#cb393-25" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> lfold acc f (l : &#39;a stream) = <span class="kw">lazy</span> (</span>
<span id="cb393-26"><a href="#cb393-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> Cons (x, xs) = <span class="dt">Lazy</span>.force l <span class="kw">in</span>  <span class="co">(* Fold a function over the stream *)</span></span>
<span id="cb393-27"><a href="#cb393-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> acc = f acc x <span class="kw">in</span>  <span class="co">(* producing a stream of partial results *)</span></span>
<span id="cb393-28"><a href="#cb393-28" aria-hidden="true" tabindex="-1"></a>  Cons (acc, lfold acc f xs))</span></code></pre></div>
<p>Since a behavior is a function from the input stream to an output
stream, we face a subtle sharing problem: if we apply the same behavior
function twice to the “same” input, we might create two separate streams
that diverge. We need to ensure that for any actual input stream, each
behavior creates exactly one output stream. This requires
memoization:</p>
<div class="sourceCode" id="cb394"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb394-1"><a href="#cb394-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (&#39;a, &#39;b) memo1 =</span>
<span id="cb394-2"><a href="#cb394-2" aria-hidden="true" tabindex="-1"></a>  {memo_f : &#39;a -&gt; &#39;b; <span class="kw">mutable</span> memo_r : (&#39;a * &#39;b) <span class="dt">option</span>}</span>
<span id="cb394-3"><a href="#cb394-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb394-4"><a href="#cb394-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> memo1 f = {memo_f = f; memo_r = <span class="dt">None</span>}</span>
<span id="cb394-5"><a href="#cb394-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb394-6"><a href="#cb394-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> memo1_app f x =</span>
<span id="cb394-7"><a href="#cb394-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> f.memo_r <span class="kw">with</span></span>
<span id="cb394-8"><a href="#cb394-8" aria-hidden="true" tabindex="-1"></a>  | <span class="dt">Some</span> (y, res) <span class="kw">when</span> x == y -&gt; res  <span class="co">(* Physical equality check *)</span></span>
<span id="cb394-9"><a href="#cb394-9" aria-hidden="true" tabindex="-1"></a>  | _ -&gt;</span>
<span id="cb394-10"><a href="#cb394-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> res = f.memo_f x <span class="kw">in</span></span>
<span id="cb394-11"><a href="#cb394-11" aria-hidden="true" tabindex="-1"></a>    f.memo_r &lt;- <span class="dt">Some</span> (x, res);  <span class="co">(* Cache for next call *)</span></span>
<span id="cb394-12"><a href="#cb394-12" aria-hidden="true" tabindex="-1"></a>    res</span>
<span id="cb394-13"><a href="#cb394-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb394-14"><a href="#cb394-14" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ($) = memo1_app  <span class="co">(* Convenient infix for memoized application *)</span></span>
<span id="cb394-15"><a href="#cb394-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb394-16"><a href="#cb394-16" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a behavior =</span>
<span id="cb394-17"><a href="#cb394-17" aria-hidden="true" tabindex="-1"></a>  ((user_action <span class="dt">option</span> * time) stream, &#39;a stream) memo1</span>
<span id="cb394-18"><a href="#cb394-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb394-19"><a href="#cb394-19" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a event = &#39;a <span class="dt">option</span> behavior</span></code></pre></div>
<p>We use physical equality (<code>==</code>) rather than structural
equality (<code>=</code>) because the external input stream is a single
physical object – if we see the same pointer, we know it is the same
stream. During debugging, we can verify that <code>memo_r</code> is
<code>None</code> before the first call and <code>Some</code>
afterwards.</p>
<h3 id="building-complex-behaviors">Building Complex Behaviors</h3>
<p>Now we can build the monadic/applicative functions for composing
behaviors. A practical tip: when working with these higher-order types,
type annotations are essential. If you do not provide type annotations
in <code>.ml</code> files, work together with an <code>.mli</code>
interface file to catch type problems early.</p>
<div class="sourceCode" id="cb395"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb395-1"><a href="#cb395-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* A constant behavior: returns the same value at all times *)</span></span>
<span id="cb395-2"><a href="#cb395-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> returnB x : &#39;a behavior =</span>
<span id="cb395-3"><a href="#cb395-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> xs = <span class="kw">lazy</span> (Cons (x, xs)) <span class="kw">in</span>  <span class="co">(* Infinite stream of x *)</span></span>
<span id="cb395-4"><a href="#cb395-4" aria-hidden="true" tabindex="-1"></a>  memo1 (<span class="kw">fun</span> _ -&gt; xs)</span>
<span id="cb395-5"><a href="#cb395-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb395-6"><a href="#cb395-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ( !* ) = returnB  <span class="co">(* Convenient prefix operator for constants *)</span></span>
<span id="cb395-7"><a href="#cb395-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb395-8"><a href="#cb395-8" aria-hidden="true" tabindex="-1"></a><span class="co">(* Lift a unary function to work on behaviors *)</span></span>
<span id="cb395-9"><a href="#cb395-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> liftB f fb = memo1 (<span class="kw">fun</span> uts -&gt; lmap f (fb $ uts))</span>
<span id="cb395-10"><a href="#cb395-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb395-11"><a href="#cb395-11" aria-hidden="true" tabindex="-1"></a><span class="co">(* Lift binary and ternary functions similarly *)</span></span>
<span id="cb395-12"><a href="#cb395-12" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> liftB2 f fb1 fb2 = memo1</span>
<span id="cb395-13"><a href="#cb395-13" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">fun</span> uts -&gt; lmap2 f (fb1 $ uts) (fb2 $ uts))</span>
<span id="cb395-14"><a href="#cb395-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb395-15"><a href="#cb395-15" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> liftB3 f fb1 fb2 fb3 = memo1</span>
<span id="cb395-16"><a href="#cb395-16" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">fun</span> uts -&gt; lmap3 f (fb1 $ uts) (fb2 $ uts) (fb3 $ uts))</span>
<span id="cb395-17"><a href="#cb395-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb395-18"><a href="#cb395-18" aria-hidden="true" tabindex="-1"></a><span class="co">(* Lift a function to work on events (None -&gt; None, Some e -&gt; Some (f e)) *)</span></span>
<span id="cb395-19"><a href="#cb395-19" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> liftE f (fe : &#39;a event) : &#39;b event = memo1</span>
<span id="cb395-20"><a href="#cb395-20" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">fun</span> uts -&gt; lmap</span>
<span id="cb395-21"><a href="#cb395-21" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">function</span> <span class="dt">Some</span> e -&gt; <span class="dt">Some</span> (f e) | <span class="dt">None</span> -&gt; <span class="dt">None</span>)</span>
<span id="cb395-22"><a href="#cb395-22" aria-hidden="true" tabindex="-1"></a>    (fe $ uts))</span>
<span id="cb395-23"><a href="#cb395-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb395-24"><a href="#cb395-24" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (=&gt;&gt;) fe f = liftE f fe  <span class="co">(* Map over events, infix style *)</span></span>
<span id="cb395-25"><a href="#cb395-25" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (-&gt;&gt;) e v = e =&gt;&gt; <span class="kw">fun</span> _ -&gt; v  <span class="co">(* Replace event value with constant *)</span></span></code></pre></div>
<p>We also need to create events from behaviors and vice versa. Creating
events out of behaviors:</p>
<div class="sourceCode" id="cb396"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb396-1"><a href="#cb396-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* whileB: produces an event at every moment the behavior is true *)</span></span>
<span id="cb396-2"><a href="#cb396-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> whileB (fb : <span class="dt">bool</span> behavior) : <span class="dt">unit</span> event =</span>
<span id="cb396-3"><a href="#cb396-3" aria-hidden="true" tabindex="-1"></a>  memo1 (<span class="kw">fun</span> uts -&gt;</span>
<span id="cb396-4"><a href="#cb396-4" aria-hidden="true" tabindex="-1"></a>    lmap (<span class="kw">function</span> <span class="kw">true</span> -&gt; <span class="dt">Some</span> () | <span class="kw">false</span> -&gt; <span class="dt">None</span>)</span>
<span id="cb396-5"><a href="#cb396-5" aria-hidden="true" tabindex="-1"></a>      (fb $ uts))</span>
<span id="cb396-6"><a href="#cb396-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb396-7"><a href="#cb396-7" aria-hidden="true" tabindex="-1"></a><span class="co">(* unique: filters out duplicate consecutive events *)</span></span>
<span id="cb396-8"><a href="#cb396-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> unique fe : &#39;a event =</span>
<span id="cb396-9"><a href="#cb396-9" aria-hidden="true" tabindex="-1"></a>  memo1 (<span class="kw">fun</span> uts -&gt;</span>
<span id="cb396-10"><a href="#cb396-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> xs = fe $ uts <span class="kw">in</span></span>
<span id="cb396-11"><a href="#cb396-11" aria-hidden="true" tabindex="-1"></a>    lmap2 (<span class="kw">fun</span> x y -&gt; <span class="kw">if</span> x = y <span class="kw">then</span> <span class="dt">None</span> <span class="kw">else</span> y)</span>
<span id="cb396-12"><a href="#cb396-12" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">lazy</span> (Cons (<span class="dt">None</span>, xs))) xs)  <span class="co">(* Compare with previous value *)</span></span>
<span id="cb396-13"><a href="#cb396-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb396-14"><a href="#cb396-14" aria-hidden="true" tabindex="-1"></a><span class="co">(* whenB: produces an event when the behavior becomes true (edge detection) *)</span></span>
<span id="cb396-15"><a href="#cb396-15" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> whenB fb =</span>
<span id="cb396-16"><a href="#cb396-16" aria-hidden="true" tabindex="-1"></a>  memo1 (<span class="kw">fun</span> uts -&gt; unique (whileB fb) $ uts)</span>
<span id="cb396-17"><a href="#cb396-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb396-18"><a href="#cb396-18" aria-hidden="true" tabindex="-1"></a><span class="co">(* snapshot: when an event occurs, capture both the event value</span></span>
<span id="cb396-19"><a href="#cb396-19" aria-hidden="true" tabindex="-1"></a><span class="co">   and current behavior value *)</span></span>
<span id="cb396-20"><a href="#cb396-20" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> snapshot fe fb : (&#39;a * &#39;b) event =</span>
<span id="cb396-21"><a href="#cb396-21" aria-hidden="true" tabindex="-1"></a>  memo1 (<span class="kw">fun</span> uts -&gt; lmap2</span>
<span id="cb396-22"><a href="#cb396-22" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">fun</span> x -&gt; <span class="kw">function</span> <span class="dt">Some</span> y -&gt; <span class="dt">Some</span> (y, x) | <span class="dt">None</span> -&gt; <span class="dt">None</span>)</span>
<span id="cb396-23"><a href="#cb396-23" aria-hidden="true" tabindex="-1"></a>      (fb $ uts) (fe $ uts))</span></code></pre></div>
<p>Creating behaviors out of events:</p>
<div class="sourceCode" id="cb397"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb397-1"><a href="#cb397-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* step: holds the value of the most recent event, starting with &#39;acc&#39; *)</span></span>
<span id="cb397-2"><a href="#cb397-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> step acc fe =</span>
<span id="cb397-3"><a href="#cb397-3" aria-hidden="true" tabindex="-1"></a>  memo1 (<span class="kw">fun</span> uts -&gt; lfold acc</span>
<span id="cb397-4"><a href="#cb397-4" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">fun</span> acc -&gt; <span class="kw">function</span> <span class="dt">None</span> -&gt; acc | <span class="dt">Some</span> v -&gt; v)</span>
<span id="cb397-5"><a href="#cb397-5" aria-hidden="true" tabindex="-1"></a>    (fe $ uts))</span>
<span id="cb397-6"><a href="#cb397-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb397-7"><a href="#cb397-7" aria-hidden="true" tabindex="-1"></a><span class="co">(* step_accum: accumulates by applying functions from events to current value *)</span></span>
<span id="cb397-8"><a href="#cb397-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> step_accum acc ff =</span>
<span id="cb397-9"><a href="#cb397-9" aria-hidden="true" tabindex="-1"></a>  memo1 (<span class="kw">fun</span> uts -&gt;</span>
<span id="cb397-10"><a href="#cb397-10" aria-hidden="true" tabindex="-1"></a>    lfold acc (<span class="kw">fun</span> acc -&gt; <span class="kw">function</span></span>
<span id="cb397-11"><a href="#cb397-11" aria-hidden="true" tabindex="-1"></a>      | <span class="dt">None</span> -&gt; acc | <span class="dt">Some</span> f -&gt; f acc)</span>
<span id="cb397-12"><a href="#cb397-12" aria-hidden="true" tabindex="-1"></a>      (ff $ uts))</span></code></pre></div>
<p>For physics simulations like our upcoming paddle game, we need to
integrate behaviors over time. This requires access to the sampling
timestamps:</p>
<div class="sourceCode" id="cb398"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb398-1"><a href="#cb398-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> integral fb =</span>
<span id="cb398-2"><a href="#cb398-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> loop t0 acc uts bs =</span>
<span id="cb398-3"><a href="#cb398-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> Cons ((_, t1), uts) = <span class="dt">Lazy</span>.force uts <span class="kw">in</span></span>
<span id="cb398-4"><a href="#cb398-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> Cons (b, bs) = <span class="dt">Lazy</span>.force bs <span class="kw">in</span></span>
<span id="cb398-5"><a href="#cb398-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* Rectangle rule: b is fb(t1), acc approximates integral up to t0 *)</span></span>
<span id="cb398-6"><a href="#cb398-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> acc = acc +. (t1 -. t0) *. b <span class="kw">in</span></span>
<span id="cb398-7"><a href="#cb398-7" aria-hidden="true" tabindex="-1"></a>    Cons (acc, <span class="kw">lazy</span> (loop t1 acc uts bs)) <span class="kw">in</span></span>
<span id="cb398-8"><a href="#cb398-8" aria-hidden="true" tabindex="-1"></a>  memo1 (<span class="kw">fun</span> uts -&gt; <span class="kw">lazy</span> (</span>
<span id="cb398-9"><a href="#cb398-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> Cons ((_, t), uts&#39;) = <span class="dt">Lazy</span>.force uts <span class="kw">in</span></span>
<span id="cb398-10"><a href="#cb398-10" aria-hidden="true" tabindex="-1"></a>    Cons (<span class="dv">0</span>., <span class="kw">lazy</span> (loop t <span class="dv">0</span>. uts&#39; (fb $ uts)))))</span></code></pre></div>
<p>In our upcoming <em>paddle game</em> example, we will express
position and velocity in a mutually recursive manner – position is the
integral of velocity, but velocity changes when position hits a wall.
This seems paradoxical: how can we define position in terms of velocity
if velocity depends on position?</p>
<p>The trick is the same as we saw in Chapter 7: integration introduces
one step of delay. The integral at time <span
class="math inline">t</span> depends on velocities at times
<em>before</em> <span class="math inline">t</span>, while the bounce
detection at time <span class="math inline">t</span> uses the position
at time <span class="math inline">t</span>. This breaks the cyclic
dependency and makes the recursion well-founded.</p>
<p>We define behaviors for user actions by extracting them from the
input stream:</p>
<div class="sourceCode" id="cb399"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb399-1"><a href="#cb399-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Left button press event *)</span></span>
<span id="cb399-2"><a href="#cb399-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> lbp : <span class="dt">unit</span> event =</span>
<span id="cb399-3"><a href="#cb399-3" aria-hidden="true" tabindex="-1"></a>  memo1 (<span class="kw">fun</span> uts -&gt; lmap</span>
<span id="cb399-4"><a href="#cb399-4" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">function</span> <span class="dt">Some</span> (Button (_, _, <span class="kw">true</span>, _)), _ -&gt; <span class="dt">Some</span> () | _ -&gt; <span class="dt">None</span>)</span>
<span id="cb399-5"><a href="#cb399-5" aria-hidden="true" tabindex="-1"></a>    uts)</span>
<span id="cb399-6"><a href="#cb399-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb399-7"><a href="#cb399-7" aria-hidden="true" tabindex="-1"></a><span class="co">(* Mouse movement event (carries coordinates) *)</span></span>
<span id="cb399-8"><a href="#cb399-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> mm : (<span class="dt">int</span> * <span class="dt">int</span>) event =</span>
<span id="cb399-9"><a href="#cb399-9" aria-hidden="true" tabindex="-1"></a>  memo1 (<span class="kw">fun</span> uts -&gt; lmap</span>
<span id="cb399-10"><a href="#cb399-10" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">function</span> <span class="dt">Some</span> (MouseMove (x, y)), _ -&gt; <span class="dt">Some</span> (x, y) | _ -&gt; <span class="dt">None</span>)</span>
<span id="cb399-11"><a href="#cb399-11" aria-hidden="true" tabindex="-1"></a>    uts)</span>
<span id="cb399-12"><a href="#cb399-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb399-13"><a href="#cb399-13" aria-hidden="true" tabindex="-1"></a><span class="co">(* Window resize event *)</span></span>
<span id="cb399-14"><a href="#cb399-14" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> screen : (<span class="dt">int</span> * <span class="dt">int</span>) event =</span>
<span id="cb399-15"><a href="#cb399-15" aria-hidden="true" tabindex="-1"></a>  memo1 (<span class="kw">fun</span> uts -&gt; lmap</span>
<span id="cb399-16"><a href="#cb399-16" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">function</span> <span class="dt">Some</span> (Resize (x, y)), _ -&gt; <span class="dt">Some</span> (x, y) | _ -&gt; <span class="dt">None</span>)</span>
<span id="cb399-17"><a href="#cb399-17" aria-hidden="true" tabindex="-1"></a>    uts)</span>
<span id="cb399-18"><a href="#cb399-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb399-19"><a href="#cb399-19" aria-hidden="true" tabindex="-1"></a><span class="co">(* Behaviors derived from events using step *)</span></span>
<span id="cb399-20"><a href="#cb399-20" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> mouse_x : <span class="dt">int</span> behavior = step <span class="dv">0</span> (liftE <span class="dt">fst</span> mm)  <span class="co">(* Current mouse X *)</span></span>
<span id="cb399-21"><a href="#cb399-21" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> mouse_y : <span class="dt">int</span> behavior = step <span class="dv">0</span> (liftE <span class="dt">snd</span> mm)  <span class="co">(* Current mouse Y *)</span></span>
<span id="cb399-22"><a href="#cb399-22" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> width : <span class="dt">int</span> behavior = step <span class="dv">640</span> (liftE <span class="dt">fst</span> screen)  <span class="co">(* Window width *)</span></span>
<span id="cb399-23"><a href="#cb399-23" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> height : <span class="dt">int</span> behavior = step <span class="dv">512</span> (liftE <span class="dt">snd</span> screen) <span class="co">(* Window height *)</span></span></code></pre></div>
<h3 id="the-paddle-game-example">The Paddle Game Example</h3>
<p>Now let us put all these pieces together to build a classic paddle
game (similar to Pong). A ball bounces around the screen, and the player
controls a paddle at the bottom to prevent the ball from falling.</p>
<p>First, we define a <em>scene graph</em>, a data structure that
represents a “world” which can be drawn on screen. Since we will use
Bogue’s <code>Sdl_area</code> for rendering, we use simple line-based
shapes (rectangles drawn as outlines, circles approximated by line
segments):</p>
<div class="sourceCode" id="cb400"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb400-1"><a href="#cb400-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> color = <span class="dt">int</span> * <span class="dt">int</span> * <span class="dt">int</span>  <span class="co">(* RGB components *)</span></span>
<span id="cb400-2"><a href="#cb400-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb400-3"><a href="#cb400-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> scene =</span>
<span id="cb400-4"><a href="#cb400-4" aria-hidden="true" tabindex="-1"></a>  | Rect <span class="kw">of</span> <span class="dt">int</span> * <span class="dt">int</span> * <span class="dt">int</span> * <span class="dt">int</span>  <span class="co">(* x, y, width, height *)</span></span>
<span id="cb400-5"><a href="#cb400-5" aria-hidden="true" tabindex="-1"></a>  | Circle <span class="kw">of</span> <span class="dt">int</span> * <span class="dt">int</span> * <span class="dt">int</span>      <span class="co">(* x, y, radius *)</span></span>
<span id="cb400-6"><a href="#cb400-6" aria-hidden="true" tabindex="-1"></a>  | Group <span class="kw">of</span> scene <span class="dt">list</span></span>
<span id="cb400-7"><a href="#cb400-7" aria-hidden="true" tabindex="-1"></a>  | Color <span class="kw">of</span> color * scene         <span class="co">(* color of subscene objects *)</span></span>
<span id="cb400-8"><a href="#cb400-8" aria-hidden="true" tabindex="-1"></a>  | Translate <span class="kw">of</span> <span class="dt">float</span> * <span class="dt">float</span> * scene  <span class="co">(* offset *)</span></span></code></pre></div>
<p>The drawing function interprets the scene graph. We use Bogue’s
<code>Sdl_area</code> to draw lines:</p>
<div class="sourceCode" id="cb401"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb401-1"><a href="#cb401-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> draw area ~h sc =</span>
<span id="cb401-2"><a href="#cb401-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">open</span> Bogue <span class="kw">in</span></span>
<span id="cb401-3"><a href="#cb401-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> f2i = <span class="dt">int_of_float</span> <span class="kw">in</span></span>
<span id="cb401-4"><a href="#cb401-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> flip_y y = h - y <span class="kw">in</span>  <span class="co">(* Bogue uses top-left origin *)</span></span>
<span id="cb401-5"><a href="#cb401-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> aux t_x t_y (r, g, b) = <span class="kw">function</span></span>
<span id="cb401-6"><a href="#cb401-6" aria-hidden="true" tabindex="-1"></a>    | Rect (x, y, w, ht) -&gt;</span>
<span id="cb401-7"><a href="#cb401-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> color = Draw.opaque (r, g, b) <span class="kw">in</span></span>
<span id="cb401-8"><a href="#cb401-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> x0, y0 = f2i t_x + x, flip_y (f2i t_y + y + ht) <span class="kw">in</span></span>
<span id="cb401-9"><a href="#cb401-9" aria-hidden="true" tabindex="-1"></a>      Sdl_area.draw_rectangle area ~color ~thick:<span class="dv">2</span> ~w ~h:ht (x0, y0)</span>
<span id="cb401-10"><a href="#cb401-10" aria-hidden="true" tabindex="-1"></a>    | Circle (x, y, rad) -&gt;</span>
<span id="cb401-11"><a href="#cb401-11" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> color = Draw.opaque (r, g, b) <span class="kw">in</span></span>
<span id="cb401-12"><a href="#cb401-12" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> cx, cy = f2i t_x + x, flip_y (f2i t_y + y) <span class="kw">in</span></span>
<span id="cb401-13"><a href="#cb401-13" aria-hidden="true" tabindex="-1"></a>      Sdl_area.draw_circle area ~color ~thick:<span class="dv">2</span> ~radius:rad (cx, cy)</span>
<span id="cb401-14"><a href="#cb401-14" aria-hidden="true" tabindex="-1"></a>    | Group scs -&gt;</span>
<span id="cb401-15"><a href="#cb401-15" aria-hidden="true" tabindex="-1"></a>      <span class="dt">List</span>.iter (aux t_x t_y (r, g, b)) scs</span>
<span id="cb401-16"><a href="#cb401-16" aria-hidden="true" tabindex="-1"></a>    | Color (c, sc) -&gt;</span>
<span id="cb401-17"><a href="#cb401-17" aria-hidden="true" tabindex="-1"></a>      aux t_x t_y c sc</span>
<span id="cb401-18"><a href="#cb401-18" aria-hidden="true" tabindex="-1"></a>    | Translate (dx, dy, sc) -&gt;</span>
<span id="cb401-19"><a href="#cb401-19" aria-hidden="true" tabindex="-1"></a>      aux (t_x +. dx) (t_y +. dy) (r, g, b) sc</span>
<span id="cb401-20"><a href="#cb401-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb401-21"><a href="#cb401-21" aria-hidden="true" tabindex="-1"></a>  aux <span class="dv">0</span>. <span class="dv">0</span>. (<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>) sc  <span class="co">(* Default color: white *)</span></span></code></pre></div>
<p>An <em>animation</em> is simply a scene behavior – a time-varying
scene. The <code>reactimate</code> function runs the animation loop: it
creates the input stream (user actions paired with sampling times),
feeds it to the scene behavior to get a stream of scenes, and draws each
scene. We use double buffering to avoid flickering.</p>
<p>For the game logic, we define lifted operators so we can write
behavior expressions naturally:</p>
<div class="sourceCode" id="cb402"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb402-1"><a href="#cb402-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (+<span class="er">*)</span> = liftB2 (+)</span>
<span id="cb402-2"><a href="#cb402-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (-<span class="er">*)</span> = liftB2 (-)</span>
<span id="cb402-3"><a href="#cb402-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ( *** ) = liftB2 ( * )</span>
<span id="cb402-4"><a href="#cb402-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (/<span class="er">*)</span> = liftB2 (/)</span>
<span id="cb402-5"><a href="#cb402-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (&amp;&amp;<span class="er">*)</span> = liftB2 (&amp;&amp;)</span>
<span id="cb402-6"><a href="#cb402-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (||<span class="er">*)</span> = liftB2 (||)</span>
<span id="cb402-7"><a href="#cb402-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (&lt;<span class="er">*)</span> = liftB2 (&lt;)</span>
<span id="cb402-8"><a href="#cb402-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (&gt;<span class="er">*)</span> = liftB2 (&gt;)</span></code></pre></div>
<p>Now we can define the game elements. The walls are drawn on the left,
top and right borders of the window:</p>
<div class="sourceCode" id="cb403"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb403-1"><a href="#cb403-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> blue = (<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">255</span>)</span>
<span id="cb403-2"><a href="#cb403-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb403-3"><a href="#cb403-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> walls =</span>
<span id="cb403-4"><a href="#cb403-4" aria-hidden="true" tabindex="-1"></a>  liftB2 (<span class="kw">fun</span> w h -&gt; Color (blue, Group</span>
<span id="cb403-5"><a href="#cb403-5" aria-hidden="true" tabindex="-1"></a>    [Rect (<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">20</span>, h<span class="dv">-1</span>); Rect (<span class="dv">0</span>, h<span class="dv">-21</span>, w<span class="dv">-1</span>, <span class="dv">20</span>);</span>
<span id="cb403-6"><a href="#cb403-6" aria-hidden="true" tabindex="-1"></a>     Rect (w<span class="dv">-21</span>, <span class="dv">0</span>, <span class="dv">20</span>, h<span class="dv">-1</span>)]))</span>
<span id="cb403-7"><a href="#cb403-7" aria-hidden="true" tabindex="-1"></a>    width height</span></code></pre></div>
<p>The paddle is tied to the mouse at the bottom border of the
window:</p>
<div class="sourceCode" id="cb404"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb404-1"><a href="#cb404-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> black = (<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb404-2"><a href="#cb404-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb404-3"><a href="#cb404-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> clamp_int ~lo ~hi x = <span class="dt">max</span> lo (<span class="dt">min</span> hi x)</span>
<span id="cb404-4"><a href="#cb404-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb404-5"><a href="#cb404-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> wall_thickness = <span class="dv">20</span></span>
<span id="cb404-6"><a href="#cb404-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> paddle_w = <span class="dv">70</span></span>
<span id="cb404-7"><a href="#cb404-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> paddle_h = <span class="dv">10</span></span>
<span id="cb404-8"><a href="#cb404-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb404-9"><a href="#cb404-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> paddle_x : <span class="dt">int</span> behavior =</span>
<span id="cb404-10"><a href="#cb404-10" aria-hidden="true" tabindex="-1"></a>  liftB2 (<span class="kw">fun</span> mx w -&gt;</span>
<span id="cb404-11"><a href="#cb404-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> lo = wall_thickness <span class="kw">in</span></span>
<span id="cb404-12"><a href="#cb404-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> hi = <span class="dt">max</span> lo (w - <span class="dv">21</span> - paddle_w) <span class="kw">in</span></span>
<span id="cb404-13"><a href="#cb404-13" aria-hidden="true" tabindex="-1"></a>    clamp_int ~lo ~hi (mx - (paddle_w / <span class="dv">2</span>)))</span>
<span id="cb404-14"><a href="#cb404-14" aria-hidden="true" tabindex="-1"></a>    mouse_x width</span>
<span id="cb404-15"><a href="#cb404-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb404-16"><a href="#cb404-16" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> paddle =</span>
<span id="cb404-17"><a href="#cb404-17" aria-hidden="true" tabindex="-1"></a>  liftB (<span class="kw">fun</span> px -&gt; Color (black, Rect (px, <span class="dv">0</span>, paddle_w, paddle_h))) paddle_x</span></code></pre></div>
<p>The ball has a velocity in pixels per second and bounces from the
walls.</p>
<p>The key ideas in the ball implementation:</p>
<ul>
<li><p><code>xbounce -&gt;&gt; (~-.)</code> – When an
<code>xbounce</code> event fires, emit the negation function
<code>(~-.)</code>. This will be used to flip the velocity
sign.</p></li>
<li><p><code>step_accum vel (xbounce -&gt;&gt; (~-.))</code> – Start
with velocity <code>vel</code>, and whenever a bounce event occurs,
apply the negation function to flip the sign. This creates a velocity
that bounces back and forth.</p></li>
<li><p><code>liftB int_of_float (integral xvel) +* width /* !*2</code> –
Integrate velocity to get position (as a float), truncate to integers,
and offset to center the ball in the window.</p></li>
<li><p><code>whenB ((xpos &gt;* width -* !*27) ||* (xpos &lt;* !*27))</code>
– Fire an event the <em>first</em> time the position exceeds the wall
boundaries (27 pixels from edges, accounting for wall thickness and ball
radius). The <code>whenB</code> combinator produces an event only on the
<em>transition</em> from false to true, ensuring we do not keep bouncing
while inside the wall.</p></li>
</ul>
<p><strong>Tying the knot with memo1 records.</strong> The mutual
recursion between <code>xvel</code>, <code>xpos</code>, and
<code>xbounce</code> requires care. If we naively wrote mutually
recursive <em>functions</em> that call each other, we would get an
infinite loop at definition time (before any stream is consumed). The
trick is to define the recursion at the <em>memo1 record</em> level: we
use <code>let rec ... and ...</code> to create mutually recursive
records where each record’s <code>memo_f</code> field references the
other records by name. The actual computation is deferred until
<code>$ uts</code> is applied.</p>
<div class="sourceCode" id="cb405"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb405-1"><a href="#cb405-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> red = (<span class="dv">255</span>, <span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb405-2"><a href="#cb405-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb405-3"><a href="#cb405-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ball : scene behavior =</span>
<span id="cb405-4"><a href="#cb405-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> wall_margin = <span class="dv">27</span> <span class="kw">in</span></span>
<span id="cb405-5"><a href="#cb405-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> vel = <span class="fl">100.0</span> <span class="kw">in</span></span>
<span id="cb405-6"><a href="#cb405-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* Horizontal motion with bouncing.</span></span>
<span id="cb405-7"><a href="#cb405-7" aria-hidden="true" tabindex="-1"></a><span class="co">     The mutual recursion is between memo1 records, not function calls. *)</span></span>
<span id="cb405-8"><a href="#cb405-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> xvel_ uts = step_accum vel (xbounce -&gt;&gt; (~-.)) $ uts</span>
<span id="cb405-9"><a href="#cb405-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">and</span> xvel = {memo_f = xvel_; memo_r = <span class="dt">None</span>}</span>
<span id="cb405-10"><a href="#cb405-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">and</span> xpos_ uts = (liftB <span class="dt">int_of_float</span> (integral xvel) +* width /* !*<span class="dv">2</span>) $ uts</span>
<span id="cb405-11"><a href="#cb405-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">and</span> xpos = {memo_f = xpos_; memo_r = <span class="dt">None</span>}</span>
<span id="cb405-12"><a href="#cb405-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">and</span> xbounce_ uts =</span>
<span id="cb405-13"><a href="#cb405-13" aria-hidden="true" tabindex="-1"></a>    whenB ((xpos &gt;* width -* !*wall_margin) ||* (xpos &lt;* !*wall_margin)) $ uts</span>
<span id="cb405-14"><a href="#cb405-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">and</span> xbounce = {memo_f = xbounce_; memo_r = <span class="dt">None</span>} <span class="kw">in</span></span>
<span id="cb405-15"><a href="#cb405-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* Vertical motion with bouncing *)</span></span>
<span id="cb405-16"><a href="#cb405-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> yvel_ uts = step_accum vel (ybounce -&gt;&gt; (~-.)) $ uts</span>
<span id="cb405-17"><a href="#cb405-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">and</span> yvel = {memo_f = yvel_; memo_r = <span class="dt">None</span>}</span>
<span id="cb405-18"><a href="#cb405-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">and</span> ypos_ uts = (liftB <span class="dt">int_of_float</span> (integral yvel) +* height /* !*<span class="dv">2</span>) $ uts</span>
<span id="cb405-19"><a href="#cb405-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">and</span> ypos = {memo_f = ypos_; memo_r = <span class="dt">None</span>}</span>
<span id="cb405-20"><a href="#cb405-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">and</span> ybounce_ uts =</span>
<span id="cb405-21"><a href="#cb405-21" aria-hidden="true" tabindex="-1"></a>    whenB ((ypos &gt;* height -* !*wall_margin) ||* (ypos &lt;* !*wall_margin)) $ uts</span>
<span id="cb405-22"><a href="#cb405-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">and</span> ybounce = {memo_f = ybounce_; memo_r = <span class="dt">None</span>} <span class="kw">in</span></span>
<span id="cb405-23"><a href="#cb405-23" aria-hidden="true" tabindex="-1"></a>  liftB2 (<span class="kw">fun</span> x y -&gt; Color (red, Circle (x, y, <span class="dv">7</span>))) xpos ypos</span></code></pre></div>
<p>Finally, we compose everything into the complete game scene:</p>
<div class="sourceCode" id="cb406"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb406-1"><a href="#cb406-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> game : scene behavior =</span>
<span id="cb406-2"><a href="#cb406-2" aria-hidden="true" tabindex="-1"></a>  liftB3 (<span class="kw">fun</span> w p b -&gt; Group [w; p; b]) walls paddle ball</span></code></pre></div>
<p>The animation loop drives the system. With Bogue, we integrate with
its event loop by using a timer and connection callbacks:</p>
<div class="sourceCode" id="cb407"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb407-1"><a href="#cb407-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> reactimate (scene : scene behavior) =</span>
<span id="cb407-2"><a href="#cb407-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">open</span> Bogue <span class="kw">in</span></span>
<span id="cb407-3"><a href="#cb407-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> w, h = <span class="dv">640</span>, <span class="dv">512</span> <span class="kw">in</span></span>
<span id="cb407-4"><a href="#cb407-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> area_widget = Widget.sdl_area ~w ~h () <span class="kw">in</span></span>
<span id="cb407-5"><a href="#cb407-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> area = Widget.get_sdl_area area_widget <span class="kw">in</span></span>
<span id="cb407-6"><a href="#cb407-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb407-7"><a href="#cb407-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* Append-only input stream: each node&#39;s tail forces a mutable &quot;hole&quot;. *)</span></span>
<span id="cb407-8"><a href="#cb407-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> mk_node (x : user_action <span class="dt">option</span> * time) :</span>
<span id="cb407-9"><a href="#cb407-9" aria-hidden="true" tabindex="-1"></a>    (user_action <span class="dt">option</span> * time) stream * (user_action <span class="dt">option</span> * time) stream <span class="dt">ref</span> =</span>
<span id="cb407-10"><a href="#cb407-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> next_ref : (user_action <span class="dt">option</span> * time) stream <span class="dt">ref</span> =</span>
<span id="cb407-11"><a href="#cb407-11" aria-hidden="true" tabindex="-1"></a>      <span class="dt">ref</span> (<span class="kw">lazy</span> (<span class="kw">assert</span> <span class="kw">false</span>))</span>
<span id="cb407-12"><a href="#cb407-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span></span>
<span id="cb407-13"><a href="#cb407-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> tail : (user_action <span class="dt">option</span> * time) stream =</span>
<span id="cb407-14"><a href="#cb407-14" aria-hidden="true" tabindex="-1"></a>      <span class="kw">lazy</span> (<span class="dt">Lazy</span>.force !next_ref)</span>
<span id="cb407-15"><a href="#cb407-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span></span>
<span id="cb407-16"><a href="#cb407-16" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">lazy</span> (Cons (x, tail)), next_ref)</span>
<span id="cb407-17"><a href="#cb407-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb407-18"><a href="#cb407-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb407-19"><a href="#cb407-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> t0 = Unix.gettimeofday () <span class="kw">in</span></span>
<span id="cb407-20"><a href="#cb407-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> uts0, hole0 = mk_node (<span class="dt">Some</span> (Resize (w, h)), t0) <span class="kw">in</span></span>
<span id="cb407-21"><a href="#cb407-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> hole : (user_action <span class="dt">option</span> * time) stream <span class="dt">ref</span> <span class="dt">ref</span> = <span class="dt">ref</span> hole0 <span class="kw">in</span></span>
<span id="cb407-22"><a href="#cb407-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> pending = <span class="dt">ref</span> <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb407-23"><a href="#cb407-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> last_time = <span class="dt">ref</span> t0 <span class="kw">in</span></span>
<span id="cb407-24"><a href="#cb407-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb407-25"><a href="#cb407-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> append_input (x : user_action <span class="dt">option</span> * time) =</span>
<span id="cb407-26"><a href="#cb407-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> node, next = mk_node x <span class="kw">in</span></span>
<span id="cb407-27"><a href="#cb407-27" aria-hidden="true" tabindex="-1"></a>    (!hole) := node;</span>
<span id="cb407-28"><a href="#cb407-28" aria-hidden="true" tabindex="-1"></a>    hole := next;</span>
<span id="cb407-29"><a href="#cb407-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">incr</span> pending</span>
<span id="cb407-30"><a href="#cb407-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb407-31"><a href="#cb407-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb407-32"><a href="#cb407-32" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* Keep physics stable even if the GUI stalls: subdivide large dt. *)</span></span>
<span id="cb407-33"><a href="#cb407-33" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> advance_time_to (t : time) =</span>
<span id="cb407-34"><a href="#cb407-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> t &lt;= !last_time <span class="kw">then</span> ()</span>
<span id="cb407-35"><a href="#cb407-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="kw">begin</span></span>
<span id="cb407-36"><a href="#cb407-36" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> max_step = <span class="fl">1.0</span> /. <span class="fl">240.0</span> <span class="kw">in</span></span>
<span id="cb407-37"><a href="#cb407-37" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> max_catchup = <span class="fl">0.25</span> <span class="kw">in</span></span>
<span id="cb407-38"><a href="#cb407-38" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> target = <span class="dt">min</span> t (!last_time +. max_catchup) <span class="kw">in</span></span>
<span id="cb407-39"><a href="#cb407-39" aria-hidden="true" tabindex="-1"></a>      <span class="kw">while</span> !last_time +. <span class="fl">1e-9</span> &lt; target <span class="kw">do</span></span>
<span id="cb407-40"><a href="#cb407-40" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> dt = <span class="dt">min</span> max_step (target -. !last_time) <span class="kw">in</span></span>
<span id="cb407-41"><a href="#cb407-41" aria-hidden="true" tabindex="-1"></a>        last_time := !last_time +. dt;</span>
<span id="cb407-42"><a href="#cb407-42" aria-hidden="true" tabindex="-1"></a>        append_input (<span class="dt">None</span>, !last_time)</span>
<span id="cb407-43"><a href="#cb407-43" aria-hidden="true" tabindex="-1"></a>      <span class="kw">done</span></span>
<span id="cb407-44"><a href="#cb407-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb407-45"><a href="#cb407-45" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb407-46"><a href="#cb407-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb407-47"><a href="#cb407-47" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* Consume the scene stream one step per input element. *)</span></span>
<span id="cb407-48"><a href="#cb407-48" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> scenes = scene $ uts0 <span class="kw">in</span></span>
<span id="cb407-49"><a href="#cb407-49" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> Cons (sc0, tail0) = <span class="dt">Lazy</span>.force scenes <span class="kw">in</span></span>
<span id="cb407-50"><a href="#cb407-50" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> scene_cursor = <span class="dt">ref</span> tail0 <span class="kw">in</span></span>
<span id="cb407-51"><a href="#cb407-51" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> current = <span class="dt">ref</span> sc0 <span class="kw">in</span></span>
<span id="cb407-52"><a href="#cb407-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb407-53"><a href="#cb407-53" aria-hidden="true" tabindex="-1"></a>  Sdl_area.add area (<span class="kw">fun</span> _renderer -&gt;</span>
<span id="cb407-54"><a href="#cb407-54" aria-hidden="true" tabindex="-1"></a>    Sdl_area.fill_rectangle area ~color:(Draw.opaque Draw.grey)</span>
<span id="cb407-55"><a href="#cb407-55" aria-hidden="true" tabindex="-1"></a>      ~w ~h (<span class="dv">0</span>, <span class="dv">0</span>);</span>
<span id="cb407-56"><a href="#cb407-56" aria-hidden="true" tabindex="-1"></a>    <span class="kw">while</span> !pending &gt; <span class="dv">0</span> <span class="kw">do</span></span>
<span id="cb407-57"><a href="#cb407-57" aria-hidden="true" tabindex="-1"></a>      <span class="dt">decr</span> pending;</span>
<span id="cb407-58"><a href="#cb407-58" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> Cons (sc, rest) = <span class="dt">Lazy</span>.force !scene_cursor <span class="kw">in</span></span>
<span id="cb407-59"><a href="#cb407-59" aria-hidden="true" tabindex="-1"></a>      current := sc;</span>
<span id="cb407-60"><a href="#cb407-60" aria-hidden="true" tabindex="-1"></a>      scene_cursor := rest</span>
<span id="cb407-61"><a href="#cb407-61" aria-hidden="true" tabindex="-1"></a>    <span class="kw">done</span>;</span>
<span id="cb407-62"><a href="#cb407-62" aria-hidden="true" tabindex="-1"></a>    draw area ~h !current);</span>
<span id="cb407-63"><a href="#cb407-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb407-64"><a href="#cb407-64" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> layout = Layout.resident area_widget <span class="kw">in</span></span>
<span id="cb407-65"><a href="#cb407-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb407-66"><a href="#cb407-66" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> action _w _l ev =</span>
<span id="cb407-67"><a href="#cb407-67" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> mx, my = Mouse.pointer_pos ev <span class="kw">in</span></span>
<span id="cb407-68"><a href="#cb407-68" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> t = Unix.gettimeofday () <span class="kw">in</span></span>
<span id="cb407-69"><a href="#cb407-69" aria-hidden="true" tabindex="-1"></a>    advance_time_to t;</span>
<span id="cb407-70"><a href="#cb407-70" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* Mouse movement updates the paddle; time was advanced above. *)</span></span>
<span id="cb407-71"><a href="#cb407-71" aria-hidden="true" tabindex="-1"></a>    append_input (<span class="dt">Some</span> (MouseMove (mx, my)), !last_time);</span>
<span id="cb407-72"><a href="#cb407-72" aria-hidden="true" tabindex="-1"></a>    Sdl_area.update area</span>
<span id="cb407-73"><a href="#cb407-73" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb407-74"><a href="#cb407-74" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> connection =</span>
<span id="cb407-75"><a href="#cb407-75" aria-hidden="true" tabindex="-1"></a>    Widget.connect area_widget area_widget action Trigger.pointer_motion</span>
<span id="cb407-76"><a href="#cb407-76" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb407-77"><a href="#cb407-77" aria-hidden="true" tabindex="-1"></a>  Widget.add_connection area_widget connection;</span>
<span id="cb407-78"><a href="#cb407-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb407-79"><a href="#cb407-79" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> tick () =</span>
<span id="cb407-80"><a href="#cb407-80" aria-hidden="true" tabindex="-1"></a>    advance_time_to (Unix.gettimeofday ());</span>
<span id="cb407-81"><a href="#cb407-81" aria-hidden="true" tabindex="-1"></a>    Sdl_area.update area;</span>
<span id="cb407-82"><a href="#cb407-82" aria-hidden="true" tabindex="-1"></a>    Widget.update area_widget;</span>
<span id="cb407-83"><a href="#cb407-83" aria-hidden="true" tabindex="-1"></a>    Timeout.add_ignore <span class="dv">16</span> tick</span>
<span id="cb407-84"><a href="#cb407-84" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb407-85"><a href="#cb407-85" aria-hidden="true" tabindex="-1"></a>  Timeout.add_ignore <span class="dv">16</span> tick;</span>
<span id="cb407-86"><a href="#cb407-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb407-87"><a href="#cb407-87" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> board = Main.of_layout layout <span class="kw">in</span></span>
<span id="cb407-88"><a href="#cb407-88" aria-hidden="true" tabindex="-1"></a>  Main.run board</span></code></pre></div>
<p>The stream-based implementation is elegant but has a limitation: in
strict OCaml, recursive signal definitions require care. In the ball
example we “tie the knot” at the level of <code>memo1</code> records (so
recursion is in <em>data</em>, not immediate function calls), and we
rely on the integrator to introduce the one-step delay that makes the
dependency causal. In a lazy language like Haskell, the same kind of
recursive definition often reads more directly, but it still needs a
delay to be meaningful.</p>
<h2 id="frp-by-incremental-computing-lwd">10.6 FRP by Incremental
Computing (Lwd)</h2>
<p>The stream-processing implementation from Section 10.5 makes time
explicit and computes signals by consuming an input stream. An
alternative is to let an incremental engine maintain the dependency
graph for you, and to put “time” and “inputs” into mutable cells.</p>
<p>This is the same picture as Section 10.3:</p>
<ol type="1">
<li><strong>Inputs</strong> live in mutable variables
(<code>Lwd.var</code>).</li>
<li><strong>Derived signals</strong> are pure computations over those
vars (<code>Lwd.map</code>, <code>Lwd.map2</code>,
<code>Lwd.join</code>, …).</li>
<li>The host program chooses an <strong>update step</strong> and samples
a root once per step.</li>
</ol>
<p>This “one sample per step” discipline establishes an <strong>update
cycle</strong>:</p>
<ul>
<li>You may update many input vars; the step ends when you sample the
root.</li>
<li>Inputs updated within the same step are treated as
<strong>simultaneous</strong> (one consistent snapshot).</li>
<li>Glitch-freedom – do not interleave “half-updated inputs” with
sampling: set everything first, then sample once.</li>
</ul>
<h3 id="mapping-frp-concepts-to-lwd">Mapping FRP Concepts to Lwd</h3>
<p>A useful correspondence is:</p>
<ul>
<li><strong>Behavior</strong>: <code>'a Lwd.t</code></li>
<li><strong>Event</strong>: <code>'a option Lwd.t</code> (a pulse) or a
queue/list carried by a var</li>
<li><strong>Observer/root</strong>: <code>'a Lwd.root</code></li>
</ul>
<div class="sourceCode" id="cb408"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb408-1"><a href="#cb408-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> LwdFrp = <span class="kw">struct</span></span>
<span id="cb408-2"><a href="#cb408-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a behavior = &#39;a Lwd.t</span>
<span id="cb408-3"><a href="#cb408-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a event = &#39;a <span class="dt">option</span> Lwd.t</span>
<span id="cb408-4"><a href="#cb408-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb408-5"><a href="#cb408-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> returnB = Lwd.return</span>
<span id="cb408-6"><a href="#cb408-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> mapB = Lwd.map</span>
<span id="cb408-7"><a href="#cb408-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> mapB2 = Lwd.map2</span>
<span id="cb408-8"><a href="#cb408-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb408-9"><a href="#cb408-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> mapE e ~f = Lwd.map e ~f:(<span class="dt">Option</span>.map f)</span>
<span id="cb408-10"><a href="#cb408-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> filterE e ~f =</span>
<span id="cb408-11"><a href="#cb408-11" aria-hidden="true" tabindex="-1"></a>    Lwd.map e ~f:(<span class="kw">function</span> <span class="dt">None</span> -&gt; <span class="dt">None</span> | <span class="dt">Some</span> x -&gt; f x)</span>
<span id="cb408-12"><a href="#cb408-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb408-13"><a href="#cb408-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> mergeE a b =</span>
<span id="cb408-14"><a href="#cb408-14" aria-hidden="true" tabindex="-1"></a>    Lwd.map2 a b ~f:(<span class="kw">fun</span> a b -&gt; <span class="kw">match</span> a <span class="kw">with</span> <span class="dt">Some</span> _ -&gt; a | <span class="dt">None</span> -&gt; b)</span>
<span id="cb408-15"><a href="#cb408-15" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p><code>Lwd</code> does not have a built-in notion of time; you supply
one (usually as a <code>float</code> variable updated each frame):</p>
<div class="sourceCode" id="cb409"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb409-1"><a href="#cb409-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> time_v : <span class="dt">float</span> Lwd.var = Lwd.var <span class="fl">0.0</span></span>
<span id="cb409-2"><a href="#cb409-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> time_b : <span class="dt">float</span> Lwd.t = Lwd.get time_v</span>
<span id="cb409-3"><a href="#cb409-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb409-4"><a href="#cb409-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> mouse_v : (<span class="dt">int</span> * <span class="dt">int</span>) Lwd.var = Lwd.var (<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb409-5"><a href="#cb409-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> mouse_b : (<span class="dt">int</span> * <span class="dt">int</span>) Lwd.t = Lwd.get mouse_v</span>
<span id="cb409-6"><a href="#cb409-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> mouse_x : <span class="dt">int</span> Lwd.t = Lwd.map mouse_b ~f:<span class="dt">fst</span></span>
<span id="cb409-7"><a href="#cb409-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> mouse_y : <span class="dt">int</span> Lwd.t = Lwd.map mouse_b ~f:<span class="dt">snd</span></span></code></pre></div>
<h3 id="events-as-pulses-and-a-caveat">Events as Pulses (and a
Caveat)</h3>
<p>The simplest event representation is a one-step pulse:</p>
<div class="sourceCode" id="cb410"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb410-1"><a href="#cb410-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> click_v : <span class="dt">unit</span> <span class="dt">option</span> Lwd.var = Lwd.var <span class="dt">None</span></span>
<span id="cb410-2"><a href="#cb410-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> click_e : <span class="dt">unit</span> <span class="dt">option</span> Lwd.t = Lwd.get click_v</span></code></pre></div>
<p>In the host program, you set <code>click_v</code> to
<code>Some ()</code> for one update step and then clear it to
<code>None</code> after sampling. This gives you “happened this step?”
semantics.</p>
<p>The caveat: if many events can occur between samples, a single
<code>option</code> cell will lose information. In that case, represent
events as a list/queue (e.g. <code>user_action list</code>) accumulated
by the host program and drained once per step.</p>
<p>One more practical rule: keep mutations (<code>Lwd.set</code>) in the
host program. If a derived signal needs to “request” an output event,
model that request as data (e.g. return <code>Some msg</code>) and let
the host send it on the next step.</p>
<h3 id="stateful-signal-combinators-one-step-memory">Stateful Signal
Combinators (One-Step Memory)</h3>
<p>In FRP, feedback loops require <em>delay</em> (“previous value”). In
a stream-based model, delay falls out of stream processing. With
incremental engines, you can implement the same idea with a bit of
internal state.</p>
<p>Here are two classic combinators implemented with internal
references. They are intentionally “single-sample” oriented: sample once
per step.</p>
<div class="sourceCode" id="cb411"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb411-1"><a href="#cb411-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* step: hold the last event value, starting from [init] *)</span></span>
<span id="cb411-2"><a href="#cb411-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> step (init : &#39;a) (e : &#39;a <span class="dt">option</span> Lwd.t) : &#39;a Lwd.t =</span>
<span id="cb411-3"><a href="#cb411-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> last = <span class="dt">ref</span> init <span class="kw">in</span></span>
<span id="cb411-4"><a href="#cb411-4" aria-hidden="true" tabindex="-1"></a>  Lwd.map e ~f:(<span class="kw">function</span></span>
<span id="cb411-5"><a href="#cb411-5" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">None</span> -&gt; !last</span>
<span id="cb411-6"><a href="#cb411-6" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> v -&gt; last := v; v)</span>
<span id="cb411-7"><a href="#cb411-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb411-8"><a href="#cb411-8" aria-hidden="true" tabindex="-1"></a><span class="co">(* rising_edge: None most of the time, Some () exactly when b flips false-&gt;true *)</span></span>
<span id="cb411-9"><a href="#cb411-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> rising_edge (b : <span class="dt">bool</span> Lwd.t) : <span class="dt">unit</span> <span class="dt">option</span> Lwd.t =</span>
<span id="cb411-10"><a href="#cb411-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> was_true = <span class="dt">ref</span> <span class="kw">false</span> <span class="kw">in</span></span>
<span id="cb411-11"><a href="#cb411-11" aria-hidden="true" tabindex="-1"></a>  Lwd.map b ~f:(<span class="kw">fun</span> now -&gt;</span>
<span id="cb411-12"><a href="#cb411-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> fire = now &amp;&amp; <span class="dt">not</span> !was_true <span class="kw">in</span></span>
<span id="cb411-13"><a href="#cb411-13" aria-hidden="true" tabindex="-1"></a>    was_true := now;</span>
<span id="cb411-14"><a href="#cb411-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> fire <span class="kw">then</span> <span class="dt">Some</span> () <span class="kw">else</span> <span class="dt">None</span>)</span></code></pre></div>
<p>These are not “pure” in the mathematical FRP sense, but they capture
a key idea: <strong>signals can have local memory</strong>, and that
memory is exactly what causality demands.</p>
<h3 id="integration-discrete-time">Integration (Discrete Time)</h3>
<p>We can also integrate a velocity signal by accumulating over time.
This is effectively a discrete-time integrator driven by your chosen
update step:</p>
<div class="sourceCode" id="cb412"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb412-1"><a href="#cb412-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> integral (v : <span class="dt">float</span> Lwd.t) (t : <span class="dt">float</span> Lwd.t) : <span class="dt">float</span> Lwd.t =</span>
<span id="cb412-2"><a href="#cb412-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> acc = <span class="dt">ref</span> <span class="fl">0.0</span> <span class="kw">in</span></span>
<span id="cb412-3"><a href="#cb412-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> prev_t = <span class="dt">ref</span> <span class="fl">0.0</span> <span class="kw">in</span></span>
<span id="cb412-4"><a href="#cb412-4" aria-hidden="true" tabindex="-1"></a>  Lwd.map2 v t ~f:(<span class="kw">fun</span> v t -&gt;</span>
<span id="cb412-5"><a href="#cb412-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> dt = t -. !prev_t <span class="kw">in</span></span>
<span id="cb412-6"><a href="#cb412-6" aria-hidden="true" tabindex="-1"></a>    prev_t := t;</span>
<span id="cb412-7"><a href="#cb412-7" aria-hidden="true" tabindex="-1"></a>    acc := !acc +. dt *. v;</span>
<span id="cb412-8"><a href="#cb412-8" aria-hidden="true" tabindex="-1"></a>    !acc)</span></code></pre></div>
<h3 id="example-reimplementing-the-paddle-scene-with-lwd">Example:
Reimplementing the Paddle Scene with Lwd</h3>
<p>We reuse the <code>scene</code> type and <code>draw</code> function
from Section 10.5. The idea is:</p>
<ul>
<li>treat <code>mouse_x</code>, <code>width</code>, <code>height</code>,
<code>time</code> as input behaviors,</li>
<li>build a reactive scene graph as an <code>Lwd.t</code>,</li>
<li>sample and draw once per frame.</li>
</ul>
<div class="sourceCode" id="cb413"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb413-1"><a href="#cb413-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> time_v : <span class="dt">float</span> Lwd.var = Lwd.var <span class="fl">0.0</span></span>
<span id="cb413-2"><a href="#cb413-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> time_b : <span class="dt">float</span> Lwd.t = Lwd.get time_v</span>
<span id="cb413-3"><a href="#cb413-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb413-4"><a href="#cb413-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> mouse_v : (<span class="dt">int</span> * <span class="dt">int</span>) Lwd.var = Lwd.var (<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb413-5"><a href="#cb413-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> mouse_x : <span class="dt">int</span> Lwd.t = Lwd.map (Lwd.get mouse_v) ~f:<span class="dt">fst</span></span>
<span id="cb413-6"><a href="#cb413-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb413-7"><a href="#cb413-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> width_v : <span class="dt">int</span> Lwd.var = Lwd.var <span class="dv">640</span></span>
<span id="cb413-8"><a href="#cb413-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> height_v : <span class="dt">int</span> Lwd.var = Lwd.var <span class="dv">512</span></span>
<span id="cb413-9"><a href="#cb413-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> width : <span class="dt">int</span> Lwd.t = Lwd.get width_v</span>
<span id="cb413-10"><a href="#cb413-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> height : <span class="dt">int</span> Lwd.t = Lwd.get height_v</span>
<span id="cb413-11"><a href="#cb413-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb413-12"><a href="#cb413-12" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> blue = (<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">255</span>)</span>
<span id="cb413-13"><a href="#cb413-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> black = (<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb413-14"><a href="#cb413-14" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> red = (<span class="dv">255</span>, <span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb413-15"><a href="#cb413-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb413-16"><a href="#cb413-16" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> clamp_int ~lo ~hi x = <span class="dt">max</span> lo (<span class="dt">min</span> hi x)</span>
<span id="cb413-17"><a href="#cb413-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb413-18"><a href="#cb413-18" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> wall_thickness = <span class="dv">20</span></span>
<span id="cb413-19"><a href="#cb413-19" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ball_r = <span class="dv">7</span></span>
<span id="cb413-20"><a href="#cb413-20" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> paddle_w = <span class="dv">70</span></span>
<span id="cb413-21"><a href="#cb413-21" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> paddle_h = <span class="dv">10</span></span>
<span id="cb413-22"><a href="#cb413-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb413-23"><a href="#cb413-23" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> walls : scene Lwd.t =</span>
<span id="cb413-24"><a href="#cb413-24" aria-hidden="true" tabindex="-1"></a>  Lwd.map2 width height ~f:(<span class="kw">fun</span> w h -&gt;</span>
<span id="cb413-25"><a href="#cb413-25" aria-hidden="true" tabindex="-1"></a>    Color (blue, Group</span>
<span id="cb413-26"><a href="#cb413-26" aria-hidden="true" tabindex="-1"></a>      [Rect (<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">20</span>, h<span class="dv">-1</span>); Rect (<span class="dv">0</span>, h<span class="dv">-21</span>, w<span class="dv">-1</span>, <span class="dv">20</span>);</span>
<span id="cb413-27"><a href="#cb413-27" aria-hidden="true" tabindex="-1"></a>       Rect (w<span class="dv">-21</span>, <span class="dv">0</span>, <span class="dv">20</span>, h<span class="dv">-1</span>)]))</span>
<span id="cb413-28"><a href="#cb413-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb413-29"><a href="#cb413-29" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> paddle_x : <span class="dt">int</span> Lwd.t =</span>
<span id="cb413-30"><a href="#cb413-30" aria-hidden="true" tabindex="-1"></a>  Lwd.map2 mouse_x width ~f:(<span class="kw">fun</span> mx w -&gt;</span>
<span id="cb413-31"><a href="#cb413-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> lo = wall_thickness <span class="kw">in</span></span>
<span id="cb413-32"><a href="#cb413-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> hi = <span class="dt">max</span> lo (w - <span class="dv">21</span> - paddle_w) <span class="kw">in</span></span>
<span id="cb413-33"><a href="#cb413-33" aria-hidden="true" tabindex="-1"></a>    clamp_int ~lo ~hi (mx - (paddle_w / <span class="dv">2</span>)))</span>
<span id="cb413-34"><a href="#cb413-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb413-35"><a href="#cb413-35" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> paddle : scene Lwd.t =</span>
<span id="cb413-36"><a href="#cb413-36" aria-hidden="true" tabindex="-1"></a>  Lwd.map paddle_x ~f:(<span class="kw">fun</span> px -&gt;</span>
<span id="cb413-37"><a href="#cb413-37" aria-hidden="true" tabindex="-1"></a>    Color (black, Rect (px, <span class="dv">0</span>, paddle_w, paddle_h)))</span>
<span id="cb413-38"><a href="#cb413-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb413-39"><a href="#cb413-39" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> ball_state =</span>
<span id="cb413-40"><a href="#cb413-40" aria-hidden="true" tabindex="-1"></a>  { <span class="kw">mutable</span> x : <span class="dt">float</span></span>
<span id="cb413-41"><a href="#cb413-41" aria-hidden="true" tabindex="-1"></a>  ; <span class="kw">mutable</span> y : <span class="dt">float</span></span>
<span id="cb413-42"><a href="#cb413-42" aria-hidden="true" tabindex="-1"></a>  ; <span class="kw">mutable</span> vx : <span class="dt">float</span></span>
<span id="cb413-43"><a href="#cb413-43" aria-hidden="true" tabindex="-1"></a>  ; <span class="kw">mutable</span> vy : <span class="dt">float</span></span>
<span id="cb413-44"><a href="#cb413-44" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb413-45"><a href="#cb413-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb413-46"><a href="#cb413-46" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ball : scene Lwd.t =</span>
<span id="cb413-47"><a href="#cb413-47" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> st : ball_state = { x = <span class="fl">0.0</span>; y = <span class="fl">0.0</span>; vx = <span class="fl">120.0</span>; vy = <span class="fl">160.0</span> } <span class="kw">in</span></span>
<span id="cb413-48"><a href="#cb413-48" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> prev_t : <span class="dt">float</span> <span class="dt">option</span> <span class="dt">ref</span> = <span class="dt">ref</span> <span class="dt">None</span> <span class="kw">in</span></span>
<span id="cb413-49"><a href="#cb413-49" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> prev_wh : (<span class="dt">int</span> * <span class="dt">int</span>) <span class="dt">option</span> <span class="dt">ref</span> = <span class="dt">ref</span> <span class="dt">None</span> <span class="kw">in</span></span>
<span id="cb413-50"><a href="#cb413-50" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> dir : <span class="dt">float</span> <span class="dt">ref</span> = <span class="dt">ref</span> <span class="fl">1.0</span> <span class="kw">in</span></span>
<span id="cb413-51"><a href="#cb413-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb413-52"><a href="#cb413-52" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> reset ~w ~h =</span>
<span id="cb413-53"><a href="#cb413-53" aria-hidden="true" tabindex="-1"></a>    st.x &lt;- <span class="dt">float_of_int</span> w /. <span class="fl">2.0</span>;</span>
<span id="cb413-54"><a href="#cb413-54" aria-hidden="true" tabindex="-1"></a>    st.y &lt;- <span class="dt">float_of_int</span> h /. <span class="fl">2.0</span>;</span>
<span id="cb413-55"><a href="#cb413-55" aria-hidden="true" tabindex="-1"></a>    st.vx &lt;- !dir *. <span class="fl">120.0</span>;</span>
<span id="cb413-56"><a href="#cb413-56" aria-hidden="true" tabindex="-1"></a>    st.vy &lt;- <span class="fl">180.0</span>;</span>
<span id="cb413-57"><a href="#cb413-57" aria-hidden="true" tabindex="-1"></a>    dir := -. !dir</span>
<span id="cb413-58"><a href="#cb413-58" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb413-59"><a href="#cb413-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb413-60"><a href="#cb413-60" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> clamp_float ~lo ~hi x = <span class="dt">max</span> lo (<span class="dt">min</span> hi x) <span class="kw">in</span></span>
<span id="cb413-61"><a href="#cb413-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb413-62"><a href="#cb413-62" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> step_physics ~w ~h ~paddle_x ~dt =</span>
<span id="cb413-63"><a href="#cb413-63" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> max_step = <span class="fl">1.0</span> /. <span class="fl">240.0</span> <span class="kw">in</span></span>
<span id="cb413-64"><a href="#cb413-64" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> paddle_plane = <span class="dt">float_of_int</span> (paddle_h + ball_r) <span class="kw">in</span></span>
<span id="cb413-65"><a href="#cb413-65" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> xmin = <span class="dt">float_of_int</span> (wall_thickness + ball_r) <span class="kw">in</span></span>
<span id="cb413-66"><a href="#cb413-66" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> xmax = <span class="dt">float_of_int</span> (<span class="dt">max</span> (wall_thickness + ball_r) (w - <span class="dv">21</span> - ball_r)) <span class="kw">in</span></span>
<span id="cb413-67"><a href="#cb413-67" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> ymax = <span class="dt">float_of_int</span> (<span class="dt">max</span> (paddle_h + ball_r) (h - <span class="dv">21</span> - ball_r)) <span class="kw">in</span></span>
<span id="cb413-68"><a href="#cb413-68" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> max_speed = <span class="fl">500.0</span> <span class="kw">in</span></span>
<span id="cb413-69"><a href="#cb413-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb413-70"><a href="#cb413-70" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">rec</span> loop remaining =</span>
<span id="cb413-71"><a href="#cb413-71" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> remaining &lt;= <span class="fl">0.0</span> <span class="kw">then</span> ()</span>
<span id="cb413-72"><a href="#cb413-72" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> <span class="kw">begin</span></span>
<span id="cb413-73"><a href="#cb413-73" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> dt1 = <span class="dt">min</span> max_step remaining <span class="kw">in</span></span>
<span id="cb413-74"><a href="#cb413-74" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x0, y0 = st.x, st.y <span class="kw">in</span></span>
<span id="cb413-75"><a href="#cb413-75" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x1 = x0 +. dt1 *. st.vx <span class="kw">in</span></span>
<span id="cb413-76"><a href="#cb413-76" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> y1 = y0 +. dt1 *. st.vy <span class="kw">in</span></span>
<span id="cb413-77"><a href="#cb413-77" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x1, vx =</span>
<span id="cb413-78"><a href="#cb413-78" aria-hidden="true" tabindex="-1"></a>          <span class="kw">if</span> x1 &lt; xmin <span class="kw">then</span> (xmin +. (xmin -. x1), -. st.vx)</span>
<span id="cb413-79"><a href="#cb413-79" aria-hidden="true" tabindex="-1"></a>          <span class="kw">else</span> <span class="kw">if</span> x1 &gt; xmax <span class="kw">then</span> (xmax -. (x1 -. xmax), -. st.vx)</span>
<span id="cb413-80"><a href="#cb413-80" aria-hidden="true" tabindex="-1"></a>          <span class="kw">else</span> (x1, st.vx)</span>
<span id="cb413-81"><a href="#cb413-81" aria-hidden="true" tabindex="-1"></a>        <span class="kw">in</span></span>
<span id="cb413-82"><a href="#cb413-82" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> y1, vy =</span>
<span id="cb413-83"><a href="#cb413-83" aria-hidden="true" tabindex="-1"></a>          <span class="kw">if</span> y1 &gt; ymax <span class="kw">then</span> (ymax -. (y1 -. ymax), -. st.vy)</span>
<span id="cb413-84"><a href="#cb413-84" aria-hidden="true" tabindex="-1"></a>          <span class="kw">else</span> (y1, st.vy)</span>
<span id="cb413-85"><a href="#cb413-85" aria-hidden="true" tabindex="-1"></a>        <span class="kw">in</span></span>
<span id="cb413-86"><a href="#cb413-86" aria-hidden="true" tabindex="-1"></a>        st.x &lt;- x1;</span>
<span id="cb413-87"><a href="#cb413-87" aria-hidden="true" tabindex="-1"></a>        st.y &lt;- y1;</span>
<span id="cb413-88"><a href="#cb413-88" aria-hidden="true" tabindex="-1"></a>        st.vx &lt;- vx;</span>
<span id="cb413-89"><a href="#cb413-89" aria-hidden="true" tabindex="-1"></a>        st.vy &lt;- vy;</span>
<span id="cb413-90"><a href="#cb413-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb413-91"><a href="#cb413-91" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> st.vy &lt; <span class="fl">0.0</span> &amp;&amp; y0 &gt;= paddle_plane &amp;&amp; st.y &lt; paddle_plane <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb413-92"><a href="#cb413-92" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> alpha = (y0 -. paddle_plane) /. (y0 -. st.y) <span class="kw">in</span></span>
<span id="cb413-93"><a href="#cb413-93" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> x_hit = x0 +. alpha *. (st.x -. x0) <span class="kw">in</span></span>
<span id="cb413-94"><a href="#cb413-94" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> paddle_left = <span class="dt">float_of_int</span> paddle_x -. <span class="dt">float_of_int</span> ball_r <span class="kw">in</span></span>
<span id="cb413-95"><a href="#cb413-95" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> paddle_right =</span>
<span id="cb413-96"><a href="#cb413-96" aria-hidden="true" tabindex="-1"></a>            <span class="dt">float_of_int</span> (paddle_x + paddle_w) +. <span class="dt">float_of_int</span> ball_r</span>
<span id="cb413-97"><a href="#cb413-97" aria-hidden="true" tabindex="-1"></a>          <span class="kw">in</span></span>
<span id="cb413-98"><a href="#cb413-98" aria-hidden="true" tabindex="-1"></a>          <span class="kw">if</span> x_hit &gt;= paddle_left &amp;&amp; x_hit &lt;= paddle_right <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb413-99"><a href="#cb413-99" aria-hidden="true" tabindex="-1"></a>            st.y &lt;- paddle_plane +. (paddle_plane -. st.y);</span>
<span id="cb413-100"><a href="#cb413-100" aria-hidden="true" tabindex="-1"></a>            st.vy &lt;- <span class="dt">abs_float</span> st.vy;</span>
<span id="cb413-101"><a href="#cb413-101" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> paddle_center =</span>
<span id="cb413-102"><a href="#cb413-102" aria-hidden="true" tabindex="-1"></a>              <span class="dt">float_of_int</span> paddle_x +. (<span class="dt">float_of_int</span> paddle_w /. <span class="fl">2.0</span>)</span>
<span id="cb413-103"><a href="#cb413-103" aria-hidden="true" tabindex="-1"></a>            <span class="kw">in</span></span>
<span id="cb413-104"><a href="#cb413-104" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> offset =</span>
<span id="cb413-105"><a href="#cb413-105" aria-hidden="true" tabindex="-1"></a>              (x_hit -. paddle_center) /. (<span class="dt">float_of_int</span> paddle_w /. <span class="fl">2.0</span>)</span>
<span id="cb413-106"><a href="#cb413-106" aria-hidden="true" tabindex="-1"></a>              |&gt; clamp_float ~lo:(<span class="fl">-1.0</span>) ~hi:<span class="fl">1.0</span></span>
<span id="cb413-107"><a href="#cb413-107" aria-hidden="true" tabindex="-1"></a>            <span class="kw">in</span></span>
<span id="cb413-108"><a href="#cb413-108" aria-hidden="true" tabindex="-1"></a>            st.vx &lt;- clamp_float ~lo:(-.max_speed) ~hi:max_speed (st.vx +. offset *. <span class="fl">120.0</span>)</span>
<span id="cb413-109"><a href="#cb413-109" aria-hidden="true" tabindex="-1"></a>          <span class="kw">end</span> <span class="kw">else</span> (</span>
<span id="cb413-110"><a href="#cb413-110" aria-hidden="true" tabindex="-1"></a>            reset ~w ~h</span>
<span id="cb413-111"><a href="#cb413-111" aria-hidden="true" tabindex="-1"></a>          )</span>
<span id="cb413-112"><a href="#cb413-112" aria-hidden="true" tabindex="-1"></a>        <span class="kw">end</span> <span class="kw">else</span> <span class="kw">if</span> st.y &lt; <span class="fl">-50.0</span> <span class="kw">then</span> (</span>
<span id="cb413-113"><a href="#cb413-113" aria-hidden="true" tabindex="-1"></a>          reset ~w ~h</span>
<span id="cb413-114"><a href="#cb413-114" aria-hidden="true" tabindex="-1"></a>        );</span>
<span id="cb413-115"><a href="#cb413-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb413-116"><a href="#cb413-116" aria-hidden="true" tabindex="-1"></a>        st.vx &lt;- clamp_float ~lo:(-.max_speed) ~hi:max_speed st.vx;</span>
<span id="cb413-117"><a href="#cb413-117" aria-hidden="true" tabindex="-1"></a>        st.vy &lt;- clamp_float ~lo:(-.max_speed) ~hi:max_speed st.vy;</span>
<span id="cb413-118"><a href="#cb413-118" aria-hidden="true" tabindex="-1"></a>        loop (remaining -. dt1)</span>
<span id="cb413-119"><a href="#cb413-119" aria-hidden="true" tabindex="-1"></a>      <span class="kw">end</span></span>
<span id="cb413-120"><a href="#cb413-120" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span></span>
<span id="cb413-121"><a href="#cb413-121" aria-hidden="true" tabindex="-1"></a>    loop dt</span>
<span id="cb413-122"><a href="#cb413-122" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb413-123"><a href="#cb413-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb413-124"><a href="#cb413-124" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> inputs : (<span class="dt">int</span> * <span class="dt">int</span> * <span class="dt">int</span> * <span class="dt">float</span>) Lwd.t =</span>
<span id="cb413-125"><a href="#cb413-125" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> wh_px : ((<span class="dt">int</span> * <span class="dt">int</span>) * <span class="dt">int</span>) Lwd.t =</span>
<span id="cb413-126"><a href="#cb413-126" aria-hidden="true" tabindex="-1"></a>      Lwd.pair (Lwd.pair width height) paddle_x</span>
<span id="cb413-127"><a href="#cb413-127" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span></span>
<span id="cb413-128"><a href="#cb413-128" aria-hidden="true" tabindex="-1"></a>    Lwd.map2 wh_px time_b ~f:(<span class="kw">fun</span> ((w, h), px) t -&gt; (w, h, px, t))</span>
<span id="cb413-129"><a href="#cb413-129" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb413-130"><a href="#cb413-130" aria-hidden="true" tabindex="-1"></a>  Lwd.map inputs ~f:(<span class="kw">fun</span> (w, h, px, t) -&gt;</span>
<span id="cb413-131"><a href="#cb413-131" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">match</span> !prev_wh <span class="kw">with</span></span>
<span id="cb413-132"><a href="#cb413-132" aria-hidden="true" tabindex="-1"></a>     | <span class="dt">Some</span> (w0, h0) <span class="kw">when</span> w0 = w &amp;&amp; h0 = h -&gt; ()</span>
<span id="cb413-133"><a href="#cb413-133" aria-hidden="true" tabindex="-1"></a>     | _ -&gt; prev_wh := <span class="dt">Some</span> (w, h); reset ~w ~h);</span>
<span id="cb413-134"><a href="#cb413-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb413-135"><a href="#cb413-135" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> dt =</span>
<span id="cb413-136"><a href="#cb413-136" aria-hidden="true" tabindex="-1"></a>      <span class="kw">match</span> !prev_t <span class="kw">with</span></span>
<span id="cb413-137"><a href="#cb413-137" aria-hidden="true" tabindex="-1"></a>      | <span class="dt">None</span> -&gt; <span class="fl">0.0</span></span>
<span id="cb413-138"><a href="#cb413-138" aria-hidden="true" tabindex="-1"></a>      | <span class="dt">Some</span> t0 -&gt;</span>
<span id="cb413-139"><a href="#cb413-139" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> dt = t -. t0 <span class="kw">in</span></span>
<span id="cb413-140"><a href="#cb413-140" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> dt &lt;= <span class="fl">0.0</span> <span class="kw">then</span> <span class="fl">0.0</span> <span class="kw">else</span> <span class="dt">min</span> dt <span class="fl">0.25</span></span>
<span id="cb413-141"><a href="#cb413-141" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span></span>
<span id="cb413-142"><a href="#cb413-142" aria-hidden="true" tabindex="-1"></a>    prev_t := <span class="dt">Some</span> t;</span>
<span id="cb413-143"><a href="#cb413-143" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> dt &gt; <span class="fl">0.0</span> <span class="kw">then</span> step_physics ~w ~h ~paddle_x:px ~dt;</span>
<span id="cb413-144"><a href="#cb413-144" aria-hidden="true" tabindex="-1"></a>    Color (red, Circle (<span class="dt">int_of_float</span> st.x, <span class="dt">int_of_float</span> st.y, ball_r)))</span>
<span id="cb413-145"><a href="#cb413-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb413-146"><a href="#cb413-146" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> game : scene Lwd.t =</span>
<span id="cb413-147"><a href="#cb413-147" aria-hidden="true" tabindex="-1"></a>  Lwd.map2 walls (Lwd.pair paddle ball) ~f:(<span class="kw">fun</span> w (p, b) -&gt; Group [w; p; b])</span></code></pre></div>
<p>Because <code>ball</code> above uses internal mutable state, you
should sample the root scene <strong>exactly once per update
step</strong> (otherwise the physics will advance multiple times).</p>
<p>Keep the sampled root (and anything you need for its computation)
reachable. In <code>Lwd</code>, nodes not reachable from any root are
considered dead and can be released.</p>
<p>This is “FRP by incremental computing” in a nutshell: the engine
caches and reuses computations in the scene graph; the host program
decides what constitutes a step and updates the input vars
accordingly.</p>
<h3 id="stream-frp-vs.-lwd-frp-a-practical-contrast">Stream FRP vs. Lwd
FRP (A Practical Contrast)</h3>
<ul>
<li>Stream-based FRP is <em>purely functional</em> and makes time
explicit, but in strict OCaml mutual recursion can be awkward.</li>
<li>Lwd-based FRP makes dependency tracking automatic and integrates
naturally with an imperative “main loop”, but stateful signal
combinators must be handled with care (sample once per step; avoid
depending on evaluation order).</li>
</ul>
<h2 id="direct-control-effects">10.7 Direct Control (Effects)</h2>
<p>FRP shines when the program is mostly “wiring”: combine signals,
transform values, render a view. But many interactions are naturally
<strong>staged</strong>:</p>
<ul>
<li>wait for a click,</li>
<li>then track mouse movement until release,</li>
<li>then wait for the next click,</li>
<li>and so on.</li>
</ul>
<p>You <em>can</em> encode staged workflows in pure FRP, but it often
becomes awkward: you start building explicit state machines “in the
large”.</p>
<p>Think of a recipe:</p>
<ol type="1">
<li>preheat the oven,</li>
<li>mix ingredients,</li>
<li>bake,</li>
<li>take out and cool.</li>
</ol>
<p>That is not a static wiring diagram: it is a program that
<em>proceeds through stages</em>. We want a <em>flow</em> that can
proceed through events in sequence: when the first relevant event
arrives, we process it and then wait for the next
event—<strong>ignoring</strong> any further occurrences of the
“earlier-stage” event after we have moved on.</p>
<p>Standard FRP combinators like “map an event” (or “whenever behavior
changes, do …”) are not designed to express this “move forward and never
look back” semantics. In Chapter 9 we learned that algebraic effects let
us express such workflows in <strong>direct style</strong>, while still
keeping the effectful interface abstract and interpretable by different
handlers.</p>
<p>In this section we will reuse the <strong>paddle game</strong> from
Sections 10.5 and 10.6, but we will drive it in direct style using
effects.</p>
<h3 id="an-effect-interface-await-inputs-render-scenes">An Effect
Interface: Await Inputs, Render Scenes</h3>
<p>We separate the <em>script</em> (the staged logic) from the
<em>interpreter</em> (Bogue / headless tests) via a small effect
interface:</p>
<div class="sourceCode" id="cb414"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb414-1"><a href="#cb414-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">input</span> =</span>
<span id="cb414-2"><a href="#cb414-2" aria-hidden="true" tabindex="-1"></a>  | Tick <span class="kw">of</span> <span class="dt">float</span>                 <span class="co">(* dt in seconds *)</span></span>
<span id="cb414-3"><a href="#cb414-3" aria-hidden="true" tabindex="-1"></a>  | User <span class="kw">of</span> user_action</span>
<span id="cb414-4"><a href="#cb414-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb414-5"><a href="#cb414-5" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> _ <span class="dt">Effect</span>.t +=</span>
<span id="cb414-6"><a href="#cb414-6" aria-hidden="true" tabindex="-1"></a>  | Await : (<span class="dt">input</span> -&gt; &#39;a <span class="dt">option</span>) -&gt; &#39;a <span class="dt">Effect</span>.t</span>
<span id="cb414-7"><a href="#cb414-7" aria-hidden="true" tabindex="-1"></a>  | Render : scene -&gt; <span class="dt">unit</span> <span class="dt">Effect</span>.t</span>
<span id="cb414-8"><a href="#cb414-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb414-9"><a href="#cb414-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> await p = <span class="dt">Effect</span>.perform (Await p)</span>
<span id="cb414-10"><a href="#cb414-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> render sc = <span class="dt">Effect</span>.perform (Render sc)</span></code></pre></div>
<p><code>Await p</code> means: “pause until you receive an
<code>input</code> for which <code>p</code> returns <code>Some v</code>,
then resume and return <code>v</code>.” This neatly expresses “ignore
everything else until the thing I’m waiting for happens”. Operationally,
this is the effect-based analog of “the next occurrence of event
<code>e</code>, and only that one”.</p>
<p><code>Render sc</code> is the output side: “send this scene to
whatever display I’m running under”.</p>
<p>We are implementing <em>coarse-grained threads</em> (cooperative
scripts): a script runs in direct style until it reaches
<code>Await</code>, at which point it yields back to the surrounding
driver. There is no explicit <code>Yield</code>: <code>Await</code> is
the suspension point.</p>
<p>Sometimes we need to wait for <em>one of several</em> possible
events. With the predicate-based <code>await</code>, this is a
one-liner:</p>
<div class="sourceCode" id="cb415"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb415-1"><a href="#cb415-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> await_either p q =</span>
<span id="cb415-2"><a href="#cb415-2" aria-hidden="true" tabindex="-1"></a>  await (<span class="kw">fun</span> u -&gt;</span>
<span id="cb415-3"><a href="#cb415-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> p u <span class="kw">with</span></span>
<span id="cb415-4"><a href="#cb415-4" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> a -&gt; <span class="dt">Some</span> (`A a)</span>
<span id="cb415-5"><a href="#cb415-5" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">None</span> -&gt;</span>
<span id="cb415-6"><a href="#cb415-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">match</span> q u <span class="kw">with</span></span>
<span id="cb415-7"><a href="#cb415-7" aria-hidden="true" tabindex="-1"></a>      | <span class="dt">Some</span> b -&gt; <span class="dt">Some</span> (`B b)</span>
<span id="cb415-8"><a href="#cb415-8" aria-hidden="true" tabindex="-1"></a>      | <span class="dt">None</span> -&gt; <span class="dt">None</span>)</span>
<span id="cb415-9"><a href="#cb415-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb415-10"><a href="#cb415-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> race = await_either</span></code></pre></div>
<h3 id="a-driver-step-until-you-need-input">A Driver: “Step Until You
Need Input”</h3>
<p>To integrate a script with a GUI event loop (and to make it
testable), it is useful to <em>step</em> the script until it blocks on
<code>Await</code>, and then resume it only when an input arrives.</p>
<p>One convenient representation is a paused computation that either
finished, or is waiting and provides a function to feed the next input
action:</p>
<div class="sourceCode" id="cb416"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb416-1"><a href="#cb416-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a paused =</span>
<span id="cb416-2"><a href="#cb416-2" aria-hidden="true" tabindex="-1"></a>  | Done <span class="kw">of</span> &#39;a</span>
<span id="cb416-3"><a href="#cb416-3" aria-hidden="true" tabindex="-1"></a>  | Awaiting <span class="kw">of</span> {feed : <span class="dt">input</span> -&gt; &#39;a paused}</span>
<span id="cb416-4"><a href="#cb416-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb416-5"><a href="#cb416-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> step ~(on_render : scene -&gt; <span class="dt">unit</span>) (th : <span class="dt">unit</span> -&gt; &#39;a) : &#39;a paused =</span>
<span id="cb416-6"><a href="#cb416-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Effect</span>.Deep.match_with th () {</span>
<span id="cb416-7"><a href="#cb416-7" aria-hidden="true" tabindex="-1"></a>    retc = (<span class="kw">fun</span> v -&gt; Done v);</span>
<span id="cb416-8"><a href="#cb416-8" aria-hidden="true" tabindex="-1"></a>    exnc = <span class="dt">raise</span>;</span>
<span id="cb416-9"><a href="#cb416-9" aria-hidden="true" tabindex="-1"></a>    effc = <span class="kw">fun</span> (<span class="kw">type</span> c) (eff : c <span class="dt">Effect</span>.t) -&gt;</span>
<span id="cb416-10"><a href="#cb416-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">match</span> eff <span class="kw">with</span></span>
<span id="cb416-11"><a href="#cb416-11" aria-hidden="true" tabindex="-1"></a>      | Render sc -&gt;</span>
<span id="cb416-12"><a href="#cb416-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Some</span> (<span class="kw">fun</span> (k : (c, _) <span class="dt">Effect</span>.Deep.continuation) -&gt;</span>
<span id="cb416-13"><a href="#cb416-13" aria-hidden="true" tabindex="-1"></a>          on_render sc;</span>
<span id="cb416-14"><a href="#cb416-14" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Effect</span>.Deep.continue k ())</span>
<span id="cb416-15"><a href="#cb416-15" aria-hidden="true" tabindex="-1"></a>      | Await p -&gt;</span>
<span id="cb416-16"><a href="#cb416-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Some</span> (<span class="kw">fun</span> (k : (c, _) <span class="dt">Effect</span>.Deep.continuation) -&gt;</span>
<span id="cb416-17"><a href="#cb416-17" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> <span class="kw">rec</span> feed (u : <span class="dt">input</span>) =</span>
<span id="cb416-18"><a href="#cb416-18" aria-hidden="true" tabindex="-1"></a>            <span class="kw">match</span> p u <span class="kw">with</span></span>
<span id="cb416-19"><a href="#cb416-19" aria-hidden="true" tabindex="-1"></a>            | <span class="dt">None</span> -&gt; Awaiting {feed}  <span class="co">(* ignore and keep waiting *)</span></span>
<span id="cb416-20"><a href="#cb416-20" aria-hidden="true" tabindex="-1"></a>            | <span class="dt">Some</span> v -&gt; <span class="dt">Effect</span>.Deep.continue k v</span>
<span id="cb416-21"><a href="#cb416-21" aria-hidden="true" tabindex="-1"></a>          <span class="kw">in</span></span>
<span id="cb416-22"><a href="#cb416-22" aria-hidden="true" tabindex="-1"></a>          Awaiting {feed})</span>
<span id="cb416-23"><a href="#cb416-23" aria-hidden="true" tabindex="-1"></a>      | _ -&gt; <span class="dt">None</span></span>
<span id="cb416-24"><a href="#cb416-24" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>This is the “flow as a lightweight thread” idea, but without a monad:
the state of the thread is the (closed-over) continuation stored inside
<code>feed</code>.</p>
<h3 id="a-handler-replay-a-script-of-inputs-headless">A Handler: Replay
a Script of Inputs (Headless)</h3>
<p>Using the stepping driver, we can interpret <code>Await</code> by
consuming a pre-recorded list of inputs (useful for tests and
examples):</p>
<div class="sourceCode" id="cb417"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb417-1"><a href="#cb417-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> run_script (<span class="kw">type</span> a) ~(inputs : <span class="dt">input</span> <span class="dt">list</span>) ~(on_render : scene -&gt; <span class="dt">unit</span>)</span>
<span id="cb417-2"><a href="#cb417-2" aria-hidden="true" tabindex="-1"></a>    (f : <span class="dt">unit</span> -&gt; a) : a =</span>
<span id="cb417-3"><a href="#cb417-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> drive (st : a paused) (inputs : <span class="dt">input</span> <span class="dt">list</span>) : a =</span>
<span id="cb417-4"><a href="#cb417-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> st <span class="kw">with</span></span>
<span id="cb417-5"><a href="#cb417-5" aria-hidden="true" tabindex="-1"></a>    | Done a -&gt; a</span>
<span id="cb417-6"><a href="#cb417-6" aria-hidden="true" tabindex="-1"></a>    | Awaiting {feed} -&gt;</span>
<span id="cb417-7"><a href="#cb417-7" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">match</span> inputs <span class="kw">with</span></span>
<span id="cb417-8"><a href="#cb417-8" aria-hidden="true" tabindex="-1"></a>       | [] -&gt; <span class="dt">failwith</span> <span class="st">&quot;run_script: no more inputs&quot;</span></span>
<span id="cb417-9"><a href="#cb417-9" aria-hidden="true" tabindex="-1"></a>       | u :: us -&gt; drive (feed u) us)</span>
<span id="cb417-10"><a href="#cb417-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb417-11"><a href="#cb417-11" aria-hidden="true" tabindex="-1"></a>  drive (step ~on_render f) inputs</span></code></pre></div>
<p>In a real GUI, you keep the current <code>paused</code> state in a
mutable cell. On each incoming event <code>u</code>, if the script is
<code>Awaiting {feed}</code>, you update the state to
<code>feed u</code>; if the script is <code>Done _</code>, you stop.
This also gives a simple form of <strong>cancellation</strong>: to
cancel a running script “from the outside”, you overwrite the stored
state (dropping the continuation) and stop feeding it inputs.</p>
<p>Here is the basic shape of such a driver loop:</p>
<div class="sourceCode" id="cb418"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb418-1"><a href="#cb418-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* This snippet uses a [script] defined below. See chapter10.ml for a runnable</span></span>
<span id="cb418-2"><a href="#cb418-2" aria-hidden="true" tabindex="-1"></a><span class="co">   version. *)</span></span>
<span id="cb418-3"><a href="#cb418-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> st : <span class="dt">unit</span> paused <span class="dt">ref</span> = <span class="dt">ref</span> (step ~on_render:(<span class="kw">fun</span> _ -&gt; ()) script)</span>
<span id="cb418-4"><a href="#cb418-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb418-5"><a href="#cb418-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> on_input (u : <span class="dt">input</span>) =</span>
<span id="cb418-6"><a href="#cb418-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> !st <span class="kw">with</span></span>
<span id="cb418-7"><a href="#cb418-7" aria-hidden="true" tabindex="-1"></a>  | Done () -&gt; ()</span>
<span id="cb418-8"><a href="#cb418-8" aria-hidden="true" tabindex="-1"></a>  | Awaiting {feed} -&gt; st := feed u</span></code></pre></div>
<h3 id="example-the-paddle-game-in-direct-style">Example: The Paddle
Game in Direct Style</h3>
<p>We reuse the <code>scene</code> type and the constants from Sections
10.5–10.6. We will keep the entire game state local to the script, and
we will request rendering after every relevant input.</p>
<div class="sourceCode" id="cb419"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb419-1"><a href="#cb419-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> walls_scene ~w ~h : scene =</span>
<span id="cb419-2"><a href="#cb419-2" aria-hidden="true" tabindex="-1"></a>  Color (blue, Group</span>
<span id="cb419-3"><a href="#cb419-3" aria-hidden="true" tabindex="-1"></a>    [Rect (<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">20</span>, h - <span class="dv">1</span>)</span>
<span id="cb419-4"><a href="#cb419-4" aria-hidden="true" tabindex="-1"></a>    ; Rect (<span class="dv">0</span>, h - <span class="dv">21</span>, w - <span class="dv">1</span>, <span class="dv">20</span>)</span>
<span id="cb419-5"><a href="#cb419-5" aria-hidden="true" tabindex="-1"></a>    ; Rect (w - <span class="dv">21</span>, <span class="dv">0</span>, <span class="dv">20</span>, h - <span class="dv">1</span>)</span>
<span id="cb419-6"><a href="#cb419-6" aria-hidden="true" tabindex="-1"></a>    ])</span>
<span id="cb419-7"><a href="#cb419-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb419-8"><a href="#cb419-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> paddle_scene ~x : scene =</span>
<span id="cb419-9"><a href="#cb419-9" aria-hidden="true" tabindex="-1"></a>  Color (black, Rect (x, <span class="dv">0</span>, paddle_w, paddle_h))</span>
<span id="cb419-10"><a href="#cb419-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb419-11"><a href="#cb419-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ball_scene ~x ~y : scene =</span>
<span id="cb419-12"><a href="#cb419-12" aria-hidden="true" tabindex="-1"></a>  Color (red, Circle (<span class="dt">int_of_float</span> x, <span class="dt">int_of_float</span> y, ball_r))</span>
<span id="cb419-13"><a href="#cb419-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb419-14"><a href="#cb419-14" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> scene_of_state ~w ~h ~paddle_x (st : ball_state) : scene =</span>
<span id="cb419-15"><a href="#cb419-15" aria-hidden="true" tabindex="-1"></a>  Group [walls_scene ~w ~h; paddle_scene ~x:paddle_x; ball_scene ~x:st.x ~y:st.y]</span></code></pre></div>
<p>The physics is the same as in the Lwd implementation (Section 10.6),
including paddle collision and “reset on miss”:</p>
<div class="sourceCode" id="cb420"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb420-1"><a href="#cb420-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> clamp_float ~lo ~hi x = <span class="dt">max</span> lo (<span class="dt">min</span> hi x)</span>
<span id="cb420-2"><a href="#cb420-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb420-3"><a href="#cb420-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> step_physics ~w ~h ~(paddle_x : <span class="dt">int</span>) ~(st : ball_state) ~(reset : <span class="dt">unit</span> -&gt; <span class="dt">unit</span>) ~dt =</span>
<span id="cb420-4"><a href="#cb420-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> max_step = <span class="fl">1.0</span> /. <span class="fl">240.0</span> <span class="kw">in</span></span>
<span id="cb420-5"><a href="#cb420-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> paddle_plane = <span class="dt">float_of_int</span> (paddle_h + ball_r) <span class="kw">in</span></span>
<span id="cb420-6"><a href="#cb420-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> xmin = <span class="dt">float_of_int</span> (wall_thickness + ball_r) <span class="kw">in</span></span>
<span id="cb420-7"><a href="#cb420-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> xmax = <span class="dt">float_of_int</span> (<span class="dt">max</span> (wall_thickness + ball_r) (w - <span class="dv">21</span> - ball_r)) <span class="kw">in</span></span>
<span id="cb420-8"><a href="#cb420-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ymax = <span class="dt">float_of_int</span> (<span class="dt">max</span> (paddle_h + ball_r) (h - <span class="dv">21</span> - ball_r)) <span class="kw">in</span></span>
<span id="cb420-9"><a href="#cb420-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> max_speed = <span class="fl">500.0</span> <span class="kw">in</span></span>
<span id="cb420-10"><a href="#cb420-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb420-11"><a href="#cb420-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> loop remaining =</span>
<span id="cb420-12"><a href="#cb420-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> remaining &lt;= <span class="fl">0.0</span> <span class="kw">then</span> ()</span>
<span id="cb420-13"><a href="#cb420-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="kw">begin</span></span>
<span id="cb420-14"><a href="#cb420-14" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> dt1 = <span class="dt">min</span> max_step remaining <span class="kw">in</span></span>
<span id="cb420-15"><a href="#cb420-15" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> x0, y0 = st.x, st.y <span class="kw">in</span></span>
<span id="cb420-16"><a href="#cb420-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> x1 = x0 +. dt1 *. st.vx <span class="kw">in</span></span>
<span id="cb420-17"><a href="#cb420-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> y1 = y0 +. dt1 *. st.vy <span class="kw">in</span></span>
<span id="cb420-18"><a href="#cb420-18" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> x1, vx =</span>
<span id="cb420-19"><a href="#cb420-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> x1 &lt; xmin <span class="kw">then</span> (xmin +. (xmin -. x1), -. st.vx)</span>
<span id="cb420-20"><a href="#cb420-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="kw">if</span> x1 &gt; xmax <span class="kw">then</span> (xmax -. (x1 -. xmax), -. st.vx)</span>
<span id="cb420-21"><a href="#cb420-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> (x1, st.vx)</span>
<span id="cb420-22"><a href="#cb420-22" aria-hidden="true" tabindex="-1"></a>      <span class="kw">in</span></span>
<span id="cb420-23"><a href="#cb420-23" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> y1, vy =</span>
<span id="cb420-24"><a href="#cb420-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> y1 &gt; ymax <span class="kw">then</span> (ymax -. (y1 -. ymax), -. st.vy)</span>
<span id="cb420-25"><a href="#cb420-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> (y1, st.vy)</span>
<span id="cb420-26"><a href="#cb420-26" aria-hidden="true" tabindex="-1"></a>      <span class="kw">in</span></span>
<span id="cb420-27"><a href="#cb420-27" aria-hidden="true" tabindex="-1"></a>      st.x &lt;- x1;</span>
<span id="cb420-28"><a href="#cb420-28" aria-hidden="true" tabindex="-1"></a>      st.y &lt;- y1;</span>
<span id="cb420-29"><a href="#cb420-29" aria-hidden="true" tabindex="-1"></a>      st.vx &lt;- vx;</span>
<span id="cb420-30"><a href="#cb420-30" aria-hidden="true" tabindex="-1"></a>      st.vy &lt;- vy;</span>
<span id="cb420-31"><a href="#cb420-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb420-32"><a href="#cb420-32" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> st.vy &lt; <span class="fl">0.0</span> &amp;&amp; y0 &gt;= paddle_plane &amp;&amp; st.y &lt; paddle_plane <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb420-33"><a href="#cb420-33" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> alpha = (y0 -. paddle_plane) /. (y0 -. st.y) <span class="kw">in</span></span>
<span id="cb420-34"><a href="#cb420-34" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x_hit = x0 +. alpha *. (st.x -. x0) <span class="kw">in</span></span>
<span id="cb420-35"><a href="#cb420-35" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> paddle_left = <span class="dt">float_of_int</span> paddle_x -. <span class="dt">float_of_int</span> ball_r <span class="kw">in</span></span>
<span id="cb420-36"><a href="#cb420-36" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> paddle_right =</span>
<span id="cb420-37"><a href="#cb420-37" aria-hidden="true" tabindex="-1"></a>          <span class="dt">float_of_int</span> (paddle_x + paddle_w) +. <span class="dt">float_of_int</span> ball_r</span>
<span id="cb420-38"><a href="#cb420-38" aria-hidden="true" tabindex="-1"></a>        <span class="kw">in</span></span>
<span id="cb420-39"><a href="#cb420-39" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> x_hit &gt;= paddle_left &amp;&amp; x_hit &lt;= paddle_right <span class="kw">then</span> <span class="kw">begin</span></span>
<span id="cb420-40"><a href="#cb420-40" aria-hidden="true" tabindex="-1"></a>          st.y &lt;- paddle_plane +. (paddle_plane -. st.y);</span>
<span id="cb420-41"><a href="#cb420-41" aria-hidden="true" tabindex="-1"></a>          st.vy &lt;- <span class="dt">abs_float</span> st.vy;</span>
<span id="cb420-42"><a href="#cb420-42" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> paddle_center =</span>
<span id="cb420-43"><a href="#cb420-43" aria-hidden="true" tabindex="-1"></a>            <span class="dt">float_of_int</span> paddle_x +. (<span class="dt">float_of_int</span> paddle_w /. <span class="fl">2.0</span>)</span>
<span id="cb420-44"><a href="#cb420-44" aria-hidden="true" tabindex="-1"></a>          <span class="kw">in</span></span>
<span id="cb420-45"><a href="#cb420-45" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> offset =</span>
<span id="cb420-46"><a href="#cb420-46" aria-hidden="true" tabindex="-1"></a>            (x_hit -. paddle_center) /. (<span class="dt">float_of_int</span> paddle_w /. <span class="fl">2.0</span>)</span>
<span id="cb420-47"><a href="#cb420-47" aria-hidden="true" tabindex="-1"></a>            |&gt; clamp_float ~lo:(<span class="fl">-1.0</span>) ~hi:<span class="fl">1.0</span></span>
<span id="cb420-48"><a href="#cb420-48" aria-hidden="true" tabindex="-1"></a>          <span class="kw">in</span></span>
<span id="cb420-49"><a href="#cb420-49" aria-hidden="true" tabindex="-1"></a>          st.vx &lt;-</span>
<span id="cb420-50"><a href="#cb420-50" aria-hidden="true" tabindex="-1"></a>            clamp_float ~lo:(-.max_speed) ~hi:max_speed (st.vx +. offset *. <span class="fl">120.0</span>)</span>
<span id="cb420-51"><a href="#cb420-51" aria-hidden="true" tabindex="-1"></a>        <span class="kw">end</span> <span class="kw">else</span> (</span>
<span id="cb420-52"><a href="#cb420-52" aria-hidden="true" tabindex="-1"></a>          reset ()</span>
<span id="cb420-53"><a href="#cb420-53" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb420-54"><a href="#cb420-54" aria-hidden="true" tabindex="-1"></a>      <span class="kw">end</span> <span class="kw">else</span> <span class="kw">if</span> st.y &lt; <span class="fl">-50.0</span> <span class="kw">then</span> (</span>
<span id="cb420-55"><a href="#cb420-55" aria-hidden="true" tabindex="-1"></a>        reset ()</span>
<span id="cb420-56"><a href="#cb420-56" aria-hidden="true" tabindex="-1"></a>      );</span>
<span id="cb420-57"><a href="#cb420-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb420-58"><a href="#cb420-58" aria-hidden="true" tabindex="-1"></a>      st.vx &lt;- clamp_float ~lo:(-.max_speed) ~hi:max_speed st.vx;</span>
<span id="cb420-59"><a href="#cb420-59" aria-hidden="true" tabindex="-1"></a>      st.vy &lt;- clamp_float ~lo:(-.max_speed) ~hi:max_speed st.vy;</span>
<span id="cb420-60"><a href="#cb420-60" aria-hidden="true" tabindex="-1"></a>      loop (remaining -. dt1)</span>
<span id="cb420-61"><a href="#cb420-61" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb420-62"><a href="#cb420-62" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb420-63"><a href="#cb420-63" aria-hidden="true" tabindex="-1"></a>  loop dt</span></code></pre></div>
<p>Now the <em>script</em> is just a direct-style loop:</p>
<div class="sourceCode" id="cb421"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb421-1"><a href="#cb421-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> paddle_game () =</span>
<span id="cb421-2"><a href="#cb421-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> w = <span class="dt">ref</span> <span class="dv">640</span> <span class="kw">in</span></span>
<span id="cb421-3"><a href="#cb421-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> h = <span class="dt">ref</span> <span class="dv">512</span> <span class="kw">in</span></span>
<span id="cb421-4"><a href="#cb421-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> paddle_x = <span class="dt">ref</span> (wall_thickness + <span class="dv">10</span>) <span class="kw">in</span></span>
<span id="cb421-5"><a href="#cb421-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> st : ball_state = { x = <span class="fl">0.0</span>; y = <span class="fl">0.0</span>; vx = <span class="fl">120.0</span>; vy = <span class="fl">180.0</span> } <span class="kw">in</span></span>
<span id="cb421-6"><a href="#cb421-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> dir = <span class="dt">ref</span> <span class="fl">1.0</span> <span class="kw">in</span></span>
<span id="cb421-7"><a href="#cb421-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb421-8"><a href="#cb421-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> reset () =</span>
<span id="cb421-9"><a href="#cb421-9" aria-hidden="true" tabindex="-1"></a>    st.x &lt;- <span class="dt">float_of_int</span> !w /. <span class="fl">2.0</span>;</span>
<span id="cb421-10"><a href="#cb421-10" aria-hidden="true" tabindex="-1"></a>    st.y &lt;- <span class="dt">float_of_int</span> !h /. <span class="fl">2.0</span>;</span>
<span id="cb421-11"><a href="#cb421-11" aria-hidden="true" tabindex="-1"></a>    st.vx &lt;- !dir *. <span class="fl">120.0</span>;</span>
<span id="cb421-12"><a href="#cb421-12" aria-hidden="true" tabindex="-1"></a>    st.vy &lt;- <span class="fl">180.0</span>;</span>
<span id="cb421-13"><a href="#cb421-13" aria-hidden="true" tabindex="-1"></a>    dir := -. !dir</span>
<span id="cb421-14"><a href="#cb421-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb421-15"><a href="#cb421-15" aria-hidden="true" tabindex="-1"></a>  reset ();</span>
<span id="cb421-16"><a href="#cb421-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb421-17"><a href="#cb421-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> set_paddle mx =</span>
<span id="cb421-18"><a href="#cb421-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> lo = wall_thickness <span class="kw">in</span></span>
<span id="cb421-19"><a href="#cb421-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> hi = <span class="dt">max</span> lo (!w - <span class="dv">21</span> - paddle_w) <span class="kw">in</span></span>
<span id="cb421-20"><a href="#cb421-20" aria-hidden="true" tabindex="-1"></a>    paddle_x := clamp_int ~lo ~hi (mx - (paddle_w / <span class="dv">2</span>))</span>
<span id="cb421-21"><a href="#cb421-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb421-22"><a href="#cb421-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb421-23"><a href="#cb421-23" aria-hidden="true" tabindex="-1"></a>  render (scene_of_state ~w:!w ~h:!h ~paddle_x:!paddle_x st);</span>
<span id="cb421-24"><a href="#cb421-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb421-25"><a href="#cb421-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> loop () =</span>
<span id="cb421-26"><a href="#cb421-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> ev =</span>
<span id="cb421-27"><a href="#cb421-27" aria-hidden="true" tabindex="-1"></a>      await (<span class="kw">function</span></span>
<span id="cb421-28"><a href="#cb421-28" aria-hidden="true" tabindex="-1"></a>        | Tick dt -&gt; <span class="dt">Some</span> (`Tick dt)</span>
<span id="cb421-29"><a href="#cb421-29" aria-hidden="true" tabindex="-1"></a>        | User (MouseMove (mx, _my)) -&gt; <span class="dt">Some</span> (`Move mx)</span>
<span id="cb421-30"><a href="#cb421-30" aria-hidden="true" tabindex="-1"></a>        | User (Resize (w1, h1)) -&gt; <span class="dt">Some</span> (`Resize (w1, h1))</span>
<span id="cb421-31"><a href="#cb421-31" aria-hidden="true" tabindex="-1"></a>        | _ -&gt; <span class="dt">None</span>)</span>
<span id="cb421-32"><a href="#cb421-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span></span>
<span id="cb421-33"><a href="#cb421-33" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">match</span> ev <span class="kw">with</span></span>
<span id="cb421-34"><a href="#cb421-34" aria-hidden="true" tabindex="-1"></a>     | `Move mx -&gt; set_paddle mx</span>
<span id="cb421-35"><a href="#cb421-35" aria-hidden="true" tabindex="-1"></a>     | `Resize (w1, h1) -&gt; w := w1; h := h1; reset ()</span>
<span id="cb421-36"><a href="#cb421-36" aria-hidden="true" tabindex="-1"></a>     | `Tick dt -&gt;</span>
<span id="cb421-37"><a href="#cb421-37" aria-hidden="true" tabindex="-1"></a>       <span class="kw">let</span> dt = <span class="kw">if</span> dt &lt;= <span class="fl">0.0</span> <span class="kw">then</span> <span class="fl">0.0</span> <span class="kw">else</span> <span class="dt">min</span> dt <span class="fl">0.25</span> <span class="kw">in</span></span>
<span id="cb421-38"><a href="#cb421-38" aria-hidden="true" tabindex="-1"></a>       <span class="kw">if</span> dt &gt; <span class="fl">0.0</span> <span class="kw">then</span> step_physics ~w:!w ~h:!h ~paddle_x:!paddle_x ~st ~reset ~dt);</span>
<span id="cb421-39"><a href="#cb421-39" aria-hidden="true" tabindex="-1"></a>    render (scene_of_state ~w:!w ~h:!h ~paddle_x:!paddle_x st);</span>
<span id="cb421-40"><a href="#cb421-40" aria-hidden="true" tabindex="-1"></a>    loop ()</span>
<span id="cb421-41"><a href="#cb421-41" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb421-42"><a href="#cb421-42" aria-hidden="true" tabindex="-1"></a>  loop ()</span></code></pre></div>
<h3 id="a-bogue-interpreter-for-the-effects">A Bogue Interpreter for the
Effects</h3>
<p>In a GUI, we keep the current paused state in a mutable cell, feed it
on pointer motion and on a periodic timer tick, and interpret
<code>Render</code> by updating a “current scene” ref that the draw
callback reads:</p>
<div class="sourceCode" id="cb422"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb422-1"><a href="#cb422-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> run_bogue ~(w : <span class="dt">int</span>) ~(h : <span class="dt">int</span>) (script : <span class="dt">unit</span> -&gt; <span class="dt">unit</span>) : <span class="dt">unit</span> =</span>
<span id="cb422-2"><a href="#cb422-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">open</span> Bogue <span class="kw">in</span></span>
<span id="cb422-3"><a href="#cb422-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> area_widget = Widget.sdl_area ~w ~h () <span class="kw">in</span></span>
<span id="cb422-4"><a href="#cb422-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> area = Widget.get_sdl_area area_widget <span class="kw">in</span></span>
<span id="cb422-5"><a href="#cb422-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb422-6"><a href="#cb422-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> current : scene <span class="dt">ref</span> = <span class="dt">ref</span> (Group []) <span class="kw">in</span></span>
<span id="cb422-7"><a href="#cb422-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> st : <span class="dt">unit</span> paused <span class="dt">ref</span> = <span class="dt">ref</span> (Done ()) <span class="kw">in</span></span>
<span id="cb422-8"><a href="#cb422-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb422-9"><a href="#cb422-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> on_render sc =</span>
<span id="cb422-10"><a href="#cb422-10" aria-hidden="true" tabindex="-1"></a>    current := sc;</span>
<span id="cb422-11"><a href="#cb422-11" aria-hidden="true" tabindex="-1"></a>    Sdl_area.update area</span>
<span id="cb422-12"><a href="#cb422-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb422-13"><a href="#cb422-13" aria-hidden="true" tabindex="-1"></a>  st := step ~on_render script;</span>
<span id="cb422-14"><a href="#cb422-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* Let the script know the initial size, if it cares. *)</span></span>
<span id="cb422-15"><a href="#cb422-15" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">match</span> !st <span class="kw">with</span></span>
<span id="cb422-16"><a href="#cb422-16" aria-hidden="true" tabindex="-1"></a>   | Done () -&gt; ()</span>
<span id="cb422-17"><a href="#cb422-17" aria-hidden="true" tabindex="-1"></a>   | Awaiting {feed} -&gt; st := feed (User (Resize (w, h))));</span>
<span id="cb422-18"><a href="#cb422-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb422-19"><a href="#cb422-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> feed_input (u : <span class="dt">input</span>) =</span>
<span id="cb422-20"><a href="#cb422-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> !st <span class="kw">with</span></span>
<span id="cb422-21"><a href="#cb422-21" aria-hidden="true" tabindex="-1"></a>    | Done () -&gt; ()</span>
<span id="cb422-22"><a href="#cb422-22" aria-hidden="true" tabindex="-1"></a>    | Awaiting {feed} -&gt; st := feed u</span>
<span id="cb422-23"><a href="#cb422-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb422-24"><a href="#cb422-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb422-25"><a href="#cb422-25" aria-hidden="true" tabindex="-1"></a>  Sdl_area.add area (<span class="kw">fun</span> _renderer -&gt;</span>
<span id="cb422-26"><a href="#cb422-26" aria-hidden="true" tabindex="-1"></a>    Sdl_area.fill_rectangle area ~color:(Draw.opaque Draw.grey)</span>
<span id="cb422-27"><a href="#cb422-27" aria-hidden="true" tabindex="-1"></a>      ~w ~h (<span class="dv">0</span>, <span class="dv">0</span>);</span>
<span id="cb422-28"><a href="#cb422-28" aria-hidden="true" tabindex="-1"></a>    draw area ~h !current);</span>
<span id="cb422-29"><a href="#cb422-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb422-30"><a href="#cb422-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> action _w _l ev =</span>
<span id="cb422-31"><a href="#cb422-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> mx, my = Mouse.pointer_pos ev <span class="kw">in</span></span>
<span id="cb422-32"><a href="#cb422-32" aria-hidden="true" tabindex="-1"></a>    feed_input (User (MouseMove (mx, my)));</span>
<span id="cb422-33"><a href="#cb422-33" aria-hidden="true" tabindex="-1"></a>    Widget.update area_widget</span>
<span id="cb422-34"><a href="#cb422-34" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb422-35"><a href="#cb422-35" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> connection =</span>
<span id="cb422-36"><a href="#cb422-36" aria-hidden="true" tabindex="-1"></a>    Widget.connect area_widget area_widget action Trigger.pointer_motion</span>
<span id="cb422-37"><a href="#cb422-37" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb422-38"><a href="#cb422-38" aria-hidden="true" tabindex="-1"></a>  Widget.add_connection area_widget connection;</span>
<span id="cb422-39"><a href="#cb422-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb422-40"><a href="#cb422-40" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> last = <span class="dt">ref</span> (Unix.gettimeofday ()) <span class="kw">in</span></span>
<span id="cb422-41"><a href="#cb422-41" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> tick () =</span>
<span id="cb422-42"><a href="#cb422-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> now = Unix.gettimeofday () <span class="kw">in</span></span>
<span id="cb422-43"><a href="#cb422-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> dt = now -. !last <span class="kw">in</span></span>
<span id="cb422-44"><a href="#cb422-44" aria-hidden="true" tabindex="-1"></a>    last := now;</span>
<span id="cb422-45"><a href="#cb422-45" aria-hidden="true" tabindex="-1"></a>    feed_input (Tick dt);</span>
<span id="cb422-46"><a href="#cb422-46" aria-hidden="true" tabindex="-1"></a>    Widget.update area_widget;</span>
<span id="cb422-47"><a href="#cb422-47" aria-hidden="true" tabindex="-1"></a>    Timeout.add_ignore <span class="dv">16</span> tick</span>
<span id="cb422-48"><a href="#cb422-48" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span></span>
<span id="cb422-49"><a href="#cb422-49" aria-hidden="true" tabindex="-1"></a>  Timeout.add_ignore <span class="dv">16</span> tick;</span>
<span id="cb422-50"><a href="#cb422-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb422-51"><a href="#cb422-51" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> layout = Layout.resident area_widget <span class="kw">in</span></span>
<span id="cb422-52"><a href="#cb422-52" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> board = Main.of_layout layout <span class="kw">in</span></span>
<span id="cb422-53"><a href="#cb422-53" aria-hidden="true" tabindex="-1"></a>  Main.run board</span></code></pre></div>
<p>You can run it (outside of mdx) like this:</p>
<div class="sourceCode" id="cb423"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb423-1"><a href="#cb423-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () = run_bogue ~w:<span class="dv">640</span> ~h:<span class="dv">512</span> paddle_game</span></code></pre></div>
<p>One practical tip (mirroring the “flows and state” warning from the
monadic version): keep the script itself as a thunk
<code>unit -&gt; _</code>, and run it <em>inside</em> a handler/driver.
If you accidentally <em>call</em> it while <em>building</em> a larger
structure, you may trigger effects too early (or outside any
handler).</p>
<h2 id="summary-1">10.8 Summary</h2>
<p>This chapter explored a progression of techniques for handling change
and interaction in functional programming.</p>
<p><strong>Zippers</strong> make “where am I in the structure?”
explicit, by representing a location as <em>context + focused
subtree</em>. This turns local navigation and rewriting problems (like
our algebraic manipulation example) into simple, efficient code.</p>
<p><strong>Incremental computing</strong> makes “what depends on what?”
explicit, by building a dependency graph behind the scenes. You write
normal-looking code; the system tracks dependencies and recomputes only
what is necessary after an update. We compared two modern OCaml
libraries:</p>
<ul>
<li><code>Lwd</code>: lightweight, pull-based sampling, explicit
resource lifetimes (<code>prim</code> acquire/release); a good fit for
reactive view trees.</li>
<li><code>Incremental</code>: stabilization-based recomputation with
cutoffs and rich observer tooling; a good fit for large DAGs and complex
dependency structure.</li>
</ul>
<p><strong>Functional Reactive Programming (FRP)</strong> adds the time
dimension. We modernized the standard vocabulary (behaviors, events,
signals), emphasized causality and glitch freedom, and kept a
stream-based implementation that makes time explicit.</p>
<p><strong>Direct control with effects</strong> complements FRP: many
interactions are staged state machines. With algebraic effects (Chapter
9), we can write reactive “scripts” in direct style (<code>await</code>,
<code>race</code>, …) and interpret them with different handlers (real
GUI loop, replayed test script, simulation).</p>
<p>A note on practice: OCaml UI and dataflow systems today often embed
an incremental engine under the hood (<code>Lwd</code>, or
<code>Incremental</code> via frameworks like Bonsai). Even without
adopting a full FRP framework, the core ideas transfer: choose a clear
update-step boundary, keep effectful input/output at the edge, and make
dependencies explicit so the runtime can do less work.</p>
<h2 id="exercises-9">10.9 Exercises</h2>
<p><strong>Exercise 1.</strong> Extend the context rewriting “pull out
subexpression” example to include <code>-</code> and <code>/</code>.
Remember: they are not commutative.</p>
<p><strong>Exercise 2.</strong> Implement a simple text editor
zipper:</p>
<ol type="1">
<li>Define a type for a text buffer as a zipper over characters, with
the cursor position represented by the split between left context and
right content.</li>
<li>Implement <code>insert_char</code>, <code>delete_char</code>,
<code>move_left</code>, <code>move_right</code>,
<code>move_to_start</code>, and <code>move_to_end</code>
operations.</li>
<li>Add word-based movement: <code>move_word_left</code> and
<code>move_word_right</code>.</li>
</ol>
<p><strong>Exercise 3.</strong> Add the following features to the paddle
game example:</p>
<ol type="1">
<li>Score keeping: increment score when the ball bounces off the
paddle</li>
<li>Game over: detect when the ball falls below the paddle</li>
<li>Restart: press a key to restart after game over</li>
<li>Speed increase: gradually increase ball speed as the game
progresses</li>
</ol>
<p><strong>Exercise 4.</strong> Our numerical integration function uses
the rectangle rule (left endpoint). Implement and compare:</p>
<ol type="1">
<li>The midpoint rule: <span class="math inline">\int_a^b f(x)dx \approx
(b-a) \cdot f\left(\frac{a+b}{2}\right)</span></li>
<li>The trapezoidal rule: <span class="math inline">\int_a^b f(x)dx
\approx (b-a) \cdot \frac{f(a) + f(b)}{2}</span></li>
<li>Simpson’s rule: <span class="math inline">\int_a^b f(x)dx \approx
\frac{b-a}{6} \left( f(a) + 4f\left(\frac{a+b}{2}\right) + f(b)
\right)</span></li>
</ol>
<p>Test the accuracy by integrating <span
class="math inline">\sin(x)</span> from 0 to <span
class="math inline">\pi</span> (exact answer: 2).</p>
<p><strong>Exercise 5.</strong> Implement <code>switch</code> and
<code>until</code> for the stream-based FRP system:</p>
<ul>
<li><code>switch : 'a behavior -&gt; 'a behavior event -&gt; 'a behavior</code>
– behaves as the most recent behavior from events</li>
<li><code>until : 'a behavior -&gt; 'a behavior event -&gt; 'a behavior</code>
– switches once on the first event</li>
</ul>
<p><strong>Exercise 6.</strong> Implement a <code>debounce</code>
combinator for events:</p>
<pre><code>val debounce : float -&gt; &#39;a event -&gt; &#39;a event</code></pre>
<p>The debounced event only fires if the original event has not fired
for the specified time interval. This is useful for handling rapid user
input like typing. Example: throttling API requests for auto-complete in
a text field.</p>
<p><strong>Exercise 7.</strong> Build a tiny “spreadsheet” with either
<code>Lwd</code> or <code>Incremental</code>: cells are variables; other
cells are formulas over them. Measure how much recomputation happens
when you update a single input cell.</p>
<p><strong>Exercise 8.</strong> Using <code>Lwd.join</code> (or
<code>Incremental.bind</code>), build a reactive computation with
<em>dynamic dependencies</em> (e.g. a toggle that chooses which subgraph
is active). Explain what should be recomputed when the toggle flips.</p>
<p><strong>Exercise 9.</strong> Extend the effect-based interface in
Section 10.7 with timeouts.</p>
<div class="sourceCode" id="cb425"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb425-1"><a href="#cb425-1" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> await_timeout : deadline:<span class="dt">float</span> -&gt; (user_action -&gt; &#39;a <span class="dt">option</span>) -&gt; &#39;a <span class="dt">option</span></span></code></pre></div>
<p>The function should return <code>Some v</code> if the awaited action
happens before the deadline, and <code>None</code> otherwise. Write a
small scripted test with <code>run_script</code>.</p>
<p><strong>Exercise 10.</strong> Implement <code>parallel</code> for
effect-based flows:</p>
<pre><code>val parallel : (unit -&gt; &#39;a) list -&gt; &#39;a list</code></pre>
<p>This should run multiple flows concurrently and collect their
results. Think about:</p>
<ul>
<li>How do you handle flows that await events?</li>
<li>What happens if one flow fails?</li>
<li>How do you handle cancellation?</li>
</ul>
<p><strong>Exercise 11.</strong> The FRP implementations in this chapter
handle time as wall-clock time from <code>Unix.gettimeofday</code>.
Implement a version with <em>virtual time</em> that can be controlled
programmatically:</p>
<ol type="1">
<li>Create a <code>Clock</code> module with
<code>advance : float -&gt; unit</code> and
<code>now : unit -&gt; float</code> functions</li>
<li>Modify the integration function to use virtual time</li>
<li>Write tests that use virtual time to verify physics behavior
deterministically</li>
</ol>
<p><strong>Exercise 12.</strong> Compare the memory characteristics of
the three FRP approaches:</p>
<ol type="1">
<li>Create a benchmark that builds a dependency graph with N nodes</li>
<li>Measure memory usage for each approach (stream-based, Lwd-based,
effect-based)</li>
<li>Measure update time when one input changes</li>
<li>Plot the results and explain the tradeoffs</li>
</ol>
<h1 id="chapter-11-the-expression-problem">Chapter 11: The Expression
Problem</h1>
<p><strong>In this chapter, you will:</strong></p>
<ul>
<li>Understand the expression problem and why it matters for evolving
codebases</li>
<li>Compare extensibility trade-offs across ADTs, objects, and variants
in OCaml</li>
<li>Learn how polymorphic variants and recursive modules enable modular
extension</li>
<li>Build a practical capstone: parser combinators (including dynamic
loading)</li>
</ul>
<p>This chapter explores <strong>the expression problem</strong>, a
classic challenge in software engineering that addresses how to design
systems that can be extended with both new data variants and new
operations without modifying existing code, while maintaining static
type safety. The expression problem lies at the heart of code
organization, extensibility, and reuse, so understanding the various
solutions helps us write more maintainable and flexible software.</p>
<p>We will examine multiple approaches in OCaml, ranging from algebraic
data types through object-oriented programming to polymorphic variants
with recursive modules. Each approach has different trade-offs in terms
of type safety, code organization, and ease of use. The chapter
concludes with a practical application: parser combinators with dynamic
code loading, demonstrating how these techniques apply to real-world
problems.</p>
<h2 id="the-expression-problem-definition">11.1 The Expression Problem:
Definition</h2>
<p>The <strong>Expression Problem</strong> concerns the design of an
implementation for expressions where:</p>
<ul>
<li><strong>Datatype extensibility</strong>: New variants of expressions
can be added</li>
<li><strong>Functional extensibility</strong>: New operations on
expressions can be added</li>
</ul>
<p>By <em>extensibility</em> we mean three conditions:</p>
<ol type="1">
<li><strong>Code-level modularization</strong>: The new datatype
variants and new operations are in separate files</li>
<li><strong>Separate compilation</strong>: The files can be compiled and
distributed separately</li>
<li><strong>Static type safety</strong>: We do not lose type checking
help and guarantees</li>
</ol>
<p>The name comes from a classic example: extending a language of
expressions with new constructs. Consider two sub-languages:</p>
<ul>
<li><strong>Lambda calculus</strong>: variables <code>Var</code>, <span
class="math inline">\lambda</span>-abstractions <code>Abs</code>,
function applications <code>App</code></li>
<li><strong>Arithmetic</strong>: variables <code>Var</code>, constants
<code>Num</code>, addition <code>Add</code>, multiplication
<code>Mult</code></li>
</ul>
<p>And operations we want to support:</p>
<ul>
<li>Evaluation <code>eval</code></li>
<li>Pretty-printing to strings <code>string_of</code></li>
<li>Free variables computation <code>free_vars</code></li>
</ul>
<p>The challenge is to combine these sub-languages and add new
operations without breaking existing code or sacrificing type safety.
This is a fundamental tension in programming language design: functional
languages typically make it easy to add new operations (just write a new
function with pattern matching), while object-oriented languages
typically make it easy to add new data variants (just add a new
subclass). Finding a solution that provides both kinds of extensibility
simultaneously, with static type safety and separate compilation, is the
essence of the expression problem.</p>
<h3 id="references">References</h3>
<ul>
<li>Ralf Lammel lectures on MSDN’s Channel 9: <a
href="http://channel9.msdn.com/Shows/Going+Deep/C9-Lectures-Dr-Ralf-Laemmel-Advanced-Functional-Programming-The-Expression-Problem">The
Expression Problem</a>, <a
href="http://channel9.msdn.com/Shows/Going+Deep/C9-Lectures-Dr-Ralf-Lmmel-Advanced-Functional-Programming-Type-Classes">Haskell’s
Type Classes</a></li>
<li>The book <em>Developing Applications with Objective Caml</em>: <a
href="http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora153.html">Comparison
of Modules and Objects</a>, <a
href="http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora154.html">Extending
Components</a></li>
<li><em>Real World OCaml</em>: <a
href="https://realworldocaml.org/v1/en/html/objects.html">Chapter 11:
Objects</a>, <a
href="https://realworldocaml.org/v1/en/html/classes.html">Chapter 12:
Classes</a></li>
<li>Jacques Garrigue’s <a
href="http://www.math.nagoya-u.ac.jp/~garrigue/papers/variant-reuse.ps.gz">Code
reuse through polymorphic variants</a>, and <a
href="http://www.math.nagoya-u.ac.jp/~garrigue/papers/nakata-icfp2006.pdf">Recursive
Modules for Programming</a> with Keiko Nakata</li>
<li><a
href="http://caml.inria.fr/pub/docs/manual-ocaml/extn.html#sec246">Extensible
variant types</a></li>
<li>Graham Hutton’s and Erik Meijer’s <a
href="https://www.cs.nott.ac.uk/~gmh/monparsing.pdf">Monadic Parser
Combinators</a></li>
</ul>
<h2
id="functional-programming-non-solution-ordinary-algebraic-datatypes">11.2
Functional Programming Non-Solution: Ordinary Algebraic Datatypes</h2>
<p>Pattern matching makes <strong>functional extensibility</strong> easy
in functional programming. When we want to add a new operation, we
simply write a new function that pattern-matches on the existing
datatype. However, ensuring <strong>datatype extensibility</strong> is
complicated when using standard variant types, because adding a new
variant requires modifying the type definition and all functions that
pattern-match on it.</p>
<p>For brevity, we place examples in a single file, but the component
type and function definitions are not mutually recursive, so they can be
put in separate modules for separate compilation.</p>
<p><strong>Non-solution penalty points:</strong></p>
<ul>
<li>Functions implemented for a broader language (e.g.,
<code>lexpr_t</code>) cannot be used with a value from a narrower
language (e.g., <code>expr_t</code>). This breaks the intuition that a
smaller language should be usable wherever a larger one is
expected.</li>
<li>Significant memory (and some time) overhead due to <em>tagging</em>:
the work of the <code>wrap</code> and <code>unwrap</code> functions,
adding tags such as <code>Lambda</code> and <code>Expr</code> to
distinguish which sub-language an expression belongs to.</li>
<li>Some code bloat due to tagging. For example, deep pattern matching
needs to be manually unrolled and interspersed with calls to
<code>unwrap</code>, making the code harder to read and maintain.</li>
</ul>
<p><strong>Verdict:</strong> Non-solution, but better than the
extensible variant types-based approach and the direct OOP approach.</p>
<p>Here is the implementation. Note how we use type parameters and
wrap/unwrap functions to achieve a form of extensibility:</p>
<div class="sourceCode" id="cb427"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb427-1"><a href="#cb427-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> var = <span class="dt">string</span>  <span class="co">(* Variables constitute a sub-language of its own *)</span></span>
<span id="cb427-2"><a href="#cb427-2" aria-hidden="true" tabindex="-1"></a>                   <span class="co">(* We treat this sub-language slightly differently --</span></span>
<span id="cb427-3"><a href="#cb427-3" aria-hidden="true" tabindex="-1"></a><span class="co">                      no need for a dedicated variant *)</span></span>
<span id="cb427-4"><a href="#cb427-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb427-5"><a href="#cb427-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> eval_var wrap sub (s : var) =</span>
<span id="cb427-6"><a href="#cb427-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">try</span> <span class="dt">List</span>.assoc s sub <span class="kw">with</span> <span class="dt">Not_found</span> -&gt; wrap s</span>
<span id="cb427-7"><a href="#cb427-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb427-8"><a href="#cb427-8" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a lambda =  <span class="co">(* Here we define the sub-language of lambda-expressions *)</span></span>
<span id="cb427-9"><a href="#cb427-9" aria-hidden="true" tabindex="-1"></a>  VarL <span class="kw">of</span> var | Abs <span class="kw">of</span> <span class="dt">string</span> * &#39;a | App <span class="kw">of</span> &#39;a * &#39;a</span>
<span id="cb427-10"><a href="#cb427-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb427-11"><a href="#cb427-11" aria-hidden="true" tabindex="-1"></a><span class="co">(* During evaluation, we need to freshen variables to avoid capture *)</span></span>
<span id="cb427-12"><a href="#cb427-12" aria-hidden="true" tabindex="-1"></a><span class="co">(* (mistaking distinct variables with the same name) *)</span></span>
<span id="cb427-13"><a href="#cb427-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> gensym = <span class="kw">let</span> n = <span class="dt">ref</span> <span class="dv">0</span> <span class="kw">in</span> <span class="kw">fun</span> () -&gt; <span class="dt">incr</span> n; <span class="st">&quot;_&quot;</span> ^ <span class="dt">string_of_int</span> !n</span>
<span id="cb427-14"><a href="#cb427-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb427-15"><a href="#cb427-15" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> eval_lambda eval_rec wrap unwrap subst e =</span>
<span id="cb427-16"><a href="#cb427-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> unwrap e <span class="kw">with</span>  <span class="co">(* Alternatively, unwrapping could use an exception *)</span></span>
<span id="cb427-17"><a href="#cb427-17" aria-hidden="true" tabindex="-1"></a>  | <span class="dt">Some</span> (VarL v) -&gt; eval_var (<span class="kw">fun</span> v -&gt; wrap (VarL v)) subst v</span>
<span id="cb427-18"><a href="#cb427-18" aria-hidden="true" tabindex="-1"></a>  | <span class="dt">Some</span> (App (l1, l2)) -&gt;  <span class="co">(* but we use the option type as it is safer *)</span></span>
<span id="cb427-19"><a href="#cb427-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> l1&#39; = eval_rec subst l1  <span class="co">(* and more flexible in this context *)</span></span>
<span id="cb427-20"><a href="#cb427-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">and</span> l2&#39; = eval_rec subst l2 <span class="kw">in</span>  <span class="co">(* Recursive processing returns expression *)</span></span>
<span id="cb427-21"><a href="#cb427-21" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">match</span> unwrap l1&#39; <span class="kw">with</span>     <span class="co">(* of the completed language, we need *)</span></span>
<span id="cb427-22"><a href="#cb427-22" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (Abs (s, body)) -&gt;  <span class="co">(* to unwrap it into the current sub-language *)</span></span>
<span id="cb427-23"><a href="#cb427-23" aria-hidden="true" tabindex="-1"></a>      eval_rec [s, l2&#39;] body  <span class="co">(* The recursive call is already wrapped *)</span></span>
<span id="cb427-24"><a href="#cb427-24" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; wrap (App (l1&#39;, l2&#39;)))  <span class="co">(* Wrap into the completed language *)</span></span>
<span id="cb427-25"><a href="#cb427-25" aria-hidden="true" tabindex="-1"></a>  | <span class="dt">Some</span> (Abs (s, l1)) -&gt;</span>
<span id="cb427-26"><a href="#cb427-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s&#39; = gensym () <span class="kw">in</span>  <span class="co">(* Rename variable to avoid capture (alpha-equivalence) *)</span></span>
<span id="cb427-27"><a href="#cb427-27" aria-hidden="true" tabindex="-1"></a>    wrap (Abs (s&#39;, eval_rec ((s, wrap (VarL s&#39;))::subst) l1))</span>
<span id="cb427-28"><a href="#cb427-28" aria-hidden="true" tabindex="-1"></a>  | <span class="dt">None</span> -&gt; e  <span class="co">(* Falling-through when not in the current sub-language *)</span></span>
<span id="cb427-29"><a href="#cb427-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb427-30"><a href="#cb427-30" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> lambda_t = Lambda_t <span class="kw">of</span> lambda_t lambda  <span class="co">(* Lambdas as the completed language *)</span></span>
<span id="cb427-31"><a href="#cb427-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb427-32"><a href="#cb427-32" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> eval1 subst =  <span class="co">(* and the corresponding eval function *)</span></span>
<span id="cb427-33"><a href="#cb427-33" aria-hidden="true" tabindex="-1"></a>  eval_lambda eval1</span>
<span id="cb427-34"><a href="#cb427-34" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">fun</span> e -&gt; Lambda_t e) (<span class="kw">fun</span> (Lambda_t e) -&gt; <span class="dt">Some</span> e) subst</span></code></pre></div>
<p>Now we define the arithmetic sub-language:</p>
<div class="sourceCode" id="cb428"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb428-1"><a href="#cb428-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a expr =  <span class="co">(* The sub-language of arithmetic expressions *)</span></span>
<span id="cb428-2"><a href="#cb428-2" aria-hidden="true" tabindex="-1"></a>  VarE <span class="kw">of</span> var | Num <span class="kw">of</span> <span class="dt">int</span> | Add <span class="kw">of</span> &#39;a * &#39;a | Mult <span class="kw">of</span> &#39;a * &#39;a</span>
<span id="cb428-3"><a href="#cb428-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb428-4"><a href="#cb428-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> eval_expr eval_rec wrap unwrap subst e =</span>
<span id="cb428-5"><a href="#cb428-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> unwrap e <span class="kw">with</span></span>
<span id="cb428-6"><a href="#cb428-6" aria-hidden="true" tabindex="-1"></a>  | <span class="dt">Some</span> (Num _) -&gt; e</span>
<span id="cb428-7"><a href="#cb428-7" aria-hidden="true" tabindex="-1"></a>  | <span class="dt">Some</span> (VarE v) -&gt;</span>
<span id="cb428-8"><a href="#cb428-8" aria-hidden="true" tabindex="-1"></a>    eval_var (<span class="kw">fun</span> x -&gt; wrap (VarE x)) subst v</span>
<span id="cb428-9"><a href="#cb428-9" aria-hidden="true" tabindex="-1"></a>  | <span class="dt">Some</span> (Add (m, n)) -&gt;</span>
<span id="cb428-10"><a href="#cb428-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> m&#39; = eval_rec subst m</span>
<span id="cb428-11"><a href="#cb428-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">and</span> n&#39; = eval_rec subst n <span class="kw">in</span></span>
<span id="cb428-12"><a href="#cb428-12" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">match</span> unwrap m&#39;, unwrap n&#39; <span class="kw">with</span>  <span class="co">(* Unwrapping to check if the subexpressions *)</span></span>
<span id="cb428-13"><a href="#cb428-13" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (Num m&#39;), <span class="dt">Some</span> (Num n&#39;) -&gt;  <span class="co">(* got computed to values *)</span></span>
<span id="cb428-14"><a href="#cb428-14" aria-hidden="true" tabindex="-1"></a>      wrap (Num (m&#39; + n&#39;))</span>
<span id="cb428-15"><a href="#cb428-15" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; wrap (Add (m&#39;, n&#39;)))  <span class="co">(* Here m&#39; and n&#39; are wrapped *)</span></span>
<span id="cb428-16"><a href="#cb428-16" aria-hidden="true" tabindex="-1"></a>  | <span class="dt">Some</span> (Mult (m, n)) -&gt;</span>
<span id="cb428-17"><a href="#cb428-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> m&#39; = eval_rec subst m</span>
<span id="cb428-18"><a href="#cb428-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">and</span> n&#39; = eval_rec subst n <span class="kw">in</span></span>
<span id="cb428-19"><a href="#cb428-19" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">match</span> unwrap m&#39;, unwrap n&#39; <span class="kw">with</span></span>
<span id="cb428-20"><a href="#cb428-20" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (Num m&#39;), <span class="dt">Some</span> (Num n&#39;) -&gt;</span>
<span id="cb428-21"><a href="#cb428-21" aria-hidden="true" tabindex="-1"></a>      wrap (Num (m&#39; * n&#39;))</span>
<span id="cb428-22"><a href="#cb428-22" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; wrap (Mult (m&#39;, n&#39;)))</span>
<span id="cb428-23"><a href="#cb428-23" aria-hidden="true" tabindex="-1"></a>  | <span class="dt">None</span> -&gt; e</span>
<span id="cb428-24"><a href="#cb428-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb428-25"><a href="#cb428-25" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> expr_t = Expr_t <span class="kw">of</span> expr_t expr  <span class="co">(* Defining arithmetic as the completed lang *)</span></span>
<span id="cb428-26"><a href="#cb428-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb428-27"><a href="#cb428-27" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> eval2 subst =  <span class="co">(* aka &quot;tying the recursive knot&quot; *)</span></span>
<span id="cb428-28"><a href="#cb428-28" aria-hidden="true" tabindex="-1"></a>  eval_expr eval2</span>
<span id="cb428-29"><a href="#cb428-29" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">fun</span> e -&gt; Expr_t e) (<span class="kw">fun</span> (Expr_t e) -&gt; <span class="dt">Some</span> e) subst</span></code></pre></div>
<p>Finally, we merge the two sub-languages. The key insight is that we
can compose evaluators by using the “fall-through” property: when one
evaluator does not recognize an expression (returning it unchanged via
the <code>None</code> case), we pass it to the next evaluator:</p>
<div class="sourceCode" id="cb429"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb429-1"><a href="#cb429-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a lexpr =  <span class="co">(* The language merging lambda-expressions and arithmetic exprs *)</span></span>
<span id="cb429-2"><a href="#cb429-2" aria-hidden="true" tabindex="-1"></a>  Lambda <span class="kw">of</span> &#39;a lambda | Expr <span class="kw">of</span> &#39;a expr  <span class="co">(* can also be used in further extensions *)</span></span>
<span id="cb429-3"><a href="#cb429-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb429-4"><a href="#cb429-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> eval_lexpr eval_rec wrap unwrap subst e =</span>
<span id="cb429-5"><a href="#cb429-5" aria-hidden="true" tabindex="-1"></a>  eval_lambda eval_rec</span>
<span id="cb429-6"><a href="#cb429-6" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">fun</span> e -&gt; wrap (Lambda e))</span>
<span id="cb429-7"><a href="#cb429-7" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">fun</span> e -&gt;</span>
<span id="cb429-8"><a href="#cb429-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">match</span> unwrap e <span class="kw">with</span></span>
<span id="cb429-9"><a href="#cb429-9" aria-hidden="true" tabindex="-1"></a>      | <span class="dt">Some</span> (Lambda e) -&gt; <span class="dt">Some</span> e</span>
<span id="cb429-10"><a href="#cb429-10" aria-hidden="true" tabindex="-1"></a>      | _ -&gt; <span class="dt">None</span>)</span>
<span id="cb429-11"><a href="#cb429-11" aria-hidden="true" tabindex="-1"></a>    subst</span>
<span id="cb429-12"><a href="#cb429-12" aria-hidden="true" tabindex="-1"></a>    (eval_expr eval_rec  <span class="co">(* We use the &quot;fall-through&quot; property of eval_expr *)</span></span>
<span id="cb429-13"><a href="#cb429-13" aria-hidden="true" tabindex="-1"></a>       (<span class="kw">fun</span> e -&gt; wrap (Expr e))  <span class="co">(* to combine the evaluators *)</span></span>
<span id="cb429-14"><a href="#cb429-14" aria-hidden="true" tabindex="-1"></a>       (<span class="kw">fun</span> e -&gt;</span>
<span id="cb429-15"><a href="#cb429-15" aria-hidden="true" tabindex="-1"></a>         <span class="kw">match</span> unwrap e <span class="kw">with</span></span>
<span id="cb429-16"><a href="#cb429-16" aria-hidden="true" tabindex="-1"></a>         | <span class="dt">Some</span> (Expr e) -&gt; <span class="dt">Some</span> e</span>
<span id="cb429-17"><a href="#cb429-17" aria-hidden="true" tabindex="-1"></a>         | _ -&gt; <span class="dt">None</span>)</span>
<span id="cb429-18"><a href="#cb429-18" aria-hidden="true" tabindex="-1"></a>       subst e)</span>
<span id="cb429-19"><a href="#cb429-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb429-20"><a href="#cb429-20" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> lexpr_t = LExpr_t <span class="kw">of</span> lexpr_t lexpr  <span class="co">(* Tying the recursive knot one last time *)</span></span>
<span id="cb429-21"><a href="#cb429-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb429-22"><a href="#cb429-22" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> eval3 subst =</span>
<span id="cb429-23"><a href="#cb429-23" aria-hidden="true" tabindex="-1"></a>  eval_lexpr eval3</span>
<span id="cb429-24"><a href="#cb429-24" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">fun</span> e -&gt; LExpr_t e)</span>
<span id="cb429-25"><a href="#cb429-25" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">fun</span> (LExpr_t e) -&gt; <span class="dt">Some</span> e) subst</span></code></pre></div>
<h2 id="lightweight-fp-non-solution-extensible-variant-types">11.3
Lightweight FP Non-Solution: Extensible Variant Types</h2>
<p>Exceptions have always formed an extensible variant type in OCaml,
whose pattern matching is done using the <code>try...with</code> syntax.
Since OCaml 4.02, the same mechanism is available for ordinary types via
<strong>extensible variant types</strong> (<code>type t = ..</code>).
This augments the normal function extensibility of FP with
straightforward data extensibility, providing a seemingly elegant
solution.</p>
<p>The syntax is simple: <code>type expr = ..</code> declares an
extensible type, and <code>type expr += Var of string</code> adds a new
variant case to it. This mirrors how exceptions work in OCaml, but for
arbitrary types.</p>
<p><strong>Non-solution penalty points:</strong></p>
<ul>
<li><strong>Giving up exhaustivity checking</strong>, which is an
important aspect of static type safety. The compiler cannot warn you
when you forget to handle a case, because new cases can be added at any
time.</li>
<li>More natural with “single inheritance” extension chains, although
merging is possible and demonstrated in our example. The sub-languages
are not differentiated by types, which is a significant
shortcoming.</li>
<li>Requires “tying the recursive knot” for functions, similar to the
previous approach.</li>
</ul>
<p><strong>Verdict:</strong> Pleasant-looking, but arguably the worst
approach because of possible bugginess. The loss of exhaustivity
checking means that bugs from unhandled cases will only be discovered at
runtime. However, if bug-proneness is not a concern (e.g., for rapid
prototyping), this is actually the most concise approach.</p>
<div class="sourceCode" id="cb430"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb430-1"><a href="#cb430-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> expr = ..  <span class="co">(* This is how extensible variant types are defined *)</span></span>
<span id="cb430-2"><a href="#cb430-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb430-3"><a href="#cb430-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> var_name = <span class="dt">string</span></span>
<span id="cb430-4"><a href="#cb430-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> expr += Var <span class="kw">of</span> <span class="dt">string</span>  <span class="co">(* We add a variant case *)</span></span>
<span id="cb430-5"><a href="#cb430-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb430-6"><a href="#cb430-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> eval_var sub = <span class="kw">function</span></span>
<span id="cb430-7"><a href="#cb430-7" aria-hidden="true" tabindex="-1"></a>  | Var s <span class="kw">as</span> v -&gt; (<span class="kw">try</span> <span class="dt">List</span>.assoc s sub <span class="kw">with</span> <span class="dt">Not_found</span> -&gt; v)</span>
<span id="cb430-8"><a href="#cb430-8" aria-hidden="true" tabindex="-1"></a>  | e -&gt; e</span>
<span id="cb430-9"><a href="#cb430-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb430-10"><a href="#cb430-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> gensym = <span class="kw">let</span> n = <span class="dt">ref</span> <span class="dv">0</span> <span class="kw">in</span> <span class="kw">fun</span> () -&gt; <span class="dt">incr</span> n; <span class="st">&quot;_&quot;</span> ^ <span class="dt">string_of_int</span> !n</span>
<span id="cb430-11"><a href="#cb430-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb430-12"><a href="#cb430-12" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> expr += Abs <span class="kw">of</span> <span class="dt">string</span> * expr | App <span class="kw">of</span> expr * expr</span>
<span id="cb430-13"><a href="#cb430-13" aria-hidden="true" tabindex="-1"></a><span class="co">(* The sub-languages are not differentiated by types,</span></span>
<span id="cb430-14"><a href="#cb430-14" aria-hidden="true" tabindex="-1"></a><span class="co">   a shortcoming of this non-solution *)</span></span>
<span id="cb430-15"><a href="#cb430-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb430-16"><a href="#cb430-16" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> eval_lambda eval_rec subst = <span class="kw">function</span></span>
<span id="cb430-17"><a href="#cb430-17" aria-hidden="true" tabindex="-1"></a>  | Var _ <span class="kw">as</span> v -&gt; eval_var subst v</span>
<span id="cb430-18"><a href="#cb430-18" aria-hidden="true" tabindex="-1"></a>  | App (l1, l2) -&gt;</span>
<span id="cb430-19"><a href="#cb430-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> l2&#39; = eval_rec subst l2 <span class="kw">in</span></span>
<span id="cb430-20"><a href="#cb430-20" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">match</span> eval_rec subst l1 <span class="kw">with</span></span>
<span id="cb430-21"><a href="#cb430-21" aria-hidden="true" tabindex="-1"></a>    | Abs (s, body) -&gt;</span>
<span id="cb430-22"><a href="#cb430-22" aria-hidden="true" tabindex="-1"></a>      eval_rec [s, l2&#39;] body</span>
<span id="cb430-23"><a href="#cb430-23" aria-hidden="true" tabindex="-1"></a>    | l1&#39; -&gt; App (l1&#39;, l2&#39;))</span>
<span id="cb430-24"><a href="#cb430-24" aria-hidden="true" tabindex="-1"></a>  | Abs (s, l1) -&gt;</span>
<span id="cb430-25"><a href="#cb430-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s&#39; = gensym () <span class="kw">in</span></span>
<span id="cb430-26"><a href="#cb430-26" aria-hidden="true" tabindex="-1"></a>    Abs (s&#39;, eval_rec ((s, Var s&#39;)::subst) l1)</span>
<span id="cb430-27"><a href="#cb430-27" aria-hidden="true" tabindex="-1"></a>  | e -&gt; e</span>
<span id="cb430-28"><a href="#cb430-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb430-29"><a href="#cb430-29" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> freevars_lambda freevars_rec = <span class="kw">function</span></span>
<span id="cb430-30"><a href="#cb430-30" aria-hidden="true" tabindex="-1"></a>  | Var v -&gt; [v]</span>
<span id="cb430-31"><a href="#cb430-31" aria-hidden="true" tabindex="-1"></a>  | App (l1, l2) -&gt; freevars_rec l1 @ freevars_rec l2</span>
<span id="cb430-32"><a href="#cb430-32" aria-hidden="true" tabindex="-1"></a>  | Abs (s, l1) -&gt;</span>
<span id="cb430-33"><a href="#cb430-33" aria-hidden="true" tabindex="-1"></a>    <span class="dt">List</span>.filter (<span class="kw">fun</span> v -&gt; v &lt;&gt; s) (freevars_rec l1)</span>
<span id="cb430-34"><a href="#cb430-34" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; []</span>
<span id="cb430-35"><a href="#cb430-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb430-36"><a href="#cb430-36" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> eval1 subst e = eval_lambda eval1 subst e</span>
<span id="cb430-37"><a href="#cb430-37" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> freevars1 e = freevars_lambda freevars1 e</span>
<span id="cb430-38"><a href="#cb430-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb430-39"><a href="#cb430-39" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> test1 = App (Abs (<span class="st">&quot;x&quot;</span>, Var <span class="st">&quot;x&quot;</span>), Var <span class="st">&quot;y&quot;</span>)</span>
<span id="cb430-40"><a href="#cb430-40" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> e_test = eval1 [] test1</span>
<span id="cb430-41"><a href="#cb430-41" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fv_test = freevars1 test1</span></code></pre></div>
<p>Now we extend with arithmetic:</p>
<div class="sourceCode" id="cb431"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb431-1"><a href="#cb431-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> expr += Num <span class="kw">of</span> <span class="dt">int</span> | Add <span class="kw">of</span> expr * expr | Mult <span class="kw">of</span> expr * expr</span>
<span id="cb431-2"><a href="#cb431-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb431-3"><a href="#cb431-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> map_expr f = <span class="kw">function</span></span>
<span id="cb431-4"><a href="#cb431-4" aria-hidden="true" tabindex="-1"></a>  | Add (e1, e2) -&gt; Add (f e1, f e2)</span>
<span id="cb431-5"><a href="#cb431-5" aria-hidden="true" tabindex="-1"></a>  | Mult (e1, e2) -&gt; Mult (f e1, f e2)</span>
<span id="cb431-6"><a href="#cb431-6" aria-hidden="true" tabindex="-1"></a>  | e -&gt; e</span>
<span id="cb431-7"><a href="#cb431-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb431-8"><a href="#cb431-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> eval_expr eval_rec subst e =</span>
<span id="cb431-9"><a href="#cb431-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> map_expr (eval_rec subst) e <span class="kw">with</span></span>
<span id="cb431-10"><a href="#cb431-10" aria-hidden="true" tabindex="-1"></a>  | Add (Num m, Num n) -&gt; Num (m + n)</span>
<span id="cb431-11"><a href="#cb431-11" aria-hidden="true" tabindex="-1"></a>  | Mult (Num m, Num n) -&gt; Num (m * n)</span>
<span id="cb431-12"><a href="#cb431-12" aria-hidden="true" tabindex="-1"></a>  | (Num _ | Add _ | Mult _) <span class="kw">as</span> e -&gt; e</span>
<span id="cb431-13"><a href="#cb431-13" aria-hidden="true" tabindex="-1"></a>  | e -&gt; e</span>
<span id="cb431-14"><a href="#cb431-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb431-15"><a href="#cb431-15" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> freevars_expr freevars_rec = <span class="kw">function</span></span>
<span id="cb431-16"><a href="#cb431-16" aria-hidden="true" tabindex="-1"></a>  | Num _ -&gt; []</span>
<span id="cb431-17"><a href="#cb431-17" aria-hidden="true" tabindex="-1"></a>  | Add (e1, e2) | Mult (e1, e2) -&gt; freevars_rec e1 @ freevars_rec e2</span>
<span id="cb431-18"><a href="#cb431-18" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; []</span>
<span id="cb431-19"><a href="#cb431-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb431-20"><a href="#cb431-20" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> eval2 subst e = eval_expr eval2 subst e</span>
<span id="cb431-21"><a href="#cb431-21" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> freevars2 e = freevars_expr freevars2 e</span>
<span id="cb431-22"><a href="#cb431-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb431-23"><a href="#cb431-23" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> test2 = Add (Mult (Num <span class="dv">3</span>, Var <span class="st">&quot;x&quot;</span>), Num <span class="dv">1</span>)</span>
<span id="cb431-24"><a href="#cb431-24" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> e_test2 = eval2 [] test2</span>
<span id="cb431-25"><a href="#cb431-25" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fv_test2 = freevars2 test2</span></code></pre></div>
<p>Merging the sub-languages:</p>
<div class="sourceCode" id="cb432"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb432-1"><a href="#cb432-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> eval_lexpr eval_rec subst e =</span>
<span id="cb432-2"><a href="#cb432-2" aria-hidden="true" tabindex="-1"></a>  eval_expr eval_rec subst (eval_lambda eval_rec subst e)</span>
<span id="cb432-3"><a href="#cb432-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb432-4"><a href="#cb432-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> freevars_lexpr freevars_rec e =</span>
<span id="cb432-5"><a href="#cb432-5" aria-hidden="true" tabindex="-1"></a>  freevars_lambda freevars_rec e @ freevars_expr freevars_rec e</span>
<span id="cb432-6"><a href="#cb432-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb432-7"><a href="#cb432-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> eval3 subst e = eval_lexpr eval3 subst e</span>
<span id="cb432-8"><a href="#cb432-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> freevars3 e = freevars_lexpr freevars3 e</span>
<span id="cb432-9"><a href="#cb432-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb432-10"><a href="#cb432-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> test3 =</span>
<span id="cb432-11"><a href="#cb432-11" aria-hidden="true" tabindex="-1"></a>  App (Abs (<span class="st">&quot;x&quot;</span>, Add (Mult (Num <span class="dv">3</span>, Var <span class="st">&quot;x&quot;</span>), Num <span class="dv">1</span>)),</span>
<span id="cb432-12"><a href="#cb432-12" aria-hidden="true" tabindex="-1"></a>       Num <span class="dv">2</span>)</span>
<span id="cb432-13"><a href="#cb432-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> e_test3 = eval3 [] test3</span>
<span id="cb432-14"><a href="#cb432-14" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fv_test3 = freevars3 test3</span></code></pre></div>
<h2 id="object-oriented-programming-subtyping">11.4 Object-Oriented
Programming: Subtyping</h2>
<p>Before examining OOP solutions to the expression problem, let us
understand OCaml’s object system.</p>
<p>OCaml’s <strong>objects</strong> are values, somewhat similar to
records. Viewed from the outside, an OCaml object has only
<strong>methods</strong>, identifying the code with which to respond to
messages (method invocations). All methods are
<strong>late-bound</strong>; the object determines what code is run
(i.e., <em>virtual</em> in C++ parlance). This is in contrast to
records, where field access is resolved at compile time.</p>
<p><strong>Subtyping</strong> determines if an object can be used in
some context. OCaml has <strong>structural subtyping</strong>: the
content of the types concerned (the methods they provide) decides if an
object can be used, not the name of the type or class. Parametric
polymorphism can be used to infer if an object has the required
methods.</p>
<div class="sourceCode" id="cb433"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb433-1"><a href="#cb433-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x = x#m  <span class="co">(* Method invocation: object#method *)</span></span>
<span id="cb433-2"><a href="#cb433-2" aria-hidden="true" tabindex="-1"></a><span class="co">(* val f : &lt; m : &#39;a; .. &gt; -&gt; &#39;a *)</span></span>
<span id="cb433-3"><a href="#cb433-3" aria-hidden="true" tabindex="-1"></a><span class="co">(* Type polymorphic in two ways: &#39;a is the method type, *)</span></span>
<span id="cb433-4"><a href="#cb433-4" aria-hidden="true" tabindex="-1"></a><span class="co">(* .. means that objects with more methods will be accepted *)</span></span></code></pre></div>
<p>Methods are computed when they are invoked, even if they do not take
arguments (unlike record fields, which are computed once when the record
is created). We define objects inside <code>object...end</code>
(compare: records <code>{...}</code>) using keywords:</p>
<ul>
<li><code>method</code> for methods (always late-bound)</li>
<li><code>val</code> for constant fields (only accessible within the
object)</li>
<li><code>val mutable</code> for mutable fields</li>
</ul>
<p>Constructor arguments can often be used instead of constant fields.
Here is a simple example:</p>
<div class="sourceCode" id="cb434"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb434-1"><a href="#cb434-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> square w = <span class="kw">object</span></span>
<span id="cb434-2"><a href="#cb434-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> area = <span class="dt">float_of_int</span> (w * w)</span>
<span id="cb434-3"><a href="#cb434-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> width = w</span>
<span id="cb434-4"><a href="#cb434-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>Subtyping often needs to be explicit: we write
<code>(object :&gt; supertype)</code> or in more complex cases
<code>(object : type :&gt; supertype)</code>.</p>
<p>Technically speaking, subtyping in OCaml always is explicit, and
<em>open types</em>, containing <code>..</code>, use <strong>row
polymorphism</strong> rather than subtyping.</p>
<div class="sourceCode" id="cb435"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb435-1"><a href="#cb435-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> a = <span class="kw">object</span> <span class="kw">method</span> m = <span class="dv">7</span>  <span class="kw">method</span> x = <span class="st">&quot;a&quot;</span> <span class="kw">end</span>  <span class="co">(* Toy example: object types *)</span></span>
<span id="cb435-2"><a href="#cb435-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> b = <span class="kw">object</span> <span class="kw">method</span> m = <span class="dv">42</span> <span class="kw">method</span> y = <span class="st">&quot;b&quot;</span> <span class="kw">end</span>  <span class="co">(* share some but not all methods *)</span></span>
<span id="cb435-3"><a href="#cb435-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb435-4"><a href="#cb435-4" aria-hidden="true" tabindex="-1"></a><span class="co">(* let l = [a; b]  -- Error: the exact types of the objects do not agree *)</span></span>
<span id="cb435-5"><a href="#cb435-5" aria-hidden="true" tabindex="-1"></a><span class="co">(* Error: This expression has type &lt; m : int; y : string &gt;</span></span>
<span id="cb435-6"><a href="#cb435-6" aria-hidden="true" tabindex="-1"></a><span class="co">         but an expression was expected of type &lt; m : int; x : string &gt;</span></span>
<span id="cb435-7"><a href="#cb435-7" aria-hidden="true" tabindex="-1"></a><span class="co">         The second object type has no method y *)</span></span>
<span id="cb435-8"><a href="#cb435-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb435-9"><a href="#cb435-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> l = [(a :&gt; &lt;m : &#39;a&gt;); (b :&gt; &lt;m : &#39;a&gt;)]  <span class="co">(* But the types share a supertype *)</span></span>
<span id="cb435-10"><a href="#cb435-10" aria-hidden="true" tabindex="-1"></a><span class="co">(* val l : &lt; m : int &gt; list *)</span></span></code></pre></div>
<h3 id="object-oriented-programming-inheritance">Object-Oriented
Programming: Inheritance</h3>
<p>The system of object classes in OCaml is similar to the module
system. Object classes are not types; rather, classes are a way to build
object <em>constructors</em>, which are functions that return objects.
Classes have their types, called class types (compare: modules and
signatures).</p>
<p>In OCaml parlance:</p>
<ul>
<li><strong>Late binding</strong> is not called anything special, since
all methods are late-bound (called <em>virtual</em> in C++)</li>
<li>A method or field declared to be defined in sub-classes is called
<strong>virtual</strong> (called <em>abstract</em> in C++); classes that
use virtual methods or fields are also called virtual</li>
<li>A method that is only visible in sub-classes is called
<strong>private</strong> (called <em>protected</em> in C++)</li>
<li>A method not visible outside the class is achieved by omitting it
from the class type (called <em>private</em> in C++) – you provide the
type for the class and omit the method in the class type, similar to
module signatures and <code>.mli</code> files</li>
</ul>
<p>OCaml allows <strong>multiple inheritance</strong>, which can be used
to implement <em>mixins</em> as virtual/abstract classes. Inheritance
works somewhat similarly to textual inclusion: the inherited class’s
methods and fields are copied into the inheriting class, but with late
binding preserved.</p>
<p>The <code>{&lt; ... &gt;}</code> syntax creates a <em>clone</em> of
the current object with some fields changed. This is essential for
functional-style object programming, where we create new objects rather
than mutating existing ones.</p>
<h2 id="direct-object-oriented-non-solution">11.5 Direct Object-Oriented
Non-Solution</h2>
<p>It turns out that although object-oriented programming was designed
with data extensibility in mind, it is a bad fit for recursive types
like those in the expression problem. Below is an attempt at solving our
problem using classes.</p>
<p>We can try to solve the expression problem using objects directly.
However, adding new functionality still requires modifying old code, so
this approach does not fully solve the expression problem.</p>
<p><strong>Non-solution penalty points:</strong></p>
<ul>
<li>No way to add functionality without modifying old code (in
particular, the abstract class and all concrete classes must be extended
with new methods)</li>
<li>Functions implemented for a broader language cannot handle values
from a narrower one</li>
<li>No deep pattern matching: we cannot examine the structure of nested
expressions</li>
</ul>
<p><strong>Verdict:</strong> Non-solution, and probably the worst
approach.</p>
<p>Here is an implementation using objects. The abstract class
<code>evaluable</code> defines the interface that all expression objects
must implement. For lambda calculus, we need helper methods:
<code>rename</code> for renaming free variables (needed for
alpha-conversion), and <code>apply</code> for beta-reduction when
possible:</p>
<div class="sourceCode" id="cb436"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb436-1"><a href="#cb436-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> var_name = <span class="dt">string</span></span>
<span id="cb436-2"><a href="#cb436-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb436-3"><a href="#cb436-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> gensym = <span class="kw">let</span> n = <span class="dt">ref</span> <span class="dv">0</span> <span class="kw">in</span> <span class="kw">fun</span> () -&gt; <span class="dt">incr</span> n; <span class="st">&quot;_&quot;</span> ^ <span class="dt">string_of_int</span> !n</span>
<span id="cb436-4"><a href="#cb436-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb436-5"><a href="#cb436-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="kw">virtual</span> [&#39;lang] evaluable =</span>
<span id="cb436-6"><a href="#cb436-6" aria-hidden="true" tabindex="-1"></a><span class="kw">object</span></span>
<span id="cb436-7"><a href="#cb436-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> <span class="kw">virtual</span> eval : (var_name * &#39;lang) <span class="dt">list</span> -&gt; &#39;lang</span>
<span id="cb436-8"><a href="#cb436-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> <span class="kw">virtual</span> rename : var_name -&gt; var_name -&gt; &#39;lang</span>
<span id="cb436-9"><a href="#cb436-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> apply (_arg : &#39;lang)</span>
<span id="cb436-10"><a href="#cb436-10" aria-hidden="true" tabindex="-1"></a>    (fallback : <span class="dt">unit</span> -&gt; &#39;lang) (_subst : (var_name * &#39;lang) <span class="dt">list</span>) =</span>
<span id="cb436-11"><a href="#cb436-11" aria-hidden="true" tabindex="-1"></a>    fallback ()</span>
<span id="cb436-12"><a href="#cb436-12" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb436-13"><a href="#cb436-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb436-14"><a href="#cb436-14" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> [&#39;lang] var (v : var_name) =</span>
<span id="cb436-15"><a href="#cb436-15" aria-hidden="true" tabindex="-1"></a><span class="kw">object</span> (self)  <span class="co">(* We name the current object `self` for later reference *)</span></span>
<span id="cb436-16"><a href="#cb436-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inherit</span> [&#39;lang] evaluable</span>
<span id="cb436-17"><a href="#cb436-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> v = v</span>
<span id="cb436-18"><a href="#cb436-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> eval subst =</span>
<span id="cb436-19"><a href="#cb436-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> <span class="dt">List</span>.assoc v subst <span class="kw">with</span> <span class="dt">Not_found</span> -&gt; self</span>
<span id="cb436-20"><a href="#cb436-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> rename v1 v2 =  <span class="co">(* Renaming a variable: *)</span></span>
<span id="cb436-21"><a href="#cb436-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> v = v1 <span class="kw">then</span> {&lt; v = v2 &gt;} <span class="kw">else</span> self  <span class="co">(* clone with new name if matched *)</span></span>
<span id="cb436-22"><a href="#cb436-22" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb436-23"><a href="#cb436-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb436-24"><a href="#cb436-24" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> [&#39;lang] <span class="dt">abs</span> (v : var_name) (body : &#39;lang) =</span>
<span id="cb436-25"><a href="#cb436-25" aria-hidden="true" tabindex="-1"></a><span class="kw">object</span> (self)</span>
<span id="cb436-26"><a href="#cb436-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inherit</span> [&#39;lang] evaluable</span>
<span id="cb436-27"><a href="#cb436-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> v = v</span>
<span id="cb436-28"><a href="#cb436-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> body = body</span>
<span id="cb436-29"><a href="#cb436-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> eval subst =  <span class="co">(* We do alpha-conversion prior to evaluation *)</span></span>
<span id="cb436-30"><a href="#cb436-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> v&#39; = gensym () <span class="kw">in</span>  <span class="co">(* Generate fresh name to avoid capture *)</span></span>
<span id="cb436-31"><a href="#cb436-31" aria-hidden="true" tabindex="-1"></a>    {&lt; v = v&#39;; body = (body#rename v v&#39;)#eval subst &gt;}</span>
<span id="cb436-32"><a href="#cb436-32" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> rename v1 v2 =  <span class="co">(* Renaming the free variable v1 *)</span></span>
<span id="cb436-33"><a href="#cb436-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> v = v1 <span class="kw">then</span> self  <span class="co">(* If v=v1, then v1 is bound here, not free -- no work *)</span></span>
<span id="cb436-34"><a href="#cb436-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> {&lt; body = body#rename v1 v2 &gt;}</span>
<span id="cb436-35"><a href="#cb436-35" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> apply arg _ subst =  <span class="co">(* Beta-reduction: substitute arg for v in body *)</span></span>
<span id="cb436-36"><a href="#cb436-36" aria-hidden="true" tabindex="-1"></a>    body#eval ((v, arg)::subst)</span>
<span id="cb436-37"><a href="#cb436-37" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb436-38"><a href="#cb436-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb436-39"><a href="#cb436-39" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> [&#39;lang] app (f : &#39;lang) (arg : &#39;lang) =</span>
<span id="cb436-40"><a href="#cb436-40" aria-hidden="true" tabindex="-1"></a><span class="kw">object</span> (self)</span>
<span id="cb436-41"><a href="#cb436-41" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inherit</span> [&#39;lang] evaluable</span>
<span id="cb436-42"><a href="#cb436-42" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> f = f</span>
<span id="cb436-43"><a href="#cb436-43" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> arg = arg</span>
<span id="cb436-44"><a href="#cb436-44" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> eval subst =  <span class="co">(* We use `apply` to differentiate between f=abs *)</span></span>
<span id="cb436-45"><a href="#cb436-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> arg&#39; = arg#eval subst <span class="kw">in</span>  <span class="co">(* (beta-redexes) and f&lt;&gt;abs *)</span></span>
<span id="cb436-46"><a href="#cb436-46" aria-hidden="true" tabindex="-1"></a>    f#apply arg&#39; (<span class="kw">fun</span> () -&gt; {&lt; f = f#eval subst; arg = arg&#39; &gt;}) subst</span>
<span id="cb436-47"><a href="#cb436-47" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> rename v1 v2 =  <span class="co">(* Cloning ensures result is subtype of &#39;lang *)</span></span>
<span id="cb436-48"><a href="#cb436-48" aria-hidden="true" tabindex="-1"></a>    {&lt; f = f#rename v1 v2; arg = arg#rename v1 v2 &gt;}  <span class="co">(* not just &#39;lang app *)</span></span>
<span id="cb436-49"><a href="#cb436-49" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb436-50"><a href="#cb436-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb436-51"><a href="#cb436-51" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> evaluable_t = evaluable_t evaluable</span>
<span id="cb436-52"><a href="#cb436-52" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> new_var1 v : evaluable_t = <span class="kw">new</span> var v</span>
<span id="cb436-53"><a href="#cb436-53" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> new_abs1 v (body : evaluable_t) : evaluable_t = <span class="kw">new</span> <span class="dt">abs</span> v body</span>
<span id="cb436-54"><a href="#cb436-54" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> new_app1 (arg1 : evaluable_t) (arg2 : evaluable_t) : evaluable_t =</span>
<span id="cb436-55"><a href="#cb436-55" aria-hidden="true" tabindex="-1"></a>  <span class="kw">new</span> app arg1 arg2</span>
<span id="cb436-56"><a href="#cb436-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb436-57"><a href="#cb436-57" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> test1 = new_app1 (new_abs1 <span class="st">&quot;x&quot;</span> (new_var1 <span class="st">&quot;x&quot;</span>)) (new_var1 <span class="st">&quot;y&quot;</span>)</span>
<span id="cb436-58"><a href="#cb436-58" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> e_test1 = test1#eval []</span></code></pre></div>
<p>Extending with arithmetic requires additional mixins. To use
lambda-expressions together with arithmetic expressions, we need to
upgrade them with a helper method <code>compute</code> that returns the
numeric value if one exists:</p>
<div class="sourceCode" id="cb437"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb437-1"><a href="#cb437-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="kw">virtual</span> compute_mixin = <span class="kw">object</span></span>
<span id="cb437-2"><a href="#cb437-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> compute : <span class="dt">int</span> <span class="dt">option</span> = <span class="dt">None</span></span>
<span id="cb437-3"><a href="#cb437-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb437-4"><a href="#cb437-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb437-5"><a href="#cb437-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> [&#39;lang] var_c v = <span class="kw">object</span></span>
<span id="cb437-6"><a href="#cb437-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inherit</span> [&#39;lang] var v</span>
<span id="cb437-7"><a href="#cb437-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inherit</span> compute_mixin</span>
<span id="cb437-8"><a href="#cb437-8" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb437-9"><a href="#cb437-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb437-10"><a href="#cb437-10" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> [&#39;lang] abs_c v body = <span class="kw">object</span></span>
<span id="cb437-11"><a href="#cb437-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inherit</span> [&#39;lang] <span class="dt">abs</span> v body</span>
<span id="cb437-12"><a href="#cb437-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inherit</span> compute_mixin</span>
<span id="cb437-13"><a href="#cb437-13" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb437-14"><a href="#cb437-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb437-15"><a href="#cb437-15" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> [&#39;lang] app_c f arg = <span class="kw">object</span></span>
<span id="cb437-16"><a href="#cb437-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inherit</span> [&#39;lang] app f arg</span>
<span id="cb437-17"><a href="#cb437-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inherit</span> compute_mixin</span>
<span id="cb437-18"><a href="#cb437-18" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb437-19"><a href="#cb437-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb437-20"><a href="#cb437-20" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> [&#39;lang] num (i : <span class="dt">int</span>) =</span>
<span id="cb437-21"><a href="#cb437-21" aria-hidden="true" tabindex="-1"></a><span class="kw">object</span> (self)</span>
<span id="cb437-22"><a href="#cb437-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inherit</span> [&#39;lang] evaluable</span>
<span id="cb437-23"><a href="#cb437-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> i = i</span>
<span id="cb437-24"><a href="#cb437-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> eval _subst = self</span>
<span id="cb437-25"><a href="#cb437-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> rename _ _ = self</span>
<span id="cb437-26"><a href="#cb437-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> compute = <span class="dt">Some</span> i</span>
<span id="cb437-27"><a href="#cb437-27" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb437-28"><a href="#cb437-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb437-29"><a href="#cb437-29" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="kw">virtual</span> [&#39;lang] operation</span>
<span id="cb437-30"><a href="#cb437-30" aria-hidden="true" tabindex="-1"></a>    (num_inst : <span class="dt">int</span> -&gt; &#39;lang) (n1 : &#39;lang) (n2 : &#39;lang) =</span>
<span id="cb437-31"><a href="#cb437-31" aria-hidden="true" tabindex="-1"></a><span class="kw">object</span> (self)</span>
<span id="cb437-32"><a href="#cb437-32" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inherit</span> [&#39;lang] evaluable</span>
<span id="cb437-33"><a href="#cb437-33" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> n1 = n1</span>
<span id="cb437-34"><a href="#cb437-34" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> n2 = n2</span>
<span id="cb437-35"><a href="#cb437-35" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> eval subst =</span>
<span id="cb437-36"><a href="#cb437-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> self&#39; = {&lt; n1 = n1#eval subst; n2 = n2#eval subst &gt;} <span class="kw">in</span></span>
<span id="cb437-37"><a href="#cb437-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> self&#39;#compute <span class="kw">with</span></span>
<span id="cb437-38"><a href="#cb437-38" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> i -&gt; num_inst i</span>
<span id="cb437-39"><a href="#cb437-39" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; self&#39;</span>
<span id="cb437-40"><a href="#cb437-40" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> rename v1 v2 = {&lt; n1 = n1#rename v1 v2; n2 = n2#rename v1 v2 &gt;}</span>
<span id="cb437-41"><a href="#cb437-41" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb437-42"><a href="#cb437-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb437-43"><a href="#cb437-43" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> [&#39;lang] add num_inst n1 n2 =</span>
<span id="cb437-44"><a href="#cb437-44" aria-hidden="true" tabindex="-1"></a><span class="kw">object</span> (self)</span>
<span id="cb437-45"><a href="#cb437-45" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inherit</span> [&#39;lang] operation num_inst n1 n2</span>
<span id="cb437-46"><a href="#cb437-46" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> compute =</span>
<span id="cb437-47"><a href="#cb437-47" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> n1#compute, n2#compute <span class="kw">with</span></span>
<span id="cb437-48"><a href="#cb437-48" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> i1, <span class="dt">Some</span> i2 -&gt; <span class="dt">Some</span> (i1 + i2)</span>
<span id="cb437-49"><a href="#cb437-49" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; <span class="dt">None</span></span>
<span id="cb437-50"><a href="#cb437-50" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb437-51"><a href="#cb437-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb437-52"><a href="#cb437-52" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> [&#39;lang] mult num_inst n1 n2 =</span>
<span id="cb437-53"><a href="#cb437-53" aria-hidden="true" tabindex="-1"></a><span class="kw">object</span> (self)</span>
<span id="cb437-54"><a href="#cb437-54" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inherit</span> [&#39;lang] operation num_inst n1 n2</span>
<span id="cb437-55"><a href="#cb437-55" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> compute =</span>
<span id="cb437-56"><a href="#cb437-56" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> n1#compute, n2#compute <span class="kw">with</span></span>
<span id="cb437-57"><a href="#cb437-57" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> i1, <span class="dt">Some</span> i2 -&gt; <span class="dt">Some</span> (i1 * i2)</span>
<span id="cb437-58"><a href="#cb437-58" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; <span class="dt">None</span></span>
<span id="cb437-59"><a href="#cb437-59" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb437-60"><a href="#cb437-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb437-61"><a href="#cb437-61" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="kw">virtual</span> [&#39;lang] computable =</span>
<span id="cb437-62"><a href="#cb437-62" aria-hidden="true" tabindex="-1"></a><span class="kw">object</span></span>
<span id="cb437-63"><a href="#cb437-63" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inherit</span> [&#39;lang] evaluable</span>
<span id="cb437-64"><a href="#cb437-64" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inherit</span> compute_mixin</span>
<span id="cb437-65"><a href="#cb437-65" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb437-66"><a href="#cb437-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb437-67"><a href="#cb437-67" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> computable_t = computable_t computable</span>
<span id="cb437-68"><a href="#cb437-68" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> new_var2 v : computable_t = <span class="kw">new</span> var_c v</span>
<span id="cb437-69"><a href="#cb437-69" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> new_abs2 v (body : computable_t) : computable_t = <span class="kw">new</span> abs_c v body</span>
<span id="cb437-70"><a href="#cb437-70" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> new_app2 v (body : computable_t) : computable_t = <span class="kw">new</span> app_c v body</span>
<span id="cb437-71"><a href="#cb437-71" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> new_num2 i : computable_t = <span class="kw">new</span> num i</span>
<span id="cb437-72"><a href="#cb437-72" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> new_add2 (n1 : computable_t) (n2 : computable_t) : computable_t =</span>
<span id="cb437-73"><a href="#cb437-73" aria-hidden="true" tabindex="-1"></a>  <span class="kw">new</span> add new_num2 n1 n2</span>
<span id="cb437-74"><a href="#cb437-74" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> new_mult2 (n1 : computable_t) (n2 : computable_t) : computable_t =</span>
<span id="cb437-75"><a href="#cb437-75" aria-hidden="true" tabindex="-1"></a>  <span class="kw">new</span> mult new_num2 n1 n2</span>
<span id="cb437-76"><a href="#cb437-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb437-77"><a href="#cb437-77" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> test2 =</span>
<span id="cb437-78"><a href="#cb437-78" aria-hidden="true" tabindex="-1"></a>  new_app2 (new_abs2 <span class="st">&quot;x&quot;</span> (new_add2 (new_mult2 (new_num2 <span class="dv">3</span>) (new_var2 <span class="st">&quot;x&quot;</span>))</span>
<span id="cb437-79"><a href="#cb437-79" aria-hidden="true" tabindex="-1"></a>                            (new_num2 <span class="dv">1</span>)))</span>
<span id="cb437-80"><a href="#cb437-80" aria-hidden="true" tabindex="-1"></a>    (new_num2 <span class="dv">2</span>)</span>
<span id="cb437-81"><a href="#cb437-81" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> e_test2 = test2#eval []</span></code></pre></div>
<h2 id="oop-non-solution-the-visitor-pattern">11.6 OOP Non-Solution: The
Visitor Pattern</h2>
<p>The <strong>visitor pattern</strong> is an object-oriented
programming pattern for turning objects into variants with shallow
pattern-matching (i.e., dispatch based on which variant a value is). It
effectively replaces data extensibility with operation extensibility:
instead of being able to add new data variants easily, we can add new
operations easily.</p>
<p>The key idea is that each data variant has an <code>accept</code>
method that takes a visitor object and calls the appropriate
<code>visit</code> method on it. This inverts the usual pattern
matching: instead of the function choosing which branch to take based on
the data, the data chooses which method to call on the visitor.</p>
<p><strong>Non-solution penalty points:</strong></p>
<ul>
<li>Adding new functionality requires modifying old code (the abstract
visitor class must declare new <code>visit</code> methods)</li>
<li>Heavy code bloat compared to pattern matching</li>
<li>No deep pattern matching: we can only dispatch on the outermost
constructor</li>
<li>Side-effects appear to be required for returning results (we store
computation results in mutable fields because keeping the visitor
polymorphic while having the result type depend on the visitor is
difficult)</li>
</ul>
<p><strong>Verdict:</strong> Poor solution, better than approaches we
considered so far, and worse than approaches we consider next.</p>
<div class="sourceCode" id="cb438"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb438-1"><a href="#cb438-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;visitor visitable = &lt; accept : &#39;visitor -&gt; <span class="dt">unit</span> &gt;</span>
<span id="cb438-2"><a href="#cb438-2" aria-hidden="true" tabindex="-1"></a><span class="co">(* The variants need be visitable *)</span></span>
<span id="cb438-3"><a href="#cb438-3" aria-hidden="true" tabindex="-1"></a><span class="co">(* We store the computation as side effect because of the difficulty *)</span></span>
<span id="cb438-4"><a href="#cb438-4" aria-hidden="true" tabindex="-1"></a><span class="co">(* to keep the visitor polymorphic but have the result type depend on the visitor *)</span></span>
<span id="cb438-5"><a href="#cb438-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb438-6"><a href="#cb438-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> var_name = <span class="dt">string</span></span>
<span id="cb438-7"><a href="#cb438-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb438-8"><a href="#cb438-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> [&#39;visitor] var (v : var_name) =</span>
<span id="cb438-9"><a href="#cb438-9" aria-hidden="true" tabindex="-1"></a><span class="kw">object</span> (self)  <span class="co">(* The &#39;visitor will determine the (sub)language *)</span></span>
<span id="cb438-10"><a href="#cb438-10" aria-hidden="true" tabindex="-1"></a>               <span class="co">(* to which a given var variant belongs *)</span></span>
<span id="cb438-11"><a href="#cb438-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> v = v</span>
<span id="cb438-12"><a href="#cb438-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> accept : &#39;visitor -&gt; <span class="dt">unit</span> =  <span class="co">(* The visitor pattern inverts the way *)</span></span>
<span id="cb438-13"><a href="#cb438-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fun</span> visitor -&gt; visitor#visitVar self  <span class="co">(* pattern matching proceeds: *)</span></span>
<span id="cb438-14"><a href="#cb438-14" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>                              <span class="co">(* the variant selects the computation *)</span></span>
<span id="cb438-15"><a href="#cb438-15" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> new_var v = (<span class="kw">new</span> var v :&gt; &#39;a visitable)</span>
<span id="cb438-16"><a href="#cb438-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb438-17"><a href="#cb438-17" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> [&#39;visitor] <span class="dt">abs</span> (v : var_name) (body : &#39;visitor visitable) =</span>
<span id="cb438-18"><a href="#cb438-18" aria-hidden="true" tabindex="-1"></a><span class="kw">object</span> (self)</span>
<span id="cb438-19"><a href="#cb438-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> v = v</span>
<span id="cb438-20"><a href="#cb438-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> body = body</span>
<span id="cb438-21"><a href="#cb438-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> accept : &#39;visitor -&gt; <span class="dt">unit</span> =</span>
<span id="cb438-22"><a href="#cb438-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fun</span> visitor -&gt; visitor#visitAbs self</span>
<span id="cb438-23"><a href="#cb438-23" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb438-24"><a href="#cb438-24" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> new_abs v body = (<span class="kw">new</span> <span class="dt">abs</span> v body :&gt; &#39;a visitable)</span>
<span id="cb438-25"><a href="#cb438-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb438-26"><a href="#cb438-26" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> [&#39;visitor] app (f : &#39;visitor visitable) (arg : &#39;visitor visitable) =</span>
<span id="cb438-27"><a href="#cb438-27" aria-hidden="true" tabindex="-1"></a><span class="kw">object</span> (self)</span>
<span id="cb438-28"><a href="#cb438-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> f = f</span>
<span id="cb438-29"><a href="#cb438-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> arg = arg</span>
<span id="cb438-30"><a href="#cb438-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> accept : &#39;visitor -&gt; <span class="dt">unit</span> =</span>
<span id="cb438-31"><a href="#cb438-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fun</span> visitor -&gt; visitor#visitApp self</span>
<span id="cb438-32"><a href="#cb438-32" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb438-33"><a href="#cb438-33" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> new_app f arg = (<span class="kw">new</span> app f arg :&gt; &#39;a visitable)</span>
<span id="cb438-34"><a href="#cb438-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb438-35"><a href="#cb438-35" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="kw">virtual</span> [&#39;visitor] lambda_visit =</span>
<span id="cb438-36"><a href="#cb438-36" aria-hidden="true" tabindex="-1"></a><span class="kw">object</span></span>
<span id="cb438-37"><a href="#cb438-37" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> <span class="kw">virtual</span> visitVar : &#39;visitor var -&gt; <span class="dt">unit</span></span>
<span id="cb438-38"><a href="#cb438-38" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> <span class="kw">virtual</span> visitAbs : &#39;visitor <span class="dt">abs</span> -&gt; <span class="dt">unit</span></span>
<span id="cb438-39"><a href="#cb438-39" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> <span class="kw">virtual</span> visitApp : &#39;visitor app -&gt; <span class="dt">unit</span></span>
<span id="cb438-40"><a href="#cb438-40" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb438-41"><a href="#cb438-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb438-42"><a href="#cb438-42" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> gensym = <span class="kw">let</span> n = <span class="dt">ref</span> <span class="dv">0</span> <span class="kw">in</span> <span class="kw">fun</span> () -&gt; <span class="dt">incr</span> n; <span class="st">&quot;_&quot;</span> ^ <span class="dt">string_of_int</span> !n</span>
<span id="cb438-43"><a href="#cb438-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb438-44"><a href="#cb438-44" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> [&#39;visitor] eval_lambda</span>
<span id="cb438-45"><a href="#cb438-45" aria-hidden="true" tabindex="-1"></a>  (subst : (var_name * &#39;visitor visitable) <span class="dt">list</span>)</span>
<span id="cb438-46"><a href="#cb438-46" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">result</span> : &#39;visitor visitable <span class="dt">ref</span>) =</span>
<span id="cb438-47"><a href="#cb438-47" aria-hidden="true" tabindex="-1"></a><span class="kw">object</span> (self)</span>
<span id="cb438-48"><a href="#cb438-48" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inherit</span> [&#39;visitor] lambda_visit</span>
<span id="cb438-49"><a href="#cb438-49" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> <span class="kw">mutable</span> subst = subst</span>
<span id="cb438-50"><a href="#cb438-50" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> <span class="kw">mutable</span> beta_redex : (var_name * &#39;visitor visitable) <span class="dt">option</span> = <span class="dt">None</span></span>
<span id="cb438-51"><a href="#cb438-51" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> visitVar var =</span>
<span id="cb438-52"><a href="#cb438-52" aria-hidden="true" tabindex="-1"></a>    beta_redex &lt;- <span class="dt">None</span>;</span>
<span id="cb438-53"><a href="#cb438-53" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> <span class="dt">result</span> := <span class="dt">List</span>.assoc var#v subst</span>
<span id="cb438-54"><a href="#cb438-54" aria-hidden="true" tabindex="-1"></a>    <span class="kw">with</span> <span class="dt">Not_found</span> -&gt; <span class="dt">result</span> := (var :&gt; &#39;visitor visitable)</span>
<span id="cb438-55"><a href="#cb438-55" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> visitAbs <span class="dt">abs</span> =</span>
<span id="cb438-56"><a href="#cb438-56" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> v&#39; = gensym () <span class="kw">in</span></span>
<span id="cb438-57"><a href="#cb438-57" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> orig_subst = subst <span class="kw">in</span></span>
<span id="cb438-58"><a href="#cb438-58" aria-hidden="true" tabindex="-1"></a>    subst &lt;- (abs#v, new_var v&#39;)::subst;</span>
<span id="cb438-59"><a href="#cb438-59" aria-hidden="true" tabindex="-1"></a>    (abs#body)#accept self;</span>
<span id="cb438-60"><a href="#cb438-60" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> body&#39; = !<span class="dt">result</span> <span class="kw">in</span></span>
<span id="cb438-61"><a href="#cb438-61" aria-hidden="true" tabindex="-1"></a>    subst &lt;- orig_subst;</span>
<span id="cb438-62"><a href="#cb438-62" aria-hidden="true" tabindex="-1"></a>    beta_redex &lt;- <span class="dt">Some</span> (v&#39;, body&#39;);</span>
<span id="cb438-63"><a href="#cb438-63" aria-hidden="true" tabindex="-1"></a>    <span class="dt">result</span> := new_abs v&#39; body&#39;</span>
<span id="cb438-64"><a href="#cb438-64" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> visitApp app =</span>
<span id="cb438-65"><a href="#cb438-65" aria-hidden="true" tabindex="-1"></a>    app#arg#accept self;</span>
<span id="cb438-66"><a href="#cb438-66" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> arg&#39; = !<span class="dt">result</span> <span class="kw">in</span></span>
<span id="cb438-67"><a href="#cb438-67" aria-hidden="true" tabindex="-1"></a>    app#f#accept self;</span>
<span id="cb438-68"><a href="#cb438-68" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> f&#39; = !<span class="dt">result</span> <span class="kw">in</span></span>
<span id="cb438-69"><a href="#cb438-69" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> beta_redex <span class="kw">with</span></span>
<span id="cb438-70"><a href="#cb438-70" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Some</span> (v&#39;, body&#39;) -&gt;</span>
<span id="cb438-71"><a href="#cb438-71" aria-hidden="true" tabindex="-1"></a>      beta_redex &lt;- <span class="dt">None</span>;</span>
<span id="cb438-72"><a href="#cb438-72" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> orig_subst = subst <span class="kw">in</span></span>
<span id="cb438-73"><a href="#cb438-73" aria-hidden="true" tabindex="-1"></a>      subst &lt;- (v&#39;, arg&#39;)::subst;</span>
<span id="cb438-74"><a href="#cb438-74" aria-hidden="true" tabindex="-1"></a>      body&#39;#accept self;</span>
<span id="cb438-75"><a href="#cb438-75" aria-hidden="true" tabindex="-1"></a>      subst &lt;- orig_subst</span>
<span id="cb438-76"><a href="#cb438-76" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">None</span> -&gt; <span class="dt">result</span> := new_app f&#39; arg&#39;</span>
<span id="cb438-77"><a href="#cb438-77" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb438-78"><a href="#cb438-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb438-79"><a href="#cb438-79" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> [&#39;visitor] freevars_lambda (<span class="dt">result</span> : var_name <span class="dt">list</span> <span class="dt">ref</span>) =</span>
<span id="cb438-80"><a href="#cb438-80" aria-hidden="true" tabindex="-1"></a><span class="kw">object</span> (self)</span>
<span id="cb438-81"><a href="#cb438-81" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inherit</span> [&#39;visitor] lambda_visit</span>
<span id="cb438-82"><a href="#cb438-82" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> visitVar var =</span>
<span id="cb438-83"><a href="#cb438-83" aria-hidden="true" tabindex="-1"></a>    <span class="dt">result</span> := var#v :: !<span class="dt">result</span></span>
<span id="cb438-84"><a href="#cb438-84" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> visitAbs <span class="dt">abs</span> =</span>
<span id="cb438-85"><a href="#cb438-85" aria-hidden="true" tabindex="-1"></a>    (abs#body)#accept self;</span>
<span id="cb438-86"><a href="#cb438-86" aria-hidden="true" tabindex="-1"></a>    <span class="dt">result</span> := <span class="dt">List</span>.filter (<span class="kw">fun</span> v&#39; -&gt; v&#39; &lt;&gt; abs#v) !<span class="dt">result</span></span>
<span id="cb438-87"><a href="#cb438-87" aria-hidden="true" tabindex="-1"></a>  <span class="kw">method</span> visitApp app =</span>
<span id="cb438-88"><a href="#cb438-88" aria-hidden="true" tabindex="-1"></a>    app#arg#accept self; app#f#accept self</span>
<span id="cb438-89"><a href="#cb438-89" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb438-90"><a href="#cb438-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb438-91"><a href="#cb438-91" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> lambda_visit_t = lambda_visit_t lambda_visit</span>
<span id="cb438-92"><a href="#cb438-92" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> lambda_t = lambda_visit_t visitable</span>
<span id="cb438-93"><a href="#cb438-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb438-94"><a href="#cb438-94" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> eval1 (e : lambda_t) subst : lambda_t =</span>
<span id="cb438-95"><a href="#cb438-95" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="dt">result</span> = <span class="dt">ref</span> (new_var <span class="st">&quot;&quot;</span>) <span class="kw">in</span></span>
<span id="cb438-96"><a href="#cb438-96" aria-hidden="true" tabindex="-1"></a>  e#accept (<span class="kw">new</span> eval_lambda subst <span class="dt">result</span> :&gt; lambda_visit_t);</span>
<span id="cb438-97"><a href="#cb438-97" aria-hidden="true" tabindex="-1"></a>  !<span class="dt">result</span></span>
<span id="cb438-98"><a href="#cb438-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb438-99"><a href="#cb438-99" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> freevars1 (e : lambda_t) =</span>
<span id="cb438-100"><a href="#cb438-100" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="dt">result</span> = <span class="dt">ref</span> [] <span class="kw">in</span></span>
<span id="cb438-101"><a href="#cb438-101" aria-hidden="true" tabindex="-1"></a>  e#accept (<span class="kw">new</span> freevars_lambda <span class="dt">result</span>);</span>
<span id="cb438-102"><a href="#cb438-102" aria-hidden="true" tabindex="-1"></a>  !<span class="dt">result</span></span>
<span id="cb438-103"><a href="#cb438-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb438-104"><a href="#cb438-104" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> test1 =</span>
<span id="cb438-105"><a href="#cb438-105" aria-hidden="true" tabindex="-1"></a>  (new_app (new_abs <span class="st">&quot;x&quot;</span> (new_var <span class="st">&quot;x&quot;</span>)) (new_var <span class="st">&quot;y&quot;</span>) :&gt; lambda_t)</span>
<span id="cb438-106"><a href="#cb438-106" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> e_test = eval1 test1 []</span>
<span id="cb438-107"><a href="#cb438-107" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fv_test = freevars1 test1</span></code></pre></div>
<p>Extending with arithmetic expressions follows a similar pattern, and
the merged language visitor inherits from both <code>lambda_visit</code>
and <code>expr_visit</code>.</p>
<h2 id="polymorphic-variants">11.7 Polymorphic Variants</h2>
<p><strong>Polymorphic variants</strong> provide a flexible alternative
to standard variants. They are to ordinary variants as objects are to
records: both enable <em>open types</em> and subtyping, both allow
different types to share the same components.</p>
<p>Interestingly, they are <em>dual</em> concepts: if we replace
“product” of records/objects by “sum” (as we discussed in earlier
chapters), we get variants/polymorphic variants. This duality implies
many behaviors are opposite. For example:</p>
<ul>
<li>While object subtypes have <em>more</em> methods, polymorphic
variant subtypes have <em>fewer</em> tags</li>
<li>The <code>&gt;</code> sign means “these tags or more” (open for
adding tags)</li>
<li>The <code>&lt;</code> sign means “these tags or less” (closed to
these tags only)</li>
<li>No sign means a closed type</li>
</ul>
<p>Because distinct polymorphic variant types can share the same tags,
the solution to the Expression Problem becomes straightforward: we can
define sub-languages with overlapping tags and compose them.</p>
<p><strong>Penalty points:</strong></p>
<ul>
<li>Requires explicit type annotations more often than regular
variants</li>
<li>Requires “tying the recursive knots” for types, e.g.,
<code>type lambda_t = lambda_t lambda</code></li>
<li>The need to tie the recursive knot separately at both the type level
and the function level. At the function level, an eta-expansion is
sometimes required due to the <em>value recursion</em> problem</li>
<li>There can be a slight time cost compared to the visitor pattern:
additional dispatch at each level of type aggregation (i.e., merging
sub-languages)</li>
</ul>
<p><strong>Verdict:</strong> A flexible and concise solution,
second-best place overall.</p>
<div class="sourceCode" id="cb439"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb439-1"><a href="#cb439-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> var = [`Var <span class="kw">of</span> <span class="dt">string</span>]</span>
<span id="cb439-2"><a href="#cb439-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb439-3"><a href="#cb439-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> eval_var sub (`Var s <span class="kw">as</span> v : var) =</span>
<span id="cb439-4"><a href="#cb439-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">try</span> <span class="dt">List</span>.assoc s sub <span class="kw">with</span> <span class="dt">Not_found</span> -&gt; v</span>
<span id="cb439-5"><a href="#cb439-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb439-6"><a href="#cb439-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a lambda =</span>
<span id="cb439-7"><a href="#cb439-7" aria-hidden="true" tabindex="-1"></a>  [`Var <span class="kw">of</span> <span class="dt">string</span> | `Abs <span class="kw">of</span> <span class="dt">string</span> * &#39;a | `App <span class="kw">of</span> &#39;a * &#39;a]</span>
<span id="cb439-8"><a href="#cb439-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb439-9"><a href="#cb439-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> gensym = <span class="kw">let</span> n = <span class="dt">ref</span> <span class="dv">0</span> <span class="kw">in</span> <span class="kw">fun</span> () -&gt; <span class="dt">incr</span> n; <span class="st">&quot;_&quot;</span> ^ <span class="dt">string_of_int</span> !n</span>
<span id="cb439-10"><a href="#cb439-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb439-11"><a href="#cb439-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> eval_lambda eval_rec subst : &#39;a lambda -&gt; &#39;a = <span class="kw">function</span></span>
<span id="cb439-12"><a href="#cb439-12" aria-hidden="true" tabindex="-1"></a>  | #var <span class="kw">as</span> v -&gt; eval_var subst v  <span class="co">(* We could also leave the type open *)</span></span>
<span id="cb439-13"><a href="#cb439-13" aria-hidden="true" tabindex="-1"></a>  | `App (l1, l2) -&gt;               <span class="co">(* rather than closing it to `lambda` *)</span></span>
<span id="cb439-14"><a href="#cb439-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> l2&#39; = eval_rec subst l2 <span class="kw">in</span></span>
<span id="cb439-15"><a href="#cb439-15" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">match</span> eval_rec subst l1 <span class="kw">with</span></span>
<span id="cb439-16"><a href="#cb439-16" aria-hidden="true" tabindex="-1"></a>    | `Abs (s, body) -&gt;</span>
<span id="cb439-17"><a href="#cb439-17" aria-hidden="true" tabindex="-1"></a>      eval_rec [s, l2&#39;] body</span>
<span id="cb439-18"><a href="#cb439-18" aria-hidden="true" tabindex="-1"></a>    | l1&#39; -&gt; `App (l1&#39;, l2&#39;))</span>
<span id="cb439-19"><a href="#cb439-19" aria-hidden="true" tabindex="-1"></a>  | `Abs (s, l1) -&gt;</span>
<span id="cb439-20"><a href="#cb439-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s&#39; = gensym () <span class="kw">in</span></span>
<span id="cb439-21"><a href="#cb439-21" aria-hidden="true" tabindex="-1"></a>    `Abs (s&#39;, eval_rec ((s, `Var s&#39;)::subst) l1)</span>
<span id="cb439-22"><a href="#cb439-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb439-23"><a href="#cb439-23" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> freevars_lambda freevars_rec : &#39;a lambda -&gt; &#39;b = <span class="kw">function</span></span>
<span id="cb439-24"><a href="#cb439-24" aria-hidden="true" tabindex="-1"></a>  | `Var v -&gt; [v]</span>
<span id="cb439-25"><a href="#cb439-25" aria-hidden="true" tabindex="-1"></a>  | `App (l1, l2) -&gt; freevars_rec l1 @ freevars_rec l2</span>
<span id="cb439-26"><a href="#cb439-26" aria-hidden="true" tabindex="-1"></a>  | `Abs (s, l1) -&gt;</span>
<span id="cb439-27"><a href="#cb439-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">List</span>.filter (<span class="kw">fun</span> v -&gt; v &lt;&gt; s) (freevars_rec l1)</span>
<span id="cb439-28"><a href="#cb439-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb439-29"><a href="#cb439-29" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> lambda_t = lambda_t lambda</span>
<span id="cb439-30"><a href="#cb439-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb439-31"><a href="#cb439-31" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> eval1 subst e : lambda_t = eval_lambda eval1 subst e</span>
<span id="cb439-32"><a href="#cb439-32" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> freevars1 (e : lambda_t) = freevars_lambda freevars1 e</span>
<span id="cb439-33"><a href="#cb439-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb439-34"><a href="#cb439-34" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> test1 = (`App (`Abs (<span class="st">&quot;x&quot;</span>, `Var <span class="st">&quot;x&quot;</span>), `Var <span class="st">&quot;y&quot;</span>) :&gt; lambda_t)</span>
<span id="cb439-35"><a href="#cb439-35" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> e_test = eval1 [] test1</span>
<span id="cb439-36"><a href="#cb439-36" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fv_test = freevars1 test1</span></code></pre></div>
<p>The arithmetic expression sub-language:</p>
<div class="sourceCode" id="cb440"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb440-1"><a href="#cb440-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a expr =</span>
<span id="cb440-2"><a href="#cb440-2" aria-hidden="true" tabindex="-1"></a>  [`Var <span class="kw">of</span> <span class="dt">string</span> | `Num <span class="kw">of</span> <span class="dt">int</span> | `Add <span class="kw">of</span> &#39;a * &#39;a | `Mult <span class="kw">of</span> &#39;a * &#39;a]</span>
<span id="cb440-3"><a href="#cb440-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb440-4"><a href="#cb440-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> map_expr (f : _ -&gt; &#39;a) : &#39;a expr -&gt; &#39;a = <span class="kw">function</span></span>
<span id="cb440-5"><a href="#cb440-5" aria-hidden="true" tabindex="-1"></a>  | #var <span class="kw">as</span> v -&gt; v</span>
<span id="cb440-6"><a href="#cb440-6" aria-hidden="true" tabindex="-1"></a>  | `Num _ <span class="kw">as</span> n -&gt; n</span>
<span id="cb440-7"><a href="#cb440-7" aria-hidden="true" tabindex="-1"></a>  | `Add (e1, e2) -&gt; `Add (f e1, f e2)</span>
<span id="cb440-8"><a href="#cb440-8" aria-hidden="true" tabindex="-1"></a>  | `Mult (e1, e2) -&gt; `Mult (f e1, f e2)</span>
<span id="cb440-9"><a href="#cb440-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb440-10"><a href="#cb440-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> eval_expr eval_rec subst (e : &#39;a expr) : &#39;a =</span>
<span id="cb440-11"><a href="#cb440-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> map_expr (eval_rec subst) e <span class="kw">with</span></span>
<span id="cb440-12"><a href="#cb440-12" aria-hidden="true" tabindex="-1"></a>  | #var <span class="kw">as</span> v -&gt; eval_var subst v  <span class="co">(* Here and elsewhere, we could also *)</span></span>
<span id="cb440-13"><a href="#cb440-13" aria-hidden="true" tabindex="-1"></a>  | `Add (`Num m, `Num n) -&gt; `Num (m + n)  <span class="co">(* factor-out the sub-language *)</span></span>
<span id="cb440-14"><a href="#cb440-14" aria-hidden="true" tabindex="-1"></a>  | `Mult (`Num m, `Num n) -&gt; `Num (m * n)  <span class="co">(* of variables *)</span></span>
<span id="cb440-15"><a href="#cb440-15" aria-hidden="true" tabindex="-1"></a>  | e -&gt; e</span>
<span id="cb440-16"><a href="#cb440-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb440-17"><a href="#cb440-17" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> freevars_expr freevars_rec : &#39;a expr -&gt; &#39;b = <span class="kw">function</span></span>
<span id="cb440-18"><a href="#cb440-18" aria-hidden="true" tabindex="-1"></a>  | `Var v -&gt; [v]</span>
<span id="cb440-19"><a href="#cb440-19" aria-hidden="true" tabindex="-1"></a>  | `Num _ -&gt; []</span>
<span id="cb440-20"><a href="#cb440-20" aria-hidden="true" tabindex="-1"></a>  | `Add (e1, e2) | `Mult (e1, e2) -&gt; freevars_rec e1 @ freevars_rec e2</span>
<span id="cb440-21"><a href="#cb440-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb440-22"><a href="#cb440-22" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> expr_t = expr_t expr</span>
<span id="cb440-23"><a href="#cb440-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb440-24"><a href="#cb440-24" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> eval2 subst e : expr_t = eval_expr eval2 subst e</span>
<span id="cb440-25"><a href="#cb440-25" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> freevars2 (e : expr_t) = freevars_expr freevars2 e</span>
<span id="cb440-26"><a href="#cb440-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb440-27"><a href="#cb440-27" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> test2 = (`Add (`Mult (`Num <span class="dv">3</span>, `Var <span class="st">&quot;x&quot;</span>), `Num <span class="dv">1</span>) : expr_t)</span>
<span id="cb440-28"><a href="#cb440-28" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> e_test2 = eval2 [<span class="st">&quot;x&quot;</span>, `Num <span class="dv">2</span>] test2</span>
<span id="cb440-29"><a href="#cb440-29" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fv_test2 = freevars2 test2</span></code></pre></div>
<p>Merging the sub-languages:</p>
<div class="sourceCode" id="cb441"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb441-1"><a href="#cb441-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a lexpr = [&#39;a lambda | &#39;a expr]</span>
<span id="cb441-2"><a href="#cb441-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb441-3"><a href="#cb441-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> eval_lexpr eval_rec subst : &#39;a lexpr -&gt; &#39;a = <span class="kw">function</span></span>
<span id="cb441-4"><a href="#cb441-4" aria-hidden="true" tabindex="-1"></a>  | #lambda <span class="kw">as</span> x -&gt; eval_lambda eval_rec subst x</span>
<span id="cb441-5"><a href="#cb441-5" aria-hidden="true" tabindex="-1"></a>  | #expr <span class="kw">as</span> x -&gt; eval_expr eval_rec subst x</span>
<span id="cb441-6"><a href="#cb441-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb441-7"><a href="#cb441-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> freevars_lexpr freevars_rec : &#39;a lexpr -&gt; &#39;b = <span class="kw">function</span></span>
<span id="cb441-8"><a href="#cb441-8" aria-hidden="true" tabindex="-1"></a>  | #lambda <span class="kw">as</span> x -&gt; freevars_lambda freevars_rec x</span>
<span id="cb441-9"><a href="#cb441-9" aria-hidden="true" tabindex="-1"></a>  | #expr <span class="kw">as</span> x -&gt; freevars_expr freevars_rec x</span>
<span id="cb441-10"><a href="#cb441-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb441-11"><a href="#cb441-11" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> lexpr_t = lexpr_t lexpr</span>
<span id="cb441-12"><a href="#cb441-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb441-13"><a href="#cb441-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> eval3 subst e : lexpr_t = eval_lexpr eval3 subst e</span>
<span id="cb441-14"><a href="#cb441-14" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> freevars3 (e : lexpr_t) = freevars_lexpr freevars3 e</span>
<span id="cb441-15"><a href="#cb441-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb441-16"><a href="#cb441-16" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> test3 =</span>
<span id="cb441-17"><a href="#cb441-17" aria-hidden="true" tabindex="-1"></a>  (`App (`Abs (<span class="st">&quot;x&quot;</span>, `Add (`Mult (`Num <span class="dv">3</span>, `Var <span class="st">&quot;x&quot;</span>), `Num <span class="dv">1</span>)),</span>
<span id="cb441-18"><a href="#cb441-18" aria-hidden="true" tabindex="-1"></a>         `Num <span class="dv">2</span>) : lexpr_t)</span>
<span id="cb441-19"><a href="#cb441-19" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> e_test3 = eval3 [] test3</span>
<span id="cb441-20"><a href="#cb441-20" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fv_test3 = freevars3 test3</span>
<span id="cb441-21"><a href="#cb441-21" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> e_old_test = eval3 [] (test2 :&gt; lexpr_t)</span>
<span id="cb441-22"><a href="#cb441-22" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fv_old_test = freevars3 (test2 :&gt; lexpr_t)</span></code></pre></div>
<h2 id="polymorphic-variants-with-recursive-modules">11.8 Polymorphic
Variants with Recursive Modules</h2>
<p>Using recursive modules, we can clean up the confusing or cluttering
aspects of tying the recursive knots: type variables and recursive call
arguments. The module system handles the recursion for us, making the
code cleaner and more modular.</p>
<p>We need <strong>private types</strong>, which for objects and
polymorphic variants means <em>private rows</em>. We can conceive of
open row types, e.g., <code>[&gt; \</code>Int of int | `String of
string]<code>as using a *row variable*, e.g.,</code>’a`:</p>
<pre><code>[`Int of int | `String of string | &#39;a]</code></pre>
<p>and then of private row types as abstracting the row variable:</p>
<pre><code>type &#39;row t = [`Int of int | `String of string | &#39;row]</code></pre>
<p>But the actual formalization of private row types is more complex.
The key point is that private row types allow us to specify that a type
is “at least” a certain set of variants, while still being
extensible.</p>
<p><strong>Penalty points:</strong></p>
<ul>
<li>We still need to tie the recursive knots for types, for example
<code>private [&gt; 'a lambda] as 'a</code></li>
<li>There can be slight time costs due to the use of functors and
dispatch on merging of sub-languages</li>
</ul>
<p><strong>Verdict:</strong> A clean solution, best place. The recursive
module approach is the most elegant solution we have seen so far.</p>
<div class="sourceCode" id="cb444"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb444-1"><a href="#cb444-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> var = [`Var <span class="kw">of</span> <span class="dt">string</span>]</span>
<span id="cb444-2"><a href="#cb444-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb444-3"><a href="#cb444-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> eval_var subst (`Var s <span class="kw">as</span> v : var) =</span>
<span id="cb444-4"><a href="#cb444-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">try</span> <span class="dt">List</span>.assoc s subst <span class="kw">with</span> <span class="dt">Not_found</span> -&gt; v</span>
<span id="cb444-5"><a href="#cb444-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb444-6"><a href="#cb444-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a lambda =</span>
<span id="cb444-7"><a href="#cb444-7" aria-hidden="true" tabindex="-1"></a>  [`Var <span class="kw">of</span> <span class="dt">string</span> | `Abs <span class="kw">of</span> <span class="dt">string</span> * &#39;a | `App <span class="kw">of</span> &#39;a * &#39;a]</span>
<span id="cb444-8"><a href="#cb444-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb444-9"><a href="#cb444-9" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">type</span> Eval =</span>
<span id="cb444-10"><a href="#cb444-10" aria-hidden="true" tabindex="-1"></a><span class="kw">sig</span> <span class="kw">type</span> <span class="dt">exp</span> <span class="kw">val</span> eval : (<span class="dt">string</span> * <span class="dt">exp</span>) <span class="dt">list</span> -&gt; <span class="dt">exp</span> -&gt; <span class="dt">exp</span> <span class="kw">end</span></span>
<span id="cb444-11"><a href="#cb444-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb444-12"><a href="#cb444-12" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> LF(X : Eval <span class="kw">with</span> <span class="kw">type</span> <span class="dt">exp</span> = <span class="kw">private</span> [&gt; &#39;a lambda] <span class="kw">as</span> &#39;a) =</span>
<span id="cb444-13"><a href="#cb444-13" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span></span>
<span id="cb444-14"><a href="#cb444-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">exp</span> = X.<span class="dt">exp</span> lambda</span>
<span id="cb444-15"><a href="#cb444-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb444-16"><a href="#cb444-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> gensym = <span class="kw">let</span> n = <span class="dt">ref</span> <span class="dv">0</span> <span class="kw">in</span> <span class="kw">fun</span> () -&gt; <span class="dt">incr</span> n; <span class="st">&quot;_&quot;</span> ^ <span class="dt">string_of_int</span> !n</span>
<span id="cb444-17"><a href="#cb444-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb444-18"><a href="#cb444-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> eval subst : <span class="dt">exp</span> -&gt; X.<span class="dt">exp</span> = <span class="kw">function</span></span>
<span id="cb444-19"><a href="#cb444-19" aria-hidden="true" tabindex="-1"></a>    | #var <span class="kw">as</span> v -&gt; eval_var subst v</span>
<span id="cb444-20"><a href="#cb444-20" aria-hidden="true" tabindex="-1"></a>    | `App (l1, l2) -&gt;</span>
<span id="cb444-21"><a href="#cb444-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> l2&#39; = X.eval subst l2 <span class="kw">in</span></span>
<span id="cb444-22"><a href="#cb444-22" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">match</span> X.eval subst l1 <span class="kw">with</span></span>
<span id="cb444-23"><a href="#cb444-23" aria-hidden="true" tabindex="-1"></a>      | `Abs (s, body) -&gt;</span>
<span id="cb444-24"><a href="#cb444-24" aria-hidden="true" tabindex="-1"></a>        X.eval [s, l2&#39;] body</span>
<span id="cb444-25"><a href="#cb444-25" aria-hidden="true" tabindex="-1"></a>      | l1&#39; -&gt; `App (l1&#39;, l2&#39;))</span>
<span id="cb444-26"><a href="#cb444-26" aria-hidden="true" tabindex="-1"></a>    | `Abs (s, l1) -&gt;</span>
<span id="cb444-27"><a href="#cb444-27" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> s&#39; = gensym () <span class="kw">in</span></span>
<span id="cb444-28"><a href="#cb444-28" aria-hidden="true" tabindex="-1"></a>      `Abs (s&#39;, X.eval ((s, `Var s&#39;)::subst) l1)</span>
<span id="cb444-29"><a href="#cb444-29" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb444-30"><a href="#cb444-30" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">rec</span> Lambda : (Eval <span class="kw">with</span> <span class="kw">type</span> <span class="dt">exp</span> = Lambda.<span class="dt">exp</span> lambda) =</span>
<span id="cb444-31"><a href="#cb444-31" aria-hidden="true" tabindex="-1"></a>  LF(Lambda)</span>
<span id="cb444-32"><a href="#cb444-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb444-33"><a href="#cb444-33" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">type</span> FreeVars =</span>
<span id="cb444-34"><a href="#cb444-34" aria-hidden="true" tabindex="-1"></a><span class="kw">sig</span> <span class="kw">type</span> <span class="dt">exp</span> <span class="kw">val</span> freevars : <span class="dt">exp</span> -&gt; <span class="dt">string</span> <span class="dt">list</span> <span class="kw">end</span></span>
<span id="cb444-35"><a href="#cb444-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb444-36"><a href="#cb444-36" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> LFVF(X : FreeVars <span class="kw">with</span> <span class="kw">type</span> <span class="dt">exp</span> = <span class="kw">private</span> [&gt; &#39;a lambda] <span class="kw">as</span> &#39;a) =</span>
<span id="cb444-37"><a href="#cb444-37" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span></span>
<span id="cb444-38"><a href="#cb444-38" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">exp</span> = X.<span class="dt">exp</span> lambda</span>
<span id="cb444-39"><a href="#cb444-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb444-40"><a href="#cb444-40" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> freevars : <span class="dt">exp</span> -&gt; &#39;b = <span class="kw">function</span></span>
<span id="cb444-41"><a href="#cb444-41" aria-hidden="true" tabindex="-1"></a>    | `Var v -&gt; [v]</span>
<span id="cb444-42"><a href="#cb444-42" aria-hidden="true" tabindex="-1"></a>    | `App (l1, l2) -&gt; X.freevars l1 @ X.freevars l2</span>
<span id="cb444-43"><a href="#cb444-43" aria-hidden="true" tabindex="-1"></a>    | `Abs (s, l1) -&gt;</span>
<span id="cb444-44"><a href="#cb444-44" aria-hidden="true" tabindex="-1"></a>      <span class="dt">List</span>.filter (<span class="kw">fun</span> v -&gt; v &lt;&gt; s) (X.freevars l1)</span>
<span id="cb444-45"><a href="#cb444-45" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb444-46"><a href="#cb444-46" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">rec</span> LambdaFV : (FreeVars <span class="kw">with</span> <span class="kw">type</span> <span class="dt">exp</span> = LambdaFV.<span class="dt">exp</span> lambda) =</span>
<span id="cb444-47"><a href="#cb444-47" aria-hidden="true" tabindex="-1"></a>  LFVF(LambdaFV)</span>
<span id="cb444-48"><a href="#cb444-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb444-49"><a href="#cb444-49" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> test1 = (`App (`Abs (<span class="st">&quot;x&quot;</span>, `Var <span class="st">&quot;x&quot;</span>), `Var <span class="st">&quot;y&quot;</span>) : Lambda.<span class="dt">exp</span>)</span>
<span id="cb444-50"><a href="#cb444-50" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> e_test = Lambda.eval [] test1</span>
<span id="cb444-51"><a href="#cb444-51" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fv_test = LambdaFV.freevars test1</span></code></pre></div>
<p>The arithmetic expression sub-language:</p>
<div class="sourceCode" id="cb445"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb445-1"><a href="#cb445-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a expr =</span>
<span id="cb445-2"><a href="#cb445-2" aria-hidden="true" tabindex="-1"></a>  [`Var <span class="kw">of</span> <span class="dt">string</span> | `Num <span class="kw">of</span> <span class="dt">int</span> | `Add <span class="kw">of</span> &#39;a * &#39;a | `Mult <span class="kw">of</span> &#39;a * &#39;a]</span>
<span id="cb445-3"><a href="#cb445-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb445-4"><a href="#cb445-4" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">type</span> Operations =</span>
<span id="cb445-5"><a href="#cb445-5" aria-hidden="true" tabindex="-1"></a><span class="kw">sig</span> <span class="kw">include</span> Eval <span class="kw">include</span> FreeVars <span class="kw">with</span> <span class="kw">type</span> <span class="dt">exp</span> := <span class="dt">exp</span> <span class="kw">end</span></span>
<span id="cb445-6"><a href="#cb445-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb445-7"><a href="#cb445-7" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> EF(X : Operations <span class="kw">with</span> <span class="kw">type</span> <span class="dt">exp</span> = <span class="kw">private</span> [&gt; &#39;a expr] <span class="kw">as</span> &#39;a) =</span>
<span id="cb445-8"><a href="#cb445-8" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span></span>
<span id="cb445-9"><a href="#cb445-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">exp</span> = X.<span class="dt">exp</span> expr</span>
<span id="cb445-10"><a href="#cb445-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb445-11"><a href="#cb445-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> map_expr f = <span class="kw">function</span></span>
<span id="cb445-12"><a href="#cb445-12" aria-hidden="true" tabindex="-1"></a>    | #var <span class="kw">as</span> v -&gt; v</span>
<span id="cb445-13"><a href="#cb445-13" aria-hidden="true" tabindex="-1"></a>    | `Num _ <span class="kw">as</span> n -&gt; n</span>
<span id="cb445-14"><a href="#cb445-14" aria-hidden="true" tabindex="-1"></a>    | `Add (e1, e2) -&gt; `Add (f e1, f e2)</span>
<span id="cb445-15"><a href="#cb445-15" aria-hidden="true" tabindex="-1"></a>    | `Mult (e1, e2) -&gt; `Mult (f e1, f e2)</span>
<span id="cb445-16"><a href="#cb445-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb445-17"><a href="#cb445-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> eval subst (e : <span class="dt">exp</span>) : X.<span class="dt">exp</span> =</span>
<span id="cb445-18"><a href="#cb445-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> map_expr (X.eval subst) e <span class="kw">with</span></span>
<span id="cb445-19"><a href="#cb445-19" aria-hidden="true" tabindex="-1"></a>    | #var <span class="kw">as</span> v -&gt; eval_var subst v</span>
<span id="cb445-20"><a href="#cb445-20" aria-hidden="true" tabindex="-1"></a>    | `Add (`Num m, `Num n) -&gt; `Num (m + n)</span>
<span id="cb445-21"><a href="#cb445-21" aria-hidden="true" tabindex="-1"></a>    | `Mult (`Num m, `Num n) -&gt; `Num (m * n)</span>
<span id="cb445-22"><a href="#cb445-22" aria-hidden="true" tabindex="-1"></a>    | e -&gt; e</span>
<span id="cb445-23"><a href="#cb445-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb445-24"><a href="#cb445-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> freevars : <span class="dt">exp</span> -&gt; &#39;b = <span class="kw">function</span></span>
<span id="cb445-25"><a href="#cb445-25" aria-hidden="true" tabindex="-1"></a>    | `Var v -&gt; [v]</span>
<span id="cb445-26"><a href="#cb445-26" aria-hidden="true" tabindex="-1"></a>    | `Num _ -&gt; []</span>
<span id="cb445-27"><a href="#cb445-27" aria-hidden="true" tabindex="-1"></a>    | `Add (e1, e2) | `Mult (e1, e2) -&gt; X.freevars e1 @ X.freevars e2</span>
<span id="cb445-28"><a href="#cb445-28" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb445-29"><a href="#cb445-29" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">rec</span> Expr : (Operations <span class="kw">with</span> <span class="kw">type</span> <span class="dt">exp</span> = Expr.<span class="dt">exp</span> expr) =</span>
<span id="cb445-30"><a href="#cb445-30" aria-hidden="true" tabindex="-1"></a>  EF(Expr)</span>
<span id="cb445-31"><a href="#cb445-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb445-32"><a href="#cb445-32" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> test2 = (`Add (`Mult (`Num <span class="dv">3</span>, `Var <span class="st">&quot;x&quot;</span>), `Num <span class="dv">1</span>) : Expr.<span class="dt">exp</span>)</span>
<span id="cb445-33"><a href="#cb445-33" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> e_test2 = Expr.eval [<span class="st">&quot;x&quot;</span>, `Num <span class="dv">2</span>] test2</span>
<span id="cb445-34"><a href="#cb445-34" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fvs_test2 = Expr.freevars test2</span></code></pre></div>
<p>Merging the sub-languages:</p>
<div class="sourceCode" id="cb446"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb446-1"><a href="#cb446-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a lexpr = [&#39;a lambda | &#39;a expr]</span>
<span id="cb446-2"><a href="#cb446-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb446-3"><a href="#cb446-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> LEF(X : Operations <span class="kw">with</span> <span class="kw">type</span> <span class="dt">exp</span> = <span class="kw">private</span> [&gt; &#39;a lexpr] <span class="kw">as</span> &#39;a) =</span>
<span id="cb446-4"><a href="#cb446-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span></span>
<span id="cb446-5"><a href="#cb446-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">exp</span> = X.<span class="dt">exp</span> lexpr</span>
<span id="cb446-6"><a href="#cb446-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">module</span> LambdaX = LF(X)</span>
<span id="cb446-7"><a href="#cb446-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">module</span> LambdaFVX = LFVF(X)</span>
<span id="cb446-8"><a href="#cb446-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">module</span> ExprX = EF(X)</span>
<span id="cb446-9"><a href="#cb446-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb446-10"><a href="#cb446-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> eval subst : <span class="dt">exp</span> -&gt; X.<span class="dt">exp</span> = <span class="kw">function</span></span>
<span id="cb446-11"><a href="#cb446-11" aria-hidden="true" tabindex="-1"></a>    | #LambdaX.<span class="dt">exp</span> <span class="kw">as</span> x -&gt; LambdaX.eval subst x</span>
<span id="cb446-12"><a href="#cb446-12" aria-hidden="true" tabindex="-1"></a>    | #ExprX.<span class="dt">exp</span> <span class="kw">as</span> x -&gt; ExprX.eval subst x</span>
<span id="cb446-13"><a href="#cb446-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb446-14"><a href="#cb446-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> freevars : <span class="dt">exp</span> -&gt; &#39;b = <span class="kw">function</span></span>
<span id="cb446-15"><a href="#cb446-15" aria-hidden="true" tabindex="-1"></a>    | #lambda <span class="kw">as</span> x -&gt; LambdaFVX.freevars x  <span class="co">(* Either of #lambda or #LambdaX.exp ok *)</span></span>
<span id="cb446-16"><a href="#cb446-16" aria-hidden="true" tabindex="-1"></a>    | #expr <span class="kw">as</span> x -&gt; ExprX.freevars x  <span class="co">(* Either of #expr or #ExprX.exp is fine *)</span></span>
<span id="cb446-17"><a href="#cb446-17" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb446-18"><a href="#cb446-18" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">rec</span> LExpr : (Operations <span class="kw">with</span> <span class="kw">type</span> <span class="dt">exp</span> = LExpr.<span class="dt">exp</span> lexpr) =</span>
<span id="cb446-19"><a href="#cb446-19" aria-hidden="true" tabindex="-1"></a>  LEF(LExpr)</span>
<span id="cb446-20"><a href="#cb446-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb446-21"><a href="#cb446-21" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> test3 =</span>
<span id="cb446-22"><a href="#cb446-22" aria-hidden="true" tabindex="-1"></a>  (`App (`Abs (<span class="st">&quot;x&quot;</span>, `Add (`Mult (`Num <span class="dv">3</span>, `Var <span class="st">&quot;x&quot;</span>), `Num <span class="dv">1</span>)),</span>
<span id="cb446-23"><a href="#cb446-23" aria-hidden="true" tabindex="-1"></a>         `Num <span class="dv">2</span>) : LExpr.<span class="dt">exp</span>)</span>
<span id="cb446-24"><a href="#cb446-24" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> e_test3 = LExpr.eval [] test3</span>
<span id="cb446-25"><a href="#cb446-25" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fv_test3 = LExpr.freevars test3</span>
<span id="cb446-26"><a href="#cb446-26" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> e_old_test = LExpr.eval [] (test2 :&gt; LExpr.<span class="dt">exp</span>)</span>
<span id="cb446-27"><a href="#cb446-27" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fv_old_test = LExpr.freevars (test2 :&gt; LExpr.<span class="dt">exp</span>)</span></code></pre></div>
<h2 id="parser-combinators">11.9 Parser Combinators</h2>
<p>We now turn to an application that demonstrates the extensibility
concepts we have been discussing. Large-scale parsing in OCaml is
typically done using external languages like OCamlLex and Menhir, which
generate efficient parsers from grammar specifications. But it is often
convenient to have parsers written directly in OCaml, especially for
smaller grammars or when we want to extend the parser dynamically.</p>
<p>Language <strong>combinators</strong> are ways of defining languages
by composing definitions of smaller languages. This is exactly the kind
of compositional, extensible design we have been exploring with the
expression problem. For example, the combinators of the <strong>Extended
Backus-Naur Form</strong> notation are:</p>
<ul>
<li><strong>Concatenation</strong>: <span class="math inline">S = A,
B</span> stands for <span class="math inline">S = \{ ab \mid a \in A, b
\in B \}</span></li>
<li><strong>Alternation</strong>: <span class="math inline">S = A \mid
B</span> stands for <span class="math inline">S = \{ a \mid a \in A \vee
a \in B \}</span></li>
<li><strong>Option</strong>: <span class="math inline">S = [A]</span>
stands for <span class="math inline">S = \{ \epsilon \} \cup A</span>,
where <span class="math inline">\epsilon</span> is an empty string</li>
<li><strong>Repetition</strong>: <span class="math inline">S = \{ A
\}</span> stands for <span class="math inline">S = \{ \epsilon \} \cup
\{ as \mid a \in A, s \in S \}</span></li>
<li><strong>Terminal string</strong>: <span class="math inline">S =
&quot;a&quot;</span> stands for <span class="math inline">S = \{ a
\}</span></li>
</ul>
<p>Parsers implemented directly in a functional programming paradigm are
functions from character streams to the parsed values. Algorithmically
they are <strong>recursive descent parsers</strong>.</p>
<p><strong>Parser combinators</strong> approach builds parsers as
<strong>monad plus</strong> values:</p>
<ul>
<li><strong>Bind</strong>:
<code>val (&gt;&gt;=) : 'a parser -&gt; ('a -&gt; 'b parser) -&gt; 'b parser</code>
<ul>
<li><code>p &gt;&gt;= f</code> is a parser that first parses
<code>p</code>, and makes the result available for parsing
<code>f</code></li>
</ul></li>
<li><strong>Return</strong>:
<code>val return : 'a -&gt; 'a parser</code>
<ul>
<li><code>return x</code> parses an empty string, symbolically <span
class="math inline">S = \{ \epsilon \}</span>, and returns
<code>x</code></li>
</ul></li>
<li><strong>MZero</strong>: <code>val fail : 'a parser</code>
<ul>
<li><code>fail</code> fails to parse anything, symbolically <span
class="math inline">S = \varnothing = \{ \}</span></li>
</ul></li>
<li><strong>MPlus</strong>:
<code>val (&lt;|&gt;) : 'a parser -&gt; 'a parser -&gt; 'a parser</code>
<ul>
<li><code>p &lt;|&gt; q</code> tries <code>p</code>, and if
<code>p</code> succeeds, its result is returned, otherwise the parser
<code>q</code> is used</li>
</ul></li>
</ul>
<p>The only non-monad-plus operation that has to be built into the monad
is some way to consume a single character from the input stream, for
example:</p>
<ul>
<li><code>val satisfy : (char -&gt; bool) -&gt; char parser</code>
<ul>
<li><code>satisfy (fun c -&gt; c = 'a')</code> consumes the character
“a” from the input stream and returns it; if the input stream starts
with a different character, this parser fails</li>
</ul></li>
</ul>
<p>Ordinary monadic recursive descent parsers <strong>do not
allow</strong> <em>left-recursion</em>: if a cycle of calls not
consuming any character can be entered when a parse failure should
occur, the cycle will keep repeating indefinitely.</p>
<p>For example, if we define numbers <span class="math inline">N := D
\mid N D</span>, where <span class="math inline">D</span> stands for
digits, then a stack of uses of the rule <span class="math inline">N
\rightarrow N D</span> will build up when the next character is not a
digit. The parser will try to match <span class="math inline">N</span>,
which requires matching <span class="math inline">N D</span>, which
requires matching <span class="math inline">N</span> again, leading to
infinite recursion.</p>
<p>On the other hand, rules can share common prefixes, and the
backtracking monad will handle trying alternatives correctly.</p>
<h2 id="parser-combinators-implementation">11.10 Parser Combinators:
Implementation</h2>
<p>The parser monad is actually a composition of two monads:</p>
<ul>
<li>The <strong>state monad</strong> for storing the stream of
characters that remain to be parsed (specifically, the current position
in the input string)</li>
<li>The <strong>backtracking monad</strong> for handling parse failures
and ambiguities (allowing us to try alternatives when one parse
fails)</li>
</ul>
<p>Alternatively, one can split the state monad into a reader monad with
the parsed string, and a state monad with the parsing position. This is
the approach we take here.</p>
<p>We experiment with a different approach to monad-plus:
<strong>lazy-monad-plus</strong>. The difference from regular monad-plus
is that the second argument to <code>mplus</code> is lazy:</p>
<pre><code>val mplus : &#39;a monad -&gt; &#39;a monad Lazy.t -&gt; &#39;a monad</code></pre>
<p>This laziness prevents the second alternative from being evaluated
until it is actually needed, which is important for avoiding infinite
recursion in some parsing scenarios.</p>
<h3 id="implementation-of-lazy-monad-plus">Implementation of
lazy-monad-plus</h3>
<p>First a brief reminder about monads with backtracking. Starting with
an operation from <code>MonadPlusOps</code>:</p>
<div class="sourceCode" id="cb448"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb448-1"><a href="#cb448-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> msum_map f l =</span>
<span id="cb448-2"><a href="#cb448-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">List</span>.fold_left  <span class="co">(* Folding left reverses the apparent order of composition *)</span></span>
<span id="cb448-3"><a href="#cb448-3" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">fun</span> acc a -&gt; mplus acc (<span class="kw">lazy</span> (f a))) mzero l  <span class="co">(* order from l is preserved *)</span></span></code></pre></div>
<p>The implementation of the lazy-monad-plus using lazy lists:</p>
<div class="sourceCode" id="cb449"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb449-1"><a href="#cb449-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a llist = LNil | LCons <span class="kw">of</span> &#39;a * &#39;a llist <span class="dt">Lazy</span>.t</span>
<span id="cb449-2"><a href="#cb449-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb449-3"><a href="#cb449-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> ltake n = <span class="kw">function</span></span>
<span id="cb449-4"><a href="#cb449-4" aria-hidden="true" tabindex="-1"></a>  | LCons (a, l) <span class="kw">when</span> n &gt; <span class="dv">1</span> -&gt; a::(ltake (n<span class="dv">-1</span>) (<span class="dt">Lazy</span>.force l))</span>
<span id="cb449-5"><a href="#cb449-5" aria-hidden="true" tabindex="-1"></a>  | LCons (a, l) <span class="kw">when</span> n = <span class="dv">1</span> -&gt; [a]  <span class="co">(* Avoid forcing the tail if not needed *)</span></span>
<span id="cb449-6"><a href="#cb449-6" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; []</span>
<span id="cb449-7"><a href="#cb449-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb449-8"><a href="#cb449-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> lappend l1 l2 =</span>
<span id="cb449-9"><a href="#cb449-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> l1 <span class="kw">with</span> LNil -&gt; <span class="dt">Lazy</span>.force l2</span>
<span id="cb449-10"><a href="#cb449-10" aria-hidden="true" tabindex="-1"></a>  | LCons (hd, tl) -&gt; LCons (hd, <span class="kw">lazy</span> (lappend (<span class="dt">Lazy</span>.force tl) l2))</span>
<span id="cb449-11"><a href="#cb449-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb449-12"><a href="#cb449-12" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> lconcat_map f = <span class="kw">function</span></span>
<span id="cb449-13"><a href="#cb449-13" aria-hidden="true" tabindex="-1"></a>  | LNil -&gt; LNil</span>
<span id="cb449-14"><a href="#cb449-14" aria-hidden="true" tabindex="-1"></a>  | LCons (a, l) -&gt; lappend (f a) (<span class="kw">lazy</span> (lconcat_map f (<span class="dt">Lazy</span>.force l)))</span>
<span id="cb449-15"><a href="#cb449-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb449-16"><a href="#cb449-16" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> LListM = MonadPlus (<span class="kw">struct</span></span>
<span id="cb449-17"><a href="#cb449-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a t = &#39;a llist</span>
<span id="cb449-18"><a href="#cb449-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> bind a b = lconcat_map b a</span>
<span id="cb449-19"><a href="#cb449-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> return a = LCons (a, <span class="kw">lazy</span> LNil)</span>
<span id="cb449-20"><a href="#cb449-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> mzero = LNil</span>
<span id="cb449-21"><a href="#cb449-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> mplus = lappend</span>
<span id="cb449-22"><a href="#cb449-22" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>)</span></code></pre></div>
<h3 id="the-parsec-monad">The Parsec Monad</h3>
<p>File <code>Parsec.ml</code>:</p>
<div class="sourceCode" id="cb450"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb450-1"><a href="#cb450-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">type</span> PARSE = <span class="kw">sig</span></span>
<span id="cb450-2"><a href="#cb450-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a backtracking_monad  <span class="co">(* Name for the underlying monad-plus *)</span></span>
<span id="cb450-3"><a href="#cb450-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a parsing_state = <span class="dt">int</span> -&gt; (&#39;a * <span class="dt">int</span>) backtracking_monad  <span class="co">(* State: position *)</span></span>
<span id="cb450-4"><a href="#cb450-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a t = <span class="dt">string</span> -&gt; &#39;a parsing_state  <span class="co">(* Reader for the parsed text *)</span></span>
<span id="cb450-5"><a href="#cb450-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> MONAD_PLUS_OPS</span>
<span id="cb450-6"><a href="#cb450-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> (&lt;|&gt;) : &#39;a monad -&gt; &#39;a monad <span class="dt">Lazy</span>.t -&gt; &#39;a monad  <span class="co">(* A synonym for mplus *)</span></span>
<span id="cb450-7"><a href="#cb450-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> run : &#39;a monad -&gt; &#39;a t</span>
<span id="cb450-8"><a href="#cb450-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> runT : &#39;a monad -&gt; <span class="dt">string</span> -&gt; <span class="dt">int</span> -&gt; &#39;a backtracking_monad</span>
<span id="cb450-9"><a href="#cb450-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> satisfy : (<span class="dt">char</span> -&gt; <span class="dt">bool</span>) -&gt; <span class="dt">char</span> monad  <span class="co">(* Consume a character of the class *)</span></span>
<span id="cb450-10"><a href="#cb450-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> end_of_text : <span class="dt">unit</span> monad  <span class="co">(* Check for end of the processed text *)</span></span>
<span id="cb450-11"><a href="#cb450-11" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb450-12"><a href="#cb450-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb450-13"><a href="#cb450-13" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> ParseT (MP : MONAD_PLUS_OPS) :</span>
<span id="cb450-14"><a href="#cb450-14" aria-hidden="true" tabindex="-1"></a>  PARSE <span class="kw">with</span> <span class="kw">type</span> &#39;a backtracking_monad := &#39;a MP.monad =</span>
<span id="cb450-15"><a href="#cb450-15" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span></span>
<span id="cb450-16"><a href="#cb450-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a backtracking_monad = &#39;a MP.monad</span>
<span id="cb450-17"><a href="#cb450-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> &#39;a parsing_state = <span class="dt">int</span> -&gt; (&#39;a * <span class="dt">int</span>) MP.monad</span>
<span id="cb450-18"><a href="#cb450-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">module</span> M = <span class="kw">struct</span></span>
<span id="cb450-19"><a href="#cb450-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> &#39;a t = <span class="dt">string</span> -&gt; &#39;a parsing_state</span>
<span id="cb450-20"><a href="#cb450-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> return a = <span class="kw">fun</span> s p -&gt; MP.return (a, p)</span>
<span id="cb450-21"><a href="#cb450-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> bind m b = <span class="kw">fun</span> s p -&gt;</span>
<span id="cb450-22"><a href="#cb450-22" aria-hidden="true" tabindex="-1"></a>      MP.bind (m s p) (<span class="kw">fun</span> (a, p&#39;) -&gt; b a s p&#39;)</span>
<span id="cb450-23"><a href="#cb450-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> mzero = <span class="kw">fun</span> _ p -&gt; MP.mzero</span>
<span id="cb450-24"><a href="#cb450-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> mplus ma mb = <span class="kw">fun</span> s p -&gt;</span>
<span id="cb450-25"><a href="#cb450-25" aria-hidden="true" tabindex="-1"></a>      MP.mplus (ma s p) (<span class="kw">lazy</span> (<span class="dt">Lazy</span>.force mb s p))</span>
<span id="cb450-26"><a href="#cb450-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end</span></span>
<span id="cb450-27"><a href="#cb450-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> M</span>
<span id="cb450-28"><a href="#cb450-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> MonadPlusOps(M)</span>
<span id="cb450-29"><a href="#cb450-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (&lt;|&gt;) ma mb = mplus ma mb</span>
<span id="cb450-30"><a href="#cb450-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> runT m s p = MP.lift <span class="dt">fst</span> (m s p)</span>
<span id="cb450-31"><a href="#cb450-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> satisfy f s p =</span>
<span id="cb450-32"><a href="#cb450-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> p &lt; <span class="dt">String</span>.length s &amp;&amp; f s.[p]  <span class="co">(* Consuming a character means accessing it *)</span></span>
<span id="cb450-33"><a href="#cb450-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> MP.return (s.[p], p + <span class="dv">1</span>) <span class="kw">else</span> MP.mzero  <span class="co">(* and advancing the parsing pos *)</span></span>
<span id="cb450-34"><a href="#cb450-34" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> end_of_text s p =</span>
<span id="cb450-35"><a href="#cb450-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> p &gt;= <span class="dt">String</span>.length s <span class="kw">then</span> MP.return ((), p) <span class="kw">else</span> MP.mzero</span>
<span id="cb450-36"><a href="#cb450-36" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<h3 id="additional-parser-operations">Additional Parser Operations</h3>
<div class="sourceCode" id="cb451"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb451-1"><a href="#cb451-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="kw">type</span> PARSE_OPS = <span class="kw">sig</span></span>
<span id="cb451-2"><a href="#cb451-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> PARSE</span>
<span id="cb451-3"><a href="#cb451-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> many : &#39;a monad -&gt; &#39;a <span class="dt">list</span> monad</span>
<span id="cb451-4"><a href="#cb451-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> opt : &#39;a monad -&gt; &#39;a <span class="dt">option</span> monad</span>
<span id="cb451-5"><a href="#cb451-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> (?|) : &#39;a monad -&gt; &#39;a <span class="dt">option</span> monad</span>
<span id="cb451-6"><a href="#cb451-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> seq : &#39;a monad -&gt; &#39;b monad <span class="dt">Lazy</span>.t -&gt; (&#39;a * &#39;b) monad  <span class="co">(* Exercise: why lazy? *)</span></span>
<span id="cb451-7"><a href="#cb451-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> (&lt;*&gt;) : &#39;a monad -&gt; &#39;b monad <span class="dt">Lazy</span>.t -&gt; (&#39;a * &#39;b) monad  <span class="co">(* Synonym for seq *)</span></span>
<span id="cb451-8"><a href="#cb451-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> lowercase : <span class="dt">char</span> monad</span>
<span id="cb451-9"><a href="#cb451-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> uppercase : <span class="dt">char</span> monad</span>
<span id="cb451-10"><a href="#cb451-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> digit : <span class="dt">char</span> monad</span>
<span id="cb451-11"><a href="#cb451-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> alpha : <span class="dt">char</span> monad</span>
<span id="cb451-12"><a href="#cb451-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> alphanum : <span class="dt">char</span> monad</span>
<span id="cb451-13"><a href="#cb451-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> literal : <span class="dt">string</span> -&gt; <span class="dt">unit</span> monad  <span class="co">(* Consume characters of the given string *)</span></span>
<span id="cb451-14"><a href="#cb451-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> (<span class="st">&lt;&lt;&gt;) : string -&gt; &#39;a monad -&gt; &#39;a monad  (* Prefix and postfix keywords *)</span></span>
<span id="cb451-15"><a href="#cb451-15" aria-hidden="true" tabindex="-1"></a><span class="st">  val (&lt;&gt;&gt;</span>) : &#39;a monad -&gt; <span class="dt">string</span> -&gt; &#39;a monad</span>
<span id="cb451-16"><a href="#cb451-16" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb451-17"><a href="#cb451-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb451-18"><a href="#cb451-18" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> ParseOps (R : MONAD_PLUS_OPS)</span>
<span id="cb451-19"><a href="#cb451-19" aria-hidden="true" tabindex="-1"></a>  (P : PARSE <span class="kw">with</span> <span class="kw">type</span> &#39;a backtracking_monad := &#39;a R.monad) :</span>
<span id="cb451-20"><a href="#cb451-20" aria-hidden="true" tabindex="-1"></a>  PARSE_OPS <span class="kw">with</span> <span class="kw">type</span> &#39;a backtracking_monad := &#39;a R.monad =</span>
<span id="cb451-21"><a href="#cb451-21" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span></span>
<span id="cb451-22"><a href="#cb451-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">include</span> P</span>
<span id="cb451-23"><a href="#cb451-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> many p =</span>
<span id="cb451-24"><a href="#cb451-24" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">let</span>* r = p <span class="kw">in</span></span>
<span id="cb451-25"><a href="#cb451-25" aria-hidden="true" tabindex="-1"></a>     <span class="kw">let</span>* rs = many p <span class="kw">in</span></span>
<span id="cb451-26"><a href="#cb451-26" aria-hidden="true" tabindex="-1"></a>     return (r::rs))</span>
<span id="cb451-27"><a href="#cb451-27" aria-hidden="true" tabindex="-1"></a>    ++ <span class="kw">lazy</span> (return [])</span>
<span id="cb451-28"><a href="#cb451-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> opt p = (<span class="kw">let</span>* x = p <span class="kw">in</span> return (<span class="dt">Some</span> x)) ++ <span class="kw">lazy</span> (return <span class="dt">None</span>)</span>
<span id="cb451-29"><a href="#cb451-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (?|) p = opt p</span>
<span id="cb451-30"><a href="#cb451-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> seq p q =</span>
<span id="cb451-31"><a href="#cb451-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* x = p <span class="kw">in</span></span>
<span id="cb451-32"><a href="#cb451-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* y = <span class="dt">Lazy</span>.force q <span class="kw">in</span></span>
<span id="cb451-33"><a href="#cb451-33" aria-hidden="true" tabindex="-1"></a>    return (x, y)</span>
<span id="cb451-34"><a href="#cb451-34" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (&lt;*&gt;) p q = seq p q</span>
<span id="cb451-35"><a href="#cb451-35" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> lowercase = satisfy (<span class="kw">fun</span> c -&gt; c &gt;= <span class="ch">&#39;a&#39;</span> &amp;&amp; c &lt;= <span class="ch">&#39;z&#39;</span>)</span>
<span id="cb451-36"><a href="#cb451-36" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> uppercase = satisfy (<span class="kw">fun</span> c -&gt; c &gt;= <span class="ch">&#39;A&#39;</span> &amp;&amp; c &lt;= <span class="ch">&#39;Z&#39;</span>)</span>
<span id="cb451-37"><a href="#cb451-37" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> digit = satisfy (<span class="kw">fun</span> c -&gt; c &gt;= <span class="ch">&#39;0&#39;</span> &amp;&amp; c &lt;= <span class="ch">&#39;9&#39;</span>)</span>
<span id="cb451-38"><a href="#cb451-38" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> alpha = lowercase ++ <span class="kw">lazy</span> uppercase</span>
<span id="cb451-39"><a href="#cb451-39" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> alphanum = alpha ++ <span class="kw">lazy</span> digit</span>
<span id="cb451-40"><a href="#cb451-40" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> literal l =</span>
<span id="cb451-41"><a href="#cb451-41" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">rec</span> loop pos =</span>
<span id="cb451-42"><a href="#cb451-42" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> pos = <span class="dt">String</span>.length l <span class="kw">then</span> return ()</span>
<span id="cb451-43"><a href="#cb451-43" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> satisfy (<span class="kw">fun</span> c -&gt; c = l.[pos]) &gt;&gt;- loop (pos + <span class="dv">1</span>) <span class="kw">in</span></span>
<span id="cb451-44"><a href="#cb451-44" aria-hidden="true" tabindex="-1"></a>    loop <span class="dv">0</span></span>
<span id="cb451-45"><a href="#cb451-45" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (<span class="st">&lt;&lt;&gt;) bra p = literal bra &gt;&gt;</span>- p</span>
<span id="cb451-46"><a href="#cb451-46" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (&lt;&gt;&gt;) p ket =</span>
<span id="cb451-47"><a href="#cb451-47" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span>* x = p <span class="kw">in</span></span>
<span id="cb451-48"><a href="#cb451-48" aria-hidden="true" tabindex="-1"></a>    literal ket &gt;&gt;- return x</span>
<span id="cb451-49"><a href="#cb451-49" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<h2 id="parser-combinators-tying-the-recursive-knot">11.11 Parser
Combinators: Tying the Recursive Knot</h2>
<p>Now we come to the key insight connecting parser combinators to the
expression problem: how do we allow the grammar to be extended
dynamically? The answer is to use a mutable reference holding a list of
grammar rules, and tie the recursive knot lazily.</p>
<p>File <code>PluginBase.ml</code>:</p>
<div class="sourceCode" id="cb452"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb452-1"><a href="#cb452-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> ParseM = ParseOps (LListM) (ParseT (LListM))</span>
<span id="cb452-2"><a href="#cb452-2" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> ParseM</span>
<span id="cb452-3"><a href="#cb452-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb452-4"><a href="#cb452-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> grammar_rules : (<span class="dt">int</span> monad -&gt; <span class="dt">int</span> monad) <span class="dt">list</span> <span class="dt">ref</span> = <span class="dt">ref</span> []</span>
<span id="cb452-5"><a href="#cb452-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb452-6"><a href="#cb452-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> get_language () : <span class="dt">int</span> monad =</span>
<span id="cb452-7"><a href="#cb452-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> <span class="dt">result</span> =</span>
<span id="cb452-8"><a href="#cb452-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">lazy</span></span>
<span id="cb452-9"><a href="#cb452-9" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">List</span>.fold_left</span>
<span id="cb452-10"><a href="#cb452-10" aria-hidden="true" tabindex="-1"></a>         (<span class="kw">fun</span> acc lang -&gt; acc &lt;|&gt; <span class="kw">lazy</span> (lang (<span class="dt">Lazy</span>.force <span class="dt">result</span>)))</span>
<span id="cb452-11"><a href="#cb452-11" aria-hidden="true" tabindex="-1"></a>          mzero !grammar_rules) <span class="kw">in</span></span>
<span id="cb452-12"><a href="#cb452-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span>* r = <span class="dt">Lazy</span>.force <span class="dt">result</span> <span class="kw">in</span></span>
<span id="cb452-13"><a href="#cb452-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span>* () = end_of_text <span class="kw">in</span> return r  <span class="co">(* Ensure we parse the whole text *)</span></span></code></pre></div>
<h2 id="parser-combinators-dynamic-code-loading">11.12 Parser
Combinators: Dynamic Code Loading</h2>
<p>OCaml supports dynamic code loading through the <code>Dynlink</code>
module. This allows us to load compiled modules at runtime, which can
register new grammar rules by mutating the <code>grammar_rules</code>
reference. This is a powerful form of extensibility: we can add new
syntax to our language without recompiling the main program.</p>
<p>File <code>PluginRun.ml</code>:</p>
<div class="sourceCode" id="cb453"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb453-1"><a href="#cb453-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> load_plug fname : <span class="dt">unit</span> =</span>
<span id="cb453-2"><a href="#cb453-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> fname = Dynlink.adapt_filename fname <span class="kw">in</span></span>
<span id="cb453-3"><a href="#cb453-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> <span class="dt">Sys</span>.file_exists fname <span class="kw">then</span></span>
<span id="cb453-4"><a href="#cb453-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> Dynlink.loadfile fname</span>
<span id="cb453-5"><a href="#cb453-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">with</span></span>
<span id="cb453-6"><a href="#cb453-6" aria-hidden="true" tabindex="-1"></a>    | (Dynlink.<span class="dt">Error</span> err) <span class="kw">as</span> e -&gt;</span>
<span id="cb453-7"><a href="#cb453-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Printf</span>.printf <span class="st">&quot;</span><span class="ch">\n</span><span class="st">ERROR loading plugin: %s</span><span class="ch">\n</span><span class="st">%!&quot;</span></span>
<span id="cb453-8"><a href="#cb453-8" aria-hidden="true" tabindex="-1"></a>        (Dynlink.error_message err);</span>
<span id="cb453-9"><a href="#cb453-9" aria-hidden="true" tabindex="-1"></a>      <span class="dt">raise</span> e</span>
<span id="cb453-10"><a href="#cb453-10" aria-hidden="true" tabindex="-1"></a>    | e -&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;</span><span class="ch">\n</span><span class="st">Unknow error while loading plugin</span><span class="ch">\n</span><span class="st">%!&quot;</span></span>
<span id="cb453-11"><a href="#cb453-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> (</span>
<span id="cb453-12"><a href="#cb453-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Printf</span>.printf <span class="st">&quot;</span><span class="ch">\n</span><span class="st">Plugin file %s does not exist</span><span class="ch">\n</span><span class="st">%!&quot;</span> fname;</span>
<span id="cb453-13"><a href="#cb453-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">exit</span> (<span class="dv">-1</span>))</span>
<span id="cb453-14"><a href="#cb453-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb453-15"><a href="#cb453-15" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () =</span>
<span id="cb453-16"><a href="#cb453-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">for</span> i = <span class="dv">2</span> <span class="kw">to</span> <span class="dt">Array</span>.length <span class="dt">Sys</span>.argv - <span class="dv">1</span> <span class="kw">do</span></span>
<span id="cb453-17"><a href="#cb453-17" aria-hidden="true" tabindex="-1"></a>    load_plug <span class="dt">Sys</span>.argv.(i) <span class="kw">done</span>;</span>
<span id="cb453-18"><a href="#cb453-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> lang = PluginBase.get_language () <span class="kw">in</span></span>
<span id="cb453-19"><a href="#cb453-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="dt">result</span> =</span>
<span id="cb453-20"><a href="#cb453-20" aria-hidden="true" tabindex="-1"></a>    Monad.LListM.run</span>
<span id="cb453-21"><a href="#cb453-21" aria-hidden="true" tabindex="-1"></a>      (PluginBase.ParseM.runT lang <span class="dt">Sys</span>.argv.(<span class="dv">1</span>) <span class="dv">0</span>) <span class="kw">in</span></span>
<span id="cb453-22"><a href="#cb453-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> Monad.ltake <span class="dv">1</span> <span class="dt">result</span> <span class="kw">with</span></span>
<span id="cb453-23"><a href="#cb453-23" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;</span><span class="ch">\n</span><span class="st">Parse error</span><span class="ch">\n</span><span class="st">%!&quot;</span></span>
<span id="cb453-24"><a href="#cb453-24" aria-hidden="true" tabindex="-1"></a>  | r::_ -&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;</span><span class="ch">\n</span><span class="st">Result: %d</span><span class="ch">\n</span><span class="st">%!&quot;</span> r</span></code></pre></div>
<h2 id="parser-combinators-toy-example">11.13 Parser Combinators: Toy
Example</h2>
<p>Let us see how this works with a concrete example. We will define two
plugins: one for parsing numbers and addition, and another for parsing
multiplication. Each plugin registers its grammar rules by appending to
the <code>grammar_rules</code> list.</p>
<p>File <code>Plugin1.ml</code>:</p>
<div class="sourceCode" id="cb454"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb454-1"><a href="#cb454-1" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> ParseM</span>
<span id="cb454-2"><a href="#cb454-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> digit_of_char d = <span class="dt">int_of_char</span> d - <span class="dt">int_of_char</span> <span class="ch">&#39;0&#39;</span></span>
<span id="cb454-3"><a href="#cb454-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb454-4"><a href="#cb454-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> number _ =  <span class="co">(* Numbers: N := D N | D where D is digits *)</span></span>
<span id="cb454-5"><a href="#cb454-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> num =  <span class="co">(* Note: we avoid left-recursion by having the digit first *)</span></span>
<span id="cb454-6"><a href="#cb454-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">lazy</span> ((<span class="kw">let</span>* d = digit <span class="kw">in</span></span>
<span id="cb454-7"><a href="#cb454-7" aria-hidden="true" tabindex="-1"></a>           <span class="kw">let</span>* (n, b) = <span class="dt">Lazy</span>.force num <span class="kw">in</span></span>
<span id="cb454-8"><a href="#cb454-8" aria-hidden="true" tabindex="-1"></a>           return (digit_of_char d * b + n, b * <span class="dv">10</span>))</span>
<span id="cb454-9"><a href="#cb454-9" aria-hidden="true" tabindex="-1"></a>      &lt;|&gt; <span class="kw">lazy</span> (<span class="kw">let</span>* d = digit <span class="kw">in</span> return (digit_of_char d, <span class="dv">10</span>))) <span class="kw">in</span></span>
<span id="cb454-10"><a href="#cb454-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Lazy</span>.force num &gt;&gt;| <span class="dt">fst</span></span>
<span id="cb454-11"><a href="#cb454-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb454-12"><a href="#cb454-12" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> addition lang =  <span class="co">(* Addition rule: S -&gt; (S + S) *)</span></span>
<span id="cb454-13"><a href="#cb454-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* Requiring a parenthesis &#39;(&#39; turns the rule into non-left-recursive *)</span></span>
<span id="cb454-14"><a href="#cb454-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* because we consume a character before recursing *)</span></span>
<span id="cb454-15"><a href="#cb454-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span>* () = literal <span class="st">&quot;(&quot;</span> <span class="kw">in</span></span>
<span id="cb454-16"><a href="#cb454-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span>* n1 = lang <span class="kw">in</span></span>
<span id="cb454-17"><a href="#cb454-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span>* () = literal <span class="st">&quot;+&quot;</span> <span class="kw">in</span></span>
<span id="cb454-18"><a href="#cb454-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span>* n2 = lang <span class="kw">in</span></span>
<span id="cb454-19"><a href="#cb454-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span>* () = literal <span class="st">&quot;)&quot;</span> <span class="kw">in</span></span>
<span id="cb454-20"><a href="#cb454-20" aria-hidden="true" tabindex="-1"></a>  return (n1 + n2)</span>
<span id="cb454-21"><a href="#cb454-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb454-22"><a href="#cb454-22" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () = grammar_rules := number :: addition :: !grammar_rules</span></code></pre></div>
<p>File <code>Plugin2.ml</code> adds multiplication to the language.
Notice how we can add this functionality without modifying any existing
code:</p>
<div class="sourceCode" id="cb455"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb455-1"><a href="#cb455-1" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> ParseM</span>
<span id="cb455-2"><a href="#cb455-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb455-3"><a href="#cb455-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> multiplication lang =  <span class="co">(* Multiplication rule: S -&gt; (S * S) *)</span></span>
<span id="cb455-4"><a href="#cb455-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span>* () = literal <span class="st">&quot;(&quot;</span> <span class="kw">in</span></span>
<span id="cb455-5"><a href="#cb455-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span>* n1 = lang <span class="kw">in</span></span>
<span id="cb455-6"><a href="#cb455-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span>* () = literal <span class="st">&quot;*&quot;</span> <span class="kw">in</span></span>
<span id="cb455-7"><a href="#cb455-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span>* n2 = lang <span class="kw">in</span></span>
<span id="cb455-8"><a href="#cb455-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span>* () = literal <span class="st">&quot;)&quot;</span> <span class="kw">in</span></span>
<span id="cb455-9"><a href="#cb455-9" aria-hidden="true" tabindex="-1"></a>  return (n1 * n2)</span>
<span id="cb455-10"><a href="#cb455-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb455-11"><a href="#cb455-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () = grammar_rules := multiplication :: !grammar_rules</span></code></pre></div>
<h3 id="chapter-summary-what-to-remember">Chapter Summary (What to
Remember)</h3>
<ul>
<li>The expression problem asks for <em>two independent dimensions of
extension</em>: add new cases (data) and add new operations, while
keeping separate compilation and static typing.</li>
<li>Ordinary ADTs make new operations easy and new cases hard; OO makes
new cases easy and new operations hard; extensible variants make new
cases easy but weaken exhaustiveness guarantees.</li>
<li>Polymorphic variants (especially with recursive modules) support a
pragmatic “structural” style of extension: you can grow a language in
separate files with less tagging boilerplate, at the cost of more
sophisticated typing.</li>
<li>Parser combinators are a capstone example because they <em>are</em>
a language combinator library: you extend the language by adding new
combinators/rules, and dynamic loading makes the modularity aspect very
concrete.</li>
</ul>
<h2 id="exercises-10">11.14 Exercises</h2>
<p>The following exercises will help you deepen your understanding of
the expression problem and the various solutions we have explored. They
range from implementing additional operations to refactoring the code
for better organization.</p>
<p><strong>Exercise 1:</strong> Implement the <code>string_of_</code>
functions or methods, covering all data cases, corresponding to the
<code>eval_</code> functions in at least two examples from the lecture,
including both an object-based example and a variant-based example
(either standard, or polymorphic, or extensible variants). This will
help you understand how functional extensibility works in each
approach.</p>
<p><strong>Exercise 2:</strong> Split at least one of the examples from
the previous exercise into multiple files and demonstrate separate
compilation.</p>
<p><strong>Exercise 3:</strong> Can we drop the tags
<code>Lambda_t</code>, <code>Expr_t</code> and <code>LExpr_t</code> used
in the examples based on standard variants (file
<code>FP_ADT.ml</code>)? When using polymorphic variants, such tags are
not needed.</p>
<p><strong>Exercise 4:</strong> Factor-out the sub-language consisting
only of variables, thus eliminating the duplication of tags
<code>VarL</code>, <code>VarE</code> in the examples based on standard
variants (file <code>FP_ADT.ml</code>).</p>
<p><strong>Exercise 5:</strong> Come up with a scenario where the
extensible variant types-based solution leads to a non-obvious or hard
to locate bug. This exercise illustrates why exhaustivity checking is so
valuable for static type safety.</p>
<p><strong>Exercise 6:</strong> Re-implement the direct object-based
solution to the expression problem (file <code>Objects.ml</code>) to
make it more satisfying. For example, eliminate the need for some of the
<code>rename</code>, <code>apply</code>, <code>compute</code>
methods.</p>
<p><strong>Exercise 7:</strong> Re-implement the visitor pattern-based
solution to the expression problem (file <code>Visitor.ml</code>) in a
functional way, i.e., replace the mutable fields <code>subst</code> and
<code>beta_redex</code> in the <code>eval_lambda</code> class with a
different solution to the problem of treating <code>abs</code> and
non-<code>abs</code> expressions differently.</p>
<p><strong>Exercise 8:</strong> Extend the sub-language
<code>expr_visit</code> with variables, and add to arguments of the
evaluation constructor <code>eval_expr</code> the substitution. Handle
the problem of potentially duplicate fields <code>subst</code>. (One
approach might be to use ideas from exercise 6.)</p>
<p><strong>Exercise 9:</strong> Implement the following modifications to
the example from the file <code>PolyV.ml</code>:</p>
<ol type="1">
<li>Factor-out the sub-language of variables, around the already present
<code>var</code> type.</li>
<li>Open the types of functions <code>eval3</code>,
<code>freevars3</code> and other functions as required, so that explicit
subtyping, e.g., in <code>eval3 [] (test2 :&gt; lexpr_t)</code>, is not
necessary.</li>
<li>Remove the double-dispatch currently in <code>eval_lexpr</code> and
<code>freevars_lexpr</code>, by implementing a cascading design rather
than a “divide-and-conquer” design.</li>
</ol>
<p><strong>Exercise 10:</strong> Streamline the solution
<code>PolyRecM.ml</code> by extending the language of <span
class="math inline">\lambda</span>-expressions with arithmetic
expressions, rather than defining the sub-languages separately and then
merging them. See slide on page 15 of Jacques Garrigue <em>Structural
Types, Recursive Modules, and the Expression Problem</em>.</p>
<p><strong>Exercise 11:</strong> Transform a parser monad, or rewrite
the parser monad transformer, by adding state for the line and column
numbers.</p>
<p><strong>Exercise 12:</strong> Implement <code>_of_string</code>
functions as parser combinators on top of the example
<code>PolyRecM.ml</code>. Sections 4.3 and 6.2 of <em>Monadic Parser
Combinators</em> by Graham Hutton and Erik Meijer might be helpful.
Split the result into multiple files as in Exercise 2 and demonstrate
dynamic loading of code.</p>
<p><strong>Exercise 13:</strong> What are the benefits and drawbacks of
our lazy-monad-plus (built on top of <em>odd lazy lists</em>) approach,
as compared to regular monad-plus built on top of <em>even lazy
lists</em>? To additionally illustrate your answer:</p>
<ol type="1">
<li>Rewrite the parser combinators example to use regular monad-plus and
even lazy lists.</li>
<li>Select one example from Lecture 8 and rewrite it using
lazy-monad-plus and odd lazy lists.</li>
</ol>
<p>(In an “odd” lazy list, the first element is strict and only the tail
is lazy. In an “even” lazy list, the entire list is wrapped in laziness.
The choice affects when computation happens and how infinite structures
are handled.)</p>
</body>
</html>
